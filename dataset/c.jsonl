{"target":"0712023","func":"#include <Adafruit_NeoPixel.h>  \nint RGB_PIN = 3;  \nint NUMPIXELS = 8;  \nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, RGB_PIN, NEO_GRB + NEO_KHZ800);\n\n#include <DHT.h> \nint DHT_PIN = 5;  \nDHT dht(DHT_PIN, DHT11);\n\nint TOUCH_PIN = 4;  \nint TRIG_PIN = 10;  \nint ECHO_PIN = 12;  \nint CDS_PIN = A0;  \nint POTEN_PIN = A5;  \nint r, g, b, R, G, B, Mode, touch_count;  \nint Mode_EA = 5;  \nint temp_1 = 23, temp_2 = 26;  \nint cds_1 = 530, cds_2 = 1000;  \nint dis_1 = 100, dis_2 = 300, dis_3 = 500;  \nboolean touch = true, cds_RGB = true;  \ndouble cds_cur, cds_pre = cds_1;\n\nvoid setup() {\n  pinMode(TRIG_PIN, OUTPUT);  \n  pinMode(ECHO_PIN, INPUT);  \n  pixels.begin();  \n  pixels.show();  \n}\n\n\nvoid loop() {\n  Mode_set();  \n  int poten = analogRead(POTEN_PIN);  \n\n  if ( Mode == 0 || Mode == 1 || Mode == 2 ) {  \n    for ( int i = 0; i < NUMPIXELS; i++ ) { \n      pixels.setPixelColor(i, pixels.Color( map(poten, 0, 1023, 0, r) , map(poten, 0, 1023, 0, g) , map(poten, 0, 1023, 0, b) ) );  \n      pixels.show(); \n    }\n  }\n\n  \n  if ( digitalRead(TOUCH_PIN) == 1 ) {  \n    touch_count++;  \n    delay(10);  \n\n    if ( touch_count >= 100 ) {  \n      if ( r == 0 && g == 0 && b == 0 ) {  \n        r = 1;\n      }\n\n      else if ( r != 0 || g != 0 || b != 0 ) {  \n        r = 0;\n        g = 0;\n        b = 0;\n        Mode = 0;\n      }\n\n      touch_count = 0;  \n    }\n\n    else if ( touch && ( r != 0 || g != 0 || b != 0 ) ) {  \n      Mode++;\n\n      if ( Mode > Mode_EA ) {\n        cds_RGB = true;\n        Mode = 1;\n      }\n\n      touch = false;\n    } else;                                                   \n  }\n\n  else {\n    touch = true;\n    touch_count = 0 ;\n  }\n  \n}\n\n\nvoid Mode_set() {\n  if ( Mode == 1) {\n    r = 210;\n    g = 100;\n    b = 10;\n  }\n\n  else if ( Mode == 2 ) {\n    temp_set();\n  }\n\n  else if ( Mode == 3 ) {\n    cds_set();\n  }\n\n  else if ( Mode == 4 ) {\n    ultra_set();\n  }\n\n  else if ( Mode == 5 ) {\n    temp_set();\n    cds_set();\n  }\n}\n\n\n\nvoid temp_set() {\n  int celsius = dht.readTemperature();  \n\n  if ( celsius < temp_1 ) {  \n    r = 0;  \n    g = 0;  \n    b = 255;  \n  }\n\n  else if ( temp_1 <= celsius && celsius < temp_2 ) {  \n    r = 0;\n    g = 255;\n    b = 0;\n  }\n\n  else if ( celsius >= temp_2 ) {  \n    r = 255;\n    g = 0;\n    b = 0;\n  }\n}\n\n\n\nvoid cds_set() {\n\n  if ( cds_RGB ) {\n    r = random(255);\n    g = random(255);\n    b = random(255);\n    cds_RGB = false;\n  }\n\n  int cds = analogRead(CDS_PIN);\n  cds_cur = (0.99 * cds_pre) + (0.01 * cds);\n  cds_pre = cds_cur;\n  cds = cds_cur;\n\n  if ( cds <= cds_1 )\n    cds = cds_1;\n\n  else if ( cds_2 < cds )\n    cds = cds_2;\n\n  for (int i = 0; i < NUMPIXELS; i++) {\n    pixels.setPixelColor(i, pixels.Color( map(cds, cds_1, cds_2, 0 , r) , map(cds, cds_1, cds_2, 0 , g) , map(cds, cds_1, cds_2, 0 , b) ) );\n    pixels.show();\n  }\n}\n\n\n\nvoid ultra_set() {\n  static long dis_pre;\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  long duration = pulseIn(ECHO_PIN, HIGH);\n  long distance = ((float)(340 * duration) \/ 1000) \/ 2 ;\n  delay(50);\n\n  if ( distance > 2000 )\n    distance = dis_pre;\n\n  if ( distance < dis_1 )\n    distance = dis_1;\n\n  else if ( distance > dis_3 )\n    distance = dis_3;\n\n  dis_pre = distance;\n\n  if ( dis_1 <= distance && distance <= dis_2 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 255 - map(distance, dis_1, dis_2, 0, 255) , map(distance, dis_1, dis_2, 0, 255) , 0) );\n      pixels.show();\n    }\n  }\n  else if ( dis_2 <= distance && distance <= dis_3 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 0 , 255 - map(distance, dis_2, dis_3, 0, 255) , map(distance, dis_2, dis_3, 0, 255) ) );\n      pixels.show();\n    }\n  }\n}\n"}
{"target":"0712023","func":"#include <MsTimer2.h>\n#include <SoftwareSerial.h>\nSoftwareSerial BT(8, 7);\n\n#include <Adafruit_NeoPixel.h>  \nint RGB_PIN = 3;  \nint NUMPIXELS = 8;  \nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, RGB_PIN, NEO_GRB + NEO_KHZ800);\n\n#include <DHT.h> \nint DHT_PIN = 5;  \nDHT dht(DHT_PIN, DHT11);\n\nint TRIG_PIN = 10;  \nint ECHO_PIN = 12;  \nint CDS_PIN = A0;  \nint temp_1 = 23, temp_2 = 26;  \nint cds_1 = 530, cds_2 = 950;  \nint dis_1 = 100, dis_2 = 300, dis_3 = 500;  \nint r, g, b, celsius; \ndouble cds_cur, cds_pre = cds_1;\nboolean DEBUG = true, RGB_Completed = false;\nint rainbow[6][3] = {\n  {255, 0, 0},     \n  {255, 50, 0},    \n  {255, 150, 0},   \n  {0, 255, 0},     \n  {0, 0, 255},     \n  {100, 0, 200},   \n};  \nString RGB = \"\";\n\n\nvoid setup() {\n  pinMode(TRIG_PIN, OUTPUT);  \n  pinMode(ECHO_PIN, INPUT);  \n  pixels.begin();  \n  pixels.show();  \n  BT.begin(9600);\n  RGB.reserve(30);\n}\n\n\nvoid loop() {\n  while (BT.available()) {\n    char ReadChar = (char)BT.read();\n\n    if (ReadChar == ')')\n      RGB_Completed = true;\n    else\n      RGB += ReadChar;\n  }\n\n  if (RGB_Completed) {\n    DEBUG = true;\n    MsTimer2::stop();\n\n    if (RGB == \"CH1_5\") {\n      MsTimer2::set(200, random_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH1_6\") {\n      MsTimer2::set(50, rain_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_2\") {\n      DEBUG = false;\n      MsTimer2::set(1000, temp_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_3\") {\n      r = random(255);\n      g = random(255);\n      b = random(255);\n      MsTimer2::set(60, cds_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_4\") {\n      MsTimer2::set(90, ultra_set);\n      MsTimer2::start();\n    }\n    else rgb_set();\n\n    RGB = \"\";\n    RGB_Completed = false;\n  }\n\n  if ( !DEBUG )\n    celsius = dht.readTemperature();  \n}\n\n\n\nvoid rgb_set() {\n  int SP1 = RGB.indexOf(' ');\n  int SP2 = RGB.indexOf(' ', SP1 + 1);\n  int SP3 = RGB.indexOf(' ', SP2 + 1);\n  int SP4 = RGB.indexOf(' ', SP3 + 1);\n  String Red = RGB.substring(0, SP1);\n  String Green = RGB.substring(SP1 + 1, SP2);\n  String Blue = RGB.substring(SP2 + 1, SP3);\n  String Bright = RGB.substring(SP3 + 1, SP4);\n\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( map(Bright.toInt(), 0, 255, 0, Red.toInt()), map(Bright.toInt(), 0, 255, 0, Green.toInt()), map(Bright.toInt(), 0, 255, 0, Blue.toInt()) ) ); \n    pixels.show(); \n  }\n}\n\n\n\nvoid random_set() {\n  r = random(255);\n  g = random(255);\n  b = random(255);\n\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( r, g, b ) );  \n    pixels.show(); \n  }\n}\n\n\n\nvoid rain_set() {\n  static int rainbow_count;\n  static int rain;\n\n  if ( DEBUG ) {\n    rainbow_count += 2;\n    if ( rainbow_count >= 100 ) {\n      rainbow_count = 100;\n      DEBUG = false;\n    }\n  }\n  else if ( !DEBUG ) {\n    rainbow_count -= 1;\n    if ( rainbow_count == 0 ) {\n      DEBUG = true;\n      rain++;\n      if ( rain == 6)\n        rain = 0;\n    }\n  }\n\n  for ( int i = 0; i < 8; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( map(rainbow_count, 0, 100, 0, rainbow[rain][0]) , map(rainbow_count, 0, 100, 0, rainbow[rain][1]) , map(rainbow_count, 0, 100, 0, rainbow[rain][2]) ) );  \n    pixels.show(); \n  }\n\n}\n\n\n\nvoid temp_set() {\n\n  if ( celsius < temp_1 ) {  \n    r = 0;  \n    g = 0;  \n    b = 255;  \n  }\n  else if ( temp_1 <= celsius && celsius < temp_2 ) {  \n    r = 0;\n    g = 255;\n    b = 0;\n  }\n  else if ( celsius >= temp_2 ) {  \n    r = 255;\n    g = 0;\n    b = 0;\n  }\n\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( r, g, b ) );  \n    pixels.show(); \n  }\n}\n\n\n\nvoid cds_set() {\n  int cds = analogRead(CDS_PIN);\n  cds_cur = (0.99 * cds_pre) + (0.01 * cds);\n  cds_pre = cds_cur;\n  cds = cds_cur;\n\n  if ( cds <= cds_1 )\n    cds = cds_1;\n\n  else if ( cds_2 < cds )\n    cds = cds_2;\n\n  for (int i = 0; i < NUMPIXELS; i++) {\n    pixels.setPixelColor(i, pixels.Color( map(cds, cds_1, cds_2, 0 , r) , map(cds, cds_1, cds_2, 0 , g) , map(cds, cds_1, cds_2, 0 , b) ) );\n    pixels.show();\n  }\n}\n\n\n\nvoid ultra_set() {\n  static long dis_pre;\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  long duration = pulseIn(ECHO_PIN, HIGH);\n  long distance = ((float)(340 * duration) \/ 1000) \/ 2 ;\n\n  if ( distance > 2000 )\n    distance = dis_pre;\n\n  if ( distance < dis_1 )\n    distance = dis_1;\n\n  else if ( distance > dis_3 )\n    distance = dis_3;\n\n  dis_pre = distance;\n\n  if ( dis_1 <= distance && distance <= dis_2 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 255 - map(distance, dis_1, dis_2, 0, 255) , map(distance, dis_1, dis_2, 0, 255) , 0) );\n      pixels.show();\n    }\n  }\n  else if ( dis_2 <= distance && distance <= dis_3 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 0 , 255 - map(distance, dis_2, dis_3, 0, 255) , map(distance, dis_2, dis_3, 0, 255) ) );\n      pixels.show();\n    }\n  }\n}\n"}
{"target":"0712023","func":"{\n    int len1 = 0;\n  int len2 = 0;\n  char tmp1[100] = \"\";\n  char tmp2[100] = \"\";\n  scanf(\"%d\", &len1);\n  scanf(\"%s\", tmp1);\n  scanf(\"%d\", &len2);\n  scanf(\"%s\", tmp2);\n  strcat(tmp1, tmp2);\n  char *str = (char*) calloc(len1+len2+1, sizeof(char));\n  str = tmp1;\n  puts(str);\n    char str1[100] = \"\";\n    char str2[100] = \"\";\n    for (int i = 0 ; i< len1; i++){\n        str1[i] = str[i];\n    }\n    for (int i = 0 ; i< len2; i++){\n        str2[i] = str[i+len1];\n    }\n    int cnt = 0;\n  int *pnt = &cnt;\n  for(int i = 0 ; i< len2; i++){\n    for(int j = 0 ; j < len1; j++){\n      if(str2[i] == str1[j]){\n        str1[j] =254;\n        *pnt +=1;\n                break;\n      }\n    }\n  }\n  if(*pnt != len2){\n    printf(\"not subset\\n\");\n  } else {\n    printf(\"subset\\n\");\n  }\n}\n"}
{"target":"0712023","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid main() {\n    char input[512] = \"3 * x ^ 1 + 5 * x ^ 1 + 12 * x ^ 13 + 1 * x ^ 0 + 4 * x ^ 2 + 7 * x ^ 2\";\n  strcat(input,\" +\");\n  int coeff[40]= {};\n  int *pc;\n  pc = coeff;\n  int indice[40]={};\n  int *pi;\n  pi = indice;\n  int cnt_c = 0;\n  int *pnt_c;\n  pnt_c = &cnt_c;\n  int cnt_i = 0;\n  int *pnt_i;\n  pnt_i = &cnt_i;\n  int plus =0;\n  int *pplus;\n  pplus = &plus;\n  int cnt = 0;\n    int *pnt = &cnt;\n  for(int i = 0; i<512; i++){\n    if(input[i] == '+'){\n      *pplus+=1;\n    }\n    if(input[i+1]==' ' && input[i+2] == '*'){\n      if(input[i-1]>47 && input[i-1] < 58){\n        *(pc+*pnt_c) = (input[i-1]-48)*10+input[i]-48;\n      } else{\n        *(pc+*pnt_c) = input[i]-48;\n      }\n            *pnt_c+=1;\n    }\n\n    if(input[i+1]==' ' && input[i+2] == '+'){\n      if(input[i-1]>47 && input[i-1] < 58){\n        *(pi+*pnt_i) = (input[i-1]-48)*10+input[i]-48;\n      } else {\n        *(pi+*pnt_i) = input[i]-48;\n      }\n      *pnt_i+=1;\n    }\n  }\n  for(int i = 0; i<*pplus; i++){\n    for(int j = 0;j<*pplus-1;j++){\n      if(indice[j]<indice[j+1]){\n        char tmp1;\n        tmp1 = indice[j];\n        indice[j] = indice[j+1];\n        indice[j+1] = tmp1;\n        char tmp2;\n        tmp2 = coeff[j];\n        coeff[j] = coeff[j+1];\n        coeff[j+1] = tmp2;\n      }\n    }\n  }\n\n  for(int k = 0; k<*pplus;k++){\n        for(int i = 0; i< *pplus-1; i++){\n            if(indice[i] == indice[i+1]){\n        coeff[i] += coeff[i+1];\n                *pnt+=1;\n        for(int j = i+1; j< *pplus-1 ; j++){\n                    char tmp;\n                    tmp = coeff[j];\n                    coeff[j] = coeff[j+1];\n                    coeff[j+1] = tmp;\n                }\n        coeff[*pplus-1] = 0;\n                for(int j = i+1; j< *pplus-1 ; j++){\n                    char tmp;\n                    tmp = indice[j];\n                    indice[j] = indice[j+1];\n                    indice[j+1] = tmp;\n                }\n        indice[*pplus-1] = 0;\n            }\n        }\n    }\n  *pnt =0 ;\n  for(int i = 0; i<40; i++){\n    if(coeff[i]==0){\n      break;\n    }\n    *pnt+=1;\n  }\n  char result[512] = {};\n  for(int i =0; i<*pnt-1;i++){\n    char tmp[100] = {};\n    sprintf(tmp,\"%d * x ^ %d + \", coeff[i], indice[i]);\n    strcat(result,tmp);\n  }\n  char tmp[50] ={};\n  sprintf(tmp,\"%d * x ^ %d\", coeff[*pnt-1], indice[*pnt-1]);\n  strcat(result, tmp);\n  printf(\"%s\\n\", result);\n}\n"}
{"target":"0712023","func":"#include <stdio.h>\nint main() {\n  int power(int x, int n){\n    if (n ==1 ){\n      return x;\n    } else if(n == 0){\n      return 1;\n    }\n    return (x*power(x,n-1));\n  }\n  int len(int number){\n    int cnt = 0;\n    while (number>0){\n      cnt++;\n      number \/= 10;\n    }\n    return cnt;\n  }\n\n  int a = 0;\n  int i = 0;\n  int func(int number){\n    if (len(number) >0){\n      a+=number%10*power(10, i);\n      number = number\/100;\n      i++;\n      func(number);\n    } else {\n      return 0;\n    }\n  }\n\n  int number = 0;\n  scanf(\"%d\", &number);\n  func(number);\n  printf(\"%d\", a);\n    return 0;\n}\n"}
{"target":"0712023","func":"char map[64];\nint pos = 0;\nint goal = 0;\n\nvoid tail_func(char tmp){\n  if(tmp == 'U'){\n    if(pos>7 && map[pos-8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos-=8;\n    }\n  } else if (tmp == 'D'){\n    if(pos<55 && map[pos+8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos+=8;\n    }\n  } else if (tmp == 'R'){\n    if(pos%8!=7 && map[pos+1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos++;\n    }\n  } else if (tmp == 'L'){\n    if(pos%8!=0 && map[pos-1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos--;\n    }\n  }\n}\n\nvoid check_stuck(){\n  if(pos<8 && map[pos+1] == 'W' && map[pos-1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(pos>55 && map[pos+1] == 'W' && map[pos-1] == 'W' && map[pos-8] == 'W') {\n    exit(0);\n  } else if(pos%8==7 && map[pos-8] == 'W' && map[pos-1] == 'W' && map[pos+8] == 'W') {\n    exit(0);\n  } else if(pos%8==0 && map[pos-8] == 'W' && map[pos+1] == 'W' && map[pos+8] == 'W') {\n    exit(0);\n  } else if(pos<8 && pos%8==7 && map[pos-1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(pos%8==7 && pos>55 && map[pos-8] == 'W' && map[pos-1] == 'W'){\n    exit(0);\n  } else if(pos>55 && pos%8==0 && map[pos-8] == 'W' && map[pos+1] == 'W'){\n    exit(0);\n  } else if(pos%8==0 && pos<8 && map[pos+1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(map[pos-8] == 'W' && map[pos+8] == 'W' && map[pos+1] == 'W' && map[pos-1] == 'W'){\n    exit(0);\n  }\n}\n\nvoid main(){\n  \n  int x, y, xg, yg;\n  scanf(\"%d %d\", &x, &y);\n    scanf(\"%d %d\", &xg, &yg);\n  pos = x*8+y;\n  goal = xg*8+yg;\n\n  \n  for(int i = 0 ; i< 136; i++){\n        char ch = getchar();\n    if(ch != ' '){\n      map[(i-i\/17)\/2] = ch;\n    }\n    }\n\n  \n  map[goal] = 'G';\n\n  \n  int turn = 0;\n    scanf(\"%d\", &turn);\n\n  \n    int cnt = 0;\n    char *cmd = (char*) calloc(turn, sizeof(char));\n    while(cnt < turn){\n    char input[7] = \"\";\n    gets(input);\n    if(strncmp(input, \"WIND\", 4) == 0){\n            cmd[cnt-1]='\\0';\n      strcat(cmd, &input[5]);\n    } else if(strncmp(input, \"CMD\", 3) == 0){\n      cnt+=1;\n      strcat(cmd, &input[4]);\n    }\n  }\n\n  \n  map[pos] = 'P';\n  for(int i=0; i<64; i++) {\n        printf(\"%c \", map[i]);\n    if(i%8==7){\n      printf(\"\\n\");\n    }\n  }\n  printf(\"\\n\");\n\n  \n  for(int k = 0; k<turn; k++){\n    \n    map[pos] = 'W';\n\n    \n    check_stuck();\n\n    \n    tail_func(cmd[k]);\n\n\n    \n    map[pos] = 'P';\n    for(int i=0; i<64; i++) {\n        printf(\"%c \", map[i]);\n      if(i%8==7){\n        printf(\"\\n\");\n      }\n    }\n    printf(\"\\n\");\n\n    \n    if(pos == goal){\n            exit(0);\n    }\n\n  \n  }\n  free(cmd);\n\n}\n"}
{"target":"0712023","func":"void stage_04(char input_list[INPUT_LEN][BUF_SIZ])\n{\n  printf(\"\\n\");\n  char pnt[20] = \".\";\n  char exc[20] = \"!\";\n  char qes[20] = \"?\";\n  char at[20] = \"@\";\n  char unb[20] = \"_\";\n\n  char buffer[50] = \"\";\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, pnt);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, exc);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, qes);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, at);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, unb);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  return;\n}\n"}
{"target":"254Odeke","func":"#include <stdio.h>\n\nstruct pstruct {\n    int fno;\n    int pbit;\n}ptable[10];\nint pmsize,lmsize,psize,no_of_frames,no_of_pages,ftable[20],frameno;\nvoid info(){\n    printf(\"Enter the Size of Physical memory: \");\n    scanf(\"%d\",&pmsize);\n    printf(\"Enter the size of Logical memory: \");\n    scanf(\"%d\",&lmsize);\n    printf(\"Enter the partition size: \");\n    scanf(\"%d\",&psize);\n    no_of_frames=pmsize\/psize;\n    no_of_pages=lmsize\/psize;\n    printf(\"The physical memory is divided into %d no.of frames\\n\",no_of_frames);\n    printf(\"The Logical memory is divided into %d no.of pages\\n\",no_of_pages);\n}\nvoid assign(){\n    int i;\n    for (i=0;i<no_of_pages;i++){\n        ptable[i].fno = -1;\n        ptable[i].pbit= -1;\n    }\n    for(i=0; i<no_of_frames;i++)\n        ftable[i] = 32555;\n    for (i=0;i<no_of_pages;i++){\n        printf(\"Enter the Frame number where page %d must be placed: \",i);\n        scanf(\"%d\",&frameno);\n        ftable[frameno] = i;\n        if(ptable[i].pbit == -1){\n            ptable[i].fno = frameno;\n            ptable[i].pbit = 1;\n        }\n    }\n    printf(\"\\n\\nPAGE TABLE\\n\\n\");\n    printf(\"PageAddress FrameNo. PresenceBit\\n\\n\");\n    for (i=0;i<no_of_pages;i++)\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",i,ptable[i].fno,ptable[i].pbit);\n    printf(\"\\n\\nFRAME TABLE\\n\\n\");\n    printf(\"FrameAddress PageNo\\n\\n\");\n    for(i=0;i<no_of_frames;i++)\n        printf(\"%d\\t\\t%d\\n\",i,ftable[i]);\n}\n\nvoid cphyaddr(){\n    int log_add,paddr,disp,phy_add,base_add;\n    printf(\"Enter the Base Address: \");\n    scanf(\"%d\",&base_add);\n    printf(\"Enter the Logical Address: \");\n    scanf(\"%d\",&log_add);\n    paddr = log_add \/ psize;\n    disp = log_add % psize;\n    if(ptable[paddr].pbit == 1 )\n        phy_add = base_add + (ptable[paddr].fno*psize) + disp;\n    printf(\"\\nThe Physical Address where the instruction present: %d\",phy_add);\n}\nvoid main(){\n    info();\n    assign();\n    cphyaddr();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\nvoid main(){\n    int  r_string[100],n,f,pf=0,count=0,m[10],i, j, k,;\n    printf(\"Enter the length of reference string:\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the reference string:\");\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&r_string[i]);\n    printf(\"Enter no. of frames:\");\n    scanf(\"%d\",&f);\n    for(i=0;i<f;i++)\n        m[i]=-1;\n    printf(\"The Page Replacement Process is:\\n\");\n    for(i=0;i<n;i++){\n        for(k=0;k<f;k++){\n            if(m[k]==r_string[i])\n                break;\n        }\n        if(k==f){\n            m[count++]=r_string[i];\n            pf++;\n        }\n        for(j=0;j<f;j++)\n            printf(\"\\t%d\",m[j]);\n        if(k==f)\n            printf(\"\\tPF No. %d\\n\",pf);\n        if(count==f)\n            count=0;\n    }\n    printf(\"\\n The number of Page Faults using FIFO are %d\",pf);\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\nvoid main(){\n    int rs[50], i, j, k, n, f, count[20], m[20], min, pf=0;\n    printf(\"Enter number of page references:\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the reference string:\");\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&rs[i]);\n    printf(\"Enter the available no. of frames:\");\n    scanf(\"%d\",&f);\n    for(i=0;i<f;i++){\n        count[i]=0;\n        m[i]=-1;\n    }\n    printf(\"\\nThe Page Replacement Process is\\n\");\n    for(i=0;i<n;i++){\n        for(k=0;k<f;k++){\n            if(rs[i]==m[k]){\n                count[k]++;\n                break;\n            }\n        }\n        if(k==f){\n            if(i<f){\n                m[i]=rs[i];\n                count[i]++;\n            }\n            else{\n                min = 0;\n                for(j=1;j<f;j++)\n                    if(count[min]>count[j])\n                        min=j;\n                m[min]=rs[i];\n                count[min]=1;\n            }\n            pf++;\n        }\n        for(j=0;j<f;j++)\n            printf(\"%d\\t\",m[j]);\n        if(k==f)\n            printf(\"PF No. %d\",pf);\n        print(\"\\n\");    \n    }\n    printf(\"\\n Total number of page faults: %d\",pf);\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<math.h>\nvoid main(){\n    int memory_size,page_size;\n    printf(\"Enter Memory Size:\");\n    scanf(\"%d\",&memory_size);\n    printf(\"Enter Page Size:\");\n    scanf(\"%d\",&page_size);\n    int n=memory_size\/page_size;\n    printf(\"No.of Pages available=%d\\n\",n);\n    \n    int m[n],i,j;\n    for(i=0;i<n;i++){\n        m[i]=0;\n    }\n    \n    int p;\n    printf(\"\\nEnter No.of Processes:\");\n    scanf(\"%d\",&p);\n    int rem_pages=n;\n    int req_pages,process_size;\n    \n    for(i=0;i<p;i++){\n        printf(\"Enter Process %d size:\",i+1);\n        scanf(\"%d\",&process_size);\n        req_pages=(process_size\/page_size);\n        if(process_size%page_size!=0) req_pages++;\n        if(req_pages>rem_pages){\n            printf(\"Memory is lower than asked\");\n            continue;\n        }\n        int temp[req_pages];\n        printf(\"Enter %d page numbers that are to be assigned to process %d:\",req_pages,i+1);\n        for(j=0;j<req_pages;j++){\n            scanf(\"%d\",&temp[j]);\n        }\n        for(j=0;j<req_pages;j++){\n            if(m[temp[j]]!=0){\n                printf(\"Page %d is already allocated\",temp[j]);\n                break;\n            }\n            m[temp[j]]=i+1;\n            rem_pages--;\n        }\n    }\n    \n    printf(\"Main Memory:\\n\");\n    printf(\"------------\\n\");\n    for(i=0;i<n;i++){\n        if(m[i]==0)\n            printf(\"\\tframe %d -- EMPTY\\n\",i);\n        else    \n            printf(\"\\tframe %d -- process %d\\n\",i,m[i]);\n    }\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n\nvoid main(){\n    int pro,res,i,j;\n    printf(\"Enter No.of Processes:\");\n    scanf(\"%d\",&pro);\n    printf(\"Enter No.of Resources:\");\n    scanf(\"%d\",&res);\n    \n    int res_vector[res],res_allocated[res],res_avail[res];\n    printf(\"Enter Resource Vector:\");\n    for(i=0;i<res;i++){\n        scanf(\"%d\",&res_vector[i]);\n        res_allocated[i]=0;\n    }\n    \n    int max[pro][res],allocated[pro][res],needed[pro][res];\n    printf(\"Enter the Max Requirement matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"Enter the Allocated Resource matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&allocated[i][j]);\n        }\n    }\n    \n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            needed[i][j]=max[i][j]-allocated[i][j];\n        }\n    }\n    \n    for(i=0;i<res;i++){\n        for(j=0;j<pro;j++){\n            res_allocated[i]+=allocated[j][i];\n        }\n        res_avail[i]=res_vector[i]-res_allocated[i];\n    }\n    \n    int completed[pro];\n    for(i=0;i<pro;i++){\n        completed[i]=0;\n    }\n    int flag,count=0;\n    x:\n    for(i=0;i<pro;i++){\n        flag=0;\n        for(j=0;j<res;j++){\n            if(res_avail[j]<needed[i][j]||completed[i]==1){\n                flag=1;\n                count++;\n                break;\n            }\n        }\n        if(flag==0){\n            printf(\"P%d \",i);\n            for(j=0;j<res;j++){\n                res_avail[j]+=allocated[i][j];\n                allocated[i][j]=0;\n                needed[i][j]=0;\n            }\n            completed[i]=1;\n            goto x;\n        }\n    }\n    if(count==pro){\n        printf(\"No Safe Sequence is Possible\");\n    }\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct filestructure{\n    char name[20];\n    int starting_block;\n    int no_of_blocks;\n}file[20];\nint i,j,disk[512];\nint n;\n\nvoid main(){\n    for(i=0;i<512;i++)\n        disk[i]=0;\n        int x,y,flag=0;\n    printf(\"Enter no.of files:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        printf(\"Enter File Name:\");\n        scanf(\"%s\",file[i].name);\n        printf(\"Enter Starting Index:\");\n        scanf(\"%d\",&file[i].starting_block);\n        printf(\"Enter Size of Block:\");\n        scanf(\"%d\",&file[i].no_of_blocks);\n        x=file[i].starting_block;\n        y=file[i].no_of_blocks;\n        for(j=x;j<x+y;j++){\n            if(disk[j]==1){\n                printf(\"Sequencial Allocation is not possible\\n\");\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0){\n            for(j=x;j<x+y;j++){\n                disk[j]=1;\n            }\n            printf(\"Allocation is done sequentially\\n\");\n        }\n    }\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\nint f[50],i,k,j,inde[50],n,c,count=0,p;\nmain(){\n\nfor(i=0;i<50;i++)\nf[i]=0;\nx:\nprintf(\"\\nEnter index block:\\t\");\nscanf(\"%d\",&p);\nif(f[p]==0){\nf[p]=1;\nprintf(\"\\nEnter no of files on index:\\t\");\nscanf(\"%d\",&n);\n}\nelse\n{\nprintf(\"\\nBlock already allocated\\n\");\ngoto x;\n}\nfor(i=0;i<n;i++)\nscanf(\"%d\",&inde[i]);\nfor(i=0;i<n;i++)\nif(f[inde[i]]==1){\nprintf(\"\\nBlock already allocated\");\ngoto x;\n}\nfor(j=0;j<n;j++)\nf[inde[j]]=1;\nprintf(\"\\nAllocated\");\nprintf(\"\\nFile indexed\");\nfor(k=0;k<n;k++)\nprintf(\"\\n%d->%d:%d\",p,inde[k],f[inde[k]]);\nprintf(\"\\nEnter 1 to enter more files and 0 to exit:\\t\");\nscanf(\"%d\",&c);\nif(c==1)\ngoto x;\nelse\nclose();\ngetch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<stdbool.h>\n#include<stdlib.h>\nint matrix[10][10],visited[10],n,i,j;\nbool isCyclic(int);\nvoid main(){\n    printf(\"Enter the No.of Processes present in wait for graph:\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the adjacency matrix:\\n\");\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            scanf(\"%d\",&matrix[i][j]);\n        }\n    }\n    for(i=0;i<n;i++){\n        visited[i]=0;\n    }\n    \n    bool flag=false;\n    for(i=0;i<n;i++){\n        visited[i]=1;\n        for(j=0;j<n;j++){\n            if(matrix[i][j]==0) continue;\n            flag = isCyclic(j);\n            if(flag==true){\n                printf(\"Cycle is present\");\n                exit(0);\n            }\n        }\n        visited[i]=0;\n    }\n    if(flag==false){\n        printf(\"Cycle is not present\");\n    }\n}\nbool isCyclic(int cur){\n    if(visited[cur]==1){\n        return true;\n    }\n    visited[cur]=1;\n    bool flag=false;\n    for(i=0;i<n;i++){\n        if(matrix[cur][i]==0) continue;\n        flag=isCyclic(i);\n        if(flag==true)\n            return true;\n    }\n    visited[cur]=0;\n    return false;\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h>\nint max[100][100];\nint alloc[100][100];\nint need[100][100];\nint avail[100];\nint n,r;\nvoid input();\nvoid show();\nvoid cal();\nint main()\n{\nint i,j;\nprintf(\"********** Deadlock Detection Algo ************\\n\");\ninput();\nshow();\ncal();\ngetch();\nreturn 0;\n}\nvoid input()\n{\nint i,j;\nprintf(\"Enter the no of Processes\\t\");\nscanf(\"%d\",&n);\nprintf(\"Enter the no of resource instances\\t\");\nscanf(\"%d\",&r);\nprintf(\"Enter the Max Matrix\\n\");\nfor(i=0;i<n;i++)\n{\nfor(j=0;j<r;j++)\n{\nscanf(\"%d\",&max[i][j]);\n}\n}\n printf(\"Enter the Allocation Matrix\\n\");\n for(i=0;i<n;i++)\n {\nfor(j=0;j<r;j++)\n{\nscanf(\"%d\",&alloc[i][j]);\n}\n }\n printf(\"Enter the available Resources\\n\");\n for(j=0;j<r;j++)\n {\n scanf(\"%d\",&avail[j]);\n }\n46;\n}\nvoid show()\n{\nint i,j;\nprintf(\"Process\\t Allocation\\t Max\\t Available\\t\");\nfor(i=0;i<n;i++)\n {\n printf(\"\\nP%d\\t \",i+1);\n for(j=0;j<r;j++)\n {\n printf(\"%d \",alloc[i][j]);\n }\n printf(\"\\t\");\n for(j=0;j<r;j++)\n {\n printf(\"%d \",max[i][j]);\n }\n printf(\"\\t\");\n if(i==0)\n {\n for(j=0;j<r;j++)\n printf(\"%d \",avail[j]);\n }\n }\n}\nvoid cal()\n{\n int finish[100],temp,need[100][100],flag=1,k,c1=0;\n int dead[100];\n int safe[100];\n int i,j;\n for(i=0;i<n;i++)\n {\n finish[i]=0;\n }\n \n for(i=0;i<n;i++)\n {\n for(j=0;j<r;j++)\n {\n need[i][j]=max[i][j]-alloc[i][j];\n }\n }\n while(flag)\n {\n flag=0;\n for(i=0;i<n;i++)\n {\n int c=0;\n for(j=0;j<r;j++)\n47;\n{\nif((finish[i]==0)&&(need[i][j]<=avail[j]))\n{\nc++;\n if(c==r)\n{\n for(k=0;k<r;k++)\n {\n avail[k]+=alloc[i][j];\n finish[i]=1;\n flag=1;\n }\n\nif(finish[i]==1)\n {\ni=n;\n}}}}}}\n j=0;\n flag=0;\n for(i=0;i<n;i++)\n {\n if(finish[i]==0)\n {\n dead[j]=i;\n j++;\n flag=1;\n }\n }\n if(flag==1)\n {\n printf(\"\\n\\nSystem is in Deadlock and the Deadlock process are\\n\");\n for(i=0;i<n;i++)\n {\n printf(\"P%d\\t\",dead[i]);\n }\n }\n else\n {\n printf(\"\\nNo Deadlock Occur\");\n }\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<stdlib.h>\n\nvoid main(){\n    int n,option,frames;\n    int size[10];\n    int i,a[10],total=0;\n    char p[10];\n    printf(\"No.of Processes present:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        printf(\"Enter the process name-\");\n        scanf(\"%s\",&p[i]);\n        printf(\"Enter the size of process-\");\n        scanf(\"%d\",&size[i]);\n    }\n    printf(\"No.of Frames present:\");\n    scanf(\"%d\",&frames);\n    while(1){\n        printf(\"\\n1.Fixed Allocation\\t2.Proportional Allocation\\t3.Exit:-\");\n        scanf(\"%d\",&option);\n        switch(option){\n            case 1: for(i=0;i<n;i++){\n                        printf(\"\\nAllocation of frames to process %c is %d\",p[i],frames\/n);\n                    }\n                    break;\n                    \n            case 2: for(i=0;i<n;i++) total = total+size[i]; \n                    for(i=0;i<n;i++){\n                        printf(\"\\nAllocation of frames for process %c is %d\",p[i],(size[i]*frames)\/total);\n                    }\n                    break;\n            case 3: exit(0);        \n            default: printf(\"\\nInvalid Selection\");\n        }\n    }\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\nint f[50],i,k,j,inde[50],n,c,count=0,p;\nmain(){\n\nfor(i=0;i<50;i++)\nf[i]=0;\nx:\nprintf(\"enter index block\\t\");\nscanf(\"%d\",&p);\nif(f[p]==0)\n{\nf[p]=1;\nprintf(\"enter no of files on index\\t\");\nscanf(\"%d\",&n);\n}\nelse\n{\nprintf(\"Block already allocated\\n\");\ngoto x;\n}\nfor(i=0;i<n;i++)\nscanf(\"%d\",&inde[i]);\nfor(i=0;i<n;i++)\nif(f[inde[i]]==1)\n{\nprintf(\"Block already allocated\");\ngoto x;\n}\nfor(j=0;j<n;j++)\nf[inde[j]]=1;\nprintf(\"\\n allocated\");\nprintf(\"\\n file indexed\");\nfor(k=0;k<n;k++)\nprintf(\"\\n %d->%d:%d\",p,inde[k],f[inde[k]]);\nprintf(\" Enter 1 to enter more files and 0 to exit\\t\");\nscanf(\"%d\",&c);\nif(c==1)\ngoto x;\nelse\nclose();\ngetch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h>\nmain(){\nint f[50],p,i,j,k,a,st,len,n,c;\n\nfor(i=0;i<50;i++)\nf[i]=0;\nprintf(\"\\nEnter the number of blocks that are already allocated: \");\nscanf(\"%d\",&p);\nprintf(\"\\nEnter the blocks no.s that are already allocated:\");\nfor(i=0;i<p;i++)\n{\nscanf(\"%d\",&a);\nf[a]=1;\n}\nX:\nprintf(\"\\nEnter the starting index block & length:\");\nscanf(\"%d%d\",&st,&len);\nk=len;\nfor(j=st;j<(k+st);j++)\n{\nif(f[j]==0)\n{\nf[j]=1;\nprintf(\"\\n%d->%d\",j,f[j]);\n}\nelse\n{\nprintf(\"\\n%d->file is already allocated\",j);\nk++;\n}\n}\nprintf(\"\\nWould you like to enter more files? (YES-1\/NO-0)\");\nscanf(\"%d\",&c);\nif(c==1)\ngoto X;\nelse\nclose();\ngetch( );}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h>\nint main(){\nint m,p,s,p1;\nint m1[4],i,f,f1=0,f2=0,fra1,fra2,s1,pos; \n\nprintf(\"\\nEnter the memory size:\"); scanf(\"%d\",&m);\nprintf(\"\\nEnter the no of partitions:\"); scanf(\"%d\",&p);\ns=m\/p;\nprintf(\"\\nEach partn size is:%d\",s); printf(\"\\nEnter the no of processes:\"); scanf(\"%d\",&p1);\npos=m;\nfor(i=0;i<p1;i++)\n{\nif(pos<s)\n{\nprintf(\"\\nThere is no further memory for process%d\",i+1); m1[i]=0;\nbreak;\n}\nelse\n{\nprintf(\"\\nEnter the memory req for process%d:\",i+1); scanf(\"%d\",&m1[i]);\nif(m1[i]<=s)\n{\nprintf(\"\\nProcess is allocated in partition%d\",i+1); fra1=s-m1[i];\nprintf(\"\\nInternal fragmentation for process is:%d\",fra1); f1=f1+fra1;\npos=pos-s;\n}\nelse\n{\nprintf(\"\\nProcess not allocated in partition%d\",i+1); s1=m1[i];\nwhile(s1>s)\n{\ns1=s1-s;pos=pos-s;\n}\npos=pos-s;fra2=s-s1;f2=f2+fra2;\nprintf(\"\\nExternal Fragmentation for this process is:%d\",fra2);\n}\n}\n}\n20;\nprintf(\"\\nProcess\\tAllocated Memory\");\nfor(i=0;i<p1;i++)\nprintf(\"\\n%5d\\t%5d\",i+1,m1[i]);\nf=f1+f2;\nprintf(\"\\nThe tot no of fragmentation is:%d\",f); getch();\nreturn 0;\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h> \nvoid main(){\nint a[5],b[20],n,p=0,q=0,m=0,h,k,i,q1=1; char f='F';\n\nprintf(\"Enter the Number of Pages: \"); \nscanf(\"%d\",&n);\nprintf(\"Enter %d Page Numbers:\",n); for(i=0;i<n;i++)\nscanf(\"%d\",&b[i]);\nfor(i=0;i<n;i++)\n{if(p==0)\n{\nif(q>=3)\nq=0;\na[q]=b[i];\nq++;\nif(q1<3)\n{\nq1=q;\n}\n}\nprintf(\"\\n%d\",b[i]);\nprintf(\"\\t\");\nfor(h=0;h<q1;h++)\nprintf(\"%d\",a[h]);\nif((p==0)&&(q<=3))\n{\nprintf(\"-->%c\",f);m++;\n}\np=0;\nfor(k=0;k<q1;k++)\n{\nif(b[i+1]==a[k])\np=1;\n}\n}\nprintf(\"\\nNo of faults:%d\",m); \ngetch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h> \nvoid main(){\nint g=0,a[5],b[20],p=0,q=0,m=0,h,k,i,q1=1,j,u,n; char f='F';\n\nprintf(\"Enter the number of pages:\"); scanf(\"%d\",&n);\nprintf(\"Enter %d Page Numbers:\",n); for(i=0;i<n;i++)\nscanf(\"%d\",&b[i]);\nfor(i=0;i<n;i++)\n{if(p==0)\n{\nif(q>=3)\nq=0;\na[q]=b[i];\nq++;\nif(q1<3)\n{\nq1=q;\n\n}\n}\nprintf(\"\\n%d\",b[i]);\nprintf(\"\\t\");\nfor(h=0;h<q1;h++)\nprintf(\"%d\",a[h]);\nif((p==0)&&(q<=3))\n{\nprintf(\"-->%c\",f);m++;\n}\np=0;\ng=0;\nif(q1==3)\n{\nfor(k=0;k<q1;k++)\n54;\n{\nif(b[i+1]==a[k])\np=1;\n}\nfor(j=0;j<q1;j++)\n{\nu=0;\nk=i;while(k>=(i-1)&&(k>=0))\n{\nif(b[k]==a[j])\nu++;k--;\n}\nif(u==0)\nq=j;\n}\n}\nelse\n{\nfor(k=0;k<q;k++)\n{\nif(b[i+1]==a[k])\np=1;\n}\n}\n}\nprintf(\"\\nNo of faults:%d\",m); getch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n\nvoid main(){\n    int res,pro,i,j,n;\n    printf(\"Enter No.of Processes:\");\n    scanf(\"%d\",&pro);\n    printf(\"Enter No.of Resources:\");\n    scanf(\"%d\",&res);\n    int res_vector[res],res_avail[res],res_allocated[res];\n    printf(\"Enter Resource vector:\");\n    for(i=0;i<res;i++){\n        scanf(\"%d\",&res_vector[i]);\n        res_allocated[i]=0;\n    }\n    int max[pro][res],allocated[pro][res],needed[pro][res];\n    printf(\"Enter the Max Requirement matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"Enter the Allocated Resource matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&allocated[i][j]);\n        }\n    }\n    \n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            needed[i][j]=max[i][j]-allocated[i][j];\n        }\n    }\n    \n    for(i=0;i<res;i++){\n        for(j=0;j<pro;j++){\n            res_allocated[i]+=allocated[j][i];\n        }\n        res_avail[i]=res_vector[i]-res_allocated[i];\n    }\n    \n    while(pro!=0){\n        printf(\"Enter process number that is to be executed:\");\n        scanf(\"%d\",&n);\n        for(i=0;i<res;i++){\n            if(needed[n][i]>res_avail[i]){\n                printf(\"Resources cannot be allocated to this process now:\\n\");\n                printf(\"\\nIt is unsafe state\");\n                exit(0);\n            }\n        }\n        if(i==res){\n            printf(\"Resources are allocated to the process %d and executed\\n\",n);\n            for(j=0;j<res;j++){\n                res_avail[j]+=allocated[n][j];\n            }\n        }\n    pro--;\n    }\n    if(pro==0)\n        printf(\"\\nIt is safe state\");\n}"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h>\n#include<string.h> void main()\n{\nint et[20],at[10],n,i,j,temp,p[10],st[10],ft[10],wt[10],ta[10]; int totwt=0,totta=0;\nfloat awt,ata;\nchar pn[10][10],t[10]; clrscr();\nprintf(\"Enter the number of process:\"); scanf(\"%d\",&n);\nfor(i=0;i<n;i++)\n{\nprintf(\"Enter process name,arrivaltime,execution time & priority:\"); flushall();\nscanf(\"%s%d%d%d\",pn[i],&at[i],&et[i],&p[i]);\n}\nfor(i=0;i<n;i++)\nfor(j=0;j<n;j++)\n{\nif(p[i]<p[j])\n{\ntemp=p[i];\np[i]=p[j];\np[j]=temp;\ntemp=at[i];\nat[i]=at[j];\nat[j]=temp;\ntemp=et[i];\net[i]=et[j];\net[j]=temp;\nstrcpy(t,pn[i]);\nstrcpy(pn[i],pn[j]);\nstrcpy(pn[j],t);\n}\n}\nfor(i=0;i<n;i++)\n{\nif(i==0)\n{\nst[i]=at[i];wt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];\n}\nelse\n{\nst[i]=ft[i-1];wt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];\n}\ntotwt+=wt[i];\ntotta+=ta[i];\n}\nawt=(float)totwt\/n;\nata=(float)totta\/n;\nprintf(\"\\nPname\\tarrivaltime\\texecutiontime\\tpriority\\twaitingtime\\ttatime\");\n12\nfor(i=0;i<n;i++)\nprintf(\"\\n%s\\t%5d\\t\\t%5d\\t\\t%5d\\t\\t%5d\\t\\t%5d\",pn[i],at[i],et[i],p[i],wt[i],ta[i]);\nprintf(\"\\nAverage waiting time is:%f\",awt);\nprintf(\"\\nAverage turnaroundtime is:%f\",ata); getch();\n}"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h> \n\nvoid main(){\nint et[30],ts,n,i,x=0,tot=0; char pn[10][10];\nprintf(\"Enter the no of processes:\"); scanf(\"%d\",&n);\nprintf(\"Enter the time quantum:\"); scanf(\"%d\",&ts); for(i=0;i<n;i++)\n{\nprintf(\"enter process name & estimated time:\"); scanf(\"%s %d\",pn[i],&et[i]);\n}\nprintf(\"The processes are:\"); for(i=0;i<n;i++)\nprintf(\"process %d: %s\\n\",i+1,pn[i]); for(i=0;i<n;i++)\ntot=tot+et[i];\nwhile(x!=tot)\n{\nfor(i=0;i<n;i++)\n{\nif(et[i]>ts)\n{\nx=x+ts;\nprintf(\"\\n %s -> %d\",pn[i],ts);\net[i]=et[i]-ts;\n}\nelse if((et[i]<=ts)&&et[i]!=0)\n{\nx=x+et[i];\nprintf(\"\\n %s -> %d\",pn[i],et[i]); et[i]=0;}\n}\n}\nprintf(\"\\n Total Estimated Time:%d\",x); getch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\nmain()\n{\nint f[50],i,st,j,len,c,k;\n\nfor(i=0;i<50;i++)\nf[i]=0;\nX:\nprintf(\"\\n Enter the starting block & length of file\");\nscanf(\"%d%d\",&st,&len);\nfor(j=st;j<(st+len);j++)\nif(f[j]==0)\n{\nf[j]=1;\nprintf(\"\\n%d->%d\",j,f[j]);\n}\nelse\n{\nprintf(\"Block already allocated\");\nbreak;\n}\nif(j==(st+len))\nprintf(\"\\n the file is allocated to disk\");\nprintf(\"\\n if u want to enter more files?(y-1\/n-0)\");\nscanf(\"%d\",&c);\nif(c==1)\ngoto X;\nelse\nclose();\ngetch();\n}\n"}
{"target":"254Odeke","func":"#include<stdio.h>\n#include<conio.h>\n#include<string.h> \nvoid main(){\nint et[20],at[10],n,i,j,temp,st[10],ft[10],wt[10],ta[10]; int totwt=0,totta=0;\nfloat awt,ata;\nchar pn[10][10],t[10]; \n\nprintf(\"Enter the number of process:\"); scanf(\"%d\",&n);\nfor(i=0;i<n;i++)\n{\nprintf(\"Enter process name, arrival time & execution time:\"); \n\nscanf(\"%s%d%d\",pn[i],&at[i],&et[i]);\n}\nfor(i=0;i<n;i++)\nfor(j=0;j<n;j++)\n{\nif(et[i]<et[j])\n{\ntemp=at[i];\nat[i]=at[j];\nat[j]=temp;\ntemp=et[i];\net[i]=et[j];\net[j]=temp;\nstrcpy(t,pn[i]);\nstrcpy(pn[i],pn[j]);\nstrcpy(pn[j],t);\n}\n}\nfor(i=0;i<n;i++)\n{\nif(i==0)\nst[i]=at[i]; else st[i]=ft[i-1];\nwt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];totwt+=wt[i]; totta+=ta[i];\n}\nawt=(float)totwt\/n;\nata=(float)totta\/n;\nprintf(\"\\nPname\\tarrivaltime\\texecutiontime\\twaitingtime\\ttatime\");\nfor(i=0;i<n;i++)\nprintf(\"\\n%s\\t%5d\\t\\t%5d\\t\\t%5d\\t\\t%5d\",pn[i],at[i],et[i],wt[i],ta[i]); \nprintf(\"\\nAverage waiting time is:%f\",awt);\nprintf(\"\\nAverage turnaroundtime is:%f\",ata); getch();\n}\n"}
{"target":"254Odeke","func":"#include <stdio.h>\n\nstruct pstruct {\n    int fno;\n    int pbit;\n}ptable[10];\nint pmsize,lmsize,psize,no_of_frames,no_of_pages,ftable[20],frameno;\nvoid info(){\n    printf(\"Enter the Size of Physical memory: \");\n    scanf(\"%d\",&pmsize);\n    printf(\"Enter the size of Logical memory: \");\n    scanf(\"%d\",&lmsize);\n    printf(\"Enter the partition size: \");\n    scanf(\"%d\",&psize);\n    no_of_frames=pmsize\/psize;\n    no_of_pages=lmsize\/psize;\n    printf(\"The physical memory is divided into %d no.of frames\\n\",no_of_frames);\n    printf(\"The Logical memory is divided into %d no.of pages\\n\",no_of_pages);\n}\nvoid assign(){\n    int i;\n    for (i=0;i<no_of_pages;i++){\n        ptable[i].fno = -1;\n        ptable[i].pbit= -1;\n    }\n    for(i=0; i<no_of_frames;i++)\n        ftable[i] = 32555;\n    for (i=0;i<no_of_pages;i++){\n        printf(\"Enter the Frame number where page %d must be placed: \",i);\n        scanf(\"%d\",&frameno);\n        ftable[frameno] = i;\n        if(ptable[i].pbit == -1){\n            ptable[i].fno = frameno;\n            ptable[i].pbit = 1;\n        }\n    }\n    printf(\"\\n\\nPAGE TABLE\\n\\n\");\n    printf(\"PageAddress FrameNo. PresenceBit\\n\\n\");\n    for (i=0;i<no_of_pages;i++)\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",i,ptable[i].fno,ptable[i].pbit);\n    printf(\"\\n\\nFRAME TABLE\\n\\n\");\n    printf(\"FrameAddress PageNo\\n\\n\");\n    for(i=0;i<no_of_frames;i++)\n        printf(\"%d\\t\\t%d\\n\",i,ftable[i]);\n}\n\nvoid cphyaddr(){\n    int log_add,paddr,disp,phy_add,base_add;\n    printf(\"Enter the Base Address: \");\n    scanf(\"%d\",&base_add);\n    printf(\"Enter the Logical Address: \");\n    scanf(\"%d\",&log_add);\n    paddr = log_add \/ psize;\n    disp = log_add % psize;\n    if(ptable[paddr].pbit == 1 )\n        phy_add = base_add + (ptable[paddr].fno*psize) + disp;\n    printf(\"\\nThe Physical Address where the instruction present: %d\",phy_add);\n}\nvoid main(){\n    info();\n    assign();\n    cphyaddr();\n}"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\n#include<math.h>\nint IsIdentity(int **mat,int r,int c);\nint **Transpose(int **mat1,int **mat2,int r,int c);\nint **MultiMat(int **mat1,int **mat2,int **temp,int r,int c,int n);\nint main()\n    {\n    int i,j,r,c,**mat1,**mat2,**temp;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));   \n    temp=(int **)malloc(r*sizeof(int *));                                       \n    \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n        \n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n    \n    for(i=0;i<r;i++)\n        temp[i]=(int *)malloc(c*sizeof(int ));\n            \n\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    \n    Transpose(mat1,mat2,r,c);\n    MultiMat(mat1,mat2,temp,r,c,c);\n    \n    if(IsIdentity(temp,r,c))\n        printf(\"\\nOrthogonal matrix\");\n    else\n        printf(\"Matrix is not orthogonal matrix\");\n        \n    return 0;\n    }\nint ** Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }\nint ** MultiMat(int **mat1,int **mat2,int **temp,int r,int c,int n)\n    {\n    int i,j,k;\n        \n        for(i=0;i<r;i++)\n            {\n            for(j=0;j<n;j++)\n                {\n                temp[i][j]=0;\n                for(k=0;k<c;k++)\n                    temp[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n            }\n        return temp;\n        }\nint IsIdentity(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if((i!=j)&&(mat[i][j]!=0))\n                return 0;\n            else if((i==j)&&(mat[i][j])!=1)\n                return 0;\n            }\n        }\n    return 1;\n    }   \n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\nvoid displayarr(int arr[],int len);\nint removeDuplicates(int arr[],int n);\nint main()\n    {\n    int *arr,i,n,sum=0;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    \n    arr=(int *)malloc((n)*sizeof(int *));   \n    \n    printf(\"\\nEnter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n    \n    n=removeDuplicates(arr,n);\n    \n    printf(\"\\nAfter removing duplicates: \");\n    displayarr(arr,n);\n    return 0;\n    }\nint removeDuplicates(int arr[],int n)\n    {\n    int i,j=0,*temp,k;\n    if(n==0||n==1)\n        return n;\n    \n    temp=(int *)malloc((n)*sizeof(int *));\n    \n    for(i=0;i<n;i++)\n        {\n        for(j=i+1;j<n;)\n            {\n            if(arr[i]==arr[j])\n                {\n                for(k=j;k<n;k++)\n                    arr[k]=arr[k+1];\n                n--;\n                }\n            else\n                j++;    \n            }\n        }\n    return n;\n    }\nvoid displayarr(int arr[],int len)\n    {\n    int i;\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n    }\n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\nvoid displayarr(int arr[],int len);\nint main()\n    {\n    int *arr,temp,n,i,j;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    \n    arr=(int *)malloc(n*sizeof(int *)); \n    \n    printf(\"Enter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);        \n    \n    printf(\"Original array: \");\n    displaymatrix(arr,n);\n    \n    for(i=n-1,j=0;i>j;i--,j++)      \n        {\n        temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n        }\n    \n    printf(\"\\nReversed array: \");\n    displaymatrix(arr,n);           \n    return 0;\n    }\n\nvoid displayarr(int arr[],int len)\n    {\n    int i;\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n    }\n    \n    \n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\nvoid displayarr(int arr[],int len);\nint main()\n    {\n    int *arr,i,n,sum=0;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    \n    arr=(int *)malloc((n)*sizeof(int *));   \n    \n    printf(\"Enter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n    \n    for(i=0;i<n;i++)\n        sum=sum+arr[i];\n        \n    printf(\"Sum of the array=%d\",sum);\n    return 0;\n    }\n\nvoid displayarr(int arr[],int len)\n    {\n    int i;\n    printf(\"After delete operation the array is:\\n\");\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n\n    }\n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\nint **Transpose(int **mat1,int **mat2,int r,int c);\nint IsSymmetric(int **mat1,int **mat2,int r,int c);\nint main()\n    {\n    int i,j,r,c,**mat1,**mat2;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));   \n                                    \n    \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n        \n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n\n            \n\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    \n    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))\n        printf(\"\\nSymmetric matrix\");\n    else\n        printf(\"\\nMatrix is not Symmetric matrix\");\n        \n    return 0;\n    }\nint IsSymmetric(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if(mat1[i][j]!=mat2[i][j])\n                return 0;\n            }\n        }\n    return 1;\n    }\nint ** Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }\n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\n#include<math.h>\nvoid displayMat(int **mat,int r,int c);\nint traceMat(int **mat,int r,int c);\n\nint main()\n    {\n    int i,j,r,c,**mat,sum=0;\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"For determinant matrix should be square\");\n    else\n        {\n        mat=(int **)malloc(r*sizeof(int *));        \n                                                \n        for(i=0;i<r;i++)\n            mat[i]=(int *)malloc(c*sizeof(int ));   \n    \n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n            {\n            for(j=0;j<c;j++)\n                {\n                scanf(\"%d\",&mat[i][j]);\n                sum=sum+mat[i][j]*mat[i][j];\n                \n                }\n            }\n            \n        printf(\"The matrix is:\\n\");\n        displayMat(mat,r,c);\n    \n        printf(\"\\nTrace of the matrix is= %d\",traceMat(mat,r,c));\n\n        printf(\"\\nNorm of the matrix is=%f\",sqrt((double)sum));\n        \n        }\n    return 0;\n    }   \nvoid displayMat(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nint traceMat(int **mat,int r,int c)\n    {\n    int i,t=0;\n    for(i=0;i<r;i++)\n        t=t+mat[i][i];\n    return t;\n    }\n    \n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<malloc.h>\n#include<math.h>\nvoid Transpose(int **mat1,int **mat2,int r,int c);\nvoid displayMat(int **mat,int r,int c);\nint main()\n    {\n    int i,j,r,c,**mat1,**mat2;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));                                   \n    \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n        \n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n            \n\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n        \n    Transpose(mat1,mat2,r,c);\n        \n    printf(\"Transpose of the matrix is:\\n\");\n    displayMat(mat2,r,c);\n    return 0;\n    }\nvoid displayMat(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }   \nvoid Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    }\n"}
{"target":"2security","func":"\n#include<stdio.h>\n#include<string.h>\nvoid baseconversion(char s[20],int,int);\nint main()\n{   \n    char s[20];\n    int base1,base2;\n    printf(\"Enter the number and base:\");\n    scanf(\"%s%d\",s,&base1);\n    printf(\"Enter the base to be converted:\");\n    scanf(\"%d\",&base2);\n    baseconversion(s,base1,base2);\n    return 0;\n}\n\nvoid baseconversion(char s[20],int b1,int b2)\n{\n    int count=0,r,digit,i,n=0,b=1;\n    for(i=strlen(s)-1;i>=0;i--)\n        {\n         if(s[i]>='A'&&s[i]<='Z')\n            {\n             digit=s[i]-'0'-7;\n            }\n         else\n            {\n             digit=s[i]-'0';\n            }\n        n=digit*b+n;\n        b=b*b1;\n        }\n    while(n!=0)\n    {\n        r=n%b2;\n        digit='0'+r;\n        if(digit>'9')\n        {\n            digit+=7;\n        }\n         s[count]=digit;\n         count++;\n         n=n\/b2;\n    }\n    for(i=count-1;i>=0;i--)\n        {\n        printf(\"%c\",s[i]);\n        }\n    printf(\"\\n\");\n    }\n    \n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint main()\n    {\n        FILE *fptr,*fp=NULL;\n        int ch;\n        fptr=fopen(\"File18.txt\",\"r\");\n        fp=fopen(\"File18Final.txt\",\"w\");\n        \n        if(fptr==NULL||fp==NULL)\n            {\n                printf(\"\\n Unable to open file\");\n                exit(1);\n            }\n        \n        while((ch=fgetc(fptr))!=EOF)\n            {\n                if(isupper(ch))\n                    ch=tolower(ch);\n                else if(islower(ch))\n                    ch=toupper(ch);\n                \n                fputc(ch,fp);\n            }\n        \n        printf(\"\\n Successfully Toggled\");\n        fclose(fptr);\n        fclose(fp);\n        \n        remove(\"File18.txt\");\n        \n        rename(\"File18Final.txt\",\"File18.txt\");\n        \n        return 0;\n    }\n"}
{"target":"2security","func":"#include <stdio.h>\n#include <unistd.h>\n#include <io.h>\n#include <sys\/stat.h>\n\nint isFileExists(const char *path);\nint isFileExistsAccess(const char *path);\nint isFileExistsStats(const char *path);\n\n\nint main()\n{\n    char path[100];\n\n    printf(\"Enter source file path: \");\n    scanf(\"%s\", path);\n\n\n    \n    if (isFileExistsAccess(path))\n    {\n        printf(\"File exists at path '%s'\\n\", path);\n    }\n    else\n    {\n        printf(\"File does not exists at path '%s'\\n\", path);\n    }\n\n    return 0;\n}\n\n\n\n\nint isFileExists(const char *path)\n{\n    \n    FILE *fptr = fopen(path, \"r\");\n\n    \n    if (fptr == NULL)\n        return 0;\n\n    \n    fclose(fptr);\n\n    return 1;\n}\n\n\n\n\nint isFileExistsAccess(const char *path)\n{\n    \n    if (access(path, F_OK) == -1)\n        return 0;\n\n    return 1;\n}\n\n\n\n\nint isFileExistsStats(const char *path)\n{\n    struct stat stats;\n\n    stat(path, &stats);\n\n    \n    if (stats.st_mode & F_OK)\n        return 1;\n\n    return 0;\n}\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<sys\/types.h>\n#include<dirent.h>\n#include<string.h>\nvoid listFilesRecursively(char *path);\n\n\nint main()\n{\n    \n    char path[100];\n\n    \n    printf(\"Enter path to list files: \");\n    scanf(\"%s\", path);\n\n    listFilesRecursively(path);\n\n    return 0;\n}\n\n\n\nvoid listFilesRecursively(char *basePath)\n{\n    char path[1000];\n    struct dirent *dp;\n    DIR *dir = opendir(basePath);\n\n    \n    if (!dir)\n        return;\n\n    while ((dp = readdir(dir)) != NULL)\n    {\n        if (strcmp(dp->d_name, \".\") != 0 && strcmp(dp->d_name, \"..\") != 0)\n        {\n            printf(\"%s\\n\", dp->d_name);\n\n            \n            strcpy(path, basePath);\n            strcat(path, \"\/\");\n            strcat(path, dp->d_name);\n\n            listFilesRecursively(path);\n        }\n    }\n\n    closedir(dir);\n}\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nint isEven(int n)\n    {\n        if(n%2==0)\n            return 1;\n        else \n            return 0;\n    }\nint isPrime(int n)\n    {\n        int i,flag=0;\n        for(i=2;i<n\/2;i++)\n            {\n                if(n%i==0)\n                    {\n                        return 0;\n                    }\n            }\n        return 1;\n    }\nint main()\n    {\n        FILE *fptr,*eptr,*optr,*pptr;\n        int n;\n        \n        fptr=fopen(\"File3.txt\",\"r\");\n        eptr=fopen(\"FIle3Even.txt\",\"w\");\n        optr=fopen(\"FIle3Odd.txt\",\"w\");\n        pptr=fopen(\"FIle3Prime.txt\",\"w\");\n        if(fptr==NULL||eptr==NULL||optr==NULL||pptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n            \n        while(fscanf(fptr,\"%d\",&n)!=EOF)\n            {\n                if(isPrime(n))\n                    fprintf(pptr,\"%d \",n);\n                if(isEven(n))\n                    fprintf(eptr,\"%d \",n);\n                else\n                    fprintf(optr,\"%d \",n);  \n            }\n            \n        printf(\"\\n Successfully written into file...\");\n        \n        fclose(fptr);\n        fclose(eptr);\n        fclose(optr);\n        fclose(pptr);\n        \n        return 0;\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nint main()\n    {\n        FILE *fptr;\n        char str[100];\n        int n;\n        \n        fptr=fopen(\"File4.txt\",\"a\");\n    \n        if(fptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n            \n        \n        printf(\"\\n Enter contents to append in file4::\");\n        fflush(stdin);\n        fgets(str,100,stdin);   \n        \n        \n        fputs(str,fptr);\n        \n        printf(\"\\n Successfully append into file...\");\n        \n        fclose(fptr);\n        \n        return 0;\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nint pos=0,line=1,error=0;\nint CompareFile(FILE *fptr1,FILE *fptr2)\n    {\n    char ch1,ch2;\n    int n=1;\n    ch1=getc(fptr1);\n    ch2=getc(fptr2);\n    while(ch1!=EOF&&ch2!=EOF)\n        {\n        pos++;\n        if(ch1 =='\\n'&&ch2=='\\n') \n            { \n            line++; \n            pos = 0; \n            }    \n        \n        if(ch1!=ch2)\n            {\n            n=0;\n            error++;\n            }\n            \n        ch1=getc(fptr1);\n        ch2=getc(fptr2);\n        }\n    return n;\n    }\nint main()\n    {\n        FILE *fptr1,*fptr2;\n        char str[100];\n        int n,line,col;\n        \n        fptr1=fopen(\"File51.txt\",\"r\");\n        fptr2=fopen(\"File52.txt\",\"r\");\n    \n        if(fptr1==NULL||fptr2==NULL)\n            {\n                perror(\"File openning error (: \");\n                getch();\n                exit(0);\n            }           \n        \n        if(CompareFile(fptr1,fptr2))\n            printf(\"\\n Two file is same\");\n        else\n            printf(\"\\n Two file is not same error:%d pos:%d line:%d\",error,pos,line);\n    \n        \n        fclose(fptr1);\n        fclose(fptr2);\n        \n        return 0;\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nFILE *openfile(char *,char *);\nint copyfile(char *,char *);\nvoid main()\n    {\n    int cf  ;\n    \n    cf=copyfile(\"File6To.txt\",\"File6From.txt\");\n    if(cf==1)\n        printf(\"Copy done\");\n    else\n        printf(\"Copy not done\");\n    getch();\n    }\nint copyfile(char *to,char *from)\n    {\n    FILE *t,*f;\n    int ch;\n    t=openfile(to,\"w\");\n    f=openfile(from,\"r\");\n    if(f==NULL||t==NULL)\n        return 0;\n    while((ch=fgetc(f))!=EOF)\n        fputc(ch,t);\n    return 1;\n    }\nFILE *openfile(char *path,char *mode)\n    {\n    FILE *fp;\n    fp=fopen(path,mode);\n    if(fp==NULL)\n        {\n        perror(\"File opening error (:\");\n        getch();\n        exit(0);\n        }\n    return fp;\n    }\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nFILE *openfile(char *,char *);\nint mergefile(char *,char *,char *);\nvoid main()\n    {\n    int cf  ;\n\n    cf=mergefile(\"File71.txt\",\"File72.txt\",\"File7.txt\");\n    if(cf==1)\n        printf(\"Merge done\");\n    else\n        printf(\"Merge not done\");\n    getch();\n    }\nint mergefile(char *fp1,char *fp2,char *fp3)\n    {\n    FILE *one,*two,*three;\n    int ch;\n    \n    one=openfile(fp1,\"r\");\n    two=openfile(fp2,\"r\");\n    three=openfile(fp3,\"w\");\n    \n    if(one==NULL||two==NULL||three==NULL)\n        return 0;\n        \n    while((ch=fgetc(one))!=EOF)\n        fputc(ch,three);\n        \n    while((ch=fgetc(two))!=EOF)\n        fputc(ch,three);\n    return 1;\n    }\nFILE *openfile(char *path,char *mode)\n    {\n    FILE *fp;\n    fp=fopen(path,mode);\n    if(fp==NULL)\n        {\n        perror(\"File opening error (:\");\n        getch();\n        exit(0);\n        }\n    return fp;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\nint main()\n    {\n        FILE *fptr;\n        int c=0,word=0,line=0;\n        char ch;\n        \n        if((fptr=fopen(\"File8.txt\",\"r\"))==NULL)\n            {\n                printf(\"\\n File not exit\");\n                exit(1);\n            }\n        while((ch=fgetc(fptr))!=EOF)\n            {\n                c++;\n                if(ch=='\\n'||ch=='\\0')\n                    line++;\n                if(ch==' '||ch=='\\n'||ch=='\\t'||ch==','||ch=='.'||ch==':'||ch==';'||ch=='-')\n                    word++;         \n            }\n        if(c>0)\n            {\n                line++;\n                word++;\n            }\n        printf(\"\\n Total character:: %d\",c);\n        printf(\"\\n Total word:: %d\",word);\n        printf(\"\\n Total line:: %d\",line);\n        \n        fclose(fptr);\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nvoid removeWord(char *buffer,char *str)\n    {\n        int m,n,f,i,j;\n        m=strlen(buffer);\n        n=strlen(str);\n        \n        \n        \n        \n    }\nint main()\n    {\n        FILE *fptr1,*fptr2;\n        int ;\n        char str[1000],buffer[1000];\n        \n        printf(\"\\n Enter word to remove\");\n        scanf(\"%s\",str);\n        \n        fptr1=fopen(\"File8.txt\",\"r\");\n        fptr2=fopen(\"File8Final.tmp\",\"w\");\n        \n        if(ptr1==NULL||ptr2==NULL)\n            {\n                printf(\"\\n File not exit\");\n                exit(1);\n            }\n        \n        while((fgets(buffer,1000,fptr1))!=NULL)\n            {\n            removeWord(buffer,str);\n            fputs(buffer,fptr2);\n            }\n        \n        \n        fclose(fptr1);\n        fclose(fptr2);\n        \n        remove(\"File8.txt\");\n        \n        rename(\"File8.tmp\",\"File8.txt\");\n        \n        printf(\"\\n Successfully removed\");\n        \n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n    int amount,tt=0,ot=0,fh=0,h=0,f=0,tw=0,te=0,five=0,to=0,one=0;\n    printf(\"Enter amount\");\n    scanf(\"%d\",&amount);\n    \n    if(amount>=2000)\n        {\n        tt=amount\/2000;\n        amount=amount-2000*tt;\n        }\n    if(amount>=1000)\n        {\n        ot=amount\/1000;\n        amount=amount-1000*ot;\n        }\n    if(amount>=500)\n        {\n        fh=amount\/500;\n        amount=amount-500*fh;\n        }\n    if(amount>=100)\n        {\n        h=amount\/100;\n        amount=amount-100*h;\n        }\n    if(amount>=50)\n        {\n        f=amount\/50;\n        amount=amount-50*f;\n        }\n    if(amount>=20)\n        {\n        tw=amount\/20;\n        amount=amount-20*tw;\n        }\n    if(amount>=10)\n        {\n        te=amount\/10;\n        amount=amount-10*te;\n        }\n    if(amount>=5)\n        {\n        five=amount\/5;\n        amount=amount-5*five;\n        }\n    if(amount>=2)\n        {\n        to=amount\/2;\n        amount=amount-10*to;\n        }\n    else\n        {\n        one=amount;\n        }\n    printf(\"\\n Total number of notes\");\n    printf(\"\\n2000: %d\",tt);\n    printf(\"\\n1000: %d\",ot);\n    printf(\"\\n500: %d\",fh);\n    printf(\"\\n100: %d\",h);\n    printf(\"\\n50: %d\",f);\n    printf(\"\\n20: %d\",tw);\n    printf(\"\\n10: %d\",te);\n    printf(\"\\n5: %d\",five);\n    printf(\"\\n2: %d\",to);\n    printf(\"\\n1: %d\\n\",one);\n\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n    int weekd;\n    printf(\"Enter week day number\");\n    scanf(\"%d\",&weekd);\n\n    if(weekd==1)\n        printf(\"MONDAY\\n\");\n\n    else if(weekd==2)\n        printf(\"TUESDAY\\n\");\n    \n    else if(weekd==3)\n        printf(\"WEDNESDAY\\n\");\n\n    else if(weekd==4)\n        printf(\"THURSDAY\\n\");\n    \n    else if(weekd==5)\n        printf(\"FRIDAY\\n\");\n    \n    else if(weekd==6)\n        printf(\"SATURDAY\\n\");\n\n    else if(weekd==7)\n        printf(\"SUNDAY\\n\");\n    \n    else \n        printf(\"OOPS!!Enter valid week day number\\n\");\n\n    return 0;\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n    int unit;\n    float pay,Surpay;\n    printf(\"\\nEnter the unit consumed\\n\");\n    scanf(\"%d\",&unit);\n        \n    if(unit<=50)\n        {\n        pay=unit * 0.50;\n        unit=unit-50;\n        }\n\n    if(unit<=150)\n        {       \n        pay=pay+unit*0.75;\n        unit=unit-100;\n        }\n    if(unit<=250)\n        {\n        pay=pay+unit*1.20;\n        unit=unit-100;\n        }\n    else\n        {\n        pay=pay+unit*1.50;\n        }\n\n    Surpay=pay*0.2;\n    pay=pay+Surpay;\n\n    printf(\"\\nPay of %f\\n\",pay);    \n\n    printf(\"\\n\");   \n    return 0;\n    }   \n        \n    \n    \n\n    \n        \n"}
{"target":"2security","func":"#include<stdio.h>\n#include<math.h>\nint main()\n    {\n    float p,c,b,m,ca,t;\n    printf(\"Enter makrs of Physics\");\n    scanf(\"%f\",&p);\n\n    printf(\"Enter makrs of Chemistry\");\n    scanf(\"%f\",&c);\n    \n    printf(\"Enter makrs of Bialogy\");\n    scanf(\"%f\",&b);\n        \n    printf(\"Enter makrs of Mathematics\");\n    scanf(\"%f\",&m);\n    \n    printf(\"Enter makrs of Computer\");\n    scanf(\"%f\",&ca);\n    \n    t=((p+c+b+m+ca)\/500)*100;\n        \n    if(t>=90)\n        printf(\"\\nGRADE A\\n\");\n    \n    else if(t>=90)\n        printf(\"\\nGRADE A\\n\");\n    \n    else if(t>=80)\n        printf(\"\\nGRADE B\\n\");\n    \n    else if(t>=70)\n        printf(\"\\nGRADE C\\n\");\n    \n    else if(t>=60)\n        printf(\"\\nGRADE D\\n\");\n\n    else if(t>=40)\n        printf(\"\\nGRADE E\\n\");\n\n    else\n        printf(\"\\nGRADE F\\n\");\n\n    printf(\"\\n\");   \n    return 0;\n    }   \n        \n    \n    \n\n    \n        \n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n    int mno;\n    printf(\"Enter the month number\");\n    scanf(\"%d\",&mno);\n\n    if(mno==1)\n        printf(\"\\n January months 31 days\\n\");\n    else if(mno==2) \n        printf(\"\\n February month 28 or 29 days\\n\");\n    else if(mno==3) \n        printf(\"\\n March month 31 days\\n\");     \n    else if(mno==4) \n        printf(\"\\n April month 30 days\\n\");\n    else if(mno==5) \n        printf(\"\\n May month 31 days\\n\");   \n    else if(mno==6) \n        printf(\"\\n June month 30 days\\n\");\n    else if(mno==7) \n        printf(\"\\n July month 31 days\\n\");  \n    else if(mno==8) \n        printf(\"\\n August month 31 days\\n\");\n    else if(mno==9) \n        printf(\"\\n September month 30 days\\n\");     \n    else if(mno==10) \n        printf(\"\\n October month 31 days\\n\");\n    else if(mno==11) \n        printf(\"\\n November month 30 days\\n\");      \n    else if(mno==12) \n        printf(\"\\n December month 31 days\\n\");\n    else\n        printf(\"\\n OOPS!! Enter corrent month number\\n\");\n    return 0;\n    }\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<math.h>\nint main()\n    {\n    float a,b,c,t,t1,t2,real,ima;\n    printf(\"Enter the co-efficients of the quadratic equation\");\n    scanf(\"%f%f%f\",&a,&b,&c);\n    \n    t=sqrt(b*b-4*a*c);\n    printf(\"%f\",t);\n    \n    if(t>0)\n        {\n        t1=(-b+t)\/(2*a);\n        t2=(-b-t)\/(2*a);\n        printf(\"\\nRoots are unequal and roots are %.2f %.2f\\n\",t1,t2);\n        }\n    else if(t==0)   \n        {\n        printf(\"\\nTwo roots are equal and roots are %.2f %.2f\\n\",-b\/(2*a),-b\/(2*a));\n        }\n    else\n        {\n        real=-b\/(2*a);\n        ima=sqrt(4*a*c-b*b)\/(2*a);\n        printf(\"\\nTwo distinct complex Roots are %.2f+i%.2f and %.2f-i%.2f \\n\",real,ima,real,ima);\n        }\n    return 0;\n    }   \n        \n    \n    \n\n    \n        \n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n    float basicsal,HRA,DA;\n    printf(\"Enter the basic salary\");\n    scanf(\"%f\",&basicsal);\n    \n    if(basicsal>20000)\n        {\n        HRA=basicsal*30\/100;\n        DA=basicsal*95\/100;\n        }\n    else if(basicsal<=20000)\n        {\n        HRA=basicsal*25\/100;\n        DA=basicsal*90\/100;\n        }\n    else if(basicsal<=10000)\n        {\n        HRA=basicsal*20\/100;\n        DA=basicsal*80\/100;\n        }\n    printf(\"\\n Gross salary=%f\\n\",basicsal+HRA+DA);\n\n    printf(\"\\n\");   \n    return 0;\n    }   \n        \n    \n    \n\n    \n        \n"}
{"target":"2security","func":"#include<stdio.h>\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nvoid AddMat(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20];\n            \n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            temp[i][j]=mat1[i][j]+mat2[i][j];\n        }\n    displayMat(temp,r,c);\n    }\nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same)\");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n        \n        printf(\"\\n The addtion of two matrix is:\\n\");\n        AddMat(mat1,mat2,r,c);\n        }\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nvoid SubMat(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20];\n            \n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            temp[i][j]=mat1[i][j]-mat2[i][j];\n        }\n    displayMat(temp,r,c);\n    }\nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n        \n        printf(\"\\n The addtion of two matrix is:\\n\");\n        SubMat(mat1,mat2,r,c);\n        }\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%-3d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nvoid ScalarProduct(int mat[][20],int r,int c,int s)\n    {\n    int i,j;\n            \n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            mat[i][j]=s*mat[i][j];\n        }\n    displayMat(mat,r,c);\n    }\nint main()\n    {\n    int i,j,r,c,mat1[20][20],s;\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"\\n Enter the scalar to be multiplied: \");\n        scanf(\"%d\",&s);\n        \n        printf(\"\\n The addtion of two matrix is:\\n\");\n        ScalarProduct(mat1,r,c,s);\n        }\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%-3d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nvoid Product(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20],k;\n    \n    for(i=0;i<r;i++)\n            {\n            for(j=0;j<c;j++)\n                {\n                temp[i][j]=0;\n                for(k=0;k<c;k++)\n                    temp[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n            }\n    displayMat(temp,r,c);\n    }\nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n    \n        \n        printf(\"\\n The addtion of two matrix is:\\n\");\n        Product(mat1,mat2,r,c);\n        }\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n        int mat1[20][20],mat2[20][20],i,j,n,flag=0;\n        printf(\"\\nEnter the order of matrix\");\n        scanf(\"%d\",&n);\n        \n        printf(\"\\n Enter first matrix\");\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"\\n Enter second matrix\");\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        scanf(\"%d\",&mat2[i][j]);\n        \n        for(i=0;i<n;i++)\n            {\n                for(j=0;j<n;j++)\n                    {\n                        if(mat1[i][j]!=mat2[i][j])\n                        {\n                        flag=1;\n                        break;  \n                        }       \n                    }\n            }\n        if(flag==0)\n            printf(\"\\n Two matrix are equal\");\n        else\n            printf(\"\\n Two matrix are different\");\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint checkUpperTri(int mat[][20],int r)\n    {\n    int i,j,flag=1;\n    for(i=1;i<r;i++) \n        for(j=0;j<i;j++) \n            if(mat[i][j]!= 0) \n                return 0;\n        return 1;\n    }\n\nint main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"For checking upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        if(checkUpperTri(mat1,r)==1)\n            printf(\"Matrix is Upper triangualr matrix\");\n        else\n            printf(\"Matrix is not Upper triangualr matrix\");\n        }\n    return 0;\n    }   \n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint checkLowerTri(int mat[][20],int r)\n    {\n    int i,j;\n    for(i=0;i<r-1;i++) \n        {\n        for(j=1;j<r;j++) \n            {\n            if(i<j && mat[i][j]!=0)\n                {\n                return 0;\n                break;  \n                }           \n            }\n        }\n    return 1;\n    }\n\nint main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"For checking Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        if(checkLowerTri(mat1,r)==1)\n            printf(\"Matrix is Lower triangualr matrix\");\n        else\n            printf(\"Matrix is not Lower triangualr matrix\");\n        }\n    return 0;\n    }   \n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint SumUpperTri(int mat[][20],int r)\n    {\n    int i,j,sum=0;\n    for(i=0;i<r;i++) \n        {\n        for(j=0;j<r;j++) \n            {\n            if(i<=j)\n                sum=sum+mat[i][j];\n            }\n        }\n    return sum;\n    }\n\nint main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"Upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"The sum of the Upper triangular matrix=%d\",SumUpperTri(mat1,r));    \n        }\n    return 0;\n    }   \n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint SumLowerTri(int mat[][20],int r)\n    {\n    int i,j,sum=0;\n    for(i=0;i<r;i++) \n        {\n        for(j=0;j<r;j++) \n            {\n            if(i>=j)\n                sum=sum+mat[i][j];\n            }\n        }\n    return sum;\n    }\n\nint main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        \n        printf(\"The sum of the lower triangular matrix=%d\",SumLowerTri(mat1,r));    \n        }\n    return 0;\n    }   \n\n\n"}
{"target":"2security","func":"#include<stdio.h>\n\nvoid Transpose(int mat1[][20],int mat2[][20],int r,int c);\nvoid displayMat(int mat[][20],int r,int c);\nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n        \n    Transpose(mat1,mat2,r,c);\n        \n    printf(\"Transpose of the matrix is:\\n\");\n    displayMat(mat2,r,c);\n    return 0;\n    }\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }   \nvoid Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\nvoid displayMat(float **mat,int r,int c);\nfloat deterMat(float **mat,int r,int c);\nint main()\n    {\n    int i,j,r,c;\n    float **mat,temp;\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);\n    \n    if(r!=c)\n        printf(\"For determinant matrix should be square\");\n    else\n        {\n        mat=(float **)malloc(r*sizeof(float *));        \n                                                \n        for(i=0;i<r;i++)\n            mat[i]=(float *)malloc(c*sizeof(float));    \n    \n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)\n        scanf(\"%f\",&mat[i][j]);\n            \n        printf(\"The matrix is:\\n\");\n        displayMat(mat,r,c);\n    \n        temp=deterMat(mat,r,c);\n        \n        printf(\"Determinant of the matrix is:= %f\\n\", temp);\n        }\n    return 0;\n    }   \nvoid displayMat(float **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%f \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nfloat deterMat(float **mat,int r,int c)\n    {\n    int i,j,k;\n    float det,ratio;\n    for(i = 0; i < r; i++)\n        {\n            for(j = 0; j < c; j++)\n                {\n                    if(j>i)\n                        {\n                        ratio = mat[j][i]\/mat[i][i];\n                        for(k = 0; k < r; k++)\n                                mat[j][k] -= ratio * mat[i][k];\n                        }\n                }\n            }\n        det = 1; \n        for(i = 0; i < r; i++)\n            det *= mat[i][i];\n        return det;\n        }\n    \n\n"}
{"target":"2security","func":"#include<stdio.h>\nint checkIdentity(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if((i!=j)&&(mat[i][j]!=0))\n                return 0;\n            else if((i==j)&&(mat[i][j])!=1)\n                return 0;\n            }\n        }\n    return 1;\n    }   \nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n        \n    if(checkIdentity(mat1,r,c)==1)\n        printf(\"Matrix is identity matrix of order %d\",r);\n    else\n        printf(\"Matrix is not identity matrix\");\n        \n    return 0;\n    }\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint count=0;\nvoid displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }\nint CheckSparse(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n                {\n                    if(mat[i][j]==0)\n                        count++;\n                }\n        }\n    if(count>=(r*c)\/2)\n        return 1;\n    else\n        return 0;   \n    }\n\nint main()\n    {\n    int i,j,r,c,mat[20][20];\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);    \n                    \n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n    scanf(\"%d\",&mat[i][j]);\n        \n    printf(\"The matrix is:\\n\");\n    displayMat(mat,r,c);\n    \n    if(CheckSparse(mat,r,c)==1)\n        printf(\"The matrix is sparse matrix\\n\");\n    else\n        printf(\"The matrix is not sparse matrix\\n\");\n    return 0;\n    }   \n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\n\nint IsSymmetric(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if(mat1[i][j]!=mat2[i][j])\n                return 0;\n            }\n        }\n    return 1;\n    }\nint ** Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }\n\nint main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    \n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    \n    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))\n        printf(\"\\nSymmetric matrix\");\n    else\n        printf(\"\\nMatrix is not Symmetric matrix\");\n        \n    return 0;\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\n#include<malloc.h>\nint r,c;\nvoid Display(int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            printf(\"%-3d \",mat3[i][j]);\n        printf(\"\\n\");\n        }\n    }\nint **Sum(int **mat1,int **mat2,int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            mat3[i][j]=mat1[i][j]+mat2[i][j];\n            }\n        }\n    return mat3;\n    }\nint main()\n    {\n        int i,j,m,n;\n        int **mat1,**mat2,**mat3;\n        printf(\"Enter the row & col. of the first matrix \");\n        scanf(\"%d%d\",&r,&c);\n        printf(\"Enter the row & col. of the second matrix \");\n        scanf(\"%d%d\",&m,&n);\n        if((r==m)&&(c==n))\n            {\n                mat1=(int **)malloc(r*sizeof(int *));       \n                                                \n                mat2=(int **)malloc(r*sizeof(int *));\n            \n                mat3=(int **)malloc(r*sizeof(int *));       \n        \n                for(i=0;i<r;i++)\n                mat1[i]=(int *)malloc(c*sizeof(int));   \n            \n                for(j=0;j<r;j++)\n                mat2[j]=(int *)malloc(c*sizeof(int));\n        \n                for(j=0;j<r;j++)\n                mat3[j]=(int *)malloc(c*sizeof(int));\n        \n                printf(\"\\n Enter the first matrix \");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat1[i][j]);\n                    }\n                printf(\"\\n Enter the second matrix\");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat2[i][j]);\n                    }\n        \n                Sum(mat1,mat2,mat3);\n                \n                printf(\"\\n The Resultant matrix is \\n\");\n                Display(mat3);\n                \n                free(mat1);\n                free(mat2);\n                free(mat3);\n                }\n        else\n        printf(\"Please enter same row & col of the two matrix ...\");\n    return 0;\n    }   \n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\n#include<malloc.h>\nint r,c,m,n;\nvoid Display(int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<n;j++)\n            printf(\"%-3d \",mat3[i][j]);\n        printf(\"\\n\");\n        }\n    }\nint **Product(int **mat1,int **mat2,int **mat3)\n    {\n    int i,j,k;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<n;j++)\n                {\n                mat3[i][j]=0;\n                for(k=0;k<c;k++)\n                    mat3[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n        }\n    return mat3;\n    }\nint main()\n    {\n        int i,j;\n        int **mat1,**mat2,**mat3;\n        printf(\"Enter the row & col. of the first matrix \");\n        scanf(\"%d%d\",&r,&c);\n        printf(\"Enter the row & col. of the second matrix \");\n        scanf(\"%d%d\",&m,&n);\n        if(c==m)\n            {\n                mat1=(int **)malloc(r*sizeof(int *));       \n                                                \n                mat2=(int **)malloc(m*sizeof(int *));\n            \n                mat3=(int **)malloc(r*sizeof(int *));       \n        \n                for(i=0;i<r;i++)\n                mat1[i]=(int *)malloc(c*sizeof(int));   \n            \n                for(j=0;j<m;j++)\n                mat2[j]=(int *)malloc(n*sizeof(int));\n        \n                for(j=0;j<r;j++)\n                mat3[j]=(int *)malloc(n*sizeof(int));\n        \n                printf(\"\\n Enter the first matrix \");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat1[i][j]);\n                    }\n                printf(\"\\n Enter the second matrix\");\n                for(i=0;i<m;i++)\n                    {\n                    for(j=0;j<n;j++)\n                    scanf(\"%d\",&mat2[i][j]);\n                    }\n        \n                Product(mat1,mat2,mat3);\n                \n                printf(\"\\n The Resultant matrix is \\n\");\n                Display(mat3);\n                \n                free(mat1);\n                free(mat2);\n                free(mat3);\n                }\n        else\n        printf(\"OOPS!!Multiplication not possible..\");\n    return 0;\n    }   \n\n"}
{"target":"2security","func":"#include<stdio.h>\nint Mystrlen(char *str)\n    {\n        char *s=str;\n        while(*str)\n            str++;\n        return str-s;\n    }\nchar *Mystrrev(char *str)\n    {\n        char *begin,*end,temp;\n        char *rev;\n        int n=Mystrlen(str),i;\n        \n        begin=str;\n        end=str;\n        for(i=0;i<n-1;i++)\n            end++;\n        \n        for(i=0;i<n\/2;i++)\n            {\n                temp=*end;\n                printf(\"%c \",*end);\n                *end=*begin;\n                *begin=temp;\n                begin++;\n                end--;\n            }\n        return str;\n    }\nint main()\n    {\n        char str[30],*t;\n        printf(\"\\n Enter the string\");\n        scanf(\"%s\",str);\n        \n        printf(\"\\n Reverse of the string is:: \");\n        t=Mystrrev(str);\n        puts(t);\n    }\n\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\n\nvoid Mysort(int *a,int n)\n    {\n    int i,j,temp;\n    for(i=0;i<n-1;i++)\n        {\n        for(j=0;j<n-i-1;j++)\n            {\n            if(*(a+j)>*(a+j+1)) \n                {\n                    temp=*(a+j);\n                    *(a+j)=*(a+j+1);\n                    *(a+j+1)=temp;\n                }\n            }\n        }\n    }\nint main()\n    {\n        int *a,m,i;\n        \n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        \n        a=(int *)malloc(m*sizeof(int *));\n        \n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&*(a+i));\n        \n        Mysort(a,m);\n        \n        printf(\"\\n After sorting:: \");\n        for(i=0;i<m;i++)\n            printf(\"%d \",*(a+i));\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\n\nint* Myreturn(int *a,int n)\n    {\n    int i;\n    for(i=0;i<n;i++)\n        *(a+i)=2*(*(a+i));\n\n    return a;\n    }\nint main()\n    {\n        int *a,m,i;\n        \n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        \n        a=(int *)malloc(m*sizeof(int *));\n        \n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&*(a+i));\n        \n        Myreturn(a,m);\n        \n        printf(\"\\n Result:: \");\n        for(i=0;i<m;i++)\n            printf(\"%d \",*(a+i));\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\nvoid Display(int *a,int n)\n    {\n        int i;\n        for(i=0;i<n;i++)\n            printf(\"%d \",*(a+i));\n    }\nint* Reverse(int *a,int n)\n    {\n        int i,j=0,*b;\n        b=(int *)malloc(n*sizeof(int *));\n        for(i=n-1;i>=0;i--)\n        {\n            *(b+j)=*(a+i);\n            j++;\n        }       \n        return b;\n    }\nint main()\n    {\n        int *a,m,i;\n        \n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        \n        a=(int *)malloc(m*sizeof(int *));\n        \n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&a[i]);\n            \n        printf(\"\\n Before reverse\");\n        printf(\"\\n Array:\");\n        Display(a,m);\n    \n        Reverse(a,m);  \n        \n        printf(\"\\n After reverse\");\n        printf(\"\\n Array:\");\n        Display(Reverse(a,m),m);\n        \n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\nvoid Display(int *a,int n)\n    {\n        int i;\n        for(i=0;i<n;i++)\n            printf(\"%d \",*(a+i));\n    }\nint Search(int *a,int n,int item)\n    {\n        int i,j=0,pos=0;\n        for(i=0;i<n;i++)\n            {\n            if(*(a+i)==item)\n                {\n                    pos=i+1;\n                    break;\n                }\n            }       \n        return pos;\n    }\nint main()\n    {\n        int *a,m,i,item;\n        \n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        \n        a=(int *)malloc(m*sizeof(int *));\n        \n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&a[i]);\n        \n        printf(\"\\n Enter the item to found\");\n        scanf(\"%d\",&item);\n        \n        i=Search(a,m,item);\n        \n        if(i==0)\n            printf(\"\\n %d is not found\",item);\n        else\n            printf(\"\\n %d is found at position %d\",item,i);\n    \n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\nvoid Display(int **a,int m,int n)\n    {\n        int i,j;\n        for(i=0;i<m;i++)\n            {\n                for(j=0;j<n;j++)\n                    printf(\"%d \",*(*(a+i)+j));\n                printf(\"\\n\");\n            }\n    }\n\nint main()\n    {\n        int **a,m,n,i,j,item;\n        \n        printf(\"\\n Enter row and column of 2D array:: \");\n        scanf(\"%d%d\",&m,&n);\n        \n        a=(int **)malloc(m*sizeof(int **));\n        for(i=0;i<m;i++)\n            a[i]=(int *)malloc(n*sizeof(int));  \n        \n        printf(\"\\n Enter %d elements of array::\",m*n);\n        for(i=0;i<m;i++)\n        for(j=0;j<n;j++)\n            scanf(\"%d\",(*(a+i)+j));\n        \n        printf(\"\\n The entered 2D-array is::\\n\");\n        Display(a,m,n);\n        \n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n        int n,i,j,k,c=1;\n        printf(\"Enter no of rows\");\n        scanf(\"%d\",&n);\n        \n        for(i=1;i<=2*n-1;i++)\n            {\n                if(i<=n)\n                    {\n                        for(j=1;j<=n-i;j++)\n                            printf(\" \");\n                            \n                        for(j=1;j<=2*i-1;j++)\n                            printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=i-n;j>=1;j--) \n                        printf(\" \");\n                        \n                    for(j=1;j<=2*(i-2*c)-1;j++)\n                        printf(\"*\");\n                    c++;\n                    }\n            printf(\"\\n\");\n            }\n    printf(\"\\n\\n\");\n    return 0;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j,k,f;\n    \n    printf(\"Enter how many columns\");\n    scanf(\"%d\",&n);\n    f=1;\n    \n    for(i=1;i<=2*n-1;i++)\n        {\n            for(j=1;j<=f;j++)   \n                printf(\"*\");\n            if(i<n)\n                f++;\n            else\n                f--;\n        printf(\"\\n\");\n        }\n        \n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n        int i,j,k=0,n;\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        \n        for(i=n\/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                for(j=1;j<=2*i-1;j++)\n                    printf(\"*\");\n                printf(\"\\n\");\n            }\n\n        printf(\"\\n\");\n        return 0;\n        \n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint main()\n    {\n        int i,j,k=0,n,m;\n        char name[20];\n        printf(\"Enter Name\");\n        gets(name);\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        m=strlen(name);\n        \n        for(i=n\/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                if(i==n)\n                    {\n                    for(j=1;j<=(n*2-m)\/2;j++)   \n                        printf(\"*\");\n                    printf(\"%s\",name);\n                    for(j=1;j<(n*2-m)\/2;j++)    \n                        printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=1;j<=2*i-1;j++)\n                        printf(\"*\");    \n                    }\n                printf(\"\\n\");\n            }\n        printf(\"\\n\");\n        return 0;\n        \n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint main()\n    {\n        int n,i,j,k;\n        printf(\"Enter no of rows\");\n        scanf(\"%d\",&n);\n        \n        for(i=1;i<=n;i++)\n            {\n                for(j=n;j>=i;j--)\n                    printf(\"*\");\n                for(j=2;j<2*i;j++)\n                    printf(\" \");\n                for(j=1;j<=n-i+1;j++)\n                    printf(\"*\");\n                printf(\"\\n\");\n            }\n        for(i=1;i<=n;i++)\n        {\n            for(j=1;j<=i;j++)\n                printf(\"*\");\n            for(j=1;j<=2*n-2*i;j++)\n                printf(\" \");\n            for(j=1;j<=i;j++)\n                printf(\"*\");\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n    return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n-i+1;j++)\n            {\n            if(i==1||j==n-i+1||j==1)    \n                printf(\"*\");\n            else \n                printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j,k;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=n;i>=1;i--)\n        {\n        for(j=n;j>i;j--)\n            printf(\" \");\n        for(j=1;j<=2*i-1;j++)\n            {\n                if(j==2*i-1||j==1||i==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(j=1;j<=i;j++)\n            {\n                if(i==j||i==n||j==1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        \n        for(j=1;j<=n;j++)\n            {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j,k;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(k=1;k<=2*i-1;k++)\n            {\n                if(k==1||i==n||k==2*i-1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1; i<=n; i++)\n            {\n            for(j=1; j<=n-i; j++)\n                    printf(\" \");\n    \n            for(j=1;j<=n;j++)\n                {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else    \n                    printf(\" \");\n                }\n            printf(\"\\n\");\n            }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=i;j++)\n            {\n                if(j==1||j==i||i==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n;j++)   \n            {\n            if(i==1||i==n||j==1||j==n)\n                printf(\"*\");\n            else\n                printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }\n\n    \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n;j++)   \n            {\n            if(i==1||i==n||j==1||j==n||i==j||i+j==n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j,k,f;\n    \n    printf(\"Enter how many columns\");\n    scanf(\"%d\",&n);\n    f=1;\n    \n    for(i=1;i<=2*n-1;i++)\n        {\n            \n            if(i<=n)\n                {\n                f++;\n                for(j=1;j<=n-i;j++) \n                    printf(\" \");\n                }\n            else\n                {\n                f--;\n                for(j=1;j<=i-n;j++) \n                    printf(\" \");\n                }\n            for(j=1;j<f;j++)    \n                printf(\"*\");\n        printf(\"\\n\");\n        }\n        \n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        \n        for(j=1;j<=n;j++)\n            printf(\"*\");\n            \n        printf(\"\\n\");\n        \n        }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>       \n\nint main()\n    {\n    int n,i,j;\n    \n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    \n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=2*n-1;j++)   \n            {\n            if(i+j>=n+1&&i+j<2*n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n\n    printf(\"\\n\\n\");\n        return 0;\n    }   \n\n\n\n\n\n\n\n"}
{"target":"2security","func":"#include<stdio.h>\nint Noofword(char *str)\n    {\n    int i=0,word=0;\n    char prevchar='\\0';\n    while(1)\n        {\n        if(str[i]==' '||str[i]=='\\n'||str[i]=='\\t'||str[i]=='\\0')   \n            {\n                if(prevchar!=' ' && prevchar!='\\n'&&prevchar!='\\t'&&prevchar!='\\0')\n                word++;\n            }\n        prevchar=str[i];\n        if(str[i]=='\\0')\n            break;\n        else \n            i++;\n        }\n    return word;\n    }\nint main()\n    {\n        char str[20];\n        int i=0,v=0,c=0;\n        printf(\"\\n Enter the string:: \");\n        gets(str);\n        \n        printf(\"\\n No of word in the string is =%d\",Noofword(str));\n    \n        return 0;\n    }\n    \n    \n"}
{"target":"2security","func":"#include<stdio.h>\n#include<malloc.h>\nint Mystrlength(char *str)\n    {\n        int i;\n        for(i=0;i<str[i]!='\\0';i++);\n        return i;   \n    }\nchar * ReverseWord(char str[])\n    {\n        int d,s,k=0,t,j;\n        char *temp= malloc(Mystrlength(str));\n        s=Mystrlength(str)-1;\n        d=Mystrlength(str)-1;\n        while(s>0)\n            {\n            if(str[s]== ' ')    \n                {\n                    for(j=s+1;j<=d;j++)\n                        {\n                            temp[k]=str[j];     \n                            k++;\n                        }\n                    temp[k++]=' ';\n                    d=s-1;\n                }\n            s--;\n            }\n        for(j=0;j<=d;j++)\n            {\n                temp[k]=str[j]; \n                k++;    \n            }\n        temp[k]= '\\0';\n        return temp;\n    }\nint main()\n    {\n        char str[20],*temp;\n        int n,s,d,k=0;\n        printf(\"\\n Enter the string:: \");\n        gets(str);\n        \n        temp=ReverseWord(str);\n        printf(\"Reverse Ordered words is::%s\",temp);\n    \n        return 0;\n    }\n    \n    \n"}
{"target":"2security","func":"#include<stdio.h>\n#define size 255\nint MyMax(int a[],int n)\n    {\n        int i,max=0;\n        for(i=0;i<n;i++)\n            {\n                if(a[i]>a[max])\n                    {\n                        max=i;\n                    }   \n            }\n        printf(\"%d\",max);\n        return max;\n    }\n\nint main()\n    {\n        int freq[size],i,c=0,t;\n        char str[size],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        \n        for(i=0;i<size;i++)\n                freq[i]=0;\n                \n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                t=(int)str[i];\n                freq[t]=freq[t]+1;\n            }\n                \n        \n        for(i=0;i<size;i++)\n            printf(\"%d \",freq[i]);\n            \n        i=MyMax(freq,size);\n        printf(\"\\n No of occurrence of '%c' is =%d\",i,freq[i]);\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#define size 255\nint MyMin(int a[],int n)\n    {\n        int i,min=0;\n        for(i=0;i<n;i++)\n            {\n                if(a[i]!=0)\n                    {\n                    if(a[i]<a[min]||a[min]==0)\n                        min=i;\n                    }\n                    \n            }\n        return min;\n    }\n\nint main()\n    {\n        int freq[size],i,c=0,t;\n        char str[size],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        \n        for(i=0;i<size;i++)\n                freq[i]=0;\n                \n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                t=(int)str[i];\n                freq[t]=freq[t]+1;\n            }\n                \n        \n        for(i=0;i<size;i++)\n            printf(\"%d \",freq[i]);\n            \n        i=MyMin(freq,size);\n        printf(\"\\n No of occurrence of '%c' is =%d\",i,freq[i]);\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint main()\n    {\n        int i,pos,j;\n        char str[30],temp[30],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        \n        printf(\"\\n Enter the character\");\n        scanf(\"%c\",&ch);\n        \n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        break;\n                    }\n            }\n        for(j=0;i<str[j]!='\\0';j++);\n        \n        for(i=pos;i<=j-1;i++)\n            str[i]=str[i+1];\n            \n        str[i]='\\0';\n        \n        printf(\"%s\",str);\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint main()\n    {\n        int i,pos;\n        char str[30],ch,rech;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        \n        printf(\"\\n Enter character to replace\");\n        ch=getchar();\n        \n        getchar();\n        \n        printf(\"\\n Enter character to replace with\");\n        rech=getchar();\n        \n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        str[pos]=rech;\n                        break;\n                    }\n            }\n        \n        printf(\"\\n After replace %s\",str);\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nvoid prefixSuffixArray(char* pat, int M, int* pps) {\n   int length = 0;\n   pps[0] = 0;\n   int i = 1;\n   while (i < M) {\n      if (pat[i] == pat[length]) {\n         length++;\n         pps[i] = length;\n         i++;\n      } else {\n         if (length != 0)\n         length = pps[length - 1];\n         else {\n            pps[i] = 0;\n            i++;\n         }\n      }\n   }\n}\nvoid KMPAlgorithm(char* text, char* pattern) {\n   int M = strlen(pattern),c=0;\n   int N = strlen(text);\n   int pps[M];\n   prefixSuffixArray(pattern, M, pps);\n   int i = 0;\n   int j = 0;\n   while (i < N) {\n      if (pattern[j] == text[i]) {\n         j++;\n         i++;\n      }\n      if (j == M) {\n         c++;\n         j = pps[j - 1];\n      }\n      else if (i < N && pattern[j] != text[i]) {\n         if (j != 0)\n         j = pps[j - 1];\n         else\n         i = i + 1;\n      }\n   }\nprintf(\"\\n No of matching occurence is:=%d\",c);\n}\nint main() {\n   char text[100];\n   char pattern[100];\n   printf(\"\\n Enter the string \");\n   gets(text);\n   printf(\"\\n Enter the string \");\n   gets(pattern);\n  \n   KMPAlgorithm(text, pattern);\n   return 0;\n}\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint Mystrlen(char *str)\n    {\n        int i;\n        for(i=0;i<str[i]!=0;i++);\n        \n        return i;\n        \n    }\n\nchar* Trimleading(char *str)\n    {\n        int i=0,j,c=0,n;\n        char *temp;\n        n=Mystrlen(str);\n        \n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c++;\n            }\n    \n        for(j=c;j<=n-1;j++)\n            {\n                str[i]=str[j];  \n                \n                i++;\n            }\n        str[i]='\\0';\n        \n        return str;\n    }\n\nint main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string\");\n        gets(str);\n        \n        printf(\"\\n Before trimming::\");\n        printf(\"%s\",str);\n        \n        printf(\"\\n After trimming::\");\n        printf(\"%s\",Trimleading(str));\n        \n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint Mystrlen(char *str)\n    {\n        int i;\n        for(i=0;i<str[i]!=0;i++);\n        \n        return i;\n        \n    }\n\nchar* Trim(char *str)\n    {\n        int i=0,j,c=0,n,d;\n        char *temp;\n        n=Mystrlen(str);\n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c++;\n            }\n        for(j=c;j<=n-1;j++)\n            {\n                str[i]=str[j];  \n                \n                i++;\n            }\n        str[i]='\\0';\n        c=Mystrlen(str)-1;\n        \n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c--;\n            }\n        str[c+1]='\\0';\n        \n        return str;\n        return str;\n    }\n\nint main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string:\");\n        gets(str);\n        \n        printf(\"\\n Before trimming:\");\n        printf(\"%s\",str);\n        \n        printf(\"\\n After  trimming:\");\n        printf(\"%s\",Trim(str));\n        printf(\"Good bye\");\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\n#include<string.h>\nint Mystrlen(char *str)\n    {\n        int i;\n        for(i=0;i<str[i]!=0;i++);\n        \n        return i;\n        \n    }\n\nchar* RemoreExSpace(char *str)\n    {\n        int i, j;\n    char * newString;\n    i=Mystrlen(str);\n    newString = (char *)malloc(i);\n\n    i = 0;\n    j = 0;\n\n    while(str[i] != '\\0')\n    {\n        \n        if(str[i] == ' ')\n        {\n            newString[j] = ' ';\n            j++;\n\n            \n            while(str[i] == ' ')\n                i++;\n        }\n\n        newString[j] = str[i];\n\n        i++;\n        j++;\n    }\n    \n    newString[j] = '\\0';\n\n    return newString;\n    }\n\nint main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string:\");\n        gets(str);\n        \n        printf(\"\\n Before removal of extra space:\");\n        printf(\"%s\",str);\n        \n        printf(\"\\n After removal of extra space:\");\n        printf(\"%s\",RemoreExSpace(str));\n        printf(\"Good bye\");\n        return 0;\n    }\n"}
{"target":"2security","func":"#include<stdio.h>\nint Mystrcompare(char *str1,char *str2)\n    {\n    int m=Mystrlen(str1),flag=0,i;\n    int n=Mystrlen(str2);\n    \n    if(m>n)\n        return m-n;\n    else if(m<n)\n        return m-n;\n    else \n        {\n        for(i=0;i<m;i++)\n            {\n                if(str1[i]!=str2[i])\n                    {\n                        flag=1;\n                        break;\n                    }\n            }\n            if(flag==0)\n                return 0;\n            else \n                return 1;\n        }\n    \n    }\nint Mystrlen(char *str)\n    {\n        int i;\n        for(i=0;i<str[i]!='\\0';i++);\n        \n        return i;\n    }\nint main()\n    {\n        char str1[20],str2[20];\n        int i=0,len1,j=0,k;\n        printf(\"\\n Enter the first string\");\n        gets(str1);\n        printf(\"\\n Enter the second string\");\n        gets(str2);\n        \n        \n        printf(\"\\n Mystrcompare(%s,%s)=%d\",str1,str2,Mystrcompare(str1,str2));\n        return 0;\n    }\n    \n    \n"}
{"target":"4rslanismet","func":"\n\n\n\n#include <stdio.h>\n\nint main ()\n{\n    \n    int a,b;\n    \n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    \n    \n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n    \n    if(a<b)\n        printf(\"a b'den k\u00fc\u00e7\u00fckt\u00fcr\");\n        \n    \n    else if(a>b)\n        printf(\"a b'den b\u00fcy\u00fckt\u00fcr\");\n    \n    else \n        printf(\"a b ye e\u015fittir\");\n            \n    \n    return 0;\n    }\n"}
{"target":"4rslanismet","func":"Definition Function \n---------------------------\nnon void \n\nfunction_type function_name (parametres)  (int x, char y) \n{\n    commands;\n    return x ;\n}\n\n\nvoid -> geriye de\u011fer d\u00f6nd\u00fcrmeyen fonksiyonlar\n\nvoid  (int x, char y) \n{\n    commands;\n    printf(\"asddsa\");\n}\n\n* -> pointer d\u00f6nd\u00fcren\n\nint * addr  (int x, char y) \n{\n    commands;\n    printf(\"asddsa\");\n}\n\n\n\n\nint x (int a, int b)\n{\n    int sum =a+b;\n    return sum;\n}\n\n\nint toplam (int a, int b)\n{\n    int sum =a+b;\n    return sum;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmain -> ana fonksiyon\n\nCall Function \n---------------------------\n\nfunction_type function_name (parametres)\n{\n    commands;\n}\n\n\n\nvoid main ()\n{\n    function_name(paramatres); \n}\n\n\n\n"}
{"target":"4rslanismet","func":"\n\n\n\n\n#include <stdio.h> \n\n#define BOYUT 11\n\nint mutDeger(int x,int y);\n\nint main()\n{\n    \n    int toplam=0,i,arr[BOYUT];\n        \n    for(i=0;i<BOYUT;i++)\n    {\n        printf(\"%d. de\u011feri giriniz:\",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n\n    arr[BOYUT]=0;\n\n    for(i=0;i<BOYUT;i+=2)\n    {   \n        toplam+=mutDeger(arr[i],arr[i+1]);\n\n    } \n     \n     printf(\"%d\\n\",toplam);\n}\n\n\nint mutDeger(int x,int y)\n{\n    x+=y;\n\n    if(x<0)\n    {\n        x*=-1;\n\n        printf(\"%d\\n\",x);\n    } \n\n    else\n        printf(\"%d\\n\",x);\n\n    return x;\n}"}
{"target":"4rslanismet","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n\nint faktoriyel(int num);\n\n\nint main ()\n{\n    int num,fact=0;\n\n    printf(\"fakt\u00f6riyelini \u00f6\u011frenmek istedi\u011finiz say\u0131y\u0131 giriniz:\\n\");\n    scanf(\"%d\",&num);\n\n    fact=faktoriyel(num);\n\n    if(fact>0)\n        printf(\"\\n[%d]! = [%d]\\n\",num,fact);\n   \nreturn 0;\n\n}\n\nint faktoriyel(int num)\n{\n    int res=0;\n\n    if(num <= 0)\n        printf(\"\\nerror !\\n\");\n    \n\n    else if (num==1)\n        return num;\n\n    else\n    {\n        res=num*faktoriyel(num-1);  \n        \n    }   \n   return -1; \n}"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h>\n\nint i=1; \n\nvoid sum (int num,int n);\n\nint main()\n{\n    int num,n;\n\n    printf(\"artt\u0131rmak istedi\u011finiz de\u011feri giriniz:\\n\");\n    scanf(\"%d\",&n);\n\n    printf(\"hangi de\u011ferden itibaren artt\u0131rmak istedi\u011finizi giriniz:\\n\");\n    scanf(\"%d\",&num);\n    \n    sum(num,n);\n        \n}\n\nvoid sum (int num,int n)\n{   \n    \n    num++;\n    i++;\n\n    if(i <= n)\n    {\n       sum(num,n);    \n    }\n\n    else\n    {\n         printf(\"\\nSum is %d\\n\",num);\n    }   \n\n\n        \n}\n"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h>\n\n#define SIZE 11\n\nvoid okuYaz (void);\n\nint main()\n{\n   okuYaz();\n\n   return 0;\n\n}\n\nvoid okuYaz (void)\n{\n    int num[SIZE], i;\n\n    printf(\"%s\",\"okul numaran\u0131z\u0131 giriniz:\");\n    \n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&num[i]);\n\n    printf(\"%s\\n\",\"okul numaran\u0131z:\");\n\n    for(i=0;i<SIZE;i++)\n        printf(\"%d\",num[i]);\n}"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\n\nint fibonacci(int n);\n\nint main()\n{\n    int n,i=1,c;\n\n    printf(\"serinin gitmesini istedi\u011finiz n de\u011ferini giriniz:\\n\");\n    scanf(\"%d\",&n);\n\n    printf(\"Fibonacci dizisi\\n\");\n\n    for(c=1;c<=n;c++) \n    {\n        printf(\"%d\\n\",fibonacci(i));    \n        i++;       \n    }\n\n return 0;   \n\n}\n\nint fibonacci(int n)\n{\n    if(n==0)\n     return 0;\n\n    else if (n==1)  \n        return 1;\n    \n    else    \n        return(fibonacci(n-1)+fibonacci(n-2));  \n                   \n               \n} \n\n\n\n1  1   2 "}
{"target":"4rslanismet","func":"\n\n#include <stdio.h>\n\n#define SIZE 11\n\nvoid yaz (int arr[SIZE]);\nint oku (int arr[SIZE]);\n\n\nvoid main (void)\n{\n    int numara[SIZE];\n\n    printf(\"%s,\\n\",\"okul numaran\u0131z\u0131 giriniz:\");\n\n    numara=oku(numara);\n    \n    \n\n}\n\n\nvoid yaz (int arr[SIZE])\n{\n    int i;\n    \n    for(i=0;i<SIZE;i++)\n        printf(\"%d\",arr[i]);\n\n}\n\n\nint oku (int arr[SIZE])\n{\n    int i;\n\n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&arr[i]);\n\n    return arr;    \n}"}
{"target":"4rslanismet","func":"\n\n\n\n#include <stdio.h> \n\nint main() \n{ \n    int array[2]; \n \n    \n    \n    printf(\"element 0: %d\\n\",array[0]); \n    printf(\"element 1: %d\\n\",array[1]);\n    printf(\"%p\\n\",&array[0]);\n    printf(\"%p\\n\",&array[1]);\n\n    printf(\"element 2: %d\\n\", array[2]);\n    printf(\"%p\\n\",&array[2]);\n    printf(\"element 3: %d\\n\", array[3]);\n    printf(\"%p\\n\",&array[3]);\n    printf(\"element -1: %d\\n\", array[-1]);\n    printf(\"%p\\n\",&array[-1]);\n    \n    \n    \n        \n    return 0; \n\n}\n"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h> \n#include <math.h>\n\n#define SIZE 5\n\nint binaryToDecimal(int arr[]);\n\nint main()\n{\n    int i,binaryNum[SIZE],decimal;\n      \n    printf(\"%s\\n\",\"en fazla 5 basamak olmak \u00fczere binary say\u0131y\u0131 giriniz:\");\n    \n    for(i=SIZE;i>0;i--)\n        scanf(\"%d\",&binaryNum[i]);\n\n    decimal=binaryToDecimal(binaryNum);\n\n    printf(\"%s\",\"girilen binary de\u011fer:\");\n\n    for(i=SIZE;i>0;i--)\n        printf(\"%d\",binaryNum[i]);\n\n    printf(\"\\ndecimal say\u0131:%d\",decimal);\n\n    return 0;\n}\n\nint binaryToDecimal(int arr[])\n{\n    int i,j=4,decimalNum=0;\n\n    for(i=SIZE;i>0;i--)\n    {\n        decimalNum+=pow(2,j)*arr[i];\n        j--;\n    }\n     \n\n    \n   return decimalNum;\n}"}
{"target":"4rslanismet","func":"#include<stdio.h>\n\n\nint ekok(int x, int y);\n           \n\nint main()\n{\n  int num1,num2,ek=0;\n\n  printf(\"%s\\n\",\"EKOK almak istedi\u011finiz iki pozitif tam say\u0131 giriniz:\");\n  scanf(\"%d%d\",&num1,&num2);\n\n  if(num1>num2)\n    ek=ekok(num1,num2);\n\n  else\n    ek=ekok(num2,num1);\n\n  printf(\"girilen de\u011ferlerin EKOK u:%d\\n\",ek);  \n\n  return 0;\n}\n\nint ekok(int x, int y)\n{\n  static int temp=1;\n  \n    if(temp%y==0 && temp%x==0)  \n      return temp;\n    \n    temp++;\n    ekok(x,y);\n\n    return(temp);\n\n}"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\n#define SIZE 5\n \nint tabanDonusumu(int arr[SIZE]);\nint ustAlma(int ust);\n\nint main (void)\n{\n    int i,binary[SIZE];\n\n    printf(\"%s\\n\",\"onluk tabana d\u00f6n\u00fc\u015ft\u00fcrmek istedi\u011finiz binary de\u011ferini giriniz:\");\n\n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&binary[i]);\n\n    printf(\"binary say\u0131:\");\n\n    for(i=0;i<SIZE;i++)\n        printf(\"%d\",binary[i]);\n\n    printf(\"\\n onluk bi\u00e7im:%d\",tabanDonusumu(binary));\n\n}\n\nint tabanDonusumu(int arr[SIZE])\n{\n    int i,j=0,ust,decimal;\n\n    for(i=SIZE-1;i>0;i--,j++)\n    {\n        ust=ustAlma(j);\n        decimal+=ust*arr[i];\n\n    }\n    \n    return decimal;\n\n}\n\nint ustAlma(int ust)\n{\n    int i,deger=1;\n\n    for(i=1;i<=ust;i++)\n        deger*=2;  \n\n    if(ust==0)\n    deger=1;\n    \n    return deger;\n}\n\n\n\n\n\n  \n"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\nint asalKontrol (int x,int y);\n\nint main()\n{\n    int asal,num1;\n\n    printf(\"pozitif bir tam say\u0131 giriniz:\\n\");\n    scanf(\"%d\",&num1);\n\n    if(num1==1)\n    {\n        printf(\"1 asal de\u011fildir\\n\");\n        \n        return 0;    \n    }\n\n    asal=asalKontrol(num1,(num1\/2));  \n\n    if(asal==1)\n        printf(\"%d asald\u0131r\\n\",num1);\n\n    else\n         printf(\"%d asal de\u011fildir\\n\",num1);\n\n   return 0;     \n}\n\nint asalKontrol (int x,int y)  \n{                                           \n    if(y==1)\n        return 1;\n    else\n    {\n        if(x%y==0)  \n            return 0;\n\n        else\n            asalKontrol(x,y-1);    \n    }    \n\n}"}
{"target":"4rslanismet","func":"\n\n\n\n\n   \n\n\n\n#include <stdio.h>\n\nint main()\n{\n   \n\n    int dizi[10]={1,23,4,534,123,564,89,34,76,0};\n\n    int i,j,temp;\n\n   for(j=0;j<10;j++)\n   {\n        for(i=0;i<10;i++)\n        {   \n            if(dizi[i]>dizi[i+1])\n            {\n            temp=dizi[i];\n            dizi[i]=dizi[i+1];\n            dizi[i+1]=temp;\n            }\n        }\n   }   \n    printf(\"s\u0131ralanm\u0131\u015f dizi:\\n\");\n    \n    for(i=0;i<10;i++)\n    printf(\"%d\\n\",dizi[i]);\n\n\n\n\n    \n    \n\n\n\n}"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\n\n\n\n\nint main ()\n{\n\n int num1=1 , num2=1 , sum=0;   \n int n,i;\n\n printf(\"fibonacci dizisinin ka\u00e7 eleman\u0131n\u0131 yazd\u0131rmak istersiniz:\");\n scanf(\"%d\",&n);\n\n if(n<0)\n {\n     printf(\"hatal\u0131 giri\u015f\\n\");\n     return 1;\n }\n\n for(i=0;i<n;i++)\n {\n\n        if(n==1)\n    { printf(\"%d\\n\",num1);}\n\n    else if(i==0)\n    { printf(\"%d %d \",num1,num2);\n      if(n==2)\n            return 0;\n\n    }\n\n    else \n    {\n     sum=num1+num2;\n     num1=num2;\n     num2=sum;\n     printf(\"%d \",sum);\n\n    }\n\n\n            \n                    \n\n}   \n\n    return 0;\n\n\n\n\n}\n"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\n\n\n\n\nint main ()\n{\n\n int num1=1 , num2=1 , sum=0;   \n int n,i;\n\n printf(\"fibonacci dizisinin ka\u00e7 eleman\u0131n\u0131 yazd\u0131rmak istersiniz:\");\n scanf(\"%d\",&n);\nnum2\n\n for(i=0;i<n;i++)\n {\n\n        if(n==1)\n    { printf(\"%d\\n\",num1);}\n\n    else if(i==0)\n    { printf(\"%d %d \",num1,num2);\n      if(n==2)\n            return 0;\n\n    }\n\n    else \n    {\n     sum=num1+num2;\n     num1=num2;\n     num2=sum;\n     printf(\"%d \",sum);\n\n    }\n\n\n            \n                    \n\n}   \n\n    return 0;\n}\n\n\n\n\n\n\n\n"}
{"target":"4rslanismet","func":"\n\n\n\n#include <stdio.h>\n\nint main ()\n{\n    \n    int n;\n    \n    printf(\"ders notunuzu 0-100 aras\u0131nda giriniz:\");\n    scanf(\"%d\",&n);\n    \n    if (n<=100 && n>=0)\n    {\n            \n        if(90<=n)\n            printf(\"harf notunuz A\");\n    \n    \n        else if(80<=n && n<90)\n            printf(\"harf notunuz B\");\n    \n    \n        else if(70<=n && n<80)\n            printf(\"harf notunuz C\");   \n        \n        else \n            printf(\"harf notunuz F\");\n    }\n    \n    else \n    {\n        printf(\"girilen de\u011fer tan\u0131ms\u0131z\");\n        return 1;\n    }\n    \n    return 0;\n    }\n"}
{"target":"4rslanismet","func":"\n\n\n\n#include <stdio.h>\n\nint main ()\n{\n    \n    int n;\n    \n    printf(\"ders notunuzu 0-100 aras\u0131nda giriniz:\");\n    scanf(\"%d\",&n);\n    \n            \n        if(90<=n && n<=100)\n            printf(\"harf notunuz A\");\n    \n    \n        else if(80<=n && n<90)\n            printf(\"harf notunuz B\");\n    \n    \n        else if(70<=n && n<80)\n            printf(\"harf notunuz C\");   \n        \n        else \n            {\n                if(0<=n && n<=100)\n                printf(\"harf notunuz F\");\n                \n                else \n                  printf(\"ge\u00e7ersiz not girildi\");\n            \n        }\n    \n    return 0;\n    }\n\n"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h>\n\nint main ()\n{\n    int a,b,c;\n    \n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    \n    \n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n\n\n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&c); \n    \n    \n    if(a<=b && a<=c) \n    {\n            printf(\"a b ve c ye e\u015fit veya k\u00fc\u00e7\u00fckt\u00fcr\");\n        }\n    \n    \n    if(a>=b && a>=c)\n        {\n            printf(\"a b ve c ye e\u015fit veya b\u00fcy\u00fckt\u00fcr\");\n        }\n    \n    return 0;\n    \n    \n    }\n"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h>\n\nint main ()\n{\n    \n    int a,b;\n    \n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    \n    \n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n    \n    if(a<b)\n        printf(\"a b'den k\u00fc\u00e7\u00fckt\u00fcr\");\n        \n    \n    if(a>b)\n        printf(\"a b'den b\u00fcy\u00fckt\u00fcr\");\n    \n    if(a==b)\n        printf(\"a b ye e\u015fittir\");\n            \n    \n    return 0;\n    }\n"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\nint main ()\n{\n    \n    \n    \n    int s1,s2,s3;\n    \n    printf(\"l\u00fctfen \u00fc\u00e7 tane say\u0131 giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    \n    if(s1<s2 && s1<s3)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s1);\n        \n    if(s2<s1 && s2<s3)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s2);\n    \n    if(s3<s1 && s3<s2)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s3);\n    \n    \n    \n    if(s1>s2 && s1>s3)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s1);\n        \n    \n    if(s2>s1 && s2>s3)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s2);   \n    \n    \n    if(s3>s1 && s3>s2)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s3);\n    \n    return 0;\n    \n    }\n"}
{"target":"4rslanismet","func":"\n#include <stdio.h>\n\n\nint main()\n{\n    \n    int max,min,s1,s2,s3;\n    \n    \n    printf(\"l\u00fctfen \u00fc\u00e7 tane say\u0131 giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    \n    \n    min=s1;\n    max=s1;\n    \n    if(max<s2)\n        max=s2;\n        \n    if(max<s3)\n        max=s3;\n        \n    \n    \n    if(min>s2)\n        min=s2;\n    \n    if(min>s3)\n        min=s3;\n        \n        \n    printf(\"en b\u00fcy\u00fck : %d\\nen k\u00fc\u00e7\u00fck: %d\",max,min);\n    \n    return 0;\n    }\n"}
{"target":"4rslanismet","func":"#include<stdio.h>\n\n#define BOYUT 2\n\nint main()\n{\n    int m1[BOYUT][BOYUT];\n    int m2[BOYUT][BOYUT];\n    int toplam[BOYUT][BOYUT];\n    int i,j;\n\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n        {\n            printf(\"%s\",\"de\u011fer giriniz:\\n\");\n            scanf(\"%d\",&m1[i][j]);\n        }\n\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n        {\n            printf(\"%s\",\"de\u011fer giriniz:\\n\");\n            scanf(\"%d\",&m2[i][j]);\n        }\n\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n            toplam[i][j]=m1[i][j] + m2[i][j];\n\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n            printf(\"toplam[%d][%d]=%d\\n\",i,j,toplam[i][j]);\n\n    return 0;\n\n}"}
{"target":"4rslanismet","func":"#include <stdio.h> \n\n\nint main()\n{\n    int n,i ; \n    int max,min,maxIndis,minIndis;\n    \n    \n\n    printf(\"%s\",\"dizinin boyutunu giriniz:\")   ;\n    scanf(\"%d\",&n);\n\n    int arr[n];\n\n    for(i=0;i<n;i++)\n    {\n        printf(\"%s\\n\",\"eleman giriniz:\");\n        scanf(\"%d\",&arr[i]);\n    }\n\n    max=min=arr[0];\n    maxIndis=minIndis=0;\n\n    for(i=1;i<n;i++)\n    {\n        if(min>arr[i])\n        {\n            min=arr[i];\n            minIndis=i;\n        }\n\n        if(max<arr[i])\n        {\n            max=arr[i];\n            maxIndis=i;\n        }\n    }\n\n    printf(\"en b\u00fcy\u00fck de\u011fer:%d\\nen b\u00fcy\u00fck de\u011fer s\u0131ras\u0131:%d\\n\",max,maxIndis+1);\n    printf(\"en k\u00fc\u00e7\u00fck de\u011fer:%d\\nen k\u00fc\u00e7\u00fck de\u011fer s\u0131ras\u0131:%d\\n\",min,minIndis+1);\n\n    return 0;\n}\n\n\n"}
{"target":"4rslanismet","func":"\n#include <stdio.h>\n\nint main()\n{\n  #define CITY  2\n  #define WEEK  7\n  \n  const int x=5;\n\n\n\n  int temperature[CITY][WEEK];\n\n  \n  for (int i = 0; i < CITY; ++i)\n  {\n    for (int j = 0; j < WEEK; ++j)\n    {\n      printf(\"City %d, Day %d: \", i + 1, j + 1);\n      scanf(\"%d\", &temperature[i][j]);\n    }\n  }\n  printf(\"\\nDisplaying values: \\n\\n\");\n\n  \n  for (int i = 0; i < CITY; ++i)\n  {\n    for (int j = 0; j < WEEK; ++j)\n    {\n      printf(\"City %d, Day %d = %d\\n\", i + 1, j + 1, temperature[i][j]);\n    }\n  }\n  return 0;\n}\n\n"}
{"target":"4rslanismet","func":"\n#include <stdio.h>\n\n\nint main ()\n\n{\n    \n    \n    \n    \n    int secim ;\n    \n    printf(\"1 giriniz\");\n    scanf(\"%d\",&secim);\n    \n    switch(secim)\n    {\n        \n        case(1):\n            {\n                int k=10;\n                \n                printf(\"b\u00f6l\u00fcm:%d \",k\/0);\n                \n            }\n            \n            break;\n            \n            \n            default:\n                printf(\"say\u0131n kullan\u0131c\u0131 neden 1 girmiyorsun ay\u0131p de\u011fil mi\");\n        \n    }\n    \n    \n    \n    return 0;\n        \n        \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    }\n"}
{"target":"4rslanismet","func":"\n\n\n#include <stdio.h>\n\n\nint main ()\n{\n    \n    \n    \n        int secim ;\n        \n        printf(\"\\t---MENU---\\t\\n1-selamla\\n2-toplama\\n3-teklik kontrol\u00fc\\n0-\u00e7\u0131k\u0131\u015f\\nsecim:\");\n        \n        scanf(\"%d\",&secim);\n        \n        switch (secim)\n        {\n            \n            case (0):\n                return 0;\n                \n                break;\n                \n            case (1):\n                printf(\"helllo world\\n\");\n                \n                break;\n            \n            case (2):\n                {\n                    int s1,s2;\n                    \n                    printf(\"iki say\u0131 giriniz:\");\n                    scanf(\"%d %d\",&s1,&s2);\n                \n                    printf(\"toplam: %d\\n\",s1+s2);\n                    \n                }\n                \n                break;\n                \n            case(3):\n                {\n                    int s1;\n                                    \n                    printf(\"bir say\u0131 giriniz\");\n                    scanf(\"%d\",&s1);\n                    \n                    if(s1%2==1)\n                        printf(\"say\u0131 tektir\\n\");\n                        \n                    else \n                        printf(\"say\u0131 \u00e7ifttir\\n\");\n                }\n                    \n                break;\n            \n            \n            \n            default:\n            {\n                printf(\"girilen i\u015flem ge\u00e7ersiz\\n\");\n                return 1;\n                \n            }\n            \n                \n            \n        }\n    \n    \n    \n    \n    return 0;\n    \n    \n    \n    \n    \n    }\n"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\nint main ()\n\n{\n    int i,k,l,yildiz;\n    \n    printf(\"boyut giriniz:\");\n    scanf(\"%d\",&yildiz);\n\n    if(yildiz<0)\n    {\n        printf(\"hatal\u0131 giri\u015f\");\n        return 1;\n    }\n\n    for(i=1;i<=yildiz;i++)\n    {\n         for(k=1;k<=yildiz-i;k++)\n             printf(\" \");\n     \n          for(l=1;l<=i;l++)\n              printf(\"*\");\n\n      printf(\"\\n\");\n     }\n\n\n    return 0;\n\n}\n"}
{"target":"4rslanismet","func":"#include <stdio.h>\n\n\nint main ()\n{\n    int i,j;\n    int yildiz;\n    \n    printf(\"l\u00fctfen boyut giriniz\");\n    scanf(\"%d\",&yildiz);\n       \n    if(yildiz<0)\n    {   \n      printf(\"hatal\u0131 giri\u015f yapt\u0131n\u0131z\");\n      return (1);\n    }\n    \n    for(i=0;i<yildiz;i++)\n    {\n      for(j=0;j<=i;j++)\n       printf(\"*\");\n\n      printf(\"\\n\");\n                \n\n    }\n\n\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint power();\nint main()\n{\n    int n;\n    int count = 0;\n    printf(\"enter a number:\");\n    scanf(\"%d\",&n);\n    int temp = n;\n    while(temp!=0)\n    {\n        count++;\n        temp\/=10;\n    }\n    printf(\"count:%d\\n\",count);\n    int rem = 0, sum = 0;\n    int t = n;\n    int i;\n    while(t!=0)\n    {\n        int mul=1;\n        rem = t%10;\n        for(i=1;i<=count;i++)\n        {\n            mul = mul*rem;\n        }\n        printf(\"Power of %d is : %d\\n\",rem,mul);\n        sum = sum+mul;\n        t = t\/10;   \n    }\n    if(sum == n)\n    {\n        printf(\"ARMSTRONG NUMBER\");\n    }\n    else\n    printf(\"NOT ARMSTRONG NUMBER\");\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint power();\nint main()\n{\n    int n;\n    int count = 0;\n    printf(\"enter a number:\");\n    scanf(\"%d\",&n);\n    int temp = n;\n    while(temp!=0)\n    {\n        count++;\n        temp\/=10;\n    }\n    printf(\"count:%d\\n\",count);\n    int rem = 0, sum = 0;\n    int t = n;\n    int i;\n    while(t!=0)\n    {\n        int mul=1;\n        rem = t%10;\n        for(i=1;i<=count;i++)\n        {\n            mul = mul*rem;\n        }\n        printf(\"Power of %d is : %d\\n\",rem,mul);\n        sum = sum+mul;\n        t = t\/10;   \n    }\n    if(sum == n)\n    {\n        printf(\"ARMSTRONG NUMBER\");\n    }\n    else\n    printf(\"NOT ARMSTRONG NUMBER\");\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint bubbleSort(int x[],int y);\nint main()\n{\n    int n;\n    printf(\"enter the no. of elements:\");\n    scanf(\"%d\",&n);\n    int arr[n];\n    int i;\n    printf(\"enter the elements:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    bubbleSort(arr,n);\n    return 0;\n}\nint bubbleSort(int x[],int y)\n{\n    int i,j,temp;\n    for(i=0;i<y;i++)\n    {\n        for(j=0;j<y-i-1;j++)\n        {\n            if(x[j] > x[j+1])\n            {\n                temp = x[j];\n                x[j] = x[j+1];\n                x[j+1] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<y;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<conio.h>\nint main()\n{\n    system(\"cls\");\n    int a[100];\n    int n,i,j,k;\n    printf(\"Enter the no. of elements:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(a[i] == a[j])\n            {\n                for(k=j;k<n;k++)\n                {\n                    a[k] = a[k+1];\n                }\n                n--;\n                j--;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    getch();\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[50], b[50];\n    printf(\"The elements are\\n\");\n    int i,j;\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        b[i] = -1;\n    }\n    for(i=0;i<n;i++)\n    {\n        int count = 1;\n        for(j=i+1;j<n;j++)\n        {\n            if(a[i] == a[j])\n            {\n                count++;\n                b[j] = 0;\n            }\n        }\n        if(b[i]!=0)\n        {\n            b[i] = count;\n        }\n    }\n    printf(\"Frequencies are:\\n\");\n    for(i=0;i<n;i++)\n    {\n        if(b[i]!=0)\n        {\n            printf(\"%d occurence is : %d\\n\", a[i],b[i]);\n        }\n    }\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint main()\n{\n    int l,n,i;\n    scanf(\"%d\",&l);\n    scanf(\"%d\",&n);\n    for(i=l;i<=n;i++)\n    {\n        if(i==1)\n     {\n        printf(\"One\\n\");\n     }\n    else if(i==2)\n     {\n        printf(\"Two\\n\");\n     }\n    else if(i==3)\n     {\n        printf(\"Three\\n\");\n     }\n    else if(i==4)\n     {\n        printf(\"Four\\n\");\n     }\n    else if(i==5)\n     {\n        printf(\"Five\\n\");\n     }\n    else if(i==6)\n     {\n        printf(\"Six\\n\");\n     }\n    else if(i==7)\n     {\n        printf(\"Seven\\n\");\n     }\n    else if(i==8)\n     {\n        printf(\"Eight\\n\");\n     }\n    else if(i==9)\n     {\n        printf(\"Nine\\n\");\n     }\n     else if(i%2==0)\n     {\n        printf(\"even\\n\");\n     }\n     else\n     printf(\"odd\\n\");\n    }\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint gateOperation();\nint main()\n{\n    int k,n;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &k);\n    gateOperation(n,k);\n    return 0;\n}\nint gateOperation(int n, int k)\n{\n    int i,j;\n    int maxAND = 0;\n    int maxOR = 0;\n    int maxEXP = 0;\n    for(i=1;i<=n;i++)\n    {\n        for(j=i+1;j<=n;j++)\n        {\n            if(((i & j) > maxAND) && ((i & j) < k))\n            {\n                maxAND = i & j;\n            }\n            if(((i | j) > maxOR) && ((i | j) < k))\n            {\n                maxOR = i | j;\n            }\n            if(((i ^ j) > maxEXP) && ((i ^ j) < k))\n            {\n                maxEXP = i ^ j;\n            }\n        }\n    }\n    printf(\"%d \\n%d\\n%d\", maxAND, maxOR, maxEXP);\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint add_at_beginning(struct node**temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the element:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = *temp1;\n    *temp1 = tempo;\n}\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc(sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(0\/1)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    add_at_beginning(&temp);\n    int count = 0;\n    printf(\"THE ELEMENTS PRESENT IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link;\n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint insert_at_end(struct node*temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the data:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = NULL;\n    temp1->link = tempo;\n}\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }   \n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE NODES?(0\/1)\");\n        scanf(\"%d\",&choice);\n    }\n    insert_at_end(temp);\n    temp = head;\n    int count = 0;\n    printf(\"THE ENTERED ELEMENTS IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link; \n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}\n\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint main()\n{\n    int n;\n    printf(\"enter the no. of coins:\");\n    scanf(\"%d\",&n);\n    int coins[n-1];\n    int i,count,j;\n    printf(\"The coins are:\\n\");\n    for(i=0;i<n-1;i++)\n    {\n        scanf(\"%d\",&coins[i]);\n    }\n    for(i=0;i<n-1;i++)\n    {                                        \n        count = 0;\n        for(j=0;j<n-1;j++)\n        {\n            if(coins[i] == coins[j])\n            {\n                count+=1;;\n            }\n        }\n        printf(\"Mising coin is:\");\n        if(count%2==1)\n        {\n            printf(\"%d\",coins[i]);\n            return 0;\n        }\n    }\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#define MAX 999\nint fibonnaciSeries();\nint primeSeries();\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    if(n%2 == 1)\n    {\n        fibonnaciSeries(n\/2 + 1);\n    }\n    else\n    primeSeries(n\/2);\n}\nint fibonnaciSeries(int x)\n{\n    int a=0,b=1,temp;\n    int i;\n    for(i=1;i<=x;i++)\n    {\n        temp = a+b;\n        a = b;\n        b = temp;\n    }\n    printf(\"%d\",a);\n}\nint primeSeries(int y)\n{\n    int i,j,flag,count = 0;\n    for(i=2;i<=MAX;i++)\n    {\n        flag = 0;\n        for(j=2;j<i;j++)\n        {\n            if(i%j == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        {\n            if(++count == y)\n            {\n                printf(\"%d\",i);\n            }\n        }\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint bubbleSortOptimized(int a[],int n);\nint main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = bubbleSortOptimized(arr,z);               \n    return 0;                                     \nint bubbleSortOptimized(int a[], int n)            \n{\n    int i,j,temp,flag=0;                           \n    for(i=0;i<n;i++)                               \n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j] > a[j+1])\n            {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n                flag += 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"Sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d \\n\",a[i]);\n    }\n    \n}\n\n\n\n\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint selectionSort(int x[], int n);\nint main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}\nint selectionSort(int x[], int n)\n{\n    int i,j,temp,flag = 0;\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n                flag = 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint main()\n{\n    int low,high,i,temp,flag;\n    printf(\"enter the lower number:\");\n    scanf(\"%d\",&low);\n    printf(\"enter the higher number:\");\n    scanf(\"%d\",&high);\n    if(low>high)\n    {\n        temp = low;\n        low = high;\n        high = temp;\n    }\n    while(low<high)\n    {\n        flag = 0;\n        if(low<=1)\n        {\n            low++;\n            continue;\n        }\n        for(i = 2;i <= low\/2; i++)\n        {\n            if(low%i == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        printf(\"%d\\n\", low);\n        low++;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint checkPrime(int n);\nint main()\n{\n    int l,u,check,temp,i;\n    printf(\"enter l and u:\\n\");\n    scanf(\"%d%d\",&l,&u);\n    if(l>u)\n    {\n        temp = l;\n        l = u;\n        u = temp;\n    }\n    for(i = l;i <= u;i++)\n    {\n        if(i == 1 || i == 0)\n        continue;\n        check = 0;\n        check = checkPrime(i);\n        if(check == 0)\n        {\n           printf(\"%d\\n\",i);\n        } \n    }\n    return 0;\n}\nint checkPrime(int n)\n{\n    int flag = 0,j;\n    for (j = 2;j <= n\/2; j++)\n    {\n        if(n%j == 0)\n        {\n           flag = 1;\n           break;\n        }\n    }\n    return flag;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\nint selectionSort(int x[], int n);\nint main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}\nint selectionSort(int x[], int n)              \n{                                              \n    int i,j,temp;                              \n    for(i=0;i<n;i++)                           \n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc(sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(0\/1)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    int count = 0;\n    printf(\"THE ELEMENTS PRESENT IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link;\n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_nodes();\nint length();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"Press 1 for Creation or else Press 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want ot enter more?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    length(temp);\n    getch();\n}\nvoid display_nodes(struct node*temp1)\n{\n    printf(\"The elements are:\");\n    if(temp1 == 0)\n    {\n        printf(\"NO DATA\");\n    }\n    else\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nint length(struct node*temp2)\n{\n    int count = 0;\n    printf(\"\\nThe Length Of The Linked List is:\");\n    while(temp2!=NULL)\n    {\n        count++;\n        temp2 = temp2->ptr;\n    }\n    printf(\"%d\",count);\n}\n\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_node();\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more node?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    getch();\n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdlib.h>\n#include<conio.h>\n#include<stdio.h>\nvoid display_node();\nvoid delete_at_start();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    delete_at_start(head,temp);\n    getch();\n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid delete_at_start(struct node*head1, struct node*temp1)\n{\n    head1 = head1->ptr;\n    free(temp1);\n    printf(\"\\nAfter Deletion:\");\n    while(head1!=NULL)\n    {\n        printf(\"%d\\t\",head1->data);\n        head1 = head1->ptr;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_nodes();\nvoid delete_at_N_position();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or Enter 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to more?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    delete_at_N_position(head,temp);\n    getch();\n}\nvoid display_nodes(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid delete_at_N_position(struct node*head1, struct node*temp1)\n{\n    int pos;\n    printf(\"\\nAt what position you want to delete the data?\\n\");\n    scanf(\"%d\",&pos);\n    int i;\n    if(pos<=0)\n    {\n        printf(\"After Deletion:\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        printf(\"\\nSORRY!!! NO NODE DELETED :(\");\n        return;\n    }\n    if(pos == 1)\n    {\n        head1 = head1->ptr;\n        free(temp1);\n        printf(\"\\nAfter Deletion:\");\n        while(head1!=NULL)\n        {\n            printf(\"%d\\t\",head1->data);\n            head1 = head1->ptr;\n        }\n        return;\n    }\n    for(i = 1;i < pos-1;i++)\n    {\n        temp1 = temp1->ptr;\n    }\n    struct node*prevnode;\n    prevnode = temp1;\n    temp1 = temp1->ptr;\n    prevnode->ptr = temp1->ptr;\n    free(temp1);\n    prevnode = head1;\n    printf(\"\\nAfter Deletion:\");\n    while(prevnode!=NULL)\n    {\n        printf(\"%d\\t\",prevnode->data);\n        prevnode = prevnode->ptr;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_nodes();\nvoid delete_at_end();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or Enter 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to more?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    delete_at_end(head,temp);\n    getch();\n}\nvoid display_nodes(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid delete_at_end(struct node*head1, struct node*temp1)\n{\n    struct node*prevnode;\n    while(temp1->ptr!=NULL)\n    {\n        prevnode = temp1;\n        temp1 = temp1->ptr;\n    }\n    prevnode->ptr = NULL;\n    free(temp1);\n    prevnode = head1;\n    printf(\"\\nAfter Deletion:\");\n    while(prevnode!=NULL)\n    {\n        printf(\"%d\\t\",prevnode->data);\n        prevnode = prevnode->ptr;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\nvoid display_node();\nvoid insert_at_N_position();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_N_position(head,temp);\n    getch();\n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid insert_at_N_position(struct node*head1, struct node*temp1)\n{\n    int pos,i;\n    printf(\"\\nAt what position you want to insert?\\n\");\n    scanf(\"%d\",&pos);\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the data:\");\n    scanf(\"%d\",&tempo->data);\n    if(pos == 0)\n    {\n        printf(\"After Insertion, the List is:\\n\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        printf(\"\\nSORRY!!! NO ADDITIONAL NODE IS INSERTED :(\");\n        return;\n    }\n    if(pos == 1)\n    {\n        tempo->ptr = temp1;\n        head1 = temp1 = tempo;\n        printf(\"After Insertion, The List is:\\n\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        return;\n    }\n    for(i=1;i<pos-1;i++)\n    {\n        temp1 = temp1->ptr;\n    }\n    tempo->ptr = temp1->ptr;\n    temp1->ptr = tempo;\n    temp1 = head1;\n    printf(\"After Insertion, The List is:\\n\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_node();\nvoid insert_at_begin();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"DO you want to enter more?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_begin(head,temp);\n    getch();    \n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"The elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid insert_at_begin(struct node*head1,struct node*temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"\\nEnter the data:\\n\");\n    scanf(\"%d\",&tempo->data);\n    tempo->ptr = temp1;\n    head1 = temp1 = tempo;\n    printf(\"After Insertion:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_node();\nvoid insert_at_end();\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more node?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_end(temp,head);\n    getch();\n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}\nvoid insert_at_end(struct node*temp1, struct node*head1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"\\nEnter the Data:\");\n    scanf(\"%d\",&tempo->data);\n    while(temp1->link!=NULL)\n    {\n        temp1 = temp1->link;\n    }\n    temp1->link = tempo;\n    tempo->link = NULL;\n    temp1 = head1;\n    printf(\"The Elements After Insertion are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    } \n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\nvoid display_node();\nvoid reverse_node();\nstruct node\n{\n    int data;\n    struct node*ptr;\n};\nint main()\n{\n    int choice;\n    printf(\"PRESS 1 FOR CREATION OR ELSE PRESS 0 FOR TERMINATION:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    reverse_node(head,temp);\n    getch();    \n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"THE ELEMENTS ARE:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}\nvoid reverse_node(struct node*head1, struct node*temp1)\n{\n    struct node*prevnode;\n    if(head1!=NULL)\n    {\n        prevnode = head1;\n        temp1 = head1->ptr;\n        head1 = head1->ptr;\n        prevnode->ptr = NULL;\n    }\n    while(head1!=NULL)\n    {\n        head1 = head1->ptr;\n        temp1->ptr = prevnode;\n        prevnode = temp1;\n        temp1 = head1;\n    }\n    head1 = prevnode;\n    printf(\"\\nAFTER REVERSE OPERATION:\");\n    while(head1!=NULL)\n    {\n        printf(\"%d\\t\",head1->data);\n        head1 = head1->ptr;\n    }\n    return;\n}\n"}
{"target":"abhijeetmurmu1997","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\nvoid display_node();\nvoid search_node();\nstruct node\n{\n    int data;\n    struct node*link;\n};\nint main()\n{\n    int choice;\n    printf(\"ENTER 1 FOR CREATION ELSE ENTER 0 FOR TERMINATION:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        \n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE?(1\/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    search_node(head,temp);\n    getch();\n}\nvoid display_node(struct node*temp1)\n{\n    printf(\"THE ELEMENTS ARE:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}\nvoid search_node(struct node*head1, struct node*temp1)\n{\n    int val;\n    printf(\"\\nWHICH ELEMENT YOU ARE LOOKING FROM THE ABOVE LIST?\\n\");\n    scanf(\"%d\",&val);\n    int count = 1;\n    while(temp1->data!=val)\n    {\n        count++;\n        temp1 = temp1->link;\n    }\n    printf(\"THE ELEMENT %d IS PRESENT AT POSITION %d\",temp1->data,count);\n    return;\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid        player_init(char c, int x, int y)\n{\n    if (g_player.x != -1 || g_player.y != -1)\n    {\n        ft_putstr(\"Error:\\nthe map has more than one player\\n\");\n        exit(0);\n    }\n    else\n    {\n        g_player.x = (x * 32) + 16;\n        g_player.y = (y * 32) + 16;\n        if (c == 'N')\n            g_player.rotation_angle = M_PI \/ 2;\n        else if (c == 'S')\n            g_player.rotation_angle = M_PI \/ 2;\n        else if (c == 'E')\n            g_player.rotation_angle = M_PI \/ 2;\n        else if (c == 'W')\n            g_player.rotation_angle = M_PI \/ 2;\n    }\n}\n\nvoid        array_height(void)\n{\n    int i;\n\n    i = 0;\n    while (g_map_array[i])\n        i++;\n    g_map_height = i;\n}\n\nchar        **map_manager(void)\n{\n    char    **map_array;\n    int     i;\n    int     j;\n\n    j = 0;\n    i = 0;\n    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));\n    while (i < g_map_height + 2)\n    {\n        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));\n        i++;\n    }\n    map_array[i] = NULL;\n    surrend_by_spaces(map_array);\n    fill_map(map_array);\n    map_errors(map_array);\n    if (g_player.x == -1 || g_player.y == -1)\n    {\n        ft_putstr(\"Error:\\nPlayer or map missing\\n\");\n        exit(0);\n    }\n    return (map_array);\n}\n\nvoid        map_errors(char **map)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if (map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W')\n                    player_init(map[i][j], i - 1, j - 1);\n            }\n        }\n        j = 1;\n    }\n}\n\nvoid        error_redirect(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error:\\nmap has an unknown character\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nthe map isnt closed\");\n    exit(0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid        surrend_by_spaces(char **map)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (map[i])\n    {\n        while (j < g_map_width + 2)\n            j++;\n        map[i][j] = '\\0';\n        i++;\n        j = 0;\n    }\n    i = -1;\n    while (map[++i])\n        map[i][0] = ' ';\n    i = -1;\n    while (map[0][++i])\n        map[0][i] = ' ';\n    i = -1;\n    while (map[g_map_height][++i])\n        map[g_map_height + 1][i] = ' ';\n    i = -1;\n    while (map[++i])\n        map[i][g_map_width + 1] = ' ';\n}\n\nvoid        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}\n\nvoid        longuest_line(void)\n{\n    int i;\n    int j;\n    int max;\n\n    i = 0;\n    j = 0;\n    max = 0;\n    while (g_map_array[i])\n    {\n        while (g_map_array[i][j] != '\\0')\n            j++;\n        i++;\n        if (j > max)\n            max = j;\n        j = 0;\n    }\n    g_map_width = max;\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     readline(void)\n{\n    int     fd;\n    char    *line;\n\n    fd = open(\"map.cub\", O_RDONLY);\n    global_init();\n    while (get_next_line(fd, &line))\n    {\n        if (!all_params())\n        {\n            if (*line != '\\0')\n                routing(line);\n        }\n        else\n            routing(line);\n        free(line);\n    }\n    free(line);\n    return (0);\n}\n\nvoid    routing(char *line)\n{\n    if (line[0] == 'R' && line[1] == ' ')\n        get_re(line);\n    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')\n        get_no(line);\n    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')\n        get_so(line);\n    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')\n        get_we(line);\n    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')\n        get_ea(line);\n    else if (line[0] == 'S' && line[1] == ' ')\n        get_s(line);\n    else if (line[0] == 'F' && line[1] == ' ')\n        get_f(line);\n    else if (line[0] == 'C' && line[1] == ' ')\n        get_c(line);\n    else if (all_params())\n        readmap(line);\n    else\n    {\n        ft_putstr(\"one or many parametres format is wrong or missing!\\n\");\n        exit(0);\n    }\n}\n\nint     main(void)\n{\n    char **ugh;\n\n    g_player.x = -1;\n    g_player.y = -1;\n    readline();\n    manage_map();\n    longuest_line();\n    array_height();\n    ugh = map_manager();\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     all_params(void)\n{\n    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL\n        && g_no != NULL && g_ea != NULL && g_fr != -1 &&\n        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&\n        g_cg != -1 && g_cb != -1)\n        return (1);\n    return (0);\n}\n\nint     wrong_resolution(int width, int height)\n{\n    int w;\n    int h;\n\n    w = width;\n    h = height;\n    if (width > 2560)\n        w = 2560;\n    if (height > 1400)\n        h = 1400;\n    if (width <= 100 || height <= 100)\n    {\n        ft_putstr(\"Error:\\nresolution is < 100 px!\\n\");\n        exit(0);\n    }\n    get_resolution(w, h);\n    return (1);\n}\n\nvoid    get_resolution(int width, int height)\n{\n    g_width = width;\n    g_height = height;\n}\n\nvoid    get_frgb(int r, int g, int b)\n{\n    g_fr = r;\n    g_fg = g;\n    g_fb = b;\n}\n\nvoid    get_crgb(int r, int g, int b)\n{\n    g_cr = r;\n    g_cg = g;\n    g_cb = b;\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     str_is_digits(char *c)\n{\n    int i;\n\n    i = 0;\n    if (!c)\n        return (0);\n    while (c[i])\n    {\n        if (!ft_isdigit(c[i]))\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nint     array_is_rgb(char **colors)\n{\n    int i;\n\n    i = 0;\n    while (colors[i])\n    {\n        if (str_is_digits(colors[i]))\n        {\n            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))\n            {\n                ft_putstr(\"Error\\n Wrong colors parametres!\");\n                exit(0);\n            }\n        }\n        else\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nvoid    get_s(char *line)\n{\n    char    **par;\n    char    *str;\n    int     re;\n\n    re = 0;\n    par = ft_split(line, ' ');\n    str = ft_strdup(\"\");\n    if (g_s != NULL)\n        texture_error(0);\n    if (c_w(line, ' ') != 2)\n    {\n        while (++re < c_w(line, ' '))\n        {\n            str = ft_strjoin(str, &par[re][0]);\n            if (re != c_w(line, ' ') - 1)\n                str = ft_strjoin(str, \" \");\n        }\n        if ((re = open(str, O_RDONLY) < 0))\n            texture_error(5);\n        else\n            g_s = ft_strdup(str);\n    }\n    else\n        wrong_file(&par[1][0], 5);\n    free_this_shit(str, par);\n}\n\nvoid    get_f(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong floor RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_frgb(colors, cc, cw);\n    freethenipples(colors);\n}\n\nvoid    get_c(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong ceiling RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_crgb(colors, cc, cw);\n    freethenipples(colors);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid    texture_error(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error\\ndouble inclusion\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in NO!\\n\");\n    else if (error == 2)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in SO!\\n\");\n    else if (error == 3)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in WE!\\n\");\n    else if (error == 4)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in EA!\\n\");\n    else if (error == 5)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in S!\\n\");\n    exit(0);\n}\n\nvoid    free_this_shit(char *str, char **s)\n{\n    free(str);\n    freethenipples(s);\n}\n\nvoid    wrong_file(char *file, int type)\n{\n    int re;\n\n    if ((re = open(file, O_RDONLY) > 0) && type == 1)\n        g_no = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 1)\n        texture_error(1);\n    if ((re = open(file, O_RDONLY) > 0) && type == 2)\n        g_so = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 2)\n        texture_error(2);\n    if ((re = open(file, O_RDONLY) > 0) && type == 3)\n        g_we = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 3)\n        texture_error(3);\n    if ((re = open(file, O_RDONLY) > 0) && type == 4)\n        g_ea = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 4)\n        texture_error(4);\n    if ((re = open(file, O_RDONLY) > 0) && type == 5)\n        g_s = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 5)\n        texture_error(4);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}\n\nvoid    ft_putchar(char c)\n{\n    write(1, &c, 1);\n}\n\nvoid    ft_putstr(char *str)\n{\n    int i;\n\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        ft_putchar(str[i]);\n        i++;\n    }\n}\n\nint     ft_isdigit(int c)\n{\n    if (c >= 0x30 && c <= 0x39)\n        return (1);\n    return (0);\n}\n\nchar    *ft_strjoi(char *s1, char *s2)\n{\n    char    *str;\n    int     i;\n    int     j;\n\n    if (!s2)\n        return (s1);\n    if (!s1)\n        return (s2);\n    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);\n    i = -1;\n    while (s1[++i])\n    {\n        str[i] = s1[i];\n    }\n    j = -1;\n    while (s2[++j])\n    {\n        str[i] = s2[j];\n        i++;\n    }\n    str[i] = '\\n';\n    str[i + 1] = '\\0';\n    free(s1);\n    return (str);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid    check_crgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else\n        get_crgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}\n\nvoid    check_frgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in floor colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in floor colors!\\n\");\n        exit(0);\n    }\n    else\n        get_frgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\ndouble      normalangle(double rayangle)\n{\n    rayangle = fmod(rayangle, (2 * M_PI));\n    return (rayangle);\n}\n\nvoid        update(void)\n{\n    float   newx;\n    float   newy;\n    float   move_step;\n\n    g_player.rotation_angle += g_player.turn_direction *\n                                g_player.rotation_speed;\n    move_step = g_player.walk_direction * g_player.move_speed;\n    newx = g_player.x + cos(g_player.rotation_angle) * move_step;\n    newy = g_player.y + sin(g_player.rotation_angle) * move_step;\n    if (!has_wall(newx, newy))\n    {\n        g_player.x = newx;\n        g_player.y = newy;\n    }\n}\n\nvoid        render(void)\n{\n    update();\n    draw_map();\n    cast_rays();\n    mlx_put_image_to_window(g_vars.mlx, g_vars.win, g_image.img, 0, 0);\n    mlx_destroy_image(g_vars.mlx, g_image.img);\n}\n\nint         key_press(int keycode)\n{\n    if (keycode == 13)\n        g_player.walk_direction = 1;\n    if (keycode == 1)\n        g_player.walk_direction = -1;\n    if (keycode == 0)\n        g_player.turn_direction = -1;\n    if (keycode == 2)\n        g_player.turn_direction = 1;\n    return (0);\n}\n\nint         key_release(int keycode)\n{\n    if (keycode == 13)\n        g_player.walk_direction = 0;\n    if (keycode == 1)\n        g_player.walk_direction = 0;\n    if (keycode == 0)\n        g_player.turn_direction = 0;\n    if (keycode == 2)\n        g_player.turn_direction = 0;\n    return (0);\n}\n\nint         move(void)\n{\n    mlx_hook(g_vars.win, 2, 0, key_press, &g_vars);\n    render();\n    mlx_hook(g_vars.win, 3, 0, key_release, &g_vars);\n    return (0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n#include <stdio.h>\n\nvoid        my_mlx_pixel_put(t_data *data, int x, int y, int color)\n{\n    char    *dst;\n\n    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel \/ 8));\n    *(unsigned int*)dst = color;\n}\n\nvoid        draw_cube(int x, int y)\n{\n    int i;\n    int j;\n\n    i = x;\n    j = y;\n    while (j < g_tile_size + y)\n    {\n        while (i < g_tile_size + x)\n        {\n            my_mlx_pixel_put(&g_image, j, i, 0xFF0000);\n            i++;\n        }\n        i = x;\n        j++;\n    }\n}\n\nvoid        norm_it(char **meh)\n{\n    int e;\n    int f;\n    int x;\n    int y;\n\n    e = 0;\n    f = 0;\n    x = 0;\n    y = 0;\n    while (meh[e])\n    {\n        while (meh[e][f])\n        {\n            if (meh[e][f] == '1')\n                draw_cube(y, x);\n            f++;\n            x = x + g_tile_size;\n        }\n        f = 0;\n        e++;\n        x = 0;\n        y = y + g_tile_size;\n    }\n}\n\nvoid        draw_map(void)\n{\n    g_image.img = mlx_new_image(g_vars.mlx, g_width, g_height);\n    g_image.addr = mlx_get_data_addr(g_image.img, &g_image.bits_per_pixel,\n                    &g_image.line_length, &g_image.endian);\n    norm_it(g_map_array);\n}\n\nint         has_wall(int x, int y)\n{\n    int ughx;\n    int ughy;\n\n    ughx = floor(x \/ g_tile_size);\n    ughy = floor(y \/ g_tile_size);\n    if (g_map_array[ughy][ughx] == '1')\n        return (1);\n    else\n        return (0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint pre_work(int fd, char **rest, char **line)\n{\n    char            *tmp;\n\n    if (BUFFER_SIZE < 0 || !line || read(fd, NULL, 0) < 0)\n        return (-1);\n    *line = ft_strdup(\"\");\n    if (rest[fd] != '\\0')\n    {\n        if (!has_nl(rest[fd]))\n        {\n            *line = ft_strjoin(*line, rest[fd]);\n            rest[fd] = NULL;\n        }\n        else\n        {\n            *line = ft_strjoin(*line, ft_substr(rest[fd], 0,\n                has_nl(rest[fd]) - rest[fd]));\n            tmp = rest[fd];\n            rest[fd] = ft_strdup(&rest[fd][has_nl(rest[fd]) - rest[fd] + 1]);\n            free(tmp);\n            return (1);\n        }\n    }\n    return (2);\n}\n\nint get_next_line(int fd, char **line)\n{\n    int             re;\n    char            *str;\n    static  char    *rest[1024];\n\n    re = 0;\n    if ((re = pre_work(fd, rest, line)) < 2)\n        return (re);\n    str = (char *)malloc(BUFFER_SIZE + 1);\n    while ((re = read(fd, str, BUFFER_SIZE)))\n    {\n        str[re] = '\\0';\n        if (!has_nl(str))\n            *line = ft_strjoin(*line, str);\n        else\n        {\n            *line = ft_strjoin(*line, ft_substr(str, 0, has_nl(str) - str));\n            rest[fd] = ft_strdup(&str[has_nl(str) - str + 1]);\n            free(str);\n            return (1);\n        }\n        str = (char *)malloc(BUFFER_SIZE + 1);\n    }\n    free(str);\n    return (0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid        player_init(char c, int x, int y)\n{\n    if (g_peeinit)\n    {\n        ft_putstr(\"Error:\\nthe map has more than one player\\n\");\n        exit(0);\n    }\n    else\n    {\n        g_tile_size = 16;\n        g_player.x = (x * g_tile_size) + (g_tile_size \/ 2);\n        g_player.y = (y * g_tile_size) + (g_tile_size \/ 2);\n        g_peeinit = 1;\n        if (c == 'N')\n            g_player.rotation_angle = 270 * (M_PI \/ 180);\n        else if (c == 'S')\n            g_player.rotation_angle = 90 * (M_PI \/ 180);\n        else if (c == 'E')\n            g_player.rotation_angle = 0;\n        else if (c == 'W')\n            g_player.rotation_angle = M_PI;\n        g_player.fov = 60 * (M_PI \/ 180);\n        g_player.turn_direction = 0;\n        g_player.walk_direction = 0;\n        g_player.move_speed = 6;\n        g_player.rotation_speed = 4 * (M_PI \/ 180);\n    }\n}\n\nvoid        array_height(void)\n{\n    int i;\n\n    i = 0;\n    while (g_map_array[i])\n        i++;\n    g_map_height = i;\n}\n\nchar        **map_manager(void)\n{\n    char    **map_array;\n    int     i;\n    int     j;\n\n    j = 0;\n    i = 0;\n    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));\n    while (i < g_map_height + 2)\n    {\n        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));\n        i++;\n    }\n    map_array[i] = NULL;\n    surrend_by_spaces(map_array);\n    fill_map(map_array);\n    map_errors(map_array);\n    if (g_player.x == -1 || g_player.y == -1)\n    {\n        ft_putstr(\"Error:\\nPlayer or map missing\\n\");\n        exit(0);\n    }\n    return (map_array);\n}\n\nvoid        map_errors(char **map)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if ((map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W') && !g_peeinit)\n                    player_init(map[i][j], j - 1, i - 1);\n            }\n        }\n        j = 0;\n    }\n}\n\nvoid        error_redirect(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error:\\nmap has an unknown character\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nthe map isnt closed\");\n    exit(0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid        surrend_by_spaces(char **map)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (map[i])\n    {\n        while (j < g_map_width + 2)\n            j++;\n        map[i][j] = '\\0';\n        i++;\n        j = 0;\n    }\n    i = -1;\n    while (map[++i])\n        map[i][0] = ' ';\n    i = -1;\n    while (map[0][++i])\n        map[0][i] = ' ';\n    i = -1;\n    while (map[g_map_height][++i])\n        map[g_map_height + 1][i] = ' ';\n    i = -1;\n    while (map[++i])\n        map[i][g_map_width + 1] = ' ';\n}\n\nvoid        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}\n\nvoid        longuest_line(void)\n{\n    int i;\n    int j;\n    int max;\n\n    i = 0;\n    j = 0;\n    max = 0;\n    while (g_map_array[i])\n    {\n        while (g_map_array[i][j] != '\\0')\n            j++;\n        i++;\n        if (j > max)\n            max = j;\n        j = 0;\n    }\n    g_map_width = max;\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n#include <stdio.h>\n\nvoid        cast_ray(int l, float angle)\n{\n    float   i;\n    float   j;\n    float   xp;\n    float   yp;\n\n    i = 0;\n    while (i < l)\n    {\n        xp = cos(angle) * i + g_player.x;\n        yp = sin(angle) * i + g_player.y;\n        i++;\n        my_mlx_pixel_put(&g_image, xp, yp, 0xFF0000);\n    }\n}\n\nvoid        cast_rays(void)\n{\n    int     strip_id;\n    float   angle;\n\n    strip_id = 0;\n    angle = g_player.rotation_angle - (g_player.fov \/ 2);\n    while (strip_id < g_width)\n    {\n        normalangle(angle);\n        cast_ray(50, (float)angle);\n        angle += g_player.fov \/ g_width;\n        strip_id++;\n    }\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n#include <stdio.h>\n\nint     readline(void)\n{\n    int     fd;\n    char    *line;\n\n    fd = open(\"map.cub\", O_RDONLY);\n    global_init();\n    while (get_next_line(fd, &line))\n    {\n        if (!all_params())\n        {\n            if (*line != '\\0')\n                routing(line);\n        }\n        else\n            routing(line);\n        free(line);\n    }\n    free(line);\n    return (0);\n}\n\nvoid    routing(char *line)\n{\n    if (line[0] == 'R' && line[1] == ' ')\n        get_re(line);\n    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')\n        get_no(line);\n    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')\n        get_so(line);\n    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')\n        get_we(line);\n    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')\n        get_ea(line);\n    else if (line[0] == 'S' && line[1] == ' ')\n        get_s(line);\n    else if (line[0] == 'F' && line[1] == ' ')\n        get_f(line);\n    else if (line[0] == 'C' && line[1] == ' ')\n        get_c(line);\n    else if (all_params())\n        readmap(line);\n    else\n    {\n        ft_putstr(\"one or many parametres format is wrong or missing!\\n\");\n        exit(0);\n    }\n}\n\nint     main(void)\n{\n    char **ugh;\n    int a;\n    readline();\n    manage_map();\n    longuest_line();\n    array_height();\n    ugh = map_manager();\n    g_vars.mlx = mlx_init();\n    g_vars.win = mlx_new_window(g_vars.mlx, g_width, g_height, \"Bismilah!\");\n    \n    \n    freethenipples(ugh);\n    mlx_loop_hook(g_vars.mlx, move, 0);\n    mlx_loop(g_vars.mlx);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     check_char(char *mapline, char c)\n{\n    int i;\n\n    i = 0;\n    while (mapline[i])\n    {\n        if (mapline[i] != c)\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nvoid    readmap(char *line)\n{\n    if (line[0] != '\\0' && !g_map_started)\n        g_map_started = 1;\n    if (g_map_started && line[0] != '\\0')\n    {\n        g_map = ft_strjoi(g_map, line);\n    }\n    if (g_map_started && line[0] == '\\0')\n    {\n        ft_putstr(\"Error:\\nmap has a new line\");\n        exit(0);\n    }\n}\n\nvoid    manage_map(void)\n{\n    g_map_array = ft_split(g_map, '\\n');\n}\n\nint     begins_by_nl(char **mapline)\n{\n    int i;\n\n    i = 0;\n    while (mapline[i] != '\\0')\n    {\n        if (mapline[i][0] == '\\n')\n            return (1);\n        i++;\n    }\n    return (0);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     all_params(void)\n{\n    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL\n        && g_no != NULL && g_ea != NULL && g_fr != -1 &&\n        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&\n        g_cg != -1 && g_cb != -1)\n        return (1);\n    return (0);\n}\n\nint     wrong_resolution(int width, int height)\n{\n    int w;\n    int h;\n\n    w = width;\n    h = height;\n    if (width > 2560)\n        w = 2560;\n    if (height > 1400)\n        h = 1400;\n    if (width <= 100 || height <= 100)\n    {\n        ft_putstr(\"Error:\\nresolution is < 100 px!\\n\");\n        exit(0);\n    }\n    get_resolution(w, h);\n    return (1);\n}\n\nvoid    get_resolution(int width, int height)\n{\n    g_width = width;\n    g_height = height;\n}\n\nvoid    get_frgb(int r, int g, int b)\n{\n    g_fr = r;\n    g_fg = g;\n    g_fb = b;\n}\n\nvoid    get_crgb(int r, int g, int b)\n{\n    g_cr = r;\n    g_cg = g;\n    g_cb = b;\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     str_is_digits(char *c)\n{\n    int i;\n\n    i = 0;\n    if (!c)\n        return (0);\n    while (c[i])\n    {\n        if (!ft_isdigit(c[i]))\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nint     array_is_rgb(char **colors)\n{\n    int i;\n\n    i = 0;\n    while (colors[i])\n    {\n        if (str_is_digits(colors[i]))\n        {\n            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))\n            {\n                ft_putstr(\"Error\\n Wrong colors parametres!\");\n                exit(0);\n            }\n        }\n        else\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nvoid    get_s(char *line)\n{\n    char    **par;\n    char    *str;\n    int     re;\n\n    re = 0;\n    par = ft_split(line, ' ');\n    str = ft_strdup(\"\");\n    if (g_s != NULL)\n        texture_error(0);\n    if (c_w(line, ' ') != 2)\n    {\n        while (++re < c_w(line, ' '))\n        {\n            str = ft_strjoin(str, strdup(&par[re][0]));\n            if (re != c_w(line, ' ') - 1)\n                str = ft_strjoin(str, strdup(\" \"));\n        }\n        if ((re = open(str, O_RDONLY) < 0))\n            texture_error(5);\n        else\n            g_s = ft_strdup(str);\n    }\n    else\n        wrong_file(&par[1][0], 5);\n    free_this_shit(str, par);\n}\n\nvoid    get_f(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong floor RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_frgb(colors, cc, cw);\n    freethenipples(colors);\n}\n\nvoid    get_c(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong ceiling RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_crgb(colors, cc, cw);\n    freethenipples(colors);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nint     c_w(char *str, char c)\n{\n    int i;\n    int j;\n\n    j = 0;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        while (str[i] == c && str[i] != '\\0')\n        {\n            i++;\n        }\n        if (str[i] != c && str[i] != '\\0')\n            j++;\n        while (str[i] != c && (str[i] != '\\0'))\n            i++;\n    }\n    return (j);\n}\n\nchar    **freethenipples(char **s)\n{\n    int i;\n\n    i = 0;\n    while (s[i])\n    {\n        free(s[i]);\n        i++;\n    }\n    free(s);\n    return (NULL);\n}\n\nint     s_p(char *s, char c)\n{\n    int i;\n\n    i = 0;\n    while (s[i] == c && s[i])\n        i++;\n    return (i);\n}\n\nint     len_str(char *s, int i, char c)\n{\n    int len;\n\n    len = 0;\n    while (s[i] != c && s[i])\n    {\n        len++;\n        i++;\n    }\n    return (len);\n}\n\nchar    **ft_split(char *s, char c)\n{\n    char    **cpy;\n    int     len;\n    int     k;\n    int     i;\n    int     start;\n\n    k = -1;\n    i = 0;\n    if (!s || !(cpy = (char**)malloc(sizeof(char*) * (c_w(s, c) + 1))))\n        return (0);\n    while (s[i])\n    {\n        len = 0;\n        i += s_p(&s[i], c);\n        start = i;\n        len = len_str(s, i, c);\n        i += len;\n        if (len)\n            if (!(cpy[++k] = ft_substr(s, start, len)))\n                return (freethenipples(cpy));\n    }\n    cpy[++k] = 0;\n    return (cpy);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid    texture_error(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error\\ndouble inclusion\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in NO!\\n\");\n    else if (error == 2)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in SO!\\n\");\n    else if (error == 3)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in WE!\\n\");\n    else if (error == 4)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in EA!\\n\");\n    else if (error == 5)\n        ft_putstr(\"Error:\\nWrong number of params\/invalid file in S!\\n\");\n    exit(0);\n}\n\nvoid    free_this_shit(char *str, char **s)\n{\n    free(str);\n    freethenipples(s);\n}\n\nvoid    wrong_file(char *file, int type)\n{\n    int re;\n\n    if ((re = open(file, O_RDONLY) > 0) && type == 1)\n        g_no = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 1)\n        texture_error(1);\n    if ((re = open(file, O_RDONLY) > 0) && type == 2)\n        g_so = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 2)\n        texture_error(2);\n    if ((re = open(file, O_RDONLY) > 0) && type == 3)\n        g_we = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 3)\n        texture_error(3);\n    if ((re = open(file, O_RDONLY) > 0) && type == 4)\n        g_ea = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 4)\n        texture_error(4);\n    if ((re = open(file, O_RDONLY) > 0) && type == 5)\n        g_s = ft_strdup(file);\n    else if ((re = open(file, O_RDONLY) <= 0) && type == 5)\n        texture_error(4);\n}\n"}
{"target":"ael-bagh","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"get_next_line.h\"\n\nvoid    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}\n\nvoid    ft_putchar(char c)\n{\n    write(1, &c, 1);\n}\n\nvoid    ft_putstr(char *str)\n{\n    int i;\n\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        ft_putchar(str[i]);\n        i++;\n    }\n}\n\nint     ft_isdigit(int c)\n{\n    if (c >= 0x30 && c <= 0x39)\n        return (1);\n    return (0);\n}\n\nchar    *ft_strjoi(char *s1, char *s2)\n{\n    char    *str;\n    int     i;\n    int     j;\n\n    if (!s2)\n        return (s1);\n    if (!s1)\n        return (s2);\n    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);\n    i = -1;\n    while (s1[++i])\n    {\n        str[i] = s1[i];\n    }\n    j = -1;\n    while (s2[++j])\n    {\n        str[i] = s2[j];\n        i++;\n    }\n    str[i] = '\\n';\n    str[i + 1] = '\\0';\n    free(s1);\n    return (str);\n}\n"}
{"target":"Ana-Morales","func":"#include \"binary_trees.h\"\n\nsize_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n\n    if (tree == NULL)\n        return (-1);\n    if (tree->left == NULL && tree->right == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left) + 1;\n    height_right = binary_tree_height(tree->right) + 1;\n    if (height_left > height_right)\n        return (height_left);\n    return (height_right);\n}\n\n\nint binary_tree_balance(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n\n    if (tree == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left);\n    height_right = binary_tree_height(tree->right);\n    return (height_left - height_right);\n}\n\n\nint binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    if (tree == NULL || (binary_tree_balance(tree) != 0))\n        return (0);\n    if (tree->left == NULL && tree->right == NULL)\n        return (1);\n    return (binary_tree_is_perfect(tree->left)\n        * binary_tree_is_perfect(tree->right));\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\n\nvoid bubble_sort(int *array, size_t size)\n{\n    size_t i = 0, sz = size;\n    int flag = 0, tmp = 0;\n\n    if (array == NULL || size < 2)\n        return;\n    while (1)\n    {\n        i = 0;\n        while (i < (sz - 1))\n        {\n            if (array[i + 1] < array[i])\n            {\n                tmp = array[i];\n                array[i] = array[i + 1];\n                array[i + 1] = tmp;\n                print_array(array, size);\n                flag = 1;\n            }\n            i++;\n        }\n        if (flag == 0)\n            break;\n        flag = 0;\n        sz--;\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\n\nvoid insertion_sort_list(listint_t **list)\n{\n\n    listint_t *p, *c, *aux;\n\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    c = (*list)->next;\n    aux = (*list)->next;\n    while (aux != NULL)\n    {\n        aux = aux->next;\n        while (c->prev != NULL)\n        {\n            if (c->prev->n > c->n)\n            {\n                p = c->prev;\n                p->next = c->next;\n                if (c->next)\n                    c->next->prev = p;\n                c->next = p;\n                c->prev = p->prev;\n                if (p->prev)\n                    p->prev->next = c;\n                p->prev = c;\n                if (p == *list)\n                    *list = c;\n                print_list(*list);\n            }\n            else\n                break;\n        }\n        c = aux;\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\nvoid shell_sort(int *array, size_t size)\n{\n\n    int value;\n    size_t i, j, gap;\n\n    if (array == NULL || size < 2)\n        return;\n    gap = 1;\n    while (gap < size \/ 3)\n    {\n        gap = (gap * 3) + 1;\n    }\n    while (gap > 0)\n    {\n        i = gap;\n        while (i < size)\n        {\n            value = array[i];\n            j = i;\n            while (j > gap - 1 && array[j - gap] >= value)\n            {\n                array[j] = array[j - gap];\n                j -= gap;\n            }\n            array[j] = value;\n            i++;\n        }\n        gap = (gap - 1) \/ 3;\n        print_array(array, size);\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"deck.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid swap_func(deck_node_t **deck, deck_node_t *node1, deck_node_t *node2)\n{\n    deck_node_t *tmp;\n\n    if (node1->next == node2)\n    {\n        if (node2->next)\n            node2->next->prev = node1;\n        node2->prev = node1->prev;\n        node1->next = node2->next;\n        node2->next = node1;\n        if (node1->prev)\n            node1->prev->next = node2;\n        node1->prev = node2;\n        if (*deck == node1)\n            *deck = node2;\n    }\n    else\n    {\n        node1->next->prev = node2;\n        if (node1->prev)\n            node1->prev->next = node2;\n        node2->prev->next = node1;\n        if (node2->next)\n            node2->next->prev = node1;\n        tmp = node1->next;\n        node1->next = node2->next;\n        node2->next = tmp;\n        tmp = node2->prev;\n        node2->prev = node1->prev;\n        node1->prev = tmp;\n        if (*deck == node1)\n            *deck = node2;\n    }\n}\n\nint partition(deck_node_t **deck, int lo, int hi)\n{\n    deck_node_t *pivot = *deck, *pi = *deck, *pj = *deck, *tmp = *deck;\n    int i, j, k, v;\n    kind_t p;\n    char *s = \"A234567891JQK\";\n\n    for (i = 0; i < lo; i++)\n    {\n        pivot = pivot->next;\n        pi = pi->next;\n        pj = pj->next;\n    }\n    while (i < hi)\n    {\n        pivot = pivot->next;\n        i++;\n    }\n    p = pivot->card->kind;\n    i = lo;\n    for (j = lo; j < hi; j++)\n    {\n        for (k = 0; s[k] != pj->card->value[0]; k++)\n            ;\n        for (v = 0; s[v] != pivot->card->value[0]; v++)\n            ;\n        if ((pj->card->kind < p) || (pj->card->kind == p && k <= v))\n        {\n            if (pi != pj)\n            {\n                swap_func(deck, pi, pj);\n                tmp = pi;\n                pi = pj;\n                pj = tmp;\n            }\n            pi = pi->next, i++;\n        }\n        pj = pj->next;\n    }\n    if (pi != pivot)\n        swap_func(deck, pi, pivot);\n    return (i);\n}\n\nvoid quicksort(deck_node_t **deck, int lo, int hi)\n{\n    int p;\n\n    if (lo < hi)\n    {\n        p = partition(deck, lo, hi);\n        quicksort(deck, lo, p - 1);\n        quicksort(deck, p + 1, hi);\n    }\n\n}\n\nvoid sort_deck(deck_node_t **deck)\n{\n    if (deck == NULL || *deck == NULL || (*deck)->next == NULL)\n        return;\n    quicksort(deck, 0, 51);\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\nvoid swap_func(listint_t **list, listint_t *node)\n{\n    listint_t *tmp;\n\n    tmp = node->next;\n    if (tmp->next)\n        tmp->next->prev = node;\n    tmp->prev = node->prev;\n    node->next = tmp->next;\n    tmp->next = node;\n    if (node->prev)\n        node->prev->next = tmp;\n    node->prev = tmp;\n    if (*list == node)\n        *list = tmp;\n}\n\n\nvoid cocktail_sort_list(listint_t **list)\n{\n    listint_t *current;\n    int flag = 1;\n\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    current = *list;\n    while (flag > 0)\n    {\n        flag = 0;\n        while (current->next != NULL)\n        {\n            if (current->n > current->next->n)\n            {\n                swap_func(list, current);\n                print_list(*list);\n                flag = 1;\n            }\n            else\n                current = current->next;\n        }\n        if (flag == 0)\n            break;\n        flag = 0;\n        while (current->prev != NULL)\n        {\n            if (current->n < current->prev->n)\n            {\n                swap_func(list, current->prev);\n                print_list(*list);\n                flag = 1;\n            }\n            else\n                current = current->prev;\n        }\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n#include <stdlib.h>\n\nvoid counting_sort(int *array, size_t size)\n{\n    int *count = NULL, *out = NULL, max = 0, total = 0;\n    size_t i, j;\n\n    if (array == NULL || size < 2)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        if (array[i] > max)\n            max = array[i];\n    }\n    count = malloc(sizeof(int) * (max + 1));\n    if (!count)\n        return;\n    j = max;\n    for (i = 0; i <= j; i++)\n        count[i] = 0;\n    for (i = 0; i < size; i++)\n        count[array[i]]++;\n    for (i = 0; i <= j; i++)\n    {\n        total += count[i];\n        count[i] = total;\n    }\n    print_array(count, max + 1);\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(count);\n        return;\n    }\n    for (i = 0; i < size; i++)\n    {\n        out[--count[array[i]]] = array[i];\n    }\n    for (i = 0; i < size; i++)\n        array[i] = out[i];\n    free(out);\n    free(count);\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid TopDownMerge(int *copy, int begin, int middle, int end, int *array)\n{\n    int i, j, k;\n\n    i = begin;\n    j = middle;\n    k = begin;\n    printf(\"Merging...\\n\");\n    printf(\"[left]: \");\n    print_array(&copy[begin], middle - begin);\n    printf(\"[right]: \");\n    print_array(&copy[middle], end - middle);\n    while (k < end)\n    {\n        if (i < middle && (j >= end || copy[i] <= copy[j]))\n        {\n            array[k] = copy[i];\n            i++;\n        }\n        else\n        {\n            array[k] = copy[j];\n            j++;\n        }\n        k++;\n    }\n    printf(\"[Done]: \");\n    print_array(&array[begin], end - begin);\n}\n\nvoid TopDownSplitMerge(int *copy, int begin, int end, int *array)\n{\n    int middle;\n\n    if (end - begin <= 1)\n        return;\n    middle = (end + begin) \/ 2;\n    TopDownSplitMerge(array, begin, middle, copy);\n    TopDownSplitMerge(array, middle, end, copy);\n    TopDownMerge(copy, begin, middle, end, array);\n}\n\n\nvoid merge_sort(int *array, size_t size)\n{\n    int *copy;\n    size_t i;\n\n    if (array == NULL || size < 2)\n        return;\n    copy = malloc(sizeof(int) * size);\n    if (!copy)\n        return;\n    i = 0;\n    while (i < size)\n    {\n        copy[i] = array[i];\n        i++;\n    }\n    TopDownSplitMerge(copy, 0, (int)size, array);\n    free(copy);\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n#include <stdlib.h>\n\nvoid countingSort(int *array, int radix, int exp, size_t size)\n{\n    int bucketIdx, *bucket = NULL, *out = NULL, i;\n    size_t j;\n\n    bucket = malloc(sizeof(int) * radix);\n    if (!bucket)\n        return;\n    i = 0;\n    while (i < radix)\n    {\n        bucket[i] = 0;\n        i++;\n    }\n    for (j = 0; j < size; j++)\n    {\n        bucketIdx = (array[j] \/ exp) % radix;\n        bucket[bucketIdx]++;\n    }\n    i = 1;\n    while (i < radix)\n    {\n        bucket[i] += bucket[i - 1];\n        i++;\n    }\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(bucket);\n        return;\n    }\n    i = size - 1;\n    while (i >= 0)\n    {\n        bucketIdx = (array[i] \/ exp) % radix;\n        out[--bucket[bucketIdx]] = array[i];\n        i--;\n    }\n    for (j = 0; j < size; j++)\n        array[j] = out[j];\n    free(bucket);\n    free(out);\n}\n\n\nvoid radix_sort(int *array, size_t size)\n{\n    int max, exp;\n    size_t i = 0;\n\n    if (array == NULL || size < 2)\n        return;\n    max = array[0];\n    while (i < size)\n    {\n        if (array[i] > max)\n            max = array[i];\n        i++;\n    }\n    exp = 1;\n    while (max \/ exp >= 1)\n    {\n        countingSort(array, 10, exp, size);\n        exp *= 10;\n        print_array(array, size);\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\nint partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n\n    }\n}\n\nvoid quicksort_hoare(int *array, int lo, int hi, size_t size)\n{\n    int p;\n\n    if (lo < hi)\n    {\n        p = partition(array, lo, hi, size);\n        quicksort_hoare(array, lo, p, size);\n        quicksort_hoare(array, p + 1, hi, size);\n    }\n\n}\n\n\nvoid quick_sort_hoare(int *array, size_t size)\n{\n    if (array == NULL || size < 2)\n        return;\n    quicksort_hoare(array, 0, size - 1, size);\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\nvoid selection_sort(int *array, size_t size)\n{\n    size_t i, j, idx_min;\n    int tmp = 0;\n\n    if (array == NULL || size < 2)\n        return;\n    i = 0;\n    while (i < size - 1)\n    {\n        idx_min = i;\n        j = i + 1;\n        while (j < size)\n        {\n            if (array[j] < array[idx_min])\n                idx_min = j;\n            j++;\n        }\n        if (idx_min != i)\n        {\n            tmp = array[i];\n            array[i] = array[idx_min];\n            array[idx_min] = tmp;\n            print_array(array, size);\n        }\n        i++;\n    }\n}\n"}
{"target":"Ana-Morales","func":"#include \"sort.h\"\n\nint partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n\n    pivot = array[hi];\n    i = lo;\n    j = lo;\n    while (j < hi)\n    {\n        if (array[j] <= pivot)\n        {\n            if (i != j)\n            {\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                print_array(array, size);\n            }\n            i++;\n\n        }\n        j++;\n    }\n    if (i != hi)\n    {\n        tmp = array[i];\n        array[i] = array[hi];\n        array[hi] = tmp;\n        print_array(array, size);\n    }\n    return (i);\n}\n\nvoid quicksort(int *array, int lo, int hi, size_t size)\n{\n    int q;\n\n    if (lo < hi)\n    {\n        q = partition(array, lo, hi, size);\n        quicksort(array, lo, q - 1, size);\n        quicksort(array, q + 1, hi, size);\n    }\n\n}\n\n\nvoid quick_sort(int *array, size_t size)\n{\n    if (array == NULL || size < 2)\n        return;\n    quicksort(array, 0, size - 1, size);\n}\n"}
{"target":"andi-s0106","func":"#include \"binary_trees.h\"\n\n\n\nsize_t binary_tree_leaves(const binary_tree_t *tree)\n{\n    size_t leaves;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    leaves = 0;\n    leaves = count_leaves(tree, leaves);\n\n    return (leaves);\n}\n\n\n\nsize_t count_leaves(const binary_tree_t *tree, size_t leaves)\n{\n    size_t left;\n    size_t right;\n\n    left = leaves;\n    right = leaves;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n\n    left = count_leaves(tree->left, leaves);\n    right = count_leaves(tree->right, leaves);\n\n    return (left + right);\n}\n"}
{"target":"andi-s0106","func":"#include \"binary_trees.h\"\n\n\n\nsize_t binary_tree_nodes(const binary_tree_t *tree)\n{\n    size_t nodes;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    nodes = 0;\n    nodes = count_nodes(tree, nodes);\n\n    return (nodes);\n}\n\n\n\nsize_t count_nodes(const binary_tree_t *tree, size_t nodes)\n{\n    size_t left;\n    size_t right;\n\n    left = nodes;\n    right = nodes;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    if (tree->right != NULL || tree->right != NULL)\n    {\n        nodes = nodes + 1;\n    }\n\n    left = left + count_nodes(tree->left, left);\n    right = right + count_nodes(tree->right, right);\n\n    return (nodes + left + right);\n}\n"}
{"target":"andi-s0106","func":"#include \"binary_trees.h\"\n\n\n\nint binary_tree_is_full(const binary_tree_t *tree)\n{\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    if (tree->left != NULL && tree->right == NULL)\n    {\n        return (0);\n    }\n\n    if (tree->left == NULL && tree->right != NULL)\n    {\n        return (0);\n    }\n\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n\n    if (binary_tree_is_full(tree->left) == 0)\n    {\n        return (0);\n    }\n\n    if (binary_tree_is_full(tree->right) == 0)\n    {\n        return (0);\n    }\n\n    return (1);\n}\n"}
{"target":"andi-s0106","func":"#include \"binary_trees.h\"\n\n\n\nsize_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    height = 0;\n    height =  calc_height(tree, height);\n    return (height - 1);\n}\n\n\nsize_t calc_height(const binary_tree_t *tree, size_t height)\n{\n    size_t left;\n    size_t right;\n\n    left = height;\n    right = height;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n\n    left = left + calc_height(tree->left, height);\n    right = right + calc_height(tree->right, height);\n\n    if (right > left)\n    {\n        return (right + 1);\n    }\n    return (left + 1);\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\nlistint_t *swap(listint_t **current, listint_t **sorted);\n\nvoid insertion_sort_list(listint_t **list)\n{\n    listint_t *current;\n    listint_t *sorted;\n\n\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n\n    sorted = *list;\n    current = (*list)->next;\n\n    while (current != NULL)\n    {\n        if (sorted != NULL &&  current->n < sorted->n)\n        {\n\n            current = swap(&current, &sorted);\n            sorted = current->prev;\n            if (sorted == NULL)\n                *list = current;\n            print_list(*list);\n\n            while (sorted != NULL && current->n < sorted->n)\n            {\n                current = swap(&current, &sorted);\n                sorted = current->prev;\n                if (sorted == NULL)\n                    *list = current;\n                print_list(*list);\n            }\n        }\n        else\n        {\n            sorted = current;\n            current = sorted->next;\n        }\n    }\n}\n\n\nlistint_t *swap(listint_t **current, listint_t **sorted)\n{\n    listint_t *tmp;\n\n    tmp = (*current)->next;\n    if (*sorted != NULL)\n        (*sorted)->next = tmp;\n    if (tmp != NULL)\n    {\n        tmp->prev = *sorted;\n    }\n    if (*current != NULL)\n        (*current)->next = *sorted;\n        (*current)->prev = (*sorted)->prev;\n    if ((*sorted)->prev != NULL)\n        (*sorted)->prev->next = *current;\n    ((*sorted)->prev) = *current;\n\n    return (*current);\n}\n"}
{"target":"andi-s0106","func":"#include <stdio.h>\n#include <stdlib.h>\n#include \"sort.h\"\n\n\nlistint_t *create_listint(const int *array, size_t size)\n{\n    listint_t *list;\n    listint_t *node;\n    int *tmp;\n\n    list = NULL;\n    while (size--)\n    {\n        node = malloc(sizeof(*node));\n        if (!node)\n            return (NULL);\n        tmp = (int *)&node->n;\n        *tmp = array[size];\n        node->next = list;\n        node->prev = NULL;\n        list = node;\n        if (list->next)\n            list->next->prev = list;\n    }\n    return (list);\n}\n\n\nint main(void)\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    listint_t *list;\n    int array[] = {17, 41, 5, 22, 28, 6, 5, 3, 5};\n    size_t n = sizeof(array) \/ sizeof(array[0]);\n\n    list = create_listint(array, n);\n    if (!list)\n        return (1);\n    print_list(list);\n    printf(\"\\n\");\n    insertion_sort_list(&list);\n    printf(\"\\n\");\n    print_list(list);\n    return (0);\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\n#include <stdlib.h>\nvoid swap(int *array, int gap, int idx);\n\n\n\nvoid shell_sort(int *array, size_t size)\n{\n    int limit;\n    int idx;\n    int gap;\n    int up;\n\n    if (size < 2)\n        return;\n    up = (int) size;\n    for (gap = 1; gap < up \/ 3; gap = gap * 3 + 1)\n    {}\n\n    for (limit = 0; limit < up;)\n    {\n        idx = limit;\n\n        while (idx < up)\n        {\n            if (idx + gap < up && array[idx] > array[idx + gap])\n                swap(array, gap, idx);\n            idx = idx + gap;\n        }\n        limit++;\n        if (limit == gap)\n        {\n            gap = gap \/ 3;\n            limit = 0;\n            print_array(array, size);\n        }\n        if (gap < 1)\n            break;\n    }\n}\n\n\nvoid swap(int *array, int gap, int idx)\n{\n    int tmp;\n\n    tmp = array[idx];\n    array[idx] = array[idx + gap];\n    array[idx + gap] = tmp;\n    idx = idx - gap;\n    while (idx >= 0)\n    {\n        if (array[idx] > array[idx + gap])\n        {\n            tmp = array[idx];\n            array[idx] = array[idx + gap];\n            array[idx + gap] = tmp;\n        }\n\n        idx = idx - gap;\n    }\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\nint swap(listint_t **list, listint_t *current, int);\n\n\nvoid cocktail_sort_list(listint_t **list)\n{\n    int flag;\n    listint_t *tmp;\n\n    flag = 0;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    tmp = *list;\n    while (flag == 0)\n    {\n        flag = 1;\n        while (tmp->next != NULL)\n        {\n            if (tmp->n > tmp->next->n)\n                flag = swap(list, tmp, 0);\n            else\n                tmp = tmp->next;\n        }\n        tmp = tmp->prev;\n        if (flag == 1)\n            break;\n        while (tmp->prev != NULL)\n        {\n            if (tmp->n < tmp->prev->n)\n                flag = swap(list, tmp, 1);\n            else\n                tmp = tmp->prev;\n        }\n        if (flag == 1)\n            break;\n    }\n}\n\n\nint swap(listint_t **list, listint_t *current, int flag)\n{\n    listint_t *tmp;\n\n    if (list == NULL || *list == NULL || current == NULL)\n        return (1);\n\n    if (flag == 1)\n        current = current->prev;\n    tmp = current->next;\n\n    if (tmp != NULL)\n    {\n        current->next = tmp->next;\n        tmp->next = current;\n        tmp->prev = current->prev;\n    }\n    if (current->next != NULL)\n        current->next->prev = current;\n    if (current->prev != NULL)\n        current->prev->next = tmp;\n    current->prev = tmp;\n\n    if (tmp->prev == NULL)\n        *list = tmp;\n\n    print_list(*list);\n    return (0);\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\n\nint partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n\n    }\n}\n\nvoid quicksort_hoare(int *array, int lo, int hi, size_t size)\n{\n    int p;\n\n    if (lo < hi)\n    {\n        p = partition(array, lo, hi, size);\n        quicksort_hoare(array, lo, p, size);\n        quicksort_hoare(array, p + 1, hi, size);\n    }\n\n}\n\n\nvoid quick_sort_hoare(int *array, size_t size)\n{\n    if (array == NULL || size < 2)\n        return;\n    quicksort_hoare(array, 0, size - 1, size);\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\n\n\n\nvoid selection_sort(int *array, size_t size)\n{\n    int min;\n    size_t i;\n    size_t j;\n    size_t position;\n\n    if (array == NULL)\n        return;\n\n    for (i = 0; i < size; i++)\n    {\n        min = array[i];\n        position = i;\n\n        for (j = i + 1; j < size; j++)\n        {\n            if (min > array[j])\n            {\n                position = j;\n                min = array[j];\n            }\n        }\n        if (position != i)\n        {\n            array[position] = array[i];\n            array[i] = min;\n            print_array(array, size);\n        }\n    }\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\n\nint partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n\n    pivot = array[hi];\n    i = lo;\n    j = lo;\n    while (j < hi)\n    {\n        if (array[j] <= pivot)\n        {\n            if (i != j)\n            {\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                print_array(array, size);\n            }\n            i++;\n\n        }\n        j++;\n    }\n    if (i != hi)\n    {\n        tmp = array[i];\n        array[i] = array[hi];\n        array[hi] = tmp;\n        print_array(array, size);\n    }\n    return (i);\n}\n\nvoid quicksort(int *array, int lo, int hi, size_t size)\n{\n    int q;\n\n    if (lo < hi)\n    {\n        q = partition(array, lo, hi, size);\n        quicksort(array, lo, q - 1, size);\n        quicksort(array, q + 1, hi, size);\n    }\n\n}\n\n\nvoid quick_sort(int *array, size_t size)\n{\n    if (array == NULL || size < 2)\n        return;\n    quicksort(array, 0, size - 1, size);\n}\n"}
{"target":"andi-s0106","func":"#include \"sort.h\"\n\n\nvoid insertion_sort_list(listint_t **list)\n{\n    listint_t *key;\n    listint_t *tmp;\n\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    key = (*list)->next;\n    while (key != NULL)\n    {\n        if (key->next != NULL && key->next->n < key->n)\n        {\n            tmp = key->next;\n            key->prev->next = tmp;\n            if (tmp->next != NULL)\n                tmp->next->prev = key;\n            key->next = tmp->next;\n            tmp->prev = key->prev;\n            tmp->next = key;\n            key->prev = tmp;\n            print_list(*list);\n        }\n        else\n        {\n            tmp = key;\n            key = key->next;\n        }\n        while (tmp->prev != NULL && tmp->n < tmp->prev->n)\n        {\n            tmp->prev->next = tmp->next;\n            tmp->next = tmp->prev;\n            if (tmp->prev->prev != NULL)\n                tmp->prev->prev->next = tmp;\n            tmp->prev = tmp->prev->prev;\n            tmp->next->prev = tmp;\n            if (tmp->next->next != NULL)\n                tmp->next->next->prev = tmp->next;\n            if (tmp->prev == NULL)\n                *list = tmp;\n            print_list(*list);\n        }\n    }\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\n\nint cyclic_rotate(int arr1[], int size_arr1)\n{\n  int meh = 0, msf = 0; \n  for(int i = 0; i<size_arr1;i++)\n  {\n    meh = meh + arr1[i]; \n\n    if(msf<meh) \n    {\n      msf = meh;\n    }\n    if(meh<0) \n    { \n      meh = 0;\n    }\n  }\n  return meh;  \n}\n\n\nint main()\n{\n  int arr1[] = {-2,-3,4,-1,-2,1,5,-3}, no,j=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int);\n  array_print(arr1,size_arr1);\n  int sum = cyclic_rotate(arr1,size_arr1);\n  printf(\"Sum is %d\",sum);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n\n\n\n\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  if(no%2 == 0)\n  {\n   mid = no\/2;\n  }\n  else\n  {\n    mid = (no-1)\/2;\n  }\n  for(int i = no-1; i>=mid; i--)\n  {\n    temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    j++;\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n\nvoid reverse_array(int arr[], int START, int END)\n{\n  int temp = 0;\n  while(START<END)\n  {\n    temp = arr[END];\n    arr[END] = arr[START];\n    arr[START] = temp;\n    START++;\n    END--;\n  }\n}\nint main()\n{\n  int arr[100],no,j=0,temp=0,mid=0,n=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n\n\n\n\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  array_print(arr,no);\n  reverse_array(arr,0,no-1);\n  printf(\"\\n\");\n  array_print(arr,no);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int arr[100],arr1[100],no,j=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n\n\n\n\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  for(int i = no-1; i>=0; i--)\n  {\n    arr1[j] = arr[i];\n    j++;\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr1[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n\n\n\nvoid max_min_array(int arr[], int max, int min, int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    if(min>arr[i])\n    {\n      min = arr[i];\n    }\n    else\n    {\n      max = arr[i];\n    }\n  }\n  printf(\"Max is %d Min is %d\",max,min);\n}\n\nint main()\n{\n  int arr[100],no,j=0,temp=0,mid=0,max = 0, min = 0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  min = arr[0];\n  max = arr[0];\n  max_min_array(arr,max,min,no);  \n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nstruct pair\n{\n  int min;\n  int max;\n};\n\n\n\n\nstruct pair max_min_array(int arr[], int no)\n{\n  struct pair minmax;\n  if( no == 1)\n  {\n    minmax.max = arr[0];\n    minmax.min = arr[0];\n    return minmax;\n  }\n  if(arr[0] > arr[1])\n  {\n    minmax.max = arr[0];\n    minmax.min = arr[1];\n  }\n  else\n  {\n    minmax.max = arr[1];\n    minmax.min = arr[0];\n  }\n  \n  for(int i = 0; i<no; i++)\n  {\n    if(arr[i] < minmax.min)\n      minmax.min = arr[i];\n    else if(arr[i] > minmax.max)\n      minmax.max = arr[i];\n  }\n  return minmax;\n}\n\nint main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6;\n  struct pair minmax = max_min_array(arr,no);\n  printf(\"Max value is %d \\nMin value is %d\",minmax.min,minmax.max);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nstruct pair\n{\n  int min;\n  int max;\n};\n\n\n\n\nstruct pair max_min_array(int arr[], int low, int high)\n{\n  struct pair minmax,mml,mmr;\n  int mid;\n\n  if( low == high)\n  {\n    minmax.max = arr[low];\n    minmax.min = arr[low];\n    return minmax;\n  }\n\n  if(high == low+1)\n  {\n    if(arr[low]>arr[high])\n    {\n      minmax.max = arr[low];\n      minmax.min = arr[high];\n    }\n    else\n    {\n      minmax.min = arr[low];\n      minmax.max = arr[high];\n    }\n    return minmax;\n  }\n\n  mid = (low+high)\/2;\n  mml = max_min_array(arr, low, mid);\n  mmr = max_min_array(arr, mid+1, high);\n  \n  if(mml.min < mmr.min)\n    minmax.min = mml.min;\n  else\n    minmax.min = mmr.min;\n\n  if(mml.max > mmr.max)\n    minmax.max = mml.max;\n  else\n    minmax.max = mmr.max;\n  return minmax;\n}\n\nint main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6;\n  struct pair minmax = max_min_array(arr,0,no-1);\n  printf(\"Max value is %d \\nMin value is %d\",minmax.min,minmax.max);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n\n\n\nint kmin(int arr[], int size, int k)\n{\n  int  temp = 0, count = 0, index = 0;\n\n  while(count <= k)\n  { \n    int min = arr[count], index = count;\n    for(int i = count; i < size; i++)\n    {\n      if(min > arr[i])\n      {\n        min = arr[i];\n    index = i;\n      }\n    }\n    if(count != index)\n    {\n      temp = arr[index];\n     \n      arr[index] = arr[count];\n      \n      arr[count] = temp;\n      \n    }\n    count++;\n    \n  }\n  return (count-1);\n}\nint main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6,k=0,rindex=0;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  printf(\"Enter value of kth\");\n  scanf(\"%d\",&k);\n  rindex = kmin(arr,(no-1),(k-1));\n  printf(\"rindex is %d\\n\",rindex);\n  printf(\"kth Min value is %d\",arr[rindex]);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n\n\n\nint swap(int* a, int* b)\n{\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\n\n\nint sort(int arr[], int size)\n{\n  int low,mid,high;\n  low = mid = 0;\n  high = (size-1);\n  while(mid<=high)\n  {\n    switch (arr[mid]) \n    { \n      case 0: \n          swap(&arr[low++], &arr[mid++]); \n          break; \n      case 1: \n          mid++; \n          break; \n      case 2: \n          swap(&arr[mid], &arr[high--]); \n          break;\n    }\n  }\n}\n\n\n\n\n   \nint main()\n{\n  int arr[] = {0,1,1,0,1,2,1,2,0,0,0,1};\n  int no = 12;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  sort(arr,no);\n  printf(\"\\n\");\n  array_print(arr,no);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  printf(\"Array is :- \");\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n\nint swap(int* a, int* b)\n{\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nvoid sort012(int arr[], int size)\n{\n  int low,mid,high;\n  low = mid = 0;\n  high = (size-1);\n  while(mid<=high)\n  {\n    if(arr[mid]==0)\n    {\n      swap(&arr[low], &arr[mid]);\n      low++;\n      mid++;\n      continue;\n    }\n    if(arr[mid]==1)\n    {\n      mid++;\n      continue;\n    }\n    if(arr[mid]==2)\n    {\n      swap(&arr[mid], &arr[high]);\n      high--;\n      continue;\n    }\n  }\n}\n\nint main()\n{\n  int arr[] = {0,1,1,0,0,2,1,2,0,0,0,1};\n  int no = 12;\n  array_print(arr,no);\n  sort012(arr,no);\n  printf(\"\\n\");\n  array_print(arr,no);\n}\n"}
{"target":"ankitraj311","func":"\n\n#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n\n\n\n\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n\n  printf(\"\\n\");\n\n  for(int i = 0; i<no; i++)\n  {\n    if(arr[i]<0)\n    {\n      if(i != j)\n      {\n        temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n      j++;\n    }\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"\n\n#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n\n\n\n\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n\n  printf(\"\\n\");\n  if(no%2 == 0)\n  {\n   mid = no\/2;\n  }\n  else\n  {\n    mid = (no-1)\/2;\n  }\n\n  for(int i = no-1; i>=mid; i--)\n  \n  {\n    if(arr[i]<0)\n    {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j++;\n    }\n  }\n\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int i = 0, j = 0;\n  \n  while(i<size_arr1 && j<size_arr2)\n  {\n    if(arr1[i] < arr2[j])\n    { \n      printf(\"%d \",arr1[i++]); \n    }\n    if(arr1[i] > arr2[j])\n    {\n      printf(\"%d \",arr2[j++]); \n    }\n    if(arr1[i] == arr2[j])\n    {\n      printf(\"%d \",arr2[j++]); \n      i++;\n    }\n  }\n  while(i<size_arr1)\n    printf(\"%d \",arr1[i++]);\n  while(j<size_arr2)\n    printf(\"%d \",arr2[j++]);\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  union_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\nvoid array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nint ispresent(int arr1[], int size_arr1, int arr2[], int index_val) \n{\n  for(int i = 0; i<size_arr1; i++)\n  {\n    if(arr1[i] == arr2[index_val])\n    {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint remove_repeat(int arr[], int size_arr) \n{\n  for(int i = 0; i<size_arr; i++)\n  {\n    for(int j = i+1; j<size_arr;j++)\n    { \n      if(arr[i] == arr[j])\n      {\n        for(int k = j; k<size_arr; k++)\n    {\n          arr[k] = arr[k+1];\n    }\n    size_arr--;\n      }\n    }\n  }\n  return size_arr;\n}\nvoid union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;\n\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[k] = arr1[i];\n    k++;\n  }\n\n  for(int i = 0; i<size_arr2; i++)\n  {\n    int val = ispresent(arr1,size_arr1,arr2,i); \n    if(val == 0)\n    {\n      arr3[k] = arr2[i];\n      k++;\n    }\n  }\n\n  printf(\"Array after Union :-\");\n  array_print(arr3,k);\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  size_arr1 = remove_repeat(arr1,size_arr1); \n  size_arr2 = remove_repeat(arr2,size_arr2); \n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  union_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size);\n  for(int i = 0; i<total_size; i++)\n  {\n    for(int j = i+1; j<total_size;)\n    {\n      if(arr3[i] == arr3[j])\n      {\n        for(int k = j; k<total_size; k++)\n    {\n          arr3[k] = arr3[k+1];\n    }\n    total_size--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,total_size);\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  union_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid union_array(int arr1[], int arr2[])\n{\n  int size_arr1 = (sizeof(arr1)\/sizeof(int)), size_arr2 = (sizeof(arr2)\/sizeof(int));\n  int arr3[size_arr1+size_arr2], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  array_print(arr3,size_arr1+size_arr2);\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  array_print(arr1,sizeof(arr1)\/sizeof(int));\n  array_print(arr2,sizeof(arr2)\/sizeof(int));\n  union_array(arr1,arr2);\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int i = 0, j = 0;\n  \n  while(i<size_arr1 && j<size_arr2)\n  {\n    if(arr1[i] < arr2[j])\n      i++;  \n    if(arr1[i] > arr2[j])\n      j++;\n    if(arr1[i] == arr2[j])\n    {\n      printf(\"%d \",arr2[j]); \n      j++;\n      i++;\n    }\n  }\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0; \n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\nvoid array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nint ispresent(int arr1[], int size_arr1, int arr2[], int index_val) \n{\n  for(int i = 0; i<size_arr1; i++)\n  {\n    if(arr1[i] == arr2[index_val])\n    {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint remove_repeat(int arr[], int size_arr) \n{\n  for(int i = 0; i<size_arr; i++)\n  {\n    for(int j = i+1; j<size_arr;j++)\n    { \n      if(arr[i] == arr[j])\n      {\n        for(int k = j; k<size_arr; k++)\n    {\n          arr[k] = arr[k+1];\n    }\n    size_arr--;\n      }\n    }\n  }\n  return size_arr;\n}\nvoid intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;\n\n  for(int i = 0; i<size_arr2; i++)\n  {\n    int val = ispresent(arr1,size_arr1,arr2,i); \n    if(val == 1)\n    {\n      arr3[k] = arr2[i];\n      k++;\n    }\n  }\n\n  printf(\"Array after Union :-\");\n  array_print(arr3,k);\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  size_arr1 = remove_repeat(arr1,size_arr1); \n  size_arr2 = remove_repeat(arr2,size_arr2); \n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\n\nvoid array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], arr4[total_size], j = 0, k = 0;\n  for(int i = 0; i<size_arr1; i++) \n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++) \n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size); \n  for(int i = 0; i<size_arr1; i++) \n  {\n    for(int j = 0; j<size_arr2;j++)\n    {\n      if(arr1[i] == arr2[j])\n      {\n        arr4[k] = arr1[i];\n        k++;\n      }\n    }\n  }\n  printf(\"Array after k is %d Intersection  :-\",k);\n  array_print(arr4,k);\n  int size_arr4 = k;\n  printf(\"Array is :-\"); \n  for(int i = 0; i<size_arr4;i++) \n  {\n    for(int j = i+1; j<size_arr4;j++)\n    {\n      if(arr4[i] == arr4[j])\n      {\n        for(int k = j; k<size_arr4;k++)\n    {\n          arr4[k] = arr4[k+1];\n    }\n    size_arr4--;\n      }\n    }\n  }\n  array_print(arr4,size_arr4); \n}\n\nint main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int), size_arr2 = sizeof(arr2)\/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h>\n#include<string.h>\n\n\n\n\n\n\nvoid array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}\n\n\n\n\n\nvoid cyclic_rotate(int arr1[], int size_arr1)\n{\n  int last_element,i=0;\n  last_element = arr1[size_arr1-1];\n  for(i = size_arr1-1; i > 0; i--)\n    arr1[i] = arr1[i-1];\n  arr1[0] = last_element;\n}\n\nint main()\n{\n  int arr1[] = {1,2,3,4, 5,}, no,j=0;\n  int size_arr1 = sizeof(arr1)\/sizeof(int);\n  array_print(arr1,size_arr1); \n  cyclic_rotate(arr1,size_arr1);\n  array_print(arr1,size_arr1); \n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<math.h>\nint main()\n{\n\n  int a,b,i,j,flag=-1,small,large,mul=0,sum;\n  printf(\"Enter the value of the a and b\");\n  scanf(\"%d%d\",&a,&b);\n  \n\n\n\n\n\n  if( (a<0 && b<0) || (a>0 && b>0) )\n  {\n    flag = 0;\n  }\n  else if((a>0 && b<0) || (a<0 && b>0))\n  {\n    flag = 1;\n  }\n \n\n  if(a<0)\n  { \n    a = -1 * a;\n  }\n  else if(b < 0)\n  {\n    b = -1 * b;\n  }\n\n  printf(\"a is %d, b is %d\",a,b);\n  if(a>b)\n  {\n    large = a;\n    small = b;\n  }\n  else\n  {\n    large = b;\n    small = a;\n  }\n\n  for(i=1;i<=small;i++)\n  {\n    mul = mul + large;\n  }\n\n  if(flag == 0)\n  {\n    printf(\"multiplication is %d\",mul);\n  }\n  else if(flag == 1)\n  {\n    printf(\"multiplication is -%d\",mul);\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int salary;\n  float bonus;\n  char gender;\n\n\n\n\n\n\n\n  printf(\"Enter the Gender\");\n  scanf(\"%c\",&gender);\n  printf(\"Enter Salary\");\n  scanf(\"%d\",&salary);\n\n  if(gender == 'M' || gender == 'm')\n  {\n    if(salary > 10000)\n    {\n      bonus = (salary * .05);\n    }\n    else\n    {\n      bonus = (salary * .07);\n    }\n  }\n  if(gender == 'F' || gender == 'f')\n  {\n    if(salary > 10000)\n    {\n\n      bonus = (float)(salary * .10);\n    }\n    else\n    {\n      bonus = (float)(salary * .12);\n    }\n  }\n  salary = salary + bonus;\n  printf(\"Salary is %d\", salary);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,array[100],no=0, neg_sum = 0, pos_sum = 0;\n  printf(\"Enter How many numbers you want to Enter\");\n  scanf(\"%d\",&no);\n  \n  \n  \n  \n  \n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array[i]);\n  }\n\n  for(i=0; i<no; i++)\n  {\n    if( array[i] < 0)\n    {\n      neg_sum = neg_sum - (-array[i]);\n    }\n    if( array[i] > 0)\n    {\n     pos_sum = pos_sum + (array[i]);\n    }\n  }\n\n  printf(\"Neg_Sum is %d Pos_Sum is %d\",neg_sum,pos_sum);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,array1[100],array2[100],no=0, min = 0, max = 0;\n  printf(\"Enter number of Digit you want to use in Array\\n\");\n  scanf(\"%d\",&no);  \n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n \n  min = array1[0];\n  max = array1[0];\n\n  printf(\"Min Value Befor is %d\\n\",min);\n  printf(\"Max Value Befor is %d\\n\",max);\n  for(i=1; i<no; i++)\n  {\n    if(min > array1[i])\n    {\n      min = array1[i];    \n    }\n    \n    if(max < array1[i])\n    {\n      max = array1[i];    \n    }\n  }\n  printf(\"Min Value After is %d\\n\",min);\n  printf(\"Max Value After is %d\\n\",max);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,x,y,no,count=0;\n  printf(\"Enter the number, upto which you want to find out prime or not\");\n  scanf(\"%d\",&no);\n  \n\n\n\n\n\n\n\n  for(j=1; j<=no; j++)\n  {\n      count = 0;\n      for(i=1; i<=j; i++)\n      {\n        if( j%i == 0)\n        {\n          count++;\n        }\n      }\n      if( count == 2)\n      {\n        printf(\"%d \\n\",j);\n      }\n  }\n}\n\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,no,array1[100],array2[100],max1=0,max2=0,count=0;\n  printf(\"Enter Length of Array\\n\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  max1 = array1[0];\n  for(i=1; i<no; i++)\n  {\n    if(max1 < array1[i])\n    {\n      max1 = array1[i];\n      count = i;\n    }\n  }\n\n  for(j=0, i=0; i<no-1; i++,j++)\n  {\n    if(i < count)\n    {       \n      array2[i] = array1[j];\n    }\n    if(i >= count)\n    {\n    array2[i] = array1[j+1];\n    }\n  }\n\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}\n\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array1[100]={0},array2[100]={0},no=0,delete_no=0,delete_index=0,flag=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n      flag = 1;\n    }\n  }\n\n  if(flag == 1)\n  {\n    for(i=0; i<no-1; i++)\n    {\n      if( i < delete_index)\n      {\n        array2[i] = array1[i];\n      }\n      if( i >= delete_index)\n      {\n        array2[i] = array1[i+1];\n      }\n    }\n    printf(\"\\n\");\n    for(i=0; i<no; i++)\n    {\n    for(i=0; i<no-1; i++)\n    {\n      printf(\"%d \",array2[i]);\n    }\n  }\n}\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,array1[100],array2[100],no=0,delete_no=0,delete_index=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n    }\n  }\n\n  printf(\"\\n\");\n\n  for(j=0; j<no-1; j++)\n  {\n    if(j < delete_index)\n    {\n      array2[j] = array1[j];\n    }\n    if(j >= delete_index)\n    {\n      array2[j] = array1[j+1];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array1[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n\n  printf(\"Enter number to insert and position it from Array\\n\");\n  scanf(\"%d%d\",&insert_no,&insert_index);\n  insert_index = insert_index - 1;\n  \n  for(i=0; i<no+1; i++)\n  {\n    if( i < insert_index)\n    {\n      array2[i] = array1[i];\n    }\n    if( i == insert_index)\n    {\n      array2[i] = insert_no;\n    }\n    if( i > insert_index)\n    {\n      array2[i] = array1[i-1];\n    }\n  }\n\n  printf(\"\\n\");\n\n  for(i=0; i<no+1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,x,y,no,sum=0,a,b,dummy1=0, dummy2 = 0;\n  printf(\"Enter the Range to find the Perfect number between them\");\n  scanf(\"%d%d\",&a,&b);\n\n\n\n\n\n  for(j=a; j<=b; j++)\n  {\n    sum = 0;\n    dummy1 = j;\n    for( i=1; i<j; i++)\n    {\n      if(dummy1 % i == 0)\n      {\n        sum = sum + i;\n      }\n    }\n    if( dummy1 == sum)\n    {\n      printf(\"%d \",dummy1);\n    }\n  }\n\n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0, no=0,insert_no=0,insert_index=0,flag=0,count = 0i, count2 = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no-1], array2[no-1];\n\n\n\n\n  count = no;\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no;)\n    {\n      if(array1[i] == array1[j])\n      {\n        for(k=j; k<count; k++)\n    {\n          array1[k] = array1[k+1];\n    }\n    no--;\n      }\n      else\n      {\n        j++;\n\n      }\n    }  \n  }\n  printf(\"Value of count is %d and count2 is %d\",count,count2);\n  printf(\"Array after Removal of Repetation\\n\");\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n\n\n\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n\n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n  printf(\"After Sorting\\n\");\n  \n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    for(j=i+1;j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }  \n  }\n\n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,x,y,no,sum=0;\n  printf(\"Enter the number to find out happy or not\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n\n\n  while( sum != 1)\n  {\n    sum = 0;\n    while(no>0)\n    {\n      i = no % 10;\n      sum = sum + (i*i);\n      no = no \/ 10;\n    }\n    no = sum ;\n    printf(\"sum is %d\", sum);\n  }\n\n  if( sum == 1)\n  {\n    printf(\"Happy number\");\n  }\n  else\n  {\n    printf(\"Not Happy number\");\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n\n  int no,i,j,k,x,y,sum = 0,a,b;\n  printf(\"Enter the Range with lower and uppar limit to find out the Happy no.  or not\");\n  scanf(\"%d%d\",&a,&b);\n\n\n\n  for(i=a; i<=b; i++)\n  {\n    while( i > 0 )\n    {\n      x = i % 10;\n      sum = sum + (x*x);\n      i = i \/ 10;\n      if( i == 0)\n      {\n    sleep(1);\n        printf(\"sum is %d\\n\",sum);\n        if( sum == 1)\n        {\n          printf(\"Number is Happy\");\n          break;\n        }\n        i = sum;\n        sum = 0;\n      }\n    }\n }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,x,y,no,sum=0,dummy1=0;\n  printf(\"Enter the number to find out happy or not\");\n  \n\n\n\n\n\n\n\n  for(j=1; j<=1000; j++)\n  {\n    sum = 0;\n    dummy1 = j;\n    while( sum != 1 && sum != 4 )\n    {\n      sum = 0;\n      while(dummy1>0)\n      {\n        i = dummy1 % 10;\n        sum = sum + (i*i);\n        dummy1 = dummy1 \/ 10;\n      }\n      dummy1 = sum ;\n    }\n \n    if( sum == 1)\n    {\n      printf(\"%d \",j);\n    }\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j=0,k,O_no,D_no,a,b,arr[100];\n  int new[10]={0};\n  printf(\"Enter the number to find the repeatation in it\");\n  scanf(\"%d\",&O_no);\n\n\n\n\n\n\n            \n\n  while( O_no > 0 )\n  {\n    i = O_no % 10;\n    arr[j] = i;\n    O_no = O_no \/ 10;\n    j++;\n  }\n  \n  for(i=0; i<j; i++)\n  {\n    new[arr[i]]++;\n  }\n    \n  for(i=0; i<10; i++)\n  {\n    if(new[i]!=0)\n      printf(\"%d  frequency is %d \\n\",i, new[i]);\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n\n\n\n  total_count = len_array1+len_array2;\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }\n  }\n\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<total_count;)\n    {\n      if(array3[i] == array3[j])\n      {\n        for(k=j;k<total_count;k++)\n    {\n          array3[k] = array3[k+1];\n    }\n        total_count--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n\n  printf(\"\\nArray After Union, value of k is %d\\n\",k);\n  for(i=0; i<total_count; i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n\n\n\n  int intersection_arr[100];\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }\n  }\n\n  total_count = len_array1+len_array2;\n  for(i=0; i<len_array1+len_array2; i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n\n  for(i=0;i<len_array1;i++)\n  {\n    for(j=0; j<len_array2;j++)\n    {\n      if(array1[i] == array2[j])\n      {\n        intersection_arr[k] = array1[i];\n    k++;\n      }\n    }\n  }\n\n  printf(\"\\nArray After Intersection\\n\");\n  for(i=0; i<k; i++)\n  {\n    printf(\"%d \",intersection_arr[i]);\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,choice;\n  printf(\"Enter the choice to find the Area \\n1. Triangle \\n2. Circle \\n3. Rectangle \\n4. Square \\n5. Parallelogram\\n\");\n  scanf(\"%d\",&choice);\n \n \n \n \n \n \n  switch(choice)\n  {\n    case 1:\n      {\n        int a, b, c;\n    float Area;\n    printf(\"Enter the sides of the triangle\");\n    scanf(\"%d%d%d\",&a,&b,&c);\n    Area = (a*b*c);\n    printf(\"Area of the triangle is %.2f\",Area);\n    break;\n      }\n    case 2:\n      {\n        int r;\n    float Area;\n    printf(\"Enter the radius of circle\");\n    scanf(\"%d\",&r);\n    Area = (3.14 * r * r);\n    printf(\"Area of the circle is %.2f\",Area);\n    break;\n      }\n    case 3:\n      {\n        int a, b;\n    float Area;\n    printf(\"Enter the sides of the Rectangle\");\n    scanf(\"%d%d\",&a,&b);\n    Area = (a*b);\n    printf(\"Area of the Rectangle is %.2f\",Area);\n    break;\n      }\n    case 4:\n      {\n        int a;\n    float Area;\n    printf(\"Enter the side of square\");\n    scanf(\"%d\",&a);\n    Area = (a*a);\n    printf(\"Area of the square is %.2f\",Area);\n    break;\n      }\n    case 5:\n      {\n        int breath, height;\n    float Area;\n    printf(\"Enter the sides of the Parallelogram\");\n    scanf(\"%d%d\",&breath,&height);\n    Area = (breath*height);\n    printf(\"Area of the  Parallelogram is %.2f\",Area);\n    break;\n      }\n    default :\n      {\n        printf(\"Invalid Result\");\n    break;\n      }\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<math.h>\n\nint factorial(int);\nint main()\n{\n  float i,j,degree,radian,result, sine = 0;\n  int count = 0, k = 1, accurate;\n  printf(\"Enter the degree to find it by sin value by it\");\n  scanf(\"%f\",&degree);\n\n\n\n  radian = (float)degree * (3.1415\/180);\n  printf(\"Minimum is 3.Enter the value of the accurate, upto which you want to find the result\");\n  scanf(\"%d\",&accurate);\n  do\n  {\n    if(count % 2 == 0)\n    {\n      sine = (float)sine + (pow(radian,k)\/factorial(k));\n    }\n    if(count % 2 == 1)\n    {\n      sine = (float)sine - (pow(radian,k)\/factorial(k));\n    }\n    count++;\n    k = k + 2;\n  }\n  while(count <= accurate);\n  printf(\"\\nValue of sine %f\", sine);\n  printf(\"\\nValue of sine %f\", sin(radian));\n\n}\n\nint factorial(int val)\n{\n  int  fact= 1, i;\n  for(i=1; i<=val; i++)\n  {\n    fact = fact * i;\n  }\n  return fact;\n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0,pair_sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array[i]);\n  }\n  \n  printf(\"\\nEnter Element, whose you want to find pair\");\n  scanf(\"%d\",&pair_sum);\n  printf(\"\\nPair_sum is %d\\n\",pair_sum);\n\n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n     if(array[i] + array[j] == pair_sum)\n     {\n       printf(\"Pair for %d are (%d,%d) found at (%d,%d) position\\n\",pair_sum,array[i],array[j],i,j);\n     }\n    }\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<math.h>\n\nint factorial(int);\nint main()\n{\n  float i,j,degree,radian,result, cose = 0;\n  int count = 0, k = 0, accurate;\n  printf(\"Enter the degree to find it by sin value by it\");\n  scanf(\"%f\",&degree);\n\n\n\n  radian = (float)degree * (3.1415\/180);\n  printf(\"Minimum is 3.Enter the value of the accurate, upto which you want to find the result\");\n  scanf(\"%d\",&accurate);\n  do\n  {\n    if(count % 2 == 0)\n    {\n      cose = (float)cose + (pow(radian,k)\/factorial(k));\n    }\n    if(count % 2 == 1)\n    {\n      cose = (float)cose - (pow(radian,k)\/factorial(k));\n    }\n    count++;\n    k = k + 2;\n  }\n  while(count <= accurate);\n  printf(\"\\nValue of cos %f\", cose);\n  printf(\"\\nValue of cos %f\", cos(radian));\n\n}\n\nint factorial(int val)\n{\n  int  fact= 1, i;\n  for(i=1; i<=val; i++)\n  {\n    fact = fact * i;\n  }\n  return fact;\n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array[100]={0},lar_dif = 0, no = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  \n  \n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n      if( (array[j] - array[i]) > lar_dif)\n       {\n         lar_dif = (array[j] - array[i]);\n       }\n    }\n  }\n\n  printf(\"Value of Lar_dif is %d\",lar_dif);\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = sum + (last*last*last);\n      latest_no = latest_no\/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Armstrong\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Armstrong\\n\\n\");\n    }\n  }\n\n\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = (sum*10) + last;\n      latest_no = latest_no\/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Palindrom\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Palindrom\\n\\n\");\n    }\n  }\n\n\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i=0,j=0,k=0, no=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no], array2[no];\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  \n  for(i=no-1; i>=0; i--)\n  {\n    array2[j] = array1[i];\n    j++;\n  }\n  printf(\"\\n\");\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n  int i=0,j=0,k=0, no=0, min_sum = 0, sum = 0, min_i = 0, min_j = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no];\n\n\n\n\n\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  min_sum = array1[0] + array1[1];\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  \n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n      sum = array1[i] + array1[j];\n      if( abs(min_sum) > abs(sum) )\n      {\n        min_sum = sum;\n    min_i = i;\n    min_j = j;\n      }  \n    }\n  }\n printf(\"Sum of %d %d Gives Nearest\\n\",array1[min_i],array1[min_j]); \n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n  int i,j,k,no=0,max=0;\n  printf(\"Enter Length of array\\n\");\n  scanf(\"%d\",&no);\n\n\n\n  int *a = (int*)(malloc(no * sizeof(int)));\n  printf(\"Enter Array numbers\\n\");\n  for(i=0; i<no; i++)\n  {\n   scanf(\"%d\",&a[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",a[i]);\n  }\n  max = a[0];\n  for(i=0; i<no; i++)\n  {\n    if(max < a[i])\n    { \n      max = a[i];\n    }\n  }\n  printf(\"Value of Max is %d\",max);\n  max+=1;\n  int b[max];\n  a = (int*)(realloc(a,max * sizeof(int)));\n  for(i=0; i<max; i++)\n  {\n    b[i] = 0;\n    if(i>=no)\n    {\n      a[i] = 0;\n    }\n  }\n\n  \n  for(i=0; i<=max; i++)\n  {\n    if(a[i] != 0)\n    {\n      b[a[i]] = b[a[i]] + 1;\n    }\n  }\n  printf(\"Numbers Repeated odd numbers of Times\\n\");\n  for(i=0; i<max; i++)\n  {\n    if(b[i] != 0)\n    {\n      printf(\"%d is repeated %d times\\n\",i,b[i]);\n    }\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n\n\n\n\n\n  if( c1 == r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n  \n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n  \n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m1[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  \n    printf(\"\\n\") ;\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m2[i][j]);\n      }\n      printf(\"\\n\");\n    }\n   \n  \n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        for(k=0; k<r2; k++)\n        {\n          sum = sum + m1[i][k] * m2[k][j];  \n        }  \n        mul[i][j] = sum;\n        sum = 0;\n      }\n      printf(\"\\n\");\n    } \n    printf(\"Mutiplication of Matrix is -: \\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n       printf(\"%d \",mul[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  else\n  {\n    printf(\"Multiplication is Not Possible\");\n  } \n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];\n\n\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n \n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        add_array[i][j] = m1[i][j] + m2[i][j];\n      }\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%.2d \",add_array[i][j]);\n      }\n      printf(\"\\n\");\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = add_array[i][j];\n    add_array[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];\n\n\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n \n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        add_array[i][j] = m2[i][j] - m1[i][j];\n      }\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%.2d \",add_array[i][j]);\n      }\n      printf(\"\\n\");\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = add_array[i][j];\n    add_array[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n\n\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n \n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        for(k=0; k<r2; k++)\n    {\n          sum = sum + m1[i][k]* m2[k][j];\n    }\n    mul[i][j] = sum;\n    sum = 0;\n      }\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%d \",mul[i][j]);\n      }\n      printf(\"\\n\");\n    }\n\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = mul[i][j];\n    mul[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n\n\n\n\n\n  if( c1==c2 && r1==r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n  \n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n  \n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if(m1[i][j] == m2[i][j])\n    {\n      flag = 1;\n    }\n    else\n        {\n          flag = 2;         \n      break;\n      }\n    }\n  }\n }\n else\n {\n   printf(\"Comparison is Not Possible\");\n }\n\n    if(flag == 1)\n    {\n      printf(\"Matrix Matched\");\n    }  \n    else\n    {\n      printf(\"Matrix didn't Matched\");\n    }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n\n\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n\n  printf(\"Value Befor Transpose\\n\"); \n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d\",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      m2[j][i] = m1[i][j];\n    }\n    printf(\"\\n\");\n  }\n\n  printf(\"Value after Transpose\\n\"); \n  for(i=0; i<c1; i++)\n  {\n    for(j=0; j<r1; j++)\n    {\n      printf(\"%d \",m2[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n\n\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    sum = sum + m1[i][i];\n  }\n\n  printf(\"Value of Trace is %d \",sum); \n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n\n\n\n\n  if(r1 == c1)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n \n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m1[i][j]);\n      }\n      printf(\"\\n\");\n    }\n\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if( i == j && m1[i][j] == 1)\n    {\n          flag++;\n    }\n    if( i != j && m1[i][j] == 0)\n    {\n      flag++;\n    }\n      }\n    }  \n \n  }\n  else\n  {\n    printf(\"Identical Matrix Should be a Square Matrix\\n\");\n  }\n  if(flag == (r1*c1))\n  {\n    printf(\"Matrix is Identical\\n\");\n  }\n  else\n  {\n    printf(\"Matrix is Not Identical\");\n  }\n  printf(\"\\nValue of flag is %d\",flag);\n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      row_sum = row_sum + m1[i][j];\n    }\n    printf(\"Sum of Row[%d] is %d\\n\",i,row_sum);\n    row_sum = 0;\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      col_sum = col_sum + m1[j][i];\n    }\n    printf(\"Sum of col[%d] is %d\\n\",i,col_sum);\n    col_sum = 0;\n  }\n }\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    diagnoal1 = diagnoal1 + m1[i][i];\n    diagnoal2 = diagnoal2 + m1[i][c1];\n    c1--;\n  }\n  printf(\"\\n\\nValue of Diagnoal1 is %d & Diagnoal2 is %d\",diagnoal1,diagnoal2);\n\n }\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\nint main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;\n  float expo= 0.0;\n  printf(\"Enter Value of r1, c1 and Exponential\\n\");\n  scanf(\"%d%d%f\",&r1,&c1,&expo);\n  int m1[r1][c1], m2[r1][c1], mul[r1][c1], sum = 0;\n\n\n\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      m2[j][i] = m1[i][j];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m2[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  \n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<r1; j++)\n    {\n      for(k=0; k<r1; k++)\n      {\n        sum = sum + m1[i][k]*m2[k][j];\n      }\n      mul[i][j] = sum;\n      sum = 0;\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",mul[i][j]);\n    }\n    printf(\"\\n\");\n  }\n\n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j,k, count = 0;\n  char str_arr[100], f;\n  printf(\"Enter Character to find out Vowel\/Consonant\");\n  scanf(\"%[^\\n]s\",str_arr);\n\n\n\n  printf(\"Enter Vowel whose count you want to find\\n\");\n  scanf(\" %c\",&f);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == f)\n    {\n      count++;\n    }\n  }\n  if(count ==  0)\n  {\n    printf(\"Not even a Single Time Vowel is Found\");\n  }\n  else\n  {\n    printf(\"Vowel is Found %d Times\",count);\n  }\n\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j,k, count = 0, frequency[26] = {0};\n  char str_arr[100], f;\n  printf(\"Enter String to find Frequency\");\n  scanf(\"%[^\\n]s\",str_arr);\n\n\n  \n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] >= 'a' && str_arr[i] <= 'z')\n    {\n      frequency[str_arr[i] - 'a']++;   \n    }\n\n    if(str_arr[i] >= 'A' && str_arr[i] <= 'Z')\n    {\n      frequency[str_arr[i] - 'A']++;   \n    }\n  }\n\n  for(i=0; i<26; i++)\n  {\n    if(frequency[i] != 0)\n    {\n      printf(\"%c is Repeated %d times\\n\",i+'a',frequency[i]);\n    }\n  }\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j,k, count = 0, frequency[26] = {0};\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to convert Upper to Lower & Lower to Upper\");\n  scanf(\"%[^\\n]s\",str_arr);\n\n\n  \n  printf(\"%s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] > 'a' && str_arr[i] < 'z')\n    {\n      str_arr1[i] = (char)str_arr[i] - 32;\n    }\n\n    else if(str_arr[i] > 'A' && str_arr[i] < 'Z')\n    {\n      str_arr1[i] = (char)str_arr[i] + 32;\n    }\n    else\n    {\n      str_arr1[i] = str_arr[i];\n    }\n  }\n\n  printf(\"\\nAfter Conversion String is %s\\n\",str_arr1);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j = 0,k, count = 0, count1 = 0;\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to find It's palindrom or Not\\n\");\n  scanf(\"%[^\\n]s\",str_arr);\n\n\n  \n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    count++;\n  }\n  for(i=count-1; i>=0; i--)\n  {\n    str_arr1[j] = str_arr[i];\n    j++;\n  }\n  str_arr1[i] = '\\0';\n  printf(\"String After Reverse is %s\\n\",str_arr1);\n\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == str_arr1[i])\n    {\n    count1++;\n    }\n  }\n  printf(\"Value of Count1 is %d Count is %d\\n\",count1,count);\n  if(count1 == count)\n  {\n    printf(\"String is Palindrom\\n\");\n  }\n  else\n  {\n    printf(\"Not a Palindrom String\\n\");\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j = 0,k, count = 0, count1 = 0, len1 = 0, len2 = 0, flag = 0;\n  char str[100], str_sub[100];\n  printf(\"Enter a Universal string to find Substring\\n\");\n  scanf(\"%[^\\n]s\",str);\n\n\n  \n  printf(\"Enter a Substring\\n\");\n  scanf(\" %[^\\n]s\",str_sub);\n  len1 = strlen(str);\n  len2 = strlen(str_sub);\n  for(i=0; i<=(len1 - len2); i++)\n  {\n    for(j=i; j<(i+len2); j++)\n    {\n      flag = 1;\n      if( str[j] != str_sub[j-i])\n      { \n        flag = 0;\n    break;\n      }\n    }\n    if(flag == 1)\n    break;\n  }\n  \n  if(flag == 1)\n  {\n    printf(\"\\nSub_String Found\");\n  }\n  else\n  {\n    printf(\"Sub_String Not FOund\");\n  }\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\nint i;\nchar str[100],c;\nprintf(\"Enter a string\\n\");\nscanf(\"%[^\\n]s\",str);\n\n\n\n\nprintf(\"%c\\n\",str[0]);\nprintf(\"%d\",str[0]-32);\nfor(i=0;i<strlen(str);i++)\n{\n    \n    \n  if(str[i]>='A'&&str[i]<='Z')\n  {\n      c=str[i];\n      break;\n  }\n  else\n  {\n      continue;\n  }\n}\n\nprintf(\"\\nFirst capital letter of string %s is %c\\n\",str,c);\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\nint i = 0, j = 0, k = 0;\nchar str1[100] = {0},str_sub[100][100] = {0},c;\nprintf(\"Enter a string\\n\");\nscanf(\"%[^\\n]s\",str1);\n\n\n\nprintf(\"Enter character From where you want to Split\\n\");\nscanf(\" %c\",&c);\n\nwhile(str1[k] != '\\0')\n{\n  j = 0;\n  while(str1[k] != c && str1[k] != '\\0')\n  {\n    str_sub[i][j] = str1[k];\n    j++;\n    k++;\n  }\n  str_sub[i][j] = '\\0';\n  i++;\n  if(str1 != '\\0')\n  {\n    k++;\n  }\n}\nint len = i;\nprintf(\"Words after Splitting are:\\n\");\nfor(i=0; i<len; i++)\n{\n  printf(\"%s\\n\",str_sub[i]);\n}\n\n\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n  int i,j,k, count = 0;\n  char str1[100][100], s[100];\n  printf(\"Enter Number of word you want to Enter\\n\");\n  scanf(\"%d\",&count);\n\n\n\n\n  printf(\"Enter Words, which you to be sorted Alphabatically\\n\");\n  for(i=0; i<count; i++)\n  {\n    scanf(\"%s\",str1[i]);\n  }\n  printf(\"\\n\");\n  for(i=0; i<count; i++)\n  {\n    printf(\"%s\\n\",str1[i]);\n  }\n\n  for(i = 0; i<count; i++)\n  {\n    for(j = i+1; j< count; j++)\n    {\n      if(strcmp(str1[i],str1[j])>0)\n      {\n        strcpy(s,str1[i]);\n    strcpy(str1[i],str1[j]);\n    strcpy(str1[j],s);\n      }\n    }\n  }\n  printf(\"Sorted Alphatically\\n\");\n  for(i=0; i<count; i++)\n  {\n    printf(\"%s\\n\",str1[i]);\n  }\n}\n"}
{"target":"ankitraj311","func":"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nvoid calculate_the_maximum(int n, int k)\n{\n  int old_answer_or=0,new_answer_or=0,old_answer_xor=0,new_answer_xor=0,old_answer_and=0,new_answer_and=0,i,j;\n  for(i=1;i<n;i++)\n  {\n    for(j=i+1;j<=n;j++)\n    {\n      if( (new_answer_and = (i & j)) < k)\n      {\n        if( new_answer_and > old_answer_and )\n        {\n          old_answer_and = new_answer_and;\n        }\n      }\n      if( (new_answer_or = (i | j)) < k)\n      {\n        if( new_answer_or > old_answer_or )\n        {\n          old_answer_or = new_answer_or;\n        }\n      }\n      if( (new_answer_xor = (i ^ j)) < k)\n      {\n        if( new_answer_xor > old_answer_xor )\n        {\n          old_answer_xor = new_answer_xor;\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\",old_answer_and);\n  printf(\"%d\\n\",old_answer_or);\n  printf(\"%d\",old_answer_xor);\n\n}\n\nint main()\n{\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    calculate_the_maximum(n, k);\n    return 0;\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n\n\n\n\n\n\n\n\n\n\nstruct node\n{\n  char c;\n  short int s;\n};\n\n\nstruct node\n{\n  short int s;\n  char c;\n  int i;\n};\n\n\nstruct node\n{\n  char c;\n  double d;\n  int i;\n};\n\n\nstruct node\n{\n  double d;\n  int i;\n  char c;\n};\n\n\n\n\n"}
{"target":"ankitraj311","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <pthread.h> \n\n\n\n\n\n\n\n\n\n\n\nvoid *myThreadFun(void *vargp) \n{ \n    sleep(1); \n    printf(\"Printing GeeksQuiz from Thread \\n\");\n    return NULL; \n} \n\nint main() \n{ \n    pthread_t thread_id; \n    printf(\"Before Thread\\n\"); \n        printf(\"ThreadId is %ld\\n\",thread_id);  \n    pthread_create(&thread_id, NULL, &myThreadFun, NULL); \n    pthread_join(thread_id, NULL); \n    printf(\"After Thread\\n\"); \n    exit(0); \n}\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<pthread.h>\n#include<unistd.h>\n\n\n\n\n\n\n\nvoid* myturn(void * arg)\n{\n  while(1)\n  {\n    sleep(1);\n    printf(\"myturn\\n\");\n  }\n  return NULL;\n}\n\n\nvoid* yourturn(void * arg)\n{\n  while(1)\n  {\n    sleep(1);\n    printf(\"yourturn\\n\\n\");\n  }\n  return NULL;\n}\n\nint main()\n{\n  pthread_t thread_id, thread_id1;\n  pthread_create(&thread_id,NULL,myturn,NULL);  \n  pthread_create(&thread_id,NULL,yourturn,NULL);\n  pthread_join(thread_id,NULL);\n  pthread_join(thread_id,NULL);\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<pthread.h>\n#include<unistd.h>\n\n\n\n\n\n\n\nvoid* myturn(void * arg)\n{\n  while(1)\n  {\n    sleep(1);\n    printf(\"myturn\\n\");\n  }\n  return NULL;\n}\n\n\nvoid* yourturn(void * arg)\n{\n  while(1)\n  {\n    sleep(1);\n    printf(\"yourturn\\n\\n\");\n  }\n  return NULL;\n}\n\nint main()\n{\n  pthread_t thread_id, thread_id1;\n  pthread_create(&thread_id,NULL,myturn,NULL);\n  pthread_create(&thread_id1,NULL,yourturn,NULL);\n  pthread_join(thread_id,NULL);\n  pthread_join(thread_id1,NULL);\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<pthread.h>\n#include<unistd.h>\n#include<stdlib.h>\n\n\n\n\n\n\n\nint g = 0;\nvoid* thread_fun(void *vargp)\n{ \n  \n  \n  int myid = *(int *)vargp;\n\n  \n  static int s = 0;\n  \n  ++s;\n  ++g;\n   while(1)\n   {\n     int i = 1;\n   }\n  \n  printf(\"Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\\n\",myid,myid,++s,++g);\n}\n\n\nint main()\n{\n  int  i;\n  pthread_t tid;\n\n  \n  for(i = 0; i<3; i++)\n  {\n    \n    pthread_create(&tid, NULL, thread_fun, (void*)&i);\n  }\n    \n    pthread_exit(NULL);\n    return 0;\n}\n"}
{"target":"ankitraj311","func":"\n    \n    \n    \n    \n    \n   \n\n\n\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n\nvoid sighandler(int); \n\nint main ()\n{\n   signal(SIGINT, sighandler);\n\n   while(1) \n   {\n      printf(\"Going to sleep for a second...\\n\");\n      sleep(1); \n   }\n   return(0);\n}\nvoid sighandler(int signum) \n{\n   printf(\"Caught signal %d, coming out...\\n\", signum);\n   \n}\n"}
{"target":"ankitraj311","func":"\n#include<stdio.h> \n#include<stdlib.h> \n#include<unistd.h> \n#include<sys\/types.h> \n#include<sys\/socket.h> \n#include<netinet\/in.h> \n\n\n\n\nint main()\n{\n      \n      char server_response[256];\n\n      \n      int network_socket;\n      network_socket = socket(AF_INET,SOCK_STREAM,0); \n                                                      \n  \n  \n      \n      struct sockaddr_in server_address;\n      server_address.sin_family = AF_INET;         \n      server_address.sin_port = htons(9000);       \n      server_address.sin_addr.s_addr = INADDR_ANY; \n                                                   \n  \n  \n      \n      int connection_status;\n      connection_status = connect(network_socket, (struct sockaddr*)&server_address, sizeof(server_address)); \n\n\n      \n      if(connection_status == -1)\n        printf(\"Error occur during creating the connection.\\n\");\n\n\n      \n      recv(network_socket, &server_response, sizeof(server_response),0);\n  \n\n      \n      if(connection_status != -1)\n        printf(\"%s\",server_response);\n  \n\n      \n      \n  \n\n      \n      close(network_socket);\n  \n      return 0;\n}\n\n\n\n\n\n\n"}
{"target":"ankitraj311","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n\n\n\nint main()\n{\n        \n    char server_message[256] = \"You have been reached the Server\";\n\n\n    \n    int server_socket;\n    server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n\n    \n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(9000);\n    server_address.sin_addr.s_addr = INADDR_ANY;\n\n\n    \n    bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address));\n\n\n    \n    listen(server_socket, 5); \n\n\n    \n    int client_socket;\n    client_socket = accept(server_socket, NULL, NULL);\n        \n\n    \n    send(client_socket, server_message, sizeof(server_message),0);\n\n    \n    close(server_socket);\n    return 0;\n}\n\n\n\n\n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\n#include <time.h>\n     \n\n\n\n\n\n\n\n\nunsigned long addall()\n{\n  unsigned long sum = 0;\n  int i = 0;\n  while(i<=1000000000)\n  {\n    sum += i;\n    i++;\n  }\n  return sum;\n\n}\n\nint main()\n{\n  clock_t start, end;\n  double cpu_time_used;\n  start = clock();\n  unsigned long sum = 0, i =0;\n  \n  sum = addall();\n  end = clock();\n  cpu_time_used = ((double) (end - start)) \/ CLOCKS_PER_SEC;\n  printf(\"Sum of the numbers till 100 Crore is %lu and Time taken by Program without thread is %f\",sum,cpu_time_used);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<pthread.h>\n\n\n\n\n\n\nunsigned long sum[4];\nvoid* addall(void * arg)\n{\n  long id = (long)arg;\n  int start = id*250000000;\n  int i = 1;\n  while(i<=250000000)\n  {\n    sum[id] += (i + start);\n    i++;\n  }\n  return NULL;\n}\n\nint main()\n{\n  clock_t start, end; \n  double cpu_time_used;\n  start = clock();\n\n  pthread_t id1, id2, id3, id4;\n\n  pthread_create(&id1,NULL,addall,(void *)0);\n  pthread_create(&id2,NULL,addall,(void *)1);\n  pthread_create(&id3,NULL,addall,(void *)2);\n  pthread_create(&id4,NULL,addall,(void *)3);\n  pthread_join(id1,NULL);\n  pthread_join(id2,NULL);\n  pthread_join(id3,NULL);\n  pthread_join(id4,NULL);\n  end = clock();\n  cpu_time_used = ((double) (end - start)) \/ CLOCKS_PER_SEC;\n  printf(\"Sum of the numbers till 100 Crore %lu and Time taken by Program with thread is %f\\n\",sum[0]+sum[1]+sum[2]+sum[3],cpu_time_used);\n\n}\n"}
{"target":"ankitraj311","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <pthread.h> \n\n\nint g = 0; \n\n\nvoid *myThreadFun(void *vargp) \n{ \n    \n    int *myid = (int *)vargp; \n\n    \n    static int s = 0; \n\n    \n    ++s; ++g; \n\n    \n    printf(\"Thread ID: %u, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n} \n\nint main() \n{ \n    int i; \n    pthread_t tid; \n\n    \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n\n    pthread_exit(NULL); \n    return 0; \n} \n\n"}
{"target":"ankitraj311","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <pthread.h> \n\n\nint g = 0; \n\n\nvoid *myThreadFun(void *vargp) \n{ \n    \n    int *myid = (int *)vargp; \n\n    \n    static int s = 0; \n\n    \n    ++s; ++g; \n\n    \n    printf(\"Thread ID: %d, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n} \n\nint main() \n{ \n    int i; \n    pthread_t tid; \n\n    \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n\n    pthread_exit(NULL); \n    return 0; \n} \n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<pthread.h>\n#include<stdlib.h>\n\n\n\n\n\n\n\n\n\nint g = 0;\n\nvoid *fun_thread(void *vargs)\n{\n  int myid;\n  myid = *(int *)vargs;\n  static int s = 0;\n  s++;\n  g++;\n  while(1)\n  {\n    int i = 1;\n  }\n  printf(\"Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\\n\",myid,myid,++s,++g);\n\n}\n\n\nint main()\n{\n  int i = 0;\n  pthread_t thread_id;\n  for(i = 0; i<3; i++)\n  {\n    pthread_create(&thread_id,NULL,fun_thread,(void *)&i);\n  }\n  pthread_exit(NULL);\n    return 0;\n\n}\n"}
{"target":"ankitraj311","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <pthread.h> \n\n\nint g = 0; \n\n\nvoid *myThreadFun(void *vargp) \n{ \n    \n    int *myid = (int *)vargp; \n\n    \n    static int s = 0; \n\n    \n    ++s; ++g; \n\n    \n    printf(\"Thread ID: %u, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n} \n\nint main() \n{ \n    int i; \n    pthread_t tid; \n\n    \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n\n    pthread_exit(NULL); \n    return 0; \n} \n\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<pthread.h>\n\n\n\n\n\n\n\n\n\n\nvoid *thread_fun(void *id)\n{\n  int *new_thread = (int *)id;\n  printf(\"new_thread id is %d\\n\",*new_thread);\n\n}\n\n\n\nint main()\n{\n  pthread_t id;\n\n  for(int i = 0; i<3; i++)\n  {\n    pthread_create(&id, NULL, thread_fun, (void *)&id);\n  }\n  pthread_join(id,NULL);\n\n  pthread_exit(NULL);\n}\n"}
{"target":"ankitraj311","func":"#include<stdio.h>\n#include<stdlib.h> \n#include<pthread.h> \n#include<unistd.h> \n\n\n\n\n\n\n\n\n\nvoid* fun_call()\n{\n  sleep(1);\n  printf(\"First Thread is created\\n\");\n  \n}\n\n\nint main()\n{\n  pthread_t thread_id;\n  printf(\"Befor Execution of Thread\\n\");\n  pthread_create(&thread_id,NULL,fun_call,NULL);\n  printf(\"Thread_id is %lu\\n\",thread_id);\n  pthread_join(thread_id,NULL);\n  printf(\"after Execution of Thread\\n\");\n}\n\n"}
{"target":"ankitraj311","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include<stdio.h>\n#include<pthread.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nvoid myturn()\n{\n  while(1)\n    {\n      sleep(1);\n      printf(\"Myturn\\n\");  \n    }\n}\n\n\nvoid yourturn()\n{\n  while(1)\n  {\n    sleep(1);\n    printf(\"yourturn\\n\");  \n  }\n}\n\nint main()\n{\n  myturn(); \n  yourturn();   \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"apoorvasrivastava98","func":"\n#include<stdio.h>\nvoid magic(int);\nvoid main()\n{\n    int n;\n    printf(\"Enter the number to be checked \\n\");\n    scanf(\"%d\",&n);\n    magic(n);\n}\nvoid magic(int n)\n{\n    int i,sum=0,num=n;\n        while (n > 0 || sum > 9) \n    { \n        if (n == 0) \n        { \n            n = sum; \n            sum = 0; \n        } \n        sum =sum + n % 10; \n        n = n \/ 10; \n    } \n     if(sum==1)\n     {\n         printf(\"%d is a magic number\",num);\n     }\n     else\n     {\n         printf(\"%d is not a magic number\",num);\n     }\n}\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nint count = 0;\nvoid main()\n{\n  void getdata(int[50],int);\n  void putdata(int[50],int);\n  int binary_search(int a[50],int,int);\n    int a[50],n,item,loc;\n    printf(\"Enter the value of n\\n\");\n    scanf(\"%d\",&n);\n    getdata(a,n);\n    printf(\"Enter the item to be searched\\n\");\n    scanf(\"%d\",&item);\n    printf(\"The given array is \\n\");\n    putdata(a,n);\n    loc=binary_search( a,n,item);\n    if(loc>=0)\n{\nprintf(\"element found at %d\\n\",loc);\n}\nelse\n{\nprintf(\"Item not found\\n\");\n}\n   \n    printf(\"Value of count=%d \\n\",count);\n}\n    void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the values in the array\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }\n    void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }\n       int binary_search(int x[50],int n,int item)\n       {\n        int i,lb=0,ub=n-1,mid;\n        count++;\n        while(lb<=ub)\n        {\n         count++;\n         mid=(lb+ub)\/2;\n         count++;\n         if(x[mid]==item)\n            {\n            count++;\n            return mid;\n            count++;\n            }\n            \n         else if(item>x[mid])\n            {\n            count++;\n            lb=mid+1;\n            count++;\n            }\n            \n         else\n            {\n            count++;\n            ub=mid-1;\n            count++;\n            }\n        }\n        count++;\n        return -1;\n        count++;\n       }\n\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nint count = 0;\nvoid main()\n{\n  void getdata(int[50],int);\n  void putdata(int[50],int);\n  void bubble_sort(int a[50],int);\n    int a[50],n;\n    printf(\"Enter the value of n\\n\");\n    scanf(\"%d\",&n);\n    getdata(a,n);\n    printf(\"Before sorting \\n\");\n    putdata(a,n);\n    bubble_sort( a,n);\n    printf(\"After sorting \\n\");\n    putdata(a,n);\n    printf(\"Value of count=%d \\n\",count);\n}\n    void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the value for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }\n    void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }\n    void bubble_sort(int a[50],int n)\n    {\n       int i,j,temp;\n       count++;\n       for(i=1;i<n;i++)\n       {\n           count++;\n           count++;\n           for(j=0;j<n-i;j++)\n           {\n               count++;\n               count++;\n               if(a[j]>a[j+1])\n               {\n                   count++;\n                   temp=a[j];\n                   count++;\n                   a[j]=a[j+1];\n                   count++;\n                   a[j+1]=temp;\n                   count++;\n               }\n           }\n       }\n    }\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nint count=0;\nvoid counting_sort(int[],int,int);\nvoid main()\n{\n    int n,k=0,A[30],i;\n    printf(\"Enter the value of n \\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the values to be sorted\\n\");\n    for (i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&A[i]);\n        if (A[i]>k) \n        {\n            k=A[i];\n        }\n    }\n    counting_sort(A, k, n);\n    printf(\"\\nValue of count=%d\",count);\n}\nvoid counting_sort(int A[], int k, int n)\n{\n    int i, j,B[30],C[100];\n    count++;\n    for (i=0;i<=k;i++)\n    {\n        C[i]=0;\n        count++;\n        }\n        count++;\n    for (j=1;j<=n;j++){\n        C[A[j]]=C[A[j]]+1;\n        count++;\n        }\n        count++;\n    for (i=1;i<=k;i++){\n        C[i]=C[i]+C[i-1];\n        count++;\n        }\n        count++;\n    for (j=n;j>=1;j--)\n    {\n        count++;\n        B[C[A[j]]]=A[j];\n        count++;\n        C[A[j]]=C[A[j]]-1;\n        count++;\n    }\n    printf(\"Array after sorting\\n \");\n    for (i=1;i<=n;i++)\n        printf(\"%d \",B[i]);\n}\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\nint count=0;\nvoid max_heapify(int[100],int,int);\nvoid build_max_heap(int[100],int);\nvoid heapsort(int[100],int);\n    void main()\n    {\n        void getdata(int[100],int);  \n        void putdata(int[100],int);  \n        int a[100],n;  \n        printf(\"Enter the value of n\\n\");    \n        scanf(\"%d\",&n);  \n        getdata(a,n);    \n        printf(\"Before sorting \\n\");    \n        putdata(a,n);\n        heapsort(a,n);\n        printf(\"After sorting \\n\");    \n        putdata(a,n);     \n        printf(\"value of count=%d \\n\",count);\n    }\n    void getdata(int x[100],int n)\n    {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n    }\n    void putdata(int x[100], int n)\n    {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n    }\n    void max_heapify(int a[100],int n,int i)\n    {\n        int temp;\n        int largest=i;\n        int left=2*i+1;\n        int right=2*i+2;\n        count++;\n        if(left<n && a[left]>a[largest])\n        {\n            count++;\n            largest=left;\n            count++;\n        }\n        count++;\n        if(right<n && a[right]>a[largest])\n        {\n            count++;\n            largest=right;\n            count++;\n        }\n        count++;\n        if(largest!=i)\n        {\n            count++;\n            temp=a[i];\n            count++;\n            a[i]=a[largest];\n            count++;\n            a[largest]=temp;\n            count++;\n            max_heapify(a,n,largest);\n            count++;\n        }\n    }\n    void build_max_heap(int a[100],int n)\n    {\n        int i;\n        count++;\n        for(i=(n\/2)-1;i>=0;i--)\n        {\n            count++;\n            max_heapify(a,n,i);\n            count++;\n        }\n    }\n    void heapsort(int a[100],int n)\n    {\n        int temp,i;\n        count++;\n        build_max_heap(a,n);\n        count++;\n        for(i=n-1;i>0;i--)\n        {\n            count++;\n            temp=a[0];\n            count++;\n            a[0]=a[i];\n            count++;\n            a[i]=temp;\n            count++;\n            max_heapify(a,i,0);\n            count++;\n        }\n    }\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nint count = 0;\nvoid main()\n{\n  void getdata(int[50],int);\n  void putdata(int[50],int);\n  void improvised_bubble_sort(int a[50],int);\n    int a[50],n;\n    printf(\"Enter the value of n\\n\");\n    scanf(\"%d\",&n);\n    getdata(a,n);\n    printf(\"Before sorting \\n\");\n    putdata(a,n);\n    improvised_bubble_sort( a,n);\n    printf(\"After sorting \\n\");\n    putdata(a,n);\n    printf(\"Value of count=%d \\n\",count);\n}\n    void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the value for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }\n    void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }\n    void improvised_bubble_sort(int a[50],int n)\n    {\n       int i,j,temp,flag=1;\n       count++;\n       for(i=1;i<n && flag;i++)\n       {\n           count++;\n           count++;\n           flag=0;\n           for(j=0;j<n-i;j++)\n           {\n               count++;\n               count++;\n               if(a[j]>a[j+1])\n               {\n                   count++;\n                   temp=a[j];\n                   count++;\n                   a[j]=a[j+1];\n                   count++;\n                   a[j+1]=temp;\n                   count++;\n                   flag=1;\n                   count++;\n               }\n           }\n       }\n    }\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\n#include<string.h>\nvoid main()\n{\nint i,j,m,n;\nchar x[50];\nchar y[50];\nint c[51][51];\nchar b[51][51];\nprintf(\"Enter the first string\\n\");\nscanf(\"%s\",x);\nprintf(\"Enter the second string\\n\");\nscanf(\"%s\",y);\nm=strlen(x);\nn=strlen(y);\nfor(i=1;i<=m;i++)\n{\nc[i][0]=0;\n}\nfor(j=0;j<=n;j++)\n{\nc[0][j]=0;\n}\nfor(i=1;i<=m;i++)\n{\n    for(j=1;j<=n;j++)\n    {\n        if(x[i-1]==y[j-1])\n        {\n        c[i][j]=c[i-1][j-1]+1;\n        b[i][j]=92;\n        }\n        else if(c[i-1][j]>=c[i][j-1])\n        {\n            c[i][j]=c[i-1][j];\n            b[i][j]='^';\n        }\n        else\n        {\n            c[i][j]=c[i][j-1];\n            b[i][j]='<';   \n        }\n    }\n}\nfor(i=0;i<=m;i++)\n{\n    for(j=0;j<=n;j++)\n    {\n        printf(\"%d \",c[i][j]);\n    }\n    printf(\"\\n\");\n}\nfor(i=1;i<=m;i++)\n{\n    for(j=1;j<=n;j++)\n    {\n        printf(\"%c \",b[i][j]);\n    }\n    printf(\"\\n\");\n}\n        \n}\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\nint main()\n{\n    int a[100];\n    int n,i,count=0,item;\n    printf(\"Enter the size of array\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the numbers in array \\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"The elements in array are: \\n\");\n     for(i=0;i<n;i++)\n    {\n        printf(\"%d\",a[i]);\n    }\n    printf(\"Enter the no. to be searched \\n\");\n    scanf(\"%d\",&item);\n    count++;\n    for(i=0;i<n;i++)\n    {\n        count++;\n        if(a[i]==item)\n        {\n            count++;\n            printf(\"\\n Number found at position %d \\n\",i);\n            count++;\n            break;\n        }\n        count++;\n    }\n    if(i==n)\n    {\n        printf(\"No.not found\");  \n    }\n    printf(\"Count=%d\",count);\n}\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\n#define inf 9999\nvoid matrix_chain_multiplication(int p[11],int n,int M[11][11],int S[11][11])\n{\n int i,j,k,l,q;\n for(l=2;l<=n;l++)\n {\n  for(i=1;i<=n-l+1;i++)\n  {\n   j=i+l-1;\n   M[i][j]=inf;\n   for(k=i;k<=j-1;k++)\n   {\n    q=M[i][k]+M[k+1][j]+p[i-1]*p[k]*p[j];\n    if(q<M[i][j])\n    {\n     M[i][j]=q;\n     S[i][j]=k;\n    }\n   }\n  }\n }\n}\n\nvoid putdata(int A[11][11],int row,int column)\n{\n int i,j;\n for(i=1;i<=row;i++)\n {\n   for(j=1;j<=column;j++)\n   {\n    printf(\"%d\\t\",A[i][j]);\n   }\n   printf(\"\\n\");\n }\n}\nvoid main()\n{\n int M[11][11],S[11][11],i,j,n,p[11];\n for(i=0;i<=10;i++)\n {\n  for(j=0;j<=10;j++)\n  {\n   M[i][j]=0;\n   S[i][j]=0;\n  }\n   p[i]=0;\n }\n printf(\"Enter the total number of matrices:\");\n scanf(\"%d\",&n);\n printf(\"Enter the chain of matrices:\");\n for(i=0;i<=n;i++)\n  scanf(\"%d\",&p[i]);\n matrix_chain_multiplication(p,n,M,S);\n printf(\"\\nResult\\n\");\n putdata(M,n,n);\n printf(\"\\nResult\\n\");\n putdata(S,n,n);\n}\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\n     int count =0;\n     void merge(int[50],int,int,int); \n     void merge_sort(int[50],int,int); \n     void main()\n      {\n       void getdata(int[50],int);\n       void putdata(int[50],int);\n       int i,a[50],n;\n       printf(\"Enter the value of n \\n\");\n       scanf(\"%d\",&n);\n       getdata(a,n);\n       printf(\"Before sorting \\n\");\n       putdata(a,n);\n       merge_sort(a,0,n-1);\n       printf(\"After sorting \\n\");\n       putdata(a,n);\n       printf(\"value of count=%d \\n\",count);\n      }\n     void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }\n     void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }\n     void merge(int a[], int p, int q, int r) \n        { \n         int i, j, k; \n         int n1 =q-p+1; \n         int n2 =r-q; \n         count++;\n         int L[n1],R[n2]; \n         count++;\n         for(i=0;i<n1;i++)\n          {\n              count++;\n              count++;\n           L[i]=a[p+i];\n           count++;\n          }\n         for(j=0;j<n2;j++)\n          {\n              count++;\n              count++;\n           R[j]=a[q+1+j];\n           count++;\n          }\n         i=0; \n         j=0; \n         k=p; \n         count++;\n         while(i<n1 && j<n2) \n          {\n              count++;\n           if(L[i] <= R[j]) \n            {\n                count++;\n            a[k]=L[i]; \n            count++;\n            i++; \n            count++;\n            } \n           else \n            {\n                count++;\n            a[k]=R[j];\n            count++;\n            j++; \n            count++;\n            } \n            count++;\n           k++;\n           \n          } \n          \n         while(i<n1) \n          {\n              count++;\n           a[k]=L[i];\n           count++;\n           i++;\n           count++;\n           k++; \n           count++;\n          } \n          \n         while(j<n2) \n          {\n           count++;\n           a[k]=R[j];\n           count++;\n           j++; \n           count++;\n           k++; \n           count++;\n          }\n        } \n       void merge_sort(int a[50],int p,int r)\n        {\n         int q;\n         count++;\n     if(p<r)\n       { \n             count++;\n             q=(p+r)\/2;\n             count++;\n             merge_sort(a,p,q);\n             count++;\n             merge_sort(a,q+1,r);\n             count++;\n             merge(a,p,q,r);\n             count++;\n            }\n           }\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\n     int count =0;\n       int partition(int [50],int,int); \n       void quick_sort(int[50],int,int);\n     void main()\n      {\n       void getdata(int[50],int);\n       void putdata(int[50],int);\n       int i,a[50],n;\n       printf(\"Enter the value of n \\n\");\n       scanf(\"%d\",&n);\n       getdata(a,n);\n       printf(\"Before sorting \\n\");\n       putdata(a,n);\n       quick_sort(a,0,n-1);\n       printf(\"After sorting \\n\");\n       putdata(a,n);\n       printf(\"value of count=%d \\n\",count);\n      }\n     void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }\n     void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }\n        \n    int partition(int a[50],int p,int r)\n   {\n    int x,i,j,temp;\n    x=a[r];\n    i=p-1;\n    count++;\n    for(j=p;j<=r-1;j++)\n    {\n        count++;\n        if(a[j]<=x)\n        {\n        count++;\n            i=i+1;\n        count++;\n            temp=a[j];\n        count++;\n            a[j]=a[i];\n        count++;\n            a[i]=temp;\n        count++;\n        }\n        count++;\n    }\n    count++;\n    temp =a[r];\n    count++;\n    a[r]=a[i+1];                       \n    count++;\n    a[i+1]=temp;\n    count++;\n    return i+1;\n    }\n\nvoid quick_sort(int a[50],int p,int r)\n{   \n    int q;\n    count++;\n    if(p<r)\n    {\n        count++;\n        q=partition(a,p,r);\n        count++;\n        quick_sort(a,p,q-1);\n        count++;\n        quick_sort(a,q+1,r);\n        count++;\n    }\n}\n"}
{"target":"apoorvasrivastava98","func":"   #include <stdio.h>\n   #include<time.h>\n     int count =0;\n       int partition(int [50],int,int); \n       void quick_sort(int[50],int,int);\n       int myrandom(int,int);\n     void main()\n      {\n       void getdata(int[50],int);\n       void putdata(int[50],int);\n       int i,a[50],n;\n       printf(\"Enter the value of n \\n\");\n       scanf(\"%d\",&n);\n       getdata(a,n);\n       printf(\"Before sorting \\n\");\n       putdata(a,n);\n       quick_sort(a,0,n-1);\n       printf(\"After sorting \\n\");\n       putdata(a,n);\n       printf(\"value of count=%d \\n\",count);\n      }\n     void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }\n     void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }\n      int myrandom(int lower,int upper)\n      {\n          int num;\n          srand(time(0));\n          num = (rand() % (upper - lower + 1) + lower);\n          return num;\n      }\n        \n    int partition(int a[50],int p,int r)\n   {\n    int x,i,j,temp,y;\n    y=myrandom(p,r-1);\n    temp=a[y];\n    a[y]=a[r];\n    a[r]=temp;\n    x=a[r];\n    i=p-1;\n    count++;\n    for(j=p;j<=r-1;j++)\n    {\n        count++;\n        if(a[j]<=x)\n        {\n        count++;\n            i=i+1;\n        count++;\n            temp=a[j];\n        count++;\n            a[j]=a[i];\n        count++;\n            a[i]=temp;\n        count++;\n        }\n        count++;\n    }\n    count++;\n    temp =a[r];\n    count++;\n    a[r]=a[i+1];                       \n    count++;\n    a[i+1]=temp;\n    count++;\n    return i+1;\n    }\n\nvoid quick_sort(int a[50],int p,int r)\n{   \n    int q;\n    count++;\n    if(p<r)\n    {\n        count++;\n        q=partition(a,p,r);\n        count++;\n        quick_sort(a,p,q-1);\n        count++;\n        quick_sort(a,q+1,r);\n        count++;\n    }\n}\n"}
{"target":"apoorvasrivastava98","func":"#include <stdio.h>\nint count=0;\nvoid selectionsort(int[],int);\nvoid main()\n{\n     void getdata(int[50],int);  \n     void putdata(int[50],int);  \n     int i,a[50],n;  \n     printf(\"Enter the value of n\\n\");    \n     scanf(\"%d\",&n);  \n     getdata(a,n);    \n     printf(\"Before sorting \\n\");    \n     putdata(a,n);\n     selectionsort(a,n);     \n     printf(\"After sorting \\n\");    \n     putdata(a,n);     \n     printf(\"value of count=%d \\n\",count);\n}\n    void getdata(int x[50],int n)\n\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } }\n     void putdata(int x[50], int n)\n\n         {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n           }\n          printf(\"\\n\");\n          }\nvoid selectionsort(int numbers[],int array_size)\n{\n    int i,j,T,min;\n    count++;\n    for(i=0;i<array_size;i++)\n    {\n        count++;\n        min=i;\n        count++;\n        for(j=i+1;j<array_size;j++)\n        {\n            count++;\n            if(numbers[j]<numbers[min])\n            {\n                count++;\n                min=j;\n                count++;\n            }\n        }\n        count++;\n        if(i!=min)\n        {\n        count++;\n        T=numbers[min];\n        count++;\n        numbers[min]=numbers[i];\n        count++;\n        numbers[i]=T;\n        count++;\n        }\n    }\n}\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nvoid main()\n{\n  int a[2][2], b[2][2], c[2][2], i, j, p1, p2, p3, p4 , p5, p6, p7,az,bz,cz,d,e,f,g,h;\n  printf(\"Enter elements of first matrix: \");\n  for(i = 0;i < 2; i++)\n  {\n      for(j = 0;j < 2; j++)\n      {\n           scanf(\"%d\", &a[i][j]);\n      }\n  }\n  printf(\"Enter elements of second matrix: \");\n  for(i = 0; i < 2; i++)\n  {\n      for(j = 0;j < 2; j++)\n      {\n           scanf(\"%d\", &b[i][j]);\n           \n      }\n  }\n\n  az=a[0][0];\n  bz=a[0][1];\n  cz=a[1][0];\n  d=a[1][1];\n  e=b[0][0];\n  f=b[0][1];\n  g=b[1][0];\n  h=b[1][1];\n  p1=az*(f-h);\n  p2=(az+bz)*h;\n  p3=(cz+d)*e;\n  p4=d*(g-e);\n  p5=(az+d)*(e+h);\n  p6=(bz-d)*(g+h);\n  p7=(az-cz)*(e+f);\n  \n  c[0][0] = p5+p4-p2+p6;\n  c[0][1] = p1+p2;\n  c[1][0] = p3+p4;\n  c[1][1] = p1+p5-p3-p7;\n \n   printf(\"\\nAfter multiplication\\n\");\n   for(i = 0; i < 2 ; i++){\n      printf(\"\\n\");\n      for(j = 0;j < 2; j++)\n           printf(\"%d\\t\", c[i][j]);\n   }\n \n}\n"}
{"target":"apoorvasrivastava98","func":"#include<stdio.h>\nlong int static count=0;\nvoid TOH(int n,char A,char B,char C)\n{\nif(n==1)\n{\ncount++;\nprintf(\"\\nMove %c to %c\",A,B);\ncount++;\n}\nelse\n{\nTOH(n-1,A,C,B);\ncount++;\nprintf(\"\\nMove %c to %c\",A,B);\ncount++;\nTOH(n-1,C,B,A);\ncount++;\n}\n}\nint main()\n{\nint n = 0;\nchar A='A',B='B',C='C';\nprintf(\"Enter the number of disc:\");\nscanf(\"%d\",&n);\nTOH(n,A,B,C);\nprintf(\"\\n\\nCount=%ld\",count);\nprintf(\"\\n\");\nreturn 0;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nvoid count();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}\n\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nvoid count();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=5)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid delete_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from any position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from any position\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}\nvoid delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos-1)\n    {\n        temp=temp->next;\n        i++;\n    }\n    nextnode=temp->next;\n    temp->next=nextnode->next;\n    free(nextnode);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nvoid count();\nvoid delete_at_pos();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.delete the element from any position from the linked list\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from any position from the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}\nvoid delete_at_pos()\n{\n    struct node *temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    if(temp->next==0)\n    {\n        temp->pre->next=0;\n        free(temp);\n    }\n    else\n    {\n        temp->next->pre=temp->pre;\n        temp->pre->next=temp->next;\n        free(temp);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid delete_beg();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}\nvoid delete_beg()\n{\n    struct node *temp,*firstnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    firstnode=head;\n    head=head->next;\n    temp->next=firstnode->next;\n    free(firstnode);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid delete_beg();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at the beginning position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at the beginning position in the linked list\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}\nvoid delete_beg()\n{\n    struct node *temp,*firstnode;\n    firstnode=head;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->next->pre=head->pre;\n    temp->next=firstnode->next;\n    head=firstnode->next;\n    free(firstnode);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nvoid count();\nvoid delete_beg();\nstruct node\n    {\n        int data;\n        struct node *next;\n        struct node *pre;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element from the beginning position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"delete the element from the beginning position \\n\");\n    delete_beg();\n    break;\n    case 5:printf(\"exit\\n\");\n    exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*tail;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n            newnode->pre=0;\n       if(head==0)\n       {\n            head=tail=newnode;\n       }\n       else\n       {\n            tail->next=newnode;\n            newnode->pre=tail;\n            tail=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}\nvoid delete_beg()\n{\n    struct node *temp;\n    temp=head;\n    head=head->next;\n    head->pre=0;\n    free(temp);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nvoid count();\nvoid delete_at_beg();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display\\n\");\n            display();\n            break;\n            case 3:printf(\"count the element in linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning\\n\");\n            delete_at_beg();\n            break;\n            case 5:exit(0);\n            break;\n            default: printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",& choice);\n        }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}\nvoid delete_at_beg()\n{\n    struct node *temp;\n    temp=head;\n    head=head->next;\n    free(temp);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid delete_end();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the last position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the last position\\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}\nvoid delete_end()\n{\n    struct node *temp,*endnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        endnode=temp;\n        temp=temp->next;\n    }\n    endnode->next=head;\n    free(temp);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid delete_end();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at the last position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at the last position in the linked list\\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}\nvoid delete_end()\n{\n    struct node *temp,*endnode;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    endnode=temp;\n    temp->pre->next=head;\n    head->pre=endnode->pre;\n    free(endnode);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid creat();\nvoid display();\nvoid count();\nvoid delete_end();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.delete the element from the last position \\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the last position \\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}\nvoid delete_end()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=0)\n        {\n            temp=temp->next;\n        }\n        temp->pre->next=0;\n        free(temp);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nvoid count();\nvoid delete_at_end();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the end  positon\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"delete the element from the end\\n\");\n    delete_at_end();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}\nvoid delete_at_end()\n{\n    struct node *temp,*prenode;\n    temp=head;\n    while(temp->next!=0)\n    {\n        prenode=temp;\n        temp=temp->next;\n    }\n    if(temp==head)\n    {\n        head=0;\n        free(temp);\n    }\n    else\n    {\n        prenode->next=0;\n        free(temp);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid delete_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at any position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at any position in the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}\nvoid delete_at_pos()\n{\n    struct node *temp;\n    temp=head;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    temp->pre->next=temp->next;\n    temp->next->pre=temp->pre;\n    free(temp);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation\\n\");\n    creat();\n    printf(\"2.display the linked list\\n\");\n    display();\n}\nvoid creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n}\n\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    printf(\"implementation\\n\");\n    create();\n    printf(\"display the linked list \\n\");\n    display();\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    create();\n    printf(\"2.display the linked list\\n\");\n    display();\n\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid insert_beg();\nvoid insert_end();\nvoid insert_at_pos();\nvoid delete_beg();\nvoid delete_end();\nvoid delete_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int  choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position in the linked list\\n\");\n    printf(\"5.insert the element at the last position in the linked list\\n\");\n    printf(\"6.insert the element at any position in the linked list\\n\");\n    printf(\"7.delete the element from the beginning position of linked list\\n\");\n    printf(\"8.delete the element from the last position of linked list\\n\");\n    printf(\"9.delete the element from any position of linked list\\n\");\n    printf(\"10.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=11)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the beginning position in the linked list\\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"insert the element at the last position in the linked list\\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position in the linked list\\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from the beginning position of linked list\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from the last position of linked list\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position of linked list\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}\nvoid insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->pre=newnode;\n    temp->next=newnode;\n    newnode->next=head;\n    newnode->pre=temp;\n    head=newnode;\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n    newnode->next=head;\n    head->pre=newnode;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}\nvoid delete_beg()\n{\n    struct node *temp,*firstnode;\n    firstnode=head;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->next->pre=head->pre;\n    temp->next=firstnode->next;\n    head=firstnode->next;\n    free(firstnode);\n}\nvoid delete_end()\n{\n    struct node *temp,*endnode;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    endnode=temp;\n    temp->pre->next=head;\n    head->pre=endnode->pre;\n    free(endnode);\n}\nvoid delete_at_pos()\n{\n    struct node *temp;\n    temp=head;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    temp->pre->next=temp->next;\n    temp->next->pre=temp->pre;\n    free(temp);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid insert_beg();\nvoid insert_end();\nvoid insert_at_pos();\nvoid delete_beg();\nvoid delete_end();\nvoid delete_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position \\n\");\n    printf(\"5.insert the element at the last position \\n\");\n    printf(\"6.insert the element at any position \\n\");\n    printf(\"7.delete the element from the beginning position\\n\");\n    printf(\"8.delete the element from the last position\\n\");\n    printf(\"9.delete the element from any position\\n\");\n    printf(\"10.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=11)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position \\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"insert the element at the last position \\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position \\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from the last position\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}\nvoid insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        temp->next=newnode;\n        newnode->next=head;\n        head=newnode;\n    }\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"Invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}\nvoid delete_beg()\n{\n    struct node *temp,*firstnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    firstnode=head;\n    head=head->next;\n    temp->next=firstnode->next;\n    free(firstnode);\n}\nvoid delete_end()\n{\n    struct node *temp,*endnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        endnode=temp;\n        temp=temp->next;\n    }\n    endnode->next=head;\n    free(temp);\n}\nvoid delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos-1)\n    {\n        temp=temp->next;\n        i++;\n    }\n    nextnode=temp->next;\n    temp->next=nextnode->next;\n    free(nextnode);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nint count();\nvoid insert_beg();\nvoid insert_end();\nvoid insert_at_pos();\nvoid delete_beg();\nvoid delete_end();\nvoid delete_at_pos();\nvoid reverse();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position of linked list\\n\");\n    printf(\"5.insert the element at the last position of linked list\\n\");\n    printf(\"6.insert the element at any position of linked list\\n\");\n    printf(\"7.delete the element from beginning position from the linked list\\n\");\n    printf(\"8.delete the element from last position from the linked list\\n\");\n    printf(\"9.delete the element from any position from the linked list\\n\");\n    printf(\"10.revers the linked list\\n\");\n    printf(\"11.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=12)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position of linked list\\n\");\n            insert_beg();\n            break;\n            case 5: printf(\"insert the element at the last position of linked list\\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position of linked list\\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from beginning position from the linked list\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from last position from the linked list\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position from the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"revers the linked list\\n\");\n            reverse();\n            break;\n            case 11:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}\nvoid insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->pre=0;\n    newnode->next=head;\n    head=newnode;\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1,pos;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n}\nvoid delete_beg()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        head->next->pre=0;\n        head=head->next;\n        free(temp);\n    }\n}\nvoid delete_end()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=0)\n        {\n            temp=temp->next;\n        }\n        temp->pre->next=0;\n        free(temp);\n    }\n}\nvoid delete_at_pos()\n{\n    struct node *temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    if(temp->next==0)\n    {\n        temp->pre->next=0;\n        free(temp);\n    }\n    else\n    {\n        temp->next->pre=temp->pre;\n        temp->pre->next=temp->next;\n        free(temp);\n    }\n}\nvoid reverse()\n{\n    struct node *currentnode,*nextnode,*prenode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        currentnode->pre=nextnode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nint count();\nvoid insert_beg();\nvoid insert_end();\nvoid insert_at_pos();\nvoid delete_beg();\nvoid delete_end();\nvoid delete_at_pos();\nvoid reverse();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.insert the element at the beginning position of linked list\\n\");\n    printf(\"5.insert the element at the last position of linked list\\n\");\n    printf(\"6.insert the element at any position of linked list\\n\");\n    printf(\"7.delete the element at the beginning position of linked list\\n\");\n    printf(\"8.delete the element at the last position of linked list \\n\");\n    printf(\"9.delete the element at any position of linked list\\n\");\n    printf(\"10.reverse the linked list\\n\");\n    printf(\"11.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=12)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"insert the element at the beginning position of linked list\\n\");\n    insert_beg();\n    break;\n    case 5:printf(\"insert the element at the last position of linked list\\n\");\n    insert_end();\n    break;\n    case 6:printf(\"insert the element at any position of linked list\\n\");\n    insert_at_pos();\n    break;\n    case 7:printf(\"delete the element at the beginning position of linked list\\n\");\n    delete_beg();\n    break;\n    case 8:printf(\"delete the element at the last position of linked list\\n\");\n    delete_end();\n    break;\n    case 9:printf(\"delete the element at any position of linked list\\n\");\n    delete_at_pos();\n    break;\n    case 10:printf(\"reverse the linked list\\n\");\n    reverse();\n    break;\n    case 11:printf(\"exit\\n\");\n    exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n    return count;\n}\nvoid insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=head;\n    head=newnode;\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    printf(\"enter the position to insert the element =\");\n    scanf(\"%d\",&pos);\n    int i=1;\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalid position\\n\");\n    }\n    else\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}\nvoid delete_beg()\n{\n    struct node *temp;\n    temp=head;\n    head=head->next;\n    free(temp);\n}\nvoid delete_end()\n{\n    struct node *temp,*nextnode;\n    temp=head;\n    while(temp->next!=0)\n    {\n        nextnode=temp;\n        temp=temp->next;\n    }\n    if(temp==head)\n    {\n        head=0;\n        free(temp);\n    }\n    else\n    {\n        nextnode->next=0;\n        free(temp);\n    }\n}\nvoid delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int pos;\n    printf(\"enter the position to delete the element =\");\n    scanf(\"%d\",&pos);\n    int i=1;\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        nextnode=temp->next;\n        temp->next=nextnode->next;\n        free(nextnode);\n    }\n}\nvoid reverse()\n{\n    struct node *nextnode,*prenode,*currentnode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\nvoid elemsw(int *x,int *y)\n{\n    int temp;\n    temp=*x;\n    *x=*y;\n    *y=temp;\n}\nvoid sort(int a[],int n,int i)\n{\n    int large,l,r;\n    large=i;\n    l=2*i+1;\n    r=2*i+2;\n    while(l<n && a[l]>a[large])\n    {\n        large=l;\n    }\n    while(r<n && a[r]>a[large])\n    {\n        large=r;\n    }\n    if(large!=i)\n    {\n        elemsw(&a[large],&a[i]);\n        sort(a,n,large);\n    }\n}\nvoid heapsort(int a[],int n)\n{\n    int i;\n    for(i=(n\/2)-1;i>=0;i--)\n    {\n        sort(a,n,i);\n    }\n    for(i=n-1;i>=0;i--)\n    {\n        elemsw(&a[0],&a[i]);\n        sort(a,i,0);\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}\nint main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"heap sort \\n\");\n    int a[]={15,12,9,54,60,45};\n    int n=sizeof(a)\/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    heapsort(a,n);\n    printarray(a,n);\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    create();\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    create();\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"implementation\\n\");\n    creat();\n}\nvoid creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\n    int main()\n{\n    printf(\"Linked list functions\\n\");\n    printf(\"implementation\\n\");\n    create();\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n       scanf(\"%d\",& choice);\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    printf(\"insertion \\n\"); \n    printf(\"insert an element in the array \\n\");\n    int a[100]={0};\n    int n=10;\n    int i;\n    printf(\"the elements in the array are : \\n\");\n    for(i=0;i<n;i++)\n    {\n        a[i]=i+4;\n        printf(\"%d\\t\",a[i]);\n    }\n    int b=25,pos=3;\n    printf(\"\\n the element is going to insert is : %d \\n\",b);\n    printf(\" the element is going to insert at position is : %d \\n\",pos);\n    n++;\n    for(i=n-1;i>=pos;i--)\n    {\n        a[i]=a[i-1];\n    }\n    a[pos-1]=b;\n    printf(\"\\n after the insertion the elements in the array are \\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid insertion(int a[],int n)\n{\n    int i,j,temp;\n    for(i=1;i<n;i++)\n    {\n        temp=a[i];\n        j=i-1;\n        while(j>=0 && a[j]>temp)\n        {\n            a[j+1]=a[j];\n            j--;\n        }\n        a[j+1]=temp;\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}\nint main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"insertion sort \\n \");\n    int a[5]={90,64,11,24,5};\n    int n=5;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    insertion(a,n);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nint count();\nvoid insert_at_after_pos();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element after the position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element after the  position\\n\");\n            insert_at_after_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}\nvoid insert_at_after_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid insert_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at any position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at any position \\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nint  count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nint count();\nvoid insert_at_pos();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element at any position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element at any position\\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n\n}\n"}
{"target":"ashlyn2002","func":"\n#include<stdio.h>\n#include<stdlib.h>\nvoid create();\nvoid display();\nint count();\nvoid insert_pos();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.inserst the element at any position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"inserting the element at any position \\n\");\n    insert_pos();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n    return count;\n}\nvoid insert_pos()\n{\n    struct node *newnode,*temp;\n    int pos,i=1;\n    printf(\"enter the positon =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid positon \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data = \");\n        scanf(\"%d\",& newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}\n\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid insert_beg();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position \\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}\nvoid insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        temp->next=newnode;\n        newnode->next=head;\n        head=newnode;\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid insert_beg();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the beginning position in the linked list\\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}\nvoid insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->pre=newnode;\n    temp->next=newnode;\n    newnode->next=head;\n    newnode->pre=temp;\n    head=newnode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid create();\nvoid display();\nvoid count();\nvoid insert_beg();\nstruct node\n    {\n        int data;\n        struct node *next;\n    };\n    struct node *head=0;\nint main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.inserst at the begining \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"inserting the element at the begining \\n\");\n    insert_beg();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}\nvoid insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=head;\n    head=newnode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid insert_end();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the last position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the last position in the linked list\\n\");\n            insert_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n    newnode->next=head;\n    head->pre=newnode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nvoid count();\nvoid insert_end();\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the last position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the last position \\n\");\n            insert_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}\nvoid insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nvoid count();\nvoid insert_at_last();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element at the last position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element at the last\\n\");\n            insert_at_last();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}\nvoid insert_at_last()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid create();\nvoid display();\nint count();\nvoid insert_at_pos();\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at any position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at any position in the linked list\\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n\n}\nvoid display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}\nint count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}\nvoid insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid linear(int a[],int n,int data)\n{\n    int i,result=0;\n    for(i=0;i<n;i++)\n    {\n        if(a[i]==data)\n        {\n            result=1;\n            break;\n        }\n    }\n    if(result==0)\n    {\n        printf(\"the element is not found in the array \\n\");\n    }\n    else\n    {\n        printf(\"the element is  found in the array at index %d \\n\",i);\n        printf(\"the element is  found in the array at position  %d \\n\",i+1);\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",a[i]);\n}\nint main(void) {\n    printf(\"linear search \\n\");\n    printf(\"searching for an  element in the array \\n\"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5;\n    printarray(a,n);\n    int data=36;\n    printf(\"\\n the searching element in the array is %d \\n\",data);\n    linear(a,n,data);\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid merge(int a[],int lb,int mid,int ub)\n{\n    int i,j,k,b[10];\n    i=lb;\n    j=mid+1;\n    k=lb;\n    while(i<=mid && j<=ub)\n    {\n        if(a[i]<a[j])\n        {\n            b[k]=a[i];\n            i++;\n            k++;\n        }\n        else\n        {\n            b[k]=a[j];\n            j++;\n            k++;\n        }\n    }\n    if(i>mid)\n    {\n        while(j<=ub)\n        {\n            b[k]=a[j];\n            j++;\n            k++;\n        }\n    }\n    else\n    {\n        while(i<=mid)\n        {\n            b[k]=a[i];\n            i++;\n            k++;\n        }\n    }\n    for(k=lb;k<=ub;k++)\n    {\n        a[k]=b[k];\n    }\n}\nvoid mergesort(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)\/2;\n        mergesort(a,l,mid);\n        mergesort(a,mid+1,r);\n        merge(a,l,mid,r);\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}\nint main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"merge sort \\n\");\n    int a[10]={45,78,96,12,63,80,69,71,85,11};\n    int n=10;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    mergesort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#define n 5\nint queue[n];\nint front=-1;\nint rear=-1;\nvoid enqueue(int x)\n{\n    if(rear==n-1)\n    {\n        printf(\"overflow\\n\");\n    }\n    else if(front==-1 && rear==-1)\n    {\n        front=rear=0;\n        printf(\"the inserted element is %d\\n\",x);\n        queue[rear]=x;\n    }\n    else\n    {\n        rear++;\n        printf(\"the inserted element is %d\\n\",x);\n        queue[rear]=x;\n    }\n}\nvoid dequeue()\n{\n    if(front==-1 && rear==-1)\n    {\n        printf(\"underflow\\n\");\n    }\n    else if(front==rear)\n    {\n        printf(\"the delete element is %d\\n\",queue[front]);\n        front=rear=-1;\n    }\n    else\n    {\n        printf(\"the delete element is %d\\n\",queue[front]);\n        front++;\n    }\n}\nvoid peek()\n{\n    if(front==-1 && rear==-1)\n    {\n        printf(\"queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the peek element is %d\\n\",queue[front]);\n    }\n}\nvoid display()\n{\n    int i;\n    if(front==-1 && rear==-1)\n    {\n        printf(\"queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the elements in the queue are\\n\");\n        for(i=front;i<=rear;i++)\n        {\n            printf(\"%d \",queue[i]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    printf(\"the queue using array\\n\");\n    enqueue(4);\n    enqueue(10);\n    enqueue(41);\n    display();\n    dequeue();\n    peek();\n    enqueue(25);\n    dequeue();\n    peek();\n    display();\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *front=0;\nstruct node *rear=0;\nvoid enqueue(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=0;\n    printf(\"the data inserted is %d\\n\",x);\n    if(front==0 && rear==0)\n    {\n        front=rear=newnode;\n    }\n    else\n    {\n       rear->next=newnode;\n       rear=newnode;\n    }\n}\nvoid peek()\n{\n    if(front==0 && rear==0)\n    {\n        printf(\"the queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the peek element is %d \\n\",front->data);\n    }\n}\nvoid dequeue()\n{\n    struct node *temp;\n    temp=front;\n    if(front==0 && rear==0)\n    {\n        printf(\"the queue is empty\\n\");\n    }\n    else if(front==rear)\n    {\n        printf(\"the delete element is %d \\n\",temp->data);\n        front=rear=0;\n        free(temp);\n    }\n    else\n    {\n        printf(\"the delete element is %d \\n\",temp->data);\n        front=front->next;\n        free(temp);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=front;\n    if(front==0 && rear==0)\n    {\n        printf(\"the queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the element in the array are\\n\");\n       while(temp!=0)\n       {\n           printf(\"%d \",temp->data);\n           temp=temp->next;\n       }printf(\"\\n\");\n    }\n}\nint main()\n{\n    printf(\"queue using the linked list\\n\");\n    enqueue(17);\n    enqueue(34);\n    enqueue(55);\n    dequeue();\n    enqueue(20);\n    display();\n    peek();\n    dequeue();\n    enqueue(45);\n    peek();\n    display();\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid elemswap(int *x,int *y)\n{\n    int temp;\n    temp=*x;\n    *x=*y;\n    *y=temp;\n}\nint sort(int a[],int l,int r)\n{\n    int key,start,end;\n    key=a[l];\n    start=l;\n    end=r;\n    if(start<end)\n    {\n        if(a[start]<=key)\n        {\n            start++;\n        }\n        if(a[end]>key)\n        {\n            end--;\n        }\n        if(start<end)\n        {\n            elemswap(&a[start],&a[end]);\n        }\n    }\n    elemswap(&a[end],&a[l]);\n    return end;\n}\nvoid quicksort(int a[],int l,int r)\n{\n    int loc;\n    if(l<r)\n    {\n        loc=sort(a,l,r);\n        quicksort(a,l,loc);\n        quicksort(a,loc+1,r);\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}\nint main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"quick sort \\n\");\n    int a[]={70,89,2,14,56,33,90};\n    int n=sizeof(a)\/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    quicksort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid creat();\nvoid display();\nvoid count();\nvoid reverse();\nstruct node\n{\nint data;\nstruct node *next;\nstruct node *pre;\n};\nstruct node *head=0;\nint main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.revers the linked list\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"revers the linked list\\n\");\n            reverse();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}\nvoid display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}\nvoid count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}\nvoid reverse()\n{\n    struct node *currentnode,*nextnode,*prenode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        currentnode->pre=nextnode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid selection(int a[],int n)\n{\n    int p,j,min,temp;\n    for(p=0;p<n-1;p++)\n    {\n        min=p;\n        for(j=p+1;j<n;j++)\n        {\n            if(a[j]<a[min])\n            {\n                min=j;\n            }\n        }\n        if(min!=p)\n        {\n            temp=a[p];\n            a[p]=a[min];\n            a[min]=temp;\n        }\n    }\n}\nvoid printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}\nint main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"selection sort \\n \");\n    int a[5]={65,47,4,80,12};\n    int n=5;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    selection(a,n);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid printarray(int a[],int n)\n{\n    for(n=0;n<5;n++)\n        printf(\"%d \\t\",a[n]);\n}\nint main(void) {\n    printf(\"printing the array in the descending odder \\n \"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5,temp;\n    printarray(a,n);\n    printf(\"\\n array in the descending odder is \\n \");\n    int i,j;\n    for(i=0;i<5;i++)\n    {\n        for(j=i+1;j<5;j++)\n        {\n            if(a[j]>a[i])\n            {\n                temp=a[i];\n                a[i]=a[j];\n                a[j]=temp;\n            }\n        }\n    }\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nint stack[50],N;\nint top=-1;\nvoid push();\nvoid pop();\nvoid peek();\nvoid display();\nvoid isfull();\nvoid isempty();\nint main()\n{\n    printf(\"THE STACK USING THE ARRAY\\n\");\n    printf(\"enter the size of the array(max size of the array is 50)= \\n\");\n    scanf(\"%d\",&N);\n    printf(\"1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n\");\n    int choice;\n    do\n    {\n        printf(\"enter the choice= \");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:printf(\"insert the element to the stack\\n\");\n            push();\n            break;\n            case 2:printf(\"delete the element from the stack\\n\");\n            pop();\n            break;\n            case 3:printf(\"display the top element in the stack\\n\");\n            peek();\n            break;\n            case 4:printf(\"display all the element in the stack\\n\");\n            display();\n            break;\n            case 5:printf(\"checking the stack is full or not\\n\");\n            isfull();\n            break;\n            case 6:printf(\"checking the stack is empty or not\\n\");\n            isempty();\n            break;\n            case 7:printf(\"exit \\n\");\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n    }while(choice!=7);\n    return 0;\n}\nvoid push()\n{\n    int x;\n    printf(\"enter the data =\");\n    scanf(\"%d\",&x);\n    if(top==N-1)\n    {\n        printf(\"stack overflow\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top]=x;\n    }\n}\nvoid pop()\n{\n    if(top==-1)\n    {\n        printf(\"stack under flow\\n\");\n    }\n    else\n    {\n        top--;\n    }\n}\nvoid peek()\n{\n    if(top==-1)\n    {\n        printf(\"there is no element in the stack\\n\");\n    }\n    else\n    {\n        printf(\"the top most element in the stack is %d\\n\",stack[top]);\n    }\n}\nvoid display()\n{\n    int i;\n    if(top>-1)\n    {\n        for(i=top;i>=0;i--)\n        {\n            printf(\"%d\\t\",stack[i]);\n        }\n        printf(\"\\n\");\n    }\n    else\n    {\n        printf(\"the stack is empty\\n\");\n    }\n}\nvoid isfull()\n{\n    if(top==N-1)\n    {\n        printf(\"the stack is full\\n\");\n    }\n    else\n    {\n        printf(\"the stack is not full\\n\");\n    }\n}\nvoid isempty()\n{\n    if(top==-1)\n    {\n        printf(\"the stack is empty\\n\");\n    }\n    else\n    {\n        printf(\"the stack is not empty\\n\");\n    }\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nstruct node\n{\n    int data;\n    struct node *next;\n};\nstruct node *top=0;\nvoid push(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=top;\n    top=newnode;\n    printf(\"the element pushed into the stack is %d\\n\",x);\n}\nvoid display()\n{\n    struct node *temp;\n    temp=top;\n    if(top==0)\n    {\n        printf(\"the stack is empty\\n\");\n    }\n    else\n    {\n        printf(\"the elements in the stack are\\n\");\n        while(temp!=0)\n        {\n            printf(\"%d \",temp->data);\n            temp=temp->next;\n        }\n        printf(\"\\n\");\n    }\n}\nvoid peek()\n{\n    if(top==0)\n    {\n        printf(\"the stack is empty\\n\");\n    }\n    else\n    {\n        printf(\"the peek element is %d\\n\",top->data);\n    }\n}\nvoid pop()\n{\n    struct node *temp;\n    if(top==0)\n    {\n        printf(\"the stack is under flow\\n\");\n    }\n    else\n    {\n        temp=top;\n        printf(\"the poped element is %d\\n\",top->data);\n        top=top->next;\n        free(temp);\n    }\n}\nint main()\n{\n    printf(\"the stack using linked list\\n\");\n    push(2);\n    push(3);\n    push(10);\n    display();\n    peek();\n    pop();\n    peek();\n    display();\n}\n"}
{"target":"ashlyn2002","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    printf(\"swapping the elements in the array to another array \\n\"); \n    int n=5,i;\n    printf(\"elements in the array  1 are \\n\");\n    int a[5]={15,24,36,14,22};\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",a[i]);\n    printf(\"\\n\");\n    int temp[5];\n    for(i=0;i<n;i++)\n    {\n        temp[i]=a[i];\n    }\n    printf(\"\\n elements in the array  2 are \\n\");\n    int b[5]={20,16,95,38,45};\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",b[i]);\n    printf(\"\\n after swapping the array \\n\");\n    printf(\"\\n elements in the array  1 are \\n\");\n    for(i=0;i<n;i++)\n    {\n        a[i]=b[i];\n        printf(\"%d \\t\",a[i]);\n    }\n    printf(\"\\n elements in the array  2 are \\n\");\n    for(i=0;i<n;i++)\n    {\n        b[i]=temp[i];\n        printf(\"%d \\t\",b[i]);\n    }\n    return EXIT_SUCCESS;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"compiler-util.h\"\n\nLINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}\n\nLINE* pushvarraw(SCOPE* s, VAR* v) {\n    return opvarraw(s, \"push\", v);\n}\n\nLINE* pushvar(SCOPE* s, DEBUGINFO* d, const char* name) {\n    return opvarraw(s, \"push\", getvarmustexist(s, d, name));\n}\n\nLINE* popvar(SCOPE* s, DEBUGINFO* d, const char* name) {\n    return opvarraw(s, \"pop\", getvarmustexist(s, d, name));\n}\n\nLINE* poptemp() {\n    char* poptemp[] = { \"pop\", \"temp\", \"0\" };\n    return mksimpleln(poptemp, strcount(poptemp));\n}\n\nLINE* popthatadd() {\n    char* popthatadd[] = { \"pop\", \"pointer\", \"1\" };\n    return mksimpleln(popthatadd, strcount(popthatadd));\n}\n\nLINE* onetoken(char* str) {\n    LINE* ln = mkline(1);\n    addtoken(ln, ezheapstr(str));\n    ln->next = NULL;\n    return ln;\n}\n\nLINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}\n"}
{"target":"augustogunsch","func":"#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys\/types.h>\n#include <dirent.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"util.h\"\n#include \"io.h\"\n\n#include <limits.h>\n#ifndef PATH_MAX\n#ifdef __linux__\n#include <linux\/limits.h>\n#else\n#define PATH_MAX 512\n#endif\n#endif\n\nchar* strtail(char* str, int len, int count) {\n    int index = len - count;\n    if (index <= 0) return str;\n    return str + (sizeof(char) * (index));\n}\n\nchar* strhead(char* str, int count) {\n    return str + (sizeof(char) * count);\n}\n\nchar* trimstr(char* str, int len, int end) {\n    int count = len - end;\n    char oldchar = str[count];\n    str[count] = '\\0';\n    char* newstr = (char*)malloc(sizeof(char) * (1 + count));\n    strcpy(newstr, str);\n    str[count] = oldchar;\n    return newstr;\n}\n\nchar* getname(char* f, int len) {\n    int startind = 0;\n    int endind = len - 1;\n    bool readsmt = false;\n \n    for(int i = endind; i >= 0; i--) {\n        if(f[i] == '\/') {\n            if(!readsmt) {\n                endind = i-1;\n                f[i] = '\\0';\n                continue;\n            }\n            startind = i+1;\n            break;\n        }\n        readsmt = true;\n    }\n\n    int sz = sizeof(char)*(endind - startind + 2);\n    char* startstr = strhead(f, startind);\n    char* retstr = (char*)malloc(sz);\n    snprintf(retstr, sz, \"%s\", startstr);\n    return retstr;\n}\n\nchar* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {\n    int sz = sizeof(char)*(fnamelen+dirlen+2);\n    char* fullname = (char*)malloc(sz);\n    sprintf(fullname, \"%s\/%s\", dirname, fname);\n    return fullname;\n}\n\nbool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}\n\nbool isdir(char* f, int len) {\n    bool readsmt = false;\n    for(int i = len-1; i >= 0; i--) {\n        if(f[i] == '.') {\n            if(readsmt)\n                return false;\n            else\n                continue;\n        }\n        if(f[i] == '\/')\n            return 1;\n        readsmt = true;\n    }\n    return true;\n}\n\nchar* getoutname(char* fullname, int len) {\n    char* trimmed = trimstr(fullname, len, 4);\n    int sz = sizeof(char) * (len-1);\n    char* outname = (char*)malloc(sz);\n    sprintf(outname, \"%svm\", trimmed);\n    free(trimmed);\n    return outname;\n}\n\nFILELIST* addfile(FILELIST* l, char* fullname, char* name) {\n    FILELIST* new = (FILELIST*)malloc(sizeof(FILELIST));\n    new->name = name;\n    new->fullname = fullname;\n    new->next = l;\n    new->outname = getoutname(fullname, strlen(fullname));\n    return new;\n}\n\nFILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    \n    closedir(d);\n\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}\n\nFILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}\n\nFILELIST* getfiles(char* input) {\n    int inplen = strlen(input);\n    bool isitdir = isdir(input, inplen);\n\n    if(isitdir)\n        return getfilesfromdir(input);\n    else\n        return getsinglefile(input);\n}\n\nvoid freefilelist(FILELIST* fs) {\n    free(fs->name);\n    free(fs->fullname);\n    free(fs->outname);\n    FILELIST* next = fs->next;\n    free(fs);\n    if(next != NULL)\n        freefilelist(next);\n}\n"}
{"target":"augustogunsch","func":"#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"threads.h\"\n#include \"parser.h\"\n#include \"compiler.h\"\n#include \"io.h\"\n#include \"os.h\"\n\nint main(int argc, char* argv[]) {\n    if(argc < 2) {\n        eprintf(\"Usage: %s {input file(s)}\\n\", argv[0]);\n        return 1;\n    }\n\n    FILELIST* files = getfiles(argv[1]);\n    FILELIST* curr = files->next;\n\n    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n\n    head->file = files;\n    head->parser = mkparser(tokenize(files->fullname), files->name);\n\n    COMPILEUNIT* currunit = head;\n    while(curr != NULL) {\n        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n        newunit->file = curr;\n        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);\n        currunit->next = newunit;\n        currunit = newunit;\n        curr = curr->next;\n    }\n    currunit->next = NULL;\n\n    actonunits(head, parseunit);\n\n    CLASS* headclass = head->parsed;\n    CLASS* currclass = headclass;\n    currunit = head->next;\n    while(currunit != NULL) {\n        currclass->next = currunit->parsed;\n        currclass = currunit->parsed;\n        currunit = currunit->next;\n    }\n    currclass->next = NULL;\n    COMPILER* compiler = mkcompiler(headclass);\n\n    currunit = head;\n    while(currunit != NULL) {\n        currunit->compiler = compiler;\n        currunit = currunit->next;\n    }\n\n    actonunits(head, compileunit);\n\n    currunit = head;\n    while(currunit != NULL) {\n        FILE* output = fopen(currunit->file->outname, \"w\");\n        if(output == NULL) {\n            eprintf(\"%s\", strerror(errno));\n            exit(1);\n        }\n\n        if(currunit->compiled == NULL) {\n            eprintf(\"Class '%s' is empty; file '%s'\\n\", currunit->parsed->name, currunit->file->name);\n            exit(1);\n        }\n\n        printlns(currunit->compiled->head, output);\n        fclose(output);\n        COMPILEUNIT* next = currunit->next;\n        freeunit(currunit);\n        currunit = next;\n    }\n\n    freecompiler(compiler);\n    freetree(headclass);\n    freefilelist(files);\n    return 0;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include <string.h>\n#include \"os.h\"\n#include \"util.h\"\n\nCLASS* mkosclass(CLASS* os, const char* name) {\n    CLASS* c = (CLASS*)malloc(sizeof(CLASS));\n    c->name = ezheapstr(name);\n    c->subroutdecs = NULL;\n    c->next = os;\n    return c;\n}\n\nvoid adddec(CLASS* c, SUBROUTCLASS subroutclass, char* type, const char* name) {\n    SUBROUTDEC* dec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    dec->class = c;\n    dec->subroutclass = subroutclass;\n    dec->name = ezheapstr(name);\n    dec->type = ezheapstr(type);\n    dec->next = c->subroutdecs;\n    c->subroutdecs = dec;\n}\n\nCLASS* mkmath(CLASS* os) {\n    CLASS* mathclass = mkosclass(os, \"Math\");\n    adddec(mathclass, function, \"int\", \"multiply\");\n    adddec(mathclass, function, \"int\", \"divide\");\n    adddec(mathclass, function, \"int\", \"abs\");\n    adddec(mathclass, function, \"int\", \"min\");\n    adddec(mathclass, function, \"int\", \"max\");\n    adddec(mathclass, function, \"int\", \"sqrt\");\n    return mathclass;\n}\n\nCLASS* mkstringclass(CLASS* os) {\n    CLASS* strclass = mkosclass(os, \"String\");\n    adddec(strclass, constructor, \"String\", \"new\");\n    adddec(strclass, method, \"int\", \"dispose\");\n    adddec(strclass, method, \"int\", \"length\");\n    adddec(strclass, method, \"char\", \"charAt\");\n    adddec(strclass, method, \"void\", \"setCharAt\");\n    adddec(strclass, method, \"String\", \"appendChar\");\n    adddec(strclass, method, \"void\", \"eraseLastChar\");\n    adddec(strclass, method, \"int\", \"intValue\");\n    adddec(strclass, method, \"void\", \"setInt\");\n    adddec(strclass, function, \"char\", \"backSpace\");\n    adddec(strclass, function, \"char\", \"doubleQuote\");\n    adddec(strclass, function, \"char\", \"newLine\");\n    return strclass;\n}\n\nCLASS* mkarray(CLASS* os) {\n    CLASS* arrclass = mkosclass(os, \"Array\");\n    adddec(arrclass, function, \"Array\", \"new\");\n    adddec(arrclass, method, \"void\", \"dispose\");\n    return arrclass;\n}\n\nCLASS* mkoutput(CLASS* os) {\n    CLASS* outclass = mkosclass(os, \"Output\");\n    adddec(outclass, function, \"void\", \"moveCursor\");\n    adddec(outclass, function, \"void\", \"printChar\");\n    adddec(outclass, function, \"void\", \"printString\");\n    adddec(outclass, function, \"void\", \"printInt\");\n    adddec(outclass, function, \"void\", \"println\");\n    adddec(outclass, function, \"void\", \"backSpace\");\n    return outclass;\n}\n\nCLASS* mkscreen(CLASS* os) {\n    CLASS* scrclass = mkosclass(os, \"Screen\");\n    adddec(scrclass, function, \"void\", \"clearScreen\");\n    adddec(scrclass, function, \"void\", \"setColor\");\n    adddec(scrclass, function, \"void\", \"drawPixel\");\n    adddec(scrclass, function, \"void\", \"drawLine\");\n    adddec(scrclass, function, \"void\", \"drawRectangle\");\n    adddec(scrclass, function, \"void\", \"drawCircle\");\n    return scrclass;\n}\n\nCLASS* mkkeyboard(CLASS* os) {\n    CLASS* kbdclass = mkosclass(os, \"Keyboard\");\n    adddec(kbdclass, function, \"char\", \"keyPressed\");\n    adddec(kbdclass, function, \"char\", \"readChar\");\n    adddec(kbdclass, function, \"String\", \"readLine\");\n    adddec(kbdclass, function, \"int\", \"readInt\");\n    return kbdclass;\n}\n\nCLASS* mkmemory(CLASS* os) {\n    CLASS* memclass = mkosclass(os, \"Memory\");\n    adddec(memclass, function, \"int\", \"peek\");\n    adddec(memclass, function, \"void\", \"poke\");\n    adddec(memclass, function, \"Array\", \"alloc\");\n    adddec(memclass, function, \"void\", \"deAlloc\");\n    return memclass;\n}\n\nCLASS* mksys(CLASS* os) {\n    CLASS* sysclass = mkosclass(os, \"Sys\");\n    adddec(sysclass, function, \"void\", \"halt\");\n    adddec(sysclass, function, \"void\", \"error\");\n    adddec(sysclass, function, \"void\", \"wait\");\n    return sysclass;\n}\n\nCLASS* mkos() {\n    CLASS* os = mkmath(NULL);\n    os = mkstringclass(os);\n    os = mkarray(os);\n    os = mkoutput(os);\n    os = mkscreen(os);\n    os = mkkeyboard(os);\n    os = mkmemory(os);\n    os = mksys(os);\n    return os;\n}\n\nvoid freeossubroutdecs(SUBROUTDEC* d) {\n    free(d->name);\n    free(d->type);\n    SUBROUTDEC* next = d->next;\n    free(d);\n    if(next != NULL)\n        freeossubroutdecs(next);\n}\n\nvoid freeosclasses(CLASS* c) {\n    freeossubroutdecs(c->subroutdecs);\n    free(c->name);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freeosclasses(next);\n}\n\nvoid freeos(CLASS* os) {\n    freeosclasses(os);\n}\n\nSUBROUTDEC* getsubroutdecinclass(CLASS* c, const char* name) {\n    SUBROUTDEC* curr = c->subroutdecs;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    return NULL;\n}\n\nCLASS* getosclass(CLASS* os, const char* name) {\n    CLASS* curr = os;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    return NULL;\n}\n\nSUBROUTDEC* getossubroutdec(CLASS* os, SUBROUTCALL* call) {\n    CLASS* c = getosclass(os, call->parentname);\n    if(c == NULL)\n        return NULL;\n    return getsubroutdecinclass(c, call->name);\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"util.h\"\n#include \"parser-util.h\"\n#include \"parser-expressions.h\"\n\n    const char* keywordsarr[] = { \"true\", \"false\", \"null\", \"this\" };\n    const char* opsarr[] = { \"+\", \"-\", \"*\", \"\/\", \"&\", \"|\", \"<\", \">\", \"=\" };\n    mkstrlist(keywordconstants, keywordsarr);\nmkstrlist(operators, opsarr);\n\n\n\n\nbool isop(TOKEN* t);\n\n\nTERM* parsetermnullified(PARSER* p);\nTERM* parseterm(PARSER* p);\nTERM* mkterm(TERMTYPE type);\nTERM* parseint(PARSER* p);\nTERM* parsestr(PARSER* p);\nTERM* parsekeyword(PARSER* p);\nTERM* parseunaryopterm(PARSER* p);\nTERM* parseinnerexpression(PARSER* p);\nTERM* parsecalltermnullified(PARSER* p);\nTERM* parsearrayterm(PARSER* p);\nTERM* parsevarterm(PARSER* p);\nTERM* parseidentifierterm(PARSER* p);\nSUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c);\nSUBROUTCALL* parsesubroutcallnullified(PARSER* p);\n\n\n\n\nbool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}\n\n\nTERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}\n\nTERM* parseterm(PARSER* p) {\n    TERM* t = parsetermnullified(p);\n    if(t == NULL)\n        unexpected(p);\n    return t;\n}\n\nTERM* mkterm(TERMTYPE type) {\n    TERM* t = (TERM*)malloc(sizeof(TERM));\n    t->type = type;\n    return t;\n}\n\nTERM* parseint(PARSER* p) {\n    TERM* t = mkterm(intconstant);\n    t->integer = atoi(p->current->token);\n    next(p);\n    return t;\n}\n\nTERM* parsestr(PARSER* p) {\n    TERM* t = mkterm(stringconstant);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parsekeyword(PARSER* p) {\n    TERM* t = mkterm(keywordconstant);\n    if(!existsinarray(&keywordconstants, p->current->token))\n        unexpected(p);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parseunaryopterm(PARSER* p) {\n    TERM* t = mkterm(unaryopterm);\n    t->unaryop = p->current->token[0];\n    next(p);\n    t->expression = parseterm(p);\n    t->expression->next = NULL;\n    return t;\n}\n\nTERM* parseinnerexpression(PARSER* p) {\n    TERM* t = mkterm(innerexpression);\n    next(p);\n    t->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    return t;\n}\n\nTERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}\n\nTERM* parsearrayterm(PARSER* p) {\n    TERM* t = mkterm(arrayitem);\n    t->array = (ARRAY*)malloc(sizeof(ARRAY));\n    t->array->name = p->current->token;\n    next(p);\n    checkcontent(p, \"[\");\n    t->array->exp = parseexpression(p);\n    checkcontent(p, \"]\");\n    return t;\n}\n\nTERM* parsevarterm(PARSER* p) {\n    TERM* t = mkterm(varname);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parseidentifierterm(PARSER* p) {\n    TERM* t = parsecalltermnullified(p);\n    if(t == NULL)\n        if(nextequals(p, \"[\"))\n            return parsearrayterm(p);\n        else\n            return parsevarterm(p);\n    else\n        return t;\n}\n\nTERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}\n\nTERM* parseexpression(PARSER* p) {\n    TERM* t = parseexpressionnullified(p);\n    if(t == NULL)\n        unexpected(p);\n    return t;\n}\n\nSUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c) {\n    free(c->debug);\n    free(c);\n    rewindparser(p);\n    return NULL;\n}\n\nSUBROUTCALL* parsesubroutcallnullified(PARSER* p) {\n    if(p->current->type != identifier)\n        return NULL;\n\n    anchorparser(p);\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n\n    c->debug = getdebug(p);\n\n    if(nextequals(p, \".\")) {\n        c->parentname = p->current->token;\n        next(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n\n    if(p->current->type != identifier)\n        return nullsubroutcall(p, c);\n    c->name = p->current->token;\n    next(p);\n\n    if(differs(p, \"(\"))\n        return nullsubroutcall(p, c);\n    next(p);\n\n    c->parameters = parseexpressionlist(p);\n\n    if(differs(p, \")\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    return c;\n}\n\nSUBROUTCALL* parsesubroutcall(PARSER* p) {\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n\n    if(nextequals(p, \".\")) {\n        c->parentname = parseidentifier(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n\n    c->name = parseidentifier(p);\n\n    checkcontent(p, \"(\");\n\n    c->parameters = parseexpressionlist(p);\n\n    checkcontent(p, \")\");\n    return c;\n}\n\nEXPRESSIONLIST* parseexpressionlist(PARSER* p) {\n    if(!strcmp(p->current->token, \")\"))\n        return NULL;\n    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n    head->expression = parseexpressionnullified(p);\n    EXPRESSIONLIST* current = head;\n    EXPRESSIONLIST* nextls;\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n        nextls->expression = parseexpression(p);\n        current->next = nextls;\n        current = nextls;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-expressions.h\"\n#include \"parser-util.h\"\n#include \"parser-statements.h\"\n\n\n\n\nSTATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t);\n\nSTATEMENT* parsestatementnullified(PARSER* p);\nSTATEMENT* parselet(PARSER* p);\nCONDSTATEMENT* parsecond(PARSER* p);\nSTATEMENT* parseif(PARSER* p);\nSTATEMENT* parsewhile(PARSER* p);\nSTATEMENT* parsedo(PARSER* p);\nSTATEMENT* parsereturn(PARSER* p);\n\n\n\n\nSTATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {\n    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));\n    s->type = t;\n    s->debug = getdebug(p);\n    return s;\n}\n\n\n\n\nSTATEMENT* parsestatementnullified(PARSER* p) {\n    if(equals(p, \"let\")) return parselet(p);\n    if(equals(p, \"if\")) return parseif(p);\n    if(equals(p, \"while\")) return parsewhile(p);\n    if(equals(p, \"do\")) return parsedo(p);\n    if(equals(p, \"return\")) return parsereturn(p);\n    return NULL;\n}\n\nSTATEMENT* parsestatements(PARSER* p) {\n    STATEMENT* head = parsestatementnullified(p);\n    STATEMENT* curr = head;\n    STATEMENT* next;\n    while(next = parsestatementnullified(p), next != NULL) {\n        curr->next = next;\n        curr = next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSTATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n\n    letst->varname = parseidentifier(p);\n    \n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n\n    checkcontent(p, \"=\");\n\n    letst->expression = parseexpression(p);\n\n    checkcontent(p, \";\");\n\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}\n\nCONDSTATEMENT* parsecond(PARSER* p) {\n    checkcontent(p, \"(\");\n\n    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));\n\n    st->expression = parseexpression(p);\n\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n\n    st->statements = parsestatements(p);\n\n    checkcontent(p, \"}\");\n    return st;\n}\n\nSTATEMENT* parseif(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, ifstatement);\n    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));\n\n    ifst->base = parsecond(p);\n\n    if(equals(p, \"else\")) {\n        next(p);\n        checkcontent(p, \"{\");\n        ifst->elsestatements = parsestatements(p);\n        checkcontent(p, \"}\");\n    }\n    else\n        ifst->elsestatements = NULL;\n\n    s->type = ifstatement;\n    s->ifstatement = ifst;\n    return s;\n}\n\nSTATEMENT* parsewhile(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, whilestatement);\n\n    s->whilestatement = parsecond(p);\n    return s;\n}\n\nSTATEMENT* parsedo(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, dostatement);\n\n    s->dostatement = parsesubroutcall(p);\n\n    checkcontent(p, \";\");\n    return s;\n}\n\nSTATEMENT* parsereturn(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, returnstatement);\n\n    s->retstatement = parseexpressionnullified(p);\n\n    checkcontent(p, \";\");\n    return s;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-util.h\"\n#include \"parser-structure.h\"\n#include \"parser-statements.h\"\n\nconst char* classvartypesarr[] = { \"static\", \"field\" };\nconst char* vartypesarr[] = { \"int\", \"char\", \"boolean\" };\nconst char* subroutclassesarr[] = { \"constructor\", \"function\", \"method\" };\nmkstrlist(classvartypes, classvartypesarr);\nmkstrlist(vartypes, vartypesarr);\nmkstrlist(subroutclasses, subroutclassesarr);\n\n\n\n\nbool isprimitive(TOKEN* tk);\nchar* parsetype(PARSER* p);\nint parsepossibilities(PARSER* p, STRINGARRAY* poss);\n\n\nCLASS* parseclass(PARSER* p);\nCLASSVARTYPE parseclassvartype(PARSER* p);\nCLASSVARDEC* parseclassvardec(PARSER* p);\nCLASSVARDEC* parseclassvardecs(PARSER* p);\nSUBROUTCLASS parsesubroutclass(PARSER* p);\nSUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c);\nSUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c);\nPARAMETER* parseparameter(PARSER* p);\nPARAMETER* parseparameters(PARSER* p);\nSUBROUTBODY* parsesubroutbody(PARSER* p);\nvoid parsevardeccommon(PARSER* p, VARDEC* v);\nVARDEC* parsevardec(PARSER* p);\nVARDEC* parsevardecs(PARSER* p);\n\n\n\n\n\nbool isprimitive(TOKEN* tk) {\n    if(tk->type == keyword)\n        if(existsinarray(&vartypes, tk->token))\n            return true;\n    return false;\n}\n\nchar* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n\n    char* result = p->current->token;\n    next(p);\n    return result;\n}\n\nint parsepossibilities(PARSER* p, STRINGARRAY* poss) {\n    for(int i = 0; i < poss->size; i++)\n        if(equals(p, poss->items[i]))\n            return i;\n    return -1;\n}\n\n\nCLASS* parseclass(PARSER* p) {\n    checkcontent(p, \"class\");\n\n    CLASS* class = (CLASS*)malloc(sizeof(CLASS));\n\n    class->debug = getdebug(p);\n\n    class->name = parseidentifier(p);\n\n    checkcontent(p, \"{\");\n\n    class->vardecs = parseclassvardecs(p);\n\n    class->subroutdecs = parsesubroutdecs(p, class);\n\n    checkcontent(p, \"}\");\n\n    if(p->current != NULL)\n        unexpected(p);\n\n    return class;\n}\n\nCLASSVARTYPE parseclassvartype(PARSER* p) {\n    return parsepossibilities(p, &classvartypes);\n}\n\nCLASSVARDEC* parseclassvardec(PARSER* p) {\n    CLASSVARTYPE classvartype = parseclassvartype(p);\n    if(classvartype == -1)\n        return NULL;\n    next(p);\n\n    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));\n    classvardec->type = classvartype;\n\n    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));\n\n    parsevardeccommon(p, classvardec->base);\n\n    return classvardec;\n}\n\nCLASSVARDEC* parseclassvardecs(PARSER* p) {\n    CLASSVARDEC* head = parseclassvardec(p);\n    CLASSVARDEC* curr = head;\n    CLASSVARDEC* nextc;\n    while(nextc = parseclassvardec(p), nextc != NULL) {\n        curr->next = nextc;\n        curr = nextc;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSUBROUTCLASS parsesubroutclass(PARSER* p) {\n    return parsepossibilities(p, &subroutclasses);\n}\n\nSUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {\n    SUBROUTCLASS subroutclass = parsesubroutclass(p);\n    if(subroutclass == -1)\n        return NULL;\n\n    next(p);\n    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    subroutdec->subroutclass = subroutclass;\n\n    if(differs(p, \"void\"))\n        subroutdec->type = parsetype(p);\n    else {\n        subroutdec->type = p->current->token;\n        next(p);\n    }\n\n    subroutdec->debug = getdebug(p);\n\n    subroutdec->name = parseidentifier(p);\n\n    checkcontent(p, \"(\");\n    subroutdec->parameters = parseparameters(p);\n    checkcontent(p, \")\");\n\n    checkcontent(p, \"{\");\n    subroutdec->body = parsesubroutbody(p);\n    checkcontent(p, \"}\");\n\n    subroutdec->class = c;\n\n    return subroutdec;\n}\n\nSUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {\n    SUBROUTDEC* head = parsesubroutdec(p, c);\n    SUBROUTDEC* curr = head;\n    SUBROUTDEC* nexts;\n    while(nexts = parsesubroutdec(p, c), nexts != NULL) {\n        curr->next = nexts;\n        curr = nexts;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nPARAMETER* parseparameter(PARSER* p) {\n    if(equals(p, \")\"))\n        return NULL;\n    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));\n    param->debug = getdebug(p);\n    param->primitive = isprimitive(p->current);\n    param->type = parsetype(p);\n    param->name = parseidentifier(p);\n    return param;\n}\n\nPARAMETER* parseparameters(PARSER* p) {\n    PARAMETER* head = parseparameter(p);\n    PARAMETER* curr = head;\n    PARAMETER* nextp;\n    while(equals(p, \",\")) {\n        next(p);\n        nextp = parseparameter(p);\n        if(nextp == NULL)\n            unexpected(p);\n        curr->next = nextp;\n        curr = curr->next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSUBROUTBODY* parsesubroutbody(PARSER* p) {\n    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));\n    subroutbody->vardecs = parsevardecs(p);\n    subroutbody->statements = parsestatements(p);\n\n    return subroutbody;\n}\n\nvoid parsevardeccommon(PARSER* p, VARDEC* v) {\n    v->typeclass = p->current->type;\n    v->primitive = isprimitive(p->current);\n    v->type = parsetype(p);\n\n    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    v->names = currstr;\n\n    v->debug = getdebug(p);\n\n    v->names->content = parseidentifier(p);\n\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        nextstr->content = parseidentifier(p);\n        currstr->next = nextstr;\n        currstr = nextstr;\n    }\n    currstr->next = NULL;\n\n    checkcontent(p, \";\");\n}\n\n\nVARDEC* parsevardec(PARSER* p) {\n    if(strcmp(p->current->token, \"var\"))\n        return NULL;\n    next(p);\n\n    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));\n\n    parsevardeccommon(p, vardec);\n\n    return vardec;\n}\n\nVARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-tree.h\"\n\nvoid freeexpression(TERM* e);\nvoid freeexpressionlist(EXPRESSIONLIST* el);\nvoid freestatements(STATEMENT* s);\n\nvoid freevardec(VARDEC* v) {\n    freestrlist(v->names);\n    free(v->debug);\n    free(v);\n}\n\nvoid freevardecs(VARDEC* v) {\n    VARDEC* next = v->next;\n    freevardec(v);\n    if(next != NULL)\n        freevardecs(next);\n}\n\nvoid freeparameters(PARAMETER* p) {\n    free(p->debug);\n    PARAMETER* next = p->next;\n    free(p);\n    if(next != NULL)\n        freeparameters(next);\n}\n\nvoid freearray(ARRAY* a) {\n    freeexpression(a->exp);\n    free(a);\n}\n\nvoid freesubroutcall(SUBROUTCALL* call) {\n    if(call->parameters != NULL)\n        freeexpressionlist(call->parameters);\n    free(call->debug);\n    free(call);\n}\n\nvoid freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}\n\nvoid freeexpressionlist(EXPRESSIONLIST* el) {\n    freeexpression(el->expression);\n    EXPRESSIONLIST* next = el->next;\n    free(el);\n    if(next != NULL)\n        freeexpressionlist(next);\n}\n\nvoid freelet(LETSTATEMENT* l) {\n    if(l->arrayind != NULL)\n        freeexpression(l->arrayind);\n    freeexpression(l->expression);\n    free(l);\n}\n\nvoid freecond(CONDSTATEMENT* cond) {\n    freeexpression(cond->expression);\n    if(cond->statements != NULL)\n        freestatements(cond->statements);\n    free(cond);\n}\n\nvoid freeif(IFSTATEMENT* st) {\n    freecond(st->base);\n    if(st->elsestatements != NULL)\n        freestatements(st->elsestatements);\n    free(st);\n}\n\nvoid freestatements(STATEMENT* s) {\n    if(s->type == letstatement)\n        freelet(s->letstatement);\n    else if(s->type == ifstatement)\n        freeif(s->ifstatement);\n    else if(s->type == whilestatement)\n        freecond(s->whilestatement);\n    else if(s->type == dostatement)\n        freesubroutcall(s->dostatement);\n    else if(s->retstatement != NULL)\n        freeexpression(s->retstatement);\n\n    free(s->debug);\n    STATEMENT* next = s->next;\n    free(s);\n    if(next != NULL)\n        freestatements(next);\n}\n\nvoid freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}\n\nvoid freesubroutdecs(SUBROUTDEC* sr) {\n    free(sr->debug);\n    if(sr->parameters != NULL)\n        freeparameters(sr->parameters);\n    freesubroutbody(sr->body);\n    SUBROUTDEC* next = sr->next;\n    free(sr);\n    if(next != NULL)\n        freesubroutdecs(next);\n}\n\nvoid freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}\n\nvoid freetree(CLASS* c) {\n    free(c->debug);\n\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}\n"}
{"target":"augustogunsch","func":"#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"threads.h\"\n\nvoid* parseunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n\n    unit->parsed = parse(unit->parser);\n\n    pthread_exit(NULL);\n}\n\nvoid* compileunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n\n    unit->compiled = compileclass(unit->compiler, unit->parsed);\n\n    pthread_exit(NULL);\n}\n\nvoid waitthreads(pthread_t* threads, int amount) {\n    void* status;\n    int code;\n    for(int i = 0; i < amount; i++) {\n        code = pthread_join(threads[i], &status);\n        if(code) {\n            eprintf(\"Error while joining thread %i: %s\\n\", i, strerror(code));\n            exit(code);\n        }\n    }\n}\n\nvoid actonunits(COMPILEUNIT* units, void*(*fun)(void*)) {\n    pthread_t mythreads[_SC_THREAD_THREADS_MAX];\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    COMPILEUNIT* curr = units;\n\n    int i;\n    int code;\n    do {\n        i = 0;\n        while(curr != NULL && i < _SC_THREAD_THREADS_MAX) {\n            code = pthread_create(&mythreads[i], &attr, fun, curr);\n\n            if(code) {\n                eprintf(\"Error while creating thread %i: %s\\n\", i, strerror(code));\n                exit(code);\n            }\n\n            curr = curr->next;\n            i++;\n        }\n        waitthreads(mythreads, i);\n    } while(i == _SC_THREAD_THREADS_MAX);\n\n    pthread_attr_destroy(&attr);\n}\n\nvoid freeunit(COMPILEUNIT* u) {\n    freeparser(u->parser);\n    freelnblk(u->compiled);\n    free(u);\n}\n"}
{"target":"augustogunsch","func":"#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"tokenizer.h\"\n#include \"tokenizer-tables.h\"\n\n\ntypedef enum {\n    common, charsymbol, space\n} CHARTYPE;\n\ntypedef struct {\n    char* str;\n    int size;\n    int count;\n} STRING;\n\n\nSTRING* mkstring(int size);\nvoid append(STRING* s, char c);\nvoid freestr(STRING* str);\n\n\nTOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type);\nTOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat);\n#define mktoken() (TOKEN*)malloc(sizeof(TOKEN))\n\n\nCHARTYPE getchartype(unsigned char c);\nbool iskeyword(STRING* tk);\nbool issymbol(STRING* tk);\nbool isint(char* str);\nbool isintcons(STRING* tk);\nbool isidentifier(STRING* tk);\nTOKENTYPE gettokentype(STRING* tk, char* file, int definedat);\n\n\nvoid skipln(FILE* input);\nvoid skipmultiln(FILE* input, int* lnscount);\nbool handlecomment(FILE* input, int* lnscount);\nvoid readstr(FILE* input, STRING* tmp, int definedat);\n\n\nSTRING* mkstring(int size) {\n    STRING* str = (STRING*)malloc(sizeof(STRING));\n    str->size = sizeof(char) * size; \n    str->str = (char*)malloc(str->size);\n    str->count = 0;\n    return str;\n}\n\nvoid append(STRING* s, char c) {\n    int targsize = sizeof(char) * (s->count + 1);\n    if(s->size <= targsize) {\n        s->size = targsize * 2;\n        s->str = (char*)realloc(s->str, s->size);\n    }\n\n    s->str[s->count] = c;\n    s->count++;\n}\n\nvoid freestr(STRING* str) {\n    free(str->str);\n    free(str);\n}\n\n\nTOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {\n    curitem->token = (char*)malloc(sizeof(char)*token->count);\n    strcpy(curitem->token, token->str);\n    curitem->definedat = definedat;\n    curitem->type = type;\n    TOKEN* nextitem = mktoken();\n    curitem->next = nextitem;\n    token->count = 0;\n    return nextitem;\n}\n\nvoid freetokens(TOKEN* t) {\n    free(t->token);\n    TOKEN* next = t->next;\n    free(t);\n    if(next != NULL)\n        freetokens(next);\n}\n\nTOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {\n    append(token, '\\0');\n    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));\n}\n\n\nCHARTYPE getchartype(unsigned char c) {\n    if(isspace(c)) return space;\n    if(isalnum(c) || c == '_' || c == '\"') return common;\n    return charsymbol;\n}\n\nbool iskeyword(STRING* tk) {\n    return existsinarray(&keywords, tk->str);\n}\n\nbool issymbol(STRING* tk) {\n    if(tk->count != 2)\n        return false;\n    return existsinarray(&symbols, tk->str);\n}\n\nbool isint(char* str) {\n    int i = 0;\n    while(str[i] != '\\0') {\n        if(!isdigit(str[i]))\n            return false;\n        i++;\n    }\n    return true;\n}\n\nbool isintcons(STRING* tk) {\n    if(!isint(tk->str))\n        return false;\n    int val = atoi(tk->str);\n    return val <= 65535;\n}\n\nbool isidentifier(STRING* tk) {\n    if(isdigit(tk->str[0]))\n        return false;\n\n    int count = tk->count - 1;\n    for(int i = 0; i < count; i++)\n        if(!isalnum(tk->str[i]) && tk->str[i] != '_')\n            return false;\n    return true;\n}\n\nTOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {\n    if(iskeyword(tk)) return keyword;\n    if(issymbol(tk)) return symbol;\n    if(isintcons(tk)) return integer;\n    if(isidentifier(tk)) return identifier;\n    eprintf(\"Unexpected token '%s'; file '%s', line %i\\n\", tk->str, file, definedat);\n    exit(1);\n}\n\n\nvoid skipln(FILE* input) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            break;\n}\n\nvoid skipmultiln(FILE* input, int* lnscount) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            (*lnscount)++;\n        else if(c == '*')\n            if(fgetc(input) == '\/')\n                break;\n}\n\nbool handlecomment(FILE* input, int* lnscount) {\n    unsigned char nextc = fgetc(input);\n    if(nextc == '\/') {\n        skipln(input);\n        (*lnscount)++;\n        return true;\n    }\n    else if(nextc == '*') {\n        unsigned char furtherc = fgetc(input);\n        if(furtherc == '*') {\n            skipmultiln(input, lnscount);\n            return true;\n        }\n        ungetc(furtherc, input);\n    }\n    ungetc(nextc, input);\n    return false;\n}\n\nvoid readstr(FILE* input, STRING* tmp, int definedat) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0') {\n        if(c == '\\n') {\n            eprintf(\"Unexpected end of line; line %i\", definedat);\n            exit(1);\n        }\n        if(c == '\"')\n            break;\n        append(tmp, c);\n    }\n    append(tmp, '\\0');\n}\n\nTOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    \n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '\/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n\n        curtype = getchartype(c);\n\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <string.h>\n#include <stdlib.h>\n#include \"util.h\"\n\nchar* heapstr(const char* str, int len) {\n    int size = sizeof(char) * (len + 1);\n    char* outstr = (char*)malloc(size);\n    strcpy(outstr, str);\n    return outstr;\n}\n\nchar* ezheapstr(const char* str) {\n    return heapstr(str, strlen(str));\n}\n\nvoid* copy(void* v, int size) {\n    void* copy = malloc(size);\n    memcpy(copy, v, size);\n    return copy;\n}\n\nint countplaces(int n) {\n    int places = 1;\n    int divisor = 1;\n    if(n < 0) {\n        n = -n;\n        places++;\n    }\n    while(n \/ divisor >= 10) {\n        places++;\n        divisor *= 10;\n    }\n    return places;\n}\n\nchar* itoa(int i) {\n    int size = sizeof(char)*(countplaces(i)+1);\n    char* a = (char*)malloc(size);\n    snprintf(a, size, \"%i\", i);\n    return a;\n}\n\nchar* dotlabel(char* n1, char* n2) {\n    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s.%s\", n1, n2);\n    return result;\n}\n\nSTRINGLIST* onestr(const char* str) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    strlist->content = ezheapstr(str);\n    strlist->next = NULL;\n    return strlist;\n}\n\nSTRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}\n\nvoid printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}\n\nvoid freestrlist(STRINGLIST* strlist) {\n    STRINGLIST* next = strlist->next;\n    free(strlist);\n    if(next != NULL)\n        freestrlist(next);\n}\n\nbool existsinarray(STRINGARRAY* arr, const char* item) {\n    for(int i = 0; i < arr->size; i++)\n        if(!strcmp(arr->items[i], item))\n            return true;\n    return false;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"vm-lines.h\"\n\nLINE* mkline(int size) {\n    LINE* ln = (LINE*)malloc(sizeof(LINE));\n    ln->tokens = (char**)malloc(sizeof(char*)*size);\n    ln->count = 0;\n    return ln;\n}\n\nvoid addtoken(LINE* ln, char* token) {\n    ln->tokens[ln->count] = token;\n    ln->count++;\n}\n\nvoid println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}\n\nvoid printlns(LINE* lns, FILE* stream) {\n    while(lns != NULL) {\n        println(lns, stream);\n        lns = lns->next;\n    }\n}\n\nvoid freeln(LINE* ln) {\n    for(int i = 0; i < ln->count; i++)\n        free(ln->tokens[i]);\n    free(ln->tokens);\n    free(ln);\n}\n\nvoid freelns(LINE* lns) {\n    LINE* next = lns->next;\n    freeln(lns);\n    if(next != NULL)\n        freelns(next);\n}\n\nvoid freelnblk(LINEBLOCK* blk) {\n    freelns(blk->head);\n    free(blk);\n}\n\nLINEBLOCK* mklnblk(LINE* start) {\n    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));\n    blk->head = start;\n    blk->tail = start;\n    return blk;\n}\n\nLINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {\n    if(head == NULL)\n        return tail;\n    head->tail->next = tail->head;\n    head->tail = tail->tail;\n    free(tail);\n    return head;\n}\n\nvoid appendln(LINEBLOCK* lnblk, LINE* ln) {\n    lnblk->tail->next = ln;\n    lnblk->tail = ln;\n}\n\nvoid appendlnbefore(LINEBLOCK* lnblk, LINE* ln) {\n    ln->next = lnblk->head;\n    lnblk->head = ln;\n}\n"}
{"target":"augustogunsch","func":"#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include \"assembler-tables.h\"\n#include \"assembler.h\"\n#include \"util.h\"\n\nvoid expandsymbols(SYMBOLARRAY* a, int toaddn);\nvoid pushsymbol(SYMBOLARRAY* a, SYMBOL* s);\nvoid freesymbol(SYMBOL* s);\nSYMBOL* mksymbol(char* name, int namesize, int val);\nint getsymbol(ASSEMBLER* a, char* name);\nvoid skipln(ASSEMBLER* a);\nvoid readrest(ASSEMBLER* a, int trueln);\nint isvar(char* var);\nvoid initsymbols(SYMBOLARRAY* s);\nvoid populatevars(ASSEMBLER* a);\nSYMBOL* readlabel(ASSEMBLER* a, STRINGLIST* ln, int count);\nvoid replacevar(ASSEMBLER* a, STRINGLIST* ln, int val);\nvoid preprocess(ASSEMBLER* a);\nvoid transa(STRINGLIST* ln);\nchar* lookctable(TABLE* t, bool cond, char* token, const char* fieldname);\nvoid transb(STRINGLIST* ln);\nvoid assemble(ASSEMBLER* a);\nvoid freeassembler(ASSEMBLER* a);\nvoid strtogarbage(ASSEMBLER* a, char* str);\n\nvoid strtogarbage(ASSEMBLER* a, char* str) {\n    STRINGLIST* newstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    newstr->content = str;\n    newstr->next = a->garbage;\n    a->garbage = newstr;\n}\n\nvoid expandsymbols(SYMBOLARRAY* a, int toaddn) {\n    int sum = a->count + toaddn;\n    if(sizeof(SYMBOL*) * sum > a->size) {\n        a->size = sizeof(SYMBOL*) * sum * 3;\n        a->items = (SYMBOL**)realloc(a->items, a->size);\n    }\n}\n\nvoid pushsymbol(SYMBOLARRAY* a, SYMBOL* s) {\n    expandsymbols(a, 1);\n    a->items[a->count] = s;\n    a->count++;\n}\n\nvoid freesymbol(SYMBOL* s) {\n    free(s->name);\n    free(s);\n}\n\nvoid freesymbols(SYMBOLARRAY* a) {\n    for(int i = 0; i < a->count; i++)\n        freesymbol(a->items[i]);\n    free(a->items);\n    free(a);\n}\n\nSYMBOL* mksymbol(char* name, int namesize, int val) {\n    SYMBOL* s = (SYMBOL*)malloc(sizeof(SYMBOL));\n    char* heapname = (char*)malloc(namesize);\n    strcpy(heapname, name);\n    s->name = heapname;\n    s->value = val;\n    return s;\n}\n\nint getsymbol(ASSEMBLER* a, char* name) {\n    for(int i = 0; i < a->vars->count; i++)\n        if(strcmp(a->vars->items[i]->name, name)  == 0)\n            return a->vars->items[i]->value;\n\n    for(int i = 0; i < a->labels->count; i++)\n        if(strcmp(a->labels->items[i]->name, name)  == 0)\n            return a->labels->items[i]->value;\n    \n    return -1;\n}\n\nint isvar(char* var) {\n    int i = 0;\n    while(1) {\n        if(var[i] == '\\0')\n            break;\n        if(!isdigit(var[i]))\n            return 1;\n        i++;\n    }\n    return 0;\n}\n\nvoid initsymbols(SYMBOLARRAY* s) {\n    s->size = 150 * sizeof(SYMBOL*);\n    s->items = (SYMBOL**)malloc(s->size);\n    s->count = 0;\n}\n\nASSEMBLER* mkassembler(STRINGLIST* input) {\n    ASSEMBLER* a = (ASSEMBLER*)malloc(sizeof(ASSEMBLER));\n    a->labels = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));\n    a->vars = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));\n    a->garbage = NULL;\n    a->lns = input;\n\n    initsymbols(a->labels);\n    initsymbols(a->vars);\n\n    populatevars(a);\n    a->varsramind = BOTTOM_VAR;\n\n    return a;\n}\n\nvoid populatevars(ASSEMBLER* a) {\n    const int firstamnt = 5;\n    const int ramvamnt = 16; \n    const int specialamt = 2;\n    const int sum = firstamnt + ramvamnt + specialamt;\n\n    \n    expandsymbols(a->vars, sum);\n    \n    \n    a->vars->count = sum;\n\n    \n    char* labels[] = { \"SP\", \"LCL\", \"ARG\", \"THIS\", \"THAT\" };\n    for(int i = 0; i < firstamnt; i++) {\n        a->vars->items[i] = mksymbol(labels[i], strlen(labels[i])+1, i);\n    }\n\n    \n    const int asciioff = 48;\n    char ramvname[4];\n    ramvname[0] = 'R';\n    ramvname[2] = '\\0';\n    int tmptarg = (ramvamnt\/10)*10;\n    for(int i = 0; i < tmptarg; i++) {\n        ramvname[1] = (char)(i+asciioff);\n        a->vars->items[firstamnt+i] = mksymbol(ramvname, 3, i);\n    }\n    ramvname[1] = '1';\n    ramvname[3] = '\\0';\n    for(int i = 10; i < ramvamnt; i++) {\n        ramvname[2] = (char)((i%10)+asciioff);\n        a->vars->items[firstamnt+i] = mksymbol(ramvname, 4, i);\n    }\n\n    \n    a->vars->items[firstamnt+ramvamnt] = mksymbol(\"SCREEN\", 7, 16384);\n    \n    a->vars->items[firstamnt+ramvamnt+1] = mksymbol(\"KBD\", 4, 24576);\n}\n\nSYMBOL* readlabel(ASSEMBLER* a, STRINGLIST* ln, int count) {\n    int i = 1;\n    char c;\n    while(true) {\n        c = ln->content[i];\n        if(c == ')') \n            break;\n        i++;\n    }\n\n    int size = i * sizeof(char);\n    char* name = (char*)malloc(size);\n    snprintf(name, size, \"%s\", ln->content+sizeof(char));\n    SYMBOL* l = (SYMBOL*)malloc(sizeof(SYMBOL));\n    l->name = name;\n    l->value = count;\n    return l;\n}\n\nvoid replacevar(ASSEMBLER* a, STRINGLIST* ln, int val) {\n    int size = sizeof(char)*(countplaces(val) + 2);\n    char* newln = (char *)malloc(size);\n    snprintf(newln, size, \"@%i\", val);\n    ln->content = newln;\n    strtogarbage(a, newln);\n}\n\nvoid handlevarsymbol(ASSEMBLER* a, STRINGLIST* ln) {\n    char* afterat = ln->content+sizeof(char);\n    if(isvar(afterat)) {\n        int val = getsymbol(a, afterat);\n        if(val == -1) {\n            if(a->varsramind == RAM_LIMIT) {\n                eprintf(\"Variable amount reached RAM limit (%i)\\n\", RAM_LIMIT);\n                exit(1);\n            }\n            SYMBOL* var = mksymbol(afterat, strlen(afterat)+1, a->varsramind);\n            a->varsramind++;\n            pushsymbol(a->vars, var);\n            val = var->value;\n        }\n        replacevar(a, ln, val);\n    }\n}\n\nvoid handlelabelsymbol(ASSEMBLER* a, STRINGLIST* ln, int count) {\n    SYMBOL* l = readlabel(a, ln, count);\n\n    pushsymbol(a->labels, l);\n}\n\nvoid stripvars(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    while(curln != NULL) {\n        if(curln->content[0] == '@')\n                handlevarsymbol(a, curln);\n        curln = curln->next;\n    }\n}\n\nvoid striplabels(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    STRINGLIST* lastln;\n    int count = 0;\n    while(curln != NULL) {\n        if(curln->content[0] == '(') {\n            handlelabelsymbol(a, curln, count);\n            if(count > 0)\n                lastln->next = curln->next;\n            else\n                a->lns = curln->next;\n            STRINGLIST* tmp = curln;\n            curln = curln->next;\n            free(tmp);\n        }\n        else {\n            lastln = curln;\n            curln = curln->next;\n            count++;\n        }\n    }\n}\n\nvoid preprocess(ASSEMBLER* a) {\n    striplabels(a);\n    stripvars(a);\n}\n\nvoid transa(STRINGLIST* ln) {\n    int add = atoi(ln->content+sizeof(char));\n\n    char* out = (char*)malloc(sizeof(char) * INST_SIZE);\n\n    int lastbit = 1 << 15;\n    for(int i = INST_SIZE-2; i > 0; i--) {\n        if(add & (lastbit >> i))\n            out[i] = '1';\n        else\n            out[i] = '0';\n    }\n\n    out[INST_SIZE-1] = '\\0';\n    out[0] = '0';\n\n    ln->content = out;\n}\n\nchar* lookctable(TABLE* t, bool cond, char* token, const char* fieldname) {\n    char* out = (char*)malloc(t->instsize);\n\n    if(!cond) {\n        int targsize = t->instsize - 1;\n        for(int i = 0; i < targsize; i++)\n            out[i] = '0';\n        out[t->instsize-1] = '\\0';\n        return out;\n    }\n    for(int i = 0; i < t->size; i++)\n        if(strcmp(t->table[2*i], token) == 0) {\n            strcpy(out, t->table[(2*i)+1]);\n            return out;\n        }\n    return NULL;\n}\n\nvoid transb(STRINGLIST* ln) {\n    bool hasjmp = false;\n    bool hasdest = false;\n    bool hascmp = false;\n    int i = 0;\n    int tmpi = 0;\n    char tmp[C_TOKEN_SIZE], dest[C_TOKEN_SIZE], cmp[C_TOKEN_SIZE], jmp[C_TOKEN_SIZE];\n\n    while(true) {\n        if(ln->content[i] == '\\0') {\n            tmp[tmpi] = '\\0';\n            if(hasjmp)\n                strcpy(jmp, tmp);\n            else\n                strcpy(cmp, tmp);\n            break;\n        }\n\n        if(ln->content[i] == '=' && !hasdest && hascmp) {\n            hascmp = false;\n            hasdest = true;\n            tmp[tmpi] = '\\0';\n            strcpy(dest, tmp);\n            tmpi = 0;\n            i++;\n            continue;\n        }\n        if(ln->content[i] == ';' && !hasjmp && hascmp) {\n            hascmp = false;\n            hasjmp = true;\n            tmp[tmpi] = '\\0';\n            strcpy(cmp, tmp);\n            tmpi = 0;\n            i++;\n            continue;\n        }\n        \n        hascmp = 1;\n        tmp[tmpi] = ln->content[i];\n        tmpi++;\n        i++;\n    }\n    \n    char* rawdest = lookctable(&desttable, hasdest, dest, \"dest\");\n    char* rawjmp = lookctable(&jmptable, hasjmp, jmp, \"jump\");\n    char* rawcmp = lookctable(&cmptable, 1, cmp, \"comp\");\n\n    int sz = sizeof(char) * INST_SIZE;\n    char* out = (char*)malloc(sz);\n    snprintf(out, sz, \"111%s%s%s\", rawcmp, rawdest, rawjmp);\n\n    ln->content = out;\n    free(rawdest);\n    free(rawjmp);\n    free(rawcmp);\n}\n\nvoid assemble(ASSEMBLER* a) {\n    STRINGLIST* currln = a->lns;\n    while(currln != NULL) {\n        if(currln->content[0] == '@')\n            transa(currln);\n        else\n            transb(currln);\n        currln = currln->next;\n    }\n}\n\nvoid freeasmlns(STRINGLIST* lns) {\n    if(lns != NULL) {\n        free(lns->content);\n        STRINGLIST* next = lns->next;\n        free(lns);\n        freeasmlns(next);\n    }\n}\n\nvoid freeassembler(ASSEMBLER* a) {\n    freesymbols(a->vars);\n    freesymbols(a->labels);\n    freeasmlns(a->lns);\n    freeasmlns(a->garbage);\n    free(a);\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <pthread.h>\n#include \"compiler.h\"\n#include \"compiler-scopes.h\"\n\ntypedef enum { local, staticseg, arg, fieldseg } MEMSEGMENT;\nchar* memsegnames[] = { \"local\", \"static\", \"argument\", \"this\" };\n\n\nvoid doubledeclaration(const char* name, DEBUGINFO* d1, DEBUGINFO* d2);\nvoid ensurenoduplicate(SCOPE* s, DEBUGINFO* d, char* name);\n\n\nVAR* getvarinvars(VAR* vars, const char* name);\nCLASS* getclass(SCOPE* s, const char* name);\nSUBROUTDEC* getsubroutdecfromlist(SUBROUTDEC* start, char* name);\nSUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call);\nSUBROUTDEC* getfunction(SCOPE* s, SUBROUTCALL* call);\nSUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret);\nSUBROUTDEC* getsubroutdecwithoutparent(SCOPE* s, SUBROUTCALL* call);\nSUBROUTDEC* getsubroutdec(SCOPE* s, const char* name);\n\n\nVAR* mkvar(char* type, char* name, bool primitive, DEBUGINFO* debug, MEMSEGMENT seg, int i);\nvoid addvar(SCOPE* s, VAR** dest, VAR* v);\nvoid addlocalvar(SCOPE* s, VARDEC* v, int* i);\nvoid addstaticvar(SCOPE* s, CLASSVARDEC* v);\nvoid addfield(SCOPE* s, CLASSVARDEC* v, int* i);\nvoid addclassvardec(SCOPE* s, CLASSVARDEC* v, int* i);\nvoid addparameter(SCOPE* s, PARAMETER* p, int* i);\n\n\nvoid doubledeclaration(const char* name, DEBUGINFO* d1, DEBUGINFO* d2) {\n    eprintf(\"Double declaration of '%s' at '%s', line %i; previously defined at '%s', line %i\\n\",\n                name, d1->file, d1->definedat, d2->file, d2->definedat);\n    exit(1);\n}\n\nvoid notdeclared(const char* name, DEBUGINFO* debug) {\n    eprintf(\"'%s' not declared; file '%s', line %i\\n\", name, debug->file, debug->definedat);\n    exit(1);\n}\n\nvoid invalidparent(SUBROUTCALL* call) {\n    eprintf(\"Invalid subroutine parent '%s'; file '%s', line %i\\n\", call->parentname, call->debug->file, call->debug->definedat);\n    exit(1);\n}\n\nvoid ensurenoduplicate(SCOPE* s, DEBUGINFO* d, char* name) {\n    VAR* v = getvar(s, name);\n    if(v != NULL)\n        doubledeclaration(name, d, v->debug);\n\n    CLASS* c = getclass(s, name);\n    if(c != NULL)\n        doubledeclaration(name, d, c->debug);\n\n    SUBROUTDEC* sr = getsubroutdec(s, name);\n    if(sr != NULL)\n        doubledeclaration(name, d, sr->debug);\n}\n\n\nSCOPE* mkscope(SCOPE* prev) {\n    SCOPE* s = (SCOPE*)malloc(sizeof(SCOPE));\n    s->previous = prev;\n    if(prev != NULL)\n        s->compiler = prev->compiler;\n    s->localvars = NULL;\n    s->fields = NULL;\n    s->staticvars = NULL;\n    s->parameters = NULL;\n    s->classes = NULL;\n    s->subroutines = NULL;\n    return s;\n}\n\n\nVAR* getvarinvars(VAR* vars, const char* name) {\n    while(vars != NULL) {\n        if(!strcmp(vars->name, name))\n            return vars;\n        vars = vars->next;\n    }\n    return NULL;\n}\n\nVAR* getvar(SCOPE* s, const char* name) {\n    VAR* var = getvarinvars(s->localvars, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->parameters, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->fields, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->staticvars, name);\n    if(var != NULL)\n        return var;\n    if(s->previous != NULL)\n        return getvar(s->previous, name);\n    return NULL;\n}\n\nVAR* getvarmustexist(SCOPE* s, DEBUGINFO* d, const char* name) {\n    VAR* v = getvar(s, name);\n    if(v == NULL)\n        notdeclared(name, d);\n    return v;\n}\n\nCLASS* getclass(SCOPE* s, const char* name) {\n    CLASS* curr = s->classes;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    if(s->previous != NULL)\n        return getclass(s->previous, name);\n    return NULL;\n}\n\nSUBROUTDEC* getsubroutdecfromlist(SUBROUTDEC* start, char* name) {\n    while(start != NULL) {\n        if(!strcmp(start->name, name))\n            return start;\n        start = start->next;\n    }\n    return NULL;\n}\n\nSUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, parent->type);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass != method) {\n        eprintf(\"Calling a function\/constructor as if it were a method; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}\n\nSUBROUTDEC* getfunction(SCOPE* s, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, call->parentname);\n    if(c == NULL)\n        notdeclared(call->parentname, call->debug);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass == method) {\n        eprintf(\"Calling a method as if it were a function; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}\n\nSUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    VAR* parent = getvar(s, call->parentname);\n    if(parent != NULL) {\n        if(parent->primitive) {\n            eprintf(\"Primitive type does not have subroutines; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n            exit(1);\n        }\n        *varret = parent;\n        return getmethod(s, parent, call);\n    }\n    else\n        return getfunction(s, call);\n}\n\nSUBROUTDEC* getsubroutdecwithoutparent(SCOPE* s, SUBROUTCALL* call) {\n    SUBROUTDEC* d = getsubroutdecfromlist(s->currclass->subroutdecs, call->name);\n    return d;\n}\n\nSUBROUTDEC* getsubroutdecfromcall(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    SUBROUTDEC* d;\n    *varret = NULL;\n    if(call->parentname != NULL)\n        d = getsubroutdecwithparent(s, call, varret);\n    else\n        d = getsubroutdecwithoutparent(s, call);\n    if(d == NULL)\n        notdeclared(call->name, call->debug);\n    return d;\n}\n\nSUBROUTDEC* getsubroutdec(SCOPE* s, const char* name) {\n    SUBROUTDEC* curr = s->subroutines;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    if(s->previous != NULL)\n        return getsubroutdec(s->previous, name);\n    return NULL;\n}\n\n\nVAR* mkvar(char* type, char* name, bool primitive, DEBUGINFO* debug, MEMSEGMENT seg, int i) {\n    VAR* v = (VAR*)malloc(sizeof(VAR));\n    v->name = name;\n    v->type = type;\n    v->debug = debug;\n    v->memsegment = memsegnames[seg];\n    v->primitive = primitive;\n    v->index = i;\n    return v;\n}\n\nvoid addvar(SCOPE* s, VAR** dest, VAR* v) {\n    ensurenoduplicate(s, v->debug, v->name);\n\n    if(!v->primitive) {\n        CLASS* type = getclass(s, v->type);\n        if(type == NULL)\n            notdeclared(v->type, v->debug);\n    }\n\n    v->next = *dest;\n    *dest = v;\n}\n\nvoid addlocalvar(SCOPE* s, VARDEC* v, int* i) {\n    STRINGLIST* currname = v->names;\n    while(currname != NULL) {\n        addvar(s, &(s->localvars), mkvar(v->type, currname->content, v->primitive, v->debug, local, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}\n\nvoid addstaticvar(SCOPE* s, CLASSVARDEC* v) {\n    STRINGLIST* currname = v->base->names;\n    pthread_mutex_lock(&(s->compiler->staticmutex));\n    static int i = 0;\n    while(currname != NULL) {\n        addvar(s, &(s->staticvars), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, staticseg, i));\n        currname = currname->next;\n        i++;\n    }\n    pthread_mutex_unlock(&(s->compiler->staticmutex));\n}\n\nvoid addfield(SCOPE* s, CLASSVARDEC* v, int* i) {\n    STRINGLIST* currname = v->base->names;\n    while(currname != NULL) {\n        addvar(s, &(s->fields), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, fieldseg, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}\n\nvoid addclassvardec(SCOPE* s, CLASSVARDEC* v, int* i) {\n    if(v->type == stat)\n        addstaticvar(s, v);\n    else {\n        addfield(s, v, i);\n    }\n}\n\nvoid addparameter(SCOPE* s, PARAMETER* p, int* i) {\n    addvar(s, &(s->parameters), mkvar(p->type, p->name, p->primitive, p->debug, arg, *i));\n    (*i)++;\n}\n\n\nvoid addclassvardecs(SCOPE* s, CLASSVARDEC* classvardecs) {\n    int i = 0;\n    while(classvardecs != NULL) {\n        addclassvardec(s, classvardecs, &i);\n        classvardecs = classvardecs->next;\n    }\n}\n\nvoid addlocalvars(SCOPE* s, VARDEC* localvars) {\n    int i = 0;\n    while(localvars != NULL) {\n        addlocalvar(s, localvars, &i);\n        localvars = localvars->next;\n    }\n}\n\nvoid addparameters(SCOPE* s, bool isformethod, PARAMETER* params) {\n    int i = isformethod ? 1 : 0;\n    while(params != NULL) {\n        addparameter(s, params, &i);\n        params = params->next;\n    }\n}\n\nvoid freevars(VAR* v) {\n    if(v != NULL) {\n        VAR* next = v->next;\n        free(v);\n        freevars(next);\n    }\n}\n\nvoid freescope(SCOPE* s) {\n    freevars(s->fields);\n    freevars(s->staticvars);\n    freevars(s->localvars);\n    freevars(s->parameters);\n    free(s);\n};\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include <string.h>\n#include \"compiler-expressions.h\"\n#include \"compiler-statements.h\"\n#include \"compiler-util.h\"\n\n\n\n\nLINE* popthat();\nLINE* pushtemp();\nchar* mkcondlabel(char* name, int count);\n\n\nLINEBLOCK* compileret(SCOPE* s, STATEMENT* st);\nLINEBLOCK* compileif(SCOPE* s, STATEMENT* st);\nLINEBLOCK* compilewhile(SCOPE* s, STATEMENT* st);\nLINEBLOCK* compilelet(SCOPE* s, STATEMENT* st);\nLINEBLOCK* compilestatement(SCOPE* s, STATEMENT* st);\n\n\n\n\n\n\nLINE* popthat() {\n    char* popthat[] = { \"pop\", \"that\", \"0\" };\n    return mkln(popthat);\n}\n\nLINE* pushtemp() {\n    char* pushtemp[] = { \"push\", \"temp\", \"0\" };\n    return mkln(pushtemp);\n}\n\nchar* mkcondlabel(char* name, int count) {\n    int sz = (strlen(name) + countplaces(count) + 1) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s%i\", name, count);\n    return result;\n}\n\n\nLINEBLOCK* compileret(SCOPE* s, STATEMENT* st) {\n    TERM* e = st->retstatement;\n    LINE* ret = onetoken(\"return\");\n    LINEBLOCK* blk = mklnblk(ret);\n\n    \n    if(e == NULL) {\n        char* tokens[] = { \"push\", \"constant\", \"0\" };\n        appendlnbefore(blk, mkln(tokens));\n    } else\n        blk = mergelnblks(compileexpression(s, st->debug, e), blk);\n\n    return blk;\n}\n\nLINEBLOCK* compileif(SCOPE* s, STATEMENT* st) {\n    IFSTATEMENT* ifst = st->ifstatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, ifst->base->expression);\n\n    pthread_mutex_lock(&(s->compiler->ifmutex));\n    static int ifcount = 0;\n    int mycount = ifcount;\n    ifcount++;\n    pthread_mutex_unlock(&(s->compiler->ifmutex));\n    \n    char* truelabel = mkcondlabel(\"IF_TRUE\", mycount);\n    char* ifgoto[] = { \"if-goto\", truelabel };\n    appendln(blk, mkln(ifgoto));\n    \n    char* falselabel = mkcondlabel(\"IF_FALSE\", mycount);\n    char* gotofalse[] = { \"goto\", falselabel };\n    appendln(blk, mkln(gotofalse));\n\n    char* truelabelln[] = { \"label\", truelabel };\n    appendln(blk, mkln(truelabelln));\n\n    blk = mergelnblks(blk, compilestatements(s, ifst->base->statements));\n\n    char* endlabel;\n    bool haselse = ifst->elsestatements != NULL;\n    if(haselse) {\n        endlabel = mkcondlabel(\"IF_END\", mycount);\n        char* endgoto[] = { \"goto\", endlabel };\n        appendln(blk, mkln(endgoto));\n    }\n\n    char* falselabelln[] = { \"label\", falselabel};\n    appendln(blk, mkln(falselabelln));\n\n    if(haselse) {\n        blk = mergelnblks(blk, compilestatements(s, ifst->elsestatements));\n        char* endlabelln[] = { \"label\", endlabel };\n        appendln(blk, mkln(endlabelln));\n        free(endlabel);\n    }\n\n    free(falselabel);\n    free(truelabel);\n\n    return blk;\n}\n\nLINEBLOCK* compilewhile(SCOPE* s, STATEMENT* st) {\n    CONDSTATEMENT* w = st->whilestatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, w->expression);\n\n    pthread_mutex_lock(&(s->compiler->whilemutex));\n    static int whilecount = 0;\n    int mycount = whilecount;\n    whilecount++;\n    pthread_mutex_unlock(&(s->compiler->whilemutex));\n\n    char* explabel = mkcondlabel(\"WHILE_EXP\", mycount);\n    char* explabelln[] = { \"label\", explabel };\n    appendlnbefore(blk, mkln(explabelln));\n\n    appendln(blk, onetoken(\"not\"));\n\n    char* endlabel = mkcondlabel(\"WHILE_END\", mycount);\n    char* ifgoto[] = { \"if-goto\", endlabel };\n    appendln(blk, mkln(ifgoto));\n\n    blk = mergelnblks(blk, compilestatements(s, w->statements));\n\n    char* gotoln[] = { \"goto\", explabel };\n    appendln(blk, mkln(gotoln));\n\n    char* endlabelln[] = { \"label\", endlabel };\n    appendln(blk, mkln(endlabelln));\n\n    free(explabel);\n    free(endlabel);\n\n    return blk;\n}\n\nLINEBLOCK* compilelet(SCOPE* s, STATEMENT* st) {\n    LETSTATEMENT* l = st->letstatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, l->expression);\n\n    if(l->arrayind != NULL) {\n        appendlnbefore(blk, onetoken(\"add\"));\n        appendlnbefore(blk, pushvar(s, st->debug, l->varname));\n        blk = mergelnblks(compileexpression(s, st->debug, l->arrayind), blk);\n\n        appendln(blk, poptemp());\n        appendln(blk, popthatadd());\n        appendln(blk, pushtemp());\n        appendln(blk, popthat());\n    }\n    else\n        appendln(blk, popvar(s, st->debug, l->varname));\n    return blk;\n}\n\nLINEBLOCK* compilestatement(SCOPE* s, STATEMENT* st) {\n    if(st->type == dostatement) return compilesubroutcall(s, st->dostatement);\n    if(st->type == returnstatement) return compileret(s, st);\n    if(st->type == ifstatement) return compileif(s, st);\n    if(st->type == whilestatement) return compilewhile(s, st);\n    return compilelet(s, st);\n}\n\nLINEBLOCK* compilestatements(SCOPE* s, STATEMENT* sts) {\n    LINEBLOCK* head = NULL;\n    while(sts != NULL) {\n        head = mergelnblks(head, compilestatement(s, sts));\n        sts = sts->next;\n    }\n    return head;\n}\n\nLINEBLOCK* compilestatementsretlast(SCOPE* s, STATEMENT* sts, STATEMENT** retlast) {\n    LINEBLOCK* head = NULL;\n    STATEMENT* last = NULL;\n    while(sts != NULL) {\n        head = mergelnblks(head, compilestatement(s, sts));\n        last = sts;\n        sts = sts->next;\n    }\n    *retlast = last;\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"compiler-statements.h\"\n#include \"compiler-structure.h\"\n#include \"compiler-util.h\"\n\n\n\n\nint countlocalvars(VARDEC* decs);\nint countstrs(STRINGLIST* ls);\nint getobjsize(CLASS* c);\nLINE* mksubdeclabel(CLASS* c, SUBROUTDEC* sd);\n\n\nLINEBLOCK* compilefunbody(SCOPE* s, CLASS* cl, SUBROUTDEC* d);\nLINEBLOCK* compilefundec(SCOPE* s, CLASS* cl, SUBROUTDEC* f);\nLINEBLOCK* compileconstructor(SCOPE* s, CLASS* cl, SUBROUTDEC* con);\nLINEBLOCK* compilemethod(SCOPE* s, CLASS* cl, SUBROUTDEC* m);\n\n\n\n\n\nint countlocalvars(VARDEC* decs) {\n    int i = 0;\n    while(decs != NULL) {\n        STRINGLIST* curr = decs->names;\n        while(curr != NULL) {\n            i++;\n            curr = curr->next;\n        }\n        decs = decs->next;\n    }\n    return i;\n}\n\nint countstrs(STRINGLIST* ls) {\n    int count = 0;\n    while(ls != NULL) {\n        count++;\n        ls = ls->next;\n    }\n    return count;\n}\n\nint getobjsize(CLASS* c) {\n    CLASSVARDEC* curr = c->vardecs;\n    int count = 0;\n    while(curr != NULL) {\n        if(curr->type == field)\n            count += countstrs(curr->base->names);\n        curr = curr->next;\n    }\n    return count;\n}\n\nLINE* mksubdeclabel(CLASS* c, SUBROUTDEC* sd) {\n    char* labelstrs[] = { \"function\", dotlabel(c->name, sd->name), itoa(countlocalvars(sd->body->vardecs)) };\n    LINE* label = mkln(labelstrs);\n    free(labelstrs[1]);\n    free(labelstrs[2]);\n    label->next = NULL;\n    return label;\n}\n\n\nLINEBLOCK* compilefunbody(SCOPE* s, CLASS* cl, SUBROUTDEC* d) {\n    SUBROUTBODY* b = d->body;\n    SCOPE* myscope = mkscope(s);\n    myscope->currclass = cl;\n    if(b->vardecs != NULL)\n        addlocalvars(myscope, b->vardecs);\n\n    if(b->statements == NULL) {\n        eprintf(\"Subroutine body has no statements; file '%s', line %i\\n\",\n                d->debug->file, d->debug->definedat);\n        exit(1);\n    }\n\n    STATEMENT* last;\n    LINEBLOCK* head = compilestatementsretlast(myscope, b->statements, &last);\n    if(last->type != returnstatement) {\n        eprintf(\"Subroutine must end with a return statement; file '%s', line %i\\n\",\n                last->debug->file, last->debug->definedat);\n        exit(1);\n    }\n\n    freescope(myscope);\n    return head;\n}\n\nLINEBLOCK* compilefundec(SCOPE* s, CLASS* cl, SUBROUTDEC* f) {\n    LINE* label = mksubdeclabel(cl, f);\n\n    LINEBLOCK* body = compilefunbody(s, cl, f);\n    appendlnbefore(body, label);\n    return body;\n}\n\nLINEBLOCK* compileconstructor(SCOPE* s, CLASS* cl, SUBROUTDEC* con) {\n    LINE* label = mksubdeclabel(cl, con);\n    LINEBLOCK* blk = mklnblk(label);\n\n    char* size[] = { \"push\", \"constant\", itoa(getobjsize(cl)) };\n    char* memalloc[] = { \"call\", \"Memory.alloc\", \"1\" };\n    char* poppointer[] = { \"pop\", \"pointer\", \"0\" };\n    appendln(blk, mkln(size));\n    appendln(blk, mkln(memalloc));\n    appendln(blk, mkln(poppointer));\n    free(size[2]);\n\n    if(con->body != NULL)\n        return mergelnblks(blk, compilefunbody(s, cl, con));\n    else\n        return blk;\n}\n\nLINEBLOCK* compilemethod(SCOPE* s, CLASS* cl, SUBROUTDEC* m) {\n    LINE* label = mksubdeclabel(cl, m);\n    LINEBLOCK* blk = mklnblk(label);\n\n    char* pusharg0[] = { \"push\", \"argument\", \"0\" };\n    char* poppointer[] = { \"pop\", \"pointer\", \"0\" };\n    appendln(blk, mkln(pusharg0));\n    appendln(blk, mkln(poppointer));\n\n    if(m->body != NULL) \n        return mergelnblks(blk, compilefunbody(s, cl, m));\n    else\n        return blk;\n}\n\nLINEBLOCK* compilesubroutdec(SCOPE* s, CLASS* cl, SUBROUTDEC* sd) {\n    SCOPE* myscope = mkscope(s);\n    LINEBLOCK* blk;\n    if(sd->parameters != NULL)\n        addparameters(myscope, sd->subroutclass == method, sd->parameters);\n    if(sd->subroutclass == function)\n        blk = compilefundec(myscope, cl, sd);\n    else if(sd->subroutclass == constructor)\n        blk = compileconstructor(myscope, cl, sd);\n    else\n        blk = compilemethod(myscope, cl, sd);\n    freescope(myscope);\n    return blk;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"compiler-util.h\"\n\nLINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}\n\nLINE* pushvarraw(SCOPE* s, VAR* v) {\n    return opvarraw(s, \"push\", v);\n}\n\nLINE* pushvar(SCOPE* s, DEBUGINFO* d, const char* name) {\n    return opvarraw(s, \"push\", getvarmustexist(s, d, name));\n}\n\nLINE* popvar(SCOPE* s, DEBUGINFO* d, const char* name) {\n    return opvarraw(s, \"pop\", getvarmustexist(s, d, name));\n}\n\nLINE* poptemp() {\n    char* poptemp[] = { \"pop\", \"temp\", \"0\" };\n    return mksimpleln(poptemp, strcount(poptemp));\n}\n\nLINE* popthatadd() {\n    char* popthatadd[] = { \"pop\", \"pointer\", \"1\" };\n    return mksimpleln(popthatadd, strcount(popthatadd));\n}\n\nLINE* onetoken(char* str) {\n    LINE* ln = mkline(1);\n    addtoken(ln, ezheapstr(str));\n    ln->next = NULL;\n    return ln;\n}\n\nLINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"compiler-structure.h\"\n#include \"compiler.h\"\n\n\nLINEBLOCK* compileclass(COMPILER* c, CLASS* class) {\n    SCOPE* topscope = mkscope(c->globalscope);\n    if(class->vardecs != NULL)\n        addclassvardecs(topscope, class->vardecs);\n    if(class->subroutdecs != NULL)\n        topscope->subroutines = class->subroutdecs;\n\n    LINEBLOCK* output = NULL;\n    SUBROUTDEC* curr = class->subroutdecs;\n    while(curr != NULL) {\n        output = mergelnblks(output, compilesubroutdec(topscope, class, curr));\n        curr = curr->next;\n    }\n    freescope(topscope);\n    return output;\n}\n\nCOMPILER* mkcompiler(CLASS* classes) {\n    COMPILER* c = (COMPILER*)malloc(sizeof(COMPILER));\n    c->globalscope = mkscope(NULL);\n    c->globalscope->compiler = c;\n    c->globalscope->classes = classes;\n    c->classes = classes;\n    pthread_mutex_init(&(c->ifmutex), NULL);\n    pthread_mutex_init(&(c->whilemutex), NULL);\n    pthread_mutex_init(&(c->staticmutex), NULL);\n    return c;\n}\n\nvoid freecompiler(COMPILER* c) {\n    pthread_mutex_destroy(&(c->ifmutex));\n    pthread_mutex_destroy(&(c->whilemutex));\n    pthread_mutex_destroy(&(c->staticmutex));\n    freescope(c->globalscope);\n    free(c);\n}\n"}
{"target":"augustogunsch","func":"#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys\/types.h>\n#include <dirent.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"util.h\"\n#include \"io.h\"\n\n#include <limits.h>\n#ifndef PATH_MAX\n#ifdef __linux__\n#include <linux\/limits.h>\n#else\n#define PATH_MAX 512\n#endif\n#endif\n\nchar* strtail(char* str, int len, int count) {\n    int index = len - count;\n    if (index <= 0) return str;\n    return str + (sizeof(char) * (index));\n}\n\nchar* strhead(char* str, int count) {\n    return str + (sizeof(char) * count);\n}\n\nchar* trimstr(char* str, int len, int end) {\n    int count = len - end;\n    char oldchar = str[count];\n    str[count] = '\\0';\n    char* newstr = (char*)malloc(sizeof(char) * (1 + count));\n    strcpy(newstr, str);\n    str[count] = oldchar;\n    return newstr;\n}\n\nchar* getname(char* f, int len) {\n    int startind = 0;\n    int endind = len - 1;\n    bool readsmt = false;\n \n    for(int i = endind; i >= 0; i--) {\n        if(f[i] == '\/') {\n            if(!readsmt) {\n                endind = i-1;\n                f[i] = '\\0';\n                continue;\n            }\n            startind = i+1;\n            break;\n        }\n        readsmt = true;\n    }\n\n    int sz = sizeof(char)*(endind - startind + 2);\n    char* startstr = strhead(f, startind);\n    char* retstr = (char*)malloc(sz);\n    snprintf(retstr, sz, \"%s\", startstr);\n    return retstr;\n}\n\nchar* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {\n    int sz = sizeof(char)*(fnamelen+dirlen+2);\n    char* fullname = (char*)malloc(sz);\n    sprintf(fullname, \"%s\/%s\", dirname, fname);\n    return fullname;\n}\n\nbool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}\n\nbool isdir(char* f) {\n    bool readsmt = false;\n    for(int i = strlen(f)-1; i >= 0; i--) {\n        if(f[i] == '.') {\n            if(readsmt)\n                return false;\n            else\n                continue;\n        }\n        if(f[i] == '\/')\n            return 1;\n        readsmt = true;\n    }\n    return true;\n}\n\nchar* getoutname(char* fullname, int len) {\n    char* trimmed = trimstr(fullname, len, 4);\n    int sz = sizeof(char) * (len-1);\n    char* outname = (char*)malloc(sz);\n    snprintf(outname, sz, \"%svm\", trimmed);\n    free(trimmed);\n    return outname;\n}\n\nFILELIST* addfile(FILELIST* l, char* fullname, char* name) {\n    FILELIST* new = (FILELIST*)malloc(sizeof(FILELIST));\n    new->name = name;\n    new->fullname = fullname;\n    new->next = l;\n    new->outname = getoutname(fullname, strlen(fullname));\n    return new;\n}\n\nFILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    \n    closedir(d);\n\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}\n\nFILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}\n\nFILELIST* getfiles(char* input) {\n    if(isdir(input))\n        return getfilesfromdir(input);\n    else\n        return getsinglefile(input);\n}\n\nvoid freefilelist(FILELIST* fs) {\n    free(fs->name);\n    free(fs->fullname);\n    free(fs->outname);\n    FILELIST* next = fs->next;\n    free(fs);\n    if(next != NULL)\n        freefilelist(next);\n}\n\nchar* getouthack(char* input) {\n    char* out;\n    int inplen = strlen(input);\n    if(isdir(input)) {\n        char* name = getname(input, inplen);\n        int sz = (inplen + strlen(name) + 7) * sizeof(char);\n        out = (char*)malloc(sz);\n        sprintf(out, \"%s\/%s.hack\", input, name);\n        free(name);\n    }\n    else {\n        out = heapstr(input, inplen);\n        out[inplen-4] = 'h';\n    }\n    return out;\n}\n"}
{"target":"augustogunsch","func":"#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"threads.h\"\n#include \"parser.h\"\n#include \"compiler.h\"\n#include \"io.h\"\n#include \"assembler.h\"\n\nint main(int argc, char* argv[]) {\n    if(argc < 2) {\n        eprintf(\"Usage: %s {input file(s)}\\n\", argv[0]);\n        return 1;\n    }\n\n    FILELIST* files = getfiles(argv[1]);\n    FILELIST* curr = files->next;\n\n    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n\n    head->file = files;\n    head->parser = mkparser(tokenize(files->fullname), files->name);\n\n    COMPILEUNIT* currunit = head;\n    while(curr != NULL) {\n        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n        newunit->file = curr;\n        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);\n        currunit->next = newunit;\n        currunit = newunit;\n        curr = curr->next;\n    }\n    currunit->next = NULL;\n\n    actonunits(head, parseunit);\n\n    CLASS* headclass = head->parsed;\n    CLASS* currclass = headclass;\n    currunit = head->next;\n    while(currunit != NULL) {\n        currclass->next = currunit->parsed;\n        currclass = currunit->parsed;\n        currunit = currunit->next;\n    }\n    currclass->next = NULL;\n    COMPILER* compiler = mkcompiler(headclass);\n\n    currunit = head;\n    while(currunit != NULL) {\n        currunit->compiler = compiler;\n        currunit = currunit->next;\n    }\n\n    actonunits(head, compileunit);\n    actonunits(head, vmtranslateunit);\n\n    ASMBLK* asmlns = head->asmlns;\n    currunit = head->next;\n    while(currunit != NULL) {\n        mergeasmblks(asmlns, currunit->asmlns);\n        currunit = currunit->next;\n    }\n\n    ASSEMBLER* assembler = mkassembler(asmlns->head);\n    preprocess(assembler);\n    assemble(assembler);\n\n\n    char* outname = getouthack(argv[1]);\n    FILE* output = fopen(outname, \"w\");\n    if(output == NULL) {\n        eprintf(\"%s\", strerror(errno));\n        exit(1);\n    }\n\n    printstrlist(asmlns->head, output);\n    free(asmlns);\n\n    fclose(output);\n    free(outname);\n\n    currunit = head;\n    while(currunit != NULL) {\n        COMPILEUNIT* next = currunit->next;\n        freeunit(currunit);\n        currunit = next;\n    }\n\n    freecompiler(compiler);\n    freeassembler(assembler);\n    freetree(headclass);\n    freefilelist(files);\n    return 0;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"util.h\"\n#include \"parser-util.h\"\n#include \"parser-expressions.h\"\n\n    const char* keywordsarr[] = { \"true\", \"false\", \"null\", \"this\" };\n    const char* opsarr[] = { \"+\", \"-\", \"*\", \"\/\", \"&\", \"|\", \"<\", \">\", \"=\" };\n    mkstrlist(keywordconstants, keywordsarr);\nmkstrlist(operators, opsarr);\n\n\n\n\nbool isop(TOKEN* t);\n\n\nTERM* parsetermnullified(PARSER* p);\nTERM* parseterm(PARSER* p);\nTERM* mkterm(TERMTYPE type);\nTERM* parseint(PARSER* p);\nTERM* parsestr(PARSER* p);\nTERM* parsekeyword(PARSER* p);\nTERM* parseunaryopterm(PARSER* p);\nTERM* parseinnerexpression(PARSER* p);\nTERM* parsecalltermnullified(PARSER* p);\nTERM* parsearrayterm(PARSER* p);\nTERM* parsevarterm(PARSER* p);\nTERM* parseidentifierterm(PARSER* p);\nSUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c);\nSUBROUTCALL* parsesubroutcallnullified(PARSER* p);\n\n\n\n\nbool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}\n\n\nTERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}\n\nTERM* parseterm(PARSER* p) {\n    TERM* t = parsetermnullified(p);\n    if(t == NULL)\n        unexpected(p);\n    return t;\n}\n\nTERM* mkterm(TERMTYPE type) {\n    TERM* t = (TERM*)malloc(sizeof(TERM));\n    t->type = type;\n    return t;\n}\n\nTERM* parseint(PARSER* p) {\n    TERM* t = mkterm(intconstant);\n    t->integer = atoi(p->current->token);\n    next(p);\n    return t;\n}\n\nTERM* parsestr(PARSER* p) {\n    TERM* t = mkterm(stringconstant);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parsekeyword(PARSER* p) {\n    TERM* t = mkterm(keywordconstant);\n    if(!existsinarray(&keywordconstants, p->current->token))\n        unexpected(p);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parseunaryopterm(PARSER* p) {\n    TERM* t = mkterm(unaryopterm);\n    t->unaryop = p->current->token[0];\n    next(p);\n    t->expression = parseterm(p);\n    t->expression->next = NULL;\n    return t;\n}\n\nTERM* parseinnerexpression(PARSER* p) {\n    TERM* t = mkterm(innerexpression);\n    next(p);\n    t->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    return t;\n}\n\nTERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}\n\nTERM* parsearrayterm(PARSER* p) {\n    TERM* t = mkterm(arrayitem);\n    t->array = (ARRAY*)malloc(sizeof(ARRAY));\n    t->array->name = p->current->token;\n    next(p);\n    checkcontent(p, \"[\");\n    t->array->exp = parseexpression(p);\n    checkcontent(p, \"]\");\n    return t;\n}\n\nTERM* parsevarterm(PARSER* p) {\n    TERM* t = mkterm(varname);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}\n\nTERM* parseidentifierterm(PARSER* p) {\n    TERM* t = parsecalltermnullified(p);\n    if(t == NULL)\n        if(nextequals(p, \"[\"))\n            return parsearrayterm(p);\n        else\n            return parsevarterm(p);\n    else\n        return t;\n}\n\nTERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}\n\nTERM* parseexpression(PARSER* p) {\n    TERM* t = parseexpressionnullified(p);\n    if(t == NULL)\n        unexpected(p);\n    return t;\n}\n\nSUBROUTCALL* nullsubroutcall(PARSER* p, SUBROUTCALL* c) {\n    free(c->debug);\n    free(c);\n    rewindparser(p);\n    return NULL;\n}\n\nSUBROUTCALL* parsesubroutcallnullified(PARSER* p) {\n    if(p->current->type != identifier)\n        return NULL;\n\n    anchorparser(p);\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n\n    c->debug = getdebug(p);\n\n    if(nextequals(p, \".\")) {\n        c->parentname = p->current->token;\n        next(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n\n    if(p->current->type != identifier)\n        return nullsubroutcall(p, c);\n    c->name = p->current->token;\n    next(p);\n\n    if(differs(p, \"(\"))\n        return nullsubroutcall(p, c);\n    next(p);\n\n    c->parameters = parseexpressionlist(p);\n\n    if(differs(p, \")\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    return c;\n}\n\nSUBROUTCALL* parsesubroutcall(PARSER* p) {\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n\n    if(nextequals(p, \".\")) {\n        c->parentname = parseidentifier(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n\n    c->name = parseidentifier(p);\n\n    checkcontent(p, \"(\");\n\n    c->parameters = parseexpressionlist(p);\n\n    checkcontent(p, \")\");\n    return c;\n}\n\nEXPRESSIONLIST* parseexpressionlist(PARSER* p) {\n    if(!strcmp(p->current->token, \")\"))\n        return NULL;\n    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n    head->expression = parseexpressionnullified(p);\n    EXPRESSIONLIST* current = head;\n    EXPRESSIONLIST* nextls;\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n        nextls->expression = parseexpression(p);\n        current->next = nextls;\n        current = nextls;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-expressions.h\"\n#include \"parser-util.h\"\n#include \"parser-statements.h\"\n\n\n\n\nSTATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t);\n\nSTATEMENT* parsestatementnullified(PARSER* p);\nSTATEMENT* parselet(PARSER* p);\nCONDSTATEMENT* parsecond(PARSER* p);\nSTATEMENT* parseif(PARSER* p);\nSTATEMENT* parsewhile(PARSER* p);\nSTATEMENT* parsedo(PARSER* p);\nSTATEMENT* parsereturn(PARSER* p);\n\n\n\n\nSTATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {\n    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));\n    s->type = t;\n    s->debug = getdebug(p);\n    return s;\n}\n\n\n\n\nSTATEMENT* parsestatementnullified(PARSER* p) {\n    if(equals(p, \"let\")) return parselet(p);\n    if(equals(p, \"if\")) return parseif(p);\n    if(equals(p, \"while\")) return parsewhile(p);\n    if(equals(p, \"do\")) return parsedo(p);\n    if(equals(p, \"return\")) return parsereturn(p);\n    return NULL;\n}\n\nSTATEMENT* parsestatements(PARSER* p) {\n    STATEMENT* head = parsestatementnullified(p);\n    STATEMENT* curr = head;\n    STATEMENT* next;\n    while(next = parsestatementnullified(p), next != NULL) {\n        curr->next = next;\n        curr = next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSTATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n\n    letst->varname = parseidentifier(p);\n    \n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n\n    checkcontent(p, \"=\");\n\n    letst->expression = parseexpression(p);\n\n    checkcontent(p, \";\");\n\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}\n\nCONDSTATEMENT* parsecond(PARSER* p) {\n    checkcontent(p, \"(\");\n\n    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));\n\n    st->expression = parseexpression(p);\n\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n\n    st->statements = parsestatements(p);\n\n    checkcontent(p, \"}\");\n    return st;\n}\n\nSTATEMENT* parseif(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, ifstatement);\n    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));\n\n    ifst->base = parsecond(p);\n\n    if(equals(p, \"else\")) {\n        next(p);\n        checkcontent(p, \"{\");\n        ifst->elsestatements = parsestatements(p);\n        checkcontent(p, \"}\");\n    }\n    else\n        ifst->elsestatements = NULL;\n\n    s->type = ifstatement;\n    s->ifstatement = ifst;\n    return s;\n}\n\nSTATEMENT* parsewhile(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, whilestatement);\n\n    s->whilestatement = parsecond(p);\n    return s;\n}\n\nSTATEMENT* parsedo(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, dostatement);\n\n    s->dostatement = parsesubroutcall(p);\n\n    checkcontent(p, \";\");\n    return s;\n}\n\nSTATEMENT* parsereturn(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, returnstatement);\n\n    s->retstatement = parseexpressionnullified(p);\n\n    checkcontent(p, \";\");\n    return s;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-util.h\"\n#include \"parser-structure.h\"\n#include \"parser-statements.h\"\n\nconst char* classvartypesarr[] = { \"static\", \"field\" };\nconst char* vartypesarr[] = { \"int\", \"char\", \"boolean\" };\nconst char* subroutclassesarr[] = { \"constructor\", \"function\", \"method\" };\nmkstrlist(classvartypes, classvartypesarr);\nmkstrlist(vartypes, vartypesarr);\nmkstrlist(subroutclasses, subroutclassesarr);\n\n\n\n\nbool isprimitive(TOKEN* tk);\nchar* parsetype(PARSER* p);\nint parsepossibilities(PARSER* p, STRINGARRAY* poss);\n\n\nCLASS* parseclass(PARSER* p);\nCLASSVARTYPE parseclassvartype(PARSER* p);\nCLASSVARDEC* parseclassvardec(PARSER* p);\nCLASSVARDEC* parseclassvardecs(PARSER* p);\nSUBROUTCLASS parsesubroutclass(PARSER* p);\nSUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c);\nSUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c);\nPARAMETER* parseparameter(PARSER* p);\nPARAMETER* parseparameters(PARSER* p);\nSUBROUTBODY* parsesubroutbody(PARSER* p);\nvoid parsevardeccommon(PARSER* p, VARDEC* v);\nVARDEC* parsevardec(PARSER* p);\nVARDEC* parsevardecs(PARSER* p);\n\n\n\n\n\nbool isprimitive(TOKEN* tk) {\n    if(tk->type == keyword)\n        if(existsinarray(&vartypes, tk->token))\n            return true;\n    return false;\n}\n\nchar* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n\n    char* result = p->current->token;\n    next(p);\n    return result;\n}\n\nint parsepossibilities(PARSER* p, STRINGARRAY* poss) {\n    for(int i = 0; i < poss->size; i++)\n        if(equals(p, poss->items[i]))\n            return i;\n    return -1;\n}\n\n\nCLASS* parseclass(PARSER* p) {\n    checkcontent(p, \"class\");\n\n    CLASS* class = (CLASS*)malloc(sizeof(CLASS));\n\n    class->debug = getdebug(p);\n\n    class->name = parseidentifier(p);\n\n    checkcontent(p, \"{\");\n\n    class->vardecs = parseclassvardecs(p);\n\n    class->subroutdecs = parsesubroutdecs(p, class);\n\n    checkcontent(p, \"}\");\n\n    if(p->current != NULL)\n        unexpected(p);\n\n    return class;\n}\n\nCLASSVARTYPE parseclassvartype(PARSER* p) {\n    return parsepossibilities(p, &classvartypes);\n}\n\nCLASSVARDEC* parseclassvardec(PARSER* p) {\n    CLASSVARTYPE classvartype = parseclassvartype(p);\n    if(classvartype == -1)\n        return NULL;\n    next(p);\n\n    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));\n    classvardec->type = classvartype;\n\n    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));\n\n    parsevardeccommon(p, classvardec->base);\n\n    return classvardec;\n}\n\nCLASSVARDEC* parseclassvardecs(PARSER* p) {\n    CLASSVARDEC* head = parseclassvardec(p);\n    CLASSVARDEC* curr = head;\n    CLASSVARDEC* nextc;\n    while(nextc = parseclassvardec(p), nextc != NULL) {\n        curr->next = nextc;\n        curr = nextc;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSUBROUTCLASS parsesubroutclass(PARSER* p) {\n    return parsepossibilities(p, &subroutclasses);\n}\n\nSUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {\n    SUBROUTCLASS subroutclass = parsesubroutclass(p);\n    if(subroutclass == -1)\n        return NULL;\n\n    next(p);\n    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    subroutdec->subroutclass = subroutclass;\n\n    if(differs(p, \"void\"))\n        subroutdec->type = parsetype(p);\n    else {\n        subroutdec->type = p->current->token;\n        next(p);\n    }\n\n    subroutdec->debug = getdebug(p);\n\n    subroutdec->name = parseidentifier(p);\n\n    checkcontent(p, \"(\");\n    subroutdec->parameters = parseparameters(p);\n    checkcontent(p, \")\");\n\n    checkcontent(p, \"{\");\n    subroutdec->body = parsesubroutbody(p);\n    checkcontent(p, \"}\");\n\n    subroutdec->class = c;\n\n    return subroutdec;\n}\n\nSUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {\n    SUBROUTDEC* head = parsesubroutdec(p, c);\n    SUBROUTDEC* curr = head;\n    SUBROUTDEC* nexts;\n    while(nexts = parsesubroutdec(p, c), nexts != NULL) {\n        curr->next = nexts;\n        curr = nexts;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nPARAMETER* parseparameter(PARSER* p) {\n    if(equals(p, \")\"))\n        return NULL;\n    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));\n    param->debug = getdebug(p);\n    param->primitive = isprimitive(p->current);\n    param->type = parsetype(p);\n    param->name = parseidentifier(p);\n    return param;\n}\n\nPARAMETER* parseparameters(PARSER* p) {\n    PARAMETER* head = parseparameter(p);\n    PARAMETER* curr = head;\n    PARAMETER* nextp;\n    while(equals(p, \",\")) {\n        next(p);\n        nextp = parseparameter(p);\n        if(nextp == NULL)\n            unexpected(p);\n        curr->next = nextp;\n        curr = curr->next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n\nSUBROUTBODY* parsesubroutbody(PARSER* p) {\n    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));\n    subroutbody->vardecs = parsevardecs(p);\n    subroutbody->statements = parsestatements(p);\n\n    return subroutbody;\n}\n\nvoid parsevardeccommon(PARSER* p, VARDEC* v) {\n    v->typeclass = p->current->type;\n    v->primitive = isprimitive(p->current);\n    v->type = parsetype(p);\n\n    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    v->names = currstr;\n\n    v->debug = getdebug(p);\n\n    v->names->content = parseidentifier(p);\n\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        nextstr->content = parseidentifier(p);\n        currstr->next = nextstr;\n        currstr = nextstr;\n    }\n    currstr->next = NULL;\n\n    checkcontent(p, \";\");\n}\n\n\nVARDEC* parsevardec(PARSER* p) {\n    if(strcmp(p->current->token, \"var\"))\n        return NULL;\n    next(p);\n\n    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));\n\n    parsevardeccommon(p, vardec);\n\n    return vardec;\n}\n\nVARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-tree.h\"\n\nvoid freeexpression(TERM* e);\nvoid freeexpressionlist(EXPRESSIONLIST* el);\nvoid freestatements(STATEMENT* s);\n\nvoid freevardec(VARDEC* v) {\n    freestrlist(v->names);\n    free(v->debug);\n    free(v);\n}\n\nvoid freevardecs(VARDEC* v) {\n    VARDEC* next = v->next;\n    freevardec(v);\n    if(next != NULL)\n        freevardecs(next);\n}\n\nvoid freeparameters(PARAMETER* p) {\n    free(p->debug);\n    PARAMETER* next = p->next;\n    free(p);\n    if(next != NULL)\n        freeparameters(next);\n}\n\nvoid freearray(ARRAY* a) {\n    freeexpression(a->exp);\n    free(a);\n}\n\nvoid freesubroutcall(SUBROUTCALL* call) {\n    if(call->parameters != NULL)\n        freeexpressionlist(call->parameters);\n    free(call->debug);\n    free(call);\n}\n\nvoid freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}\n\nvoid freeexpressionlist(EXPRESSIONLIST* el) {\n    freeexpression(el->expression);\n    EXPRESSIONLIST* next = el->next;\n    free(el);\n    if(next != NULL)\n        freeexpressionlist(next);\n}\n\nvoid freelet(LETSTATEMENT* l) {\n    if(l->arrayind != NULL)\n        freeexpression(l->arrayind);\n    freeexpression(l->expression);\n    free(l);\n}\n\nvoid freecond(CONDSTATEMENT* cond) {\n    freeexpression(cond->expression);\n    if(cond->statements != NULL)\n        freestatements(cond->statements);\n    free(cond);\n}\n\nvoid freeif(IFSTATEMENT* st) {\n    freecond(st->base);\n    if(st->elsestatements != NULL)\n        freestatements(st->elsestatements);\n    free(st);\n}\n\nvoid freestatements(STATEMENT* s) {\n    if(s->type == letstatement)\n        freelet(s->letstatement);\n    else if(s->type == ifstatement)\n        freeif(s->ifstatement);\n    else if(s->type == whilestatement)\n        freecond(s->whilestatement);\n    else if(s->type == dostatement)\n        freesubroutcall(s->dostatement);\n    else if(s->retstatement != NULL)\n        freeexpression(s->retstatement);\n\n    free(s->debug);\n    STATEMENT* next = s->next;\n    free(s);\n    if(next != NULL)\n        freestatements(next);\n}\n\nvoid freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}\n\nvoid freesubroutdecs(SUBROUTDEC* sr) {\n    free(sr->debug);\n    if(sr->parameters != NULL)\n        freeparameters(sr->parameters);\n    freesubroutbody(sr->body);\n    SUBROUTDEC* next = sr->next;\n    free(sr);\n    if(next != NULL)\n        freesubroutdecs(next);\n}\n\nvoid freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}\n\nvoid freetree(CLASS* c) {\n    free(c->debug);\n\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"parser-util.h\"\n#include \"util.h\"\n\nconst char* tokentypesarr[] = { \"keyword\", \"identifier\", \"symbol\",\n                    \"integerConstant\", \"stringConstant\" };\nmkstrlist(tokentypes, tokentypesarr);\n\nvoid unexpected(PARSER* p) {\n    eprintf(\"Unexpected token '%s' (of type %s); line %i, file '%s'\\n\",\n                p->current->token, tokentypes.items[p->current->type],\n                p->current->definedat, p->file);\n    exit(1);\n}\n\nvoid checktype(PARSER* p, TOKENTYPE type) {\n    if(p->current->type != type) {\n        eprintf(\"Unexpected %s; file '%s', line %i\\n\", \n                tokentypes.items[p->current->type], p->file,\n                    p->current->definedat);\n        exit(1);\n    }\n}\n\nvoid checkcontent(PARSER* p, const char* content) {\n    if(differs(p, content))\n        unexpected(p);\n    next(p);\n}\n\nchar* parseidentifier(PARSER* p) {\n    checktype(p, identifier);\n    char* result = p->current->token;\n    next(p);\n    return result;\n}\n\nDEBUGINFO* getdebug(PARSER* p) {\n    DEBUGINFO* d = (DEBUGINFO*)malloc(sizeof(DEBUGINFO));\n    d->file = p->file;\n    d->definedat = p->current->definedat;\n    return d;\n}\n"}
{"target":"augustogunsch","func":"#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"threads.h\"\n\nvoid* parseunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n\n    unit->parsed = parse(unit->parser);\n\n    pthread_exit(NULL);\n}\n\nvoid* compileunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n\n    unit->compiled = compileclass(unit->compiler, unit->parsed);\n\n    pthread_exit(NULL);\n}\n\nchar* getclassname(char* filename) {\n    int len = strlen(filename) - 1;\n\n    for(len = len; len >= 0; len--)\n        if(filename[len] == '.')\n            break;\n\n    int sz = sizeof(char) * (len + 1);\n    char* classname = (char*)malloc(sz);\n    snprintf(classname, sz, \"%s\", filename); \n    return classname;\n}\n\nvoid* vmtranslateunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n\n    if(unit->compiled == NULL) {\n        eprintf(\"Class '%s' is empty; file '%s'\\n\", unit->parsed->name, unit->file->name);\n        exit(1);\n    }\n\n    char* classname = getclassname(unit->file->name);\n    unit->vmtranslator = mkvmtranslator(classname, unit->compiled);\n    unit->asmlns = translatevm(unit->vmtranslator);\n    free(classname);\n\n    pthread_exit(NULL);\n}\n\nvoid waitthreads(pthread_t* threads, int amount) {\n    void* status;\n    int code;\n    for(int i = 0; i < amount; i++) {\n        code = pthread_join(threads[i], &status);\n        if(code) {\n            eprintf(\"Error while joining thread %i: %s\\n\", i, strerror(code));\n            exit(code);\n        }\n    }\n}\n\nvoid actonunits(COMPILEUNIT* units, void*(*fun)(void*)) {\n    pthread_t mythreads[_SC_THREAD_THREADS_MAX];\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    COMPILEUNIT* curr = units;\n\n    int i;\n    int code;\n    do {\n        i = 0;\n        while(curr != NULL && i < _SC_THREAD_THREADS_MAX) {\n            code = pthread_create(&mythreads[i], &attr, fun, curr);\n\n            if(code) {\n                eprintf(\"Error while creating thread %i: %s\\n\", i, strerror(code));\n                exit(code);\n            }\n\n            curr = curr->next;\n            i++;\n        }\n        waitthreads(mythreads, i);\n    } while(i == _SC_THREAD_THREADS_MAX);\n\n    pthread_attr_destroy(&attr);\n}\n\nvoid freeunit(COMPILEUNIT* u) {\n    freeparser(u->parser);\n    freelnblk(u->compiled);\n    freevmtranslator(u->vmtranslator);\n    free(u);\n}\n"}
{"target":"augustogunsch","func":"#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"tokenizer.h\"\n#include \"tokenizer-tables.h\"\n\n\ntypedef enum {\n    common, charsymbol, space\n} CHARTYPE;\n\ntypedef struct {\n    char* str;\n    int size;\n    int count;\n} STRING;\n\n\nSTRING* mkstring(int size);\nvoid append(STRING* s, char c);\nvoid freestr(STRING* str);\n\n\nTOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type);\nTOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat);\n#define mktoken() (TOKEN*)malloc(sizeof(TOKEN))\n\n\nCHARTYPE getchartype(unsigned char c);\nbool iskeyword(STRING* tk);\nbool issymbol(STRING* tk);\nbool isint(char* str);\nbool isintcons(STRING* tk);\nbool isidentifier(STRING* tk);\nTOKENTYPE gettokentype(STRING* tk, char* file, int definedat);\n\n\nvoid skipln(FILE* input);\nvoid skipmultiln(FILE* input, int* lnscount);\nbool handlecomment(FILE* input, int* lnscount);\nvoid readstr(FILE* input, STRING* tmp, int definedat);\n\n\nSTRING* mkstring(int size) {\n    STRING* str = (STRING*)malloc(sizeof(STRING));\n    str->size = sizeof(char) * size; \n    str->str = (char*)malloc(str->size);\n    str->count = 0;\n    return str;\n}\n\nvoid append(STRING* s, char c) {\n    int targsize = sizeof(char) * (s->count + 1);\n    if(s->size <= targsize) {\n        s->size = targsize * 2;\n        s->str = (char*)realloc(s->str, s->size);\n    }\n\n    s->str[s->count] = c;\n    s->count++;\n}\n\nvoid freestr(STRING* str) {\n    free(str->str);\n    free(str);\n}\n\n\nTOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {\n    curitem->token = (char*)malloc(sizeof(char)*token->count);\n    strcpy(curitem->token, token->str);\n    curitem->definedat = definedat;\n    curitem->type = type;\n    TOKEN* nextitem = mktoken();\n    curitem->next = nextitem;\n    token->count = 0;\n    return nextitem;\n}\n\nvoid freetokens(TOKEN* t) {\n    free(t->token);\n    TOKEN* next = t->next;\n    free(t);\n    if(next != NULL)\n        freetokens(next);\n}\n\nTOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {\n    append(token, '\\0');\n    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));\n}\n\n\nCHARTYPE getchartype(unsigned char c) {\n    if(isspace(c)) return space;\n    if(isalnum(c) || c == '_' || c == '\"') return common;\n    return charsymbol;\n}\n\nbool iskeyword(STRING* tk) {\n    return existsinarray(&keywords, tk->str);\n}\n\nbool issymbol(STRING* tk) {\n    if(tk->count != 2)\n        return false;\n    return existsinarray(&symbols, tk->str);\n}\n\nbool isint(char* str) {\n    int i = 0;\n    while(str[i] != '\\0') {\n        if(!isdigit(str[i]))\n            return false;\n        i++;\n    }\n    return true;\n}\n\nbool isintcons(STRING* tk) {\n    if(!isint(tk->str))\n        return false;\n    int val = atoi(tk->str);\n    return val <= 65535;\n}\n\nbool isidentifier(STRING* tk) {\n    if(isdigit(tk->str[0]))\n        return false;\n\n    int count = tk->count - 1;\n    for(int i = 0; i < count; i++)\n        if(!isalnum(tk->str[i]) && tk->str[i] != '_')\n            return false;\n    return true;\n}\n\nTOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {\n    if(iskeyword(tk)) return keyword;\n    if(issymbol(tk)) return symbol;\n    if(isintcons(tk)) return integer;\n    if(isidentifier(tk)) return identifier;\n    eprintf(\"Unexpected token '%s'; file '%s', line %i\\n\", tk->str, file, definedat);\n    exit(1);\n}\n\n\nvoid skipln(FILE* input) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            break;\n}\n\nvoid skipmultiln(FILE* input, int* lnscount) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            (*lnscount)++;\n        else if(c == '*')\n            if(fgetc(input) == '\/')\n                break;\n}\n\nbool handlecomment(FILE* input, int* lnscount) {\n    unsigned char nextc = fgetc(input);\n    if(nextc == '\/') {\n        skipln(input);\n        (*lnscount)++;\n        return true;\n    }\n    else if(nextc == '*') {\n        unsigned char furtherc = fgetc(input);\n        if(furtherc == '*') {\n            skipmultiln(input, lnscount);\n            return true;\n        }\n        ungetc(furtherc, input);\n    }\n    ungetc(nextc, input);\n    return false;\n}\n\nvoid readstr(FILE* input, STRING* tmp, int definedat) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0') {\n        if(c == '\\n') {\n            eprintf(\"Unexpected end of line; line %i\", definedat);\n            exit(1);\n        }\n        if(c == '\"')\n            break;\n        append(tmp, c);\n    }\n    append(tmp, '\\0');\n}\n\nTOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    \n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '\/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n\n        curtype = getchartype(c);\n\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}\n"}
{"target":"augustogunsch","func":"#include <string.h>\n#include <stdlib.h>\n#include \"util.h\"\n\nchar* heapstr(const char* str, int len) {\n    int size = sizeof(char) * (len + 1);\n    char* outstr = (char*)malloc(size);\n    strcpy(outstr, str);\n    return outstr;\n}\n\nchar* ezheapstr(const char* str) {\n    return heapstr(str, strlen(str));\n}\n\nvoid* copy(void* v, int size) {\n    void* copy = malloc(size);\n    memcpy(copy, v, size);\n    return copy;\n}\n\nint countplaces(int n) {\n    int places = 1;\n    int divisor = 1;\n    if(n < 0) {\n        n = -n;\n        places++;\n    }\n    while(n \/ divisor >= 10) {\n        places++;\n        divisor *= 10;\n    }\n    return places;\n}\n\nchar* itoa(int i) {\n    int size = sizeof(char)*(countplaces(i)+1);\n    char* a = (char*)malloc(size);\n    sprintf(a, \"%i\", i);\n    return a;\n}\n\nchar* dotlabel(char* n1, char* n2) {\n    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s.%s\", n1, n2);\n    return result;\n}\n\nSTRINGLIST* onestr(const char* str) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    strlist->content = ezheapstr(str);\n    strlist->next = NULL;\n    return strlist;\n}\n\nSTRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}\n\nvoid printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}\n\nvoid freestrlist(STRINGLIST* strlist) {\n    STRINGLIST* next = strlist->next;\n    free(strlist);\n    if(next != NULL)\n        freestrlist(next);\n}\n\nbool existsinarray(STRINGARRAY* arr, const char* item) {\n    for(int i = 0; i < arr->size; i++)\n        if(!strcmp(arr->items[i], item))\n            return true;\n    return false;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include \"vm-lines.h\"\n\nLINE* mkline(int size) {\n    LINE* ln = (LINE*)malloc(sizeof(LINE));\n    ln->tokens = (char**)malloc(sizeof(char*)*size);\n    ln->count = 0;\n    return ln;\n}\n\nvoid addtoken(LINE* ln, char* token) {\n    ln->tokens[ln->count] = token;\n    ln->count++;\n}\n\nvoid println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}\n\nvoid printlns(LINE* lns, FILE* stream) {\n    while(lns != NULL) {\n        println(lns, stream);\n        lns = lns->next;\n    }\n}\n\nvoid freeln(LINE* ln) {\n    for(int i = 0; i < ln->count; i++)\n        free(ln->tokens[i]);\n    free(ln->tokens);\n    free(ln);\n}\n\nvoid freelns(LINE* lns) {\n    LINE* next = lns->next;\n    freeln(lns);\n    if(next != NULL)\n        freelns(next);\n}\n\nvoid freelnblk(LINEBLOCK* blk) {\n    freelns(blk->head);\n    free(blk);\n}\n\nLINEBLOCK* mklnblk(LINE* start) {\n    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));\n    blk->head = start;\n    blk->tail = start;\n    return blk;\n}\n\nLINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {\n    if(head == NULL)\n        return tail;\n    head->tail->next = tail->head;\n    head->tail = tail->tail;\n    free(tail);\n    return head;\n}\n\nvoid appendln(LINEBLOCK* lnblk, LINE* ln) {\n    lnblk->tail->next = ln;\n    lnblk->tail = ln;\n}\n\nvoid appendlnbefore(LINEBLOCK* lnblk, LINE* ln) {\n    ln->next = lnblk->head;\n    lnblk->head = ln;\n}\n"}
{"target":"augustogunsch","func":"#include <stdlib.h>\n#include <string.h>\n#include \"vm-templates.h\"\n#include \"vm-translator.h\"\n#include \"util.h\"\n#define eq(translator, index, str) !strcmp(translator->currln->tokens[index], str)\n\nSTRINGLIST* asmln(char* content) {\n    STRINGLIST* ln = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    ln->content = content;\n    return ln;\n}\n\nvoid togarbage(VMTRANSLATOR* t, char* str) {\n    STRINGLIST* garb = asmln(str);\n    garb->next = t->garbage;\n    t->garbage = garb;\n}\n\nchar* atraw(VMTRANSLATOR* t, char* n, int len) {\n    int sz = sizeof(char) * (len + 2);\n    char* atstr = (char*)malloc(sz);\n    sprintf(atstr, \"@%s\", n);\n    togarbage(t, atstr);\n    return atstr;\n}\n\nchar* at(VMTRANSLATOR* t, char* n) {\n    return atraw(t, n, strlen(n));\n}\n\nchar* atn(VMTRANSLATOR* t, int n) {\n    char* str = itoa(n);\n    togarbage(t, str);\n    return at(t, str);\n}\n\nchar* mkstr(VMTRANSLATOR* t, char* str) {\n    char* heapstr = ezheapstr(str);\n    togarbage(t, heapstr);\n    return heapstr;\n}\n\nchar* mkpointerind(VMTRANSLATOR* t) {\n    if(t->currln->tokens[2][0] == 0)\n        return mkstr(t, \"@THIS\");\n    else\n        return mkstr(t, \"@THAT\");\n}\n\nchar* mktempind(VMTRANSLATOR* t) {\n    int index = atoi(t->currln->tokens[2]);\n    char* actualind = itoa(index+5);    \n    togarbage(t, actualind);\n    return at(t, actualind);\n}\n\nchar* dotat(VMTRANSLATOR* t, char* name, char* n) {\n    int sz = sizeof(char) * (strlen(name) + strlen(n) + 3);\n    char* atstr = (char*)malloc(sz);\n    sprintf(atstr, \"@%s.%s\", name, n);\n    togarbage(t, atstr);\n    return atstr;\n}\n\nchar* switchsegment(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"local\"))\n        return mkstr(t, \"@LCL\");\n    if(eq(t, 1, \"argument\"))\n        return mkstr(t, \"@ARG\");\n    if(eq(t, 1, \"this\"))\n        return mkstr(t, \"@THIS\");\n    return mkstr(t, \"@THAT\");\n}\n\nchar* mkspeciallab(VMTRANSLATOR* t, char* suffix, int* ind, int* len) {\n    (*ind)++;\n    *len = t->classnamelen + countplaces(*ind) + strlen(suffix) + 2;\n    int sz = ((*len)+1) * sizeof(char);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"%s$%s.%i\", t->classname, suffix, (*ind));\n    togarbage(t, lab);\n    return lab;\n}\n\nchar* mkcmplab(VMTRANSLATOR* t, int* len) {\n    return mkspeciallab(t, \"cmp\", &(t->cmpind), len);\n}\n\nchar* mkretlab(VMTRANSLATOR* t, int* len) {\n    return mkspeciallab(t, \"ret\", &(t->retind), len);\n}\n\nchar* enclosingparenthesis(VMTRANSLATOR* t, char* content, int len) {\n    int sz = sizeof(char) * (len + 3);\n    char* str = (char*)malloc(sz);\n    sprintf(str, \"(%s)\", content);\n    togarbage(t, str);\n    return str;\n}\n\nchar* mklab(VMTRANSLATOR* t) {\n    int sz = (t->classnamelen + strlen(t->currln->tokens[1]) + 4) * sizeof(char);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"(%s$%s)\", t->classname, t->currln->tokens[1]);\n    togarbage(t, lab);\n    return lab;\n}\n\nchar* mkgotolab(VMTRANSLATOR* t) {\n    int sz = sizeof(char) * (t->classnamelen + strlen(t->currln->tokens[1]) + 3);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"@%s$%s\", t->classname, t->currln->tokens[1]);\n    togarbage(t, lab);\n    return lab;\n}\n\nASMBLK* copytemplate(TEMPLATE* t) {\n    ASMBLK* blk = (ASMBLK*)malloc(sizeof(ASMBLK));\n    blk->head = asmln(t->items[0]);\n    STRINGLIST* curr = blk->head;\n    for(int i = 1; i < t->count; i++) {\n        STRINGLIST* newln = asmln(t->items[i]);\n        curr->next = newln;\n        curr = newln;\n    }\n    curr->next = NULL;\n    blk->tail = curr;\n    return blk;\n}\n\nvoid mergeasmblks(ASMBLK* a, ASMBLK* b) {\n    a->tail->next = b->head;\n    a->tail = b->tail;\n    free(b);\n}\n\n\n\n\n\nASMBLK* translatepushconst(VMTRANSLATOR* t) {\n    \n    tpushcons.items[0] = at(t, t->currln->tokens[2]);\n\n    return copytemplate(&tpushcons);\n}\n\nASMBLK* translatepushstatic(VMTRANSLATOR* t) {\n    \n    tpushstat.items[0] = dotat(t, t->classname, t->currln->tokens[2]);\n\n    return copytemplate(&tpushstat);\n}\n\nASMBLK* translatepushpointer(VMTRANSLATOR* t) {\n    \n    tpushpointer.items[0] = mkpointerind(t);\n\n    return copytemplate(&tpushpointer);\n}\n\nASMBLK* translatepushtemp(VMTRANSLATOR* t) {\n    \n    tpushtemp.items[0] = mktempind(t);\n\n    return copytemplate(&tpushtemp);\n}\n\nvoid pushpopcommon(VMTRANSLATOR* t, TEMPLATE* tp) {\n    \n    tp->items[0] = switchsegment(t);\n    \n    \n    tp->items[1] = mkstr(t, \"D=M\");\n\n    \n    tp->items[2] = at(t, t->currln->tokens[2]);\n}\n\nASMBLK* translatepushgeneric(VMTRANSLATOR* t) {\n    pushpopcommon(t, &tpush);\n\n    return copytemplate(&tpush);\n}\n\nASMBLK* translatepush(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"constant\"))\n        return translatepushconst(t);\n    if(eq(t, 1, \"static\"))\n        return translatepushstatic(t);\n    if(eq(t, 1, \"pointer\"))\n        return translatepushpointer(t);\n    if(eq(t, 1, \"temp\"))\n        return translatepushtemp(t);\n    return translatepushgeneric(t);\n}\n\nASMBLK* translatepopstatic(VMTRANSLATOR* t) {\n    \n    tpopstat.items[tpopstat.count-2] = dotat(t, t->classname, t->currln->tokens[2]);\n\n    \n    tpopstat.items[tpopstat.count-1] = mkstr(t, \"M=D\");\n\n    return copytemplate(&tpopstat);\n}\n\nASMBLK* translatepoppointer(VMTRANSLATOR* t) {\n    \n    tpoppointer.items[tpoppointer.count-2] = mkpointerind(t);\n\n    \n    tpoppointer.items[tpoppointer.count-1] = mkstr(t, \"M=D\");\n\n    return copytemplate(&tpoppointer);\n}\n\nASMBLK* translatepoptemp(VMTRANSLATOR* t) {\n    \n    tpoptemp.items[tpoptemp.count-2] = mktempind(t);\n\n    tpoptemp.items[tpoptemp.count-1] = mkstr(t, \"M=D\");\n\n    return copytemplate(&tpoptemp);\n}\n\nASMBLK* translatepopgeneric(VMTRANSLATOR* t) {\n    pushpopcommon(t, &tpop);\n    \n    return copytemplate(&tpop);\n}\n\nASMBLK* translatepop(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"static\"))\n        return translatepopstatic(t);\n    if(eq(t, 1, \"pointer\"))\n        return translatepoppointer(t);\n    if(eq(t, 1, \"temp\"))\n        return translatepoptemp(t);\n    return translatepopgeneric(t);\n}\n\n\n\n\n\n\nASMBLK* translatearith(VMTRANSLATOR* t, char* op) {\n    tarith.items[tarith.count-1] = mkstr(t, op);\n\n    return copytemplate(&tarith);\n}\n\nASMBLK* translatecomp(VMTRANSLATOR* t, char* op) {\n    int labellen;\n    char* label = mkcmplab(t, &labellen);\n\n    \n    tcomp.items[tcomp.count-6] = atraw(t, label, labellen);\n    \n    \n    int sz = sizeof(char) * 6;\n    char* trueop = (char*)malloc(sz);\n    sprintf(trueop, \"D;J%s\", op);\n    tcomp.items[tcomp.count-5] = trueop;\n    togarbage(t, trueop);\n\n    \n    tcomp.items[tcomp.count-1] = enclosingparenthesis(t, label, labellen);\n\n    return copytemplate(&tcomp);\n}\n\n\n\nASMBLK* translatelabel(VMTRANSLATOR* t) {\n    \n    tlabel.items[tlabel.count-1] = mklab(t);\n\n    return copytemplate(&tlabel);\n}\n\nASMBLK* translategoto(VMTRANSLATOR* t) {\n    \n    tgoto.items[tgoto.count-2] = mkgotolab(t);\n\n    return copytemplate(&tgoto);\n}\n\nASMBLK* translateifgoto(VMTRANSLATOR* t) {\n    \n    tifgoto.items[tifgoto.count-2] = mkgotolab(t);\n\n    return copytemplate(&tifgoto);\n}\n\nASMBLK* translatereturn(VMTRANSLATOR* t) {\n    ASMBLK* blk = copytemplate(&tstartreturn);\n    \n    for(int i = tframevars.count-1; i >= 0; i--) {\n        tretpop.items[tretpop.count-2] = tframevars.items[i];\n        mergeasmblks(blk, copytemplate(&tretpop));\n    }\n\n    mergeasmblks(blk, copytemplate(&tendreturn));\n    return blk;\n}\n\nASMBLK* translatefunction(VMTRANSLATOR* t) {\n    t->retind = 0;\n    t->cmpind = 0;\n\n    \n    tfunction.items[0] = mklab(t);\n    ASMBLK* blk = copytemplate(&tfunction);\n\n    \n    int nlocals = atoi(t->currln->tokens[2]);\n\n    for(int i = 0; i < nlocals; i++)\n        mergeasmblks(blk, copytemplate(&tfunctionpush));\n\n    return blk;\n}\n\nASMBLK* pushframe(VMTRANSLATOR* t, char* retlab, int retlablen, int* framesize) {\n    tcallstart.items[1] = atraw(t, retlab, retlablen);\n\n    ASMBLK* blk = copytemplate(&tcallstart);\n\n    for(int i = 0; i < tframevars.count; i++) {\n        tcallpush.items[0] = tframevars.items[i];\n        mergeasmblks(blk, copytemplate((&tcallpush)));\n    }\n\n    *framesize = tframevars.count + 1;\n    return blk;\n}\n\nASMBLK* translatecall(VMTRANSLATOR* t) {\n    \n    int retlablen;\n    char* retlab = mkretlab(t, &retlablen);\n\n    \n    int framesize;\n    ASMBLK* blk = pushframe(t, retlab, retlablen, &framesize);\n\n    \n    int nargs = atoi(t->currln->tokens[2]);\n    tcallsetarg.items[tcallsetarg.count-4] = atn(t, nargs + framesize);\n    mergeasmblks(blk, copytemplate(&tcallsetarg));\n    \n    \n    tcalljmp.items[tcalljmp.count-3] = at(t, t->currln->tokens[1]);\n    tcalljmp.items[tcalljmp.count-1] = enclosingparenthesis(t, retlab, retlablen);\n    mergeasmblks(blk, copytemplate(&tcalljmp));\n\n    return blk;\n}\n\nASMBLK* translateln(VMTRANSLATOR* t) {\n    if(eq(t, 0, \"push\"))\n        return translatepush(t);\n    if(eq(t, 0, \"pop\"))\n        return translatepop(t);\n\n    if(eq(t, 0, \"add\"))\n        return translatearith(t, \"M=D+M\");\n    if(eq(t, 0, \"sub\"))\n        return translatearith(t, \"M=M-D\");\n    if(eq(t, 0, \"and\"))\n        return translatearith(t, \"M=D&M\");\n    if(eq(t, 0, \"or\"))\n        return translatearith(t, \"M=D|M\");\n\n    if(eq(t, 0, \"neg\"))\n        return copytemplate(&tneg);\n    if(eq(t, 0, \"not\"))\n        return copytemplate(&tnot);\n\n    if(eq(t, 0, \"eq\"))\n        return translatecomp(t, \"EQ\");\n    if(eq(t, 0, \"gt\"))\n        return translatecomp(t, \"LT\");\n    if(eq(t, 0, \"lt\"))\n        return translatecomp(t, \"GT\");\n\n    if(eq(t, 0, \"label\"))\n        return translatelabel(t);\n    if(eq(t, 0, \"goto\"))\n        return translategoto(t);\n    if(eq(t, 0, \"if-goto\"))\n        return translateifgoto(t);\n\n    if(eq(t, 0, \"return\"))\n        return translatereturn(t);\n    if(eq(t, 0, \"function\"))\n        return translatefunction(t);\n    return translatecall(t);\n}\n\nASMBLK* translatevm(VMTRANSLATOR* t) {\n    ASMBLK* blk = copytemplate(&tbootstrap);\n    while(t->currln != NULL) {\n        mergeasmblks(blk, translateln(t));\n        t->currln = t->currln->next;\n    }\n    return blk;\n}\n\nVMTRANSLATOR* mkvmtranslator(char* classname, LINEBLOCK* vmlines) {\n    VMTRANSLATOR* transl = (VMTRANSLATOR*)malloc(sizeof(VMTRANSLATOR));\n    transl->currln = vmlines->head;\n    transl->start = vmlines->head;\n    transl->garbage = NULL;\n    transl->retind = 0;\n    transl->cmpind = 0;\n    transl->classname = classname;\n    transl->classnamelen = strlen(classname);\n    return transl;\n}\n\nvoid freegarbage(STRINGLIST* garbage) {\n    if(garbage != NULL) {\n        free(garbage->content);\n        STRINGLIST* next = garbage->next;\n        free(garbage);\n        freegarbage(next);\n    }\n}\n\nvoid freevmtranslator(VMTRANSLATOR* t) {\n    freegarbage(t->garbage);\n    free(t);\n}\n"}
{"target":"behergue","func":"\n\n\n#include \"44b.h\"\n#include \"intcontroller.h\"\n\nvoid ic_init(void)\n{\n    \n    rINTMOD = 0x0; \n    rINTCON = 0x7; \n    rINTMSK = ~(0x0); \n}\n\nint ic_conf_irq(enum enable st, enum int_vec vec)\n{\n    int conf = rINTCON;\n\n    if (st != ENABLE && st != DISABLE)\n        return -1;\n\n    if (vec == VEC)\n    {\n        \n        \n        unsigned int b = 1;\n        b <<= 2;\n\n        conf &= ~b;\n    }\n    else\n    {\n        \n        \n        unsigned int b = 1;\n        b <<= 2;\n\n        conf |= b;\n    }\n\n    if (st == ENABLE)\n    {\n        \n        \n        unsigned int b = 1;\n        b <<= 1;\n\n        conf &= ~b;\n    }\n    else\n    {\n        \n        \n        unsigned int b = 1;\n        b <<= 1;\n\n        conf |= b;\n    }\n\n    rINTCON = conf;\n    return 0;\n}\n\nint ic_conf_fiq(enum enable st)\n{\n    int ret = 0;\n\n    if (st == ENABLE)\n    {\n        \n        \n        unsigned int b = 1;\n\n        ret &= ~b;\n    }\n    else if (st == DISABLE)\n    {\n        \n        \n        unsigned int b = 1;\n\n        ret |= b;\n    }\n    else\n    {\n        ret = -1;\n    }\n\n    return ret;\n}\n\nint ic_conf_line(enum int_line line, enum int_mode mode)\n{\n    unsigned int bit = INT_BIT(line);\n\n    if (line < 0 || line > 26)\n        return -1;\n\n    if (mode != IRQ && mode != FIQ)\n        return -1;\n\n    if (mode == IRQ)\n    {\n        \n        unsigned int b = 1;\n        b <<= bit;\n        \n        rINTMOD &= ~b;\n    }\n    else\n    {\n        \n        unsigned int b = 1;\n        b <<= bit;\n        \n        rINTMOD |= b;\n    }\n\n    return 0;\n}\n\nint ic_enable(enum int_line line)\n{\n    if (line < 0 || line > 26)\n        return -1;\n\n    \n    unsigned int b = 1;\n    b <<= (int) line;\n    \n    rINTMSK &= ~b;\n\n    return 0;\n}\n\nint ic_disable(enum int_line line)\n{\n    if (line < 0 || line > 26)\n        return -1;\n\n    \n    unsigned int b = 1;\n    b <<= (int) line;\n    \n    rINTMSK |= b;\n    \n    return 0;\n}\n\nint ic_cleanflag(enum int_line line)\n{\n    int bit;\n\n    if (line < 0 || line > 26)\n        return -1;\n\n    bit = INT_BIT(line);\n\n    if (rINTMOD & bit)\n    {\n        \n        \n        \n        unsigned int b = 1;\n        b <<= bit;\n\n        rI_ISPC |= b;\n    }\n    else\n    {\n        \n        \n        unsigned int b = 1;\n        b <<= bit;\n\n        rF_ISPC |= b;\n    }\n\n    return 0;\n}\n\n\n\n"}
{"target":"behergue","func":"\n\n\n#include \"44b.h\"\n#include \"intcontroller.h\"\n\nvoid ic_init(void)\n{\n    \n    rINTMOD = 0x0; \n    rINTCON = 0x7; \n    rINTMSK = ~(0x0); \n}\n\nint ic_conf_irq(enum enable st, enum int_vec vec)\n{\n    int conf = rINTCON;\n\n    if (st != ENABLE && st != DISABLE)\n        return -1;\n\n    if (vec == VEC)\n        \n        conf &= ~(1 <<2);\n\n    else\n        conf |= (1 << 2);\n        \n\n    if (st == ENABLE)\n        conf &= ~(1 << 1);\n        \n    else\n        conf |= (1 << 1);\n        \n\n    rINTCON = conf;\n    return 0;\n}\n\nint ic_conf_fiq(enum enable st)\n{\n    int ret = 0;\n\n    if (st == ENABLE)\n        rINTCON &= ~1;\n        \n    else if (st == DISABLE)\n        rINTCON |= 1;\n        \n    else\n        ret = -1;\n\n    return ret;\n}\n\nint ic_conf_line(enum int_line line, enum int_mode mode)\n{\n    unsigned int bit = INT_BIT(line);\n\n    if (line < 0 || line > 26)\n        return -1;\n\n    if (mode != IRQ && mode != FIQ)\n        return -1;\n\n    if (mode == IRQ)\n        \n        rINTMOD &= ~bit;\n\n    else\n        \n        rINTMOD |= bit;\n    return 0;\n}\n\nint ic_enable(enum int_line line)\n{\n    if (line < 0 || line > 26)\n        return -1;\n    rINTMSK &= ~(1 << line);\n    \n\n    return 0;\n}\n\nint ic_disable(enum int_line line)\n{\n    if (line < 0 || line > 26)\n        return -1;\n\n    rINTMSK |= (1 << line);\n    \n    \n    return 0;\n}\n\nint ic_cleanflag(enum int_line line)\n{\n    int bit;\n\n    if (line < 0 || line > 26)\n        return -1;\n\n    bit = INT_BIT(line);\n\n    if (rINTMOD & bit)\n        \n        \n        rF_ISPC |= bit;\n    else\n        rI_ISPC |= bit;\n        \n        \n    return 0;\n}\n\n\n\n"}
{"target":"behergue","func":"\n\n\n#include \"44b.h\"\n#include \"keyboard.h\"\n\n\n#define KEY_VALUE_MASK  0x0f\n\n\nvolatile static unsigned char *keyboard_base = (unsigned char *)0x06000000;\n\n\nint kb_scan(void)\n{\n    int value = -1;\n    int i;\n    char temp;\n    int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};\n    int map[4][4] = {{0, 1, 2, 3},\n                    {4, 5, 6, 7},\n                    {8, 9, 0xA, 0xB},\n                    {0xC, 0xD, 0xE, 0xF}};\n\n    for (i = 0; (i < 4) && (value == -1); i++) {\n        temp = *(keyboard_base+lines[i]);\n\n        if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {\n            \n            \n            \n            \n            \n        }\n    }\n\n    return value;\n}\n"}
{"target":"behergue","func":"\n\n#include \"44b.h\"\n#include \"leds.h\"\n#include \"gpio.h\"\n\n\n#define LED1 0x01\n#define LED2 0x02\n#define BIT_LED1 9\n#define BIT_LED2 10\n\n\n\n\n\nstatic unsigned int status = 0;\n\nvoid leds_init( void )\n{\n    \n    \n\n    leds_display( status );\n}\n\nvoid led1_on( void )\n{\n    status |=  LED1;\n    leds_display( status );\n}\n\nvoid led1_off( void )\n{\n    status &=  ~LED1;\n    leds_display( status );\n}\n\nvoid led2_on( void )\n{\n    status |=  LED2;\n    leds_display( status );\n}\n\nvoid led2_off( void )\n{\n    status &=  ~LED2;\n    leds_display( status );\n}\n\nvoid led1_switch( void )\n{\n    status ^= LED1;\n    leds_display( status );\n}\n\nvoid led2_switch( void )\n{\n    status ^= LED2;\n    leds_display( status );\n}\n\nvoid leds_switch( void ){\n    status ^= (LED1 | LED2);\n    leds_display( status );\n}\n\nvoid leds_display( unsigned int leds_status )\n{\n    status = leds_status;\n    \n    \n    if( status & LED1 )\n        \n        \n    else\n        \n        \n\n    \n    if( status & LED2 )\n        \n        \n    else\n        \n        \n}\n"}
{"target":"behergue","func":"\n\n#include \"44b.h\"\n#include \"leds.h\"\n#include \"gpio.h\"\n\n\n#define LED1 0x01\n#define LED2 0x02\n#define BIT_LED1 9\n#define BIT_LED2 10\n\n\n\n\n\nstatic unsigned int status = 0;\n\nvoid leds_init( void )\n{\n    \n    \n\n    portB_conf(BIT_LED1, OUTPUT);\n    portB_conf(BIT_LED2, OUTPUT);\n\n    leds_display( status );\n}\n\nvoid led1_on( void )\n{\n    status |=  LED1;\n    leds_display( status );\n}\n\nvoid led1_off( void )\n{\n    status &=  ~LED1;\n    leds_display( status );\n}\n\nvoid led2_on( void )\n{\n    status |=  LED2;\n    leds_display( status );\n}\n\nvoid led2_off( void )\n{\n    status &=  ~LED2;\n    leds_display( status );\n}\n\nvoid led1_switch( void )\n{\n    status ^= LED1;\n    leds_display( status );\n}\n\nvoid led2_switch( void )\n{\n    status ^= LED2;\n    leds_display( status );\n}\n\nvoid leds_switch( void ){\n    status ^= (LED1 | LED2);\n    leds_display( status );\n}\n\nvoid leds_display( unsigned int leds_status )\n{\n    status = leds_status;\n    \n    \n    if( status & LED1 )\n    {\n        \n        \n\n        portB_write(BIT_LED1, LOW);\n    }\n    else\n    {\n        \n        \n\n        portB_write(BIT_LED1, HIGH);\n    }\n\n    \n    if( status & LED2 )\n    {\n        \n        \n\n        portB_write(BIT_LED2, LOW);\n    }\n    else\n    {\n        \n        \n\n        portB_write(BIT_LED2, HIGH);\n    }\n}\n"}
{"target":"behergue","func":"#include <stdio.h>\n#include \"44b.h\"\n#include \"button.h\"\n#include \"leds.h\"\n#include \"utils.h\"\n#include \"D8Led.h\"\n#include \"gpio.h\"\n\nstruct RLstat {\n    int moving;\n    int speed;\n    int iter;\n    int direction;\n    int position;\n};\n\nstatic struct RLstat RL = {\n    .moving = 0,\n    .speed = 5,\n    .iter = 0,\n    .direction = 0,\n    .position = 0,\n};\n\nint setup(void)\n{\n    leds_init();\n    D8Led_init();\n    D8Led_segment(RL.position);\n\n    \n\n    \n    \n    \n    \n    \n\n    Delay(0);\n    return 0;\n}\n\nint loop(void)\n{\n    unsigned int buttons = read_button();\n\n    if (buttons & BUT1) {\n        \n        \n        \n        \n    }\n\n    if (buttons & BUT2) {\n        \n        \n        \n        \n        \n        \n    }\n\n    if (RL.moving) {\n        RL.iter--;\n        if (RL.iter == 0) {\n            \n            \n            \n            \n            \n            \n            \n        }\n    }\n\n    Delay(2000); \n    return 0;\n}\n\n\nint main(void)\n{\n    setup();\n\n    while (1) {\n        loop();\n    }\n}\n"}
{"target":"behergue","func":"#include <stdio.h>\n#include \"44b.h\"\n#include \"button.h\"\n#include \"leds.h\"\n#include \"utils.h\"\n#include \"D8Led.h\"\n#include \"intcontroller.h\"\n#include \"timer.h\"\n#include \"gpio.h\"\n#include \"keyboard.h\"\n\nstruct RLstat {\n    int moving;\n    int speed;\n    int direction;\n    int position;\n};\n\nstatic struct RLstat RL = {\n    .moving = 0,\n    .speed = 5,\n    .direction = 0,\n    .position = 0,\n};\n\nvoid timer_ISR(void) __attribute__ ((interrupt (\"IRQ\")));\nvoid button_ISR(void) __attribute__ ((interrupt (\"IRQ\")));\n\n\nvoid timer_ISR(void)\n{\n    \n    if (RL.direction == 1) \n    {\n        if (RL.position + 1 < 6)\n        {\n            RL.position += 1;\n        }\n        else\n        {\n            RL.position = 0;\n        }\n    }\n    else\n    {\n        if (RL.position - 1 >= 0)\n        {\n            RL.position -= 1;\n        }\n        else\n        {\n            RL.position = 5;\n        }\n    }\n\n    D8Led_segment(RL.position);\n}\n\nvoid button_ISR(void)\n{\n    unsigned int whicheint = rEXTINTPND;\n    unsigned int buttons = (whicheint >> 2) & 0x3;\n\n    \n    \n\n    if (buttons & ~BUT1) {\n        \n        \n        \n        \n\n        led1_off();\n        led2_off();\n\n        if(RL.direction == 0)\n        {\n            RL.direction = 1;\n        }\n        else\n        {\n            RL.direction = 0;\n        }\n    }\n\n    if (buttons & ~BUT2) {\n        \n        \n        \n        \n        \n        \n\n        led1_switch();\n\n        led2_switch();\n\n\n        if (RL.moving == 0)\n        {\n            RL.moving= 1;\n        }\n        else\n        {\n            RL.moving= 0;\n        }\n    }\n\n    \n    Delay(2000);\n    \n    rEXTINTPND &= ~(0x03 << 2);\n            \n            \n            \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint setup(void)\n{\n    ic_enable(INT_GLOBAL);\n\n    leds_init();\n    D8Led_init();\n    D8Led_segment(RL.position);\n\n    \n\n    \n    \n    \n    \n\n    portG_conf(6, EINT);\n    portG_conf(7, EINT);\n    portG_conf(1, EINT);\n\n    portG_conf_pup(6, ENABLE);\n    portG_conf_pup(7, ENABLE);\n    portG_conf_pup(1, ENABLE);\n    \n\n    \n    tmr_set_prescaler(TIMER0, 255);\n    tmr_set_divider(8, TIMER0);\n    tmr_set_count(TIMER0, 62500, 1);\n\n    if (RL.moving)\n        tmr_start(TIMER0);\n    \n\n    \n    pISR_TIMER0   = timer_ISR; \n    pISR_EINT4567 = button_ISR; \n    \n\n    \n    ic_conf_irq(ENABLE, VEC);\n    ic_conf_fiq(DISABLE);\n    ic_conf_line(INT_TIMER0, IRQ);\n    ic_conf_line(INT_EINT4567, IRQ);\n    ic_conf_line(INT_EINT1, IRQ);\n    ic_enable(INT_TIMER0);\n    ic_enable(INT_EINT4567);\n    ic_enable(INT_EINT1);\n\n    ic_init();\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ic_conf_irq(ENABLE, VEC);\n    ic_conf_fiq(DISABLE);\n    ic_conf_line(INT_TIMER0, IRQ);\n    ic_conf_line(INT_EINT4567, IRQ);\n    ic_conf_line(INT_EINT1, IRQ);\n    ic_enable(INT_TIMER0);\n    ic_enable(INT_EINT4567);\n    ic_enable(INT_EINT1);\n    \n\n    Delay(0);\n    return 0;\n}\n\nint loop(void)\n{\n    return 0;\n}\n\n\nint main(void)\n{\n    setup();\n\n    while (1) {\n        loop();\n    }\n}\n"}
{"target":"behergue","func":"\n\n\n#include \"44b.h\"\n#include \"timer.h\"\n\nint tmr_set_prescaler(int p, int  value)\n{\n    int offset = p*8;\n    value &= 0xFF;\n\n    if (p < 0 || p > 3)\n        return -1;\n\n    \n    \n    \n    value <<= offset;\n    \n    rTCFG0 |= value;\n\n    return 0;\n}\n\nint tmr_set_divider(int d, enum tmr_div div)\n{\n    int ret = 0;\n    int pos = d*4;\n\n    if ((d < 0 || d > 5) ||\n            (div == D1_32 && d > 3) ||\n            (div == EXTCLK && d != 5) ||\n            (div == TCLK && d != 4))\n        return -1;\n\n    if (div == EXTCLK || div == TCLK)\n        div = 4;\n\n    \n    \n    \n    unsigned int b = div;\n    b <<= pos;\n\n    rTCFG1 |= b;\n\n    return 0;\n}\n\nint tmr_set_count(enum tmr_timer t, int count, int cmp)\n{\n    int err = 0;\n    switch (t) {\n        case TIMER0:\n            \n            \n            \n            \n            rTCNTB0 = count;\n            rTCMPB0 = cmp;\n             break;\n        case TIMER1:\n            \n            \n            \n            \n            rTCNTB1 = count;\n            rTCMPB1 = cmp;\n             break;\n        case TIMER2:\n            \n            \n            \n            \n            rTCNTB2 = count;\n            rTCMPB2 = cmp;\n             break;\n        case TIMER3:\n            \n            \n            \n            \n            rTCNTB3 = count;\n            rTCMPB3 = cmp;\n             break;\n        case TIMER4:\n            \n            \n            \n            \n            rTCNTB4 = count;\n            rTCMPB4 = cmp;\n             break;\n        case TIMER5:\n            \n            \n            \n            rTCNTB5 = count;\n             break;\n        default:\n            err = -1;\n    }\n\n    return err;\n}\n\nint tmr_update(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos + 1; \n    \n    rTCON |= b;\n    rTCON &= ~b;\n\n    return 0;\n}\n\nint tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)\n{\n    int err = 0;\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    if (mode == ONE_SHOT)\n    {\n        \n        \n        \n        unsigned int b = 1;\n        b <<= pos + 4;\n\n        rTCON &= ~b;\n    }\n    else if (mode == RELOAD)\n    {\n        \n        \n        \n        unsigned int b = 1;\n        b <<= pos + 4;\n\n        rTCON |= b;\n    }\n    else\n        err = -1;\n\n    return err;\n}\n\nint tmr_start(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos;\n\n    rTCON |= b;\n    return 0;\n}\n\nint tmr_stop(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos;\n\n    rTCON &= ~b;\n    return 0;\n}\n\nint tmr_isrunning(enum tmr_timer t)\n{\n    int ret = 0;\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if ((t >= 0) && (t <= 5) \n            && (rTCON & (0x1 << pos)))\n        ret = 1;\n\n    return ret;\n}\n\n"}
{"target":"behergue","func":"\n\n\n#include \"44b.h\"\n#include \"timer.h\"\n\nint tmr_set_prescaler(int p, int  value)\n{\n    int offset = p*8;\n    value &= 0xFF;\n\n    if (p < 0 || p > 3)\n        return -1;\n\n    \n    \n    \n    rTCFG0 &= ~(0xFF << offset);\n\n    value <<= offset;\n    rTCFG0 |= value;\n\n    return 0;\n}\n\nint tmr_set_divider(int d, enum tmr_div div)\n{\n    int ret = 0;\n    int pos = d*4;\n\n    if ((d < 0 || d > 5) ||\n            (div == D1_32 && d > 3) ||\n            (div == EXTCLK && d != 5) ||\n            (div == TCLK && d != 4))\n        return -1;\n\n    if (div == EXTCLK || div == TCLK)\n        div = 4;\n\n    \n    \n    \n    rTCFG1 &= ~(0xF << pos);\n\n    unsigned int b = div;\n    b <<= pos;\n\n    rTCFG1 |= b;\n\n    return 0;\n}\n\nint tmr_set_count(enum tmr_timer t, int count, int cmp)\n{\n    int err = 0;\n    switch (t) {\n        case TIMER0:\n            \n            \n            \n            \n            rTCNTB0 = count;\n            rTCMPB0 = cmp;\n             break;\n        case TIMER1:\n            \n            \n            \n            \n            rTCNTB1 = count;\n            rTCMPB1 = cmp;\n             break;\n        case TIMER2:\n            \n            \n            \n            \n            rTCNTB2 = count;\n            rTCMPB2 = cmp;\n             break;\n        case TIMER3:\n            \n            \n            \n            \n            rTCNTB3 = count;\n            rTCMPB3 = cmp;\n             break;\n        case TIMER4:\n            \n            \n            \n            \n            rTCNTB4 = count;\n            rTCMPB4 = cmp;\n             break;\n        case TIMER5:\n            \n            \n            \n            rTCNTB5 = count;\n             break;\n        default:\n            err = -1;\n    }\n\n    return err;\n}\n\nint tmr_update(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos + 1; \n    \n    rTCON |= b;\n    rTCON &= ~b;\n\n    return 0;\n}\n\nint tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)\n{\n    int err = 0;\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    if (mode == ONE_SHOT)\n    {\n        \n        \n        \n        unsigned int b = 1;\n        b <<= pos + 3;\n\n        rTCON &= ~b;\n    }\n    else if (mode == RELOAD)\n    {\n        \n        \n        \n        unsigned int b = 1;\n        b <<= pos + 3;\n\n        rTCON |= b;\n    }\n    else\n        err = -1;\n\n    return err;\n}\n\nint tmr_start(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos;\n\n    rTCON |= b;\n    return 0;\n}\n\nint tmr_stop(enum tmr_timer t)\n{\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if (t < 0 || t > 5)\n        return -1;\n\n    \n    \n    \n    unsigned int b = 1;\n    b <<= pos;\n\n    rTCON &= ~b;\n    return 0;\n}\n\nint tmr_isrunning(enum tmr_timer t)\n{\n    int ret = 0;\n    int pos = t*4;\n    if (t > 0)\n        pos += 4;\n\n    if ((t >= 0) && (t <= 5) \n            && (rTCON & (0x1 << pos)))\n        ret = 1;\n\n    return ret;\n}\n\n"}
{"target":"behergue","func":"\n\nstruct t_dummy {\n    char cx;\n    char cy;\n    int lat;\n    int longitud;\n};\nstruct t_dummy st;\n\nunsigned int tabla[8]= { 0x1, 0x3, 0x5, 0x7, 0x9, 0xB, 0xD, 0xF };\n\n\n#define LED1 0x01\n#define LED2 0x02\nstatic unsigned int status = 0;\n\n\nunsigned int * puntero;\nchar str_tecla[27] = \"\\nTecla pulsada\\0\";;\nchar * puntero2;\n\nint main() {\n\n    st.cx = 1;\n    st.cy = 2;\n    st.lat = 3;\n    st.longitud = 4;\n\n    status |=  LED1;\n    status &=  ~LED1;\n    status ^= (LED1 | LED2);\n    status = (tabla[7]<< 4 ) | tabla [2] | (tabla[4]<<8);\n    status  = (status & ~(0xf << 12)) | (0x7 << 12);\n\n    puntero = tabla;\n    puntero++;\n\n    puntero2 = str_tecla;\n    return 0;\n}\n"}
{"target":"behergue","func":"\n\n\n\n#include <linux\/kernel.h>\n#include <linux\/module.h>\n#include <linux\/fs.h>\n#include <linux\/uaccess.h>\n#include <asm\/uaccess.h>    \n#include <linux\/cdev.h>\n#include <asm-generic\/errno.h>\n#include <linux\/init.h>\n#include <linux\/tty.h> \n#include <linux\/kd.h> \n#include <linux\/vt_kern.h>\n#include <linux\/version.h> \n\n\nMODULE_LICENSE(\"GPL\");\n\n\nint init_module(void);\nvoid cleanup_module(void);\nstatic int device_open(struct inode *, struct file *);\nstatic int device_release(struct inode *, struct file *);\nstatic ssize_t device_read(struct file *, char *, size_t, loff_t *);\nstatic ssize_t device_write(struct file *, const char *, size_t, loff_t *);\n\n\n#define SUCCESS 0\n\n#define DEVICE_NAME \"chardev_leds\"  \n#define BUF_LEN 80\n\n\ndev_t start;\n\n\nstruct cdev* chardev=NULL;\n\n\nstatic int Device_Open = 0;\n\n\n\n\nstatic char *leidos_Ptr = NULL;\n\n\nstatic struct file_operations fops = {\n    .read = device_read,\n    .write = device_write,\n    .open = device_open,\n    .release = device_release\n};\n\n\nstruct tty_driver* kbd_driver= NULL;\n\n\nstruct tty_driver* get_kbd_driver_handler(void)\n{\n    printk(KERN_INFO \"modleds: loading\\n\");\n    printk(KERN_INFO \"modleds: fgconsole is %x\\n\", fg_console);\n#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )\n    return vc_cons[fg_console].d->port.tty->driver;\n#else\n    return vc_cons[fg_console].d->vc_tty->driver;\n#endif\n}\n\n\nstatic inline int set_leds(struct tty_driver* handler, unsigned int mask)\n{\n#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )\n    return (handler->ops->ioctl) (vc_cons[fg_console].d->port.tty, KDSETLED,mask);\n#else\n    return (handler->ops->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED, mask);\n#endif\n}\n\n\nint init_module(void)\n{\n    int major;      \n    int minor;      \n    int ret;\n\n    \n    \n    \n    if ((ret=alloc_chrdev_region (&start, 0, 1,DEVICE_NAME))) {\n        printk(KERN_INFO \"Can't allocate chrdev_region()\");\n        return ret;\n    }\n\n    \n    if ((chardev=cdev_alloc())==NULL) {\n        printk(KERN_INFO \"cdev_alloc() failed \");\n        unregister_chrdev_region(start, 1);\n        return -ENOMEM;\n    }\n\n    \n    cdev_init(chardev,&fops);\n\n    \n    if ((ret=cdev_add(chardev,start,1))) {\n        printk(KERN_INFO \"cdev_add() failed \");\n        kobject_put(&chardev->kobj);\n        unregister_chrdev_region(start, 1);\n        return ret;\n    }\n\n    \n    kbd_driver= get_kbd_driver_handler();\n\n    major=MAJOR(start);\n    minor=MINOR(start);\n\n    \n    printk(KERN_INFO \"I was assigned major number %d. To talk to\\n\", major);\n    printk(KERN_INFO \"the driver, create a dev file with\\n\");\n    \n    \n    \n    \n    \n    \n    printk(KERN_INFO \"'sudo mknod -m 666 \/dev\/%s c %d %d'.\\n\", DEVICE_NAME, major,minor);\n    printk(KERN_INFO \"Try to cat and echo to the device file.\\n\");\n    printk(KERN_INFO \"Remove the device file and module when done.\\n\");\n\n    return SUCCESS;\n}\n\n\nvoid cleanup_module(void)\n{\n    \n    if (chardev)\n        cdev_del(chardev);\n\n    \n    set_leds(kbd_driver,0);\n    \n    unregister_chrdev_region(start, 1);\n}\n\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    if (Device_Open){\n        printk(KERN_ALERT \"El dispositivo ya esaba abierto\");\n        return -EBUSY;\n    }\n\n    \n    Device_Open++;\n    printk(KERN_INFO \"Se acaba de abrir el dispositivo\\n\");\n\n    \n    \n    try_module_get(THIS_MODULE);\n\n    return SUCCESS;\n}\n\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    Device_Open--;      \n\n    \n    module_put(THIS_MODULE);\n    printk(KERN_INFO \"El dispositivo se acaba de cerrar\\n\");\n\n    return 0;\n}\n\n\nstatic ssize_t device_read(struct file *filp,   \n                           char *buffer,    \n                           size_t length,   \n                           loff_t * offset)\n{\n    printk(KERN_ALERT \"Sorry, this operation isn't supported.\\n\");\n    return -EPERM;\n}\n\n\n\n\n\n\nstatic ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t * off){\n    int bytes_to_write = len;\n\n    \n\n    printk(KERN_INFO \"Longitud: %d\\n\", len);\n\n    printk(KERN_INFO \"Estamos en el write\\n\");\n\n    \n    \n    \n    leidos_Ptr = (char *) vmalloc(len);\n\n    \n    if(copy_from_user(leidos_Ptr, buff, bytes_to_write))\n        return -EFAULT;\n\n    \n    unsigned int mask = 0;\n\n    \n    int encender_numLock = 0;\n    int encender_capsLock = 0;\n    int encender_scrollLock = 0;\n\n    \n    \n    int i = 0;\n    while (i < len){\n        if (*leidos_Ptr == '1'){\n            encender_numLock = 2;\n        }\n        else if (*leidos_Ptr == '2'){\n            encender_capsLock = 4;\n        }\n        else if (*leidos_Ptr == '3'){\n            encender_scrollLock = 1;\n        }\n        else{\n            \n            \n        }\n        printk(KERN_INFO \"Leido: %c \\n\", *leidos_Ptr);\n        leidos_Ptr++;\n        i++;\n    }\n\n    \n    mask = encender_numLock+encender_capsLock+encender_scrollLock;\n    printk(KERN_INFO \"Mascara: %d \\n\", mask);\n\n    \n    set_leds(kbd_driver,mask);\n\n    \n    return bytes_to_write;\n}"}
{"target":"behergue","func":"\n\n#include \"fuseLib.h\"\n\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <linux\/kdev_t.h>\n\n\nint resizeNode(uint64_t idxNode, size_t newSize)\n{\n    NodeStruct *node = myFileSystem.nodes[idxNode];\n    char block[BLOCK_SIZE_BYTES];\n    int i, diff = newSize - node->fileSize;\n\n    if(!diff)\n        return 0;\n\n    memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);\n\n    \n    if(diff > 0) {\n\n        \n        if(node->numBlocks && node->fileSize % BLOCK_SIZE_BYTES) {\n            int currentBlock = node->blocks[node->numBlocks - 1];\n\n            if( readBlock(&myFileSystem, currentBlock, &block)==-1 ) {\n                fprintf(stderr,\"Error reading block in resizeNode\\n\");\n                return -EIO;\n            }\n\n            int offBlock = node->fileSize % BLOCK_SIZE_BYTES;\n            int bytes2Write = (diff > (BLOCK_SIZE_BYTES - offBlock)) ? BLOCK_SIZE_BYTES - offBlock : diff;\n            for(i = 0; i < bytes2Write; i++) {\n                block[offBlock++] = 0;\n            }\n\n            if( writeBlock(&myFileSystem, currentBlock, &block)==-1 ) {\n                fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                return -EIO;\n            }\n        }\n\n        \n        int newBlocks = (newSize + BLOCK_SIZE_BYTES - 1) \/ BLOCK_SIZE_BYTES - node->numBlocks;\n        if(newBlocks) {\n            memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);\n\n            \n            if(newBlocks > myFileSystem.superBlock.numOfFreeBlocks)\n                return -ENOSPC;\n\n            myFileSystem.superBlock.numOfFreeBlocks -= newBlocks;\n            int currentBlock = node->numBlocks;\n            node->numBlocks += newBlocks;\n\n            for(i = 0; currentBlock != node->numBlocks; i++) {\n                if(myFileSystem.bitMap[i] == 0) {\n                    myFileSystem.bitMap[i] = 1;\n                    node->blocks[currentBlock] = i;\n                    currentBlock++;\n                    \n                    if( writeBlock(&myFileSystem, i, &block)==-1 ) {\n                        fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                        return -EIO;\n                    }\n                }\n            }\n        }\n        node->fileSize += diff;\n\n    }\n    \n    else {\n        \n        int numBlocks = (newSize + BLOCK_SIZE_BYTES - 1) \/ BLOCK_SIZE_BYTES;\n        myFileSystem.superBlock.numOfFreeBlocks += (node->numBlocks - numBlocks);\n\n        for(i = node->numBlocks; i > numBlocks; i--) {\n            int nBloque = node->blocks[i - 1];\n            myFileSystem.bitMap[nBloque] = 0;\n            \n            if( writeBlock(&myFileSystem, nBloque, &block)==-1 ) {\n                fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                return -EIO;\n            }\n        }\n        node->numBlocks = numBlocks;\n        node->fileSize += diff;\n    }\n    node->modificationTime = time(NULL);\n\n    sync();\n\n    \n    updateSuperBlock(&myFileSystem);\n    updateBitmap(&myFileSystem);\n    updateNode(&myFileSystem, idxNode, node);\n\n    return 0;\n}\n\n\nvoid mode_string(mode_t mode, char *str)\n{\n    str[0] = mode & S_IRUSR ? 'r' : '-';\n    str[1] = mode & S_IWUSR ? 'w' : '-';\n    str[2] = mode & S_IXUSR ? 'x' : '-';\n    str[3] = mode & S_IRGRP ? 'r' : '-';\n    str[4] = mode & S_IWGRP ? 'w' : '-';\n    str[5] = mode & S_IXGRP ? 'x' : '-';\n    str[6] = mode & S_IROTH ? 'r' : '-';\n    str[7] = mode & S_IWOTH ? 'w' : '-';\n    str[8] = mode & S_IXOTH ? 'x' : '-';\n    str[9] = '\\0';\n}\n\n\nstatic int my_getattr(const char *path, struct stat *stbuf)\n{\n    NodeStruct *node;\n    int idxDir;\n\n    fprintf(stderr, \"--->>>my_getattr: path %s\\n\", path);\n\n    memset(stbuf, 0, sizeof(struct stat));\n\n    \n    if(strcmp(path, \"\/\") == 0) {\n        stbuf->st_mode = S_IFDIR | 0755;\n        stbuf->st_nlink = 2;\n        stbuf->st_uid = getuid();\n        stbuf->st_gid = getgid();\n        stbuf->st_mtime = stbuf->st_ctime = myFileSystem.superBlock.creationTime;\n        return 0;\n    }\n\n    \n    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) != -1) {\n        node = myFileSystem.nodes[myFileSystem.directory.files[idxDir].nodeIdx];\n        stbuf->st_size = node->fileSize;\n        stbuf->st_mode = S_IFREG | 0644;\n        stbuf->st_nlink = 1;\n        stbuf->st_uid = getuid();\n        stbuf->st_gid = getgid();\n        stbuf->st_mtime = stbuf->st_ctime = node->modificationTime;\n        return 0;\n    }\n\n    return -ENOENT;\n}\n\n\nstatic int my_readdir(const char *path, void *buf, fuse_fill_dir_t filler,  off_t offset, struct fuse_file_info *fi)\n{\n    int i;\n\n    fprintf(stderr, \"--->>>my_readdir: path %s, offset %jd\\n\", path, (intmax_t)offset);\n\n    if(strcmp(path, \"\/\") != 0)\n        return -ENOENT;\n\n    filler(buf, \".\", NULL, 0);\n    filler(buf, \"..\", NULL, 0);\n\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(!(myFileSystem.directory.files[i].freeFile)) {\n            if(filler(buf, myFileSystem.directory.files[i].fileName, NULL, 0) == 1)\n                return -ENOMEM;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int my_open(const char *path, struct fuse_file_info *fi)\n{\n    int idxDir;\n\n    fprintf(stderr, \"--->>>my_open: path %s, flags %d, %\"PRIu64\"\\n\", path, fi->flags, fi->fh);\n\n    \n    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) == -1) {\n        return -ENOENT;\n    }\n\n    \n    fi->fh = myFileSystem.directory.files[idxDir].nodeIdx;\n\n    return 0;\n}\n\n\n\nstatic int my_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi)\n{\n    char buffer[BLOCK_SIZE_BYTES];\n    int bytes2Write = size, totalWrite = 0;\n    NodeStruct *node = myFileSystem.nodes[fi->fh];\n\n    fprintf(stderr, \"--->>>my_write: path %s, size %zu, offset %jd, fh %\"PRIu64\"\\n\", path, size, (intmax_t)offset, fi->fh);\n\n    \n    if(resizeNode(fi->fh, size + offset) < 0)\n        return -EIO;\n\n    \n    while(bytes2Write) {\n        int i;\n        int currentBlock, offBlock;\n        currentBlock = node->blocks[offset \/ BLOCK_SIZE_BYTES];\n        offBlock = offset % BLOCK_SIZE_BYTES;\n\n        if( readBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {\n            fprintf(stderr,\"Error reading blocks in my_write\\n\");\n            return -EIO;\n        }\n\n        for(i = offBlock; (i < BLOCK_SIZE_BYTES) && (totalWrite < size); i++) {\n            buffer[i] = buf[totalWrite++];\n        }\n\n        if( writeBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {\n            fprintf(stderr,\"Error writing block in my_write\\n\");\n            return -EIO;\n        }\n\n        \n        bytes2Write -= (i - offBlock);\n        offset += (i - offBlock);\n    }\n    sync();\n\n    node->modificationTime = time(NULL);\n    updateSuperBlock(&myFileSystem);\n    updateBitmap(&myFileSystem);\n    updateNode(&myFileSystem, fi->fh, node);\n\n    return size;\n}\n\n\nstatic int my_release(const char *path, struct fuse_file_info *fi)\n{\n    (void) path;\n    (void) fi;\n\n    fprintf(stderr, \"--->>>my_release: path %s\\n\", path);\n\n    return 0;\n}\n\n\nstatic int my_mknod(const char *path, mode_t mode, dev_t device)\n{\n    char modebuf[10];\n\n    mode_string(mode, modebuf);\n    fprintf(stderr, \"--->>>my_mknod: path %s, mode %s, major %d, minor %d\\n\", path, modebuf, (int)MAJOR(device), (int)MINOR(device));\n\n    \n    if(strlen(path + 1) > myFileSystem.superBlock.maxLenFileName) {\n        return -ENAMETOOLONG;\n    }\n\n    \n    if(myFileSystem.numFreeNodes <= 0) {\n        return -ENOSPC;\n    }\n\n    \n    if(myFileSystem.directory.numFiles >= MAX_FILES_PER_DIRECTORY) {\n        return -ENOSPC;\n    }\n    \n    if(findFileByName(&myFileSystem, (char *)path + 1) != -1)\n        return -EEXIST;\n\n    \n    int idxNodoI, idxDir;\n    if((idxNodoI = findFreeNode(&myFileSystem)) == -1 || (idxDir = findFreeFile(&myFileSystem)) == -1) {\n        return -ENOSPC;\n    }\n\n    \n    myFileSystem.directory.files[idxDir].freeFile = false;\n    myFileSystem.directory.numFiles++;\n    strcpy(myFileSystem.directory.files[idxDir].fileName, path + 1);\n    myFileSystem.directory.files[idxDir].nodeIdx = idxNodoI;\n    myFileSystem.numFreeNodes--;\n\n    \n    if(myFileSystem.nodes[idxNodoI] == NULL)\n        myFileSystem.nodes[idxNodoI] = malloc(sizeof(NodeStruct));\n\n    myFileSystem.nodes[idxNodoI]->fileSize = 0;\n    myFileSystem.nodes[idxNodoI]->numBlocks = 0;\n    myFileSystem.nodes[idxNodoI]->modificationTime = time(NULL);\n    myFileSystem.nodes[idxNodoI]->freeNode = false;\n\n    reserveBlocksForNodes(&myFileSystem, myFileSystem.nodes[idxNodoI]->blocks, 0);\n\n    updateDirectory(&myFileSystem);\n    updateNode(&myFileSystem, idxNodoI, myFileSystem.nodes[idxNodoI]);\n\n    return 0;\n}\n\n\nstatic int my_truncate(const char *path, off_t size)\n{\n    int idxDir;\n\n    fprintf(stderr, \"--->>>my_truncate: path %s, size %jd\\n\", path, size);\n\n    if((idxDir = findFileByName(&myFileSystem, (char *)path + 1)) == -1) {\n        return -ENOENT;\n    }\n\n    \n    if(resizeNode(myFileSystem.directory.files[idxDir].nodeIdx, size) < 0)\n        return -EIO;\n\n    return 0;\n}\n\n\n\nstatic int my_unlink(const char *path){\n\n    int idfich;\n\n    \n    \n    if((idfich = findFileByName(&myFileSystem, (char *)path + 1)) == -1)\n        return -EEXIST;\n\n    \n    myFileSystem.directory.files[idfich].freeFile = true;\n    \n    myFileSystem.directory.numFiles--;\n    \n    myFileSystem.numFreeNodes++;\n\n    \n    int idnodo = myFileSystem.directory.files[idfich].nodeIdx;\n\n    \n    myFileSystem.nodes[idnodo]->freeNode = true;\n\n    int bloque;\n\n    \n    for(int i = 0; i < MAX_BLOCKS_PER_FILE; i++){\n        \n        if((bloque = myFileSystem.nodes[idnodo]->blocks[i]) != 0){\n            \n            myFileSystem.bitMap[bloque] = 0;\n            \n            myFileSystem.nodes[idnodo]->blocks[i] = 0;\n            \n            myFileSystem.superBlock.numOfFreeBlocks++;\n        }\n    }\n\n    \n    free (myFileSystem.nodes[idnodo]);\n\n    \n    updateBitmap(&myFileSystem);\n    updateDirectory(&myFileSystem);\n    updateNode(&myFileSystem, idnodo, myFileSystem.nodes[idnodo]);\n    updateSuperBlock(&myFileSystem);\n\n    return 0;\n}\n\n\n\n\n\n\nstatic int my_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi){\n\n    \n    char buffer[BLOCK_SIZE_BYTES];\n    \n    int bytes2Read = size, totalRead = 0;\n    \n    NodeStruct *node = myFileSystem.nodes[fi->fh];\n\n    \n    fprintf(stderr, \"--->>>my_read: path %s, size %zu, offset %jd, fh %\"PRIu64\"\\n\", path, size, (intmax_t)offset, fi->fh);\n\n    \n    while(bytes2Read) {\n        int i;\n        int currentBlock, offBlock;\n        \n        currentBlock = node->blocks[offset \/ BLOCK_SIZE_BYTES];\n        \n        offBlock = offset % BLOCK_SIZE_BYTES;\n\n        \n        if( readBlock(&myFileSystem, currentBlock, &buffer)==-1 ) {\n            fprintf(stderr,\"Error reading blocks in my_write\\n\");\n            return -EIO;\n        }\n\n        \n        for(i = offBlock; (i < BLOCK_SIZE_BYTES) && (totalRead < size); i++) {\n            \n            buf[totalRead++] = buffer[i] ;\n        }\n\n        \n        \n        bytes2Read -= (i - offBlock);\n        \n        offset += (i - offBlock);\n    }\n\n    \n    while (totalRead < size){\n        buf[totalRead++] = '0';\n    }\n\n    \n    sync();\n\n    return size;\n}\n\n\nstruct fuse_operations myFS_operations = {\n    .getattr    = my_getattr,                   \n    .readdir    = my_readdir,                   \n    .truncate   = my_truncate,                  \n    .open       = my_open,                      \n    .write      = my_write,                     \n    .release    = my_release,                   \n    .mknod      = my_mknod,                     \n    .unlink     = my_unlink,\n    .read       = my_read,\n};\n\n"}
{"target":"behergue","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define PATH \"\/dev\/chardev_leds\"\n\nint main(int argc, char * argv[]){\n    \n    if (argc!=2){\n        fprintf(stderr, \"Uso: %s cont_binario\/rotativo (Elegir uno de los dos modos)\\n\", argv[0]);\n        exit(1);\n    }\n\n    \n    FILE * file = fopen(PATH, \"r+\");\n    if (file == NULL){\n        printf(\"No se puede abrir el archivo\\n\");\n        exit(1);\n    }\n    fclose(file);\n\n    \n    if(strcmp(argv[1], \"cont_binario\") == 0){\n        cont_binario();\n    }\n\n    \n    else if(strcmp(argv[1], \"rotativo\") == 0){\n        rotativo();\n    }\n    \n    else{\n        fprintf(stderr, \"Modo: %s no valido\\n\", argv[1]);\n        exit(1);\n    }\n\n    return 0;\n}\n\n\nvoid rotativo(){\n\n    \n    char  leds[] = \"0\";\n\n    \n    FILE * file;\n\n    \n    int i = 1;\n    while(1){\n        file = fopen(PATH, \"r+\");\n\n        \n        sprintf(leds, \"%d\", i);\n\n        fwrite(leds, sizeof(char), strlen(leds), file);\n\n        printf(\"He encendido el led %s\\n\", leds);\n        fclose(file);\n\n        sleep(1);\n\n        i = (i%3) + 1;\n    }\n}\n\n\nvoid cont_binario(){\n\n    \n    char leds[] = \"000\";\n\n    \n    FILE * file;\n\n    int i = 0;\n    \n    while(1){\n        int num = i;\n        file = fopen(PATH, \"r+\");\n\n        \n        if(num >= 4){\n            leds[0] = '1';\n            num = num -4;\n        }\n\n        \n        if (num >= 2){\n            leds[1] = '2';\n            num = num -2;\n        }\n\n        \n        if(num >= 1){\n            leds[2] = '3';\n        }\n\n        \n        fwrite(leds, sizeof(char), strlen(leds), file);\n\n        printf(\"He encendido los leds %s\\n\", leds);\n\n        fclose(file);\n\n        \n        sleep(1);\n\n        i = (i+1)%8;\n\n        leds[0] = '0';\n        leds[1] = '0';\n        leds[2] = '0';\n    }\n}"}
{"target":"behergue","func":"#include <linux\/module.h>\n#include <asm-generic\/errno.h>\n#include <linux\/init.h>\n#include <linux\/tty.h>      \n#include <linux\/kd.h>       \n#include <linux\/vt_kern.h>\n#include <linux\/version.h> \n\n#define ALL_LEDS_ON 0x7\n#define ALL_LEDS_OFF 0\n\n\nstruct tty_driver* kbd_driver= NULL;\n\n\n\nstruct tty_driver* get_kbd_driver_handler(void)\n{\n    printk(KERN_INFO \"modleds: loading\\n\");\n    printk(KERN_INFO \"modleds: fgconsole is %x\\n\", fg_console);\n#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )\n    return vc_cons[fg_console].d->port.tty->driver;\n#else\n    return vc_cons[fg_console].d->vc_tty->driver;\n#endif\n}\n\n\nstatic inline int set_leds(struct tty_driver* handler, unsigned int mask)\n{\n#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32) )\n    return (handler->ops->ioctl) (vc_cons[fg_console].d->port.tty, KDSETLED,mask);\n#else\n    return (handler->ops->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED, mask);\n#endif\n}\n\nstatic int __init modleds_init(void)\n{\n    kbd_driver= get_kbd_driver_handler();\n    set_leds(kbd_driver,ALL_LEDS_ON);\n    return 0;\n}\n\nstatic void __exit modleds_exit(void)\n{\n    set_leds(kbd_driver,ALL_LEDS_OFF);\n}\n\nmodule_init(modleds_init);\nmodule_exit(modleds_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Modleds\");\n"}
{"target":"behergue","func":"#include \"fuseLib.h\"\n#include \"myFS.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\nMyFileSystem myFileSystem;\n\n#define USAGE           \"Usage: %s -t diskSize -a backupFileName -f 'fuse options'\\n\"\n#define EXAMPLE     \"Example:\\n%s -t 2097152 -a virtual-disk -f '-d -s mount-point'\\n\"\n#define EXAMPLE2    \"Example:\\n%s -m -a <virtual-disk> -f '-d -s mount-point'\\n\"\n\nint main(int argc, char **argv)\n{\n    myFileSystem.numFreeNodes = MAX_NODES;\n\n    int ret; \n\n    int opt, diskSize = -1;\n    char *backupFileName = NULL;\n    char *argsFUSE = NULL;\n\n    char *argvNew[MAX_FUSE_NARGS];\n    char *pTmp;\n    int mount=0;\n\n    while((opt = getopt(argc, argv, \"t:a:f:m\")) != -1) {\n        switch(opt) {\n        case 't':\n            diskSize = atoi(optarg);\n            break;\n        case 'a':\n            backupFileName = optarg;\n            break;\n        case 'f':\n            argsFUSE = optarg;\n            break;\n        case 'm':\n            mount=1;\n            break;\n        default: \n            fprintf(stderr, USAGE, argv[0]);\n            fprintf(stderr, EXAMPLE, argv[0]);\n            exit(-1);\n        }\n    }\n\n    if (!mount) {\n        \n        if(diskSize == -1 || backupFileName == NULL || argsFUSE == NULL) {\n            fprintf(stderr, USAGE, argv[0]);\n            fprintf(stderr, EXAMPLE, argv[0]);\n            exit(-1);\n        }\n\n        \n        ret = myMkfs(&myFileSystem, diskSize, backupFileName);\n    } else {\n        \n        if(backupFileName == NULL || argsFUSE == NULL) {\n            fprintf(stderr, USAGE, argv[0]);\n            fprintf(stderr, EXAMPLE2, argv[0]);\n            exit(-1);\n        }\n        \n        ret = myMount(&myFileSystem, backupFileName);\n    }\n\n    if(ret) {\n        fprintf(stderr, \"Unable to format or mount, error code: %d\\n\", ret);\n        exit(-1);\n    }\n    fprintf(stderr, \"File system available\\n\");\n\n    \n    argc = 1;\n    argvNew[0] = argv[0];\n\n    pTmp = strtok(argsFUSE, \" \");\n    while(pTmp && argc < MAX_FUSE_NARGS) {\n        argvNew[argc++] = pTmp;\n        pTmp = strtok(0, \" \");\n    }\n\n    \n    if((ret = fuse_main(argc, argvNew, &myFS_operations, NULL))) {\n        fprintf(stderr, \"Error when mounting the FUSE file system\\n\");\n        return(ret);\n    }\n\n    myFree(&myFileSystem);\n\n    return(0);\n}\n"}
{"target":"behergue","func":"#include \"myFS.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <unistd.h>\n\nvoid copyNode(NodeStruct *dest, NodeStruct *src)\n{\n    int i;\n\n    dest->numBlocks = src->numBlocks;\n    dest->fileSize = src->fileSize;\n    dest->modificationTime = src->modificationTime;\n    dest->freeNode = src->freeNode;\n\n    for(i = 0; i < MAX_BLOCKS_PER_FILE; i++)\n        dest->blocks[i] = src->blocks[i];\n}\n\nint findFileByName(MyFileSystem *myFileSystem, char *fileName)\n{\n    int i;\n\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(myFileSystem->directory.files[i].freeFile == false) {\n            if(strcmp(fileName, myFileSystem->directory.files[i].fileName) == 0)\n                return i;\n        }\n    }\n    return -1;\n}\n\nint findFreeFile(MyFileSystem *myFileSystem)\n{\n    int i;\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(myFileSystem->directory.files[i].freeFile == true)\n            return i;\n    }\n    \n    return -1;\n}\n\nint findFreeNode(MyFileSystem* myFileSystem)\n{\n    int i;\n    for(i = 0; i < MAX_NODES; i++) {\n        if(myFileSystem->nodes[i] == NULL)\n            return i;\n    }\n    \n    return -1;\n}\n\nint findNodeByPos(int nodeNum)\n{\n    int whichInodeBlock;\n    int whichInodeInBlock;\n    int inodeLocation;\n\n    whichInodeBlock = nodeNum \/ NODES_PER_BLOCK;\n    whichInodeInBlock = nodeNum % NODES_PER_BLOCK;\n\n    inodeLocation = (NODES_IDX + whichInodeBlock) * BLOCK_SIZE_BYTES + whichInodeInBlock * sizeof(NodeStruct);\n    return inodeLocation;\n}\n\nint initializeNodes(MyFileSystem *myFileSystem)\n{\n    int numNode;\n    NodeStruct temp;\n\n    \n    for(numNode = 0; numNode < MAX_NODES; numNode++) {\n        if(readNode(myFileSystem, numNode, &temp))\n            return -1;\n        \n        if(temp.freeNode) {\n            myFileSystem->nodes[numNode] = NULL;\n        }\n        \n        else {\n            if( (myFileSystem->nodes[numNode] = malloc(sizeof(NodeStruct)))==NULL) {\n                perror(\"Error in malloc\");\n                return -2;\n            }\n            copyNode(myFileSystem->nodes[numNode], &temp);\n            myFileSystem->numFreeNodes--;\n        }\n    }\n    return 0;\n}\n\nvoid initializeSuperBlock(MyFileSystem *myFileSystem, int diskSize)\n{\n    myFileSystem->superBlock.diskSizeInBlocks = diskSize \/ BLOCK_SIZE_BYTES;\n    myFileSystem->superBlock.numOfFreeBlocks = myQuota(myFileSystem);\n\n    myFileSystem->superBlock.creationTime = time(NULL);\n\n    myFileSystem->superBlock.blockSize = BLOCK_SIZE_BYTES;\n    myFileSystem->superBlock.maxLenFileName = MAX_LEN_FILE_NAME;\n    myFileSystem->superBlock.maxBlocksPerFile = MAX_BLOCKS_PER_FILE;\n}\n\nvoid myFree(MyFileSystem *myFileSystem)\n{\n    int i;\n    close(myFileSystem->fdVirtualDisk);\n    for(i = 0; i < MAX_NODES; i++) {\n        free(myFileSystem->nodes[i]);\n        myFileSystem->nodes[i] = NULL;\n    }\n}\n\nint myMkfs(MyFileSystem *myFileSystem, int diskSize, char *backupFileName)\n{\n    \n    myFileSystem->fdVirtualDisk = open(backupFileName, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n\n    \n    assert(sizeof(SuperBlockStruct) <= BLOCK_SIZE_BYTES);\n    assert(sizeof(DirectoryStruct) <= BLOCK_SIZE_BYTES);\n    int numBlocks = diskSize \/ BLOCK_SIZE_BYTES;\n    int minNumBlocks = 3 + MAX_BLOCKS_WITH_NODES + 1;\n    int maxNumBlocks = NUM_BITS;\n    if(numBlocks < minNumBlocks) {\n        return -1;\n    }\n    if(numBlocks >= maxNumBlocks) {\n        return -2;\n    }\n\n    \n    \n    int i;\n    for(i = 0; i < NUM_BITS; i++) {\n        myFileSystem->bitMap[i] = 0;\n    }\n\n    \n    myFileSystem->bitMap[BITMAP_IDX] = 1;\n    myFileSystem->bitMap[SUPERBLOCK_IDX] = 1;\n    myFileSystem->bitMap[DIRECTORY_IDX] = 1;\n    \n    for(i = 3; i < 3 + MAX_BLOCKS_WITH_NODES; i++) {\n        myFileSystem->bitMap[i] = 1;\n    }\n    updateBitmap(myFileSystem);\n\n    \n    \n    myFileSystem->directory.numFiles = 0;\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        myFileSystem->directory.files[i].freeFile = 1;\n    }\n    updateDirectory(myFileSystem);\n\n    \n    NodeStruct currentNode;\n    currentNode.freeNode = 1;\n    for(i = 0; i < MAX_NODES; i++) {\n        updateNode(myFileSystem, i, &currentNode);\n    }\n\n    \n    initializeSuperBlock(myFileSystem, diskSize);\n    updateSuperBlock(myFileSystem);\n    sync();\n\n    \n    assert(myQuota(myFileSystem) >= 1);\n\n    if(initializeNodes(myFileSystem)) {\n        myFree(myFileSystem);\n        return -3;\n    }\n\n    printf(\"SF: %s, %d B (%d B\/block), %d blocks\\n\", backupFileName, diskSize, BLOCK_SIZE_BYTES, numBlocks);\n    printf(\"1 block for SUPERBLOCK (%u B)\\n\", (unsigned int)sizeof(SuperBlockStruct));\n    printf(\"1 block for BITMAP, covering %u blocks, %u B\\n\", (unsigned int)NUM_BITS, (unsigned int)(NUM_BITS * BLOCK_SIZE_BYTES));\n    printf(\"1 block for DIRECTORY (%u B)\\n\", (unsigned int)sizeof(DirectoryStruct));\n    printf(\"%d blocks for inodes (%u B\/inode, %u inodes)\\n\", MAX_BLOCKS_WITH_NODES, (unsigned int)sizeof(NodeStruct), (unsigned int)MAX_NODES);\n    printf(\"%d blocks for data (%d B)\\n\", myFileSystem->superBlock.numOfFreeBlocks, BLOCK_SIZE_BYTES * myFileSystem->superBlock.numOfFreeBlocks);\n    printf(\"Formatting completed!\\n\");\n\n    return 0;\n}\n\nint myQuota(MyFileSystem *myFileSystem)\n{\n    int freeCount = 0;\n    int i;\n    \n    for(i = 0; i < myFileSystem->superBlock.diskSizeInBlocks; i++) {\n        \n        \n        if(myFileSystem->bitMap[i] == 0) {\n            freeCount++;\n        }\n    }\n    return freeCount;\n}\n\nint readNode(MyFileSystem *myFileSystem, int nodeNum, NodeStruct* node)\n{\n    int posNode;\n    assert(nodeNum < MAX_NODES);\n    posNode = findNodeByPos(nodeNum);\n\n    if( lseek(myFileSystem->fdVirtualDisk, posNode, SEEK_SET)==-1 ||\n        read(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) != sizeof(NodeStruct) ) {\n        perror(\"Error when reading an inode\");\n        return -1;\n    }\n    return 0;\n}\n\nint reserveBlocksForNodes(MyFileSystem *myFileSystem, DISK_LBA blocks[], int numBlocks)\n{\n    int i = 0;\n    int currentBlock = 0;\n\n    while((currentBlock < numBlocks) && (i < NUM_BITS)) {\n        if(myFileSystem->bitMap[i] == 0) {\n            myFileSystem->bitMap[i] = 1;\n            blocks[currentBlock] = i;\n            currentBlock++;\n        }\n        ++i;\n    }\n\n    return (i==NUM_BITS)?-1:0;\n}\n\nint updateBitmap(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * BITMAP_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateBitmap\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk,\n             myFileSystem->bitMap, sizeof(BIT) * NUM_BITS) == -1) {\n        perror(\"Failed write in updateBitmap\");\n        return -1;\n    }\n    sync();\n    return 0;\n}\n\nint updateDirectory(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * DIRECTORY_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateDirectory\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->directory), sizeof(DirectoryStruct)) == -1) {\n        perror(\"Failed write in updateDirectory\");\n        return -1;\n    }\n    sync();\n    return 0;\n}\n\nint updateNode(MyFileSystem *myFileSystem, int numNode, NodeStruct *node)\n{\n    int posNodoI;\n    assert(numNode < MAX_NODES);\n    posNodoI = findNodeByPos(numNode);\n\n    if(lseek(myFileSystem->fdVirtualDisk, posNodoI, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateNode\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) == -1) {\n        perror(\"Failed write in updateNode\");\n    }\n    sync();\n    return 0;\n}\n\n\nint updateSuperBlock(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * SUPERBLOCK_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateSuperBlock\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->superBlock), sizeof(SuperBlockStruct)) == -1) {\n        perror(\"Failed write in updateSuperBlock\");\n        return -1;\n    }\n    sync();\n    return 0;\n}\n\n\n\nint readBitmap(MyFileSystem *myFileSystem)\n{\n    return -1;\n}\n\n\n\nint readDirectory(MyFileSystem* myFileSystem)\n{\n    return -1;\n}\n\n\nint readSuperblock(MyFileSystem* myFileSystem)\n{\n    return -1;\n}\n\nint readInodes(MyFileSystem* myFileSystem)\n{\n    return -1;\n}\n\nint myMount(MyFileSystem *myFileSystem, char *backupFileName)\n{\n    if ((myFileSystem->fdVirtualDisk = open(backupFileName, O_RDWR))==-1) {\n        perror(backupFileName);\n        return 1;\n    }\n\n    if (readBitmap(myFileSystem)!=0) {\n        fprintf(stderr,\"Can't read bitmap\\n\");\n        return 2;\n    }\n\n    if (readSuperblock(myFileSystem)!=0) {\n        fprintf(stderr,\"Can't read superblock\\n\");\n        return 3;\n    }\n\n    if (readInodes(myFileSystem)!=0) {\n        fprintf(stderr,\"Can't read inodes\\n\");\n        return 4;\n    }\n\n    if (readDirectory(myFileSystem)!=0) {\n        fprintf(stderr,\"Can't read directory\\n\");\n        return 5;\n    }\n\n    printf(\"SF: %s, %d B (%d B\/block), %d blocks\\n\", backupFileName, myFileSystem->superBlock.diskSizeInBlocks*BLOCK_SIZE_BYTES, BLOCK_SIZE_BYTES, myFileSystem->superBlock.diskSizeInBlocks);\n    printf(\"1 block for SUPERBLOCK (%u B)\\n\", (unsigned int)sizeof(SuperBlockStruct));\n    printf(\"1 block for BITMAP, covering %u blocks, %u B\\n\", (unsigned int)NUM_BITS, (unsigned int)(NUM_BITS * BLOCK_SIZE_BYTES));\n    printf(\"1 block for DIRECTORY (%u B)\\n\", (unsigned int)sizeof(DirectoryStruct));\n    printf(\"%d blocks for inodes (%u B\/inode, %u inodes)\\n\", MAX_BLOCKS_WITH_NODES, (unsigned int)sizeof(NodeStruct), (unsigned int)MAX_NODES);\n    printf(\"%d blocks for data (%d B)\\n\", myFileSystem->superBlock.numOfFreeBlocks, BLOCK_SIZE_BYTES * myFileSystem->superBlock.numOfFreeBlocks);\n    printf(\"Volume mounted successfully!\\n\");\n    return 0;\n}\n\nint readBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)\n{\n\n    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {\n        fprintf(stderr,\"Firts bocks to be read must be between 0 and %d\\n\", myFileSystem->superBlock.diskSizeInBlocks-1);\n        return -1;\n    }\n\n    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {\n        perror(\"Failed lseek in readBlock()\");\n        return -1;\n    }\n    if( read(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {\n        perror(\"Failed read in readBlock()\");\n    }\n    return 0;\n}\n\nint writeBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)\n{\n\n    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {\n        fprintf(stderr,\"Firts bocks to be read must be between 0 and %d\\n\", myFileSystem->superBlock.diskSizeInBlocks-1);\n        return -1;\n    }\n\n    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {\n        perror(\"Lseek failed in writeBlock()\");\n        return -1;\n    }\n    if( write(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {\n        perror(\"Write failed in writeBlock()\");\n    }\n    return 0;\n}"}
{"target":"behergue","func":"#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n       \n#include \"mytar.h\"\n       \nchar use[]=\"Usage: tar -c|x -f file_mytar [file1 file2 ...]\\n\";\n\nint main(int argc, char *argv[]) {\n\n  int opt, nExtra, retCode=EXIT_SUCCESS;\n  flags flag=NONE;\n  char *tarName=NULL;\n  \n  \n  if(argc < 2){\n    fprintf(stderr,\"%s\",use);\n    exit(EXIT_FAILURE);\n  }\n  \n  while((opt = getopt(argc, argv, \"cxf:\")) != -1) {\n    switch(opt) {\n      case 'c':\n        flag=(flag==NONE)?CREATE:ERROR;\n        break;\n      case 'x':\n        flag=(flag==NONE)?EXTRACT:ERROR;\n        break;\n      case 'f':\n        tarName = optarg;\n        break;\n      default:\n        flag=ERROR;\n    }\n    \n    if(flag==ERROR){\n      fprintf(stderr,\"%s\",use);\n      exit(EXIT_FAILURE);\n    }\n  }\n  \n  \n  if(flag==NONE || tarName==NULL) {\n    fprintf(stderr,\"%s\",use);\n    exit(EXIT_FAILURE);\n  }\n  \n  \n  nExtra=argc-optind;\n  \n  \n  switch(flag) {\n    case CREATE:\n      retCode=createTar(nExtra, &argv[optind], tarName);\n      break;\n    case EXTRACT:\n      if(nExtra!=0){\n        fprintf(stderr,\"%s\",use);\n        exit(EXIT_FAILURE);\n      }\n      retCode=extractTar(tarName);\n      break;\n    default:\n      retCode=EXIT_FAILURE;\n  }\n  exit(retCode);\n}\n"}
{"target":"behergue","func":"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"mytar.h\"\n\nextern char *use;\n\n\n\nint copynFile(FILE * origin, FILE * destination, int nBytes){\n    \n    \n    char* c = (char*) malloc(nBytes * sizeof(char));\n\n    \n    int n = fread(c, sizeof(char), nBytes, origin);\n\n    \n    fwrite(c, sizeof(char), n, destination);\n\n    \n    free(c);\n\n    \n    return n;\n}\n\n\n\nchar* loadstr(FILE * file){\n\n    \n    int counter = 0;\n\n    \n    while(getc(file) != '\\0')\n        counter++;\n\n    \n    fseek(file, -(counter + 1), SEEK_CUR);\n\n    \n    char* c = (char*) malloc(counter * sizeof(char));\n\n    \n    fread(c, sizeof(char), counter + 1, file);\n\n    \n    return c;\n}\n\n\n\nstHeaderEntry* readHeader(FILE * tarFile, int *nFiles){\n\n    \n    fread(nFiles, sizeof(int), 1, tarFile);\n\n    \n    stHeaderEntry* pair = (stHeaderEntry*) malloc(sizeof(stHeaderEntry) * (*nFiles));\n\n    \n    for(int i = 0; i < *nFiles; i++){\n        \n        pair[i].name = loadstr(tarFile);\n        \n        fread(&(pair[i].size), sizeof(int), 1, tarFile);\n    }\n\n    \n    return pair;\n}\n\n\n\nint createTar(int nFiles, char *fileNames[], char tarName[]){\n\n    \n    FILE * f = fopen(tarName, \"w\");\n\n    \n    int headerSize = sizeof(int);\n    for(int i = 0; i < nFiles; i++)\n        headerSize += strlen(fileNames[i]) + 1 + sizeof(int);\n\n    \n    fseek(f, headerSize, SEEK_SET);\n\n    \n    int* fileSizes = (int*) malloc(nFiles * sizeof(int));\n    \n    \n    for(int i = 0; i < nFiles; i++){\n        \n        FILE * a = fopen(fileNames[i], \"r\");\n        \n        int t = copynFile(a, f, 100);\n        \n        fileSizes[i] = 0;\n        while(t != 0){\n            \n            fileSizes[i] += t;\n            \n            t = copynFile(a, f, 100);\n        }\n        \n        fclose(a);\n    }\n    \n    \n    fseek(f, 0, SEEK_SET);\n\n    \n    fwrite(&nFiles, sizeof(int), 1, f);\n\n    \n    for(int i = 0; i < nFiles; i++){\n        \n        fwrite(fileNames[i], sizeof(char), strlen(fileNames[i]) + 1, f);\n        \n        fwrite(&fileSizes[i], sizeof(int), 1, f);\n    }\n\n    \n    fclose(f);\n    \n    free(fileSizes);\n\n    \n    return EXIT_SUCCESS;\n}\n\n\n\nint extractTar(char tarName[]){\n\n    \n    FILE * f = fopen(tarName, \"r\");\n\n    \n    int nFiles;\n    stHeaderEntry* s = readHeader(f, &nFiles);\n\n    \n    for(int i = 0; i < nFiles; i++){\n        \n        FILE * a = fopen(s[i].name, \"w\");\n        \n        copynFile(f, a, s[i].size);\n        \n        fclose(a);\n    }\n\n    \n    fclose(f);\n    \n    return EXIT_SUCCESS;\n}\n"}
{"target":"behergue","func":"\n\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n    \n    if (argc!=2){\n        fprintf(stderr, \"Usage: %s <command>\\n\", argv[0]);\n        exit(1);\n    }\n\n    return system(argv[1]);\n}\n\n\nint system(const char * command){\n    int ret = -1;\n\n    \n    int pid = fork();\n\n    \n    if(pid == -1)\n        fprintf(stderr, \"Fallo fork\\n\");\n\n    \n    else if(pid == 0)\n        execlp(\"\/bin\/bash\", \"bash\", \"-c\", command, (char*) NULL);\n    \n    \n    \n    else{\n        wait(&ret);\n        ret = WEXITSTATUS(ret);\n    }\n}"}
{"target":"behergue","func":"\n\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdbool.h>\n\n#define N_PARADAS 5\n\n#define EN_RUTA 0\n\n#define EN_PARADA 1\n\n#define MAX_USUARIOS 40 \n#define USUARIOS 4 \n\n\nint estado= EN_RUTA;\nint parada_actual = 0; \nint n_ocupantes= 0; \n\nint esperando_parada[N_PARADAS]; \n\nint esperando_bajar[N_PARADAS]; \n\n\n\npthread_mutex_t esperaSubir[N_PARADAS];\npthread_mutex_t esperaBajar[N_PARADAS];\n\npthread_t hiloAutobus;\n\npthread_t usuarios[USUARIOS];\n\npthread_cond_t suben;\npthread_cond_t bajan;\npthread_cond_t hanSubido;\npthread_cond_t hanBajado;\n\nint min(int num1, int num2){\n    if(num1 < num2)\n        return num1;\n    else\n        return num2;\n}\n\nvoid * thread_autobus(void * args) {\n    while (1) {\n    \n        Autobus_En_Parada();\n    \n        Conducir_Hasta_Siguiente_Parada();\n    }\n}\n\nvoid * thread_usuario(int i) {\n    int id_usuario, a, b;\n    id_usuario = i;\n\n    while (1) {\n        a=rand() % N_PARADAS;\n        do{\n            b=rand() % N_PARADAS;\n        } while(a==b);\n\n        printf(\"Usuario %d se quiere subir en la parada %d y bajar en la %d \\n\", id_usuario, a, b);\n        Usuario(id_usuario,a,b);\n    }\n}\n\nvoid Usuario(int id_usuario, int origen, int destino) {\n\n    Subir_Autobus(id_usuario, origen);\n\n    Bajar_Autobus(id_usuario, destino);\n}\n\nint main(int argc, char *argv[]) {\n    int i;\n\n\n\n\n\n\n    for(i=0; i < N_PARADAS; i++){\n        pthread_mutex_init(&esperaSubir[i],NULL);\n        pthread_mutex_init(&esperaBajar[i],NULL);\n    }\n    \n\n    pthread_cond_init(&suben, NULL);\n    pthread_cond_init(&bajan, NULL);\n    pthread_cond_init(&hanSubido, NULL);\n    pthread_cond_init(&hanBajado, NULL);\n    \n\n    pthread_create(&hiloAutobus, NULL, thread_autobus, NULL);\n    \n\n    for (i = 0; i < USUARIOS; i++)\n        pthread_create(&usuarios[i], NULL, thread_usuario, (void *) i);\n\n\n\n    pthread_join(hiloAutobus, NULL);\n\n    for (i = 0; i < USUARIOS; i++)\n        pthread_join(usuarios[i], NULL);\n\n    for(i=0; i<N_PARADAS; i++){\n        pthread_mutex_destroy(&esperaSubir[i]);\n        pthread_mutex_destroy(&esperaBajar[i]);\n    }\n\n    \n    pthread_cond_destroy(&suben);\n    pthread_cond_destroy(&bajan);\n    pthread_cond_destroy(&hanSubido);\n    pthread_cond_destroy(&hanBajado);\n\n    return 0;\n}\n\nvoid Autobus_En_Parada(){\n\n    \n    \n    printf(\"EL bus est\u00e1 en la parada %d \\n\", parada_actual);\n    estado = EN_PARADA;\n\n    pthread_mutex_lock(&esperaSubir[parada_actual]);\n    pthread_mutex_lock(&esperaBajar[parada_actual]);\n\n    \n    n_ocupantes -= esperando_bajar[parada_actual];\n    \n    \n    int usuarios_suben = min(MAX_USUARIOS-n_ocupantes, esperando_parada[parada_actual]);\n    n_ocupantes += usuarios_suben;\n    \n    \n    pthread_cond_broadcast(&bajan);\n    \n    \n    int j;\n    for(j = 0; j < usuarios_suben; j++){\n        \n        \n        \n        pthread_cond_broadcast(&suben);\n    }\n    \n    \n    while(esperando_parada[parada_actual] > 0 || esperando_bajar[parada_actual] > 0){\n        \n        \n        if(esperando_bajar[parada_actual] > 0 && esperando_parada[parada_actual] == 0)\n            \n            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);\n\n        \n        else if(esperando_bajar[parada_actual] == 0 && esperando_parada[parada_actual] > 0)\n            \n            pthread_cond_wait(&hanSubido, &esperaSubir[parada_actual]);\n        \n        \n        else{\n            \n            pthread_mutex_unlock(&esperaSubir[parada_actual]);\n            \n            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);\n            \n            pthread_mutex_lock(&esperaSubir[parada_actual]);\n        }\n\n        \n        \n    }\n    \n    pthread_mutex_unlock(&esperaSubir[parada_actual]);\n    pthread_mutex_unlock(&esperaBajar[parada_actual]);\n\n    estado = EN_RUTA;\n    printf(\"El bus est\u00e1 en ruta \\n\");\n}\n\nvoid Conducir_Hasta_Siguiente_Parada(){\n\n    \n    sleep((random() % 5)+1);\n    parada_actual = (parada_actual + 1) % N_PARADAS;\n}\n\nvoid Subir_Autobus(int id_usuario, int origen){\n\n\n    \n    pthread_mutex_lock(&esperaSubir[origen]);\n    esperando_parada[origen]++;\n\n    \n    while(parada_actual != origen || estado != EN_PARADA){\n        pthread_cond_wait(&suben, &esperaSubir[origen]);\n    }\n\n    \n    esperando_parada[origen]--;\n\n    \n    if(esperando_parada[origen] == 0)\n        pthread_cond_signal(&hanSubido);\n\n    printf(\"Usuario %d se sube en la parada %d \\n\", id_usuario, origen);\n    \n    \n    pthread_mutex_unlock(&esperaSubir[origen]);\n}\n\nvoid Bajar_Autobus(int id_usuario, int destino){\n\n\n    pthread_mutex_lock(&esperaBajar[destino]);\n    esperando_bajar[destino]++;\n\n    while(parada_actual != destino || estado != EN_PARADA){\n        pthread_cond_wait(&bajan, &esperaBajar[destino]);\n    }\n\n    esperando_bajar[destino]--;\n\n    if(esperando_bajar[destino] == 0)\n        pthread_cond_signal(&hanBajado);\n    \n    printf(\"Usuario %d se baja en la parada %d \\n\", id_usuario, destino);\n    pthread_mutex_unlock(&esperaBajar[destino]);\n}"}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid get_media(FILE *fd, char *tipo){\n    char cadena[100];\n    float suma = 0.1;\n    float num[50];\n\n    if(fd == NULL){\n        fputs(\"File error\", stderr);\n        exit(1);\n    }\n\n    char *eptr;\n    while(feof(fd) == 0){\n        \n        strcpy(cadena, fgets(cadena,100 ,fd));\n        float result = strtod(cadena, &eptr);\n        suma += result;\n    }\n\n    fclose(fd);\n\n    printf(\"%s: La media de los milisegundos es: %f\\n\",tipo, suma\/50);\n}\n\n\nint main(int argc, char** argv)\n{\n    FILE *fd;\n    fd = fopen(\"miliParalelo.txt\", \"r\");\n    get_media(fd, \"Paralelo\");\n\n    fd = fopen(\"mili.txt\", \"r\");\n    get_media(fd, \"Serie\");\n    \n    return 0;\n}"}
{"target":"bgmanuel99","func":"#include <mpi.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(int argc, char** argv)\n{\n    clock_t t_ini, t_fin;\n    double secs;\n\n    int nproc=50;\n    int myrank;\n\n    t_ini = clock();\n\n    MPI_Init(&argc,&argv);\n    \n    MPI_Comm_size (MPI_COMM_WORLD, &nproc);\n    MPI_Comm_rank (MPI_COMM_WORLD,&myrank);\n\n    printf(\"Hola mundo, soy el proceso %d de un total de %d \\n\",myrank,nproc);\n\n    MPI_Finalize();\n\n    t_fin = clock();\n\n    secs = (double)(t_fin - t_ini)\/ CLOCKS_PER_SEC;\n    printf(\"%.16g milisegundos\\n\", secs * 1000.0);\n    \n    return 0;\n}\n"}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <string.h>\n#include \"mpi.h\"\nint main(int argc, char **argv){\n\n int rank, count;\n char msg[20];\n MPI_Status status;   \n MPI_Init( &argc , &argv);\n MPI_Comm_rank( MPI_COMM_WORLD ,&rank);\n int i= 0;\n while(i<10){\n     if(rank==0){\n     strcpy(msg,\"Hello World\");\n     MPI_Send( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD);\n\n    MPI_Recv( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD , &status);\n            printf(\"Master: El mensaje es: %s\\n\",msg);\n\n\n     \n    }else\n    {\n        MPI_Recv( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD , &status);\n        printf(\"Secundario: El mensaje es: %s\\n\",msg);\n        strcpy(msg,\"Bye World\");\n        MPI_Send( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD);\n    }\n    i++;\n }\n    \n\n    MPI_Finalize();\n\n\n}"}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <mpi.h>\n \nint matriz[4][4] = {\n    {1,2,3,4},\n    {5,6,7,8},\n    {9,10,11,12},\n    {13,14,15,16}\n};\n\nint main(int argc, char* argv[]){\n    int size, rank, buffer[16];\n\n    MPI_Init(&argc, &argv);\n    \n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int my_row[4];\n    \n    for(int i = 0; i < 4; i++ ){\n        my_row[i] = matriz[i][rank];\n    }\n \n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n\n    if(rank==0){\n        for(int j = 0; j < 16; j++){\n            printf(\"%d \", buffer[j]);\n            if(j == 3 || j == 7 || j == 11) printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    MPI_Finalize();\n \n    return 0;\n}"}
{"target":"bgmanuel99","func":"#include <math.h>\n#include <mpi.h> \n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(int argc, char *argv[]) {\n    int rank, \n    size, \n    valor; \n    MPI_Status status; \n\n    MPI_Init(&argc, &argv); \n    \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    \n    srand(time(NULL));\n\n    if (rank == 0) {\n        valor = rand() % 4 + 1;\n        valor *= valor;\n    }\n\n    printf(\"[%d]: Antes del Bcast, el valor es %d \\n\", rank, valor);\n\n    MPI_Bcast(&valor, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    \n    printf(\"[%d]: Despues del Bcast, el valor es %d \\n\", rank, valor);\n\n    MPI_Finalize();\n\n    return 0;\n} "}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <string.h>\n#include \"mpi.h\"\n\nint main(int argc, char **argv){\n  MPI_Init(NULL, NULL);\n double A[10000];\n double B[10000];\n int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  if (world_size < 2) {\n    fprintf(stderr, \"World size must be greater than 1 for %s\\n\", argv[0]);\n    MPI_Abort(MPI_COMM_WORLD, 1);\n  }\n\n\n  if (world_rank != 0) {\n\n    int i = 0;\n\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] %d from process %d\\n\", world_rank, B[109],\n           world_rank - 1);\n  } else {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n  }\n\n  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,\n           MPI_COMM_WORLD);\n  \n  \n  \n  if (world_rank == 0) {\n    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] %d from process %i\\n\", world_rank, B[109],\n           1);\n  }\n  MPI_Finalize();\n\n\n\n}"}
{"target":"bgmanuel99","func":"#include <math.h>\n#include <mpi.h> \n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    int rank, \n    size; \n\n    MPI_Init(&argc, &argv); \n\n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n\n    int *buffer = NULL;\n    int localData;\n\n    if (rank == 0) {\n        buffer = malloc(size * sizeof(int));\n\n        for(int i = 0; i < size; i++){\n            buffer[i] = rank;\n        }\n\n        printf(\"El proceso %d contiene los datos: \", rank);\n        for(int i = 0; i < size; i++){\n            printf(\"%d, \", buffer[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    MPI_Scatter(buffer, 1, MPI_INT, &localData, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    printf(\"El proceso %d contiene el dato %d\\n\", rank, localData);\n    localData += rank;\n    printf(\"El proceso %d despues de sumar su indice al dato contiene ahora el dato %d\\n\", rank, localData);\n\n    MPI_Gather(&localData, 1, MPI_INT, buffer, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    if(rank == 0){\n        printf(\"Despues de los procesos de scatter y gather ahora el proceso %d contiene los datos: \", rank);\n        for(int i = 0; i < size; i++){\n            printf(\"%d, \", buffer[i]);\n        }\n        printf(\"\\n\");\n\n        free(buffer);\n    }\n\n    MPI_Finalize();\n\n    return 0;\n} "}
{"target":"bgmanuel99","func":"#include <mpi.h>\n#include <stdio.h>\n\nint main(int argc, char** argv){\n    int size, rank, value;\n    MPI_Status status;\n\n    MPI_Init(&argc,&argv);\n\n    MPI_Comm_size (MPI_COMM_WORLD, &size);\n    MPI_Comm_rank (MPI_COMM_WORLD, &rank);\n\n    if(rank == 0){\n        printf(\"Introduce el valor que quieres que se comunique: \");\n        scanf(\"%d\", &value);\n        printf(\"[%d]: envio el dato: %d a [%d]\\n\", rank, value, rank+1);\n        MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);\n    }else{\n        MPI_Recv(&value, 1, MPI_INT, rank-1, size, MPI_COMM_WORLD, &status);\n        if(rank < size-1) {\n            printf(\"[%d]: recibo el dato: %d de [%d] y lo envio a [%d]\\n\", rank, value, rank-1, rank+1);\n            MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);\n        }else{\n            printf(\"[%d]: recibo el dato: %d de [%d] y termino\\n\", rank, value, rank-1);\n        }\n    }\n\n    MPI_Finalize();\n    \n    return 0;\n}"}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <string.h>\n#include \"mpi.h\"\n\nint main(int argc, char **argv){\n  MPI_Init(NULL, NULL);\n double A[10000];\n double B[10000];\n int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n\n  if (world_rank != 0) {\n\n    int i = 0;\n\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] = %d from process %d\\n\", world_rank, B[109],\n           world_rank - 1);\n  } else {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n  }\n    printf(\"%d =>rank to : %d\\n\",world_rank,(world_rank + 1) % world_size);\n  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,\n           MPI_COMM_WORLD);\n\n  if (world_rank == 0) {\n    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] = %d \\n\", world_rank, 3);\n  }\n  MPI_Finalize();\n\n\n\n}"}
{"target":"bgmanuel99","func":"#include <math.h>\n#include <mpi.h> \n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    int rank, \n    size; \n\n    MPI_Init(&argc, &argv); \n\n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n\n    int localData[2];\n    int resultSum[2];\n    int resultProd[2];\n\n    for(int i = 0; i < 2; i++){\n        localData[i] = rank+1;\n    }\n\n    MPI_Reduce(localData, resultSum, 2, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    MPI_Reduce(localData, resultProd, 2, MPI_INT, MPI_PROD, 0, MPI_COMM_WORLD);\n\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    if(rank == 0){\n        printf(\"El resultado de la suma de los arrays es: %d, %d.\\n\", resultSum[0], resultSum[1]);\n        printf(\"El resultado del producto de los arrays es: %d, %d.\\n\", resultProd[0], resultProd[1]);\n    }\n\n    MPI_Finalize();\n\n    return 0;\n} "}
{"target":"bgmanuel99","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n\nvoid *func1 (void*);\nvoid *func2 (void*);\n\npthread_t thread1, thread2, thmain;\npthread_attr_t attr;\npthread_mutex_t mutex;\n\nint num1;\nint num2;\n\n\nvoid *func1 (void *arg){\n    \n    int suma = 1;\n    int size=(int) arg;\n    for(int i = 1; i < size; i++){\n        suma = suma * (int) arg;\n        arg--;\n    }\n    printf(\"Soy el thread 1 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    pthread_exit(NULL);\n}\n\nvoid *func2 (void *arg){\n    int err;\n    if(err = pthread_join(thread1, NULL)){\n        printf(\"Error al esperar a thread1 \\n \");\n    }else{\n        int suma = 1;\n        int size=(int) arg;\n        for(int i = 1; i < size; i++){\n            suma = suma * (int) arg;\n            arg--;\n        }\n        printf(\"Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    }\n    pthread_exit(NULL);\n}\n\nint main(void){\n    thmain = pthread_self();\n    \n    pthread_attr_init(&attr);\n\n    printf(\"Soy la funcion main y voy a lanzar los dos threads \\n\");\n\n    pthread_create(&thread1, &attr, func1, 4);\n    pthread_create(&thread2, &attr, func2, 5);\n\n    sleep(2);\n\n    printf(\"Soy main: he lanzado los dos threads y termino\\n\");\n\n    pthread_exit(NULL);\n}"}
{"target":"bgmanuel99","func":"#include <sys\/types.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main(int argc, char *argv[]){\n    pid_t pid1;\n    int status1=0,status2=0;\n    int my_pipe[2];\n\n\n    if (pipe(my_pipe)==-1){ \n        fprintf(stderr, \"Pipe Failed\" ); \n        return 1; \n    } \n    \n\n    if((pid1=fork())==0){\n        \n        close(my_pipe[0]);\n        printf(\"Child %d\\n\", getpid());\n\n        char buffer[240];\n        strcpy(buffer,\"Envio este mensaje a mi padre usando las pipes aprendidas en la practica 3\\n\");\n        write(my_pipe[1],&buffer,sizeof(buffer));\n        exit(EXIT_SUCCESS);\n        \n    }else{\n        \n            printf(\"Father%d\\n\", getpid());\n\n            waitpid(pid1,&status1,2);\n            close(my_pipe[1]);\n\n            char buffer[240];\n            \n            \n            read(my_pipe[0],buffer,sizeof(buffer));\n            printf(buffer);\n    }\n    return 0;\n}"}
{"target":"bgmanuel99","func":"#include <pthread.h> \n#include <stdio.h> \n#include <stdlib.h>\n\npthread_mutex_t count_mutex;\npthread_cond_t count_threshold_cv;\nint buffer[10]={0,0,0,0,0,0,0,0,0,0};\nvoid *productor(void *arg){\n    int i = 0;\n    printf(\"Lleno el buffer para mi consumidor\\n\");\n    pthread_mutex_lock(&count_mutex); \n    for(i; i < 10;i++ ){\n        buffer[i]=i+1;\n    }\n    printf(\"He terminado y permito a mi consumidor leer el buffer\\n\");\n    pthread_cond_signal(&count_threshold_cv);\n    pthread_mutex_unlock(&count_mutex);\n    sleep(1);\n    pthread_exit(NULL);\n}\n\nvoid *consumidor(void *arg){\nint i = 0;\n    printf(\"Voy a esperar a que se llenen los datos\\n\");\n    pthread_mutex_lock(&count_mutex);\n    pthread_cond_wait(&count_threshold_cv, &count_mutex); \n    printf(\"Voy a leer los datos y limpiar el buffer\\n\");\n    for(i; i < 10;i++ ){\n \n        printf(\"%d, \",buffer[i]);\n        buffer[i]=0;\n        pthread_mutex_unlock(&count_mutex);\n    }\n    printf(\"\\n\");\n    sleep(2);\n    pthread_exit(NULL);\n}\n\n\nint main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    pthread_attr_t attr;\n\n    pthread_mutex_init(&count_mutex, NULL);   \n    pthread_cond_init (&count_threshold_cv, NULL);\n\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    while(1){\n        pthread_create(&hilo1,&attr, *productor,NULL);\n        pthread_create(&hilo2,&attr, *consumidor,NULL);\n        pthread_join(hilo1,NULL);\n        pthread_join(hilo2,NULL);\n\n    }\n    pthread_attr_destroy(&attr);   \n    pthread_mutex_destroy(&count_mutex);   \n    pthread_cond_destroy(&count_threshold_cv);   \n    pthread_exit (NULL);\n    return 0;\n}\n"}
{"target":"bgmanuel99","func":"#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <pthread.h>\n#define MAXLON 1000\n\n\npthread_t thread1, thmain;\npthread_attr_t attr;\n\nvoid *cuenta (void *);\n\nvoid *cuenta (void *arg){\n    int pos, cont = 0, leidos;\n    char cadena[MAXLON];\n    int fd;\n\n    fd = open((char) arg, O_RDONLY);\n    while ((leidos = read(fd, cadena, MAXLON)) != 0)\n    {\n        for(pos = 0; pos < leidos; pos++){\n            if((cadena[pos] == 'a') || (cadena[pos] == 'A')) cont++;\n        }\n    }\n    printf(\"Fichero %s: %d caracteres 'a' o 'A' encontrados \\n\", (char) arg, cont);\n    close(fd);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]){\n    thmain = pthread_self();\n    \n    pthread_attr_init(&attr);\n\n    printf(\"Soy la funcion main y voy a lanzar un thread \\n\");\n\n    pthread_create(&thread1, &attr, cuenta,\"ejemplo.txt\");\n\n    sleep(2);\n    printf(\"Fichero ejemplo.txt: 30 caracteres 'a' o 'A' encontrados\\n\");\n\n    printf(\"Soy main: he lanzado un thread y termino\\n\");\n\n    pthread_exit(NULL);\n\n}"}
{"target":"bgmanuel99","func":"#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#include <semaphore.h>\n#include <string.h>\n\nint buffer[10]={0,0,0,0,0,0,0,0,0,0};\nsem_t semaforo;\n\nvoid *fhilo1(void *arg){\n    int i;\n\n    printf(\"\\nEstoy llenando el buffer \\n\");\n\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo);\n        \n        buffer[i] = i+1;\n        sem_post(&semaforo);\n    }\n\n    sleep(random()%3);\n    pthread_exit(NULL);\n}\nvoid *fhilo2(void *arg){\n    int i;\n\n    printf(\"\\nLos valores del buffer son: \\n\");\n\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo); \n        printf(\"%d, \",buffer[i]);\n        buffer[i] = 0;\n        sem_post(&semaforo);\n    }\n\n    sleep(random()%3);\n    printf(\"\\n\");\n\n    for(i = 0; i < 10; i++){\n        printf(\"%d, \",buffer[i]);\n    }\n    pthread_exit(NULL);\n}\n\nint main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    time_t t;\n    srandom(time(&t));\n\n    sem_init(&semaforo,0,10);\n\n    while(1){\n        pthread_create(&hilo1,NULL, *fhilo1,NULL);\n        pthread_create(&hilo2,NULL, *fhilo2,NULL);\n\n        if(buffer[0] == 0) pthread_join(hilo1,NULL);\n        else pthread_join(hilo2,NULL);\n    }\n    \n\n    sem_destroy(&semaforo);\n\n    return 0;\n}\n"}
{"target":"bgmanuel99","func":"#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <pthread.h>\n\npthread_mutex_t my_lock1, my_lock2, my_lock_main;\npthread_mutexattr_t attr;\n\nvoid *func1 (void *arg);\nvoid *func2 (void *arg);\n\nint aux[100];\n\nvoid *func1 (void *arg){\n    printf(\"He entrado en la func1\\n\");\n    if (pthread_mutex_init(&my_lock1, NULL) != 0) { \n        printf(\"\\nThread 1 mutex init has failed\\n\"); \n        return 1; \n    }\n\n    pthread_mutex_lock(&my_lock1);\n\n\n\n    printf(\"Soy el mutex thread y voy a introducir en aux todos 1\\n\");\n    for(int i = 0; i < 100; i++){\n        aux[i]=1;\n    }\n\n    printf(\"Thread 1:   El nuevo valor de aux es:\\n\");\n\n    for(int i = 0; i<100 ;i++){\n        printf(\"%d, \",aux[i]);\n    }\n\n    pthread_mutex_unlock(&my_lock1);\n    pthread_exit(NULL);\n}\n \nvoid *func2(void *arg){\n    printf(\"\\nHe entrado en la func2\\n\");\n        if (pthread_mutex_init(&my_lock2, NULL) != 0) { \n            printf(\"\\nThread 2 mutex init has failed\\n\"); \n            return 1;\n        }\n\n        pthread_mutex_lock(&my_lock2);\n\n        printf(\"Soy el mutex thread 2 y voy a introducir en aux todos 2\\n\");\n\n        for(int i = 0; i < 100; i++){\n            aux[i]=2;\n        }\n        \n        printf(\"Thread 2:   El nuevo valor de aux es:\\n\");\n\n        for(int i = 0; i<100 ;i++){\n            printf(\"%d, \",aux[i]);\n        }\n\n        pthread_mutex_unlock(&my_lock2);\n    \n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]){\n    if (pthread_mutex_init(&my_lock_main, NULL) != 0) { \n        printf(\"\\n Thread main mutex init has failed\\n\"); \n        return 1; \n    }\n    \n    pthread_attr_init(&attr);\n\n    pthread_create(&my_lock1, &attr, func1, NULL);\n    sleep(5);\n    pthread_create(&my_lock2, &attr, func2, NULL);\n\n    sleep(10);\n    \n    if(pthread_mutexattr_destroy(&my_lock_main) == 0){\n        printf(\"\\nSe ha destruido el main thread\\n\");\n    }\n}"}
{"target":"bgmanuel99","func":"#include <sys\/types.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n    int Par[10];\n    int Impar[10];\n\nint main(int argc, char *argv[]){\n    pid_t pid1, pid2;\n    int status1=0,status2=0;\n    int my_pipe[2];\n    int my_pipe2[2];\n\n\n    if (pipe(my_pipe2)==-1){ \n        fprintf(stderr, \"Pipe Failed\" ); \n        return 1; \n    } \n    if (pipe(my_pipe)==-1){ \n        fprintf(stderr, \"Pipe Failed\" ); \n        return 1; \n    } \n    \n\n    if((pid1=fork())==0){\n        \n        close(my_pipe[0]);\n        printf(\"Child %d\\n\", getpid());\n        int impar=1;\n        for(int i=0;i<10;i++){\n            Impar[i]=impar*impar;    \n            impar+=2;\n        }\n\n        write(my_pipe[1],&Impar,sizeof(Impar)+1);\n        exit(EXIT_SUCCESS);\n        \n    }else{\n        if((pid2=fork())==0){\n            \n            close(my_pipe2[0]);\n            printf(\"Child %d\\n\", getpid());\n            int par=2;\n            for(int i=0;i<10;i++){\n                Par[i]=par*par;\n                par+=2;\n            } \n            write(my_pipe2[1],&Par,sizeof(Par)+1);\n            \n            \n            exit(EXIT_SUCCESS);\n            \n        \n        }else{\n            printf(\"Father%d\\n\", getpid());\n\n            waitpid(pid1,&status1,2);\n            close(my_pipe[1]);\n\n            waitpid(pid2,&status2,2);\n            close(my_pipe2[1]);\n            \n           \n            int ParS[10];\n            int ImparS[10];\n            int Total[20];\n\n            \n            \n            read(my_pipe[0],ImparS,sizeof(ImparS));\n            read(my_pipe2[0],ParS,sizeof(ParS));\n\n            int indexImpar=0;\n            int indexPar=0;\n\n            \n\n            for(int i = 0; i < 20;){\n                Total[i]=ImparS[indexImpar];\n                i++;\n                indexImpar++;\n                Total[i]=ParS[indexPar];\n                i++;\n                indexPar++;\n            }\n\n            for(int i=0;i<20;i++) printf(\"%i \", Total[i]);\n            \n        }\n    }\n    return 0;\n}"}
{"target":"bgmanuel99","func":"#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char const *argv[])\n{\n    pid_t pid, pid1, pid2, pid3;\n\n    for(int i = 0; i < 4 ; i++){ \n        switch (pid = fork())\n        {\n        case 0:\n            printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n            if(i==0||i==1){\n                for(int j = 0; j < 2; j++){ \n                    switch(pid1 = fork()){\n                    case 0:\n                        printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                        \n                        if(j == 0){\n                            switch(pid3 = fork()){\n                            case 0:\n                                printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                                break;\n                            case -1:\n                                printf(\"ERROR\");\n                                exit(-1);\n                            default:\n                                break;\n                            }\n                            if(pid3 == 0) break;\n                        }\n                        break;\n                    case -1:\n                        printf(\"ERROR\");\n                        exit(-1);\n                    default:\n                        break;\n                    }\n                    if(pid1 == 0) break;\n                }\n            }else if(i==2){\n                \n                switch(pid2 = fork())\n                {\n                case 0:\n                    printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                    break;\n                case -1:\n                    printf(\"ERROR\");\n                    exit(-1);\n                default:\n                    break;\n                }\n                if(pid2 == 0) break;\n            }\n            break;\n        case -1:\n            printf(\"ERROR\");\n            exit(-1);\n        default:\n            break;\n        }\n        if(pid == 0) break;\n    }\n\n    \n\n    return 0;\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct myArray{\n     int totalSize;\n     int usedSize;\n     int *ptr; \n\n};\n\nvoid createArray(struct myArray * a, int tSize, int uSize){\n\n     \n     \n     \n     \n\n     a->totalSize = tSize; \n     a->usedSize = uSize; \n     a->ptr = (int *) malloc(tSize*sizeof(int)); \n}\n\nvoid show(struct myArray *a){\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"%d\\n\", (a->ptr)[i]);\n     }\n   \n}\n\nvoid setVal(struct myArray *a){\n     int n;\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"Enter element %d: \", i);\n          scanf(\"%d\", &n);\n          (a->ptr)[i] = n;\n     }\n   \n}\n\nint main(){\n     struct myArray marks;\n     createArray(&marks, 100, 2);\n     \n     printf(\"We are running setVal function now.\\n\");\n     setVal(&marks);\n     printf(\"We are running show function now.\\n\");\n     show(&marks);\n\n     return 0;\n}"}
{"target":"chandanXP","func":"\n#include<stdio.h>\n#include<stdlib.h>\n\n\nstruct Node{\n     int data;\n     struct Node*left;\n     struct Node*right;\n     };\n\nstruct Node*create(int x){\n     struct Node*temp=(struct Node*)malloc(sizeof(struct Node));\n     temp->data=x;\n     temp->left=NULL;\n     temp->right=NULL;\n}\n\n\nvoid inOrderTraversal(struct Node *root){\n     if(root==NULL){\n          return;\n     }else{\n          inOrderTraversal(root->left);\n          printf(\"%d \",root->data);\n          inOrderTraversal(root->right);\n          return;\n     }\n}\n\n\nstruct Node*insert(struct Node*root, int value){\n     if(root==NULL){\n          root = create(value);\n     }\n     else if(value<root->data){\n          root->left = insert(root->left, value);\n     }\n     else if (value > root->data){\n          root->right = insert(root->right, value);\n     }\n\n     \n     else{\n          printf(\"\\nValue: %d you enterd is already exist\\n\", value);\n     }\n\n     return root;\n}\n\nstruct Node*findMinimum(struct Node*root){\n     \n     if(root==NULL){\n          return NULL;\n     }\n     else if(root->left!=NULL){\n          return findMinimum(root->left);\n     }\n     return root;\n}\nstruct Node*delete(struct Node*root, int value){\n     if(root==NULL){\n          printf(\"\\nValue: %d is not present or the tree is empty!\\n\", value);\n          return NULL;\n     }\n     else if(value<root->data){\n          root->left = delete(root->left, value);\n     }\n     else if(value>root->data){\n          root->right= delete(root->right, value);\n     }\n     else{\n          \n          if(root->left == NULL && root->right==NULL){\n               \n               free(root);\n               return NULL;\n          }\n          \n          else if(root->left ==NULL || root->right==NULL){\n               \n               \n               struct Node*temp=root;\n               if(root->left==NULL){\n                    root=root->right;\n               }\n               else{\n                    root=root->left;\n               }\n               free(temp);\n               \n          }\n          \n          else{\n               \n               \n               struct Node*temp = findMinimum(root->right);\n               root->data=temp->data;\n               \n\n               root->right= delete(root->right, temp->data);\n\n          }\n     }\n     return root;\n}\n\nstruct Node*verify(struct Node*root, int value){\n     if(root==NULL){\n          printf(\"\\nThe Tree maybe Empty or value is not present...\\n\");\n          return root;\n     }\n     else if(value<root->data){\n          root->left= verify(root->left, value);\n     }\n     else if(value>root->data)\n     {\n          root->right= verify(root->right, value);\n     }\n     else if(root->data==value){\n          printf(\"\\nThe value you mentioned is present in this tree..(value: %d)\\n\", root->data);\n     }\n     else{\n          printf(\"\\nValue you entered is no present..\\n\");\n     }\n     return root;\n     \n}\n\nint main(){\n     \n     struct Node*root=NULL;\n     \n     root=create(10);\n     \n     insert(root, 5);\n     insert(root, 7);\n     insert(root, 13);\n     insert(root, 1);\n     insert(root, 49);\n     insert(root, 50);\n     insert(root, 35);\n     insert(root, 8);\n     insert(root, 8);\n\n     delete(root,49);\n     delete(root,99);\n\n     verify(root, 70);\n\n     printf(\"\\n--inOrder Traversal--\\n\");\n     inOrderTraversal(root);\n\n     return 0;\n}"}
{"target":"chandanXP","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node\n{\n     int data;          \n     struct Node *next; \n};\n\nvoid linkedListTraversal(struct Node *head)\n{\n     struct Node *ptr = head;\n     do\n     {\n          printf(\"Element is : %d\\n\", ptr->data);\n          ptr = ptr->next;\n     } while (ptr != head);\n}\n\nstruct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     \n     p->next = ptr;\n     ptr->next = head;\n     return head;\n}\n\nstruct Node *insertAtTheIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *q = head;\n     int i = 0;\n     while (i != index - 1)\n     {\n          q = q->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = q->next;\n     q->next = ptr;\n     return head;\n}\n\nstruct Node *insertAtTheFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     \n     ptr->next = p->next;\n     p->next = ptr;\n     return ptr;\n}\n\nstruct Node *deleteFirst(struct Node *head)\n{\n     struct Node *ptr = head;\n     \n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     head = head->next; \n     p->next = head;    \n     free(ptr);         \n     return head;       \n}\n\nstruct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n\n     while (q->data != value) \n     {\n          p = p->next;\n          q = q->next;\n     }\n\n     if (q->data == value) \n     {\n          p->next = q->next; \n          free(q);           \n     }\n\n     return head;\n}\n\nstruct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != head)\n     { \n          p = p->next;\n          q = q->next;\n     }\n     p->next = head; \n     free(q);        \n     return head;    \n}\n\nint main()\n{\n     \n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n\n     \n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n\n     \n     head->data = 7;\n     head->next = second;\n\n     \n     second->data = 11;\n     second->next = third;\n\n     \n     third->data = 70;\n     third->next = fourth;\n\n     \n     fourth->data = 22;\n     fourth->next = head;\n\n     linkedListTraversal(head);\n\n     \n\n     head = insertAtEnd(head, 54);\n     printf(\"---List After Insertion---\\n\");\n     linkedListTraversal(head);\n\n     \n     \n     \n\n     \n     \n     \n\n     \n     \n     \n\n     \n     \n     \n\n     \n     \n     \n\n     return 0;\n}\n\n\n\n\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\n\nstruct Node{\n     int data;\n     struct Node *next;\n};\n\nvoid linkedListtraversal(struct Node*ptr){\n     while(ptr!=NULL){\n          printf(\"%d\\n\", ptr->data);\n          ptr=ptr->next;\n     }\n\n}\n\nstruct Node * deleteByInfo(struct Node*head, int value){\n     struct Node*ptr=head;\n     struct Node*q=head->next;\n     while(q->data!=value){\n          ptr=ptr->next;\n          q=q->next;\n     };\n     ptr->next=q->next;\n     free(q);\n     return head; \n}\n\nint main(){\n\n     struct Node*head,\n     *second,\n     *third, \n     *fourth, \n     *fifth, \n     *sixth, \n     *seventh;\n\n     head= (struct Node*)malloc(sizeof(struct Node));\n     second = (struct Node*)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node*)malloc(sizeof(struct Node));\n     fifth = (struct Node*)malloc(sizeof(struct Node));\n     sixth = (struct Node*)malloc(sizeof(struct Node));\n     seventh = (struct Node*)malloc(sizeof(struct Node));\n \n     head->data =100;\n     head->next = second;\n\n     second->data= 200;\n     second->next= third;\n\n     third->data=300;\n     third->next=fourth;\n\n     fourth->data=400;\n     fourth->next=fifth;\n\n     fifth->data=500;\n     fifth->next= sixth;\n\n     sixth->data=600;\n     sixth->next=seventh;\n\n     seventh->data=700;\n     seventh->next=NULL;\n\n     linkedListtraversal(head);\n\n     head = deleteByInfo(head, 300);\n\n     linkedListtraversal(head);\n\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node\n{\n     int data;\n     struct Node *next;\n};\n\nvoid linkedListTreversal(struct Node*ptr){\n     while (ptr!=NULL)\n     {\n          printf(\"Element : %d\\n\", ptr->data);\n          ptr=ptr->next;\n     }\n     \n\n}\n\nstruct Node *reversedList(struct Node *head){\n     struct Node *p = head;\n     printf(\"%d\\n\", p->data);\n     struct Node *q = head->next;\n     printf(\"%d\\n\", q->data);\n     head=head->next;\n     printf(\"%d\\n\", head->data);\n     p->next=NULL;\n     while (q->next!=NULL)\n     {\n          \n\n          head=head->next;\n          printf(\"b\\n\");\n\n          \n          \n\n          q=q->next;\n          printf(\"d\\n\");\n\n          p=q->next;\n          printf(\"a\\n\");\n\n     }\n     return head;\n      \n     \n};\n\n\nint main(){\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n\n     head->data=100;\n     head->next=second;\n\n     second ->data=200;\n     second->next=third;\n\n     third->data=300;\n     third->next=fourth;\n\n     fourth->data=400;\n     fourth->next=NULL;\n\n     printf(\"---Linked list before reverse---\\n\");\n     linkedListTreversal(head);\n     head = reversedList(head);\n     printf(\"%d\\n\", head->data);\n     printf(\"---Linked list after reverse---\\n\");\n     linkedListTreversal(head);\n \n     return 0;\n}\n\n\n\n"}
{"target":"chandanXP","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node\n{\n     int data;          \n     struct Node *next; \n     struct Node *prev; \n};\n\nint Traversal(struct Node *ptr)\n{\n     while (ptr != NULL)\n     {\n          printf(\"Element: %d\\n\", ptr->data);\n          ptr = ptr->next;\n     }\n}\n\n\nstruct Node *insertAtFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     head->prev = ptr;\n     ptr->prev = NULL;\n     return ptr;\n};\n\n\nstruct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     p->next->prev = ptr;\n     ptr->prev = p;\n     return head; \n};\n\n\nstruct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     ptr->data = data;\n     p->next = ptr;\n     ptr->next = NULL;\n     ptr->prev = p;\n\n     return head;\n};\n\n\n\n\n\nstruct Node *deleteFirst(struct Node *head)\n{\n     struct Node *ptr = head;\n     head = head->next;\n     head->prev = NULL;\n     free(ptr);\n     return head;\n}\n\n\nstruct Node *deleteInBetween(struct Node *head, int index)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     for (int i = 0; i < index - 1; i++)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = q->next;\n     q->next->prev = p;\n     free(q);\n     return head;\n}\n\n\nstruct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n}\n\nint main()\n{\n     \n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n\n     \n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n\n     \n     head->data = 7;\n     head->next = second;\n     head->prev = NULL;\n\n     \n     second->data = 11;\n     second->next = third;\n     second->prev = head;\n\n     \n     third->data = 70;\n     third->next = fourth;\n     third->prev = second;\n\n     \n     fourth->data = 22;\n     fourth->next = NULL;\n     fourth->prev = third;\n\n     Traversal(head); \n\n     \n     \n     \n\n     \n     \n     \n\n     \n     \n     \n\n     \n\n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     \n     head = deleteLastNode(head);\n     printf(\"---After deletion---\\n\");\n     Traversal(head);\n\n     return 0;\n}\n\n\n\n\n\n\n\n\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct stack{\n     int size;\n     char top;\n     char *arr;\n};\n\nint isFull(struct stack*ptr){\n     if(ptr->top == ptr->size-1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nint stackTop(struct stack*sp){\n    return sp->arr[sp->top];\n}\n\nint isEmpty(struct stack*ptr){\n     if(ptr->top == -1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nchar push(struct stack*ptr, char val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n        \n    }\n}\n\nchar pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n        \n    }\n}\n\nint precedence(char ch){\n     if(ch == '*' || ch=='\/'){\n          return 3;\n     }\n     else if(ch=='+' || ch=='-')\n          return 2;\n     else\n          return 0;\n     \n}\nint isOperator(char ch){\n     if(ch=='+' || ch=='-' || ch=='*' || ch=='\/'){\n          return 1;\n     }\n     else\n          return 0;\n\n}\n\nchar*infixToPostfix(char* infix){\n     struct stack *sp = (struct stack *)malloc(sizeof(struct stack));\n     sp->size = 100;\n     sp->top = -1;\n     sp->arr = (char*)malloc(sp->size * sizeof(char));\n     char *postfix = (char *)malloc((strlen(infix)+1)* sizeof(char));\n     int i = 0;\n     int j = 0;\n     while(infix[i]!='\\0'){\n          if(!isOperator(infix[i])){\n               postfix[j]=infix[i];\n               j++;\n               i++;\n          }\n          else{\n               if(precedence(infix[i])> precedence(stackTop(sp))){\n                    push(sp, infix[i]);\n                    i++;\n\n               }\n               else\n               {\n                    postfix[j]=pop(sp);\n                    j++;\n\n               }\n             \n          }\n          while(!isEmpty(sp)){\n               postfix[j]=pop(sp);\n               j++;\n\n\n          }\n          postfix[j]='\\0';\n          return postfix;\n     }\n\n}\n \n\nint main(){\n     char * infix = \"a-b+t\/6\";\n     printf(\"postfix is %s\", infixToPostfix(infix));\n\n     \n\n  \n     return 0;\n}\n"}
{"target":"chandanXP","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <string.h>\n \nvoid main()\n{\n    int i, j, count = 0, pos, flag = 0;\n    char s1[100], s2[10], s3[100];\n    char *ptr1, *ptr2, *ptr3;\n \n    printf(\"\\nenter the String:\");\n    scanf(\" %[^\\n]s\", s1);\n    printf(\"\\nenter the string to be inserted:\");\n    scanf(\" %[^\\n]s\", s2);\n    printf(\"\\nenter the position you like to insert:\");\n    scanf(\"%d\", &pos);\n \n    ptr1 = s1;\n    ptr3 = s3;\n    \n    for (i = 0, j = 0;*ptr1 != '\\0'; ptr1++, i++, j++, ptr3++)\n    {\n        s3[j] = s1[i];\n        if (*ptr1 == ' ' && flag != 1)\n            ++count;\n        if (flag != 1 && count == pos - 1)\n        {\n            flag = 1;\n            for(ptr2 = s2;*ptr2 != '\\0'; ptr2++)\n            {\n                s3[++j] = *ptr2;\n                ptr3++;\n            }\n            s3[++j] = ' ';\n            ptr3++;\n        }\n    }\n    s3[j] = '\\0';\n    printf(\"\\nthe string after modification is\\n\\n %s\\n\", s3);\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n\nint display(int arr[], int n)\n{\n     for(int i = 0; i < n; i++){\n          printf(\"%d \",arr[i]);\n     }\n     printf(\"\\n\");\n}\n\nint indInsertion(int arr[], int size, int element, int capacity, int index){ \n     if(size >= capacity){\n          printf(\"Insertion failed!\");\n          return 0;\n     }\n     for(int i = size-1; i >= index; i-- ){\n          arr[i+1] = arr[i];\n     }\n     arr[index] = element;\n     size +=1;\n     display(arr, size);\n     \n}\n\nint main(){\n     int arr[100] = {7, 8, 12, 27, 88};\n     int size = 5, element = 40, index = 3;\n     display(arr, size);\n     indInsertion(arr, size, element, 100, index);\n     \n \n     return 0;\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct InsertionAtGiven\n{\n     int data;\n     struct InsertionAtGiven *next;  \n};\n\nvoid listTravesal(struct InsertionAtGiven*ptr){\n     \n\n     while (ptr!=NULL)\n     {\n          printf(\"%d\\n\", ptr->data);\n          ptr=ptr->next;\n     }\n   \n}\n\nstruct InsertionAtGiven* insertAfterValue(struct InsertionAtGiven*head, int info, int value){\n     struct InsertionAtGiven*ptr=head;\n     struct InsertionAtGiven*q= head->next;\n     struct InsertionAtGiven*insert;\n     insert->data=value;\n\n     while (ptr->data!=info)\n     {\n         ptr=ptr->next;\n         q=q->next;\n\n     }\n     ptr->next=insert;\n     insert->next=q;\n     return head;\n      \n}\n\nint main(){\n     struct InsertionAtGiven*head,\n     *second,\n     *third,\n     *fourth,\n     *fifth;\n\n     head = (struct InsertionAtGiven * )malloc(sizeof(struct InsertionAtGiven));\n     second = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n     third = (struct InsertionAtGiven *)malloc(sizeof( struct InsertionAtGiven));\n     fourth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n     fifth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n\n     head->data=100;\n     head->next=second;\n\n     second->data=200;\n     second->next=third;\n\n     third->data=300;\n     third->next=fourth;\n\n     fourth->data=400;\n     fourth->next=NULL;\n\n\n     listTravesal(head);\n\n     head = insertAfterValue(head, 200, 550);\n\n     listTravesal(head);\n\n  \n     return 0;\n}\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n\nint linearSearch(int arr[], int size, int element){\n     for (int i =0; i < size; i++){\n          if(arr[i]== element){\n               return 1;\n          }\n     }\n     return -1;\n}\n\nint binarySearch(int arr[], int size, int element){\n     int low,mid,high;\n     low=0;\n     high = size-1;\n     \n     while(low<=high){\n          mid = (low+high)\/2; \n          if(arr[mid]==element){\n               return mid;\n          }\n          if(arr[mid]<element){\n               low=mid+1;\n               \n          }\n          else{\n               high = mid-1;\n          }\n     \n     }\n     return -1;\n\n}\n\n\nint main(){\n     \n     \n     \n\n     \n     int arr[] = {1,3,5,7,9,56,574,594,599,632};\n     int size = sizeof(arr)\/sizeof(int);\n\n     int element = 6;\n     \n     int searchIndex = binarySearch(arr,size,element);\n\n     printf(\"The element %d was found at index %d \\n\", element, searchIndex);\n     return 0;\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node{\n     int data;\n     struct Node *next;\n\n};\nvoid linkedListTraversal(struct Node*ptr){\n     while(ptr!=NULL){\n          printf(\"Element: %d\\n\",ptr->data);\n          ptr=ptr->next;\n          \n     }\n};\n\n\nstruct Node * insertAtFirst(struct Node *head, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     return ptr;\n\n};\n\n\nstruct Node * insertAtIndex(struct Node *head, int data, int index){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     struct Node * p = head;\n     int i = 0;\n     while (i!=index-1)\n     {\n          p = p->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head;\n      \n};\n\n\nstruct Node * insertAtEnd(struct Node *head, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node * p = head; \n     while (p->next != NULL)\n     {\n         p = p->next;  \n     }\n     p->next =ptr;\n     ptr->next= NULL;\n     return head;\n    \n};\n\nstruct Node * insertAfterNode(struct Node *head, struct Node *previousNode, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->data = data;\n     ptr->next = previousNode->next;\n     previousNode->next = ptr;\n     return head;\n\n \n};\n\nint main(){\n     \n     struct Node*head;\n     struct Node*second;\n     struct Node*third;\n     struct Node*fourth;\n \n     \n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n\n     \n     head->data=7;\n     head->next=second;\n\n     \n     second->data=11;\n     second->next=third;\n\n     \n     third->data=70;\n     third->next=fourth;\n\n     \n     fourth->data=22;\n     fourth->next=NULL;\n\n     printf(\"\\nLinked list before insertion\\n\");\n     linkedListTraversal(head);\n     \n     \n     \n     head= insertAfterNode(head, second, 45);\n     printf(\"\\nLinked list after insertion\\n\");\n\n\n     linkedListTraversal(head);\n\n     return 0;\n}\n\n\n\n\n"}
{"target":"chandanXP","func":"\n\n#include<stdio.h>  \n#include<stdlib.h>\n\ntypedef struct Node \n{\n        int data; \n        struct Node *next; \n}node;\n\nstruct Node * insert(struct Node *head, int data, int index){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     struct Node * p = head;\n     int i = 0;\n     while (i!=index-1)\n     {\n          p = p->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head;\n\n};\n\nint find(node *ptr, int key)\n{\n        node *start = ptr;\n        ptr =  ptr -> next; \n        \n        while(ptr!=start)\n        {\n                if(ptr->data == key) \n                {\n                        return 1;\n                }\n                ptr = ptr -> next;  \n        }\n        \n        return 0;\n}\nstruct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n\n     return head;\n}\n\nvoid print(node *start,node *ptr)\n{\n        if(ptr==start)\n        {\n                return;\n        }\n        printf(\"%d \",ptr->data);\n        print(start,ptr->next);\n}\nint main()\n{\n        \n        node *start,*temp, *Head; \n        start = (node *)malloc(sizeof(node)); \n        temp = start;  \n        temp -> next = start; \n\n \n        printf(\" Linked List Example\\n\");\n        printf(\"Choose List operation \");\n           \n        printf(\"1. Insert\\n\");\n        printf(\"2. Delete\\n\");\n        printf(\"3. Print\\n\");\n        printf(\"4. Find\\n\");\n        printf(\"5. EXIT\\n\");\n\n        \n        \n\n while(1)\n        {\n                printf(\" Press your choice \\n\"); \n\n                int choice;  \n                scanf(\"%d\",&choice); \n\n                if(choice==1) \n                {\n                        int data;\n                        printf(\"The Element to be inserted in the list is: \");\n                        scanf(\"%d\",&data);\n                        insert(struct node *start, int data, int index);\n                }\n                else if(choice==2)\n                {\n                        int data;\n                        printf(\"The Element to be deleted from the list is: \");\n                        scanf(\"%d\",&data);\n                        delete(start,data);   \n                }\n                else if(choice==3)\n                {\n                        printf(\"The list is \");\n                        print(start,start->next);   \n                        printf(\"\\n\");\n                }\n                else if(choice==4)\n                {\n                        int data;\n                        printf(\"The Element is to be searched in the list is: \");\n                        scanf(\"%d\",&data);\n                        int status = find(start,data);    \n                        if(status)\n                        {\n                                printf(\"Element Found\\n\");\n                        }\n                        else\n                        {\n                                printf(\"Element Not Found\\n\");\n                        }\n                }\n        else\n                    break;\n        }\n}\n\n"}
{"target":"chandanXP","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node\n{\n     int data;          \n     struct Node *next; \n};\nvoid linkedListTraversal(struct Node *ptr)\n{\n     while (ptr != NULL)\n     {\n          printf(\"Element: %d\\n\", ptr->data);\n          ptr = ptr->next;\n     }\n};\n\n\nstruct Node *insertAtFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     return ptr;\n};\n\n\nstruct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head; \n};\n\n\nstruct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     p->next = ptr;\n     ptr->next = NULL;\n     return head; \n};\n\nstruct Node *insertAfterNode(struct Node *head, struct Node *previousNode, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     ptr->next = previousNode->next;\n     previousNode->next = ptr;\n     return head; \n};\n\n\nstruct Node *deleteFirst(struct Node *head)\n{\n     struct Node *ptr = head;\n     head = head->next;\n     free(ptr);\n     return head;\n}\n\nstruct Node *deleteInBetween(struct Node *head, int index)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     for (int i = 0; i < index - 1; i++)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = q->next;\n     free(q);\n     return head;\n}\n\nstruct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n}\n\nstruct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n\n     while (q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n\n     return head;\n}\n\nint main()\n{\n     \n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n\n     \n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n\n     \n     head->data = 7;\n     head->next = second;\n\n     \n     second->data = 11;\n     second->next = third;\n\n     \n     third->data = 70;\n     third->next = fourth;\n\n     \n     fourth->data = 22;\n     fourth->next = NULL;\n\n     printf(\"\\nLinked list before insertion\\n\");\n     linkedListTraversal(head);\n     \n     \n     \n     head = insertAfterNode(head, second, 45);\n     printf(\"\\nLinked list after insertion\\n\");\n     linkedListTraversal(head);\n\n     \n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     return 0;\n}\n\n\n\n\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node{\n     int data;\n     struct Node *next;\n\n};\nvoid linkedListTraversal(struct Node*ptr){\n     while(ptr!=NULL){\n          printf(\"Element: %d\\n\",ptr->data);\n          ptr=ptr->next;\n     }\n}\nstruct Node * deleteFirst(struct Node * head){\n     struct Node * ptr = head;\n     head = head->next;\n     free(ptr);\n     return head;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nstruct Node * deleteInBetween(struct Node * head, int index){\n     struct Node *p =head;\n     struct Node *q = head->next;\n     for (int i=0; i<index-1; i++){\n          p= p->next;\n          q=q->next;\n     }\n     p->next=q->next;\n     free(q);\n     return head;\n\n}\n\nstruct Node * deleteLastNode(struct Node * head){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while(q->next != NULL){\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n\n}\n\nstruct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n      \n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     \n     return head;\n}\n\nint main(){\n     \n     struct Node*head;\n     struct Node*second;\n     struct Node*third;\n     struct Node*fourth;\n     struct Node*fifth;\n     struct Node*sixth;\n     struct Node*seventh;\n \n     \n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n     fifth = (struct Node *) malloc(sizeof(struct Node));\n     sixth = (struct Node *) malloc(sizeof(struct Node));\n     seventh = (struct Node *) malloc(sizeof(struct Node));\n\n     \n     head->data=7;\n     head->next=second;\n\n     \n     second->data=11;\n     second->next=third;\n\n     \n     third->data=70;\n     third->next=fourth;\n\n     \n     fourth->data=22;\n     fourth->next=fifth;\n\n      \n     fifth->data=44;\n     fifth->next=sixth;\n\n      \n     sixth->data=20;\n     sixth->next=seventh; \n\n     \n     seventh->data=100;\n     seventh->next=NULL;\n\n     linkedListTraversal(head);\n\n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     \n     \n     \n     \n\n     \n     head = deleteByGivenKey(head, 70);\n     printf(\"---After deletion---\\n\");\n     linkedListTraversal(head);\n\n     return 0;\n}\n\n\n\n\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node{\n     int data;\n     struct Node *next;\n\n};\nvoid linkedListTraversal(struct Node*ptr){\n     while(ptr!=NULL){\n          printf(\"Element: %d\\n\",ptr->data);\n          ptr=ptr->next;\n     }\n}\n\nint main(){\n     \n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n \n     \n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n\n\n     \n     head->data=7;\n     head->next=second;\n\n     \n     second->data=11;\n     second->next=third;\n\n     \n     third->data=70;\n     third->next=fourth;\n\n     \n     fourth->data=22;\n     fourth->next=NULL;\n\n     linkedListTraversal(head);\n\n     return 0;\n}\n\n\n\n\n"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct stack{\n     int size;\n     char top;\n     char *arr;\n};\n\nint isFull(struct stack*ptr){\n     if(ptr->top == ptr->size-1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nint isEmpty(struct stack*ptr){\n     if(ptr->top == -1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nchar push(struct stack*ptr, char val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n        \n    }\n}\n\nchar pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n        \n    }\n}\n\nint match(char a, char b){\n     if (a=='{' && b=='}' )\n     {\n          return 1;\n     }\n\n     if (a=='[' && b==']' )\n     {\n          return 1;\n     }\n\n     if (a=='(' && b==')' )\n     {\n          return 1;\n     }\n     return 0;\n}\n\n\nint parenthesisMatch(char*exp){\n     \n     struct stack* sp;\n     sp->size=100;\n     sp->top= -1;\n     sp->arr = (char*)malloc(sp->size * sizeof(char));\n\n     char popped_ch;\n\n     for (int i = 0; exp[i]!='\\0'; i++)\n     {\n          if (exp[i]=='(' || exp[i]=='[' || exp[i]=='{' )\n          {\n               push(sp, exp[i]);\n          }\n          else if (exp[i]==')' || exp[i]=='}' || exp[i]==']')\n          {\n               if (isEmpty(sp))\n               {\n                    return 0;\n               }\n               popped_ch = pop(sp);\n               if(!match(popped_ch, exp[i])){\n                    return 0;\n               }\n          }\n          \n     }\n     if (isEmpty(sp))\n     {\n          return 1;\n     }\n     else{\n          return 0;\n     }\n     \n     \n}\n\nint main(){\n     \n     \n     char*exp = \"(8*{19*(4-2)*([9-7]})\";\n\n     \n     if(parenthesisMatch(exp)){\n          printf(\"The Parenthesis are balanced.\\n\");\n     }\n     else{\n          printf(\"The Parenthesis are not balanced.\\n\");\n     }\n\n  \n     return 0;\n}\n\n "}
{"target":"chandanXP","func":"\n#include <stdio.h>\n#include<stdlib.h>\n\nstruct stack{\n    int size;\n    int top;\n    int *arr;\n};\n\nint isEmpty(struct stack*ptr){\n    if(ptr->top== -1){\n        printf(\"Stack is empty..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n    \n}\nint isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        \n        return 0;\n    }\n    \n}\n\nvoid push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n        \n    }\n}\n\nint pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n        \n        \n    }\n}\n\nint peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n        \n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}\n\nint main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    \n    \n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    \n    printf(\"Popped %d from the stack\\n\", pop(sp));\n     \n    \n    for(int j=1; j <= sp->top + 1; j++){\n        printf(\"The value at position %d is %d\\n\",j,peek(sp, j));\n    }\n\n    return 0;\n}"}
{"target":"chandanXP","func":"#include <stdio.h>\n#include<stdlib.h>\n\nstruct stack{\n    int size;\n    int top;\n    int *arr;\n};\n\nint isEmpty(struct stack*ptr){\n    if(ptr->top== -1){\n        printf(\"Stack is empty..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n    \n}\nint isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        \n        return 0;\n    }\n    \n}\n\nvoid push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n        \n    }\n}\n\nint pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n        \n        \n    }\n}\n\n\nint main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    \n    \n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46);\n    \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    printf(\"Popped %d from the stack\\n\", pop(sp)); \n     \n    \n\n    return 0;\n}"}
{"target":"chandanXP","func":"#include <stdio.h>\n#include<stdlib.h>\n\nstruct stack{\n    int size;\n    int top;\n    int *arr;\n};\n\nint isEmpty(struct stack*ptr){\n    if(ptr->top== -1){\n        printf(\"Stack is empty..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n    \n}\nint isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        \n        return 0;\n    }\n    \n}\n\nvoid push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n        \n    }\n}\n\nint pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n        \n        \n    }\n}\n\nint peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n        \n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}\n\nint stackTop(struct stack*sp){\n    return sp->arr[sp->top];\n}\n\nint stackBottom(struct stack* sp){\n    return sp->arr[0];\n}\n\nint main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    \n    \n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    \n    \n    printf(\"Popped %d from the stack\\n\", pop(sp));\n     \n    \n    \n    \n    \n    \n    printf(\"The top most value of this stack is %d\\n\", stackTop(sp));\n    \n     printf(\"The bottom most value of this stack is %d\\n\", stackBottom(sp));\n    \n\n    return 0;\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct stack{\n     int size;\n     int top;\n     int *arr;\n};\n\nint isFull(struct stack*ptr){\n     if(ptr->top == ptr->size-1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nint isEmpty(struct stack*ptr){\n     if(ptr->top == -1){\n          return 1;\n     }\n     else{\n          return 0;\n     }\n\n}\n\nint main(){\n\n     \n     \n     \n     \n\n     struct stack * s;\n     s->size = 80;\n     s->top = -1;\n     s->arr = (int*)malloc(s->size*sizeof(int));\n\n     \n     s->arr[0]= 7;\n     s->top++;\n\n     \n     if(isEmpty(s)){\n          printf(\"The stack is empty..\\n\");\n     }\n     else{\n          printf(\"The stack is not empty..\\n\");\n     }\n\n  \n     return 0;\n}"}
{"target":"chandanXP","func":"#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data; \n    struct node *right_child; \n    struct node *left_child; \n};\n\nstruct node* search(struct node *root, int x)\n{\n    if(root==NULL || root->data==x) \n        return root;\n    else if(x>root->data) \n        return search(root->right_child, x);\n    else \n        return search(root->left_child,x);\n}\n\n\nstruct node* find_minimum(struct node *root)\n{\n    if(root == NULL)\n        return NULL;\n    else if(root->left_child != NULL) \n        return find_minimum(root->left_child); \n\n    return root;\n}\n\n\nstruct node* new_node(int x)\n{\n    struct node *p;\n    p = malloc(sizeof(struct node));\n    p->data = x;\n    p->left_child = NULL;\n    p->right_child = NULL;\n\n    return p;\n}\n\nstruct node* insert(struct node *root, int x)\n{\n    \n    if(root==NULL)\n        return new_node(x);\n    else if(x>root->data) \n        root->right_child = insert(root->right_child, x);\n    else \n        root->left_child = insert(root->left_child,x);\n    return root;\n}\n\n\nstruct node* delete(struct node *root, int x)\n{\n    \n    if(root==NULL)\n        return NULL;\n    if (x>root->data)\n        root->right_child = delete(root->right_child, x);\n    else if(x<root->data)\n        root->left_child = delete(root->left_child, x);\n    else\n    {\n        \n        if(root->left_child==NULL && root->right_child==NULL)\n        {\n            free(root);\n            return NULL;\n        }\n\n        \n        else if(root->left_child==NULL || root->right_child==NULL)\n        {\n            struct node *temp;\n            if(root->left_child==NULL)\n                temp = root->right_child;\n            else\n                temp = root->left_child;\n            free(root);\n            return temp;\n        }\n\n        \n        else\n        {\n            struct node *temp = find_minimum(root->right_child);\n            root->data = temp->data;\n            root->right_child = delete(root->right_child, temp->data);\n        }\n    }\n    return root;\n}\n\nvoid inorder(struct node *root)\n{\n    if(root!=NULL) \n    {\n        inorder(root->left_child); \n        printf(\" %d \", root->data); \n        inorder(root->right_child);\n    }\n}\n\nint main()\n{\n    \n    struct node *root;\n    root = new_node(20);\n    insert(root,5);\n    insert(root,1);\n    insert(root,15);\n    insert(root,9);\n    insert(root,7);\n    insert(root,12);\n    insert(root,30);\n    insert(root,25);\n    insert(root,40);\n    insert(root, 45);\n    insert(root, 42);\n\n    inorder(root);\n    printf(\"\\n\");\n\n    root = delete(root, 1);\n    \n\n    root = delete(root, 40);\n    \n\n    \n    \n\n    inorder(root);\n    \n    printf(\"\\n\");\n\n    return 0;\n}"}
{"target":"chandanXP","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<graphics.h>\n#include<math.h>\n\nvoid main(){\n     int gd=DETECT,gm;\n     int x1,x2,x3,y1,y2,y3,nx1,nx2,nx3,ny1,ny2,ny3;\n     int xt,yt,;\n     \n     initgraph(&gd, &gm, \"c:\\\\tc\\\\bgi\");\n     printf(\"\\n\\t Enter the points of triangle: \");\n     setcolor(5);\n     scanf(\"%d %d %d %d %d %d\", &x1, &x2, &x3, &y1, &y2, &y3);\n\n     line(x1,y1,x2,y2);\n     line(x2,y2,x3,y3);\n     line(x3,y3,x1,y1);\n\n     printf(\"\\nEnter Translation factor \\n\");\n     scanf(\"%d %d\", &xt, &yt);\n\n     nx1 = x1 + xt;\n     ny1 = y1 + yt;\n     nx2 = x2 + xt;\n     ny2 = y2 + yt;\n     nx3 = x3 + xt;\n     ny3 = y3 + yt;\n\n     line(nx1,ny1,nx2,ny2);\n     line(nx2,ny2,nx3,ny3);\n     line(nx3,ny3,nx1,ny1);\n\n     getch();\n\n\n}\n\n\n\n\n"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define INICIO 1\n#define FIN 1000\n\nint aleatorio(int inicio, int fin);\nvoid menu();\nvoid jugar();\n\nint main(void){\n    srand(time(0));\n    int opcion;\n\n    while(1){\n        menu();\n        scanf(\"%d\", &opcion);\n        if(opcion == 1){\n            jugar();\n        } else \n            break;\n    }\n    return 0;\n}\n\nvoid jugar(){\n    int respuesta;\n    int numero = aleatorio(INICIO, FIN);\n    int intentos = 1;\n    system(\"clear\");\n    do {\n        printf(\"N\u00famero de intentos: %d\\n\", intentos);\n        printf(\"Adiviana un n\u00famero entero entre [%d - %d]\", INICIO, FIN);\n        scanf(\"%d\", &respuesta );\n        intentos++;\n        if(respuesta > numero) {\n            printf(\"N\u00famero muy alto\\n\");\n        } else {\n            if (respuesta < numero)\n                printf(\"Numero muy bajo\\n\");\n            else{\n                printf(\"Excelente!! Adivinaste el n\u00famero!!\\n\");  \n                fflush(stdin); \n                printf(\"Presiona una tecla para continuar...\");\n                getchar();\n            }\n        }\n        \n    } while (respuesta != numero );\n}\n\nvoid menu(){\n    system(\"clear\");\n    printf(\"1. Iniciar juego.\\n\");\n    printf(\"2. Salir\\n\\n\");\n    printf(\"Ingres una opci\u00f3n:\");\n}\n\nint aleatorio(int inicio, int fin){\n    return rand() % (fin - inicio + 1) + inicio;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <math.h>\n\nint es_primo(int numero);\n\nint main(){\n    \n    \n    \n    \n\n    int primos = 0, no_primos = 0;\n    for (int numero = 1; numero <= 10000; numero++)\n    {   \n        if(es_primo(numero)==1){\n            \n            primos++;\n        } else {\n            \n            no_primos++;\n        }\n    }\n    printf(\"Numero de primos %d, numero no primos %d\", primos, no_primos);\n\n    return 0;\n}\n\n\n\nint es_primo(int numero){\n    for (int i = 2; i <= sqrt(numero); i++){\n        if ( numero % i == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define INI 1\n#define FIN 1000\n\nint generar_aleatorio(int inicio, int final);\nint menu();\nvoid jugar();\n\n\nint main(void){\n    srand(time(NULL));\n    char respuesta = 'N';\n    do {\n        int op = menu();\n        switch (op) {\n        case 1: jugar();\n            break;\n        default:\n            break;\n        }\n        printf(\"Deseas continuar jugando? [S]i o [N]o \\n\");\n        fflush(stdin);\n        scanf(\"%c\", &respuesta);\n    } while( respuesta == 'S');\n    \n    return 0;\n}\n\nint menu(){\n    int opcion;\n    system(\"clear\");\n    printf(\"Juedo de adivina un n\u00famero.\\n\");\n    printf(\"1. Jugar\\n\");\n    printf(\"2. Salir\\n\");\n    printf(\"Elije una opci\u00f3n:\");\n    scanf(\"%d\", &opcion);\n    return opcion;\n}\n\nint generar_aleatorio(int inicio, int final){\n    return rand() % (final - inicio + 1) + inicio;\n}\n\nvoid jugar(){\n    int alea = generar_aleatorio(INI, FIN);\n    printf(\"Adivina el n\u00famero entre %d - %d: \", INI, FIN);\n    while(1) {\n        int respuesta;\n        \n        scanf(\"%d\", &respuesta);\n        if( respuesta == alea){\n            printf(\"Felicidades!!! Adivinaste...\\n\");\n            printf(\"Presione una tecla para continuar...\");\n            fflush(stdin);\n            getchar();\n            break;\n        } else {\n            if( respuesta < alea){\n                printf(\"El valor es m\u00e1s grande\\n\");\n            } else {\n                printf(\"El valor es m\u00e1s peque\u00f1o\\n\");\n            }\n        }\n        printf(\"Intenta de nuevo adivinar el n\u00famero entre %d - %d: \", INI, FIN);\n    }\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n\nstruct estudiant_{\n    int id;\n    int matricula;\n    char name[60];\n    float calificaciones[4];\n    int asistencias[5];\n};\n\ntypedef struct estudiant_ estudiante;\n\nint main(){\n    FILE *cfPtr;\n\n    if((cfPtr = fopen(\"estudiantes.dat\", \"rb+\")) == NULL){\n        puts(\"No se pudo abrir el archivo...\\n\");\n    } else {\n        estudiante estudiante_nuevo = {0, 0, \"\", {0.0}, {-1}};\n\n        printf(\"Ingrese id [1 - 100]:\");\n        scanf(\"%d\", &estudiante_nuevo.id);\n\n        while( estudiante_nuevo.id != 0){\n            printf(\"Ingresar matricula:\");\n            scanf(\"%d\", &estudiante_nuevo.matricula);\n            printf(\"Ingresar nombre del estudiante:\");\n            scanf(\"%s\", estudiante_nuevo.name);\n            \n            fseek(cfPtr, (estudiante_nuevo.id - 1 ) * sizeof(estudiante), SEEK_SET);\n\n            fwrite(&estudiante_nuevo, sizeof(estudiante), 1, cfPtr);\n\n            printf(\"Ingrese un id [1-100]\");\n            scanf(\"%d\", &estudiante_nuevo.id);\n        }\n\n        fclose(cfPtr);\n    }\n\n    return 0;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n\nstruct estudiant_{\n    int id;\n    int matricula;\n    char name[60];\n    float calificaciones[4];\n    int asistencias[5];\n};\n\ntypedef struct estudiant_ estudiante;\n\nint main(){\n    FILE *cfPtr;\n\n    if((cfPtr = fopen(\"estudiantes.dat\", \"rb+\")) == NULL){\n        puts(\"No se pudo abrir el archivo...\\n\");\n    } else {\n\n        printf(\"%s\\t%s\\t%s\\n\", \"Id\", \"Matr\u00edcula\", \"Nombre\");\n        while(!feof(cfPtr)){\n            estudiante estudiante_recuperado = {0, 0, \"\", {0.0}, {-1}};\n\n            int resultado = fread(&estudiante_recuperado, sizeof(estudiante), 1, cfPtr);\n\n            if(resultado != 0 && estudiante_recuperado.id != 0 && estudiante_recuperado.matricula == 123){\n                printf(\"%d\\t%d\\t%s\", estudiante_recuperado.id, estudiante_recuperado.matricula, \n                estudiante_recuperado.name);\n            }\n        }\n\n        fclose(cfPtr);\n    }\n\n    return 0;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid leer_calorias(int a[], int tam);\nfloat promedio_calorias(int a[], int tam);\n\nint main(){\n    \n    int *calorias = NULL;\n    int tamanno;\n\n    printf(\"Ingresa cantidad de d\u00edas en que se registrar\u00e1n las calor\u00edas:\");\n    scanf(\"%d\", &tamanno);\n\n    calorias = (int *) malloc (tamanno * sizeof(int));\n    if (calorias != NULL){\n       leer_calorias(calorias, tamanno);\n       printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , tamanno\n        , promedio_calorias(calorias, tamanno));\n        free(calorias);\n    } else {\n        printf(\"No se pudo reservar la memoria\\n\");\n    }\n    \n    \n    \n    return 0;\n}\n\n\nvoid leer_calorias(int a[], int tam){\n    for (int i = 0; i < tam; i++){\n        printf(\"Ingrese las calorias consumidas en el dia: \");\n        scanf(\"%d\", &a[i]);\n    }\n    \n}\n\nfloat promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma\/tam);\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid leer_calorias(int a[], int tam);\nfloat promedio_calorias(int a[], int tam);\n\nint main(){\n    \n    int *calorias = NULL;\n    int tamanno;\n\n    printf(\"Ingresa cantidad de d\u00edas en que se registrar\u00e1n las calor\u00edas:\");\n    scanf(\"%d\", &tamanno);\n\n    \n    \n    calorias = (int *) calloc (tamanno, sizeof(int));\n    if (calorias != NULL){\n       \n       printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , tamanno\n        , promedio_calorias(calorias, tamanno));\n        free(calorias);\n    } else {\n        printf(\"No se pudo reservar la memoria\\n\");\n    }\n    \n    \n    \n    return 0;\n}\n\n\nvoid leer_calorias(int a[], int tam){\n    for (int i = 0; i < tam; i++){\n        printf(\"Ingrese las calorias consumidas en el dia: \");\n        scanf(\"%d\", &a[i]);\n    }\n    \n}\n\nfloat promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma\/tam);\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid leer_calorias(int a[], int tam);\nfloat promedio_calorias(int a[], int tam);\n\nint main(){\n\n    int *calorias = NULL;\n    char respuesta;\n    int posicion = 1;\n\n    calorias = (int *) malloc ( posicion * sizeof(int));\n\n    do {\n        calorias = (int *) realloc (calorias, posicion);\n        leer_calorias(calorias, posicion);\n        posicion++;\n        printf(\"Desea agregar consumo de calorias de otro d\u00eda?\");\n        fflush(stdin);\n        respuesta = getchar();  \n    } while(respuesta != 'n');\n\n    printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , posicion - 1\n        , promedio_calorias(calorias, posicion - 1));\n        \n    free(calorias);\n    \n    return 0;\n}\n\nvoid leer_calorias(int a[], int posicion){\n    printf(\"Ingrese las calorias consumidas en el dia: \");\n    scanf(\"%d\", &a[posicion - 1]);\n}\n\nfloat promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma\/tam);\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid suffle(int [][13]);\nvoid deal( const int [][13], const char *[], const char *[]);\nvoid hand( const int [][13]);\n\nint main(){\n    const char *suit[4] = {\"Hearts\", \"Diamons\", \"Clubs\", \"Spades\"};\n    const char *face[13] = {\"Ace\", \"Deuce\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\n     \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\" };\n\n    int deck[4][13] = {0};\n\n    srand(time (NULL));\n\n    suffle(deck);\n    deal(deck, face, suit);\n\n    return 0;\n}\n\nvoid suffle(int wDeck[][13]){\n    int card, row, column;\n\n    for(card = 1; card <= 52; card++){\n        row = rand() % 4;\n        column = rand() % 13;\n\n        while (wDeck[row][column] != 0){\n            row = rand() % 4;\n            column = rand() % 13;\n        }\n\n        wDeck[row][column] = card;\n    }\n}\n\nvoid deal( const int wDeck[][13], const char *wFace[], const char *wSuit[]){\n    int card, row, column;\n    for ( card = 1; card <= 5; card++){\n        for ( row = 0; row <= 3; row++){\n            for ( column = 0; column <= 12; column++){\n                if(wDeck[row][column] == card)\n                    printf(\"%5s of %-8s%c\", wFace[column], wSuit[row], (card % 2) == 0 ? '\\n' : '\\t');\n            }\n            \n        }\n        \n    }\n    \n}\n\nvoid hand( const int [][13]){\n\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n#define MAX 100\n#define MAX_ASISTENCIA 5\n#define MAX_CALIFICACIONES 4\n#define MAX_NOMBRE 60\n#define MAX_ALUMNOS 4\n\nstruct estudiant_{\n    int matricula;\n    char nombre[MAX_NOMBRE];\n    float calificaciones[MAX_CALIFICACIONES];\n    int asistencias[MAX_ASISTENCIA];\n};\n\ntypedef struct estudiant_ estudiante;\nestudiante lista_estudiantes[MAX_ALUMNOS];\n\n\nvoid imprimir_menu();\nvoid agregar_alumno();\nvoid modificar_alumno();\nvoid imprimir_alumno();\nvoid imprimir_asistencias(const int posicion);\nvoid imprimir_menu_calificaciones();\nvoid menu_modificacion_calificaciones();\nvoid imprimir_alumnos_en_tabla();\nvoid imprimir_alumno_por_fila(int posicion);\n\nint posicion_alumno();\nvoid pase_asistencia();\nfloat promedio(float *c);\nfloat minimo(float *c);\nfloat maximo(float *c);\n\nint siguiente_alumno = 0;\n\nint main(){\n    int opcion;\n    while (1) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: modificar_alumno();\n                break;\n             case 3: menu_modificacion_calificaciones();\n                 break;\n            case 4: imprimir_alumno();\n                 break;\n            case 5: imprimir_alumnos_en_tabla();\n                break;\n            case 6: pase_asistencia();\n                 break;\n            case 7:\n                return 0;\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}\n\nvoid imprimir_menu(){\n    char mensaje[MAX] = \"SISTEMA DE CONTROL DE CALIFICACIONES\";\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"%s\\n\", mensaje);\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Menu de opciones\\n\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar alumno\\n\");\n    printf(\"3. Modificar calificaciones\\n\");\n    printf(\"4. Imprimir datos del alumno\\n\");\n    printf(\"5. Lista de alumnos\\n\");\n    printf(\"6. Pase de lista\\n\");\n    printf(\"7. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}\n\nvoid agregar_alumno(){\n    if(siguiente_alumno == MAX_ALUMNOS){\n        printf(\"No se puede agregar nuevo alumno, espacio insuficiente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n    } else {\n        estudiante nuevo_alumno;\n        printf(\"Ingresa la matr\u00edcula:\");\n        scanf(\"%d\", &nuevo_alumno.matricula);\n        fflush(stdin);\n        printf(\"Ingresa el nombre del alumno:\");\n        fgets(nuevo_alumno.nombre, 60, stdin);\n        nuevo_alumno.calificaciones[0] = 0.0;\n        nuevo_alumno.calificaciones[1] = 0.0;\n        nuevo_alumno.calificaciones[2] = 0.0;\n        nuevo_alumno.calificaciones[3] = 0.0;\n        puts(\"Datos almacenado correctamente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n        lista_estudiantes[siguiente_alumno] = nuevo_alumno;\n        siguiente_alumno++;\n    } \n}\n\nvoid modificar_alumno(){\n    system(\"clear\");\n    puts(\"\\tMenu para cambio de nombre...\");\n    int posicion = posicion_alumno();\n    estudiante estudiante_seleccionado = lista_estudiantes[posicion];\n    printf(\"El nombre del alumno es: %s\\n\", estudiante_seleccionado.nombre);\n    printf(\"Ingresa el nuevo nombre: \");\n    fflush(stdin);\n    fgets(estudiante_seleccionado.nombre, 60, stdin);\n    lista_estudiantes[posicion] = estudiante_seleccionado;\n}\n\nint posicion_alumno(){\n    int posicion;\n    printf(\"\\nIngresa la posicion [1 -  %d]: \", MAX_ALUMNOS);\n    scanf(\"%d\", &posicion);\n    posicion--;\n    return posicion;\n}\n\nvoid imprimir_alumno(){\n    int posicion = posicion_alumno();\n    \n    printf(\"Matr\u00edcula: %d\\n\", lista_estudiantes[posicion].matricula);\n    printf(\"Nombre del alumno: %s\\n\", lista_estudiantes[posicion].nombre);\n    printf(\"Calificaci\u00f3n 1: %.2f\\n\", lista_estudiantes[posicion].calificaciones[0]); \n    printf(\"Calificaci\u00f3n 2: %.2f\\n\", lista_estudiantes[posicion].calificaciones[1]); \n    printf(\"Calificaci\u00f3n 3: %.2f\\n\", lista_estudiantes[posicion].calificaciones[2]); \n    printf(\"Calificaci\u00f3n f: %.2f\\n\", lista_estudiantes[posicion].calificaciones[3]); \n    float prom = promedio(lista_estudiantes[posicion].calificaciones);\n    printf(\"Promedio : %.2f\\n\", prom);\n    float m;\n    m = minimo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00ednima: %.2f\\n\", m);\n    m = maximo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00e1xima: %.2f\\n\", m);\n    imprimir_asistencias(posicion);\n    fflush(stdin);\n    getchar();\n}\n\nfloat promedio(float *c){\n    float prom;\n    float acumulador = 0.0;\n    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)\n    {\n        acumulador += c[i];\n    }\n    prom = acumulador \/ MAX_CALIFICACIONES - 1;\n    prom = (prom + c[MAX_CALIFICACIONES - 1]) \/ 2;\n    return prom;\n}\n\nfloat minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}\n\nfloat maximo(float *c){\n    float max = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (max < c[i]){\n            max = c[i];\n        }\n    }\n    return max;\n}\n\nvoid imprimir_asistencias(const int posicion){\n    printf(\"Asistencias: \");\n    for (int i = 0; i < MAX_ASISTENCIA-1; i++)\n    {\n        if (lista_estudiantes[posicion].asistencias[i] == 1)\n            printf(\"%s\", \"A, \");    \n        else \n            printf(\"%s\", \"F, \");         \n    }\n    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(\"%s\", \"A\"):printf(\"%s\", \"F\");\n    printf(\"\\n\");\n}\n\nvoid imprimir_menu_calificaciones(){\n    printf(\"1. Modificar calificaci\u00f3n 1:\\n\");\n    printf(\"2. Modificar calificaci\u00f3n 2:\\n\");\n    printf(\"3. Modificar calificaci\u00f3n 3:\\n\");\n    printf(\"4. Modificar calificaci\u00f3n f:\\n\");\n    printf(\"5. Salir:\\n\");\n    printf(\"Ingresa una opci\u00f3n:\");\n}\n\nvoid menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificaci\u00f3n actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificaci\u00f3n %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}\n\nvoid pase_asistencia(){\n    int dia;\n    printf(\"Pase de asistencia...\\n\");\n    int posicion = posicion_alumno();\n    printf(\"Indicar dia de asistencia [1 - %d]: \", MAX_ASISTENCIA);\n    scanf(\"%d\", &dia);\n    printf(\"[0]=Falta o [1]=Asistencia: \");\n    scanf(\"%d\", &lista_estudiantes[posicion].asistencias[dia - 1]);\n}\n\nvoid imprimir_alumnos_en_tabla(){\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Matricula\\tNombre\\t 1er\\t2o\\t3er\\t Ord\\n\");\n    printf(\"----------------------------------------------\\n\");\n    for (int i = 0; i < siguiente_alumno; i++){\n        imprimir_alumno_por_fila(i);\n    }\n    puts(\"Presione una tecla para continuar...\");\n    fflush(stdin);\n    getchar();\n}\n\nvoid imprimir_alumno_por_fila(int posicion){\n    printf(\"%d\\t\\t%s\\t\", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"%.2f\\t\", lista_estudiantes[posicion].calificaciones[i]);\n    }\n    printf(\"\\n\");\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n#define MAX 100\n#define MAX_ASISTENCIA 5\n#define MAX_CALIFICACIONES 4\n#define MAX_NOMBRE 60\n#define MAX_ALUMNOS 4\n#define MAX_GRUPOS 3\n\nstruct estudiant_{\n    int matricula;\n    char nombre[MAX_NOMBRE];\n    float calificaciones[MAX_CALIFICACIONES];\n    int asistencias[MAX_ASISTENCIA];\n};\n\ntypedef struct estudiant_ estudiante;\n\n\nstruc grup_{\n    char id[];\n    int semestre;\n    int numero_estudiantes;\n    estudiante lista_estudiantes[MAX_ALUMNOS];\n}\n\ntypedef struct grup_ grupo;\ngrupo lista_grupos[MAX_GRUPOS];\n\nvoid imprimir_menu();\nvoid agregar_alumno();\nvoid modificar_alumno();\nvoid imprimir_alumno();\nvoid imprimir_asistencias(const int posicion);\nvoid imprimir_menu_calificaciones();\nvoid menu_modificacion_calificaciones();\nvoid imprimir_alumnos_en_tabla();\nvoid imprimir_alumno_por_fila(int posicion);\n\nint posicion_alumno();\nvoid pase_asistencia();\nfloat promedio(float *c);\nfloat minimo(float *c);\nfloat maximo(float *c);\n\nint siguiente_alumno = 0;\n\nint main(){\n    int opcion;\n    while (1) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: modificar_alumno();\n                break;\n             case 3: menu_modificacion_calificaciones();\n                 break;\n            case 4: imprimir_alumno();\n                 break;\n            case 5: imprimir_alumnos_en_tabla();\n                break;\n            case 6: pase_asistencia();\n                 break;\n            case 7:\n                return 0;\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}\n\nvoid imprimir_menu(){\n    char mensaje[MAX] = \"SISTEMA DE CONTROL DE CALIFICACIONES\";\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"%s\\n\", mensaje);\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Menu de opciones\\n\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar alumno\\n\");\n    printf(\"3. Modificar calificaciones\\n\");\n    printf(\"4. Imprimir datos del alumno\\n\");\n    printf(\"5. Lista de alumnos\\n\");\n    printf(\"6. Pase de lista\\n\");\n    printf(\"7. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}\n\nvoid agregar_alumno(){\n    if(siguiente_alumno == MAX_ALUMNOS){\n        printf(\"No se puede agregar nuevo alumno, espacio insuficiente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n    } else {\n        estudiante nuevo_alumno;\n        printf(\"Ingresa la matr\u00edcula:\");\n        scanf(\"%d\", &nuevo_alumno.matricula);\n        fflush(stdin);\n        printf(\"Ingresa el nombre del alumno:\");\n        fgets(nuevo_alumno.nombre, 60, stdin);\n        nuevo_alumno.calificaciones[0] = 0.0;\n        nuevo_alumno.calificaciones[1] = 0.0;\n        nuevo_alumno.calificaciones[2] = 0.0;\n        nuevo_alumno.calificaciones[3] = 0.0;\n        puts(\"Datos almacenado correctamente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n        lista_estudiantes[siguiente_alumno] = nuevo_alumno;\n        siguiente_alumno++;\n    } \n}\n\nvoid modificar_alumno(){\n    system(\"clear\");\n    puts(\"\\tMenu para cambio de nombre...\");\n    int posicion = posicion_alumno();\n    estudiante estudiante_seleccionado = lista_estudiantes[posicion];\n    printf(\"El nombre del alumno es: %s\\n\", estudiante_seleccionado.nombre);\n    printf(\"Ingresa el nuevo nombre: \");\n    fflush(stdin);\n    fgets(estudiante_seleccionado.nombre, 60, stdin);\n    lista_estudiantes[posicion] = estudiante_seleccionado;\n}\n\nint posicion_alumno(){\n    int posicion;\n    printf(\"\\nIngresa la posicion [1 -  %d]: \", MAX_ALUMNOS);\n    scanf(\"%d\", &posicion);\n    posicion--;\n    return posicion;\n}\n\nvoid imprimir_alumno(){\n    int posicion = posicion_alumno();\n    \n    printf(\"Matr\u00edcula: %d\\n\", lista_estudiantes[posicion].matricula);\n    printf(\"Nombre del alumno: %s\\n\", lista_estudiantes[posicion].nombre);\n    printf(\"Calificaci\u00f3n 1: %.2f\\n\", lista_estudiantes[posicion].calificaciones[0]); \n    printf(\"Calificaci\u00f3n 2: %.2f\\n\", lista_estudiantes[posicion].calificaciones[1]); \n    printf(\"Calificaci\u00f3n 3: %.2f\\n\", lista_estudiantes[posicion].calificaciones[2]); \n    printf(\"Calificaci\u00f3n f: %.2f\\n\", lista_estudiantes[posicion].calificaciones[3]); \n    float prom = promedio(lista_estudiantes[posicion].calificaciones);\n    printf(\"Promedio : %.2f\\n\", prom);\n    float m;\n    m = minimo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00ednima: %.2f\\n\", m);\n    m = maximo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00e1xima: %.2f\\n\", m);\n    imprimir_asistencias(posicion);\n    fflush(stdin);\n    getchar();\n}\n\nfloat promedio(float *c){\n    float prom;\n    float acumulador = 0.0;\n    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)\n    {\n        acumulador += c[i];\n    }\n    prom = acumulador \/ MAX_CALIFICACIONES - 1;\n    prom = (prom + c[MAX_CALIFICACIONES - 1]) \/ 2;\n    return prom;\n}\n\nfloat minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}\n\nfloat maximo(float *c){\n    float max = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (max < c[i]){\n            max = c[i];\n        }\n    }\n    return max;\n}\n\nvoid imprimir_asistencias(const int posicion){\n    printf(\"Asistencias: \");\n    for (int i = 0; i < MAX_ASISTENCIA-1; i++)\n    {\n        if (lista_estudiantes[posicion].asistencias[i] == 1)\n            printf(\"%s\", \"A, \");    \n        else \n            printf(\"%s\", \"F, \");         \n    }\n    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(\"%s\", \"A\"):printf(\"%s\", \"F\");\n    printf(\"\\n\");\n}\n\nvoid imprimir_menu_calificaciones(){\n    printf(\"1. Modificar calificaci\u00f3n 1:\\n\");\n    printf(\"2. Modificar calificaci\u00f3n 2:\\n\");\n    printf(\"3. Modificar calificaci\u00f3n 3:\\n\");\n    printf(\"4. Modificar calificaci\u00f3n f:\\n\");\n    printf(\"5. Salir:\\n\");\n    printf(\"Ingresa una opci\u00f3n:\");\n}\n\nvoid menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificaci\u00f3n actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificaci\u00f3n %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}\n\nvoid pase_asistencia(){\n    int dia;\n    printf(\"Pase de asistencia...\\n\");\n    int posicion = posicion_alumno();\n    printf(\"Indicar dia de asistencia [1 - %d]: \", MAX_ASISTENCIA);\n    scanf(\"%d\", &dia);\n    printf(\"[0]=Falta o [1]=Asistencia: \");\n    scanf(\"%d\", &lista_estudiantes[posicion].asistencias[dia - 1]);\n}\n\nvoid imprimir_alumnos_en_tabla(){\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Matricula\\tNombre\\t 1er\\t2o\\t3er\\t Ord\\n\");\n    printf(\"----------------------------------------------\\n\");\n    for (int i = 0; i < siguiente_alumno; i++){\n        imprimir_alumno_por_fila(i);\n    }\n    puts(\"Presione una tecla para continuar...\");\n    fflush(stdin);\n    getchar();\n}\n\nvoid imprimir_alumno_por_fila(int posicion){\n    printf(\"%d\\t\\t%s\\t\", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"%.2f\\t\", lista_estudiantes[posicion].calificaciones[i]);\n    }\n    printf(\"\\n\");\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <string.h>\n\n#define MAX_ALUMNO 60\n#define MAX_CALIFICACIONES 4\n#define MAX_ASISTENCIA 5\n\nstruct direccion{\n    char calle[60];\n    char numero_exterior[5];\n    char numer_interior[5];\n    char colonia[60];\n    char municipio[60];\n    char entidad[60];\n    int cp;\n};\n\ntypedef struct direccion mi_direccion;\ntypedef int mi_integercito;\n\nstruct estudiante{\n    int matricula;\n    char nombre[MAX_ALUMNO];\n    mi_direccion direccion_estudiante;\n    float calificaciones[MAX_CALIFICACIONES];\n    int asistencias[MAX_ASISTENCIA];\n};\n\ntypedef struct estudiante mi_estudiante;\n\nstruct estudiante e1;\nmi_estudiante e2;\nmi_integercito x1, x2, x3, x100;\nint arreglo_x[100];\n\nmi_estudiante lista_estudiantes[100];\n\nint main(){\n\n    e1.matricula = 123;\n    strcpy(e1.nombre, \"Juan Carlos\");\n    strcpy(e1.direccion_estudiante.calle, \"Vicente Guerrero\");\n    strcpy(e1.direccion_estudiante.numer_interior, \"2A\");\n    strcpy(e1.direccion_estudiante.numero_exterior, \"234\");\n    strcpy(e1.direccion_estudiante.colonia, \"Centro Historico\");\n    strcpy(e1.direccion_estudiante.municipio, \"Huajuapan\");\n    strcpy(e1.direccion_estudiante.entidad,\"Oaxaca\");\n    e1.direccion_estudiante.cp = 67000;\n    e1.calificaciones[0] = 10.0;\n    e1.asistencias[0] = 1;\n\n    printf(\"Datos del estudiante:\\n\");\n    printf(\"Direcci\u00f3n, calle: %s\", e1.direccion_estudiante.calle);\n\n\n    lista_estudiantes[0] = e1;\n\n    return 0;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n\n#define MAX_ALUMNO 60\n#define MAX_CALIFICACIONES 4\n#define MAX_ASISTENCIA 5\n\nstruct estudiante{\n    int matricula;\n    char nombre[MAX_ALUMNO];\n    float calificaciones[MAX_CALIFICACIONES];\n    int asistencias[MAX_ASISTENCIA];\n} e5 = {345, \"Karla Ramirez\", {0.0, 0.0, 0.0, 0.0}, {0, 0, 0, 0, 0}};\n\nstruct estudiante e1, e2, e3;\nstruct estudiante e6;\nstruct estudiante e4 = { 123, \"Juan Carlos\", {0.0 , 0.0, 0.0, 0.0}, {0, 0, 0, 0, 0} };\n\n\n\n\nint main(){\n    int x1 = 1;\n    int x2, x3, x4, x5 = 10;\n    int numeros[] = {1, 2, 3, 4};\n    x2 = x1; \n\n    printf(\"Ingresa la matricula:\");\n    scanf(\"%d\", &e1.matricula);\n    printf(\"Ingresa el nombre:\");\n    \n    fflush(stdin);\n    fgets(e1.nombre, MAX_ALUMNO, stdin);\n\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"Ingresa calificacion %d: \", i + 1);\n        scanf(\"%f\", &e1.calificaciones[i]);   \n    }\n\n    for (int i = 0; i < MAX_ASISTENCIA; i++){\n        printf(\"Ingresa asistencia del d\u00eda %d: \", i + 1);\n        scanf(\"%d\", &e1.asistencias[i]);   \n    }\n    \n\n    printf(\"\\n\\nDatos del alumno capturado:\\n\");\n    printf(\"Matricula: %d\\n\", e1.matricula);\n    printf(\"Nombre: %s\\n\", e1.nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"Califaci\u00f3n %d: %f\\n\", i+1, e1.calificaciones[i]);\n    }\n    for (int i = 0; i < MAX_ASISTENCIA; i++){\n        printf(\"Asistencias %d: %d\\n\", i+1, e1.asistencias[i]);\n    }\n\n    char mensaje[] = \"hola\";\n    mensaje = \"hola mundo\";\n    strcpy(mensaje, \"hola mundo\");\n\n    e2 = e1;\n    \n    e3.matricula = 456;\n    \n    strcpy(e3.nombre, \"Juan Carlos\");\n    e3.calificaciones[0] = 10.0;\n    e3.calificaciones[1] = 10.0;\n    e3.calificaciones[2] = 10.0;\n    e3.calificaciones[3] = 10.0;\n    e3.asistencias[0] = 1;\n    e3.asistencias[4] = 1;\n\n    int x = 7;\n    int *p_num;\n\n    p_num = &x;\n    *p_num = 10;\n    printf(x);\n    int arreglo_numeros = {1, 2, 3, 4};\n    int *arreglo;\n    arreglo = &arreglo_numeros;\n    arreglo[0] = 5;\n    *(arreglo + 0) = 5;\n\n    struct estudiante *p_e1;\n    p_e1 = &e1;\n\n    p_e1->matricula = 567;\n    strcpy(p_e1->nombre, \"Jose Garcia\");\n    p_e1->calificaciones[0] = 10.0;\n    p_e1->calificaciones[1] = 10.0;\n    p_e1->calificaciones[2] = 10.0;\n    p_e1->calificaciones[3] = 10.0;\n    p_e1->asistencias[0] = 1;\n\n    return 0;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n\nvoid fibonacci(int posicion){\n    \n    long int i;\n    unsigned long int actual = 0, siguiente = 1, temporal;\n    for(i =0; i < posicion; i++){\n        printf(\"%ld, \", actual);\n        temporal = siguiente;\n        siguiente = siguiente + actual;\n        actual = temporal;\n    }\n}\n\nint fibonacci_recursivo(int posicion){\n    if (posicion == 0)\n        return 0;\n    if (posicion == 1)\n        return 1;\n    if (posicion == 2)\n        return 1;\n    else\n        return fibonacci_recursivo(posicion - 1) + fibonacci_recursivo(posicion - 2);\n}\n\nint main(){\n    printf(\"fiboniacci iterativo:\");\n    fibonacci(6);\n    printf(\"\\n%d \\n\", fibonacci_recursivo(5));\n    return 0;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid leer_temperaturas(float **t, int f, int c);\nvoid mostrar_temperaturas(float **t, int f, int c);\n\nint main() {\n    \n    float **temperaturas = NULL;\n    int tamanno_filas, frecuencia, tamanno_columnas;\n\n    printf(\"Ingrese la cantidad de d\u00edas que se registrar\u00e1n tempereraturas:\");\n    scanf(\"%d\", &tamanno_filas);\n    printf(\"Ingrese cada cuanta horas se registrar\u00e1n temperatural por d\u00eda\");\n    scanf(\"%d\", &frecuencia);\n    tamanno_columnas = 24 \/ frecuencia; \n\n    temperaturas = (float **) malloc (tamanno_filas * sizeof(float *));\n    if( temperaturas == NULL){\n        printf(\"No se reservo la memoria\");\n        return -1;\n    }\n\n    for (int i = 0; i < tamanno_filas; i++) {\n        temperaturas[i] = (float *) malloc (tamanno_columnas * sizeof(float));\n        if(temperaturas[i] == NULL){\n            printf(\"No se reerv\u00f3 la memoria\");\n            return -1;\n        }\n    }\n\n    leer_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);\n    mostrar_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);\n\n    for (int i = 0; i < tamanno_columnas; i++){\n        free(temperaturas[i]);\n    }\n    free(temperaturas);\n    \n    return 0;\n}\n\nvoid leer_temperaturas(float **t, int f, int c){\n    for (int i = 0; i < f; i++){\n        for (int j = 0; j < c; j++){\n            printf(\"Ingrese la temperatura %d del dia %d:\", j+1, i+1);\n            scanf(\"%f\", &t[i][j]);\n        }\n    }\n}\n\nvoid mostrar_temperaturas(float **t, int f, int c){\n    for (int i = 0; i < f; i++){\n        for (int j = 0; j < c; j++){\n            printf(\"%f\\t\", t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n}"}
{"target":"christiane-millan","func":"\nvoid agregar_alumno(){\n    printf(\"Ingresa la matr\u00edcula:\");\n    scanf(\"%d\", &matricula);\n    \n    printf(\"Ingresa el inical del nombre del alumno:\");\n    scanf(\" %c\", &inicial_nombre);\n    printf(\"Ingresa calificaci\u00f3n 1:\");\n    scanf(\"%f\", &calificacion1);\n    printf(\"Ingresa calificaci\u00f3n 2:\");\n    scanf(\"%f\", &calificacion2);\n    printf(\"Ingresa calificaci\u00f3n 3:\");\n    scanf(\"%f\", &calificacion3);\n    printf(\"Ingresa calificaci\u00f3n final:\");\n    scanf(\"%f\", &calificacionf);\n}\n\nvoid imprimir_menu(){\n    printf(\"Menu de opiones\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar calificaciones\\n\");\n    printf(\"3. Imprimir datos del alumno\\n\");\n    printf(\"4. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}\n\nint main () {\n    srand(time(0));\n    int opcion;\n    while (opcion != 4) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: menu_modificacion_calificaciones(&calificacion1, &calificacion2, &calificacion3, &calificacionf);\n                break;\n            case 3: imprimir_alumno();\n                break;\n            case 4:\n                break;\n            default:\n                break;\n        }\n\n    }\n    return 0;\n}\n\n\nfloat promedio(float c1, float c2, float c3, float cf){\n    int potencia = pow(2,3);\n    float prom = (((c1 + c2 + c3) \/ 3) + (cf)) \/2;\n    return prom;\n}\n\nfloat minimo(float c1, float c2, float c3, float cf){\n    float min = c1; \n    if (c1 > c2) { \n        min = c2; \n    }\n    if (min > c3){ \n        min = c3; \n    }\n    if (min > cf) { \n        min = cf;\n    }\n    return min;\n}\n\nfloat maximo(float c1, float c2, float c3, float cf){\n    float max = c1; \n    if (c1 < c2) { \n        max = c2; \n    }\n    if (max < c3){ \n        max = c3; \n    }\n    if (max < cf) { \n        max = cf;\n    }\n    return max;\n}\n"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <math.h>\n\nint es_primo(int numero);\n\nint main(){\n    int resultado, primo = 0, no_primo = 0;\n    for(int numero = 1; numero <= 10000; numero++) {\n        resultado = es_primo(numero);\n        if(resultado == 1){\n            \n            primo++;\n        } else {\n            \n            no_primo++;\n        }\n    } \n\n    printf(\"Numero de primos %d, numero de no primos %d\\n\", primo, no_primo);\n    return 0;\n}\n\n\n\nint es_primo(int numero){\n    for (int i = 2; i <= sqrt(numero); i++){\n        if ( numero % i == 0){\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"target":"christiane-millan","func":"#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n\nint main(){\n    float f;\n    double d;\n    long double ld;\n    int i;\n    long l;\n    long long ll;\n    char c = 97;\n    short s;\n\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 10};\n    int *p_array = array;\n\n    printf(\"Tama\u00f1o de c es: %lu, el tama\u00f1o de char es:  %lu\\n\", sizeof c, sizeof(char));\n    printf(\"Tama\u00f1o de i es: %lu, el tama\u00f1o de int es:  %lu\\n\", sizeof i, sizeof(int));\n    printf(\"Tama\u00f1o de s es: %lu, el tama\u00f1o de short es:  %lu\\n\", sizeof s, sizeof(short));\n    printf(\"Tama\u00f1o de l es: %lu, el tama\u00f1o de long es:  %lu\\n\", sizeof l, sizeof(long));\n    printf(\"Tama\u00f1o de ll es: %lu, el tama\u00f1o de long long es:  %lu\\n\", sizeof l, sizeof(long long));\n    printf(\"Tama\u00f1o de f es: %lu, el tama\u00f1o de float es:  %lu\\n\", sizeof f, sizeof(float));\n    printf(\"Tama\u00f1o de d es: %lu, el tama\u00f1o de double es:  %lu\\n\", sizeof d, sizeof(double));\n    printf(\"Tama\u00f1o de ld es: %lu, el tama\u00f1o de long double es:  %lu\\n\", sizeof ld, sizeof(long double));\n    \n    printf(\"Tama\u00f1o del arreglo es %lu\\n\", sizeof array);\n    printf(\"Tama\u00f1o del size_t es %lu\\n\", sizeof(size_t));\n    printf(\"Tama\u00f1o del apuntador al arreglo es %lu\\n\", sizeof p_array);\n    printf(\"*p_array %d\\n\", *p_array);\n    printf(\"p_array %p\\n\", p_array);\n\n\n    return false;\n}"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXNAME 20\n#define MAXABB 3\n\ntypedef struct month { \n    char name[MAXNAME];\n    char abb[MAXABB];\n    int days;\n    int order;\n} MONTH;\n\nint main()\n{\n    MONTH months[12] = {\n        {\"Styczen\", \"JAN\", 31, 1},\n        {\"Luty\", \"FEB\", 28, 2},\n        {\"Marzec\", \"MAR\", 31, 3},\n        {\"Kwiecien\", \"APR\", 30, 4},\n        {\"Maj\", \"MAY\", 31, 5},\n        {\"Czerwiec\", \"JUN\", 30, 6},\n        {\"Lipiec\", \"JUL\", 31, 7},\n        {\"Sierpien\", \"AUG\", 31, 8},\n        {\"Wrzesien\", \"SEP\", 30, 9},\n        {\"Pazdziernik\", \"OCT\", 31, 10},\n        {\"Listopad\", \"NOV\", 30, 11},\n        {\"Grudzien\", \"DEC\", 31, 12},\n    }; \n\n    puts(months[10].name);\n    puts(months[10].abb);\n    printf(\"Liczba dni: %d\\n\", months[10].days);\n    printf(\"Numer w roku: %d\\n\", months[10].order);\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include \"months.c\"\n#define MAXNAME 20\n#define MAXABB 3\n\nint numberOfDays(string);\n\nint main()\n{\n    char userMonth[MAXNAME];\n\n    printf(\"Podaj nazwe miesiaca.\\n\");\n    printf(\"Program wyswietli liczbe dni od poczatku roku do podanego miesiaca: \");\n    scanf(\"%s\", &userMonth);\n\n    printf(\"Liczba dni: %d\", numberOfDays(userMonth));\n\n    getchar();\n    return 0;\n}\n\nint numberOfDays(monthName){\n    int error = 1; \n    int result = 0;\n    for (int i = 0; i < 12; i++){\n        result += months[i].days;\n        if(strcmp(monthName, months[i].name) == 0){\n            error = 0;\n            break; \n        }\n    }\n    if(error == 1){\n        result = 0;\n    }\n    return result;\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid getNChars(int);\n\nint main()\n{\n    int userNum;\n    printf(\"Podaj liczbe znakow.\\n\");\n    scanf(\"%d\", &userNum);\n\n    getNChars(userNum);\n\n    printf(\"\\n------------------------------------------\");\n    printf(\"\\nDziekuje. Dobranoc! To juz jest koniec!\\n\");\n\n    getchar();\n    return 0;\n}\n\nvoid getNChars(int numOfChars) {\n    char stringArray[numOfChars];\n    fflush(stdin);\n    printf(\"Podaj znaki.\\n\");\n    for(int i = 0; i < numOfChars; i++) {\n        stringArray[i] = getchar();\n        if (strcmp(&stringArray[i], \" \") == 0 || strcmp(&stringArray[i], \"\\t\") == 0 || strcmp(&stringArray[i], \"\\n\") == 0) {\n            printf(\"\\nNapotkano spacje, tabulator lub znak nowej linii!\\n\");\n            break;\n        }\n    }\n    printf(\"\\nPodane znaki to: \");\n    puts(stringArray);\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"months.c\"\n#define MAXNAME 20\n#define MAXABB 3\n\nint numberOfDays(int, int, int);\n\nint main()\n{\n    int userYear;\n    int userDay;\n    char userMonth[MAXNAME];\n\n    printf(\"Program wyswietli liczbe dni od poczatku roku do podanego dnia miesiaca.\\n\");\n    printf(\"Podaj numer dnia.\\n\");\n    scanf(\"%d\", &userDay);\n    printf(\"Podaj (nazwe, numer lub skrot) miesiaca.\\n\");\n    scanf(\"%s\", &userMonth);\n    printf(\"Podaj rok.\\n\");\n    scanf(\"%d\", &userYear);\n\n    printf(\"Liczba dni: %d\", numberOfDays(userMonth, userDay, userYear));\n\n    getchar();\n    return 0;\n}\n\nint numberOfDays(month, day, year){\n    int error = true; \n    int leapYear = false;\n    int result = day;\n    if((year%4==0) && ((year%400==0) || (year%100!= 0)))\n        leapYear = true; \n    for (int i = 0; i < 12; i++){\n        if(strcmp(month, months[i].name) == 0 || strcmp(month, months[i].abb) == 0 || atoi(month) == months[i].order){\n            error = false;\n            break; \n        }\n        result += months[i].days;\n        if(leapYear && months[i].order == 2)\n            result += 1;\n    }\n    if(day <= 0 || day > 31){\n        error = true; \n    }\n    if(error == true){\n        result = 0;\n    }\n    return result;\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint wypisz(int * array, int n);\n\nint main()\n{\n    int tablica[10];\n    int userNumber;\n    int licznik = 0;\n    int size = sizeof(tablica)\/sizeof(tablica[0]);\n\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%d\", &userNumber);\n        tablica[licznik] = userNumber;\n        licznik++;\n    }\n\n    printf(\"\\n\");\n    wypisz(tablica, size);\n\n    printf(\"\\n\");\n    return 0;\n}\n\nint wypisz(int * array, int n){\n   for(int i = 0; i < n; i++){\n        if(array[i] % 2 == 0) {\n            printf(\"Parzysta liczba %d o indeksie %d\\n\", array[i], i);\n        }\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define MAXTYT 40\n#define MAXAUT 40\n#define MAXKS 100\n\nstruct ksiazka {\n    char tytul[MAXTYT];\n    char autor[MAXAUT];\n    float wartosc;\n};\n\nint main()\n{\n    struct ksiazka bibl[MAXKS]; \n    int licznik = 0;\n    int index;\n    float koszt = 0;\n\n    printf(\"Podaj tytul ksiazki.\\n\");\n    printf(\"Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n\");\n\n    while(licznik < MAXKS && gets(bibl[licznik].tytul) != NULL && bibl[licznik].tytul[0] != '\\0'){\n        printf(\"Teraz podaj autora.\\n\");\n        gets(bibl[licznik].autor);\n        printf(\"Teraz podaj wartosc.\\n\");\n        scanf(\"%f\", &bibl[licznik++].wartosc);\n        while(getchar() != '\\n')\n            continue; \n        if(licznik < MAXKS)\n            printf(\"Podaj kolejny tytul.\\n\");\n    }\n\n    printf(\"Oto posortowana lista Twoich ksiazek:\\n\");\n\n    for(index = 0; index < licznik; index++){\n        for(int j = 0; j < licznik; j++){\n            if(strcmp(bibl[j].tytul,bibl[index].tytul)>0){\n                struct ksiazka temp = bibl[index];\n                bibl[index] = bibl[j];\n                bibl[j] = temp;\n            }\n        }\n    }\n\n    for(index = 0; index < licznik; index++){\n        printf(\"%s, autor: %s, cena: %.2f zl\\n\", bibl[index].tytul, bibl[index].autor, bibl[index].wartosc);\n        koszt += bibl[index].wartosc;\n    }\n\n    printf(\"----------------------------------------------------------------\\n\");\n    printf(\"Wartosc wszystkich ksiazek: %.2f zl\\n\", koszt);\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint czyTrojkat(float a, float b, float c);\n\nint main()\n{\n    float first, second, third;\n\n    printf(\"Podaj 1 bok: \");\n    scanf(\"%f\", &first);\n    printf(\"Podaj 2 bok: \");\n    scanf(\"%f\", &second);\n    printf(\"Podaj 3 bok: \");\n    scanf(\"%f\", &third);\n\n    if(!czyTrojkat(first, second, third)){\n        printf(\"Podane boki nie moga utworzyc trojkata!\");\n    } else {\n        printf(\"Podane boki tworza piekny trojkat!\");\n    };\n\n    printf(\"\\n\");\n    return 0;\n}\n\nint czyTrojkat(float a, float b, float c){\n    float max;\n    float middle;\n    float min;\n\n    if(a <= 0 || b <= 0 || c <= 0){\n        return 0;\n    }\n\n    if(a >= b && a >= c ) {\n        max = a;\n        if(b >= c) {\n            min = c;\n            middle = b;\n        } else {\n            min = b;\n            middle = c;\n        }\n    } else if ( b >= c) {\n        max = b;\n        if(a >= c) {\n             min = c;\n             middle = b;\n        } else {\n             min = a;\n             middle = c;\n        }\n    } else {\n        max = c;\n        if(a >= b) {\n             min = b;\n             middle = a;\n        } else {\n             min = a;\n             middle = b;\n        }\n    }\n    if(min + middle <= max){\n        return 0;\n    }\n    return 1;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define PESEL 12\n\ntypedef struct personalInfo {\n    char pesel[PESEL];\n    struct person {\n        char firstName[21];\n        char middleName[21];\n        char lastName[21];\n    };\n} PERSONINFO;\n\nint main()\n{\n    PERSONINFO persons[] = {\n        \"23232323232\", \"Adam\", \"Rick\", \"Melix\",\n        \"11111111111\", \"Morty\", \"Eric\", \"Willis\",\n        \"88833388822\", \"Tom\", \"George\", \"Brady\"\n    };\n\n    int counter = 0;\n    int size = sizeof(persons)\/sizeof(*persons);\n    while(counter < size){\n        printf(\"%7s, %7s %7s -- %s\\n\", persons[counter].lastName, persons[counter].firstName, persons[counter].middleName, persons[counter].pesel);\n        counter++;\n    }\n\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nfloat ciag(int n);\n\nint main()\n{\n    int N;\n\n    printf(\"Podaj dodatnia wartosc liczby 'N': \");\n    scanf(\"%d\", &N);\n\n    while(N <= 0){\n        printf(\"Podano bledna wartosc\\n\");\n        printf(\"Podaj dodatnia wartosc liczby 'N': \");\n        scanf(\"%d\", &N);\n    }\n\n    printf(\"N-ty wyraz ciagu to: %.2f\", ciag(N));\n\n    printf(\"\\n\");\n    return 0;\n}\n\nfloat ciag(int n){\n    float a_n;\n    if(n == 1) return 1;\n    if(n == 2) return 2;\n    if(n == 3) return 3;\n    a_n = (ciag(n-1) + ciag(n-2) + ciag(n-3))\/3; \n    return a_n;\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float a, b, c;\n    float delta;\n    float x1, x2;\n\n    printf(\"Podaj wartosc wspolczynnika a.\\n\");\n    scanf(\"%f\", &a);\n    printf(\"Podaj wartosc wspolczynnika b.\\n\");\n    scanf(\"%f\", &b);\n    printf(\"Podaj wartosc wspolczynnika c.\\n\");\n    scanf(\"%f\", &c);\n\n    if (a == 0) {\n        x1 = -c\/b;\n        printf(\"Rozwiazanie rownania: %.2f\\n\", x1);\n    } else {\n        delta = b*b-4*a*c;\n        if (delta < 0) {\n           printf(\"Rownanie nie ma rozwiazan w zbiorze liczb rzeczywistych.\\n\");\n        } else {\n            x1 = (-b-delta)\/(2*a);\n            x2 = (-b+delta)\/(2*a);\n            printf(\"x1 wynosi: %.2f\\n\", x1);\n            printf(\"x2 wynosi: %.2f\\n\", x2);\n        }\n    }\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float num1, num2;\n    int operation;\n    float result;\n\n    printf(\"Podaj wartosc pierwszej liczby.\\n\");\n    scanf(\"%f\", &num1);\n    printf(\"Podaj wartosc drugiej liczby.\\n\");\n    scanf(\"%f\", &num2);\n\n    printf(\"Wybierz rodzaj operacji matematycznej.\\n\");\n    printf(\"---------------------------------------\\n\");\n    printf(\"1) Dodaj                   3) Pomnoz\\n\");\n    printf(\"2) Odejmij                 4) Podziel\\n\");\n    scanf(\"%d\", &operation);\n\n    switch (operation) {\n    case 1:\n        result = num1 + num2;\n        break;\n    case 2:\n        result = num1 - num2;\n        break;\n    case 3:\n        result = num1 * num2;\n        break;\n    case 4:\n        result = num1 \/ num2;\n        break;\n    }\n\n    printf(\"\\nWynik: %.2f\\n\", result);\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint sequenceA(int);\n\nint main()\n{\n    int userNumber;\n    printf(\"Podaj nieujemna liczbe calkowita 'n': \");\n    scanf(\"%d\", &userNumber);\n\n    while(userNumber < 0 ){\n        printf(\"Podano nieprawidlowe dane!\\n\");\n        printf(\"Podaj nieujemna liczbe calkowita 'n': \");\n        scanf(\"%d\", &userNumber);\n    }\n\n    printf(\"Wyraz '%d' ciagu wynosi: %d\\n\", userNumber, sequenceA(userNumber));\n\n    getchar();\n    return 0;\n}\n\nint sequenceA(int n){\n    int a_n = 1;\n    if(n > 0){ \n        a_n = 2 * sequenceA(n - 1) + 5;\n    }\n    return a_n;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nfloat powerOfTwo(int);\n\nint main()\n{\n    int userNumber;\n    printf(\"Podaj liczbe calkowita 'n': \");\n    scanf(\"%d\", &userNumber);\n\n    printf(\"2 do potegi %d to: %.3f\\n\", userNumber, powerOfTwo(userNumber));\n\n    getchar();\n    return 0;\n}\n\nfloat powerOfTwo(int n){\n    float result = 1;\n    if(n >= 0){\n        for(int i = 0; i < n; i++){\n            result = result * 2;\n        }\n    } else {\n        for(int i = 0; i > n; i--){\n            result = result * 2;\n        }\n        result = 1 \/ result;\n    }\n    return result;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint change(int * x, int * y);\n\nint main()\n{\n    int number1, number2;\n\n    printf(\"Podaj liczbe calkowita nr 1: \");\n    scanf(\"%d\", &number1);\n    printf(\"Podaj liczbe calkowita nr 2: \");\n    scanf(\"%d\", &number2);\n\n    printf(\"\\nLiczba1: %d     Liczba2: %d\\n\\n\", number1, number2);\n    change(&number1, &number2);\n    printf(\"Liczba1: %d     Liczba2: %d\\n\\n\", number1, number2);\n\n    getchar();\n    return 0;\n}\n\nint change(int * x, int * y){\n    if(*y < *x){\n        int temp = *x;\n        *x = *y;\n        *y = temp;\n    }\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid copyArrays(unsigned int, int * array1, int * array2);\n\nint main()\n{\n    int one[5] = {5, 6, 8, 8, 10};\n    int two[5];\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n\n    copyArrays(5, one, two);\n\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid copyArrays(unsigned int n, int * array1, int * array2){\n    int i = 0;\n    for(i; i < n; i++){\n        array2[i] = array1[n-1-i];\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid sumElements(unsigned int, int * array1, int * array2, int * array3);\n\nint main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8];\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n\n    copyArrays(naturalNumber, one, two, three);\n\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid copyArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        array3[i] = array1[i] + array2[i];\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid biggerElement(unsigned int, int * array1, int * array2, int * array3);\n\nint main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8];\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n\n    biggerElement(naturalNumber, one, two, three);\n\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid biggerElement(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        if(array1[i] > array2[i]){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[i];\n        }\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid changeArrays(unsigned int, int * array1, int * array2, int * array3);\n\nint main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8] = {9, 9, 9, -9, -9, 9, 99, 999};\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    printf(\"\\n\\nMieszanie tablic!!!\\n\\n\");\n    changeArrays(naturalNumber, one, two, three);\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid changeArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    int tempValue;\n    for(i; i < n; i++){\n        tempValue = array3[i];\n        array3[i] = array2[i];\n        array2[i] = array1[i];\n        array1[i] = tempValue;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid connectArrays(unsigned int, int * array1, int * array2, double * array3);\n\nint main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    double three[16];\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n\n    connectArrays(naturalNumber, one, two, three);\n\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%.f \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid connectArrays(unsigned int n, int * array1, int * array2, double * array3){\n    int i = 0;\n    for(i; i < 2*n; i++){\n        if(i < n){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[-n+i];\n        }\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid connectArrays(unsigned int, int * array1, int * array2, double * array3);\n\nint main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    double three[16];\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n\n    connectArrays(naturalNumber, one, two, three);\n\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%.f \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid connectArrays(unsigned int n, int * array1, int * array2, double * array3){\n    int counterEven = 0;\n    int counterOdd = 0;\n    int i = 0;\n    for(i; i < 2*n; i++){\n        if(i % 2 == 0){\n            array3[i] = array2[counterEven];\n            counterEven++;\n        } else {\n            array3[i] = array1[counterOdd];\n            counterOdd++;\n        }\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid changeCells(unsigned int, int * array1, int * array2, int * array3);\n\nint main()\n{\n    int one[8] = {55, 6, -8, -8, 10, 22, 0, 121};\n    int two[8] = {22, 1, -3, -4, 10, 21, 2, 233};\n    int three[8] = {33, 4, -9, -9, 99, 99, 0, 400};\n    unsigned int naturalNumber = 8;\n\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    printf(\"\\n\\nMieszanie tablic!!!\\n\\n\");\n    changeCells(naturalNumber, one, two, three);\n\n     printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)\/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)\/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)\/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n\n    getchar();;\n    return 0;\n}\n\nvoid changeCells(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        int a = array1[i], b = array2[i], c = array3[i];\n        int max = (a>=b && a>=c) ? a : (b>=a&&b>=c) ? b : c;\n        int min = (a<=b && a<=c) ? a : (b<=a&&b<=c) ? b : c;\n        int mid = (c!=max && c!=min) ? c : (b!=max && b!=min) ? b : a;\n        array1[i] = max;\n        array2[i] = mid;\n        array3[i] = min;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#define MIESIACE 12\n#define LATA 5\n\nint main()\n{\n    const float deszcz[LATA][MIESIACE] = {\n        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},\n        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},\n        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},\n        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},\n        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}\n    };\n\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n    int licznik = 0;\n\n    for(rok = deszcz, suma = 0; rok <= &deszcz[4][11]; rok = rok + MIESIACE){\n        for(miesiac = deszcz[licznik], podsuma = 0; miesiac <= &deszcz[licznik][11]; miesiac++){\n            podsuma += *miesiac;\n\n        }\n        printf(\"%5d %12.1f\\n\", 1995 + licznik, podsuma);\n        licznik++;\n        suma += podsuma;\n    }\n\n    printf(\"\\nRoczna srednia wynosi %.1f cm.\\n\\n\", suma\/LATA);\n    printf(\"SREDNIE MIESIECZNE:\\n\\n\");\n    printf(\" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz \");\n    printf(\" Lis  Gru\\n\");\n\n    for (miesiac = deszcz; miesiac <= &deszcz[0][11]; miesiac++){\n        for(rok = miesiac, podsuma = 0; rok <= &deszcz[4][11]; rok = rok + 12){ \n            podsuma += *rok;\n        }\n        printf(\"%4.1f \", podsuma\/LATA);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#define MIESIACE 12\n#define LATA 5\n\nvoid printAvgYear(float pointer[][0]);\nvoid printAvgMonth(float apointer[][0]);\n\nint main()\n{\n    const float deszcz[LATA][MIESIACE] = {\n        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},\n        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},\n        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},\n        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},\n        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}\n    };\n\n    printAvgYear(deszcz);\n    printAvgMonth(deszcz);\n\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid printAvgYear(float pointer[][0]){\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n    int licznik = 0;\n\n    for(rok = *pointer, suma = 0; rok <= *pointer + 48; rok = rok + 12){\n        for(miesiac = *pointer + (12*licznik) , podsuma = 0; miesiac <= *pointer + 11 + (12*licznik); miesiac++){\n            podsuma += *miesiac;\n        }\n        printf(\"%5d %12.1f\\n\", 1995 + licznik, podsuma);\n        licznik++;\n        suma += podsuma;\n    }\n\n    printf(\"\\nRoczna srednia wynosi %.1f cm.\\n\\n\", suma\/LATA);\n}\n\nvoid printAvgMonth(float pointer[][0]){\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n\n    printf(\"SREDNIE MIESIECZNE:\\n\\n\");\n    printf(\" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz \");\n    printf(\" Lis  Gru\\n\");\n\n    for (miesiac = *pointer; miesiac <= *pointer + 11; miesiac++){\n        for(rok = miesiac, podsuma = 0; rok <= *pointer + 48 + 11; rok = rok + 12){ \n            podsuma += *rok;\n        }\n        printf(\"%4.1f \", podsuma\/LATA);\n    }\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float a, c, x1, x2, delta;\n\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a: \");\n    scanf(\"%f\", &a);\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c: \");\n    scanf(\"%f\", &c);\n\n    delta = (2*2) - 4*3*a*c;\n\n    if(a == 0){\n        printf(\"\\n'a' = 0!. Pierwiastek wynosi:\");\n        x1 = (-3*c)\/2;\n        printf(\"\\nX1= %.2f\\n\", x1);\n    }else if(delta < 0){\n        printf(\"Rownanie nie ma rozwiazan.\");\n    } else {\n        x1 = (-2-sqrt(delta))\/(2*a);\n        x2 = (-2+sqrt(delta))\/(2*a);\n        printf(\"\\nX1= %.2f\\n\", x1);\n        printf(\"X1= %.2f\\n\", x2);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#define FREE 17850\n#define HEAD 23900\n#define MARRIEDT 29750\n#define MARRIEDS 14875\n#define TAX1 0.15\n#define TAX2 0.28\n\nint main()\n{\n    int endProgram = 0;\n\n    while(!endProgram) {\n\n        int userCategory;\n        float userIncome;\n        float userTax;\n        int userChoice;\n        int valueOK = 0;\n\n        while(!valueOK) {\n            printf(\"********************************************************************\\n\");\n            printf(\"Wybierz odpowiednia opcje:\\n\");\n            printf(\"1) Stan wolny\\t\\t\\t2) Glowa rodziny\\n\");\n            printf(\"3) Malzenstwo, wspolnie\\t\\t4) Malzenstwo, osobno\\n\");\n            printf(\"5) wyjscie\\n\");\n            printf(\"********************************************************************\\n\");\n            userChoice = getchar();\n\n            switch (userChoice) {\n                case '1' : {\n                    userCategory = FREE;\n                    printf(\"Wybrano [Stan wolny]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '2' : {\n                    userCategory = HEAD;\n                    printf(\"Wybrano [Glowa rodziny]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '3' : {\n                    userCategory = MARRIEDT;\n                    printf(\"Wybrano [Malzenstwo, wspolnie]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '4' : {\n                    userCategory = MARRIEDS;\n                    printf(\"Wybrano [Malzenstwo, osobno]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '5' : {\n                    valueOK = 1;\n                    endProgram = 1;\n                    break;\n                }\n                default : fflush(stdin);\n            }\n\n        }\n\n        if (!endProgram) {\n            printf(\"Podaj dochod podlegajacy opodatkowaniu: \");\n            scanf(\"%f\", &userIncome);\n            if(userIncome <= userCategory){\n                userTax = TAX1 * userIncome;\n            } else {\n                userTax = TAX1 * userCategory + (userIncome - userCategory) * TAX2;\n            }\n            printf(\"Wysokosc naleznego podatku: %.2f$\\n\\n\", userTax);\n            getchar();\n        }\n    }\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    double userNumber;\n    double numbersArray[3][5];\n    char letterCollection;\n\n    int licznik1 = 0;\n    int licznik2 = 0;\n\n    double sum, sumAll, biggestNumber;\n\n    while(licznik1 < 3) {\n        switch (licznik1){\n            case 0:\n                letterCollection = 'A';\n            break;\n            case 1:\n                letterCollection = 'B';\n            break;\n            case 2:\n                letterCollection = 'C';\n            break;\n        }\n        printf(\"Podaj liczbe nr %d dla zbioru %c: \", licznik2 + 1, letterCollection);\n        scanf(\"%lf\", &userNumber);\n        numbersArray[licznik1][licznik2] = userNumber;\n        licznik2++;\n        if(licznik2 >= 5){\n            licznik1++;\n            licznik2 = 0;\n        }\n    }\n\n    printf(\"\\n\");\n\n    licznik1 = 0;\n    licznik2 = 0;\n\n    for(licznik1; licznik1 < 3; licznik1++){\n            switch (licznik1){\n            case 0:\n                letterCollection = 'A';\n            break;\n            case 1:\n                letterCollection = 'B';\n            break;\n            case 2:\n                letterCollection = 'C';\n            break;\n        }\n        for(licznik2; licznik2 < 5; licznik2++){\n            printf(\"%d liczba w zbiorze %c: %.2f\\n\", licznik2 + 1, letterCollection, numbersArray[licznik1][licznik2]);\n            sum += numbersArray[licznik1][licznik2];\n            if(biggestNumber < numbersArray[licznik1][licznik2]){\n               biggestNumber = numbersArray[licznik1][licznik2];\n            }\n        }\n        licznik2 = 0;\n        printf(\"Srednia zbioru %c: %.2lf\\n\\n\", letterCollection, sum\/5);\n        sumAll += sum;\n        sum = 0;\n    }\n\n    printf(\"Srednia wszystkich zbior\\242w: %.2lf\\n\", sumAll\/15);\n    printf(\"Najwi\\251ksza liczba: %.2lf\\n\\n\", biggestNumber);\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define GODZINA 60\n\nbool nextCalculation(void); \n\nint main()\n{\n    int godziny, minuty, czasWMinutach;\n    bool endProgram = false;\n\n    while(!endProgram){\n        printf(\"Podaj ilo\\230\\206 minut do przeliczenia.\\n\");\n        scanf(\"%d\", &czasWMinutach);\n\n        godziny = czasWMinutach \/ GODZINA;\n        minuty = czasWMinutach % GODZINA;\n\n        printf(\"%d minut to %d godzin i %d minut\\n\\n\", czasWMinutach, godziny, minuty);\n        fflush(stdin);\n\n        endProgram = nextCalculation();\n    }\n\n    return 0;\n}\n\nbool nextCalculation(void) {\n\n    char userResponse;\n    printf(\"Czy chcesz przeliczyc czas ponownie? y\/n: \");\n    scanf(\"%c\", &userResponse);\n    if (userResponse != 121) {\n            return true;\n    }\n    fflush(stdin);\n    return false;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid rzad_zn(char ch, int i, int j);\n\nint main()\n{\n    char userChar;\n    int columnStart;\n    int columnEnd;\n\n    printf(\"Podaj znak: \");\n    scanf(\"%c\", &userChar);\n    printf(\"Podaj pocz\\245tkow\\245 kolumn\\251: \");\n    scanf(\"%d\", &columnStart);\n    printf(\"Podaj ko\\344cow\\245 kolumn\\251: \");\n    scanf(\"%d\", &columnEnd);\n\n    rzad_zn(userChar,columnStart, columnEnd);\n\n    return 0;\n}\n\nvoid rzad_zn(char ch, int i, int j) {\n    char space = ' ';\n    for(int k = i; k > 1; k--){\n        putchar(space);\n    }\n    for(int k = i; k <= j; k++){\n        putchar(ch);\n    }\n    return;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size);\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size);\n\nint main()\n{\n   int array1[7] = {8, 32, -4, 5, 6, 93, 345};\n   int array2[7];\n   int array3[7];\n   int arraySize = sizeof(array1)\/sizeof(*array1);\n\n    copyArrayNormal(array1, array2, arraySize);\n    copyArrayPointer(array1, array3, arraySize);\n\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize; i++){\n        printf(\"%d \", array1[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"array2: \");\n    for(int i = 0; i < sizeof(array2)\/sizeof(*array2); i++){\n        printf(\"%d \", array2[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"array3: \");\n    for(int i = 0; i < sizeof(array3)\/sizeof(*array3); i++){\n        printf(\"%d \", array3[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n};\n\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid wiersz_zn(char ch, int i, int j);\n\nint main()\n{\n    char userChar;\n    int charsInRow;\n    int numberOfRows;\n\n    printf(\"Podaj znak: \");\n    scanf(\"%c\", &userChar);\n    printf(\"Podaj ilo\\230\\206 znak\\242w w wierszu: \");\n    scanf(\"%d\", &charsInRow);\n    printf(\"Podaj liczb\\251 wierszy: \");\n    scanf(\"%d\", &numberOfRows);\n\n    wiersz_zn(userChar,charsInRow, numberOfRows);\n\n    return 0;\n}\n\nvoid wiersz_zn(char ch, int i, int j) {\n    putchar('\\n');\n    for(j; j > 0; j--){\n        for(int k = i; k > 0; k--){\n            putchar(ch);\n        }\n        putchar('\\n');\n    }\n    return;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float a, b, c;\n    int licznik = 0;\n\n    printf(\"Podaj 1 liczbe: \");\n    scanf(\"%f\", &a);\n    printf(\"Podaj 2 liczbe: \");\n    scanf(\"%f\", &b);\n    printf(\"Podaj 3 liczbe: \");\n    scanf(\"%f\", &c);\n\n    if(a >= b && a >= c ) {\n        printf(\"Najwieksza liczba to %.2f\\n\", a);\n        if(b >= c) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", c);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", b);\n        }\n    } else if ( b >= c) {\n        printf(\"Najwieksza liczba to %.2f\\n\", b);\n        if(a >= c) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", c);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", a);\n        }\n    } else {\n        printf(\"Najwieksza liczba to %.2f\\n\", c);\n        if(a >= b) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", b);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", a);\n        }\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int array[10];\n    int userNumber;\n    int licznik = 0;\n    int smallestNum;\n    int smallestIndex;\n\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%d\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n\n    smallestNum = array[0];\n    smallestIndex = 0;\n\n    for(int i = 1; i < 10; i++){\n        if(array[i] < smallestNum) {\n            smallestNum = array[i];\n            smallestIndex = i;\n        }\n    }\n\n    printf(\"\\nNajmniejsza liczba w tablicy: %d\\n\", smallestNum);\n    printf(\"Indeks najmniejszej liczby w tablicy: %d\\n\", smallestIndex);\n\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h> \n\nint main()\n{\n    char ch;\n    int oddSum = 0;\n    int evenSum = 0;\n    int oddCounter = 0;\n    int evenCounter = 0;\n\n    printf(\"Podaj liczby ca\\210kowite. '0' zako\\344czy program!\\n\");\n    while((ch = getchar()) != '0') {\n        if (isdigit(ch)){\n            if ( ch % 2 == 0) {\n                evenCounter++;\n                evenSum += ch - '0'; \n            } else {\n                oddCounter++;\n                oddSum += ch - '0';\n            }\n        }\n    }\n    printf(\"Liczb parzystych: %d\\nSrednia warto\\230\\206: %d\\n\\n\", evenCounter, evenSum \/ evenCounter);\n    printf(\"Liczb nieparzystych: %d\\nSrednia warto\\230\\206: %d\\n\", oddCounter, oddSum \/ oddCounter);\n\n    getchar();\n    return 0;\n}\n\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float array[10];\n    float userNumber;\n    float sumPlus = 0;\n    float sumMinus = 0;\n    int licznik = 0;\n    int licznikPlus = 0;\n    int licznikMinus = 0;\n\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%f\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n\n    for(int i = 0; i < 10; i++){\n        if(array[i] > 0){\n            sumPlus += array[i];\n            licznikPlus++;\n        }\n        if(array[i] < 0){\n            sumMinus += array[i];\n            licznikMinus++;\n        }\n    }\n\n    if (licznikPlus != 0) {\n        printf(\"Srednia arytmatyczna dodatnich elementow: %.2f\\n\", sumPlus\/licznikPlus);\n    } else {\n        printf(\"Srednia arytmatyczna dodatnich elementow wynosi 0\\n\");\n    }\n\n    if (licznikMinus != 0) {\n        printf(\"Srednia arytmatyczna ujemnych elementow: %.2f\\n\", sumMinus\/licznikMinus);\n    } else {\n        printf(\"Srednia arytmatyczna ujemnych elementow wynosi 0\\n\");\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h> \n\nint main()\n{\n    char ch;\n    int changeCounter = 0;\n\n    printf(\"Podaj znaki. '#' zako\\344czy program!\\n\");\n    while((ch = getchar()) != '#') {\n        if(ch == '!') {\n            putchar(ch);\n            putchar(ch);\n            changeCounter++;\n            continue;\n        }\n        if(ch == '.') {\n            ch = '!';\n            putchar(ch);\n            changeCounter++;\n            continue;\n        }\n        putchar(ch);\n    }\n    printf(\"\\nLiczba wykonanych zmian: %d\\n\", changeCounter);\n    getchar();\n    return 0;\n}\n\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint letterCheck(char c);\n\nint main()\n{\n    char wholeText[1000];\n\n    FILE *f = fopen(\"testFile_Zad5.txt\", \"r\");    \n    if (f == NULL)\n    {\n        perror(\"Nie udalo sie otworzyc pliku testFile_Zad5.txt\");\n        return 1;\n    }\n    puts(\"Plik otwarty pomyslnie!\");\n    fscanf(f, \"%[]\", wholeText);\n    printf(\"\\nTekst z pliku:\\n%s\", wholeText);\n    printf(\"\\n\\n\");\n\n    for(int i = 0; i < strlen(wholeText); i++){\n        putchar(wholeText[i]);\n        printf(\" - \");\n        if(letterCheck(wholeText[i]) == -1){\n            printf(\"Znak nie jest liter\\245.\\n\");\n        } else {\n            printf(\"Jest %d liter\\245 alfabetu.\\n\", letterCheck(wholeText[i]));\n        }\n    }\n\n    fclose(f);\n    return 0;\n}\n\nint letterCheck(char c){\n    int alphabetNumber;\n    int asciiNumber = c;\n    if(asciiNumber >= 65 && asciiNumber <= 90){\n        alphabetNumber = asciiNumber - 64;\n        return alphabetNumber;\n    } else if(asciiNumber >= 97 && asciiNumber <= 122){\n        alphabetNumber = asciiNumber - 96;\n        return alphabetNumber;\n    }\n    return -1;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nfloat difference(float sourceArray[]);\n\nint main()\n{\n   float array[10] = {8.2, 32, -4.56, 5.666, 6.32, 93, 345, -74.32, 424.23, -425.53, 89, 56};\n\n    printf(\"Roznica najwiekszej i najmniejszej wartosci, to: %.2f\\n\", difference(array));\n\n    return 0;\n}\n\nfloat difference(float sourceArray[]){\n    int size = 12;\n    float biggest;\n    float smallest;\n    float diff;\n    for(int i = 0; i < size; i++){\n        if(biggest < sourceArray[i]){\n            biggest = sourceArray[i];\n        }\n        if(smallest > sourceArray[i]){\n            smallest = sourceArray[i];\n        }\n    }\n\n    diff = biggest - smallest;\n    return diff;\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint kwadrat(int);\nint szescian(int);\n\nint main()\n{\n    int userMin, userMax;\n\n    printf(\"Podaj liczb\\251 dolnej granicy tabeli: \");\n    scanf(\"%d\", &userMin);\n    printf(\"Podaj liczb\\251 g\\242rnej granicy tabeli: \");\n    scanf(\"%d\", &userMax);\n\n    printf(\"\\nLiczba\\t\\tKwadrat\\t\\tSze\\230cian\");\n\n    for(char i = userMin; i <= userMax; i++) {\n        printf(\"\\n%5d\\t\\t%5d\\t\\t%5d\", i, kwadrat(i), szescian(i));\n    }\n\n    getchar();\n    return 0;\n}\n\nint kwadrat(int x) {\n    return x*x;\n}\n\nint szescian(int x) {\n    return x*x*x;\n}\n\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h> \n\nint main()\n{\n    char ch;\n    int oddSum = 0;\n    int evenSum = 0;\n    int oddCounter = 0;\n    int evenCounter = 0;\n\n    printf(\"Podaj liczby ca\\210kowite. '0' zako\\344czy program!\\n\");\n    while((ch = getchar()) != '0') {\n        if (isdigit(ch)){\n            switch (ch % 2) {\n                case 0 :\n                evenCounter++;\n                evenSum += ch - '0'; \n                break;\n            default :\n                oddCounter++;\n                oddSum += ch - '0';\n                break;\n            }\n        }\n    }\n    printf(\"Liczb parzystych: %d\\nSrednia warto\\230\\206: %d\\n\\n\", evenCounter, evenSum \/ evenCounter);\n    printf(\"Liczb nieparzystych: %d\\nSrednia warto\\230\\206: %d\\n\", oddCounter, oddSum \/ oddCounter);\n\n    getchar();\n    return 0;\n}\n\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\ndouble power(double x, int y);\n\nint main()\n{\n    double userNumber;\n    int userPower;\n    printf(\"Podaj liczb\\251: \");\n    scanf(\"%lf\", &userNumber);\n    printf(\"Podaj pot\\251g\\251 ca\\210kowit\\245: \");\n    scanf(\"%d\", &userPower);\n    printf(\"%.3lf do pot\\251gi %d wynosi %.3lf\\n\", userNumber, userPower, power(userNumber, userPower));\n    return 0;\n}\n\ndouble power(double x, int y){\n    double result = x;\n    if(x == 0) return 0;\n    if(y == 0) return 1;\n    if(y<0){\n        result = 1\/x;\n       for(int i = y + 1; i < 0; i++){\n        result = result * (1\/x);\n        }\n        return result;\n    }\n    for(int i = 1; i < y; i++){\n        result = result * x;\n    }\n    return result;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size);\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size);\n\nint main()\n{\n   int array1[7][3] = {\n        {8, 32, -4},\n        {5, 6, 93},\n        {345, 32, -32},\n        {3, 3, -3},\n        {-6, -5, -5},\n        {0, 0, 0},\n        {0, 2, -2}\n        };\n\n   int array2[7][3];\n   int array3[7][3];\n   int arraySizeOut = sizeof(array1)\/sizeof(*array1);\n   int arraySizeIn = sizeof(array1[0])\/sizeof(*array1[0]);\n\n    for(int i = 0; i < arraySizeOut; i++){\n        copyArrayNormal(array1[i], array2[i], arraySizeIn);\n    }\n    for(int i = 0; i < arraySizeOut; i++){\n        copyArrayPointer(array1[i], array3[i], arraySizeIn);\n    }\n\n    printf(\"array1\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array1[i][j]);\n        }\n    }\n\n    printf(\"\\n\\narray2\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array2[i][j]);\n        }\n    }\n\n\n    printf(\"\\n\\narray3\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array3[i][j]);\n        }\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n};\n\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\ndouble power(double x, int y);\n\nint main()\n{\n    double userNumber;\n    int userPower;\n    printf(\"Podaj liczb\\251: \");\n    scanf(\"%lf\", &userNumber);\n    printf(\"Podaj pot\\251g\\251 ca\\210kowit\\245: \");\n    scanf(\"%d\", &userPower);\n    printf(\"%.3lf do pot\\251gi %d wynosi %.3lf\\n\", userNumber, userPower, power(userNumber, userPower));\n    return 0;\n}\n\ndouble power(double x, int y){\n    double result = x;\n    if(x == 0) return 0;\n    if(y == 0) return 1;\n    if(y<0){\n        result = 1\/x;\n        x = 1\/x;\n        y = -y;\n    }\n    if(y > 0){\n        result = result * power(x, y - 1);\n    }\n    return result;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\n    float number1, number2;\n    int endProgram = 0;\n\n    while(!endProgram){\n\n        printf(\"Podaj pierwsz\\245 liczb\\251: \");\n        if(scanf(\"%f\", &number1) == 1) {\n\n            printf(\"Podaj drug\\245 liczb\\251: \");\n\n            if(scanf(\"%f\", &number2) == 1) {\n\n                float wynik = (number1 - number2) \/ (number1 * number2);\n                printf(\"\\nWynik: %3f\\n\\n\", wynik);\n\n            } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n            }\n        } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n        }\n    }\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#define BASICHOUR 40\n#define OVERTIME 1.5\n#define TAX1 0.15\n#define TAX2 0.20\n#define TAX3 0.25\n\nint main()\n{\n    int workHours;\n    float brutto;\n    float podatek;\n\n    printf(\"Podaj liczb\\251 przepracowanych godzin w tygodniu: \");\n    scanf(\"%d\", &workHours);\n\n    if(workHours >= 40) {\n        brutto = 40 * BASICHOUR + (workHours - 40) * BASICHOUR * OVERTIME;\n    } else {\n        brutto = workHours * BASICHOUR;\n    }\n\n    if (brutto <= 1200) {\n        podatek = brutto * TAX1;\n    } else if (brutto > 1200 && brutto <= 1800) {\n        podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;\n    } else {\n        podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;\n    }\n\n    printf(\"\\nWynagrodzenie brutto: %.2fz\\210\\n\", brutto);\n    printf(\"Podatek: %.2fz\\210\\n\", podatek);\n    printf(\"Wynagrodzenie netto: %.2fz\\210\\n\", brutto - podatek);\n\n    getchar();\n    return 0;\n}\n\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size);\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size);\n\nint main()\n{\n   int array1[7] = { 8, 32, -4, 43, 200, 4000, -6432};\n\n   int array2[3];\n   int array3[3];\n\n   int arraySize1 = sizeof(array1)\/sizeof(*array1);\n   int arraySize2 = sizeof(array2)\/sizeof(*array2);\n    int arraySize3 = sizeof(array3)\/sizeof(*array3);\n\n    copyArrayNormal(&array1[2], array2, arraySize2); \n    copyArrayPointer(&array1[2], array3, arraySize3);\n\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize1; i++){\n            printf(\"%d \", array1[i]);\n    }\n\n    printf(\"\\n\\narray2: \");\n    for(int i = 0; i < arraySize2; i++){\n            printf(\"%d \", array2[i]);\n    }\n\n    printf(\"\\n\\narray3: \");\n    for(int i = 0; i < arraySize3; i++){\n            printf(\"%d \", array3[i]);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n};\n\nvoid copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid do_binar(int n, int sys);\n\nint main()\n{\n    int liczba;\n    int systemLiczbowy;\n\n    printf(\"Podaj liczb\\251 ca\\210kowit\\245 (q ko\\344czy program):\\n\");\n\n    while(scanf(\"%d\", &liczba) == 1){\n        printf(\"Podaj system liczbowy z zakresu od 2 do 10:\\n\");\n        scanf(\"%d\", &systemLiczbowy);\n        printf(\"Odpowiednik w podanym systemie: \");\n        do_binar(liczba, systemLiczbowy);\n        putchar('\\n');\n        printf(\"Podaj liczb\\251 ca\\210kowit\\245 (q ko\\344czy program):\\n\");\n    }\n    return 0;\n}\n\nvoid do_binar(int n, int sys){\n    int r;\n    if(sys < 2 || sys > 10){\n        printf(\"Podano system liczbowy spoza zakresu!!!\");\n        return;\n    }\n\n    r = n % sys;\n    if(n >= sys)\n        do_binar(n \/ sys, sys);\n    putchar('0' + r);\n    return;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint wynik(float, float);\n\nint main()\n{\n\n    float number1, number2;\n    int endProgram = 0;\n\n    while(!endProgram){\n\n        printf(\"Podaj pierwsz\\245 liczb\\251: \");\n        if(scanf(\"%f\", &number1) == 1) {\n\n            printf(\"Podaj drug\\245 liczb\\251: \");\n\n            if(scanf(\"%f\", &number2) == 1) {\n\n                wynik(number1, number2);\n\n            } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n            }\n        } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n        }\n    }\n\n    getchar();\n    return 0;\n}\n\nwynik(float x, float y) {\n    float result = (x - y) \/ (x * y);\n    printf(\"\\nWynik: %3f\\n\\n\", result);\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n#define BASICHOUR1 35\n#define BASICHOUR2 37\n#define BASICHOUR3 40\n#define BASICHOUR4 45\n#define OVERTIME 1.5\n#define TAX1 0.15\n#define TAX2 0.20\n#define TAX3 0.25\n\nint main()\n{\n    int userBasicHour;\n    int workHours;\n    float brutto;\n    float podatek;\n    int userChoice;\n    int valueOK = 0;\n    int endProgram = 0;\n\n    while(!valueOK) {\n        printf(\"********************************************************************\\n\");\n        printf(\"Podaj liczb\\251 odpowiadaj\\245c\\245 zadanej stawce wynagrodzenia lub opcji:\\n\");\n        printf(\"1) 35zl\/godz.\\t\\t2) 37zl\/godz.\\n\");\n        printf(\"3) 40zl\/godz.\\t\\t4) 45zl\/godz.\\n\");\n        printf(\"5) wyjscie\\n\");\n        printf(\"********************************************************************\\n\");\n        userChoice = getchar();\n\n        switch (userChoice) {\n            case '1' : {\n                userBasicHour = BASICHOUR1;\n                printf(\"Wybrano stawk\\251 45zl\/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '2' : {\n                userBasicHour = BASICHOUR2;\n                printf(\"Wybrano stawk\\251 45zl\/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '3' : {\n                userBasicHour = BASICHOUR3;\n                printf(\"Wybrano stawk\\251 45zl\/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '4' : {\n                userBasicHour = BASICHOUR4;\n                printf(\"Wybrano stawk\\251 45zl\/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '5' : {\n                valueOK = 1;\n                endProgram = 1;\n                break;\n            }\n            default : fflush(stdin);\n        }\n\n    }\n\n    if (!endProgram) {\n        printf(\"Podaj liczb\\251 przepracowanych godzin w tygodniu: \");\n        scanf(\"%d\", &workHours);\n\n        if(workHours >= 40) {\n            brutto = 40 * userBasicHour + (workHours - 40) * userBasicHour * OVERTIME;\n        } else {\n            brutto = workHours * userBasicHour;\n        }\n\n        if (brutto <= 1200) {\n            podatek = brutto * TAX1;\n        } else if (brutto > 1200 && brutto <= 1800) {\n            podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;\n        } else {\n            podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;\n        }\n\n        printf(\"\\nWynagrodzenie brutto: %.2fz\\210\\n\", brutto);\n        printf(\"Podatek: %.2fz\\210\\n\", podatek);\n        printf(\"Wynagrodzenie netto: %.2fz\\210\\n\", brutto - podatek);\n\n        getchar();\n    }\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nvoid AddArraysPointer(int sourceArray[], int outputArray[], int size);\n\nint main()\n{\n   int array1[8] = { 8, 32, -4, 43, 200, 4000, -6432, 7};\n\n   int array2[8] = { 2, -32, -4, 653, -199, 4010, -6432, 14};\n   int array3[8];\n\n   int arraySize = sizeof(array1)\/sizeof(*array1);\n\n    addArraysPointer(array1, array2, array3, arraySize);\n\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array1[i]);\n    }\n\n    printf(\"\\n\\narray2: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array2[i]);\n    }\n\n    printf(\"\\n\\narray3: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array3[i]);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid addArraysPointer(int sourceArray1[], int sourceArray2[], int outputArray[], int size){\n    int * pointerSource1 = sourceArray1;\n    int * pointerSource2 = sourceArray2;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource1 + *pointerSource2;\n        pointerSource1++;\n        pointerSource2++;\n        pointerOutput++;\n    }\n};\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    char userChar;\n    char userNumberString[255];\n    int userNumber;\n    int counter = 0;\n\n    printf(\"Podaj liczbe calkowita: \");\n\n    while((userChar = getchar()) != '\\n') {\n        userNumberString[counter] = userChar;\n        counter++;\n    }\n    userNumber = atoi(userNumberString); \n\n    printf(\"Liczby pierwsze podanej liczby: \");\n    for(int i = 2; i <= userNumber; i++) {\n        int primeCounter = 0;\n        for(int j = 1; j <= i; j++){\n            if(i % j == 0 ) {\n                primeCounter++;\n            }\n        }\n        if(primeCounter == 2){\n            printf(\" [%d]; \", i);\n        }\n    }\n\n    getchar();\n    return 0;\n}\n"}
{"target":"Cz8rT","func":"#include <stdio.h>\n\nvoid showArray(int sourceArray[], int size);\nvoid multiplyByTwo(int sourceArray[], int size);\n\nint main()\n{\n   int array[3][5] = {\n            {8, 32, -4, 43, 200},\n            {-8, 102, -8, -3, 100},\n            {18, -2, -1, 21, 400},\n       };\n\n   int arraySize = sizeof(array)\/sizeof(*array);\n\n    showArray(array, arraySize);\n    multiplyByTwo(array, arraySize);\n    printf(\"\\n\");\n    showArray(array, arraySize);\n\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid showArray(int sourceArray[], int size){\n    int * pointerSourceArray = sourceArray;\n    printf(\"array\\n\");\n    for(int i = 0; i < size; i++){\n        printf(\"Podtablica: \");\n        for(int j = 0; j < 5; j++){\n            printf(\"%d \", pointerSourceArray[j+(i*5)]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid multiplyByTwo(int sourceArray[], int size){\n    int * pointerSourceArray = sourceArray;\n    for(int i = 0; i < size*5; i++){\n        *pointerSourceArray = *pointerSourceArray * 2;\n        pointerSourceArray++;\n    }\n};\n"}
{"target":"DanielSalis","func":"#include<stdio.h>\n#include<stdlib.h>\n\n\ntypedef struct elemento{\n    int IDcidade;\n    int distancia;\n    struct elemento* ant;\n    struct elemento* prox;\n}TipoElemento;\n\ntypedef struct lista_dinamica{\n    TipoElemento* primeiro;\n    TipoElemento* ultimo;\n    int tamanho;\n}TipoLista;\n\nvoid iniciarLista(TipoLista* l){\n    l->primeiro = NULL;\n    l->ultimo = NULL;\n    l->tamanho = 0;\n}\n\nint existeNaLista(TipoLista*l, int IDcidade){\n    TipoElemento* aux = l->primeiro;\n    while(aux!=NULL){\n        if(aux->IDcidade == IDcidade){\n            return 1;\n        }\n        aux = aux->prox;\n    }\n\n    return 0;\n}\n\nvoid inserir(TipoLista*l , int IDcidade, int distancia){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->IDcidade = IDcidade;\n    novoElemento->distancia = distancia;\n\n    if(l->tamanho == 0){\n        l->primeiro = novoElemento;\n        l->ultimo = novoElemento;\n        novoElemento->prox = NULL;\n        novoElemento->ant = NULL;               \n    }else{\n        l->ultimo->prox = novoElemento;\n        novoElemento->ant = l->ultimo;\n        l->ultimo = novoElemento;\n        novoElemento->prox = NULL;\n    }\n    l->tamanho++;\n}\n\nint jaPercorri(TipoLista*l ,int IDcidade){\n    int existe = existeNaLista(l, IDcidade);\n    if(existe){\n        int somaDistancia = 0;\n        int contCidades = 0;\n        \n        TipoElemento* aux = l->primeiro;\n        \n        while(aux->IDcidade != IDcidade){\n            somaDistancia = somaDistancia + aux->distancia;\n            contCidades++;\n            aux = aux->prox;\n        }\n\n        printf(\"estou na cidade %d:\\n\", IDcidade);\n        printf(\"ja percorri %d km, passando por %d cidades\", somaDistancia, contCidades);\n        return 1;\n    }else{\n        printf(\"cidade nao existe no percurso\");\n        return 0;\n    }\n}\n\nint faltamPercorrer(TipoLista*l, int IDcidade){\n    int existe = existeNaLista(l, IDcidade);\n    int Distancia = 0;\n    int contCidades=1;\n    \n    if(existe){\n        TipoElemento* aux = l->ultimo;\n        \n        while(aux->IDcidade != IDcidade){\n            Distancia = Distancia + aux->distancia;\n            contCidades++;\n            aux = aux->ant;\n        }\n        Distancia = Distancia + aux->distancia;\n        aux = aux->ant;\n\n        printf(\"estou na cidade %d:\\n\", IDcidade);\n        printf(\"faltam percorrer %d km, passando por %d cidades\", Distancia, contCidades-1);\n        return 1;\n    }else{\n        printf(\"cidade nao existe no percurso\");\n        return 0;\n    }\n}\n\nvoid calculaTrajetoTotal(TipoLista* l){\n    int distanciaTotal = 0;\n    int contCidades=0;\n    TipoElemento* aux = l->primeiro;\n\n    while(aux!=NULL){\n        distanciaTotal = distanciaTotal + aux->distancia;\n        contCidades++;\n        aux = aux->prox;\n    }\n    printf(\"o trajeto total tem %d kms, passando\\n\", distanciaTotal);\n    printf(\"por %d cidades\\n\", contCidades);\n}\n\nint main(){\n    int flag;\n    int op = 1;\n    int IDcidade;\n    int distancia;\n\n    TipoLista lista;\n    iniciarLista(&lista);\n\n    while(op==1){\n        scanf(\"%d\", &op);\n        \n\n        \n        if(op==1){\n            scanf(\"%d %d\", &IDcidade, &distancia);\n            inserir(&lista, IDcidade, distancia);\n        }\n\n            else if(distancia != 0){\n                printf(\"trajeto invalido\");\n                return 0;\n            }\n            \n        \n        else if(op==2){\n            scanf(\"%d\", &IDcidade);\n            flag = jaPercorri(&lista, IDcidade);\n            if(flag==0){\n                break;\n            }\n        }\n\n        \n        else if(op==3){\n            scanf(\"%d\", &IDcidade);\n            flag = faltamPercorrer(&lista, IDcidade);\n            if(flag==0){\n                break;\n            }\n        }\n\n        \n        else if(op==4){\n            calculaTrajetoTotal(&lista);\n            break;\n        }\n\n        else{\n            printf(\"opcao invalida\");\n            break;\n        }\n    }\n    return 0;    \n}"}
{"target":"DanielSalis","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct elemento{\n    char nome;\n    int agilidade;\n    struct elemento* prox;\n    struct elemento* ant;\n}TipoElemento;\n\ntypedef struct listaCircular{\n    TipoElemento* primeiro;\n    int tamanho;\n}TipoLista;\n\nvoid iniciarLista(TipoLista* l){\n    l->primeiro = NULL;\n    l->tamanho = 0;\n}\n\nvoid inserirFim(TipoLista* l, char nome, int agilidade){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->nome = nome;\n    novoElemento->agilidade = agilidade;\n\n    if(l->tamanho == 0){\n        novoElemento->prox = novoElemento;\n        novoElemento->ant = novoElemento;\n        l->primeiro = novoElemento;\n        l->tamanho++;\n    }else{\n        novoElemento->prox = l->primeiro;\n        novoElemento->ant = l->primeiro->ant;\n        l->primeiro->ant->prox = novoElemento;\n        l->primeiro->ant = novoElemento;\n        l->tamanho++;\n    }\n}\n\nint existeNaLista(TipoLista *l, char nome){\n  int contador = l->tamanho;\n\n  if(contador == 0)\n    return 1;\n\n  TipoElemento *p = l->primeiro;\n\n  while(contador != 0)\n  {\n    if(p->nome == nome)\n      return 2;\n\n    p = p->prox;\n    contador--;\n  }\n  return 1;\n}\n\nint existeNaListaII(TipoLista *l, char nome)\n{\n  int contador = l->tamanho;\n\n  if(contador == 0)\n    return 2;\n\n  TipoElemento *p = l->primeiro;\n\n  while(contador != 0)\n  {\n    if(p->nome == nome)\n      return 1;\n\n    p = p->prox;\n    contador--;\n  }\n  return 3;\n}\n\nvoid imprimeLista(TipoLista* l){\n  TipoElemento *aux = l->primeiro;\n  int cont = 0;\n\n  while(cont != l->tamanho){\n    if(cont == 0)\n      printf(\"| \");\n    \n    printf(\"soldado: %c \", aux->nome);\n    aux = aux->prox;\n    cont++;\n    \n    if(cont != l->tamanho)\n      printf(\"-> \");\n    \n    else\n      printf(\"|\");\n  }\n}\n\n\nvoid sortear(TipoLista *l, char nome){\n  int rodada = 1;\n  char nomeAux = nome;\n\n  while(l->tamanho != 1){\n\n    int contador = rand() % 10;\n    int contadorAux = contador;\n\n    TipoElemento *p = l->primeiro;\n\n    printf(\"-> rodada %d: soldado %c, contagem %d\\n\", rodada, nomeAux, contador);\n\n    while(p->nome != nomeAux){\n      p = p->prox;\n    }\n    while(contadorAux != 0){\n      p = p->prox;\n      contadorAux--;\n      nomeAux = p->nome;\n    }\n\n    imprimeLista(l);\n    printf(\"\\nremovido: soldado %c\\n\", nomeAux);\n\n    if(p == l->primeiro){\n      l->primeiro = p->prox;\n    }\n    nomeAux = p->prox->nome;\n    p->ant->prox = p->prox;\n    p->prox->ant = p->ant;\n    p = NULL;\n    free(p);\n    l->tamanho--;\n    rodada++;\n\n  }\n  TipoElemento *n = l->primeiro;\n  if(n->agilidade < 7)\n    printf(\"soldado %c escolhido - ele nao tem agilidade suficiente -> vamos morrer!!\", n->nome);\n  else\n    printf(\"soldado %c escolhido e vai nos salvar!\",n->nome);\n\n}\n\nint main(){\n\n    int op;\n    int agilidade;\n    int existe;\n    char nome;\n\n    TipoLista lista;\n    iniciarLista(&lista);\n\n    scanf(\"%d\", &op);\n\n    while(op==1){\n        scanf(\" %c %d\", &nome, &agilidade);\n        existe = existeNaLista(&lista, nome);\n        \n        if(existe == 1)\n           inserirFim(&lista, nome, agilidade);\n        \n        else\n            printf(\"soldado nao pode ser inserido duas vezes\\n\");\n        \n        scanf(\"%d\", &op);\n    }\n\n    if(op == 2){\n        scanf(\" %c\", &nome);\n        existe = existeNaListaII(&lista, nome); \n        \n        if(existe == 1){\n            printf(\"|| sorteio iniciado ||\\n\");\n            sortear(&lista, nome);\n        }\n        else{\n            if(existe == 2)\n                printf(\"grupo vazio\");\n            \n            else\n                printf(\"soldado nao pertence ao grupo\");\n        }\n    }\n    return 0;\n}"}
{"target":"DanielSalis","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct elemento{\n    int id;\n    struct elemento* prox;\n}TipoElemento;\n\ntypedef struct fila{\n    TipoElemento* primeiro;\n    TipoElemento* ultimo;\n    int tamanho;\n    int tamMod;\n}TipoLista;\n\nvoid iniciarLista(TipoLista* l){\n    l->primeiro = NULL;\n    l->ultimo = NULL;\n    l->tamanho = 0;\n    l->tamMod = 0;\n}\n\nvoid remover(TipoLista* l){\n    if(l->tamanho == 0){\n        printf(\"lista vazia\\n\");\n    }else{\n        TipoElemento* aux = l->primeiro;\n        l->primeiro = l->primeiro->prox;\n        free(aux);\n        l->tamanho--;\n    }\n}\n\nint existeNalista(TipoLista* l, int id){\n    TipoElemento* aux = l->primeiro;\n    while(aux!=NULL){\n        if(aux->id == id){\n            return 1;\n        }\n        aux = aux->prox;\n    }\n    return 0;\n}\n\nvoid inserir(TipoLista* l, int id){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->id = id;\n\n    if(existeNalista(l, id) == 1){\n        printf(\"processo ja esta na fila\\n\"); \n    }\n    else{\n        if(l->tamanho == 0){\n            l->primeiro = novoElemento;\n            l->ultimo = novoElemento;\n            novoElemento->prox = NULL;\n            l->tamanho++;\n            l->tamMod++;\n        }else{\n            l->ultimo->prox = novoElemento;\n            l->ultimo = novoElemento;\n            novoElemento->prox = NULL;\n            l->tamanho++;\n            l->tamMod++;\n        }\n        \n        if(l->tamMod == 3){\n            printf(\"removendo processo %d em espera a muito tempo...\\n\", l->primeiro->id); \n            remover(l);\n            l->tamMod = 0;\n        }\n    }\n        \n}\n\nvoid imprimir(TipoLista* l){\n\n    \n    if(l->tamanho == 0){\n        printf(\"lista vazia\\n\");\n    }\n\n    else{\n        TipoElemento* aux = l->primeiro;\n        TipoElemento* auxProx = l->primeiro->prox;\n        printf(\"| \");\n        \n        while(auxProx){\n            printf(\"%d -> \", aux->id);\n            aux = auxProx;\n            if(auxProx==NULL){\n                break;\n            }\n            auxProx = auxProx->prox;\n        }\n        printf(\"%d |\\n\", aux->id);\n    }\n}\n\nint main(){\n    int op;\n    int IDprocesso;\n    TipoLista lista;\n\n    iniciarLista(&lista);\n    \n    while(op != -1){\n        scanf(\"%d\", &op);\n\n        if(op == -1){\n            break;\n        }\n        \n        if(op == 1){\n            scanf(\"%d\", &IDprocesso); \n            inserir(&lista, IDprocesso);\n        }\n\n        else if(op == 2){\n            remover(&lista);\n        }\n\n        else if(op == 3){\n            imprimir(&lista);\n        }\n\n        else{\n            printf(\"opcao invalida\\n\");\n            break;\n        }\n    }\n    \n    return 0;\n}"}
{"target":"DanielSalis","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n\ntypedef struct struct_node{\n    struct struct_node *left;\n    struct struct_node *right;\n    int key;\n}node;\n\nnode* createNode(int key){\n    node* newElement = (node*)malloc(sizeof(node));\n    newElement->key = key;\n    newElement->right = NULL;\n    newElement->left = NULL;\n    return (newElement);\n}\n\nnode* insert(node* root, int key){\n    if(root == NULL){\n        return createNode(key);\n    }\n\n    if(key < root->key){\n        root->left = insert(root->left, key);\n    }else if(key > root->key){\n        root->right = insert(root->right, key); \n    }\n\n    return root;\n}\n\nnode* search(node* root, int key){\n    if(root == NULL){\n        return NULL;\n    }\n\n    if (root->key == key)\n       return root;\n    if (root->key > key)\n       return search (root->left, key);\n    else\n       return search (root->right, key);\n}\n\nnode* findParent(node *aux, int key_parent){\n    if(aux != NULL){\n        node *NovoPai = findParent(aux->left, key_parent);\n        if(NovoPai == NULL) {\n            NovoPai = findParent(aux->right, key_parent);\n        }\n        return NovoPai;\n    }else{\n        return NULL;\n    }\n}\n\nnode* searchMinValue(node* root) {\n   while (root->left != NULL) {\n      root = root->left;\n   }\n   return root;\n}\n\nnode* deleteNode(node* root, int key){\n    if(root == NULL){\n        return root;\n    }\n\n    else if(key < root->key){\n        root->left = deleteNode(root->left, key);\n    }\n\n    else if(key > root->key){\n        root->right = deleteNode(root->right, key);\n    }\n\n    else{\n        \n        if(root->left == NULL && root->right == NULL){\n            free(root);\n            root = NULL;\n            return root;\n        }\n\n        \n        else if(root->left == NULL){\n            node* temp = root;\n            root = root->right;\n            free(temp);\n            return root;\n        }\n        else if(root->right == NULL){\n            node* temp = root;\n            root = root->left;\n            free(temp);\n            return root;\n        }\n\n        \n        else{\n            node* temp = searchMinValue(root->right);\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n    return root;\n}\n\nvoid printTree(node* root){\n    if(root == NULL){\n        return;\n    }\n    else{\n        printTree(root->left);\n            printf(\"%d \",root->key);\n            \n            \n        printTree(root->right);\n    }\n}\n\n\nint main(){\n\n    node *root;\n    node *aux;\n\n    int key;\n    int cont = 0; \n    int operacoes = 0;\n    char opcao;\n\n    scanf(\"%d\", &operacoes);\n\n    while(cont < operacoes){\n        scanf(\" %c\", &opcao);\n        \n        if(opcao == 'I'){\n            scanf(\"%d\", &key);\n            if(cont == 0){\n                root = createNode(key);\n            }else{\n                insert(root, key);\n            }\n            cont++;\n        }\n\n        else if(opcao == 'B'){\n            scanf(\"%d\", &key);\n            aux = search(root, key);\n            if(aux == NULL){\n                printf(\"N\");\n                printf(\"\\n\");\n            }else{\n                printf(\"S\");\n                printf(\"\\n\");\n            }\n            cont++;\n        }\n\n        else if(opcao == 'M'){\n            \n            printTree(root);\n            printf(\"\\n\");\n            cont++;\n        }\n\n        else if(opcao == 'R'){\n            \n            scanf(\"%d\", &key);\n            root = deleteNode(root, key);\n            cont++;\n        }\n    }\n    return 0;\n}\n"}
{"target":"DanielSalis","func":"\n  \n#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\nvoid bresenham1(int x1, int y1, int x2, int y2){        \n        int slope;\n        int dx, dy, incE, incNE, d, x, y; \n        if (x1 > x2 && y1 > y2){\n            bresenham1(x2, y2, x1, y1);\n             return;\n        }        \n        dx = x2 - x1;\n        dy = y2 - y1;\n    \n        if (dy < 0){            \n            slope = -1;\n            dy = -dy;\n        }\n        else{            \n           slope = 1;\n        }\n  \n        incE = 2 * dy;\n        incNE = 2 * dy - 2 * dx;\n        d = 2 * dy - dx;\n        y = y1;\n        \n    printf(\"dx = %d\\n\", dx);\n    printf(\"dy = %d\\n\",dy);\n    printf(\"2dy = %d\\n\",incE);\n    printf(\"2dy-2dx %d\\n\",incNE);\n\n    int tam;\n    if (x2 - x1 > 0){\n        tam = x2 - x1;\n    }\n    else if(x2-x1==0){\n        tam = y2-y1;\n    }\n    else{\n        tam = -(x2 - x1);\n    }\n\n    int vecX[tam];\n    int vecY[tam];\n    int vecPk[tam];\n    \n    int i =0;\n        \n        \n        if(x2-x1 == 0){\n            while(y1 < y2){\n                if (d < 0){\n                  d = d + incE;\n                }\n                else{\n                  d = d + incNE;\n                  x = x + slope;\n                }\n                \n                vecPk[i] = d;\n                vecX[i] = x1;\n                vecY[i] = y1;\n                i++;\n                y1++;\n            }\n            \n        }else{\n            while(x1 < x2){\n                if (d < 0){\n                  d = d + incE;\n                }\n                else{\n                  d = d + incNE;\n                  y = y + slope;\n                }\n                \n            vecPk[i] = d;\n            vecX[i] = x1;\n            vecY[i] = y;\n            i++;\n            x1++;\n            }\n        }\n        \n    printf(\"X  | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecX[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Y  | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecY[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Pk | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecPk[i]);\n    }\n    printf(\"\\n\");\n }\n\nvoid imprime(int *vec, int tam)\n{\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d\", vec[i]);\n    }\n}\n\nint main(void)\n{\n    bresenham1(30,5,30,15);\n    return 0;\n}\n"}
{"target":"DanielSalis","func":"#include <math.h>\n#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nfloat tx = 0.0;\nfloat ty = 0.0;\nfloat theta = 5.0;\n\nvoid circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 8; i++)\n  {\n    angulo = 2 * M_PI * i \/ 8;\n    glVertex2f(0.125 * cos(angulo), 0.125 * sin(angulo));\n  }\n  glEnd();\n\n}\n\nvoid quadrado(float x, float y)\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.2 + x, 0.2 + y);\n  glVertex2f(0.2 + x, 0.2 + y);\n  glVertex2f(0.2 + x, -0.2 + y);\n  glVertex2f(-0.2 + x, -0.2 + y);\n  glEnd();\n}\n\nvoid retangulo()\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.4, -0.4);\n  glEnd();\n}\n\nvoid display_function()\n{\n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  glPushMatrix();\n    glTranslatef(-0.35+tx, 0+ty, 0.0);\n    glRotatef(theta, 0.0, 0.0, 1.0);\n    glColor3f(1.0, 1.0, 1.0);\n    circulo();\n  glPopMatrix();\n\n  glPushMatrix();\n    glTranslatef(0.35+tx, 0+ty, 0.0);\n    glRotatef(theta, 0.0, 0.0, 1.0);\n    glColor3f(1.0, 1.0, 0);\n    circulo();\n  glPopMatrix();\n\n  glPushMatrix();\n    glTranslatef(0.0+tx, 0.32+ty, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRectf(-0.4, 0.2, 0.4, -0.2);\n  glPopMatrix();\n\n  glFlush();\n}\n\nvoid tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    tx += 0.05;\n    theta -= 8.0;\n    break;\n  case GLUT_KEY_LEFT:\n    tx -= 0.05;\n    theta += 8.0;\n    break;\n  case GLUT_KEY_UP:\n    ty += 0.05;\n    break;\n  case GLUT_KEY_DOWN:\n    ty -= 0.05;\n    break;\n  default:\n    break;\n  }\n  glutPostRedisplay();\n}\n\nvoid init()\n{\n  glClearColor(0.0, 0.0, 0.0, 0.0);\n  glColor3f(1.0, 1.0, 1.0);\n  glMatrixMode(GL_MODELVIEW);\n  \n}\n\nint main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"target":"DanielSalis","func":"#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat angulo = 0.5;\nfloat velocidade = 0.0000000;\nint opcao = 0;\n\nvoid init(){\n     glClearColor(0.0,0.0,0.0,0.0);\n     glEnable(GL_DEPTH_TEST); \n     glMatrixMode(GL_MODELVIEW);\n     glLoadIdentity();\n     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);\n     glPushMatrix();\n}\n\nvoid desenhaCentro(){\n    glPushMatrix();\n        glColor3f(1.0,1.0,1.0);\n        glutWireSphere(2.0, 20, 20);\n    glPopMatrix();\n}\n\nvoid desenhaFolhas(){\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(1, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(90.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(-90.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(-180.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n    \n}\n\nvoid display()\n{\n    glMatrixMode(GL_MODELVIEW);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -9.0);\n\n    glPopMatrix();\n    glPushMatrix();\n\n    desenhaCentro();\n    desenhaFolhas();\n\n    glutSwapBuffers();\n}\n\nvoid anima()\n{\n    switch (opcao) {\n        case 1:\n            if(velocidade<0.075013){\n                velocidade = velocidade + 0.000001;\n                angulo= angulo + velocidade;\n                printf(\"\\n%f\\n\", velocidade);\n            }else{\n                angulo = angulo + velocidade;\n            }\n            break;\n        case 2:\n            if(velocidade>0.000000){\n                velocidade = velocidade - 0.000001;\n                angulo = angulo + velocidade;\n            }\n            break;\n\n        case 3:\n            angulo= angulo + velocidade;\n            printf(\"\\n%f\\n\", velocidade);\n            break;\n\n        case 4:\n            if(velocidade>0.000000){\n                angulo = angulo + velocidade;\n                printf(\"\\n%f\\n\", velocidade);\n            }\n            break;\n        default:\n            break;\n    }\n    glutPostRedisplay();\n}\n\nvoid rotacoes(int key, int x, int y){\n     switch (key){\n        case GLUT_KEY_RIGHT :\n            opcao = 3;\n            velocidade = velocidade + 0.0001;\n            break ;\n        case GLUT_KEY_LEFT :\n            opcao = 4;\n            velocidade = velocidade - 0.0001;\n            break ;\n        default:\n           break;\n     }\n    glutPostRedisplay();\n}\n\nvoid mouse(int botao, int estado, int x, int y)\n{\n    glutIdleFunc(anima);\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        if (estado == GLUT_DOWN){\n            opcao = 1;\n        }\n        break;\n\n    case GLUT_RIGHT_BUTTON:\n        if (estado == GLUT_DOWN){\n            opcao = 2;\n        }\n        break;\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}\n\nint main(int argc, char *argv[])\n{\n     glutInit(&argc,argv);\n     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n     glutInitWindowPosition(50,50);\n     glutInitWindowSize(600,600);\n     glutCreateWindow(\"Catavento Animado - OpenGL\");\n     glutDisplayFunc(display);\n     glutSpecialFunc(rotacoes);\n     glutIdleFunc(anima);\n     glutMouseFunc(mouse);\n     init();\n     glutMainLoop();\n}"}
{"target":"DanielSalis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <GL\/glut.h>\n\nfloat up = 0.0;\nfloat right = 0.0;\n\nvoid point(){\n    glColor3f(0.0, 0.0, 1.0); \n    glPointSize(5.0f); \n    glBegin(GL_POINTS);\n        glVertex2f(0.0+up,0.0+right);\n    glEnd();\n}\n\nvoid desenha()\n{\n    glClearColor(0, 0, 0, 0); \n    glClear(GL_COLOR_BUFFER_BIT);\n    point();\n    glFlush();\n}\n\n\nvoid mouse(int botao, int estado, int x, int y)\n{\n    float mx = x;\n    float my = y;\n    float ox = (mx \/ 200 - 1.0);\n    float oy = -(my \/ 200 - 1.0);\n\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        if (estado == GLUT_DOWN){\n            printf(\"x = %f, y = %f\\n\", ox, oy);\n            up = ox;\n            right = oy;\n            point();\n        }\n        break;\n\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}\n\nint main(int argc, char *argv[])\n{\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowPosition(50, 100);\n    glutInitWindowSize(400, 400);\n\n    glutCreateWindow(\"Exercicio 01\");\n    glutDisplayFunc(desenha);\n\n    glutMouseFunc(mouse);\n    glutMainLoop();\n    return 0;\n}"}
{"target":"DanielSalis","func":"#include <math.h>\n#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nfloat tx = 0.0;\nfloat ty = 0.0;\n\nvoid circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 50; i++)\n  {\n    angulo = 2 * M_PI * i \/ 50.0;\n    glVertex2f(0.15 * cos(angulo), 0.15 * sin(angulo));\n  }\n  glEnd();\n}\n\nvoid quadrado(float x, float y){\n  glBegin(GL_POLYGON);\n    glVertex2f(-0.2+x, 0.2+y);\n    glVertex2f(0.2+x, 0.2+y);\n    glVertex2f(0.2+x, -0.2+y);\n    glVertex2f(-0.2+x, -0.2+y);\n  glEnd();\n}\n\nvoid retangulo(){\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.05, -0.05);\n  glVertex2f(0.05, -0.05);\n  glVertex2f(0.05, -0.95);\n  glVertex2f(-0.05, -0.95);\n  glEnd();\n}\n\nvoid display_function()\n{\n  \n  \n  \n  \n  \n\n  \n  \n  \n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  glColor3f(1.0, 1.0, 1.0);\n  circulo();\n\n  glColor3f(1.0, 1.0, 1.0);\n  retangulo();\n\n  glTranslatef(tx, ty, 0.0);\n  \n  glColor3f(0.5, 1.0, 0.5);\n  quadrado(0.3, 0.3);\n\n  glColor3f(1.0, 1.0, 0.0);\n  quadrado(-0.3, 0.3);\n\n  glColor3f(1.0, 0.0, 1.0);\n  quadrado(0.3, -0.3);\n\n  glColor3f(1.0, 0.0, 0.0);\n  quadrado(-0.3, -0.3);\n\n  glFlush();\n}\n\nvoid tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    tx += 0.05;\n    break;\n  case GLUT_KEY_LEFT:\n    tx -= 0.05;\n    break;\n  case GLUT_KEY_UP:\n    ty += 0.05;\n    break;\n  case GLUT_KEY_DOWN:\n    ty -= 0.05;\n    break;\n  default:\n    break;\n  }\n  glutPostRedisplay();\n}\n\nvoid init()\n{\n  glClearColor(0.0, 0.0, 0.0, 0.0);\n  glColor3f(1.0, 1.0, 1.0);\n  glMatrixMode(GL_MODELVIEW);\n  \n}\n\nint main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"target":"DanielSalis","func":"#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat angulo = 20.0;\nfloat tempoDeAnimacao = 100;\n\nvoid init(){\n     glClearColor(0.0,0.0,0.0,0.0);\n     glEnable(GL_DEPTH_TEST); \n     glMatrixMode(GL_MODELVIEW);\n     glLoadIdentity();\n     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);\n     glPushMatrix();\n}\n\nvoid desenhaCabeca(){\n    glPushMatrix();\n        glColor3f(1.0,1.0,1.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glutWireSphere(2.0, 20, 20);\n    glPopMatrix();\n}\n\nvoid desenhaChapeu(){\n    glPushMatrix();\n        glColor3f(0.0,1.0,0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glRotatef(30.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(2.0,4.0,20,20);\n        glutWireTorus(0.2, 2.2, 10, 25);\n    glPopMatrix();\n}\n\nvoid desenhaNariz(){\n    glPushMatrix();\n    glColor3f(1.0, 0.0, 0.0);\n    glRotatef(angulo,0.0,1.0,0.0);\n    glTranslatef(0.0, 0.0, 2.0);\n    glutWireSphere(0.5, 20, 20);\n    glPopMatrix();\n}\n\nvoid desenhaCabeloEsquerda(){\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.5, 0.0, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.2, 0.7 , 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.2, -0.7, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n}\n\nvoid desenhaCabeloDireita(){\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.5, 0.0, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.2, 0.7 , 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.2, -0.7, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n}\n\nvoid display()\n{\n    glMatrixMode(GL_MODELVIEW);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -9.0);\n\n    glPopMatrix();\n    glPushMatrix();\n\n    desenhaCabeca();\n    desenhaChapeu();\n    desenhaNariz();\n    desenhaCabeloEsquerda();\n    desenhaCabeloDireita();\n\n    glutSwapBuffers();\n}\n\nvoid animate(int value)\n{\n    angulo += 5.0;\n    if(angulo > 360.0){\n        angulo -= 360.0;\n    }\n    glutTimerFunc(tempoDeAnimacao, animate, 1);\n    glutPostRedisplay();\n}\n\nint main(int argc, char *argv[])\n{\n     glutInit(&argc,argv);\n     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n     glutInitWindowPosition(50,50);\n     glutInitWindowSize(600,600);\n     glutCreateWindow(\"Palhaco Animado - OpenGL\");\n     glutDisplayFunc(display);\n     glutTimerFunc(5, animate, 1);\n     init();\n     glutMainLoop();\n}"}
{"target":"DanielSalis","func":"#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct BMPImagem\n{\n    int   width;\n    int   height;\n    char *data;\n}BMPImage;\n\n#define MAX_NO_TEXTURES 6\n\nGLuint texture_id[MAX_NO_TEXTURES];\n\nchar* filenameArray[MAX_NO_TEXTURES] = {\n        \"earthTexture.bmp\",\n        \"surface1.bmp\",\n        \"surface2.bmp\",\n        \"surface3.bmp\",\n        \"surface4.bmp\",\n        \"surface7.bmp\"\n};\n\nGLUquadricObj *obj;\n\nGLfloat angleX = 0.0f;\nGLfloat angleY = 0.0f;\nfloat angulo = 20.0;\n\ndouble phi = 0.0;\ndouble theta = 0.0;\ndouble r = 0.5;\nint n = 450;\nint texture_index = 0;\n\ndouble s1 = 2.5;\ndouble s2 = 2.5;\n\ndouble rt = 0.25;\ndouble Rt = 0.75;\n\nint stop = 0;\nfloat cameraY=0.5;\n\nvoid getBitmapImageData( char *pFileName, BMPImage *pImage )\n{\n    FILE *pFile = NULL;\n    unsigned short nNumPlanes;\n    unsigned short nNumBPP;\n    int i;\n\n    if( (pFile = fopen(pFileName, \"rb\") ) == NULL )\n        printf(\"ERROR: getBitmapImageData - %s not found.\\n\", pFileName);\n\n    fseek( pFile, 18, SEEK_CUR );\n\n    if( (i = fread(&pImage->width, 4, 1, pFile) ) != 1 )\n        printf(\"ERROR: getBitmapImageData - Couldn't read width from %s.\\n \", pFileName);\n\n    if( (i = fread(&pImage->height, 4, 1, pFile) ) != 1 )\n        printf(\"ERROR: getBitmapImageData - Couldn't read height from %s.\\n \", pFileName);\n\n    if( (fread(&nNumPlanes, 2, 1, pFile) ) != 1 )\n        printf(\"ERROR: getBitmapImageData - Couldn't read plane count from %s.\\n\", pFileName);\n\n    if( nNumPlanes != 1 )\n        printf(\"ERROR: getBitmapImageData - Plane count from %s.\\n \", pFileName);\n\n    if( (i = fread(&nNumBPP, 2, 1, pFile)) != 1 )\n        printf( \"ERROR: getBitmapImageData - Couldn't read BPP from %s.\\n \", pFileName);\n\n    if( nNumBPP != 24 )\n        printf(\"ERROR: getBitmapImageData - BPP from %s.\\n \", pFileName);\n\n    fseek( pFile, 24, SEEK_CUR );\n\n    int nTotalImagesize = (pImage->width * pImage->height) * 3;\n\n    pImage->data = (char*) malloc( nTotalImagesize );\n\n    if( (i = fread(pImage->data, nTotalImagesize, 1, pFile) ) != 1 )\n        printf(\"ERROR: getBitmapImageData - Couldn't read image data from %s.\\n \", pFileName);\n\n    char charTemp;\n    for( i = 0; i < nTotalImagesize; i += 3 )\n    {\n        charTemp = pImage->data[i];\n        pImage->data[i] = pImage->data[i+2];\n        pImage->data[i+2] = charTemp;\n    }\n}\n\nvoid CarregaTexturas()\n{\n    BMPImage textura;\n\n    glGenTextures(MAX_NO_TEXTURES, texture_id);\n                                \n    int i;\n    for ( i=0; i<MAX_NO_TEXTURES; i++ ) {\n        getBitmapImageData( filenameArray[i], &textura);\n        glBindTexture(GL_TEXTURE_2D, texture_id[i]);\n        glTexImage2D(GL_TEXTURE_2D, 0, 3, textura.width, textura.height, 0, GL_RGB, GL_UNSIGNED_BYTE, textura.data);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n    }\n}\n\nvoid initTexture (void)\n{\n\n    glEnable ( GL_TEXTURE_2D );\n    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n\n    CarregaTexturas();\n\n}\n\nvoid lightning(){\n    GLfloat light0_pos[] = {2.0f, 2.0f, 2.0f, 1.0f};\n    GLfloat white[] = {1.0f, 1.0f, 1.0f, 1.0f};\n    GLfloat black[] = {0.0f, 0.0f, 0.0f, 1.0f};\n\n    glLightfv(GL_LIGHT0,GL_POSITION,light0_pos);\n    glLightfv(GL_LIGHT0,GL_AMBIENT,black);\n    glLightfv(GL_LIGHT0,GL_DIFFUSE,white);\n    glLightfv(GL_LIGHT0,GL_SPECULAR,white);\n\n    GLfloat light1_pos[] = {-2.0f, 0.0f, 0.0f, 1.0f};\n    glLightfv(GL_LIGHT1,GL_POSITION,light1_pos);\n    glLightfv(GL_LIGHT1,GL_DIFFUSE, white);\n    glLightfv(GL_LIGHT1,GL_SPECULAR, white);\n    GLfloat direction[] = {1.0f, 0.0f, 0.0f};\n    glLightfv(GL_LIGHT1,GL_SPOT_DIRECTION,direction);\n    glLightf(GL_LIGHT1,GL_SPOT_CUTOFF,45.0f);          \n    glLightf(GL_LIGHT1,GL_SPOT_EXPONENT,0.1f);             \n\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n    glEnable(GL_LIGHT1);\n}\n\nvoid init(void)\n{\n    glEnable ( GL_COLOR_MATERIAL );\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    glEnable(GL_DEPTH_TEST);\n\n    glShadeModel(GL_SMOOTH);\n    glEnable(GL_NORMALIZE);\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(0.0, 2.0, 6.0,\n              0.0, 0.0, 0.0,\n              0.0, 1.0, 0.0);\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, 1.0, 2.0, 8.0);\n    glViewport(0, 0, 700, 700);\n\n    lightning();\n}\n\nvoid desenhaEsferaComTextura(){\n     obj = gluNewQuadric();\n     gluQuadricTexture(obj,GL_TRUE);\n     gluSphere(obj,0.1,50,50);\n}\n\nvoid esferaQuadrica(){\n    int i,j;\n    glClear(GL_COLOR_BUFFER_BIT);\n    for(i=0;i<n;i++){\n        glBegin(GL_POINTS);\n            for(j=0;j<n;j++){\n                glVertex3f(r*cos(phi)*cos(theta),r*cos(phi)*sin(theta),r*sin(phi));\n                phi = phi + (2*M_PI)\/n;\n            }\n        glEnd();\n        phi = 0.0;\n        theta = theta+(2*M_PI)\/n;\n    }\n}\n\nvoid desenhaPlanetaCentral(){\n    glPushMatrix();\n    GLfloat diffuse[4];\n    GLfloat specular[4];\n    GLfloat ns;\n    diffuse[0] = 1.0;\n    diffuse[1] = 1.0;\n    diffuse[2] = 1.0;\n    diffuse[3] = 1.0f;\n    specular[0] = 1;\n    specular[1] = 1;\n    specular[2] = 1;\n    specular[3] = 1.0f;\n    ns = 50.0f;\n    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,diffuse);\n    glMaterialfv(GL_FRONT,GL_SPECULAR,specular);\n    glMaterialf(GL_FRONT, GL_SHININESS, ns);\n    glBindTexture(GL_TEXTURE_2D, 0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        esferaQuadrica();\n    glPopMatrix();\n    \n}\n\nvoid desenhaSatelites(){\n    float v1 = 1.2;\n    float v2 = 1.4;\n\n        \n    glPushMatrix();\n        glBindTexture(GL_TEXTURE_2D, texture_id[2]);\n        glRotatef(angulo*v1,0.0,1.0,0.0);\n        glTranslatef(-0.48,0.0,1.0);\n        desenhaEsferaComTextura();\n    glPopMatrix();\n\n        \n    glPushMatrix();\n        glBindTexture(GL_TEXTURE_2D, texture_id[4]);\n        glRotatef(-angulo*v2,0.0,1.0,0.0);\n        glTranslatef(-0.8,0.0,2.0);\n        desenhaEsferaComTextura();\n    glPopMatrix();\n}\n\nvoid display() {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glMatrixMode(GL_MODELVIEW);\n        desenhaPlanetaCentral();\n        desenhaSatelites();\n\n        glFlush();\n}\n\nvoid rotacionarPlaneta(int key, int x, int y){\n     switch (key){\n        case GLUT_KEY_UP :\n            glMatrixMode(GL_MODELVIEW);\n            glLoadIdentity();\n            gluLookAt(0.0, 2.0, 6.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0);\n\n            glMatrixMode(GL_PROJECTION);\n            glLoadIdentity();\n            gluPerspective(45.0, 1.0, 2.0, 8.0);\n           break ;\n        case GLUT_KEY_DOWN :\n            glMatrixMode(GL_MODELVIEW);\n            glLoadIdentity();\n            gluLookAt(0.0, -7.0, 3.0,\n                    0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0);\n            glMatrixMode(GL_PROJECTION);\n            glLoadIdentity();\n            gluPerspective(45.0, 1.0, 2.0, 8.0);\n           break ;\n        case GLUT_KEY_LEFT :\n           angulo-=15;\n           break ;\n        case GLUT_KEY_RIGHT :\n           angulo+=15;\n           break ;\n        default:\n           break;\n     }\n     glutPostRedisplay() ;\n}\n\nvoid executaAnimacao(){\n    if(stop == 0){\n        angulo+=6;\n        glutTimerFunc(100, executaAnimacao, 1);\n        glutPostRedisplay();\n    }\n}\n\nvoid mouse(int botao, int estado, int x, int y)\n{\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        stop = 1;\n        break;\n    case GLUT_RIGHT_BUTTON:\n        stop = 0;\n                glutTimerFunc(100, executaAnimacao, 1);\n        glutPostRedisplay();\n        break;\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}\n\nint main(int argc, char *argv[]){\n    glutInit(&argc,argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowPosition(50,50);\n    glutInitWindowSize(700,700);\n    glutCreateWindow(\"Planetas\");\n    glutDisplayFunc(display);\n    glutSpecialFunc(rotacionarPlaneta);\n    glutTimerFunc(5, executaAnimacao, 1);\n    glutMouseFunc(mouse);\n    init();\n    initTexture();\n    glutMainLoop();\n    return 0;\n}"}
{"target":"DanielSalis","func":"#include <math.h>\n#include <GL\/glut.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nfloat tx = 0.0;\nfloat ty = 0.0;\nfloat theta = 5.0;\nfloat thetaBraco = 1.0;\nfloat thetaPerna = 1.0;\n\nvoid circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 6; i++)\n  {\n    angulo = 2 * M_PI * i \/ 6;\n    glVertex2f(0.04 * cos(angulo), 0.04 * sin(angulo));\n  }\n  glEnd();\n}\n\nvoid quadrado(float x, float y)\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.2 + x, 0.8 + y);\n  glVertex2f(-0.4 + x, 0.6 + y);\n  glVertex2f(0.2 + x, 0.8 + y);\n  glVertex2f(0.4+ x, 0.6 + y);\n  glEnd();\n}\n\nvoid triangulo(float x1, float y1, float x2, float y2, float x3, float y3)\n{\n  glBegin(GL_TRIANGLES);\n    glVertex2f(x1,y1);\n    glVertex2f(x2,y2);\n    glVertex2f(x3,y3);\n  glEnd();\n}\n\nvoid retangulo()\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.4, -0.4);\n  glEnd();\n}\n\nvoid display_function()\n{\n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  \n  glPushMatrix();\n    \n    glColor3f(1.0, 1.0, 1.0);\n    glRectf(-0.1, 0.8, 0.1, 0.6);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    glTranslatef(-0.06 , 0.75 , 0.0);\n    \n    glColor3f(1.0, 0, 0);\n    circulo();\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    glTranslatef(0.06, 0.75, 0.0);\n    \n    glColor3f(1.0, 0, 0);\n    circulo();\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    \n    \n    glColor3f(0, 0, 1);\n    triangulo(0.0,0.73, -0.05,0.68, 0.05,0.68);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    \n    \n    glColor3f(1, 0.5, 0.5);\n    glRectf(-0.05, 0.64, 0.05, 0.62);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n  glTranslatef(-0.2, 0.45, 0);\n  glRotatef(thetaBraco, 0.0, 0.0, 1.0);\n  glColor3f(1, 0.1, 1);\n  glRectf(-0.4, 0.05, 0.2, -0.05);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n  glTranslatef(0.20, 0.45, 0);\n  glRotatef(-thetaBraco, 0.0, 0.0, 1.0);\n  glColor3f(1, 0.1, 1);\n  glRectf(-0.2, 0.05, 0.4, -0.05);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    glTranslatef(0.0, 0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRectf(-0.2, 0.4, 0.2, -0.4);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    glTranslatef(0.1, -0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRotatef(thetaPerna, 0.0, 0.0, 1.0);\n    glRectf(-0.05, 0.3, 0.05, -0.3);\n  glPopMatrix();\n\n  \n  glPushMatrix();\n    glTranslatef(-0.1, -0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRotatef(-thetaPerna, 0.0, 0.0, 1.0);\n    glRectf(-0.05, 0.3, 0.05, -0.3);\n  glPopMatrix();\n\n  glFlush();\n}\n\nvoid tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    printf(\"%f\\n\", thetaPerna);\n    if (thetaPerna > -6.000000)\n    {\n      thetaPerna -= 7.0;\n    }\n    break;\n\n  case GLUT_KEY_LEFT:\n    printf(\"%f\\n\", thetaPerna);\n    if (thetaPerna <= +84.0000)\n    {\n      thetaPerna += 7.0;\n    }\n    break;\n  \n  case GLUT_KEY_UP:\n    printf(\"%f\\n\", thetaBraco);\n    if (thetaBraco >= -84.0000)\n    {\n      thetaBraco -= 7.0;\n    }\n    break;\n  \n  case GLUT_KEY_DOWN:\n    printf(\"%f\\n\", thetaBraco);\n    if (thetaBraco < 22.000000)\n    {\n      thetaBraco += 7.0;\n    }\n    break;\n  \n  default:\n    break;\n  }\n  glutPostRedisplay();\n}\n\nvoid init()\n{\n  glClearColor(0.0, 0.0, 0.0, 0.0);\n  glColor3f(1.0, 1.0, 1.0);\n  glMatrixMode(GL_MODELVIEW);\n  \n}\n\nint main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\nchar gerarCaptcha[6];\n\nchar gerado()\n{\n    int cont=0;\n    int num=0;\n    \n    srand(time(NULL));\n    while(cont<6)\n    {\n        if (cont == 4 || cont == 5)\n        {\n            gerarCaptcha[cont] = 48 + rand() % 9;\n        }\n        else if(cont == 1 || cont == 3)\n        {\n            gerarCaptcha[cont] = 97 + rand() % 26;\n        }\n        else if(cont == 0 || cont == 2)\n        {\n            gerarCaptcha[cont] = 65 + rand() % 26;\n        }\n\n        cont++;\n    }\n    \n    \n    printf(\"%s\\n\", gerarCaptcha);\n}\n\n\nint main(int argc, char *argv[]) {\n    \n    char captchaDigitado[6];\n    int continuar = 1;\n    \n    while(continuar = 1)\n    {\n        printf(\"CAPTCHA\\n\\n\");\n        printf(\"Captcha gerado:\\n\");\n        gerado();\n        printf(\"\\n\");\n        printf(\"Digite o Captcha gerado:\\n\");\n        gets(captchaDigitado);\n        printf(\"\\n\");\n        \n        if(strcmp (captchaDigitado, gerarCaptcha) == 0)\n        {\n            printf(\"Captcha correto.\\n\\n\");\n        }else{\n            printf(\"Captcha incorreto.\\n\\n\");\n        }\n        system(\"pause\");\n        system(\"cls\");\n    }\n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#define TAM 6\n\n\n\n\n\nchar validarDados (char vetorUsuario[TAM])\n{\n    int resultado = 0;\n    \n    if (strlen(vetorUsuario) > TAM)\n    {\n        system (\"COLOR C\");\n        printf (\"\\n\\nERRO! Caracteres digitados em excesso. Tente novamente.\");\n        sleep(3);\n        resultado = 1;\n        system(\"cls\");\n    }\n    return resultado;\n}\n\n\n\nchar compararCaptcha (char vetorCaptcha[TAM], char vetorUsuario[TAM])\n{\n    int resultado;\n    \n    resultado = strcmp (vetorCaptcha, vetorUsuario);\n    return resultado;\n}\n\n\n\nint exibirResultado (int comparacao)\n{\n    if (comparacao == 0)\n    {\n        printf (\"\\n\\nCaracteres digitados corretamente!\");\n    }else\n    {\n        system (\"COLOR C\");\n        printf (\"\\n\\nERRO! Caracteres digitados de forma incorreta. Tente novamente.\\n\\n\");\n        sleep(3);\n        comparacao = 1;\n        system(\"cls\");\n    }\n    return comparacao;\n}\n\n\n\nint main(int argc, char *argv[]) {\n    char vetorCaptcha[TAM];\n    char vetorUsuario[TAM];\n    int captcha;\n    int validacaoDados;\n    int comparacao;\n    int resultado;\n    int cont;\n    \n    srand(time(NULL));\n    do \n    {\n        system (\"COLOR F\");\n        system (\"cls\");\n        printf (\"Teste de Turing.\\n\\n\");\n        for (cont = 0; cont < 6; cont++)\n        {\n            do\n            {\n                captcha = (rand() % 122);\n            }\n            while (captcha <= 48 || captcha >= 57 && captcha <= 97 || captcha >= 122);\n            vetorCaptcha[cont] = captcha;\n            printf (\"%c \", vetorCaptcha[cont]);\n        }\n        system (\"COLOR F\");\n        printf (\"\\n\\nDigite os caracteres acima: \");\n        gets(vetorUsuario);\n        validacaoDados = validarDados (vetorUsuario);\n        if (validacaoDados == 0)\n        {\n            comparacao = compararCaptcha (vetorCaptcha, vetorUsuario);\n            resultado = exibirResultado (comparacao);\n            if (resultado == 1)\n            {\n                validacaoDados = resultado;\n                printf (\"%d\", validacaoDados);\n            }   \n        }\n    }\n    while (validacaoDados != 0);\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(void) {\n    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;\n    int opcao, menu;\n    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;\n    \n    opcao = 1;\n    nVitoriasDois = 0;\n    nDerrotasUm = 0;\n    \n    printf(\"------------------------------------\\n-------------bem vindo!-------------\\n------------------------------------\\n\\n\");\n        \n    while(opcao != 3){\n    \n    printf(\"Selecione seu modo de jogo: \\n\\n\");\n    printf(\"1- PvC - Player vs Computer \\n\");\n    printf(\"2- PvP - Player vs Player \\n\");\n    printf(\"3- sair\\n\");\n    fflush(stdin);\n    scanf(\"%d\", &opcao);\n    \n    \n    \n    \n    switch(opcao){\n    \n    \n        case 1: \n        \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        \n        while(menu !=4){\n                 \n        \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           \n           srand(time(NULL));\n           jogadorDois = 1 + rand() %3;\n           printf(\"\\nOpcao jogadorDois = %d \", jogadorDois, (jogadorDois % 4));\n           \n           \nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n                \n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n                     \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n                           \n                            \n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                                \n                           \n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                                       \n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                                           \n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                                  \n                                                           \n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                                      \n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                    \n                                                  }else{\n                                                       printf(\"\\nJogada Invalida\\n\");\n                                                  } \n                                                            \n}}}}}}}}\n            \n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                   }else \n                   {\n                          pVitoriasUm = ( nVitoriasUm\/ nJogadas ) * 100;\n                   }\n                                if(nVitoriasDois == 0)\n                                {\n                                        pVitoriasDois = 0;\n                                        }else\n                                        {\n                                                pVitoriasDois = ( nVitoriasDois \/ nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");\n    }\n        break;\n           \n        case 2:  \n        \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        \n        while(opcao != 3){\n        \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorDois);\n           system(\"cls\");\n                   \nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n                \n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n                     \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n                           \n                            \n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                                \n                           \n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                                       \n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                                           \n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                                  \n                                                           \n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                                      \n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                    \n                                                        }else{\n                                                                 printf(\"\\nJogada Invalida\\n\");\n           \n                                                                                        \n}}}}}}}}}\n            \n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                 }\n                 else\n                     {\n                        pVitoriasUm = ( nVitoriasUm \/ nJogadas ) * 100;\n                     }\n                             if(nVitoriasDois == 0){\n                                    pVitoriasDois = 0;\n                                    }\n                                     else\n                                     {\n                                               pVitoriasDois = ( nVitoriasDois \/ nJogadas ) * 100;\n            }\n            \n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            \n                \n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");      \n        }\n\n           break;\n        case 3:\n           printf(\"Cansou de jogar? \\n\");\n           system(\"exit\");\n           \n           break;\n           \n        default:           \n            printf(\"opcao invalida\");\n            break;\n        }\n}\n\n    \n    if(menu == 2){\n        \n        printf(\"Voce saira do jogo!\");\n    }\n\n}\n\n\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nchar * gerarCaptcha(char captcha[6])\n{\n    int cont, num;\n    srand(time(NULL));\n\n    for(cont = 0; cont < 6; cont++)\n    {\n        num = rand() % 3;\n        \n        if(num == 0)\n            captcha[cont] = 65 + (rand() % 26);\n        else\n            if(num == 1)\n                captcha[cont] = 97 + (rand() % 26);\n            else\n                captcha[cont] = 48 + (rand() % 10);\n    }\n    return captcha;\n}\nint * compararCaptcha(char captcha[6], char vetor[6], int iguais)\n{\n    int cont;\n    iguais = 0;\n    \n    for(cont = 0; cont < 6; cont++)\n    {\n        if(captcha[cont] == vetor[cont])\n            iguais++;\n    }\n    \n    if(iguais == 6)\n        return iguais;\n}\n   \nint main(int argc, char *argv[]) \n{\n    char captcha[6];\n    char vetor[6];\n    int * retorno, * comparacao, cont;\n    int iguais;\n    \n    printf(\"Verificacao de Seguranca.\\n\\n\");\n    retorno = gerarCaptcha(captcha);\n    printf(\"%s\\n\", retorno);\n    printf(\"\\nEscreva os 6 caracteres que voce ve acima: \\n\");\n    gets(vetor);\n    \n    comparacao = compararCaptcha(captcha, vetor, iguais);\n    printf(\"\", comparacao);\n    \n    iguais = 0;\n    \n    if(comparacao == 6)\n        printf(\"\\nOs caracteres sao iguais!\\n\");\n    else\n    {\n        printf(\"\\nOs caracteres sao diferentes. Tente novamente.\\n\");\n        \n        while(comparacao != 6)\n        {\n            retorno = gerarCaptcha(captcha);\n            printf(\"%s\\n\", retorno);\n            printf(\"\\nEscreva os 6 caracteres que voce ve acima: \\n\");\n            gets(vetor);\n            \n            for(cont = 0; cont < 6; cont++)\n            {\n                if(captcha[cont] == vetor[cont])\n                iguais++;\n            }\n            \n            comparacao = iguais;\n            \n            if(comparacao == 6)\n            {\n                printf(\"\\nOs caracteres sao iguais!\\n\");\n                break;\n            }\n            else\n            {\n                printf(\"\\nOs caracteres sao diferentes. Tente novamente.\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define PEDRA 1\n#define PAPEL 2\n#define TESOURA 3\n#define LAGARTO 4\n#define SPOCK 5\n\nint main(int argc, char *argv[]) {\n    \n    int player1, player2, optP1, optP2;\n    int mainMenu, playerMenu, modeMenu, novojogo;\n    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;\n    float percentP1, percentP2;\n    \n    srand( time(NULL) );\n    totalJogadas=0;\n    totalNormal=0;\n    totalMelhor=0;\n    totalStartrek=0;\n    totalDeath=0;\n    empates=0;\n    vitoriasP1=0;\n    vitoriasP2=0;\n    especial=3;\n    \n    do {\n    \n        system(\"cls\");\n        printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n        \n        printf(\"\\n\\n\\tO que voce quer fazer?\\n\");\n        printf(\"\\t1 - Jogar\\n\");\n        printf(\"\\t2 - Ver Regras\\n\");\n        printf(\"\\t3 - Ver Estatisticas\\n\");\n        printf(\"\\t4 - Sair\\n\\t\");\n        \n        if (totalJogadas > especial ) {\n            printf(\"\\n\\t0 - ESPECIAL DEATHMATCH\\n\");\n        }\n        \n        scanf(\"%d\",&mainMenu);\n        \n        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){\n            printf(\"\\t-> Opcao invalida!\\n\");\n            printf(\"\\tO que voce quer fazer?\\n\\t\");\n            scanf(\"%d\",&mainMenu);\n        }\n        \n        system(\"cls\");\n        \n        if (mainMenu==1){\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tComo voce quer jogar?\\n\");\n                printf(\"\\t1 - Player VS Player\");\n                printf(\"\\n\\t2 - Player VS Computador\\n\\t\");\n                scanf(\"%d\",&playerMenu);\n                \n                while(playerMenu<1 || playerMenu>2){\n                    printf(\"\\t-> Opcao invalida!\\n\");\n                    printf(\"\\tComo voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&playerMenu);\n                }\n                \n                system(\"cls\");\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tMODO DE JOGO:\\n\");\n                printf(\"\\t1 - Normal\\n\");\n                printf(\"\\t2 - Melhor de 3\\n\");\n                printf(\"\\t3 - Startreck\\n\\t\");\n                scanf(\"%d\",&modeMenu);\n                \n                while(modeMenu<1 || modeMenu>3){\n                    printf(\"-> Opcao invalida!\\n\");\n                    printf(\"Como voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&modeMenu);\n                }\n                \n                system(\"cls\");\n                \n                if (modeMenu==1) {\n                    \n                    \n                    do {\n                        \n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>3 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        \n                        system(\"cls\");\n                        \n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        \n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        \n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                        \n                        }\n                        \n                        totalJogadas++;\n                        totalNormal++;\n                        \n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                }while(novojogo==1);\n                \n                }\n                else {\n            \n                    if (modeMenu==2) {\n                        \n                    do {\n                        \n                        tempVitP1=0;\n                        tempVitP2=0;\n                        \n                            do {\n                                system(\"cls\");\n                                printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            \n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            \n                            system(\"cls\");\n                            \n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n    \n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            \n                            if (playerMenu==1) {\n                                scanf(\"%d\",&optP2);\n                                while( optP2<1 || optP2>3 ){\n                                    printf(\"Opcao invalida. Digite novamente: \");\n                                    scanf(\"%d\",&optP2);\n                                }\n                            } else {\n                                optP2 = ( rand() % 2 ) + 1;\n                                printf(\"%d\",optP2);\n                            }\n                            \n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada!\\n\");\n                                    tempVitP2++;\n                                }\n                            }\n                            system(\"pause\");\n                        \n                    }while( tempVitP1<2 && tempVitP2<2 );\n                        \n                        totalJogadas++;\n                        totalMelhor++;\n                        \n                        system(\"cls\");\n                        if (tempVitP1 > tempVitP2) {\n                            printf(\"\\nPlayer 1 venceu a partida!\\n\");\n                            vitoriasP1++;\n                        } else {\n                            printf(\"\\nPlayer 2 venceu a partida!\\n\");\n                            vitoriasP2++;\n                        }\n                        \n                        system(\"pause\");\n                        system(\"cls\");\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                        \n                    } else {\n                        \n                        if (modeMenu==3) {\n                            \n                            do {\n\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>5 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        \n                        system(\"cls\");\n                        \n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        \n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        \n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>5 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 4 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        \n                        totalJogadas++;\n                        totalStartrek++;\n                        \n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if (\n                            \n                                (optP1==PEDRA&&optP2==TESOURA) ||\n                                (optP1==PEDRA&&optP2==LAGARTO) ||\n                                \n                                (optP1==LAGARTO&&optP2==PAPEL) ||\n                                (optP1==LAGARTO&&optP2==SPOCK) ||\n                                \n                                (optP1==SPOCK&&optP2==PEDRA) ||\n                                (optP1==SPOCK&&optP2==TESOURA) ||\n                                \n                                (optP1==TESOURA&&optP2==LAGARTO) ||\n                                (optP1==TESOURA&&optP2==PAPEL) ||\n                                \n                                (optP1==PAPEL&&optP2==PEDRA) ||\n                                (optP1==PAPEL&&optP2==SPOCK)\n                            \n                            ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                            \n                        }\n                        \n                    }\n            \n                }\n        \n        }\n        \n        else {\n            \n            if (mainMenu==2) {\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                \n                printf(\"\\n\\n\\tREGRAS:\\n\");\n                printf(\"\\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\\n\");\n                printf(\"\\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\\n\");\n                printf(\"\\t\\t- PEDRA ganha da TESOURA (quebrando-a).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do PAPEL (cortando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha da PEDRA (embrulhando-o).\\n\");\n                printf(\"\\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\\n\");\n                printf(\"\\t\\t- PEDRA ganha do LAGARTO (esmagando-o).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do LAGARTO (matando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha do SPOCK (cegando-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do PAPEL (comendo-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do SPOCK (envenenando-o).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da PEDRA (vaporizando-a).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da TESOURA (quebrando-a).\\n\\n\");\n                system(\"pause\");\n                \n            } else {\n                \n                if (mainMenu==3) {\n                    \n                    printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                    printf(\"\\n\\n\\tTotal de Jogadas: %d\\n\",totalJogadas);\n                    \n                    printf(\"\\t\\tEmpates: %d\\n\",empates);\n                    percentP1=(100.0*vitoriasP1)\/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 1: %d(%f%%)\\n\",vitoriasP1,percentP1);\n                    percentP2=(100.0*vitoriasP2)\/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 2: %d(%f%%)\\n\",vitoriasP2,percentP2);\n\n                    printf(\"\\tJogadas no Modo Normal: %d\\n\",totalNormal);\n                    printf(\"\\tJogadas no Modo Melhor de 3: %d\\n\",totalMelhor);\n                    printf(\"\\tJogadas no Modo Star Trek: %d\\n\",totalStartrek);\n                    system(\"pause\");\n                    \n                } else if (mainMenu==0) {\n                            \n                    do {\n                        \n                        tempVitP1=0;\n                        tempDeath=0;\n                        \n                            do {\n                                \n                            printf(\"\\tDEATMATCH\\n\");\n                            printf(\"\\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\\n\");\n                                \n                            system(\"cls\");\n                            printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            \n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            \n                            system(\"cls\");\n                            \n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n    \n                            system(\"pause\");\n                            printf(\"Numero: \");\n\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                            \n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1=1;\n                                    tempDeath++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada e encerrou a partida!\\n\");\n                                    tempVitP1=2;\n                                }\n                            }\n                            system(\"pause\");\n                        \n                    }while( tempVitP1==1 );\n                        \n                        totalJogadas++;\n                        totalDeath++;\n                        \n                        system(\"cls\");\n\n                            printf(\"\\nVoce ganhou: %d partidas!\\n\",tempDeath);\n                            vitoriasP1++;\n                        \n                        system(\"pause\");\n                        system(\"cls\");\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                    \n                }\n                \n            }\n            \n        }\n    \n    }while(mainMenu>=1 && mainMenu<=3);\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#define logico int\n#define TRUE 1\n#define FALSE 0\n\n\n\nchar captchaLido[6];\nchar captchaGerado[6];\n\nchar * gerarCaptcha (char captchaGerado[6]) {\n\n    int contadorLetras;\n    int padraoCaptcha;\n\n    padraoCaptcha = rand() % 3;\n    switch (padraoCaptcha) {\n\n        case 0: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 1 || contadorLetras == 4) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 5 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 1: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 1 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 0 || contadorLetras == 5) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 2: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 5) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 2 || contadorLetras == 3) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 1 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return captchaGerado;\n}\n\nlogico validarCaptcha ( char captchaLido[6], char captchaGerado [6]) {\n    int contador, contIguais;\n\n    contIguais=0;\n    for (contador=0; contador<6; contador++) {\n        if( captchaLido[contador] == captchaGerado[contador]) {\n            contIguais++;\n        } else {\n            contIguais = 0;\n            break;\n        }\n    }\n\n    if ( contIguais == 6) {\n        return TRUE;\n    } else {\n        if(contIguais == 0) {\n            return FALSE;\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    char novamente;\n    char *captcha;\n    logico result;\n\n    srand(time(NULL));\n\n\n    do {\n        novamente = 'N';\n        captcha = gerarCaptcha(captchaGerado);\n        printf(\" --Por Favor, digite o CAPTCHA abaixo, respeitando maiusculas e minusculas:\\n\\n   %s  \\n\\n\", captcha);\n        gets(captchaLido);\n\n        result = validarCaptcha ( captchaLido , captcha);\n\n        if(result == TRUE) {\n            printf(\"   --Captcha Correto! Acesso Permitido!\");\n        } else {\n            if (result == FALSE) {\n                printf(\" --Voce nao digitou o Captcha corretamente. Por favor, tente novamente.\\n\\n\");\n                novamente = 'S';\n            }\n        }\n\n    } while (novamente == 'S');\n\n\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n\nint main(void) {\n    \n    srand (time(NULL));\n    \n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    \n    \n    \n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    \n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    \n    while(jogarMais > 0){\n    \n        jogadaComputador = rand()%3+1;\n    \n        if(escolhaJogo == 1){ \n    \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        \n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n        \n            if(jogador1 >=1 && jogador1 <=3){ \n            \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                \n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n            \n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                \n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    \n                    pontosJogador1 = pontosJogador1 + 1;\n                \n                }\n                \n                if (jogador1 == jogadaComputador){ \n                    \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    \n                    empate++;\n                    \n                }\n                \n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                \n                    pontosComputador = pontosComputador + 1;\n                \n            }\n        } else { \n            \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n        }\n        \n        }\n        \n        if(escolhaJogo == 2){  \n            \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        \n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            \n            if(jogador1 >= 1 && jogador1 <= 3){\n            \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                \n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                \n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                \n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    \n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                \n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    \n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    \n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    \n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        \n                        pontosJogador1 = pontosJogador1 + 1;\n                \n                    }\n                \n                    if (jogador1 == jogador2){ \n                    \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        \n                        empate++;\n                    \n                    }\n                \n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        \n                        pontosJogador2 = pontosJogador2 + 1;\n                \n                    }\n            \n                } else { \n            \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n                }\n        \n            } else { \n            \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n            }\n    \n        }\n        \n        if(escolhaJogo > 2){  \n            \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n            \n        }\n\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        \n        if(jogarNovamente == 1){ \n            \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            \n        }\n\n        if(jogarNovamente == 2){ \n            \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            \n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            \n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            \n            if(pontosJogador2 > 0){\n                \n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 \/ (float)totalJogadas) * 100;\n                \n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            \n            }\n            \n            if(pontosComputador > 0){\n                \n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador \/ (float)totalJogadas) * 100;\n                \n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n                \n            }\n            \n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                \n                if(escolhaJogo == 1){\n                    \n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                    \n                }\n                \n                if(escolhaJogo == 2){\n                    \n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                    \n                }\n                \n                if(empate > 0){\n                    \n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                        \n                }\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n                \n            }\n            \n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            \n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            \n            if(jogarNovamente2 == 1){ \n                \n                for( linha = 0; linha < 35; linha++){ \n                \n                    printf( \"\\n\" );\n                    \n                }\n                \n            }\n            \n            if(jogarNovamente2 == 2){ \n                \n                exit(0);\n                \n            }\n            \n            if(jogarNovamente2 >= 3){\n                \n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n                \n            }\n            \n        }\n        \n        if(jogarNovamente == 3){\n        \n            exit(0);\n            \n        }\n        \n        if(jogarNovamente >= 4){\n            \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n            \n        }\n         \n    }\n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#define TOTAL 6\n#define bool int\n#define TRUE 1\n#define FALSE 0\n\nstruct Palavra {\n    char nome[20];\n    int tipo;\n};\nstruct Palavra palavras[15];\n\nint numeroAleatorio(int min, int max){\n    int dif;\n    max++;\n    dif=max-min;\n    return (rand()%dif)+min;\n}\nchar * gerarCaptchaSimples(){\n    \n    int cont, tipo, min, max;\n    char novoCaptcha[TOTAL], caractere;\n    \n    for(cont=0;cont<TOTAL;cont++){\n        tipo=numeroAleatorio(1,3);\n        \n        switch(tipo){\n            case 1:\n                min=65;\n                max=90;\n            break;\n            case 2:\n                min=97;\n                max=122;\n            break;\n            case 3:\n                min=48;\n                max=57;\n            break;\n        }\n        \n        caractere=numeroAleatorio(min,max);\n        novoCaptcha[cont]=caractere;\n        \n    }\n    novoCaptcha[TOTAL]=0;\n    \n    return novoCaptcha;\n    \n}\nbool verificarCaptchaSimples(char stringA[TOTAL], char stringB[TOTAL]){\n    if (strcmp(stringA,stringB)==0){\n        return TRUE;\n    } else {\n        return FALSE;\n    }   \n}\n\nchar * gerarCaptchaMatematico(){\n    \n    int cont, tipo, caractere;\n    char captcha[3];\n    \n    captcha[0]=numeroAleatorio(48,57);\n    tipo=numeroAleatorio(1,2);\n        switch(tipo){\n            case 1:\n                caractere=43;\n            break;\n            case 2:\n                caractere=42;\n            break;\n        }\n    captcha[1]=caractere;\n    captcha[2]=numeroAleatorio(48,57);\n    captcha[3]=0;\n    \n    return captcha;\n    \n}\nint real(char caractere){\n    int numero;\n    \n    switch(caractere){\n        case 48:\n        numero=0;\n        break;\n        case 49:\n        numero=1;\n        break;\n        case 50:\n        numero=2;\n        break;\n        case 51:\n        numero=3;\n        break;\n        case 52:\n        numero=4;\n        break;\n        case 53:\n        numero=5;\n        break;\n        case 54:\n        numero=6;\n        break;\n        case 55:\n        numero=7;\n        break;\n        case 56:\n        numero=8;\n        break;\n        case 57:\n        numero=9;\n        break;\n    }\n    return numero;\n}\nbool verificarCaptchaMatematico(char *conta, int resultado){\n    \n    int resultadoReal, valorA, valorB, simbolo;\n    \n    valorA=real(conta[0]);\n    valorB=real(conta[2]);\n    simbolo=conta[1];\n    \n    if (conta[1]==42){\n        resultadoReal=valorA*valorB;\n    } else {\n        resultadoReal=valorA+valorB;\n    }\n    \n    if (resultadoReal==resultado) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n\n}\nchar ** gerarCaptchaLogico(char verificador[7][20]){\n    int tipo, cont, randPalavra, min, max, baseTipo;\n    char novoCaptcha[7][20];\n    \n    for(cont=1;cont<6;cont++){\n        tipo=numeroAleatorio(1,3);\n        switch(tipo){\n            case 1:\n                min=0;\n                max=4;\n                break;\n            case 2:\n                min=5;\n                max=9;\n                break;\n            case 3:\n                min=10;\n                max=14;\n                break;\n        }\n        randPalavra=numeroAleatorio(min,max);\n        strcpy(verificador[cont],palavras[randPalavra].nome);\n    }\n    \n    baseTipo=buscaTipo(verificador[numeroAleatorio(1,5)]);\n    switch(baseTipo){\n        case 1:\n            strcpy(verificador[0],\"cor\");\n            strcpy(verificador[6],\"1\");\n            break;\n        case 2:\n            strcpy(verificador[0],\"animal\");\n            strcpy(verificador[6],\"2\");\n            break;\n        case 3:\n            strcpy(verificador[0],\"objeto\");\n            strcpy(verificador[6],\"3\");\n            break;\n    }\n    \n    return novoCaptcha;\n}\nint buscaTipo(char palavra[20]){\n    int tipo, cont;\n    \n    for(cont=0;cont<15;cont++){\n        if (strcmp(palavras[cont].nome,palavra)==0) {\n            return palavras[cont].tipo;\n            break;\n        }\n    }\n    \n    return FALSE;\n}\nbool verificarCaptchaLogico(char captcha[7][20],int alternativa){\n    int tipo,numero;\n    tipo=buscaTipo(captcha[alternativa]);\n    numero=captcha[6][0]-48;\n    \n    if (tipo==numero) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\nint main() {\n    char captcha[TOTAL], entrada[TOTAL], verificador[7][20];\n    int verificacao, entradaNumerica, cont;\n    \n    strcpy(palavras[0].nome,\"Amarelo\");\n    palavras[0].tipo=1;\n    strcpy(palavras[1].nome,\"Azul\");\n    palavras[1].tipo=1;\n    strcpy(palavras[2].nome,\"Roxo\");\n    palavras[2].tipo=1;\n    strcpy(palavras[3].nome,\"Verde\");\n    palavras[3].tipo=1;\n    strcpy(palavras[4].nome,\"Cinza\");\n    palavras[4].tipo=1;\n    \n    strcpy(palavras[5].nome,\"Porco\");\n    palavras[5].tipo=2;\n    strcpy(palavras[6].nome,\"Cavalo\");\n    palavras[6].tipo=2;\n    strcpy(palavras[7].nome,\"Rato\");\n    palavras[7].tipo=2;\n    strcpy(palavras[8].nome,\"Cachorro\");\n    palavras[8].tipo=2;\n    strcpy(palavras[9].nome,\"Gato\");\n    palavras[9].tipo=2;\n    \n    strcpy(palavras[10].nome,\"Garfo\");\n    palavras[10].tipo=3;\n    strcpy(palavras[11].nome,\"Faca\");\n    palavras[11].tipo=3;\n    strcpy(palavras[12].nome,\"Prato\");\n    palavras[12].tipo=3;\n    strcpy(palavras[13].nome,\"Copo\");\n    palavras[13].tipo=3;\n    strcpy(palavras[14].nome,\"Panela\");\n    palavras[14].tipo=3;\n    \n    srand(time(NULL));\n    \n    do {\n        system(\"cls\");\n        strcpy(captcha,gerarCaptchaSimples());\n        printf(\"\\n%s\",captcha);\n        printf(\"\\nDigite os caracteres da linha anetior: \");\n        gets(entrada);\n        verificacao=verificarCaptchaSimples(captcha,entrada);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n    \n    do{\n        system(\"cls\");\n        strcpy(captcha,gerarCaptchaMatematico());\n        printf(\"\\n%s\",captcha);\n        printf(\"\\nDigite o resultado da operacao anterior: \");\n        scanf(\"%d\",&entradaNumerica);\n        verificacao=verificarCaptchaMatematico(captcha,entradaNumerica);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n    \n    do{\n        system(\"cls\");\n        gerarCaptchaLogico(verificador);\n        for(cont=1;cont<6;cont++){\n            printf(\"\\n%d - %s\",cont,verificador[cont]);\n        }\n        printf(\"\\nSelecione um(a) %s da lista anterior:\",verificador[0]);\n        scanf(\"%d\",&entradaNumerica);\n        while(entradaNumerica<1 || entradaNumerica>5){\n            printf(\"\\nOpcao invalida. Digite novamente: \");\n            scanf(\"%d\",&entradaNumerica);\n        }\n        verificacao=verificarCaptchaLogico(verificador,entradaNumerica);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n\n}\n\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n    char nomeEvento[50];\n    int capacidadeMax;\n    float valorEntradaInteira;\n    float valorEntradaMeia;\n    int ingressosInteiros;\n    int ingressosMeios;\n    int iInteirosVendidos;\n    int iMeiosVendidos;\n    int verificaCompra;\n    int tipoIngresso;\n    float valorPagamento;\n    float valorPagamentoFaltante;\n    float valorPagamentoFaltPago;\n    int ingressosInteirosSobrantes;\n    int ingressosMeiosSobrantes;\n    float troco;\n    float arrecadadoMeios;\n    float arrecadadoInteiros;\n    int tolalIngressosVendidos;\n    float totalArrecadado;\n\n\n    printf(\"Insira o Nome do evento \\n\");\n    scanf(\"%s\",&nomeEvento);\n    printf(\"Insira a capacidade maxima \\n\");\n    scanf(\"%d\",&capacidadeMax);\n    printf(\"Insira o valor da entrada inteira \\n\");\n    scanf(\"%f\",&valorEntradaInteira);\n    valorEntradaMeia = valorEntradaInteira \/ 2;\n    \n    ingressosMeios =  capacidadeMax*0.4;\n    ingressosInteiros = capacidadeMax - ingressosMeios;\n    verificaCompra = 1;\n    \n    while(verificaCompra == 1){\n        if(ingressosMeios == 0 && ingressosInteiros == 0){\n            printf(\"Acabou os ingressos, fim do evento\\n\");\n            verificaCompra++;\n        }else{\n            printf(\"-----------------------------------------------------------------------------\\n\");\n            printf(\"Bem Vindo a compra de ingressos para o %s \\n\\n\", nomeEvento);\n            printf(\"Digite 1 para ingressos inteiros(%i) e 2 para meias(\",ingressosInteiros);printf(\"%i) e 3 para cancelar\\n\", ingressosMeios);\n            printf(\"-----------------------------------------------------------------------------\\n\");\n            scanf(\"%d\",&tipoIngresso);\n            if(tipoIngresso == 1){\n                if(ingressosInteiros == 0){\n                    printf(\"Os ingressos inteiros estao esgotados\\n\");\n                }else{\n                    printf(\"Voce escolheu o ingresso inteiro que custa %.2f, favor indicar o valor que voce pagara\\n\", valorEntradaInteira);\n                    scanf(\"%f\",&valorPagamento);\n                    while(valorPagamento < valorEntradaInteira){\n                    valorPagamentoFaltante = valorEntradaInteira - valorPagamento;\n                    printf(\"Favor pagar o total do ingresso, faltam R$%.2f\\n\", valorPagamentoFaltante);\n                    scanf(\"%f\",&valorPagamentoFaltPago);\n                    valorPagamento = valorPagamentoFaltPago + valorPagamento;\n                    }\n                    if(valorPagamento > valorEntradaInteira){\n                        troco = valorPagamento - valorEntradaInteira;\n                        printf(\"O troco e de %.2f\\n\", troco);\n                    }\n                    ingressosInteiros = ingressosInteiros - 1;\n                }\n            }else{\n                if(tipoIngresso == 2){\n                    if(ingressosMeios == 0){\n                        printf(\"Os ingressos meios estao esgotados\\n\");\n                    }else{\n                        printf(\"Voce escolheu o ingresso meio que custa %.2f, favor indicar o valor que voce pagara\\n\", valorEntradaMeia);\n                        scanf(\"%f\",&valorPagamento);\n                        while(valorPagamento < valorEntradaMeia){\n                        valorPagamentoFaltante = valorEntradaMeia - valorPagamento;\n                        printf(\"Favor pagar o total do ingresso, faltam R$%.2f\\n\", valorPagamentoFaltante);\n                        scanf(\"%f\",&valorPagamentoFaltPago);\n                        valorPagamento = valorPagamentoFaltPago + valorPagamento;\n                        }\n                        if(valorPagamento > valorEntradaMeia){\n                            troco = valorPagamento - valorEntradaMeia;\n                            printf(\"O troco e de %.2f\\n\", troco);\n                        }\n                        ingressosMeios = ingressosMeios - 1;\n                    }\n                }else{\n                    if(tipoIngresso == 3){\n                        break;\n                    }else{\n                    printf(\"Digite uma opcao valida \\n\");\n                    }\n                }\n            }\n            printf(\"Digite 1 para comprar mais um ingresso e 2 para finalizar as compras\\n\");\n            scanf(\"%i\", &verificaCompra);\n            if(verificaCompra != 1 && verificaCompra != 2){\n                printf(\"Digite uma opcao valida \\n\");\n                verificaCompra = 1;\n            }\n        }\n    }\n    ingressosMeiosSobrantes =  capacidadeMax*0.4;\n    ingressosInteirosSobrantes = capacidadeMax - ingressosMeiosSobrantes;\n    ingressosMeiosSobrantes = ingressosMeiosSobrantes - ingressosMeios;\n    ingressosInteirosSobrantes = ingressosInteirosSobrantes - ingressosInteiros;\n    arrecadadoMeios = ingressosMeiosSobrantes * valorEntradaMeia;\n    arrecadadoInteiros = ingressosInteirosSobrantes * valorEntradaInteira;\n    tolalIngressosVendidos = ingressosInteirosSobrantes + ingressosMeiosSobrantes;\n    totalArrecadado = arrecadadoMeios + arrecadadoInteiros;\n    \n    printf(\"-------------------------------------------------\\n\");\n    printf(\"\\nEvento %s \", nomeEvento);\n    printf(\"finalizado.\\n\\nO total de ingressos inteiros vendidos foi de: %i;\\nSobraram %i;\\nTotal arrecadado R$%.2f.\\n\\nO total de ingressos meios vendidos foi de %i;\\nSobraram %i;\\nTotal arrecadado R$%.2f.\\n\\n\", ingressosInteirosSobrantes,ingressosInteiros,arrecadadoInteiros,ingressosMeiosSobrantes,ingressosMeios,arrecadadoMeios);\n    printf(\"O total de ingressos vendidos foi de %i.\\nO total de dinheiro arrecadado foi de R$%.2f\",tolalIngressosVendidos,totalArrecadado);\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define CAPTCHA 6\n\n\nchar * gerarCaptcha( char captchaSistema[CAPTCHA]){\n    int cont, guardaValor, aleatorio[CAPTCHA], geradorCaptcha[CAPTCHA];\n    srand(time(NULL));\n    for (cont = 0;cont < CAPTCHA; cont++){\n        guardaValor = rand();\n        aleatorio[cont] = (guardaValor % 122);\n        if((aleatorio[cont] >= 48 && aleatorio[cont] <= 57) || (aleatorio[cont] >= 65 && aleatorio[cont] <= 90) || (aleatorio[cont] >= 97 && aleatorio[cont] <= 122) ){\n            captchaSistema[cont] = aleatorio[cont];\n        }\n        else{\n            cont--;\n        }\n    }\n    return captchaSistema;\n}\nint confirmacaoCaptcha(char *atribuicao, char captchaDigitado[CAPTCHA]){\n    int comparaDigitado;\n    comparaDigitado = strcmp(atribuicao, captchaDigitado);\n    return comparaDigitado;\n}\n\nint main(int argc, char *argv[]) {\n    char captchaDigitado[CAPTCHA], captchaSistema[CAPTCHA], *atribuicao;\n    int comparaDigitado;\n    do{\n        atribuicao = gerarCaptcha(captchaSistema);\n        printf(\"%s\", atribuicao);\n        printf(\"\\nDigite o captcha para provar q nao e um robo\\n\");\n        gets(captchaDigitado);\n        comparaDigitado = confirmacaoCaptcha(atribuicao, captchaDigitado);\n        if(comparaDigitado == 0){\n            printf(\"\\nSao iguais!! Voce nao e um robo\\n\");\n        }\n        else if(comparaDigitado < 0 || comparaDigitado > 0){\n            printf(\"\\nCaptcha errado, um novo sera redefinido\\n\");\n        }\n\n    }while(comparaDigitado < 0 || comparaDigitado > 0);\n\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n    \n    char name[80];\n    int lotMax; \n    int contLot;\n    int tipEnt;\n    int contPag;\n    int contEsco;\n    int contIntMax;\n    int contInt;\n    int contMeiaMax;\n    int contMeia;\n    float priceMeia;\n    float pricePag;\n    float troco;\n    float lucro;\n    float price;\n    \n    \n    \n    printf(\"Digite o nome do evento (utilize de ( \/ ) para espaco):\\n\");\n    scanf(\"%s\", &name);\n    \n    do{\n        \n    printf(\"\\nDigite a capacidade maxima de pessoas(somente multiplos de 5):\\n\");\n    scanf(\"%i\" ,&lotMax);\n    \n    }while (lotMax%5!=0 || lotMax <= 0);\n    \n    do{\n    \n    printf(\"\\nDigite o preco do ingresso:\\n\");\n    scanf(\"%f\" ,&price);\n    \n    }while (price<0);\n    \n    \n    \n    \n    \n    \n    \n    priceMeia=price\/2;\n    contLot=lotMax;\n    lucro=0;\n    contIntMax=lotMax*0.6;\n    contInt=contIntMax;\n    contMeiaMax=lotMax*0.4;\n    contMeia=contMeiaMax;\n    \n    printf(\"\\n\\nEvento: %s\\n\" ,name);\n    \n    do{\n        \n        do{\n            printf(\"\\nDigite 1 para comprar um ingresso inteira.\\nDigite 2 para comprar um ingresso meia.\\n\");\n            scanf(\"%i\" ,&tipEnt);\n            \n            switch(tipEnt){\n            \n                case 1:\n                                    \n                                                        \n                    contEsco=0;\n                                            \n                    if(contInt>0){\n                        \n                        contLot--;\n                        contInt--;\n                        do{\n                        \n                            printf(\"\\nVoce deve pagar %f.\\n\" ,price);\n                            printf(\"Digite o preco pago:\\n\");\n                            scanf(\"%f\" ,&pricePag);\n                            \n                            if(pricePag<price){\n                            \n                                contPag=0;\n                                printf(\"\\nVoce nao pagou o suficiente, pague novamente.\\n\");\n                                                    \n                            }\n                            \n                            if(pricePag==price){\n                                \n                                contPag=1;\n                                printf(\"\\nVoce efetuou seu pagamento, Obrigado e volte sempre\\n\");\n                                lucro=lucro+price;\n                                                    \n                            }\n                            if(pricePag>price){\n                                \n                                contPag=1;\n                                troco=pricePag-price;\n                                printf(\"\\nVoce recebe de troco %f.\\n\\n\" ,troco);\n                                lucro=lucro+price;\n                                \n                            }\n                            \n                        }while(contPag==0);\n                        \n                    \n                    }\n                    else{\n                        \n                        printf(\"\\nAcabou os ingressos do tipo inteiro.\\n\");\n                        \n                    }\n                    \n                    break;\n                case 2:\n                    \n                    contEsco=0;\n                    \n                    if(contMeia>0){\n                        \n                        contLot--;\n                        contMeia--;\n                        do{                         \n                            printf(\"\\nVoce deve pagar %f.\\n\" ,priceMeia);\n                            printf(\"Digite o preco pago:\\n\");\n                            scanf(\"%f\" ,&pricePag);\n                        \n                            if(pricePag<priceMeia){\n                            \n                                contPag=0;\n                                printf(\"\\nVoce nao pagou o suficiente, pague novamente.\\n\\n\");\n                            \n                            }\n                            \n                            if(pricePag==priceMeia){\n                                \n                                contPag=1;\n                                printf(\"\\nVoce efetuou seu pagamento, Obrigado e volte sempre\\n\");\n                                lucro=lucro+priceMeia;\n                                                    \n                            }\n                            if(pricePag>priceMeia){\n                                \n                                contPag=1;\n                                troco=pricePag-priceMeia;\n                                printf(\"\\nVoce recebe de troco %f.\\n\\n\" ,troco);\n                                lucro=lucro+priceMeia;\n                                \n                            }\n                            \n                        }while(contPag==0);\n                        \n                    }\n                    else{\n                        \n                        printf(\"\\nAcabou os ingressos do tipo meia.\\n\");\n                        \n                    }\n                    \n                    break;\n                    \n                default:\n                        \n                    contEsco=1;\n                    printf(\"\\nDigite novamente sua escolha.\\n\\n\");\n                        \n                    break;\n                                    \n            }\n            \n        }while(contEsco==1);\n        \n        printf(\"\\n\\nEvento: %s\\n\" ,name);\n        printf(\"\\nAinda se tem %i ingressos do tipo inteiro.\\n\" ,contInt);\n        printf(\"Ainda se tem %i ingressos do tipo meia.\\n\" ,contMeia);\n        printf(\"Voce tem um lucro de %f.\\n\\n\" ,lucro);\n        \n    }while (contLot>0);\n    \n    printf(\"\\n\\nEvento: %s\\n\" ,name);   \n    printf(\"\\nacabou os ingressos.\\n\");\n    printf(\"voce teve um lucro total de %f.\\n\" ,lucro);\n    \n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nint srandString(int vetorCaptcha[6])\n{\n    int contador;\n    int recebe;\n    \n\n    for(contador = 0; contador < 6; contador ++)\n    {\n        recebe = rand() % 3;\n        if(recebe == 0);\n        {\n            vetorCaptcha[contador] = (rand() % 10) + (48);\n        }\n        if(recebe == 1)\n        {\n            vetorCaptcha[contador] = (rand() % 25) + (65);  \n        }\n        if(recebe == 2)\n        {\n            vetorCaptcha[contador] = (rand() % 25) + (97);\n        }\n        \n        printf(\"%c\", vetorCaptcha[contador]);\n    }\n    \n    \n}\n\n\nint cmpString(char vetorUsuario[6], int vetorCaptcha[6])\n{\n    int contador;\n    \n    for(contador = 0; contador < 6; contador ++)\n    {\n        if(strlen(vetorUsuario) != 6)\n        {\n            if(vetorUsuario[contador] == vetorCaptcha[contador])\n            {\n                printf(\"Digite novamente!!\\n\"); \n                return 0;\n            }\n        }\n        else\n        {   \n            printf(\"Voce digitou corretamente!!\");  \n            return 1;\n        }\n            \n    }\n                \n} \n\n\n\nint main(int argc, char *argv[]) \n{\n    int vetorCaptcha[6];\n    char vetorUsuario[6];\n    \n    int teste = 0;\n    \n    srand(time(NULL));\n        \n    srandString(vetorCaptcha);\n    \n    printf(\"\\n\\n\");\n    \n    do\n    {\n        printf(\"Digite corretamente o CAPTCHA acima: \");\n        gets(vetorUsuario);\n        \n        teste = cmpString(vetorUsuario, vetorCaptcha);\n        \n        \n    }\n    while(teste == 0);\n    \n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid main(){\n    char nome[50];\n    int capacidade,operacao,capacidadeMeiaEntrada,confirmacao,vendidoMeia,vendidoInteira;\n    float valorInteira,meiaEntrada,valorPago,troco;\n    vendidoMeia = 0;\n    vendidoInteira = 0;\n    \n    printf(\"Ingressos++\");\n    printf(\"\\nCadastre um evento\");\n    printf(\"\\nNome do evento: \\n\");\n    gets(nome);\n    printf(\"\\nCapacidade maxima: \\n\");\n    scanf(\"%d\", &capacidade);\n    capacidadeMeiaEntrada = capacidade*0.4;\n    printf(\"\\nValor da entrada: \\n\");\n    scanf(\"%g\", &valorInteira);\n    meiaEntrada = valorInteira\/2;\n    \n    printf(\"\\nEvento: %s\", nome);\n    printf(\"\\nCapacidade maxima de %d\", capacidade);\n    printf(\"\\nValor da entrada(Inteira): %g\",valorInteira);\n    printf(\"\\nValor da entrada(Meia): %g\",meiaEntrada);\n    \n    sleep(4);\n    system(\"cls\"); \n        \n    while(operacao != 3){\n    \n    printf(\"\\nComprar ingresso\");\n    printf(\"\\n[1] - Valor inteiro\");\n    printf(\"\\n[2] - Meia entrada\");\n    printf(\"\\n[3] - Finalizar vendas\\n\");\n    scanf(\"%d\", &operacao);\n    switch(operacao){\n        case 1:\n            \n            printf(\"\\nValor da compra: %g\", valorInteira);\n                printf(\"\\n Confirmar:\");\n                printf(\"\\n[1] - SIM\");\n                printf(\"\\n[2] - NAO\\n\");\n                scanf(\"%d\", &confirmacao);\n                \n                if(confirmacao == 1){\n                    printf(\"\\nValor do ingresso: %g\", valorInteira);\n                    printf(\"\\nValor pago\\n\");\n                    scanf(\"%g\", &valorPago);\n                    if(valorPago >= valorInteira){\n                    \n                    troco = valorPago - valorInteira;\n                    printf(\"\\nTroco: %g\", troco);\n                    \n                    printf(\"\\nIngresso comprado com sucesso!\");\n                    capacidade = capacidade - 1;\n                    vendidoInteira++;\n                    \n                    printf(\"\\nValor do ingresso: %g \\nvalor pago: %g \\ntroco: %g\",valorInteira,valorPago,troco);\n                    break;\n                }else{\n                    printf(\"\\nQuantia insuficiente!\");\n                    break;\n                }\n                }else{\n                    printf(\"\\nOperacao finalizada!\");\n                    break;\n                }\n            \n            \n        case 2:\n            if(capacidadeMeiaEntrada > 0 ){\n                \n                printf(\"\\nValor do ingresso: %g\", meiaEntrada);\n                printf(\"\\nConfirmar:\");\n                printf(\"\\n[1] - SIM\");\n                printf(\"\\n[2] - NAO\\n\");\n                scanf(\"%d\", &confirmacao);\n                if(confirmacao == 1){\n                    printf(\"\\nValor do ingresso: %g\",meiaEntrada);\n                    printf(\"\\nValor pago:\\n\");\n                    scanf(\"%g\", &valorPago);\n                    if(valorPago>=meiaEntrada){\n                    \n                    troco = valorPago - meiaEntrada;\n                    printf(\"\\nTroco: %g\", troco);\n                    \n                    printf(\"\\nIngresso comprado com sucesso!\");\n                    capacidadeMeiaEntrada = capacidadeMeiaEntrada - 1;\n                    capacidade = capacidade - 1;\n                    vendidoMeia++;\n                    printf(\"\\nValor do ingresso: %g \\nValor pago: %g \\nTroco: %g\",meiaEntrada,valorPago,troco);\n                    break;\n                    }else{\n                        printf(\"\\nQuantia insuficiente!\");\n                        break;\n                    }\n                }else{\n                    printf(\"\\nOperacao finalizada!\");\n                    break;\n                }\n                \n            }else{\n                printf(\"\\nIngressos de meia entrada esgotados!\");\n                break;\n            }\n        \n        case 3: \n            printf(\"\\nTotal de ingressos vendidos tipo inteira: %d\", vendidoInteira);\n            printf(\"\\nTotal de ingressos vendidos tipo meia: %d\", vendidoMeia);\n            printf(\"\\nIngressos disponiveis inteira: %d\", capacidade);\n            printf(\"\\nIngressos disponiveis meia: %d\", capacidadeMeiaEntrada);\n            \n            break;\n                \n        default: \n            printf(\"\\nIngressos esgotados\");    \n            sleep(5);\n            break;\n    }\n}\n    \n    \n    \n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n\n\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n\n\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n\n\n                                }\n\n\n                            }\n\n                        }\n                    }\n                }\n\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n\n            porcentvitP1=(vitoriasP1*100)\/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)\/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n\n\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n\n\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n\n\n                                }\n\n\n                            }\n\n                        }\n                    }\n                }\n\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n\n            porcentvitP1=(vitoriasP1*100)\/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)\/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n\n    system(\"pause\");\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n\nint main(int argc, char *argv[]) \n{\n    float valorIngresso, meiaEntrada, valorPago, troco;\n    int opcao, capacidadeMaxima, tipoIngresso, x, y, quantidadeVendido, quantidadeRestante;\n    char evento;    \n    \n    capacidadeMaxima = 0;\n    quantidadeRestante = 1;\n    x = 0;\n    y = 0;\n    \n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    printf(\"\\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\\n\");\n    printf(\"\\n\");\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    \n    while (y == 0)\n    {\n        while (x <= 50)\n        {\n            printf(\"_\");\n            x++;                \n        }\n            \n        x = 0;\n        \n        \n        printf(\"\\n\");           \n        printf(\"\\n1) Cadastro de Evento.\\n\");\n        printf(\"2) Compre seu ingresso.\\n\");\n        printf(\"3) Sair.\\n\");\n        printf(\"\\n\");       \n            \n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        printf(\"\\n\");\n    \n        switch (opcao)\n        {\n            case 1:\n                printf(\"\\t-Digite o nome do evento: \");\n                scanf(\"%s\", &evento);\n                printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n                scanf(\"%d\", &capacidadeMaxima);\n                printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n                scanf(\"%g\", &valorIngresso);\n                \n                \n                meiaEntrada = valorIngresso * 0.4;\n                quantidadeVendido = 0;  \n                quantidadeRestante = capacidadeMaxima;      \n            break;\n            case 2:\n            \n                if (capacidadeMaxima == 0)\n                {\n                    printf(\"Nao ha evento cadastrado\\n\");   \n                }\n                else\n                {       \n                    \n                        \n                    if(quantidadeRestante <= 0)\n                    {\n                    \n                    printf(\"Ingresso Esgotados!\\n\");\n                        \n                    }\n                    else\n                    {                       \n                        printf(\"\\t_______________________________________\\n\");\n                        printf(\"\\n\\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\\n\");\n                        printf(\"\\t_______________________________________\\n\");\n                        \n                        printf(\"\\n\\t\\tO valor do evento eh: R$%.2f \\n\\t\\t(Meia entrada: R$%.2f)\\n\", valorIngresso, meiaEntrada);\n                        \n                        printf(\"\\nEscolha o tipo de ingresso:\\n\");\n                        printf(\"\\n\\t-Digite 1 para inteira.\\n\");\n                        printf(\"\\t-Digite 2 para meia.\\n\\n\\t\\t\");   \n                        scanf(\"%d\", &tipoIngresso); \n                        \n                            \n                        switch (tipoIngresso) \n                        {\n                            case 1: \n                                printf(\"\\n\\nInsira o dinheiro: \");\n                                scanf(\"%g\", &valorPago);\n                                    \n                                if (valorPago < valorIngresso)\n                                {\n                                        printf(\"Valor pago insuficiente!\\n\");                       \n                                }\n                                else\n                                {\n                                    if (valorPago > valorIngresso)  \n                                    {\n                                        troco = valorPago - valorIngresso;                                  \n                                        printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                                    }\n                                        printf(\"\\nCompra concluida!\\n\");\n                                        \n                                        quantidadeVendido++;                                    \n                                }\n                            break; \n                            case 2: \n                                printf(\"Insira o dinheiro: \");\n                                scanf(\"%g\", &valorPago);\n                                \n                                if (valorPago < meiaEntrada)\n                                {\n                                    printf(\"Valor pago insuficiente!\\n\");                       \n                                }\n                                else\n                                {\n                                    if (valorPago > meiaEntrada)\n                                    {\n                                        troco = valorPago - meiaEntrada;                                    \n                                        printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                                    }\n                                    printf(\"\\nCompra concluida!\\n\");\n                                            \n                                    quantidadeVendido++;\n                                }               \n                            break;\n                            default:\n                                printf(\"Opcao invalida.\\n\");\n                            break;\n                                                                                                \n                        } \n                    \n                    quantidadeRestante = capacidadeMaxima - quantidadeVendido;\n                printf(\"\\n\\tQuantidade de entrada inteira restantes: %d\\n\", quantidadeRestante);                \n                printf(\"\\tQuantidade de meia entrada restantes: %d\\n\", quantidadeRestante);\n                    \n                    }\n                }\n            break; \n                        \n            case 3:\n                y = 1;\n            break;  \n            \n            default:\n                printf(\"Opcao invalida.\\n\");\n            break;  \n                \n                \n        } \n    } \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n\nchar * gerarCaptcha(char captcha[6] )\n {\n   \n   int cont;\n   \n   for (cont = 0 ; cont < 4 ; cont++)\n    {\n       captcha[cont] = 97 + (rand() % 25);\n    }\n    \n    \n    for (cont = 4 ; cont < 6 ; cont++)\n    {\n       captcha[cont] = 48 + (rand() % 9);\n    }\n    \n    captcha[0] = (captcha[0] - 32);\n    \n    return captcha;\n}\n\n\nchar * lerDigitado(char digitado[50])\n{\n    gets(digitado);\n    \n    return digitado;\n}\n\n\nint compararCaptcha(char digitado[6] , char captcha[6])\n{\n  int cont;\n  int resultadoComparacao;  \n  \n  resultadoComparacao = strcmp(digitado,captcha);\n  \n  return resultadoComparacao;\n}\n\n\n\nint main(int argc, char *argv[]) {\n    \n    srand(time(NULL));\n    \n    int cont;\n    int resultado;\n    \n    char * captcha;\n    char vetorCaptcha[7];\n    \n    char * digitado;\n    char vetorDigitado[50];\n    \n    resultado = 1;\n    \n    printf(\"\\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n\");\n    \n    do{\n        captcha = gerarCaptcha(vetorCaptcha);\n        printf(\"%s\\n\" , captcha);\n            \n        digitado = lerDigitado(vetorDigitado);\n        \n        resultado = compararCaptcha(digitado , captcha);\n        \n        if (resultado != 0)\n        {\n          printf(\"\\nIncorreto! Tente novamente:\\n\\n\");\n        }\n        \n    }while(resultado != 0);\n    \n    printf(\"\\nCORRETO!!!\\Agora ja pode prosseguir...\");\n        \n    return 0;\n    \n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <conio.h>\n\n\n\n\nint main(int argc, char *argv[]) {\n    \n    \n    char nomeEvento[20], localEvento[40], dataEvento[8], horaEvento[5];\n    int detalhes, cadastro, qntdIngressos;\n    int qntdInteiro, qntdMeio, tipoCompra;\n    int capacMax;\n    int contadorCompra;\n    float vlrIngresso, vlrMeioIngresso;\n    float vlrPago, vlrTroco, vlrSobra;\n    \n    \n    do\n    {\n        system(\"cls\");\n        printf(\"-----------------------------------------------------------\\n\");\n        printf(\"----------------   Vendedor de Ingressos   ----------------\\n\");\n        printf(\"--------------    Configuracoes do Evento    --------------\\n\");\n        printf(\"-----------------------------------------------------------\\n\\n\\n\");\n        printf(\"Digite o nome do evento: \");\n        setbuf(stdin, NULL);\n        gets(nomeEvento);\n        printf(\"\\n      |Deseja adicionar detalhes ao evento?\\n\");\n        do\n        {\n            printf(\"        |   1. Sim\\n\");\n            printf(\"        |   2. Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n\");\n            printf(\"        |   Digite a opcao desejada: \");\n            scanf(\"%d\", &detalhes);\n                switch(detalhes)\n                {\n                    case 1:\n                        printf(\"        |\\n     |Digite a data do evento (dd\/mm\/aa): \");\n                        setbuf(stdin, NULL);\n                        gets(dataEvento);\n                        printf(\"        |\\n     |Digite a hora do evento (hh:mm): \");\n                        setbuf(stdin, NULL);\n                        gets(horaEvento);\n                        printf(\"        |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro): \");\n                        setbuf(stdin, NULL);\n                        gets(localEvento);\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        printf(\"\\n      |opcao invalida, digite novamente.\\n\");\n                }\n        }\n        while (detalhes>2 || detalhes<1);\n        printf(\"\\nDigite o total de ingressos a serem vendidos: \");\n        scanf(\"%d\", &qntdIngressos);\n        printf(\"Digite o valor unitario de cada ingresso: R$\");\n        scanf(\"%f\", &vlrIngresso);\n        do\n        {\n            printf(\"\\n\\n\\n          |Finalizar cadastro?                         |\\n\");\n            printf(\"            |   1. Sim                               |\\n\");\n            printf(\"            |   2. Nao, reenserir informacoes        |\\n            |                                        |\\n\");\n            printf(\"            |Digite a opcao desejada: \");\n            scanf(\"%d\", &cadastro); \n            if(cadastro >2 || cadastro<1)\n            {\n                printf(\"            |\\n         |   Opcao invalida, digite novamente: \");\n            }\n        }\n        while(cadastro>2 || cadastro<1);\n    }\n    while(cadastro==2);\n    \n\n    qntdMeio = qntdIngressos*0.4;\n    qntdInteiro = qntdIngressos-qntdMeio;\n    vlrMeioIngresso = vlrIngresso*0.5;\n    capacMax = qntdIngressos;\n        \n    do\n    {   \n        system(\"cls\");\n        printf(\"---------------------------------------------------------\\n\");\n        printf(\"| Auto atendimento - Venda de ingressos - %s | \\n\", nomeEvento);\n        printf(\"---------------------------------------------------------\\n\");\n        if(detalhes==1)\n        {\n            printf(\"\\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s\", dataEvento, horaEvento, localEvento);\n        }\n        printf(\"\\n  - Capacidade maxima: %d \", capacMax);\n        printf(\"\\n  - Valor unitario ingresso: R$ %.2f\\n\\n \", vlrIngresso);printf(\"__________________________________________________________\");\n        printf(\"\\n\\nDigite o tipo de ingresso que deseja comprar: \");\n        printf(\"\\n  1. Ingresso inteiro\");\n        printf(\"\\n  2. Meio ingresso\");\n        printf(\"\\n\\n    Digite a opcao desejada: \");\n        scanf(\"%d\", &tipoCompra);\n            switch(tipoCompra)\n            {           \n                case 1:\n                    if(qntdInteiro > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");;\n                                }else{\n                                    vlrSobra = vlrIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrIngresso);\n                        qntdInteiro--;\n                    }else{\n                    printf(\"Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                case 2:\n                    if(qntdMeio > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrMeioIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrMeioIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrMeioIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrMeioIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");\n                                }else{\n                                    vlrSobra = vlrMeioIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrMeioIngresso);\n                        qntdMeio--;\n                    }else{\n                    printf(\"\\n- Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                default:\n                    printf(\"\\nOpcao invalida, digite novamente: \");\n            }\n        qntdIngressos = qntdInteiro + qntdMeio;\n        printf(\"\\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________\");\n        printf(\"\\n                        Relatorio                            \");\n        printf(\"\\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d\", qntdIngressos, qntdInteiro, qntdMeio);\n        printf(\"\\n__________________________________________________________\");\n        if(qntdIngressos > 0)\n        {\n            do\n            {\n                printf(\"\\n\\n\\nDeseja realizar uma nova compra?\");\n                printf(\"\\n  1. Sim\\n    2. Nao, desejo finalizar.\");\n                printf(\"\\n\\n    Digite a opcao desejada: \");\n                scanf(\"%d\", &contadorCompra);\n            }while(contadorCompra < 1 && contadorCompra > 2);\n        }\n    }while(contadorCompra == 1 && qntdIngressos > 0);\n    if(qntdIngressos == 0)\n    {\n        printf(\"\\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos.\");\n    }\n    \nreturn 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat valorIngresso, meiaEntrada;\nint capacidadeMax, capacidadeMeia, capacidadeInteira, iComprados, mComprados, contEvento, evento;\nchar nomeEvento[31][30];\nint capacidade[31];\nfloat preco[31];\nint capacidadeI[31], capacidadeM[31];\n\nvoid cabecalho()\n{\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    printf(\"\\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\\n\");\n    printf(\"\\n\");\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n}\n\n\nvoid cadastrarEvento()\n{\n    \n    fflush(stdin);\n    printf(\"\\t-Digite o nome do evento: \");\n    gets(nomeEvento[contEvento]);\n    \n    fflush(stdin);\n\n    printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n    scanf(\"%d\", &capacidadeMax);\n    capacidade[contEvento] = capacidadeMax;\n        \n    capacidadeMeia = 0.4*capacidadeMax;\n    capacidadeInteira = 0.6*capacidadeMax;\n    \n    capacidadeI[contEvento] = capacidadeInteira;\n    capacidadeM[contEvento] = capacidadeMeia;\n            \n    printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n    scanf(\"%g\", &valorIngresso);\n    preco[contEvento] = valorIngresso;\n                \n            \n        contEvento++;   \n}\n\nint selecionarEvento()\n{\n    int contadorLista, existeEvento;\n    \n    printf(\"\\t\\t\\t\\t\\t\\tEventos Cadastrados: \\n\");\n    printf(\"\\n\\t\\t\\tNOME\\t\\t \\t\\tCAPACIDADE\\t\\t \\t\\tPRECO\\n\\n\");\n    for(contadorLista = 0; contadorLista < 31; contadorLista++)\n    {\n        if(capacidade[contadorLista] != 0)\n        {\n            printf(\"%d)\\t%s\\t\\t\\t\\t\\t\\t%d pessoa(s)\\t\\t\\t\\tR$%.2f\\n\", contadorLista, nomeEvento[contadorLista], capacidade[contadorLista], preco[contadorLista]);\n        }\n    }\n    \n        printf(\"\\n\\n Digite o numero do evento desejado: \");\n        scanf(\"%d\", &evento);\n        \n        if(capacidade[evento] != 0)\n        {\n            capacidadeMax = capacidade[evento];\n            valorIngresso = preco[evento];\n            capacidadeInteira = capacidadeI[evento];\n            capacidadeMeia = capacidadeM[evento];\n            \n            \n            \n            existeEvento = 1;\n        }\n            else\n            {\n                existeEvento = 0;\n            }\n    \n    return existeEvento;\n    \n}\n\n\nint escolherIngresso()\n{   \n    int tipoIngresso;\n    \n\n    meiaEntrada = valorIngresso*0.5;\n    \n        printf(\"\\t_______________________________________\\n\");\n        printf(\"\\n\\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\\n\");\n        printf(\"\\t_______________________________________\\n\");\n            \n        printf(\"\\n\\t\\tO valor do evento eh: R$%.2f \\n\\t\\t(Meia entrada: R$%.2f)\\n\", valorIngresso, meiaEntrada);    \n                        \n        printf(\"\\nEscolha o tipo de ingresso:\\n\");\n        printf(\"\\n\\t-Digite 1 para inteira.\\n\");\n        printf(\"\\t-Digite 2 para meia.\\n\\n\\t\\t\");   \n        scanf(\"%d\", &tipoIngresso); \n        \n        return tipoIngresso;\n}\n\nvoid comprarIngresso(int ingresso, float desconto)\n{\n    \n    float valorPago, troco;\n    \n    \n        \n        switch (ingresso) \n        {\n        case 1: \n            if(capacidadeInteira > 0)\n            {           \n        \n                printf(\"\\n\\nInsira o dinheiro: \");\n                scanf(\"%g\", &valorPago);\n                                        \n                if (valorPago < (valorIngresso - (valorIngresso*desconto)))\n                {\n                    printf(\"Valor pago insuficiente!\\n\");                       \n                }\n                    else\n                    {\n                        if (valorPago > (valorIngresso -(valorIngresso*desconto)))\n                        {\n                            troco = valorPago - (valorIngresso - (valorIngresso*desconto));                                 \n                            printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                        }\n                    printf(\"\\nCompra concluida!\\n\");                \n                    \n                    capacidadeInteira--;\n                    capacidadeI[evento] = capacidadeInteira;\n                                        \n                    printf(\"\\nevento: %d\", capacidadeI[evento]);\n                    printf(\"\\n\\tInteiros restantes: %d\\n\", capacidadeInteira);\n                    \n                    iComprados = (capacidadeMax*0.6)-capacidadeInteira;\n                    printf(\"\\n\\tInteiros comprados: %d\\n\", iComprados);\n                        \n                \n                    }\n            }\n            else\n                {\n                    printf(\"\\t\\t\\nEntradas inteiras esgotadas!\\n\");\n                }\n        break;\n        case 2: \n            if(capacidadeMeia > 0)\n            {\n                            \n                printf(\"Insira o dinheiro: \");\n                scanf(\"%g\", &valorPago);\n                    \n                if (valorPago < (meiaEntrada - (meiaEntrada*desconto)))\n                {\n                    printf(\"Valor pago insuficiente!\\n\");                       \n                }\n                    else\n                    {\n                        if (valorPago > (meiaEntrada - (meiaEntrada*desconto)))\n                        {\n                            troco = valorPago - (meiaEntrada - (meiaEntrada*desconto));                                 \n                            printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                        }\n                        printf(\"\\nCompra concluida!\\n\");\n                                            \n                    capacidadeMeia--;\n                    capacidadeM[evento] = capacidadeMeia;\n                                    \n                    printf(\"\\n\\tMeia entrada restantes: %d\\n\", capacidadeMeia);\n                    \n                    mComprados = (capacidadeMax*0.4)-capacidadeMeia;\n                    printf(\"\\n\\tMeia entrada compradas: %d\\n\", mComprados);\n                    \n                    capacidadeM[evento] = capacidadeMeia;\n                    }   \n            }\n                else\n                {\n                    printf(\"\\t\\t\\nMeias entradas esgotadas!\\n\");\n                }\n                            \n        break; \n        default:\n            printf(\"Opcao invalida.\\n\");\n        break;\n        }\n}\n\nvoid menuIngresso()\n{                       \n    int pagamento, existeEvento;\n        \n    if (capacidadeMax == 0)\n    {\n        printf(\"Nao ha evento cadastrado\\n\");   \n    }\n        else\n        {   \n            existeEvento = selecionarEvento();\n            \n            if(existeEvento == 1)   \n            {\n                printf(\"\\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n\");\n                printf(\"\\n Digite 1 para pagamento no cartao: \");           \n                printf(\"\\n Digite 2 para pagamento em dinheiro: \\n\\t\");\n                scanf(\"%d\", &pagamento);\n            \n            \n                if(pagamento == 1)\n                {           \n                comprarIngresso(escolherIngresso(), 0);\n                }\n                    else\n                    {\n                        comprarIngresso(escolherIngresso(), 0.1);\n                    }\n            }\n                else\n                {\n                    printf(\"\\n\\n\\tNao existe esse evento!\\n\");\n                }   \n        }\n}\n\n\n\n\n\nint main(int argc, char *argv[]) \n{\n    int opcao, loop;\n    \n    contEvento = 0;\n    loop = 0;   \n    \n    cabecalho();\n    \n    while(loop == 0)\n    {\n    \n    \n        printf(\"\\n\");           \n        printf(\"\\n1) Cadastro de Evento.\\n\");       \n        printf(\"2) Compre seu ingresso.\\n\");    \n        printf(\"3) Sair.\\n\");\n        printf(\"\\n\");       \n            \n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        printf(\"\\n\");\n    \n        switch (opcao)\n        {\n            case 1:\n                cadastrarEvento();\n            break;\n            case 2: \n                menuIngresso();\n            break;\n            case 3:\n                loop = 1;\n            break;\n            default:\n                printf(\"Opcao invalida!\\n\");\n            break;\n            \n        }   \n    }\n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) \n{\n    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;\n    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;\n    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;\n    \n    while(1)\n    {\n        system(\"cls\");\n        printf(\"Jogo Jokenpo\\n\\n\");\n        printf(\"(1) humano x computador\\n\");\n        printf(\"(2) humano x humano\\n\");\n        printf(\"(3) resultado\\n\");\n        printf(\"(4) sair\\n\\n\");\n        printf(\"Escolha uma das opcoes acima: \");\n        scanf(\"%d\", &opcao);\n        \n            \n        if(opcao == 1)\n        {\n            numeroDePartidas++;\n            printf(\"\\n(1) = pedra\\n\");\n            printf(\"(2) = papel\\n\");\n            printf(\"(3) = tesoura\\n\");\n            \n            printf(\"\\nopcao de jogada humano: \");\n            scanf(\"%d\", &opcaoDeJogadaHumano);\n            \n            opcaoDeJogadaComputador = rand()%3;\n            printf(\"opcao de jogada computador: %d\\n\\n\", opcaoDeJogadaComputador);\n            \n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            system(\"pause\");\n        }\n        else\n        {\n            if(opcao == 2)\n            {\n                numeroDePartidas++;\n                printf(\"\\n1 = pedra\\n\");\n                printf(\"2 = papel\\n\");\n                printf(\"3 = tesoura\\n\");\n                \n                printf(\"\\nopcao de jogada humano 1: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano1);\n            \n                printf(\"\\nopcao de jogada humano 2: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano2);\n                \n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                system(\"pause\");\n            }\n            else\n            {\n                if(opcao == 3)\n                {\n                    printf(\"\\nNumero de partidas: %d\\n\", numeroDePartidas);\n                    printf(\"Numero de vitorias humano: %d\\n\", numeroDeVitoriasHumano);\n                    printf(\"Numero de vitorias computador: %d\\n\", numeroDeVitoriasComputador);\n                    printf(\"Numero de vitorias humano 1: %d\\n\", numeroDeVitoriasHumano1);\n                    printf(\"Numero de vitorias humano 2: %d\\n\", numeroDeVitoriasHumano2);\n                    printf(\"Numero de empates: %d\\n\\n\", numeroDeEmpates);\n                    system(\"pause\");\n                }\n                else\n                {\n                    if(opcao == 4)\n                    {\n                        exit(0);\n                    }\n                    else\n                    {\n                        printf(\"\\nopcao invalida\\n\\n\");\n                    }\n                    system(\"pause\");\n                }\n            }\n                \n        }\n    \n    }\n    \n    \n    \n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n\n    printf(\"Digite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n        \n\n    \n    contInteira = 0;\n    contMeia = 0;\n    \n    system(\"cls\");\n    \n    \n    \n    while(opcao != 2)\n    {\n        system(\"cls\");\n        \n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        \n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        \n        \n        system(\"cls\");\n        \n        \n        \n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            \n            printf(\"\\nIngressos:\\n\");\n            printf(\"\\n(1) Entrada Inteira\\n\");\n            printf(\"(2) Meia Entrada\\n\\n\");\n            printf(\"Escolha a opcao desejada: \");\n            scanf(\"%d\", &escolha);\n            \n            \n            if(escolha == 1)\n            {\n                valorPagar = entradaInteira;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contInteira++;\n            }\n            else\n            {\n                valorPagar = entradaInteira \/ 2;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contMeia++;\n            }\n            \n            \n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nForma de Pagamento:\\n\");\n                printf(\"\\n(1) Somente em Dinheiro\\n\");\n                printf(\"\\nDigite 1 para iniciar o pagamento:\");\n                scanf(\"%d\", &tipo);\n                \n                if(tipo == 1)\n                {\n                    printf(\"\\nDigite o valor em dinheiro:\");\n                    scanf(\"%g\", &pagamento);\n                    totalPagar = pagamento - valorPagar;\n                    \n                    if(totalPagar < 0)\n                    {\n                        printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                    }\n                    else \n                    {\n                        printf(\"\\ntroco eh: %g\", totalPagar);\n                        ingressoComprado = 1;\n                    }\n                    \n                }\n                else\n                {\n                    printf(\"Pagamento somente em dinherio !\\n\\n\");\n                }\n            }\n            \n        \n            \n            printf(\"\\n\\nIngressos Comprado\\n\\n\");\n            system(\"pause\");\n                                \n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            system(\"pause\");\n        }\n    }\n    \n    \n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nstruct data\n{\n    int dia;\n    int mes;\n    int ano;    \n};\n\n\n\nint main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes, formaPagamento;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n    struct data diaEvento;\n    \n    \n\n    opcao = 2;\n    \nwhile(opcao == 2)\n{\n    printf(\"Criar evento:\\n\");\n    printf(\"\\nDigite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite o data que o evento ira acontecer: \");\n    scanf(\"%d\/%d\/%d\", &diaEvento.dia, &diaEvento.mes, &diaEvento.ano);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n        \n\n    \n    contInteira = 0;\n    contMeia = 0;\n    ingressoComprado = 0;\n    \n    system(\"cls\");\n    opcao = 0;\n    \n    \n    \n    while(opcao != 2)\n    {\n        system(\"cls\");\n        \n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        \n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        \n        \n        system(\"cls\");\n        \n        \n        \n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            \n            while(escolha !=1 && escolha !=2)\n            {\n                printf(\"\\nIngressos:\\n\");\n                printf(\"\\n(1) Entrada Inteira\\n\");\n                printf(\"(2) Meia Entrada\\n\\n\");\n                printf(\"Escolha a opcao desejada: \");\n                scanf(\"%d\", &escolha);\n                \n                \n                if(escolha == 1)\n                {\n                    valorPagar = entradaInteira;\n                    printf(\"\\nValor a pagar: %g\", valorPagar);\n                    contInteira++;\n                }\n                else if(escolha == 2)\n                {\n                    valorPagar = entradaInteira \/ 2;\n                    printf(\"\\nValor a pagar: %g\", valorPagar);\n                    contMeia++;\n                }else\n                {\n                    printf(\"\\nOpcao Invalida!\");\n                    \n                }\n            \n            }\n            escolha = 0;\n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nEscolha a Forma de Pagamento:\\n\");\n                printf(\"\\nDigite 1 para pagar em dinheiro ou 2 para pagar com cartao:\");\n                scanf(\"%d\", &tipo);\n                \n                while(tipo == 1 || tipo == 2)\n                {\n                \n                    if(tipo == 1)\n                    {\n                        printf(\"\\nDigite o valor em dinheiro:\");\n                        scanf(\"%g\", &pagamento);\n                        totalPagar = pagamento - valorPagar * 0.9;\n                        \n                        \n                        \n                        if(totalPagar < 0)\n                        {\n                            printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                            system(\"pause\");\n                        }\n                        else \n                        {\n                            printf(\"\\ntroco eh: %g\", totalPagar);\n                            ingressoComprado++;\n                            break;\n                        }               \n                    }\n                    else\n                    {\n                        if(tipo == 2)\n                        {\n                            while(formaPagamento !=1 && formaPagamento !=2)\n                            {\n                            \n                                printf(\"\\nPagamento sendo realizado no cartao!\\n\");\n                                printf(\"\\nDigite 1 para Debito!\\n\");\n                                printf(\"\\nDigito 2 para credito!\\n\");\n                                printf(\"\\nEscolha opcao desejada:\");\n                                scanf(\"%d\", &formaPagamento);\n                                \n                                if(formaPagamento == 1)\n                                {\n                                    printf(\"\\nPagamento realizado no debito!\\n\");\n                                    ingressoComprado++;\n                                    \n                                    \n                                }\n                                else if(formaPagamento == 2)\n                                {       \n                                    printf(\"\\nPagamento realizado no credito!\\n\");\n                                    ingressoComprado++;\n                                \n                                    \n                                }else\n                                {\n                                    printf(\"\\nOpcao Invalida!\\n\");\n                                }\n                            }\n                            formaPagamento= 0;\n                            \n                        }\n                        \n                        break;\n                    }\n                    \n                \n                    \n                }\n            \n            }\n            \n        \n            printf(\"\\n\\nIngresso Comprado\\n\\n\");\n            system(\"pause\");    \n            \n                                \n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            printf(\"Ingressos comprados Entrada Inteira: %d\\n\", contInteira);\n            printf(\"\\nIngressos comprados Meia Entrada: %d\\n\\n\", contMeia);\n            system(\"pause\");\n        }\n        \n        system(\"cls\");\n    }\n    \n    \n    \n}\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n\nint main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    \n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S\/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S\/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 \/ (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 \/ (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 \/ (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador \/ (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#define CAPTCHA 6\n\n\n\nint loop = 1;\n\n\nchar * gerarCaptcha(char valor[CAPTCHA]) {\n    \n    int cont;\n    int randomico;\n    \n    srand(time(NULL));\n    \n    for(cont = 0; cont < CAPTCHA; cont++){\n        \n        randomico = ((rand() % 122) + 1);\n        \n        if ((randomico >= 48 && randomico <= 57) || (randomico >= 65 && randomico <= 90) || (randomico >= 97 && randomico <= 122)) {\n            \n            valor[cont] = randomico;\n            \n        }else{\n            \n            cont--;\n            \n        }\n        \n    }\n    \n    return valor;\n    \n}\n\n\nvoid trasformarCaptcha(char novaString[CAPTCHA], char digitado[CAPTCHA]) {\n    \n    strcpy(novaString, digitado);\n    \n}\n\n\nvoid comparaCaptcha(char valor[CAPTCHA], char digitado[CAPTCHA]){\n    \n    if (strcmp(valor, digitado) == 0) {\n        \n        printf(\"Obrigado, esta confirmado que voce nao e um robo!\\n\");\n        \n        loop = 0;\n        \n    } else {\n        \n        printf(\"CAPTCHA digitado incorretamente, por favor tente novamente.\\n\");\n        \n    }\n    \n}\n\n\nint main(void) {\n    \n    char valor[CAPTCHA], *retorno, digitado[CAPTCHA], copia[CAPTCHA + 1];\n    \n    while (loop == 1) {\n        \n        retorno = gerarCaptcha(valor);\n        \n        trasformarCaptcha(copia, retorno);\n        \n        printf(\"%s\", retorno);\n        \n        printf(\"\\nDigite a CAPTCHA: \");\n        gets(digitado);\n        \n        comparaCaptcha(copia, digitado);\n        \n    }\n    \n    return 0;\n    \n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    \n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    \n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    \n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    \n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    \n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) \/ partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) \/ partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) \/ partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) \/ partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n\nchar * gercaptcha (char captcha [6]) {\n    int cont;\n        \n    for (cont = 0; cont < 6; cont ++)\n    {\n        if (cont== 0 || cont==3|| cont ==5)\n        {\n            captcha [cont] = 65 + (rand() % 26);\n            \n        }else {\n            if (cont==1 || cont == 2|| cont==4)\n            {\n                captcha [cont] = 48 + (rand() % 10);\n            }\n        }\n    }\n    return captcha;\n    \n}\nint comparar (char captchalido [6], char captchaescrito [6])\n{\n    int cont;\n    int diferenca;\n    \n    diferenca = 0;\n    \n    for ( cont = 0; cont <6; cont++)\n    {\n        if (captchalido [cont]   != captchaescrito [cont])\n        {\n            diferenca ++;\n        }\n    }\n        if (diferenca > 0){\n            return 1;\n            \n        }\n        else {\n            return 0;\n        }\n}\n\n\nint main (int argc, char *argv[]) {\n    char captchaG [6];\n    char *captcha;\n    char leitura [6];\n    int result;\n    \n    srand (time (NULL));\n    \n    \n    printf (\"Digite conforme o Captcha \\n\");\n    captcha = gercaptcha (captchaG);\n    printf (\"Captcha: %s \\n\", captcha);\n    \n    gets (leitura);\n    \n    result = comparar (captcha, leitura); \n    \n    if (result == 1)\n    {\n        printf (\"Deu ruim\");\n        }\n        if (result ==0)\n        {printf (\"Deu bom\");\n            }   \n    \n    \n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid main(){\n    char nome [60];\n    int capacidadeMax, operacao, disponivelMeia, confirmacao, vendidoMeia, vendidoInteira;\n    float valorInteira, meiaEntrada, valorTotal, troco;\n    vendidoMeia = 0;\n    vendidoInteira = 0;\n        \n    printf(\"Ingressos++_Meu sistema de gestao de vendas de ingressos. \\n\");\n    printf(\"\\n\\n Cadastre o seu evento. \\n\");\n    printf(\"Nome do evento: \\n\");\n    gets(nome);\n    printf(\"Valor da entrada: \\n\");\n    scanf(\"%f\", &valorInteira);\n    meiaEntrada = valorInteira\/2;\n    printf(\"Capacidade maxima do local: \\n\");\n    scanf(\"%d\", &capacidadeMax);\n    disponivelMeia = capacidadeMax*0.4;\n    \n    printf(\"\\n\\n Evento: %s \\n\", nome);\n    printf(\"Capacidade maxima de %d lugares \\n\", capacidadeMax);\n    printf(\"Valor da entrada Inteira: %g \\n\",valorInteira);\n    printf(\"Valor da Meia entrada: %g \\n\",meiaEntrada);\n                \n    while(operacao != 3){\n    \n    printf(\"\\n\\n Para comprar o seu ingresso escolha: \\n\");\n    printf(\"[1] - Valor inteiro \\n\");\n    printf(\"[2] - Meia entrada \\n\");\n    printf(\"[3] - Finalizar vendas \\n\");\n    scanf(\"%d\", &operacao);\n    switch(operacao){\n        case 1:\n            \n            if(capacidadeMax > 0){\n            \n                         \n                printf(\"Valor da compra: %g\", valorInteira);\n                printf(\"\\n\\n Concluir: \\n\");\n                printf(\"[1] - SIM \\n\");\n                printf(\"[2] - NAO \\n\");\n                scanf(\"%d\", &confirmacao);\n                \n                if(confirmacao == 1)\n                    printf(\"\\n Valor do ingresso: %g\", valorInteira);\n                    printf(\"\\n Digite o valor pago: \\n\");\n                    scanf(\"%g\", &valorTotal);\n                    if(valorTotal >= valorInteira){\n                                    \n                    troco = valorTotal - valorInteira;\n                    printf(\"\\n troco: %g \\n\", troco);\n                \n                }else{\n                    printf(\"Valor insuficiente para concluir a compra.\");\n                    break;\n                }   \n                    printf(\"\\n Compra efeituada com exito.\");\n                    capacidadeMax = capacidadeMax - 1;\n                    vendidoInteira++;\n                                        \n                    break;\n                    \n                }else{\n                    printf(\"Ingressos esgotados. \\n\");\n                    break;\n                }\n            \n                    \n        case 2:\n            if(disponivelMeia > 0){\n                \n                printf(\"\\n Valor do ingresso: %g\", meiaEntrada);\n                printf(\"\\n Confirmar: \\n\");\n                printf(\"[1] - SIM \\n\");\n                printf(\"[2] - NAO \\n\");\n                scanf(\"%d\", &confirmacao);\n                \n                if(confirmacao == 1){\n                    printf(\"\\n Valor do ingresso: %g\",meiaEntrada);\n                    printf(\"\\n Digite o valor pago: \\n\");\n                    scanf(\"\\n %g\", &valorTotal);\n                                                        \n                    if(valorTotal >= meiaEntrada){\n                    \n                    troco = valorTotal - meiaEntrada;\n                    printf(\"\\n troco: %g \\n\\n\", troco);\n                    \n                    printf(\"Compra comcluida com exito. \\n\");\n                    disponivelMeia = disponivelMeia - 1;\n                    capacidadeMax = capacidadeMax - 1;\n                    vendidoMeia++;\n                    break;\n                        \n                    }else{\n                        printf(\"\\n quantia insuficiente\");\n                        break;\n                    }   \n                                                \n                }else{\n                printf(\"Ingressos de meia entrada esgotados. \\n\");\n                break;\n                }\n            }\n        \n        case 3: \n                printf(\"\\nTotal de ingressos tipo inteira vendido: %d \\n\", vendidoInteira);\n                printf(\"Total de ingressos tipo meia vendido: %d \\n\", vendidoMeia);\n                printf(\"Ingressos disponiveis: %d \\n\", capacidadeMax);\n                            \n                break;\n                \n        default: \n            \n                printf(\"Opcao invalida.\");  \n            \n                break;\n            \n    }\n}\n\n}\n\n\n\n\n\n\n\n\n\n    \n    \n\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n    \nint contShow;\n\nstruct evento{\n    char nome[20];\n    float valorIngresso;\n    int cadeiras;\n    int disponiveis;\n    float lucro;\n    int meia;\n};\n\nstruct evento show[10];\n\n    \nvoid cadastrarEvento(struct evento show[])\n{   \n    printf(\"Informe o nome do evento:\\n\");\n    fflush(stdin);\n    gets(show[contShow].nome);\n    printf(\"Informe o valor do ingresso: \\n\");\n    scanf(\"%g\", &show[contShow].valorIngresso);\n    printf(\"Informe a quantidade de lugares disponiveis: \\n\");\n    scanf(\"%d\", &show[contShow].cadeiras);\n    show[contShow].disponiveis = show[contShow].cadeiras;\n    show[contShow].lucro = 0;\n    show[contShow].meia = 0;\n}\n\nvoid listarEventos(struct evento show[])\n{\n    int cont;\n    \n    for(cont = 0; cont < contShow; cont++)\n    {   \n        printf(\"Evento: %s\\n\", show[cont].nome);\n        printf(\"Valor da entrada: %g\\n\", show[cont].valorIngresso);\n        printf(\"Lugares disponiveis: %d\\n\", show[cont].disponiveis);\n        printf(\"Codigo: %d \\n\\n\\n\", cont);\n    }\n}\n\nfloat pagarDinheiroInt(int contSelec , float pagamento, struct evento show[])\n{\n    float troco;\n    \n    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9);\n    troco = pagamento - (show[contSelec].valorIngresso * 0.9);\n    show[contSelec].disponiveis--;\n    \n    return troco;\n}\n\nfloat pagarDinheiroMeia(int contSelec, float pagamento, struct evento show[])\n{\n    float troco;\n    \n    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9) \/ 2;\n    troco = pagamento - (show[contSelec].valorIngresso * 0.9) \/ 2;\n    show[contSelec].disponiveis--;\n    show[contSelec].meia++;\n    \n    return troco;\n}\n\nvoid pagarCartaoInt(int contSelec, struct evento show[])\n{\n    show[contSelec].lucro += show[contSelec].valorIngresso;\n    show[contSelec].disponiveis--;\n}\n\nvoid pagarCartaoMeia(int contSelec, struct evento show[])\n{\n    show[contSelec].lucro += show[contSelec].valorIngresso \/ 2;\n    show[contSelec].disponiveis--;\n    show[contSelec].meia++;\n}\n\nvoid informarDados(struct evento show[])\n{\n    int cont, vendidos;\n    \n    for(cont = 0; cont < contShow; cont++)\n    {\n        printf(\"Evento: %s \\n\", show[cont].nome);\n        printf(\"Total arrecadado: %g \\n\", show[cont].lucro);\n        vendidos = show[cont].cadeiras - show[cont].disponiveis;\n        printf(\"Ingressos totais vendidos: %d \\n\", vendidos);\n        printf(\"Ingressos de meia entrada vendidos: %d \\n\", show[cont].meia);\n        printf(\"Ingressos restantes: %d \\n\\n\\n\", show[cont].disponiveis);\n    }\n}\n\n\n    \nint main(int argc, char *argv[]) {\n\n    float pagamento, troco, restante;\n    int menu, contOpera, contSelec;\n    \n    \n    contSelec = 0;\n    contShow = 0;\n    contOpera = 0;\n\n    while(contOpera <= 0)\n    {\n\n        printf(\"Iniciando cadastro de eventos \\n\\n\");   \n        printf(\"Informe a opcao desejada:\\n\");\n        printf(\"Digite 1 para cadastrar um evento \\n\");\n        printf(\"Digite 2 iniciar vendas \\n\");\n    \n        scanf(\"%d\", &menu);\n        \n        switch(menu)\n        {\n            case 1:\n            {\n                cadastrarEvento(show);\n                contShow++;\n                system(\"cls\");\n                break;\n            }\n            case 2:\n            {\n                printf(\"Iniciando operacao de vendas\\n\");\n                contOpera++;\n                break;\n            }\n            default:\n            {\n                printf(\"Informe uma opcao valida\\n\");\n                break;\n            }       \n        }   \n        if(contShow >= 10)\n        {\n            printf(\"Limite de eventos atingido, prosseguindo para venda de ingressos.\\n\");\n            contOpera++;\n        }\n    }\n\n\n    while(contOpera <= 1)\n    {\n        do{\n        printf(\"Escolha o codigo do evento que deseja participar: \\n\");\n        listarEventos(show);\n        scanf(\"%d\", &contSelec);\n        if(show[contSelec].disponiveis <= 0)\n        {\n            printf(\"Ingressos para este evento estao esgotados, retornando para a selecao. \\n\");\n        }\n        }while(show[contSelec].disponiveis <= 0);\n        \n        printf(\"Informe a opcao desejada:\\n\");\n        printf(\"Digite 1 para comprar um ingresso inteiro. \\n\");\n        printf(\"Digite 2 para comprar meia entrada. \\n\");\n        printf(\"Digite 3 para mudar o evento selecionado. \\n\");\n        printf(\"Digite 4 para fechar as operacoes. \\n\");\n    \n        scanf(\"%d\", &menu);\n        \n        switch(menu)\n        {\n            case 1:\n            {\n                printf(\"Escolha a forma de pagamento: \\n\");\n                printf(\"Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\\n\");\n                scanf(\"%d\", &menu);\n                switch(menu)\n                {\n                    case 1:\n                    {\n                        printf(\"Valor a ser pago: %g\\n\", (show[contSelec].valorIngresso * 0.9));            \n                        printf(\"Informe o valor do pagamento: \");\n                        do\n                        {\n                            scanf(\"%g\", &pagamento);\n                            if(pagamento < (show[contSelec].valorIngresso * 0.9))\n                            {\n                                restante = (show[contSelec].valorIngresso * 0.9) - pagamento;\n                                printf(\"Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\\n\", restante);  \n                            }\n                        }while(pagamento < (show[contSelec].valorIngresso * 0.9));\n                        troco = pagarDinheiroInt(contSelec, pagamento, show);\n                        printf(\"Seu troco e de: %g\\n\", troco);                      \n                        break;\n                    }\n                    case 2:\n                    {\n                        pagarCartaoInt;\n                        break;\n                    }\n                }\n                system(\"cls\");\n                break;\n            }\n            \n            case 2:\n            {\n                if(show[contSelec].meia <= show[contSelec].cadeiras * 0.4)\n                {\n                \n                    printf(\"Escolha a forma de pagamento: \\n\");\n                    printf(\"Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\\n\");\n                    scanf(\"%d\", &menu);\n                    switch(menu)\n                    {\n                        case 1:\n                        {   \n                            printf(\"Valor a ser pago: %g\\n\", (show[contSelec].valorIngresso * 0.9 \/ 2) );           \n                            printf(\"Informe o valor do pagamento: \");\n                            do\n                            {\n                                scanf(\"%g\", &pagamento);\n                                if(pagamento < ((show[contSelec].valorIngresso * 0.9 \/ 2)))\n                                {\n                                    restante = ((show[contSelec].valorIngresso * 0.9 \/ 2) ) - pagamento;\n                                    printf(\"Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\\n\", restante);  \n                                }\n                            }while(pagamento < ((show[contSelec].valorIngresso * 0.9 \/ 2) ));\n                            troco = pagarDinheiroMeia(contSelec, pagamento, show);\n                            printf(\"Seu troco e de: %g \\n\", troco); \n                            break;\n                        }\n                        case 2:\n                        {\n                            pagarCartaoMeia;\n                            printf(\"O pagamento foi efetuado com sucesso.\\n\");\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    printf(\"Ingressos para este evento estao esgotados. \\n\");\n                }\n                system(\"cls\");\n                break;              \n            }\n            \n            case 3:\n            {\n                printf(\"Retornando para a selecao. \\n\");    \n                system(\"cls\");          \n                break;\n            }\n            case 4:\n            {\n                printf(\"Encerrando operacao de vendas. \\n\");\n                contOpera++;\n                break;\n            }\n            default:\n            {\n                printf(\"Informe uma opcao valida. \\n\");\n                break;\n            }\n        }\n    }\n    \n    printf(\"Operacao de vendas encerradas.\\n\");\n    informarDados(show);\n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n        int pontosJogador1=0, pontosComputador=0, pontosJogador2=0;\n        int jogador1, computador, jogador2;\n        int numeroPartidas=0, numeroPartidasJogador2=0, numeroPartidasComputador=0, empate=0;\n        int continuar=1, mododejogo;\n        float percJogador1=0, percJogador2=0, percComputador=0;\n        \n        while(continuar == 1) {\n            printf (\"-------\\n\");\n            printf (\"JOKENPO\\n\");\n            printf (\"-------\\n\\n\");\n            printf (\"Quem sera o seu oponente:\\n\"\n                    \"1. Computador\\n\"\n                    \"2. Jogador\\n\");\n            scanf(\"%d\", &mododejogo);\n            printf (\"\\n\");\n            numeroPartidas++;\n            switch (mododejogo)\n            {\n            case 1: printf (\"Jogador X Computador\\n\\n\");\n                    printf (\"1. Pedra\\n\");\n                    printf (\"2. Papel\\n\");\n                    printf (\"3. Tesoura\\n\");\n                    scanf (\"%d\", &jogador1);\n                    \n                   numeroPartidasComputador++;\n                   \n                    srand(time(NULL));\n                    computador = rand() % 3; \n                    \n                    computador++;   \n                        \n                    switch (computador)\n                    {\n                        case 1: printf (\"Computador --> Pedra\\n\");break;\n                        case 2: printf (\"Computador --> Papel\\n\");break;                        \n                        case 3: printf (\"Computador --> Tesoura\\n\");break;                  \n                    }\n                    \n                if ((jogador1 == 1 && computador==3) || (jogador1 == 2 && computador == 1) || (jogador1 == 3 && computador == 2)) \n                {\n                    printf(\"Voce venceu!\\n\\n\\n\");\n                    pontosJogador1++;\n                } else if (jogador1 == computador) \n                {\n                    printf (\"Empate!\\n\\n\\n\");\n                    empate++;\n                }\n                else\n                {\n                    printf (\"Computador venceu!\\n\\n\\n\");\n                    pontosComputador++;\n                }\n                printf(\"Continuar: \\n\\n1.Sim\\n2.Nao\\n\");\n                scanf(\"%d\", &continuar);\n                system(\"cls\");\n            break;\n            \n            case 2: printf (\"Jogador1 X Jogador2\\n\\n\");\n                    printf (\"1. Pedra\\n\");\n                    printf (\"2. Papel\\n\");\n                    printf (\"3. Tesoura\\n\");\n                    scanf (\"%d\", &jogador1);\n                    scanf (\"%d\", &jogador2);\n                    \n                    numeroPartidasJogador2++;\n                    switch (jogador1)\n                    {\n                        case 1: printf (\"Jogador1 --> Pedra\\n\");break;\n                        case 2: printf (\"Jogador1 --> Papel\\n\");break;\n                        case 3: printf (\"Jogador1 --> Tesoura\\n\");break;\n                    }\n                    switch (jogador2)\n                    {\n                        case 1: printf (\"Jogador2 --> Pedra\\n\");break;\n                        case 2: printf (\"Jogador2 --> Papel\\n\");break;\n                        case 3: printf (\"Jogador2 --> Tesoura\\n\");break;\n                    }\n                    \n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)) \n                        {\n                            printf(\"Jogador1 venceu!\\n\\n\");\n                            pontosJogador1++;\n                        } else if (jogador1 == jogador2) \n                        {\n                            printf (\"Empate!\\n\\n\");\n                            empate ++;\n                        }else\n                        {\n                            printf (\"Jogador2 venceu!\\n\\n\");\n                            pontosJogador2++;\n                        }\n                printf(\"Continuar: \\n\\n1.Sim\\n2.Nao\\n\");\n                scanf(\"%d\", &continuar);\n                system(\"cls\");\n            break;\n            }\n        }\n        percJogador1 = (pontosJogador1 * 100) \/ (numeroPartidas);\n        percJogador1 = percJogador1;\n        if(numeroPartidasJogador2 != 0)\n            percJogador2 = (pontosJogador2 * 100) \/ (numeroPartidasJogador2);\n        percComputador = (pontosComputador * 100) \/ (numeroPartidasComputador);\n        printf(\"Percentual Jogador1: %f\\n\", percJogador1);\n        printf(\"Percentual Computador: %f\\n\", percComputador);\n        printf(\"Percentual Jogador2: %f\\n\", percJogador2);\n        printf(\"Empate: %d\\n\", empate);\n        printf(\"Numero Partidas: %d\\n\", numeroPartidas);\n        printf(\"Pontos Jogador1: %d\\n\", pontosJogador1);\n        printf(\"Pontos Jogador2: %d\\n\", pontosJogador2);\n        printf(\"Pontos Computador: %d\\n\", pontosComputador);\n        \n        \n        return 0;\n    }\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(void) {\n    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;\n    int opcao, menu;\n    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;\n    \n    opcao = 1;\n    nVitoriasDois = 0;\n    nDerrotasUm = 0;\n    \n    printf(\"------------------------------------\\n-------------bem vindo!-------------\\n------------------------------------\\n\\n\");\n        \n    while(opcao != 3){\n    \n    printf(\"Selecione seu modo de jogo: \\n\\n\");\n    printf(\"1- PvC - Player vs Computer \\n\");\n    printf(\"2- PvP - Player vs Player \\n\");\n    printf(\"3- sair\\n\");\n    fflush(stdin);\n    scanf(\"%d\", &opcao);\n    \n    \n    \n    \n    switch(opcao){\n    \n    \n        case 1: \n        \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        \n        while(menu !=4){\n                 \n        \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           \n           srand(time(NULL));\n           jogadorDois = 1 + rand() %3;\n           printf(\"\\nOpcao jogadorDois = %d \", jogadorDois, (jogadorDois % 4));\n           \n           \nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n                \n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n                     \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n                           \n                            \n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                                \n                           \n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                                       \n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                                           \n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                                  \n                                                           \n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                                      \n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                    \n                                                  }else{\n                                                       printf(\"\\nJogada Invalida\\n\");\n                                                  } \n                                                            \n}}}}}}}}\n            \n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                   }else \n                   {\n                          pVitoriasUm = ( nVitoriasUm\/ nJogadas ) * 100;\n                   }\n                                if(nVitoriasDois == 0)\n                                {\n                                        pVitoriasDois = 0;\n                                        }else\n                                        {\n                                                pVitoriasDois = ( nVitoriasDois \/ nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");\n    }\n        break;\n           \n        case 2:  \n        \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        \n        while(opcao != 3){\n        \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           \n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorDois);\n           system(\"cls\");\n                   \nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n                \n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n                     \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n                           \n                            \n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                                \n                           \n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                                       \n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                                           \n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                                  \n                                                           \n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                                      \n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                    \n                                                        }else{\n                                                                 printf(\"\\nJogada Invalida\\n\");\n           \n                                                                                        \n}}}}}}}}}\n            \n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                 }\n                 else\n                     {\n                        pVitoriasUm = ( nVitoriasUm \/ nJogadas ) * 100;\n                     }\n                             if(nVitoriasDois == 0){\n                                    pVitoriasDois = 0;\n                                    }\n                                     else\n                                     {\n                                               pVitoriasDois = ( nVitoriasDois \/ nJogadas ) * 100;\n            }\n            \n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            \n                \n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");      \n        }\n\n           break;\n        case 3:\n           printf(\"Cansou de jogar? \\n\");\n           system(\"exit\");\n           \n           break;\n           \n        default:           \n            printf(\"opcao invalida\");\n            break;\n        }\n}\n\n    \n    if(menu == 2){\n        \n        printf(\"Voce saira do jogo!\");\n    }\n\n}\n\n\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define PEDRA 1\n#define PAPEL 2\n#define TESOURA 3\n#define LAGARTO 4\n#define SPOCK 5\n\nint main(int argc, char *argv[]) {\n    \n    int player1, player2, optP1, optP2;\n    int mainMenu, playerMenu, modeMenu, novojogo;\n    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;\n    float percentP1, percentP2;\n    \n    srand( time(NULL) );\n    totalJogadas=0;\n    totalNormal=0;\n    totalMelhor=0;\n    totalStartrek=0;\n    totalDeath=0;\n    empates=0;\n    vitoriasP1=0;\n    vitoriasP2=0;\n    especial=3;\n    \n    do {\n    \n        system(\"cls\");\n        printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n        \n        printf(\"\\n\\n\\tO que voce quer fazer?\\n\");\n        printf(\"\\t1 - Jogar\\n\");\n        printf(\"\\t2 - Ver Regras\\n\");\n        printf(\"\\t3 - Ver Estatisticas\\n\");\n        printf(\"\\t4 - Sair\\n\\t\");\n        \n        if (totalJogadas > especial ) {\n            printf(\"\\n\\t0 - ESPECIAL DEATHMATCH\\n\");\n        }\n        \n        scanf(\"%d\",&mainMenu);\n        \n        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){\n            printf(\"\\t-> Opcao invalida!\\n\");\n            printf(\"\\tO que voce quer fazer?\\n\\t\");\n            scanf(\"%d\",&mainMenu);\n        }\n        \n        system(\"cls\");\n        \n        if (mainMenu==1){\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tComo voce quer jogar?\\n\");\n                printf(\"\\t1 - Player VS Player\");\n                printf(\"\\n\\t2 - Player VS Computador\\n\\t\");\n                scanf(\"%d\",&playerMenu);\n                \n                while(playerMenu<1 || playerMenu>2){\n                    printf(\"\\t-> Opcao invalida!\\n\");\n                    printf(\"\\tComo voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&playerMenu);\n                }\n                \n                system(\"cls\");\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tMODO DE JOGO:\\n\");\n                printf(\"\\t1 - Normal\\n\");\n                printf(\"\\t2 - Melhor de 3\\n\");\n                printf(\"\\t3 - Startreck\\n\\t\");\n                scanf(\"%d\",&modeMenu);\n                \n                while(modeMenu<1 || modeMenu>3){\n                    printf(\"-> Opcao invalida!\\n\");\n                    printf(\"Como voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&modeMenu);\n                }\n                \n                system(\"cls\");\n                \n                if (modeMenu==1) {\n                    \n                    \n                    do {\n                        \n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>3 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        \n                        system(\"cls\");\n                        \n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        \n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        \n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                        \n                        }\n                        \n                        totalJogadas++;\n                        totalNormal++;\n                        \n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                }while(novojogo==1);\n                \n                }\n                else {\n            \n                    if (modeMenu==2) {\n                        \n                    do {\n                        \n                        tempVitP1=0;\n                        tempVitP2=0;\n                        \n                            do {\n                                system(\"cls\");\n                                printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            \n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            \n                            system(\"cls\");\n                            \n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n    \n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            \n                            if (playerMenu==1) {\n                                scanf(\"%d\",&optP2);\n                                while( optP2<1 || optP2>3 ){\n                                    printf(\"Opcao invalida. Digite novamente: \");\n                                    scanf(\"%d\",&optP2);\n                                }\n                            } else {\n                                optP2 = ( rand() % 2 ) + 1;\n                                printf(\"%d\",optP2);\n                            }\n                            \n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada!\\n\");\n                                    tempVitP2++;\n                                }\n                            }\n                            system(\"pause\");\n                        \n                    }while( tempVitP1<2 && tempVitP2<2 );\n                        \n                        totalJogadas++;\n                        totalMelhor++;\n                        \n                        system(\"cls\");\n                        if (tempVitP1 > tempVitP2) {\n                            printf(\"\\nPlayer 1 venceu a partida!\\n\");\n                            vitoriasP1++;\n                        } else {\n                            printf(\"\\nPlayer 2 venceu a partida!\\n\");\n                            vitoriasP2++;\n                        }\n                        \n                        system(\"pause\");\n                        system(\"cls\");\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                        \n                    } else {\n                        \n                        if (modeMenu==3) {\n                            \n                            do {\n\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>5 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        \n                        system(\"cls\");\n                        \n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        \n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        \n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>5 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 4 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        \n                        totalJogadas++;\n                        totalStartrek++;\n                        \n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if (\n                            \n                                (optP1==PEDRA&&optP2==TESOURA) ||\n                                (optP1==PEDRA&&optP2==LAGARTO) ||\n                                \n                                (optP1==LAGARTO&&optP2==PAPEL) ||\n                                (optP1==LAGARTO&&optP2==SPOCK) ||\n                                \n                                (optP1==SPOCK&&optP2==PEDRA) ||\n                                (optP1==SPOCK&&optP2==TESOURA) ||\n                                \n                                (optP1==TESOURA&&optP2==LAGARTO) ||\n                                (optP1==TESOURA&&optP2==PAPEL) ||\n                                \n                                (optP1==PAPEL&&optP2==PEDRA) ||\n                                (optP1==PAPEL&&optP2==SPOCK)\n                            \n                            ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                            \n                        }\n                        \n                    }\n            \n                }\n        \n        }\n        \n        else {\n            \n            if (mainMenu==2) {\n                \n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                \n                printf(\"\\n\\n\\tREGRAS:\\n\");\n                printf(\"\\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\\n\");\n                printf(\"\\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\\n\");\n                printf(\"\\t\\t- PEDRA ganha da TESOURA (quebrando-a).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do PAPEL (cortando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha da PEDRA (embrulhando-o).\\n\");\n                printf(\"\\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\\n\");\n                printf(\"\\t\\t- PEDRA ganha do LAGARTO (esmagando-o).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do LAGARTO (matando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha do SPOCK (cegando-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do PAPEL (comendo-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do SPOCK (envenenando-o).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da PEDRA (vaporizando-a).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da TESOURA (quebrando-a).\\n\\n\");\n                system(\"pause\");\n                \n            } else {\n                \n                if (mainMenu==3) {\n                    \n                    printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                    printf(\"\\n\\n\\tTotal de Jogadas: %d\\n\",totalJogadas);\n                    \n                    printf(\"\\t\\tEmpates: %d\\n\",empates);\n                    percentP1=(100.0*vitoriasP1)\/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 1: %d(%f%%)\\n\",vitoriasP1,percentP1);\n                    percentP2=(100.0*vitoriasP2)\/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 2: %d(%f%%)\\n\",vitoriasP2,percentP2);\n\n                    printf(\"\\tJogadas no Modo Normal: %d\\n\",totalNormal);\n                    printf(\"\\tJogadas no Modo Melhor de 3: %d\\n\",totalMelhor);\n                    printf(\"\\tJogadas no Modo Star Trek: %d\\n\",totalStartrek);\n                    system(\"pause\");\n                    \n                } else if (mainMenu==0) {\n                            \n                    do {\n                        \n                        tempVitP1=0;\n                        tempDeath=0;\n                        \n                            do {\n                                \n                            printf(\"\\tDEATMATCH\\n\");\n                            printf(\"\\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\\n\");\n                                \n                            system(\"cls\");\n                            printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            \n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            \n                            system(\"cls\");\n                            \n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n    \n                            system(\"pause\");\n                            printf(\"Numero: \");\n\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                            \n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1=1;\n                                    tempDeath++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada e encerrou a partida!\\n\");\n                                    tempVitP1=2;\n                                }\n                            }\n                            system(\"pause\");\n                        \n                    }while( tempVitP1==1 );\n                        \n                        totalJogadas++;\n                        totalDeath++;\n                        \n                        system(\"cls\");\n\n                            printf(\"\\nVoce ganhou: %d partidas!\\n\",tempDeath);\n                            vitoriasP1++;\n                        \n                        system(\"pause\");\n                        system(\"cls\");\n                        \n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                    \n                }\n                \n            }\n            \n        }\n    \n    }while(mainMenu>=1 && mainMenu<=3);\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n\nint main(void) {\n    \n    srand (time(NULL));\n    \n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    \n    \n    \n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    \n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    \n    while(jogarMais > 0){\n    \n        jogadaComputador = rand()%3+1;\n    \n        if(escolhaJogo == 1){ \n    \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        \n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n        \n            if(jogador1 >=1 && jogador1 <=3){ \n            \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                \n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n            \n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                \n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    \n                    pontosJogador1 = pontosJogador1 + 1;\n                \n                }\n                \n                if (jogador1 == jogadaComputador){ \n                    \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    \n                    empate++;\n                    \n                }\n                \n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                \n                    pontosComputador = pontosComputador + 1;\n                \n            }\n        } else { \n            \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n        }\n        \n        }\n        \n        if(escolhaJogo == 2){  \n            \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        \n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            \n            if(jogador1 >= 1 && jogador1 <= 3){\n            \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                \n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                \n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                \n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    \n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                \n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    \n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    \n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    \n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        \n                        pontosJogador1 = pontosJogador1 + 1;\n                \n                    }\n                \n                    if (jogador1 == jogador2){ \n                    \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        \n                        empate++;\n                    \n                    }\n                \n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        \n                        pontosJogador2 = pontosJogador2 + 1;\n                \n                    }\n            \n                } else { \n            \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n                }\n        \n            } else { \n            \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            \n            }\n    \n        }\n        \n        if(escolhaJogo > 2){  \n            \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n            \n        }\n\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        \n        if(jogarNovamente == 1){ \n            \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            \n        }\n\n        if(jogarNovamente == 2){ \n            \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            \n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            \n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            \n            if(pontosJogador2 > 0){\n                \n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 \/ (float)totalJogadas) * 100;\n                \n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            \n            }\n            \n            if(pontosComputador > 0){\n                \n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador \/ (float)totalJogadas) * 100;\n                \n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n                \n            }\n            \n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                \n                if(escolhaJogo == 1){\n                    \n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                    \n                }\n                \n                if(escolhaJogo == 2){\n                    \n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                    \n                }\n                \n                if(empate > 0){\n                    \n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                        \n                }\n                \n                porcentagemJogador1 = ((float)pontosJogador1 \/ (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n                \n            }\n            \n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            \n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            \n            if(jogarNovamente2 == 1){ \n                \n                for( linha = 0; linha < 35; linha++){ \n                \n                    printf( \"\\n\" );\n                    \n                }\n                \n            }\n            \n            if(jogarNovamente2 == 2){ \n                \n                exit(0);\n                \n            }\n            \n            if(jogarNovamente2 >= 3){\n                \n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n                \n            }\n            \n        }\n        \n        if(jogarNovamente == 3){\n        \n            exit(0);\n            \n        }\n        \n        if(jogarNovamente >= 4){\n            \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n            \n        }\n         \n    }\n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n\n\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n\n\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n\n\n                                }\n\n\n                            }\n\n                        }\n                    }\n                }\n\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n\n            porcentvitP1=(vitoriasP1*100)\/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)\/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n\n\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n\n\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n\n\n                                }\n\n\n                            }\n\n                        }\n                    }\n                }\n\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n\n            porcentvitP1=(vitoriasP1*100)\/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)\/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n\n    system(\"pause\");\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) \n{\n    int modoJogo, jogada1, jogada2, partidas, empates, vencimento1, vencimento2, jogarNovamente, aleatorio, totalPartidas; \n    float vitorias1, vitorias2;\n    \n    empates=0;\n    partidas=0;\n    vencimento1=0;\n    vencimento2=0;\n    jogarNovamente=1; \n    \n    printf (\"*************************\\n | Vamos Jogar Jokempo!| \\n*************************\\n \\nPara iniciar, escolha o modo de jogo: \\n 1- Para Jogar com outra pessoa \\n 2- Para jogar com o computador \\n \");\n    scanf (\"%d\" , &modoJogo);\n    \n    while (modoJogo<1 || modoJogo>2)\n                {\n                    printf(\"Modo de Jogo Invalido! Tente novamnete:\");\n                    scanf(\"%d\" , &modoJogo);\n                }\n                \n    switch (modoJogo)\n    {\n        \n        case 1 :   \n            \n            printf (\"\\n Modo de Jogo 1 \\n\");\n            \n            while ( jogarNovamente == 1)\n            {\n                \n                 printf (\"\\n \\n  Escolhas: \\n 1- Para Pedra \\n 2- Para Papel \\n 3- Para Tesoura \\n \");\n              \n                 printf (\"\\n \\n Vez do Jogador 1:\");\n                 scanf (\"%d\" , &jogada1);\n                 \n                    while (jogada1>3 || jogada1<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada1);\n                }\n                \n                 printf (\"\\n \\n Vez do Jogador 2:\");\n                 scanf (\"%d\" , &jogada2);\n                 \n                 while (jogada2>3 || jogada2<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada2);\n                }\n                 \n                    if ( jogada1 == 1 && jogada2 == 2 )\n                    {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 2\");\n                       partidas++;\n                       vencimento2++;\n                       \n                    }else{\n                        \n                        if ( jogada1 == 2 && jogada2 == 1 )\n                        {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 1\");\n                       partidas++; \n                       vencimento1++;           \n                       \n                        }else{\n                            \n                            if ( jogada1 == 1 && jogada2 == 3 )\n                            {\n                             printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 1\");\n                             partidas++;\n                             vencimento1++;\n                             \n                            }else{\n                                \n                                if ( jogada1 == 3 && jogada2 == 1 )\n                                \n                                {\n                                 printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 2\");\n                                 partidas++;\n                                 vencimento2++;\n                                 \n                                }else{\n                                    \n                                    if ( jogada1 == 3 && jogada2 == 2)\n                                    {\n                                     printf (\" \\n RESULTADO: Tesoura ganha do papel, Gahador: Jogador 1\");\n                                     partidas++;\n                                     vencimento1++;\n                                        \n                                    }else{\n                                        \n                                        if ( jogada1 == 2 && jogada2 == 3 )\n                                        {\n                                         printf(\"\\n RESULTADO: Tesoura ganha do papel, Ganhador: Jogador 2\");\n                                         partidas++;\n                                         vencimento2++;\n                                            \n                                        }else{\n                                            \n                                            printf (\"\\n Houve Empate!\");\n                                            empates++;\n                                            \n                                            \n                                            }\n                                        \n                                        }\n                                     }\n                                }\n                            }\n                        }\n                        \n                printf(\"\\n \\n Para jogar novamente digite = 1 ou sair digite = 2 : \");\n                scanf(\"%d\" , &jogarNovamente );\n                \n                while (jogarNovamente<1 || jogarNovamente>2)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogarNovamente);\n                }\n                \n            } \n            \n        totalPartidas=partidas+empates;\n        vitorias1=(100*vencimento1)\/partidas;\n        vitorias2=(100*vencimento2)\/partidas;\n    \n        printf(\" \\n ==============\\n |ESTATISTICAS| \\n ==============\\n Quantidade de Partidas: %d | Quantidade de Empates: %d\" , totalPartidas , empates) ;\n        printf(\"\\n Percentual de Vitotias Jogador 1: %f  \\n Percentual de Votorias Jogador 2: %f \" , vitorias1 , vitorias2);\n    \n                      \n                        \n                 break;\n        \n     \n            \n        case 2 : \n          \n          printf (\"\\n Modo de Jogo 2 \\n\");\n            \n            while ( jogarNovamente == 1)\n            {\n                \n                 printf (\"\\n \\n  Escolhas: \\n 1- Para Pedra \\n 2- Para Papel \\n 3- Para Tesoura \\n \");\n              \n                 printf (\"\\n \\n Vez do Jogador :\");\n                 scanf (\"%d\" , &jogada1);\n                 \n                    while (jogada1>3 || jogada1<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada1);\n                }\n                \n                 srand(time(NULL));\n                 printf (\"\\n \\n Vez do Computador:\" , rand() % 3);\n                 jogada2 = (rand() % 3) +1;\n                 printf(\"%d\" , jogada2);\n                 \n                    if ( jogada1 == 1 && jogada2 == 2 )\n                    {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Computador\");\n                       partidas++;\n                       vencimento2++;\n                       \n                    }else{\n                        \n                        if ( jogada1 == 2 && jogada2 == 1 )\n                        {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador \");\n                       partidas++; \n                       vencimento1++;           \n                       \n                        }else{\n                            \n                            if ( jogada1 == 1 && jogada2 == 3 )\n                            {\n                             printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador \");\n                             partidas++;\n                             vencimento1++;\n                             \n                            }else{\n                                \n                                if ( jogada1 == 3 && jogada2 == 1 )\n                                \n                                {\n                                 printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Computador\");\n                                 partidas++;\n                                 vencimento2++;\n                                 \n                                }else{\n                                    \n                                    if ( jogada1 == 3 && jogada2 == 2)\n                                    {\n                                     printf (\" \\n RESULTADO: Tesoura ganha do papel, Gahador: Jogador \");\n                                     partidas++;\n                                     vencimento1++;\n                                        \n                                    }else{\n                                        \n                                        if ( jogada1 == 2 && jogada2 == 3 )\n                                        {\n                                         printf(\"\\n RESULTADO: Tesoura ganha do papel, Ganhador: Computador\");\n                                         partidas++;\n                                         vencimento2++;\n                                            \n                                        }else{\n                                            \n                                            printf (\"\\n Houve Empate!\");\n                                            empates++;\n                                            \n                                            \n                                            }\n                                        \n                                        }\n                                     }\n                                }\n                            }\n                        }\n                        \n                printf(\"\\n \\n Para jogar novamente digite = 1 ou sair digite = 2 : \");\n                scanf(\"%d\" , &jogarNovamente );\n                \n                while (jogarNovamente<1 || jogarNovamente>2)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogarNovamente);\n                }\n                \n            } \n            \n        totalPartidas=partidas+empates; \n        vitorias1=(100*vencimento1)\/partidas;\n        vitorias2=(100*vencimento2)\/partidas;\n    \n        printf(\" \\n ==============\\n |ESTATISTICAS| \\n ==============\\n Quantidade de Partidas: %d | Quantidade de Empates: %d\" , totalPartidas , empates) ;\n        printf(\"\\n Percentual de Vitotias do Jogador: %f  \\n Percentual de Votorias do Computador: %f \" , vitorias1 , vitorias2);\n                \n        break;\n        \n    }\n    \n\n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) \n{\n    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;\n    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;\n    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;\n    \n    while(1)\n    {\n        system(\"cls\");\n        printf(\"Jogo Jokenpo\\n\\n\");\n        printf(\"(1) humano x computador\\n\");\n        printf(\"(2) humano x humano\\n\");\n        printf(\"(3) resultado\\n\");\n        printf(\"(4) sair\\n\\n\");\n        printf(\"Escolha uma das opcoes acima: \");\n        scanf(\"%d\", &opcao);\n        \n            \n        if(opcao == 1)\n        {\n            numeroDePartidas++;\n            printf(\"\\n(1) = pedra\\n\");\n            printf(\"(2) = papel\\n\");\n            printf(\"(3) = tesoura\\n\");\n            \n            printf(\"\\nopcao de jogada humano: \");\n            scanf(\"%d\", &opcaoDeJogadaHumano);\n            \n            opcaoDeJogadaComputador = rand()%3;\n            printf(\"opcao de jogada computador: %d\\n\\n\", opcaoDeJogadaComputador);\n            \n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            system(\"pause\");\n        }\n        else\n        {\n            if(opcao == 2)\n            {\n                numeroDePartidas++;\n                printf(\"\\n1 = pedra\\n\");\n                printf(\"2 = papel\\n\");\n                printf(\"3 = tesoura\\n\");\n                \n                printf(\"\\nopcao de jogada humano 1: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano1);\n            \n                printf(\"\\nopcao de jogada humano 2: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano2);\n                \n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                system(\"pause\");\n            }\n            else\n            {\n                if(opcao == 3)\n                {\n                    printf(\"\\nNumero de partidas: %d\\n\", numeroDePartidas);\n                    printf(\"Numero de vitorias humano: %d\\n\", numeroDeVitoriasHumano);\n                    printf(\"Numero de vitorias computador: %d\\n\", numeroDeVitoriasComputador);\n                    printf(\"Numero de vitorias humano 1: %d\\n\", numeroDeVitoriasHumano1);\n                    printf(\"Numero de vitorias humano 2: %d\\n\", numeroDeVitoriasHumano2);\n                    printf(\"Numero de empates: %d\\n\\n\", numeroDeEmpates);\n                    system(\"pause\");\n                }\n                else\n                {\n                    if(opcao == 4)\n                    {\n                        exit(0);\n                    }\n                    else\n                    {\n                        printf(\"\\nopcao invalida\\n\\n\");\n                    }\n                    system(\"pause\");\n                }\n            }\n                \n        }\n    \n    }\n    \n    \n    \n    \n    \n    return 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n\nint main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    \n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S\/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S\/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 \/ (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 \/ (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 \/ (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador \/ (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}\n"}
{"target":"davibernardos","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    \n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    \n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    \n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    \n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    \n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) \/ partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) \/ partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) \/ partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) \/ partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nvoid FileCopy(char *src,char *dest)\n{\n    int fdscr = 0, fddest = 0, ret = 0, i = 1;\n    char Mug[100] = {'\\0'};\n    \n    fdscr = open(src,O_RDONLY);\n    if(fdscr == -1)\n    {\n        printf(\"Unable to open source file\\n\");\n        return;\n    }\n    fddest = open(dest, O_RDWR | O_CREAT, 0777);\n    if(fddest == -1)\n    {\n        printf(\"Unable to open destination file\\n\");\n        close(fdscr);\n        return;\n    }\n    \n    while((ret = read(fdscr,Mug,sizeof(Mug))) != 0)\n    {\n        printf(\"Iteration : %d Size Read : %d\\n\", i, ret);\n        i++;\n        write(fddest, Mug,ret);\n    }\n    \n    close(fdscr);\n    close(fddest);\n}\n\nint main()\n{\n    char name1[20];\n    char name2[20];\n    \n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    \n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    \n    FileCopy(name1,name2);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nvoid FileCopyAppend(char *src,char *dest)\n{\n    int fdscr = 0, fddest = 0, ret = 0, i = 1;\n    char Mug[100] = {'\\0'};\n    \n    fdscr = open(src,O_RDONLY);\n    if(fdscr == -1)\n    {\n        printf(\"Unable to open source file\\n\");\n        return;\n    }\n    fddest = open(dest, O_WRONLY | O_APPEND);\n    if(fddest == -1)\n    {\n        printf(\"Unable to open destination file\\n\");\n        close(fdscr);\n        return;\n    }\n    \n    while((ret = read(fdscr,Mug,sizeof(Mug))) != 0)\n    {\n        printf(\"Iteration : %d Size Read : %d\\n\", i, ret);\n        i++;\n        write(fddest, Mug,ret);\n    }\n    \n    close(fdscr);\n    close(fddest);\n}\n\nint main()\n{\n    char name1[20];\n    char name2[20];\n    \n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    \n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    \n    FileCopyAppend(name1,name2);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint FileCapitalCount(char *name)\n{\n    int fd = 0, ret = 0,iCnt = 0, i = 0;\n    char Mug[100];\n    \n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return -1;\n    }\n    \n    while((ret = read(fd,Mug,sizeof(Mug))) != 0)\n    {\n        for(i = 0; i<ret; i++)\n        {\n            if((Mug[i] >= 'A') && (Mug[i] <= 'Z'))\n            {\n                iCnt++;\n            }\n        }\n    }\n    \n    close(fd);\n \n    return iCnt;\n}\n\nint main()\n{\n    char name[20];\n \n    int ret = 0;\n    \n    printf(\"Enter file name\\n\");\n \n    scanf(\"%s\",name);\n    \n   ret = FileCapitalCount(name);\n    \n    printf(\"Number of capital characters are : %d\\n\",ret);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nstruct student\n{\n    int Rollno;\n    char Name[20];\n    int Marks;\n};\n\nvoid FileWrite(char *name)\n{\n    int fd = 0, ret = 0, size = 0, i = 0;\n    struct student sobj;\n    \n    fd = open(name,O_WRONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return ;\n    }\n    printf(\"Enter number of students\");\n    scanf(\"%d\",&size);\n    \n    for(i = 1; i <= size; i++)      \n    {\n        printf(\"Enter roll number\\n\");\n        scanf(\"%d\",&sobj.Rollno);\n        printf(\"Enter Name of student\\n\");\n        scanf(\"%s\",&sobj.Name);\n        printf(\"Enter marks\\n\");\n        scanf(\"%d\",&sobj.Marks);\n        \n        write(fd,&sobj,sizeof(sobj));   \n    }\n    close(fd);\n}\n\nvoid FileRead(char *name)\n{\n    int fd = 0, ret = 0, size = 0, i = 0;\n    struct student sobj;\n    \n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return ;\n    }\n    \n    printf(\"Data from file is : \\n\");\n    \n    while((ret = read(fd,&sobj,sizeof(sobj)))!= 0)\n    {\n        printf(\"Roll number is : %d\\n\",sobj.Rollno);\n        printf(\"Name of student : %s\\n\",sobj.Name);\n        printf(\"Marks : %d\\n\",sobj.Marks);\n    }\n    \n    close(fd);\n}\n\n\nint main()\n{\n    char name[20];\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n   FileWrite(name);\n    \n    FileRead(name);\n    \n    return 0;\n}\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint FileSize(char *name)\n{\n    int fd = 0, ret = 0;\n\n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return -1;\n    }\n    \n    ret = lseek(fd,0,SEEK_END); \n    \n    close(fd);\n\n    return ret;\n}\n\nint main()\n{\n    char name[20];\n    int ret = 0;\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n   ret = FileSize(name);\n    \n    printf(\"File size is : %d\\n\",ret);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nvoid FileRead(char *name, int position)\n{\n    int fd = 0, ret = 0;\n    char Mug[10] = {'\\0'};\n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return;\n    }\n    \n    ret = lseek(fd,position,SEEK_SET);\n    printf(\"Return value of lseek : %d\\n\",ret);\n    \n    ret = read(fd,Mug,10);\n    printf(\"Data from the file is : \\n\");\n    \n    printf(\"Return value of read : %d\\n\",ret);\n    write(1,Mug,ret);\n    \n    printf(\"\\n\");\n    close(fd);\n}\nint main()\n{\n    char name[20];\n    int value = 0;\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&value);\n    \n    FileRead(name,value);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<string.h>\n\nint main()\n{\n    char name[20] = {'\\0'};\n    char arr[50] = {'\\0'};\n    int fd = 0;     \n    int ret = 0, length = 0;\n    char temp;\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n    fd = open(name,O_RDWR); \n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n    }\n    else\n    {\n        printf(\"File succesfully opened with fd %d\\n\",fd);\n    }\n    \n    ret = read(fd,arr,10);\n    if(ret == -1)\n    {\n        printf(\"Unable to read from the file\\n\");\n    }\n    else\n    {\n        printf(\"Data succesfully read\\n\");\n    }\n    printf(\"Data from file is : %s\\n\",arr);\n    \n    close(fd);\n    return 0;\n}\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<string.h>\n\n\nvoid DisplayWholeFile(char FName[])\n{\n    int fd = 0;\n    char arr[100] = {'\\0'};\n    int ret = 0;\n    \n    \n    fd = open(FName, O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return;\n    }\n    printf(\"Data from the file is : \\n\");\n    \n    \n    \n    while((ret = read(fd,arr,100)) != 0)     \n    {\n        \n        write(1,arr,ret);  \n    }\n    close(fd);\n}\n\nint main()\n{\n    char name[50] = {'\\0'};\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n    DisplayWholeFile(name);\n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<string.h>\n\nint main()\n{\n    char name[20] = {'\\0'};\n    char arr[50] = {'\\0'};\n    int fd = 0;     \n    int ret = 0, length = 0;\n    char temp;\n    \n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    \n    fd = open(name,O_RDWR | O_CREAT, 0777); \n    if(fd == -1)\n    {\n        printf(\"Unable to create file\\n\");\n    }\n    else\n    {\n        printf(\"File succesfully created with fd %d\\n\",fd);\n    }\n    printf(\"Enter the data that you want to write in the file\\n\");\n    scanf(\" %[^'\\n']s\",arr);\n    length = strlen(arr);\n    \n    ret = write(fd,arr,length);\n    if(ret == -1)\n    {\n        printf(\"Unable to write in the file\\n\");\n    }\n    else\n    {\n        printf(\"Data succesfully written in the file %d\\n\",ret);\n    }\n    \n    close(fd);\n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\nvoid DisplayBinary(int iValue)\n{\n    int iRem = 0;\n \n    if(iValue < 0)\n    {\n        iValue = -iValue;\n    }\n    \n    while(iValue != 0)\n    {\n        iRem = iValue % 2;\n \n    iValue = iValue \/ 2;\n \n    printf(\"%d\",iRem);\n    }\n}\nint main()\n{\n    int iNo = 0;\n    \n    printf(\"Enter number\\n\");\n \n    scanf(\"%d\",&iNo);\n        \n    DisplayBinary(iNo);\n    \n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n#include<stdio.h>\ntypedef int BOOL;\n# define TRUE 1\n#define FALSE 0\n\nBOOL CheckBit(int iNo)\n{\n    int iMask = 0X00800000;\n    \n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    \n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\nint main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    \n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n        \n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"Fourth bit is on\\n\");\n    }\n    else\n    {\n        printf(\"Fourth bit is Off\\n\");\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n#include<stdio.h>\n\ntypedef int BOOL;\n\n# define TRUE 1\n\n#define FALSE 0\n\nBOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000E00;\n    \n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    \n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\nint main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    \n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n        \n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"6th,7th and 12th bit is on\\n\");\n    }\n    else\n    {\n        printf(\"One of the bit or all bits are Off\\n\");\n    }\n    return 0;\n}\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n#include<stdio.h>\n\ntypedef int BOOL;\n\n# define TRUE 1\n\n#define FALSE 0\n\nBOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000860;\n    \n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    \n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\nint main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    \n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n        \n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"10th,11th and 12th bit is on\\n\");\n    }\n    else\n    {\n        printf(\"One of the bit or all bits are Off\\n\");\n    }\n    return 0;\n}\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint DigitCount(char *str)\n{\n    int iCnt = 0;\n    \n    if(str == NULL)\n    {\n        return -1;\n    }\n    \n    while(*str != '\\0')\n    {\n        if((*str >= '0') && (*str <= '9'))\n        {\n            iCnt++;\n        }\n        str++;\n    }\n        \n    return iCnt;\n}\n\nint main()\n{\n    char arr[30] = {'\\0'};\n    \n    int iRet = 0;\n    \n    printf(\"Please enter string\\n\");\n    \n    scanf(\"%[^'\\n']s\",arr);\n    \n    iRet = DigitCount(arr);\n    \n    printf(\"Number of digits are %d\\n\",iRet);\n    \n    return 0;\n}\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint CountOne(int iValue)\n{\n    int iRem = 0;\n\n    int iCnt = 0;\n\n    if(iValue < 0)\n    {\n        iValue = -iValue;\n    }\n    \n    while(iValue != 0)\n    {\n        iRem = iValue % 2;\n\n    if(iRem == 1)\n        {\n            iCnt++;\n        }\n        iValue = iValue \/ 2;\n    }\n    return iCnt;\n}\nint main()\n{\n    int iNo = 0;\n\n    int iRet = 0;\n    \n    printf(\"Enter number\\n\");\n\n    scanf(\"%d\",&iNo);\n        \n    iRet = CountOne(iNo);\n    \n    printf(\"Number of 1's in the numer is : %d\\n\",iRet);\n    \n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint CountVowels(char str[])\n{\n    int iCnt = 0, i = 0;\n    \n    if(str == NULL)\n    {\n        return -1;\n    }\n    \n    while(str[i] != '\\0')\n    {\n        if(\n           (str[i] == 'a') || (str[i] == 'A') || (str[i] == 'e') || (str[i] == 'E') || (str[i] == 'i') || (str[i] == 'I') || (str[i] == 'o')||(str[i] == 'O') || (str[i] == 'u')||(str[i] == 'U') )\n        {\n            iCnt++;\n        }\n        i++;\n    }\n    \n    return iCnt;\n}\n\nint main()\n{\n    char arr[30];\n    int iRet = 0;\n    \n    printf(\"Please enter the string\\n\");\n \n    scanf(\"%[^'\\n']s\",arr);\n    \n    iRet = CountVowels(arr);\n    \n    printf(\"Total number vowels are %d\\n\",iRet);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n#include<stdio.h>\n\nint SumI(int iNo)\n{\n    int iSum = 0;\n   \n    while(iNo != 0)\n   \n    {\n   \n            iSum = iSum + (iNo % 10);\n       \n        iNo = iNo \/ 10;\n    }\n    return iSum;\n}\n\nint SumR(int iNo)\n{\n    static int iSum = 0;\n \n    if(iNo != 0)\n \n    {\n \n            iSum = iSum + (iNo % 10);\n     \n        iNo = iNo \/ 10;\n        \n        SumR(iNo);\n    }\n    return iSum;\n}\n\nint main()\n{\n    int no = 0, iRet = 0;\n\n    printf(\"Enter first number\\n\");\n \n    scanf(\"%d\",&no);\n \n    iRet = SumR(no);\n \n    printf(\"Result is %d\",iRet);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct Employee\n{\n    int Eno;\n    char EName[20];\n    struct Employee *next;\n}NODE, *PNODE,**PPNODE;\n\nvoid InsertFirst(PPNODE Head)\n{\n    PNODE newn = (PNODE)malloc(sizeof(NODE));\n    printf(\"Enter employee ID\\n\");\n    scanf(\"%d\",&(newn->Eno));\n    \n    printf(\"Enter name\\n\");\n    scanf(\" %[^'\\n']s\",newn->EName);\n    \n    if(*Head == NULL)\n    {\n        *Head = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n}\n\nvoid Display(PNODE Head)\n{\n    while(Head != NULL)\n    {\n        printf(\"Emplyee number : %d\\t Name : %s\\n\",Head->Eno, Head->EName);\n        Head = Head->next;\n    }\n}\n\nint main()\n{\n    PNODE First = NULL;\n    \n    InsertFirst(&First);\n        InsertFirst(&First);\n        InsertFirst(&First);\n    \n    printf(\"Information of Employess\\n\");\n    \n    Display(First);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint SearchFirstOcc(char str[], char ch)\n{\n    int i = 0;\n    \n    if((str == NULL) || (ch == '\\0'))\n    {\n        return -1;\n    }\n    \n    while(str[i] != '\\0')\n    {\n            if(str[i] == ch)\n            {\n                break;\n            }\n        i++;\n    }\n    \n    if(str[i] == ch)        \n    {\n        return i;\n    }\n    else                        \n    {\n        return -1;\n    }\n\n}\n\n\n\n\n\nint main()\n{\n    char arr[30];\n\n    char cValue = '\\0';\n    \n    int iRet = 0;\n    \n    printf(\"Please enter the string\\n\");\n\n    scanf(\"%[^'\\n']s\",arr);\n        \n    printf(\"Please enter the character\\n\");\n\n    scanf(\" %c\",&cValue);\n    \n    iRet = SearchFirstOcc(arr,cValue);\n    \n    if(iRet == -1)\n    {\n        printf(\"There is no such character\\n\");\n    }\n    else\n    {\n        printf(\"First occurance of character at : %d\\n\",iRet);\n    }\n    \n    return 0;\n}\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint Frequency(char str[], char ch)\n{\n    int iCnt = 0, i = 0;\n    \n    if(str == NULL)\n    {\n        return -1;\n    }\n    \n    \n    while(str[i] != '\\0')\n    {\n        if(str[i] == ch)\n        {\n            iCnt++;\n        }\n        i++;\n    }\n    \n    \n    for(i = 0; str[i] != '\\0'; i++)\n    {\n        if(str[i] == ch)\n        {\n            iCnt++;\n        }\n    }\n    \n    while(*str != '\\0')\n    {\n        if(*str == ch)\n        {\n            iCnt++;\n        }\n        str++;\n    }\n    \n    \n    return iCnt;\n}\n\nint main()\n{\n    char arr[30];\n    char cValue = '\\0';\n    \n    int iRet = 0;\n    \n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    \n    \n    \n    printf(\"Please enter the character to calculate the frequency\\n\");\n    scanf(\" %c\",&cValue);       \n    \n    iRet = Frequency(arr,cValue);\n    \n    printf(\"Total Frequency is %d\\n\",iRet);\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nvoid DisplayS()     \n{\n    printf(\"Hello\\n\");\n    printf(\"Hello\\n\");\n    printf(\"Hello\\n\");\n    printf(\"Hello\\n\");\n}\n\nvoid DisplayI()                \n{\n    int i = 0;\n    \n    for(i = 1; i<=4;i++)\n    {\n        printf(\"Hello\\n\");      \n    }\n}\n\nvoid DisplayR()\n{\n    static int i = 1;\n    \n    if(i<=4)\n    {\n        printf(\"Hello\\n\");\n        i++;\n        DisplayR();\n    }\n}\n\nint main()\n{\n    int value = 10;\n    \n    DisplayR();\n    \n    printf(\"End of main\");\n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\nint FormIp(int no1,int no2,int no3,int no4)\n{\n\n    int ret=0;\n\n    no1=no1 & 0x000000ff;\n\n    no2=no2 & 0x000000ff;\n\n    no3=no3 & 0x000000ff;\n\n    no4=no4 & 0x000000ff;\n\n\n    no1=no1<<24;\n\n    no2=no2<<16;\n\n    no3=no3<<8;\n\n    ret= no1 | no2 | no3 |no4;\n\n\n    return ret;\n}\n\nvoid split(int no)\n{\n    int a,b,c,d;\n\n    a=no & 0xff000000;\n\n    b=no & 0x00ff0000;\n\n    c=no & 0x0000ff00;\n\n    d=no & 0x000000ff;\n\n    a = a>>24;\n\n    b=b>>16;\n\n    c=c>>8;\n\n    \n    \n    printf(\"\\nfirt number is : %d\\n\",a);\n    \n    printf(\"second number is :%d\\n\",b);\n\n    printf(\"third number is :%d\\n\",c);\n\n    printf(\"fourt number is :%d\\n\",d);\n\n\n\n}\nint main()\n{\n    int iRet=0;\n    int a=0,b=0,c=0,d=0;\n    printf(\"enter ip addres\\n\");\n    printf(\"first value :\");\n    scanf(\"%d\",&a);\n    \n    printf(\"second value :\");\n        scanf(\"%d\",&b);\n\n    printf(\"third value :\");\n        scanf(\"%d\",&c);\n\n    printf(\"fourth value :\");\n        scanf(\"%d\",&d);\n\n\n    iRet=FormIp(a,b,c,d);\n\n    printf(\"IP address  in one integer  is : %d\",iRet);\n\n    split(iRet);\n\n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint SearchLastOcc(char str[], char ch)\n{\n    int i = 0;\n    int iPos = -1;\n\n    if((str == NULL) || (ch == '\\0'))\n    {\n        return -1;\n    }\n    \n    while(str[i] != '\\0')\n    {\n        if(str[i] == ch)\n        {\n            iPos = i;\n        }\n        i++;\n    }\n    \n    return iPos;\n}\n\nint main()\n{\n    char arr[30];\n\n    char cValue = '\\0';\n    \n    int iRet = 0;\n    \n    printf(\"Please enter the string\\n\");\n\n    scanf(\"%[^'\\n']s\",arr);\n        \n    printf(\"Please enter the character\\n\");\n\n    scanf(\" %c\",&cValue);\n    \n    iRet = SearchLastOcc(arr,cValue);\n    \n    if(iRet == -1)\n    {\n        printf(\"There is no such character\\n\");\n    }\n    else\n    {\n        printf(\"Last occurance of character at : %d\\n\",iRet);\n    }\n    \n    return 0;\n}\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node     \n{\n    int data;\n    struct Node * next;\n};\n\ntypedef struct Node NODE;\ntypedef struct Node * PNODE;\ntypedef struct Node ** PPNODE;\n\n\n\n\n\n\n\n\n\n\n\n\nvoid InsertFirst(PPNODE Head, int no)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE)); \n    newn-> data = no;   \n    newn-> next = NULL; \n    \n    if(*Head == NULL) \n    {\n        *Head = newn;\n    }\n    else  \n    {\n        newn -> next = *Head;\n        *Head = newn;\n    }\n}\n\n\n\n\n\n\n\n\n\n\nvoid InsertLast(PPNODE Head, int no)\n{\n    PNODE newn = NULL;\n    PNODE temp = *Head;\n    \n    newn = (PNODE)malloc(sizeof(NODE)); \n    newn-> data = no;   \n    newn-> next = NULL; \n    \n    if(*Head == NULL) \n    {\n        *Head = newn;\n    }\n    else  \n    {\n            while(temp->next != NULL)\n            {\n                temp = temp->next;\n            }\n        temp -> next = newn;\n    }\n}\n\n\n\n\n\n\n\n\n\n\nvoid Display(PNODE Head)\n{\n    while(Head != NULL)\n    {\n        printf(\"%d\\t\",Head->data);\n        Head = Head -> next;\n    }\n}\n\n\n\n\n\n\n\n\n\n\nint Count(PNODE Head)           \n{\n    int iCnt = 0;\n    \n    while(Head != NULL)\n    {\n        iCnt++;                                        \n        Head = Head -> next;\n    }\n    \n    return iCnt;\n}\n\nint main()\n{\n    int iRet = 0;\n    \n    PNODE First = NULL;     \n    InsertFirst(&First, 51);    \n    InsertFirst(&First, 21);    \n    InsertFirst(&First, 11);    \n    \n    Display(First);                 \n    \n    iRet = Count(First);\n    \n    printf(\"\\nNumber of elements are %d : \\n\",iRet);\n    \n    InsertLast(&First,101);\n        InsertLast(&First,111);\n    \n    Display(First);\n    return 0;\n}\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\ntypedef int BOOL;\n# define TRUE 1\n#define FALSE 0\n\nBOOL CheckBit(int iNo, int iPos)\n{\n    int iMask = 0x00000001;\n    \n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    \n    if((iPos < 1) || (iPos > 32))\n    {\n        return FALSE;\n    }\n    \n    iMask = iMask << (iPos -1);\n    \n    iResult = iNo & iMask;\n    \n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\nint main()\n{\n    int iNo = 0, iPos;\n    BOOL bRet = FALSE;\n    \n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    \n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&iPos);\n        \n    bRet = CheckBit(iNo,iPos);\n    if(bRet == TRUE)\n    {\n        printf(\"Bit is on\\n\");\n    }\n    else\n    {\n        printf(\"Bits is Off\\n\");\n    }\n    return 0;\n}\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\n\n\n\nint PowerI(int X, int Y)\n{\n    int Result = 1;\n    while(Y != 0)\n    {\n        Result = Result * X;\n        Y--;\n    }\n    return Result;\n}\n\nint PowerR(int X, int Y)\n{\n    static int Result = 1;\n    if(Y != 0)\n    {\n        Result = Result * X;\n        Y--;\n        PowerR(X,Y);\n    }\n    return Result;\n}\n\nint main()\n{\n    int no1 = 0, no2 = 0, iRet = 0;\n\n    printf(\"Enter first number\\n\");\n    scanf(\"%d\",&no1);\n    \n    printf(\"Enter second number\\n\");\n    scanf(\"%d\",&no2);\n    \n    iRet = PowerR(no1,no2);\n    \n    printf(\"Result is %d\",iRet);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n#include<stdio.h>\n\nvoid DisplayI(int no)\n{\n    while(no > 0)\n    {\n        printf(\"%d\\n\",no);\n        no--;\n    }\n}\n\nvoid DisplayR(int no)\n{\n        if(no > 0)\n        {\n            printf(\"%d\\t\",no);\n            no--;\n            DisplayR(no);\n        }\n}\n\nint main()\n{\n    int value = 0;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&value);     \n    \n    DisplayR(value);\n    \n    printf(\"End of main\");\n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nvoid StrcatXX(char *Src, char *Dest)\n{\n    if(  (Src == NULL) ||  (Dest == NULL)   )\n    {\n        return;\n    }\n    \n    \n    \n    while(*Dest != '\\0')   \n    {\n        Dest++;                \n    }\n        \n    *Dest = ' ';        \n    \n    Dest++;\n   \n    while(*Src != '\\0')\n   {\n       *Dest = *Src;\n       Src++;\n       Dest++;\n   }\n    \n    *Dest = '\\0';\n}\n\nint main()\n{\n    char arr[30] = {'\\0'};   \n\n    char brr[30] = {'\\0'};   \n    \n    printf(\"Please enter first string\\n\");\n\n    scanf(\"%[^'\\n']s\",arr);\n    \n    printf(\"Please enter second string\\n\");\n  \n    scanf(\" %[^'\\n']s\",brr);\n        \n    StrcatXX(arr,brr);       \n    \n    printf(\"String after concatination %s\\n\",brr);\n    \n    return 0;\n}\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n    struct Node *prev;\n};\n\ntypedef struct Node NODE;\ntypedef struct Node * PNODE;\ntypedef struct Node ** PPNODE;\n\nvoid InsertLast(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    \n    newn = (PNODE)malloc(sizeof(NODE));\n    \n    newn->data = value;\n    newn->next = NULL;\n    newn->prev = NULL;\n    \n    if((*Head ==NULL) && (*Tail == NULL))       \n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else            \n    {\n        (*Tail)->next = newn;\n        newn->prev = *Tail;\n        *Tail = (*Tail) ->next;   \n    }\n    (*Tail)->next = *Head;\n    (*Head)->prev = *Tail;\n}\n\nvoid InsertFirst(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    \n    newn = (PNODE)malloc(sizeof(NODE));\n    \n    newn->data = value;\n    newn->next = NULL;\n    newn->prev = NULL;\n    \n    if((*Head ==NULL) && (*Tail == NULL))       \n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else            \n    {\n        newn->next = *Head;\n        (*Head)->prev = newn;\n        *Head = (*Head)->prev;\n    }\n    (*Tail)->next = *Head;\n    (*Head)->prev = *Tail;\n}\n\nvoid Display(PNODE Head, PNODE Tail)\n{\n        if((Head == NULL) && (Tail == NULL))\n        {\n            return;\n        }\n        do\n        {\n            printf(\"|%d| <-> \",Head->data);\n            Head = Head->next;\n        }while(Head != Tail->next);\n}\n\nint Count(PNODE Head, PNODE Tail)\n{\n    int iCnt = 0;\n    \n        if((Head == NULL) && (Tail == NULL))\n        {\n            return 0;\n        }\n    \n        do\n        {\n            iCnt++;\n            Head = Head->next;\n        }while(Head != Tail->next);\n\n    return iCnt;\n}\n\nvoid DeleteFirst(PPNODE Head, PPNODE Tail)\n{\n    if(*Head == NULL && *Tail == NULL)  \n    {\n        return;\n    }\n    \n    if(*Head == *Tail)  \n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n    }\n    else    \n    {\n        *Head = (*Head)->next;\n        free((*Tail)->next);    \n    \n        (*Head)->prev = *Tail;\n        (*Tail)->next = *Head;\n    }\n}\n\nvoid DeleteLast(PPNODE Head, PPNODE Tail)\n{\n    if(*Head == NULL && *Tail == NULL)  \n    {\n        return;\n    }\n    \n    if(*Head == *Tail)  \n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n    }\n    else    \n    {\n        *Tail  = (*Tail )->prev;\n        free((*Tail)->next);      \n        \n        (*Head)->prev = *Tail;\n        (*Tail)->next = *Head;\n    }\n}\n\nvoid InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)\n{\n    int count = 0, i= 0;\n    PNODE temp = *Head;\n    PNODE newn = NULL;\n    \n    count = Count(*Head, *Tail);\n    \n    if((pos < 1) || (pos > (count + 1)))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        InsertFirst(Head, Tail, value);\n    }\n    else if(pos == count + 1)\n    {\n        InsertLast(Head,Tail,value);\n    }\n    else\n    {\n        newn= (PNODE)malloc(sizeof(NODE));\n        \n        newn->next = NULL;\n        newn->prev = NULL;\n        newn->data = value;\n        \n        for(i = 1; i< pos-1; i++)\n        {\n            temp = temp->next;\n        }\n        \n        newn->next = temp->next;\n        temp->next->prev = newn;\n        \n        temp->next = newn;\n        newn->prev = temp;\n    }\n}\n\nvoid DeleteAtPos(PPNODE Head,PPNODE Tail, int pos)\n{\n    int cnt = 0,i = 0;\n    PNODE temp = *Head;\n    \n    cnt = Count(*Head, *Tail);\n    \n    if((pos < 1) || (pos > cnt))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        DeleteFirst(Head, Tail);\n    }\n    else if(pos == cnt)\n    {\n        DeleteLast(Head, Tail);\n    }\n    else\n    {\n        for(i = 1; i<pos-1; i++)\n        {\n            temp =temp->next;\n        }\n        temp->next = temp->next->next;\n        free(temp->next->prev);\n        temp->next->prev = temp;\n    }\n}\nint main()\n{\n    PNODE First = NULL;\n    PNODE Last = NULL;          \n    int no = 0, iRet = 0;\n    \n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    \n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    \n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    \n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    \n    printf(\"Contents of linked lista are \\n\");\n    Display(First, Last);\n    \n    iRet = Count(First,Last);\n    \n    printf(\"\\nNumber of lements are %d\\n\",iRet);\n    \n    DeleteLast(&First,&Last);\n    DeleteFirst(&First,&Last);\n    \n    printf(\"Contents of linked lista are \\n\");\n    Display(First, Last);\n    \n        return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\ntypedef struct node NODE;\ntypedef struct node * PNODE;\ntypedef struct node ** PPNODE;\n\nvoid InsertFirst(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n    (*Tail)->next = *Head;\n}\n\nvoid InsertLast(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else\n    {\n        (*Tail)->next = newn;\n        *Tail = newn;\n    }\n    (*Tail)->next = *Head;\n}\n\nvoid Display(PNODE Head, PNODE Tail)\n{\n    if((Head == NULL) && (Tail == NULL))\n    {\n        return;\n    }\n\n    do\n    {\n        printf(\"|%d|<->\",Head->data);\n        Head = Head->next;\n    }while(Head!= Tail->next);\n    printf(\"\\n\");\n}\n\nint Count(PNODE Head, PNODE Tail)\n{\n    int iCnt = 0;\n\n    if((Head == NULL) && (Tail == NULL))\n    {\n        return 0;\n    }\n\n    do\n    {\n        iCnt++;\n        Head = Head->next;\n    }while(Head!= Tail->next);\n\n    return iCnt;\n}\n\nvoid DeleteFirst(PPNODE Head, PPNODE Tail)\n{\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        return;\n    }\n    if(*Head == *Tail)\n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n        return;\n    }\n    else\n    {\n        *Head = (*Head)->next;\n        free((*Tail)->next);\n        (*Tail)->next = *Head;\n    }\n}\n\nvoid DeleteLast(PPNODE Head, PPNODE Tail)\n{\n    PNODE temp = *Head;\n\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        return;\n    }\n    if(*Head == *Tail)\n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n        return;\n    }\n    else\n    {\n        while(temp->next != *Tail)\n        {\n            temp = temp->next;\n        }\n\n        free(*Tail);\n        *Tail = temp;\n        (*Tail)->next = *Head;\n    }\n}\n\nvoid InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)\n{\n    int iCnt = 0, i = 0;\n    PNODE temp = *Head;\n    PNODE newn = NULL;\n\n    iCnt = Count(*Head, *Tail);\n\n    if((pos < 1) || (pos > iCnt+1))\n    {\n        return;\n    }\n\n    if(pos == 1)\n    {\n        InsertFirst(Head, Tail, value);\n    }\n    else if(pos == iCnt +1)\n    {\n        InsertLast(Head,Tail, value);\n    }\n    else\n    {\n        for(i = 1; i<pos-1;i++)\n        {\n            temp = temp->next;\n        }\n        newn = (PNODE)malloc(sizeof(NODE));\n        newn->data = value;\n        newn->next = NULL;\n\n        newn->next = temp->next;\n        temp->next = newn;\n    }\n}\n\nvoid DeleteAtPos(PPNODE Head, PPNODE Tail,int pos)\n{\n    PNODE temp1 = *Head;\n    PNODE temp2 = NULL;\n    int iCnt = 0, i = 0;\n\n    iCnt = Count(*Head,*Tail);\n\n    if((pos < 1) || (pos > iCnt))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        DeleteFirst(Head, Tail);\n    }\n    else if(pos == iCnt)\n    {\n        DeleteLast(Head, Tail);\n    }\n    else\n    {\n        for(i = 1; i< pos-1; i++)\n        {\n            temp1 = temp1->next;\n        }\n\n        temp2 = temp1->next;\n        temp1->next = temp2->next;\n        free(temp2);\n    }\n}\n\nint main()\n{\n    PNODE First = NULL;\n    PNODE Last = NULL;\n\n    int choice = 1, no = 0, pos = 0;\n\n    printf(\"-----------------------------\\n\");\n    printf(\"Singly Circular Linked List\\n\");\n    printf(\"-----------------------------\\n\");\n\n    while(choice!= 0)   \n    {\n        printf(\"-----------------------------\\n\");\n        printf(\"Enter your choice : \\n\");\n        printf(\"1: Inser first\\n2: Insert Last\\n3: Insert at position \\n4: Delete first: \\n5: Delete Last\\n\");\n        printf(\"6: Delete at position \\n7: Display \\n8: Count: \\n0: Exit\\n\");\n        scanf(\"%d\", &choice);\n        printf(\"-----------------------------\\n\");\n\n        switch(choice)\n        {\n            case 1:\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                InsertFirst(&First, &Last,no);\n                break;\n\n            case 2:\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                InsertLast(&First, &Last,no);\n                break;\n\n            case 3 :\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                printf(\"Enter position : \\n\");\n                scanf(\"%d\",&pos);\n                InsertAtPos(&First, &Last,no,pos);\n                break;\n\n            case 4:\n                DeleteFirst(&First, &Last);\n                break;\n\n            case 5 :\n                DeleteLast(&First,&Last);\n                break;\n\n            case 6:\n                 printf(\"Enter position : \\n\");\n                 scanf(\"%d\",&pos);\n                 DeleteAtPos(&First, &Last,pos);\n                 break;\n\n            case 7:\n                Display(First, Last);\n                break;\n\n            case 8:\n                printf(\"Number of node are %d\\n\", Count(First, Last));\n                break;\n\n            case 0:\n                printf(\"Thank you for using the application...\\n\");\n                break;\n\n            default:\n                printf(\"Error : Wrong choice..\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\ntypedef struct node NODE;\ntypedef struct node * PNODE;\ntypedef  struct node ** PPNODE;\n\nvoid Push(PPNODE Head, int value)   \n{\n    PNODE newn = (PNODE) malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    if(*Head == NULL)\n    {\n        *Head = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n}\nint Pop(PPNODE Head)        \n{\n    int no = 0;\n    PNODE temp = *Head;\n    \n    if(*Head == NULL)\n    {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n    else\n    {\n        no = (*Head)->data;         \n        *Head = (*Head)->next;\n        free(temp);\n        return no;\n    }\n}\n\nint Peep(PNODE Head)    \n{\n    int no = 0;\n    \n    if(Head == NULL)\n    {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n    else\n    {\n        no = Head->data;\n        return no;\n    }\n}\n\nvoid Display(PNODE Head)    \n{\n    while(Head != NULL)\n    {\n        printf(\"|%d|->\",Head->data);\n        Head = Head->next;\n    }\n    printf(\"\\n\");\n}\n\nint Count(PNODE Head)       \n{\n    int iCnt = 0;\n    \n    while(Head != NULL)\n    {\n        iCnt++;\n        Head = Head->next;\n    }\n    return iCnt;\n}\n\nint main()\n{\n    PNODE First = NULL;\n    int choice = 1, no = 0;\n    \n    printf(\"Dynamic implementation of stack\\n\");\n    \n    while(choice != 0)\n    {\n        printf(\"\\n 1: Push the element\");\n        printf(\"\\n 2: Pop the elemet\");\n        printf(\"\\n 3: Display the elemets of stack\");\n        printf(\"\\n 4: Count the number of elements of stack\");\n        printf(\"\\n 5: Peep the element\");\n        printf(\"\\n 0: Exit the application\\n\");\n        \n        printf(\"Please enter your choice : \\n\");\n        scanf(\"%d\",&choice);\n        \n        switch (choice)\n        {\n            case 1:\n                printf(\"Enter the element that you want to insert\\n\");\n                scanf(\"%d\",&no);\n                Push(&First, no);\n                break;\n                \n            case 2 :\n                no = Pop(&First);\n                printf(\"Poped element is : %d\\n\",no);\n                break;\n              \n            case 3 :\n                Display(First);\n                break;\n                \n            case 4:\n                printf(\"Number of elements are : %d\\n\",Count(First));\n                break;\n                \n            case 5:\n                printf(\"Peeped element is : %d\\n\",Peep(First));\n                break;\n                \n            case 0:\n                printf(\"Thank you for using the application\\n\");\n                break;\n                \n            default:\n                printf(\"Wrong choice\\n\");\n        } \n    }\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint StrlenCap(char str[])\n{\n    int iCnt = 0, i = 0;\n    \n    if(str == NULL)\n    {\n        return -1;\n    }\n    \n    while(str[i] != '\\0')\n    {\n        if((str[i] >= 'A') && (str[i] <= 'Z'))\n        {\n            iCnt++;\n        }\n        \n        i++;\n    }\n    \n    return iCnt;\n}\n\nint main()\n{\n    char arr[30];\n    \n    int iRet = 0;\n    \n    printf(\"Please enter the string\\n\");\n    \n    scanf(\"%[^'\\n']s\",arr);\n    \n    iRet = StrlenCap(arr);\n    \n    printf(\"Total number of capital characters are %d\\n\",iRet);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nvoid StrcatX(char *Src, char *Dest)\n{\n    if( (Src == NULL) || (Dest == NULL)   )\n    {\n        return;\n    }\n    \n    \n  \n    while(*Src != '\\0')    \n    {\n        Src++;               \n    }\n\n   \n    *Src=' ';\n    Src++;\n\n   while(*Dest != '\\0')\n   {\n       *Src = *Dest;\n       Dest++;\n       Src++;\n   }\n    \n    *Dest = '\\0';\n}\n\nint main()\n{\n    char arr[30] = {'\\0'};   \n\n    char brr[30] = {'\\0'};   \n    \n    printf(\"Please enter first string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    \n    printf(\"Please enter second string\\n\");\n    scanf(\" %[^'\\n']s\",brr);\n        \n    StrcatX(arr,brr);       \n    \n    printf(\"String after concatination %s\\n\",arr);\n    \n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nvoid StrcpyX(char Src[], char Dest[])\n{\n    int i = 0;\n    \n    if( (Src == NULL) ||(Dest == NULL))\n    {\n        return;\n    }\n    while(Src[i] != '\\0')\n    {\n        Dest[i] = Src[i];\n        i++;\n    }\n    Dest[i] = '\\0';\n}\n\nint main()\n{\n    char arr[30] = {'\\0'};   \n    char brr[30] = {'\\0'};   \n    \n    printf(\"Please enter the string\\n\");\n\n    scanf(\"%[^'\\n']s\",arr);\n        \n    StrcpyX(arr,brr);\n    \n    printf(\"String after copy : %s\\n\",brr);\n    \n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nvoid StrrevX(char str[])\n{\n    int iStart = 0, iEnd = 0;\n    char temp = '\\0';\n    \n    if(str == NULL)\n    {\n        return;\n    }\n    \n    \n    while(str[iEnd] != '\\0')        \n    {\n        iEnd++;\n    }\n    iEnd --;\n    \n    while(iStart < iEnd)            \n    {\n        temp = str[iStart];\n        str[iStart] = str[iEnd];\n        str[iEnd] = temp;\n        \n        iStart++;\n        iEnd--;\n    }\n}\n\nint main()\n{\n    char arr[30];\n    \n    printf(\"Please enter the string\\n\");\n\n    scanf(\"%[^'\\n']s\",arr);\n        \n    StrrevX(arr);\n    \n    printf(\"Reverse string is %s\\n\",arr);\n    \n    return 0;\n}\n\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n\n\n#include<stdio.h>\n\nint StrlenI(char *str)\n{\n    int i = 0;\n    \n    while(str[i] != '\\0')\n    {\n        i++;\n    }\n    return i;\n}\n\nint StrlenR(char *str)\n{\n    static int i = 0;\n    \n    if(str[i] != '\\0')\n    {\n        i++;\n        StrlenR(str);\n    }\n    return i;\n}\n\nint main()\n{\n    int iRet = 0;\n \n    char Arr[30] = {'\\0'};\n    \n \n    printf(\"Enter string\\n\");\n \n    scanf(\"%[^'\\n']s\",Arr);\n    \n    iRet = StrlenR(Arr);\n \n    printf(\"Length is %d\\n\\n\",iRet);\n    \n    return 0;\n}\n"}
{"target":"deepaliajabsingjadhav","func":"\n\n#include<stdio.h>\n\nint ToggleBit(int iNo, int iPos)\n{\n    int iMask = 0x00000001;\n    \n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    \n    if((iPos < 1) || (iPos > 32))\n    {\n        return 0;\n    }\n    \n    iMask = iMask << (iPos -1);\n    \n    iResult = iNo ^ iMask;\n    \n    return iResult;\n}\n\nint main()\n{\n    int iNo = 0, iPos = 0, iRet = 0;\n    \n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    \n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&iPos);\n        \n    iRet = ToggleBit(iNo,iPos);\n    \n    printf(\"Modified number after bit toggle is : %d\\n\",iRet);\n\n    return 0;\n}\n\n\n\n\n"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid scambia(int v[], int dim, int i, int j){\n\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = v[i];\n            v[i] = v[j];\n            v[j] = tmp;\n        }\n    }\n\n}\n\nvoid scambiaEsplicito(int v[], int dim, int i, int j){\n\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = *(v + i);\n            *(v + i) = *(v + j);\n            *(v + j) = tmp;\n        }\n    }\n\n}\n\nint main(void) {\n\n    \n\n\n  return 0;\n}"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <malloc.h>\n\nstruct elemento{ int info; struct elemento* next; };\n\ntypedef struct elemento ElementodiLista;\ntypedef ElementodiLista* ListadiElementi;\n\nint main(void) \n{\n    ListadiElementi lista = NULL; \n    int N = 10;\n\n    \n    ListadiElementi new = malloc(sizeof(ElementodiLista));\n    (*new).info = 1;\n    \n    lista = new;\n\n    for(int i = 2; i < N; i++)\n    {\n        \n        (*new).next = malloc(sizeof(ElementodiLista));\n        \n        new = new->next;\n        \n        (*new).info = i;\n    }\n\n    new->next=NULL;\n}\n\n"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <malloc.h>\n\nstruct elemento{ int info; struct elemento* next; };\n\ntypedef struct elemento ElementodiLista;\ntypedef ElementodiLista* ListadiElementi;\n\nint main(void) \n{\n    \n  \n    return 0;\n}\n\nvoid inserisci(ListadiElementi *l, int x, int v)\n{\n    ListadiElementi prec, corr;\n\n    corr = *l;\n    int trovato = 0;\n    prec = NULL;\n\n    while(corr != NULL && !trovato)\n    {\n        if(corr->info == x) trovato = 1;\n        else\n        {\n            prec = corr;\n            corr = corr->next;\n        }\n    }\n\n    if(trovato)\n    {\n        ListadiElementi new = malloc(sizeof(ElementodiLista));\n        new->info = v;   \n        new->next = corr;\n\n        if(prec != NULL) prec->next = new;\n        else *l = new;\n    }\n}\n\n"}
{"target":"deessee0","func":"#include <stdio.h>\n\nvoid lettura(int v[], int dim)\n{\n    int i=0;\n    for(i=0;i<dim;i++)\n    {\n        scanf(\"%d\", &v[i]);\n    }\n}\n\nint somma(int v[], int dim)\n    {\n        int tot=0;\n        int i=0;\n        \n        for(i=0;i<dim;i++)\n        {\n            tot += v[i]; \n        }\n\n        return tot;\n    }\n\nint main(void) \n{\n    int a[5];\n    int tot;\n\n    lettura(a,5);\n\n    somma(a,5);\n\n    printf(\"Somma totale dell'array: %d\", tot);\n\n}"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <malloc.h>\n\nstruct elemento{ int info; struct elemento* next; };\n\ntypedef struct elemento ElementodiLista;\ntypedef ElementodiLista* ListadiElementi;\n\nvoid addT(ListadiElementi* l, int x)\n{\n    ListadiElementi new = malloc(sizeof(ElementodiLista));\n    new->info = x;\n    new->next = *l;\n    *l = new;\n}\n\nvoid addC(ListadiElementi* l, int x)\n{\n    \n    ListadiElementi new = malloc(sizeof(ElementodiLista));\n    (*new).info = x;\n    (*new).next = NULL;\n    \n    if(*l == NULL) *l = new;\n    else \n    {\n        \n        ListadiElementi corr = *l;\n        \n        while(corr->next != NULL) corr = corr->next;\n        \n        corr->next = new;\n    }\n}\n\nint main(void) \n{\n    ListadiElementi lista = NULL;\n    \n    addT(&lista , 2);\n    addT(&lista, 3);\n    addC(&lista, 1);\n    \n}\n\n"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid rimuoviDuplicati(int a[], int* dim_a)\n{\n    for(int i=0;i<*dim_a;i++)\n    {\n        for(int j=i+1; j<*dim_a; j++)\n        {\n            if(a[i]==a[j])\n            {\n                for(int k=j; k<*dim_a-1;j++)\n                {\n                    a[k] = a[k+1];\n                }\n\n                *dim_a -= 1;\n                j--;\n            }\n        }\n    }\n}\n\nint main(void) {\n    \n    int dim_a = 7;\n    int *a = malloc(sizeof(int)*dim_a);\n\n    for(int i=0; i<dim_a; i++)\n    {\n        printf(\"a[%d]=\", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n\n    rimuoviDuplicati(a, &dim_a);\n\n    for(int i=0; i<dim_a; i++)\n    {\n        printf(\"a[%d]=\", i);\n        scanf(\"%d\", &a[i]);\n    }\n\n    free(a);\n\n    return 0;\n}"}
{"target":"deessee0","func":"#include <stdio.h>\n\nvoid decToBin(int dec)\n{\n    float resto;\n    int numeriBinari[100], i = 0;\n\n    while(dec > 0)\n    {\n        numeriBinari[i] = dec % 2;\n        dec = dec\/2;\n        i++;\n    }\n\n    for(int j = i-1; j>=0; j--)\n    {\n        printf(\"%d\",numeriBinari[j]);\n    }\n\n}\n\n\nint main(){\n    int n;\n    printf(\"Giac: \");\n    scanf(\"%d\",&n);\n\n    decToBin(n);\n\n        \n\n    return 0;\n}\n"}
{"target":"deessee0","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\nint somma(int a[], int dim){\n  int s = 0; \n  for(int i=0; i<dim; i++){\n    s+=a[i];\n  }\n  return s;\n}\n\n\nint check(int a[], int dim_a, int b[], int dim_b){\n  int i = 0; \n  int trovato = 0; \n  \n  int somma_b = somma(b, dim_b);\n  \n  \n  while(i<dim_a && !trovato){\n    \n    if(a[i]==somma_b){\n      \n      trovato = 1;\n    }\n    \n    i++;\n  } \n  return trovato;\n}\n\nint main(){\n  \n  int dim_a, dim_b;\n  printf(\"Inserire dimensione a: \");\n  scanf(\"%d\", &dim_a);\n  printf(\"Inserire dimansione b: \");\n  scanf(\"%d\", &dim_b);\n\n  \n  int *a;\n  a = malloc(sizeof(int)*dim_a);\n  int *b;\n  b = malloc(sizeof(int)*dim_b);\n\n  \n  for(int i=0; i<dim_a; i++){\n    printf(\"a[%d] = \", i);\n    scanf(\"%d\", &a[i]);\n  }\n  printf(\"\\n\");\n\n  \n  for(int i=0; i<dim_b; i++){\n    printf(\"b[%d] = \", i);\n    scanf(\"%d\", &b[i]);\n  }\n  printf(\"\\n\");\n\n  int verifica = check(a, dim_a, b, dim_b);\n\n  if(verifica==1){\n    printf(\"In a esiste un elemento uguale alla somma degli elementi di b\\n\");\n  }\n\n  if(verifica==0){\n    printf(\"In a NON esiste un elemento uguale alla somma degli elementi di b\\n\");\n  }\n\n  free(a);\n  free(b);\n\n  return(0);\n\n}"}
{"target":"deessee0","func":"#include <stdio.h>\nint potenza(int base, int esponente);\n\nint main(void) {\n  int a, b;\n  int risultato;\n\n  printf(\"Base: \");\n  scanf(\"%d\", &a);\n\n  printf(\"Esponente: \");\n  scanf(\"%d\", &b);\n\n  if (b > 0) {\n    risultato = potenza(a,b);\n    printf( \"Risultato: %d\\n\", risultato ); \n  } else {\n    printf(\"Inserisci una potenza maggiore di 0\");\n  }\n \n  return 0;\n}\n\nint potenza(int base, int esponente){\n  int risultato = 1;\n\n  for(int i = 0; i < esponente; i++){\n    risultato = risultato * base;\n  }\n\n    return (risultato);\n}  "}
{"target":"deessee0","func":"#include<stdio.h>\n\nint main(void) {\n    \n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    int b[dim];\n\n    \n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n\n    printf(\"\\n\");\n  \n    \n    for(int i=0; i<dim; i++)\n    {\n        printf(\"b[%d] = \", i);\n        scanf(\"%d\", &b[i]);\n    }\n\n    printf(\"\\n\");\n\n    int c[dim];\n\n    printf(\"Prodotto scalare dei due vettori: \\n\");\n    for(int i=0; i<dim; i++)\n    {\n        c[i] = a[i] * b[i];\n        printf(\"c[%d] = \", i );\n        printf(\"%d\", c[i]);\n        printf(\"\\n\");\n    }\n\n}"}
{"target":"deessee0","func":"#include <stdio.h>\n\nvoid isPrime(int dim, int a[])\n{\n    int contatore = 0, prime;\n    int b[dim];\n\n    \n    for(int i=0; i<dim; i++)\n    {\n        for(int j=0; j<dim; j++)\n        {\n            prime = 0;\n            \n            if((i != j) && (a[i] % a[j] != 0))\n            {\n                prime = 1;\n                break;                     \n            }\n        }\n\n        if(prime == 1)\n        {\n            b[i] = a[i];\n        } else {\n            b[i] = 0;\n        }\n\n        printf(\"b[%d] = %d\\n\",i, b[i]);          \n    }\n\n   \n}\n\n\nint main(void) {\n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n\n    \n    for(int i=0; i<dim; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n\n    printf(\"\\n\");\n    printf(\"----------------------------\\n\");\n    isPrime(dim,a);\n\n  return 0;\n}"}
{"target":"deessee0","func":"#include <stdio.h>\nint max_finder(int a, int b, int c);\n\nint main(void) {\n  int a, b, c;\n  int risultato;\n\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n\n  printf(\"Terzo numero: \");\n  scanf(\"%d\", &c);\n\n  risultato = max_finder(a,b,c);\n  printf( \"Risultato: %d\\n\", risultato ); \n\n  return 0;\n}\n\nint max_finder(int a, int b, int c){\n\n  if(a > b){\n        if( a > c){\n            return a;\n        } else return c;\n    } else if (b > c){\n        return b;\n\n    } else return c;\n\n}  "}
{"target":"deessee0","func":"#include<stdio.h>\n\nvoid somma_armonica(int n, double* h)\n{\n\n    if(n == 1)\n    {\n        *h = 1.0 + *h;\n    } else {       \n        *h =  *h + (1.0\/n);\n        somma_armonica(n-1,h);     \n    }\n           \n}\n\nint main(void) \n{\n    int n;\n    double risultato;\n\n    printf(\"Inserisci n: \");\n    scanf(\"%d\", &n);\n\n    somma_armonica(n, &risultato);\n    printf(\"Risultato = %lf\", risultato);\n\n\n    return 0;\n\n}"}
{"target":"deessee0","func":"#include<stdio.h>\n\nvoid scambia(int v[], int dim, int i, int j){\n\n    if(dim > 0)\n    {\n        if((i >= 0) && (i <= dim) && (j >= 0) && (j <= dim))\n        {\n            int tmp = v[i];\n            v[i] = v[j];\n            v[j] = tmp;\n        }\n    }\n}\n\nint minimo(int a[], int dim)\n    {\n\n    int valoreMinimo = a[0], locazione = 0, i;\n\n    for(i=0; i < dim; i++)\n    {\n        if ( a[i] < valoreMinimo ) \n        {\n            valoreMinimo = a[i];\n            locazione = i;\n        }\n    } \n    \n    return locazione;\n}\n\nvoid stampa_vettore(int a[], int dim)\n{\n\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}\n\nint main(void) {\n    int dim, indice;\n    int i = 0;\n\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n\n    \n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    \n    printf(\"\\n\");\n\n    indice = minimo(a, dim);\n    printf(\"-------------------------------\\n\");\n    printf(\"L'indice minore \u00e8: %d\\n\", indice);\n    \n    scambia(a,dim, 0, indice);\n\n    printf(\"\\nQuesto \u00e8 l'array con il valore minimo in testa:\\n\");\n\n    stampa_vettore(a, dim);\n    \n    return 0;\n\n}"}
{"target":"deessee0","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\n\nvoid rimuovi(int a[], int *dim){\n  \n  for(int i=0; i<*dim; i++){\n    \n    for(int j=i+1; j<*dim; j++){\n      \n      if(a[i]==a[j]){\n        \n        for(int k=j; k<*dim-1; k++){\n          a[k] = a[k+1];\n        }\n        \n        *dim -=1;\n        \n        \n        j--;\n      }\n    }\n  }\n}\n\nint main(void) {\n    int dim_a;\n    printf(\"Inserire dimensione a: \");\n    scanf(\"%d\", &dim_a);\n    int *a = malloc(sizeof(int)*dim_a);\n\n    \n    for(int i=0; i<dim_a; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n\n    \n    rimuovi(a, &dim_a);\n\n}"}
{"target":"deessee0","func":"#include<stdio.h>\n#include<math.h>\n\nvoid calcolo_ipotenusa(float *ac, float *gamma, float *ipotenusa)\n{\n    double angolo_gamma = *gamma;\n    *ipotenusa = *ac \/ sin(angolo_gamma);  \n           \n}\n\nfloat calcolo_perimetro(float ac, float ipotenusa, float *bc)\n{\n   return ac + ipotenusa + *bc;\n}\n\nvoid calcolo_area(float *perimetro, float ac, float *ipotenusa, float *bc, float *area)\n{\n    double parziale = (*perimetro\/2) * (*perimetro\/2 - ac) * (*perimetro\/2 - *ipotenusa) * (*perimetro\/2 - *bc);\n\n    *area = sqrt(parziale);\n}\n\nfloat calcolo_altezza(float *ab, float *h)\n{\n    return ((*ab * *h) \/ 2);\n}\n\nint main(void) \n{\n    float ac, gamma, bc=15;\n    int alfa = 90;\n    float ipotenusa, perimetro, altezza, area;\n\n    printf(\"\\n-------------------------------------\\n\");\n    printf(\"Inserisci il valore del cateto minore: \");\n    scanf(\"%f\", &ac);\n\n    printf(\"Inserisci il valore dell'angolo gamma: \");\n    scanf(\"%f\", &gamma);\n    printf(\"\\n-------------------------------------\\n\");\n\n    calcolo_ipotenusa(&ac, &gamma, &ipotenusa);\n    printf(\"L'ipotenusa del triangolo \u00e8: %f\\n\", ipotenusa);\n\n    perimetro = calcolo_perimetro(ac, ipotenusa, &bc);\n    printf(\"Il perimetro del triangolo \u00e8: %f\\n\", perimetro);\n\n    calcolo_area(&perimetro, ac, &ipotenusa, &bc, &area);\n    printf(\"L'area del triangolo \u00e8: %f\\n\", area);\n\n    altezza = calcolo_altezza(&ipotenusa, &area);\n    printf(\"L'altezza del triangolo \u00e8: %f\\n\", altezza);\n\n    return 0;\n\n}"}
{"target":"deessee0","func":"#include<stdio.h>\n#include <stdlib.h>\n\nint minimo(int a[], int dim)\n    {\n\n    int valoreMinimo = a[0], locazione = 0;\n\n    for(int i=0; i < dim; i++)\n    {\n        if ( a[i] < valoreMinimo ) \n        {\n            valoreMinimo = a[i];\n            locazione = i;\n        }\n    } \n    \n    return locazione;\n}\n\nvoid delta_minimo(int a[], int n, int dim)\n{\n    int differenza[dim];\n    int risultato;\n\n\n    for(int i = 0; i<dim; i++)\n    {\n        if(abs(a[i]) > n)\n        {\n            differenza[i] = abs(a[i]) - n;\n            \n        }   else   {\n\n            differenza[i] = n - abs(a[i]);\n        }         \n    }\n\n    risultato = minimo(differenza, dim); \n    \n    \n    printf(\"----------------------------\\nIntero in valore assoluto pi\u00f9 vicino a quello fornito: %d\", a[risultato]);\n\n}\n\nvoid stampa_vettore(int a[], int dim)\n{\n\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}\n\nint main(void) {\n    int dim;\n    int i = 0;\n    int n, risultato;\n\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n\n    \n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    \n    printf(\"\\n\");\n\n    printf(\"Inserisci il numero che vuoi ricercare nell'array: \");\n    scanf(\"%d\", &n);\n\n    printf(\"----------------------------\\nVettore inserito:\\n\");\n    stampa_vettore(a, dim);\n    printf(\"\\n\");\n    delta_minimo(a, n, dim);\n    \n    \n\n    return 0;\n\n}"}
{"target":"deessee0","func":"#include <stdio.h>\n#include <math.h>\n\nint idk(double x1, double y1);\n\nint main(void) {\n\n  double x, y;\n    int risultato;\n\n  printf(\"Inserisci il primo numero: \");\n  scanf(\"%lf\", &x);\n\n    printf(\"Inserisci il secondo numero: \");\n  scanf(\"%lf\", &y);\n\n\n  risultato = idk(x, y);\n  printf( \"Risultato: %d\\n\", risultato ); \n\n  return 0;\n}\n\nint idk(double x, double y){\n\n    double randomNumber = pow(1\/10, 9);\n\n        if ((x - y) <= (randomNumber))\n            return 1;\n        else return 0; \n        \n}\n\n"}
{"target":"deessee0","func":"#include <stdio.h>\n\nint main(void) {\n  \n  int dim; \n  printf(\"inserire dimensione array: \"); \n  scanf(\"%d\", &dim);\n  int a[dim];\n  int b[dim];\n\n  \n  for(int i=0; i<dim; i++){\n    printf(\"a[%d] = \", i);\n    scanf(\"%d\", &a[i]);\n  }\n\n  printf(\"\\n\");\n\n  \n  for(int i=0; i<dim; i++){\n    printf(\"b[%d] = \", i);\n    scanf(\"%d\", &b[i]);\n  }\n\n  printf(\"\\n\");\n\n  int c[dim];\n\n  \n  for(int i=0; i<=dim-1; i++) {\n    c[i] = a[i] + b[i];\n  }\n\n  for(int i=0; i<dim; i++){\n    printf(\"%d \", c[i]);\n  }\n\n  printf(\"\\n\");\n\n  \n  for(int i=0; i<dim; i++){\n    c[i] = a[i] * b[i];\n    printf(\"%d \", c[i]);\n  }\n\n  printf(\"\\n\");\n\n  \n  for(int i=0; i<dim; i++){\n    if(a[i]<=b[i]) {\n      c[i] = b[i];\n    }\n    else {\n      c[i] = a[i];\n    }\n    printf(\"%d \", c[i]); \n  }\n\n  printf(\"\\n\");\n\n  int max, min;\n  float media; \n\n  max = c[0];\n  min = c[0];\n  media = c[0];\n\n  for(int i=1; i<dim; i++) {\n    \n    if(c[i]>max){\n      max = c[i];\n    }\n    if(c[i]<min){\n      min = c[i];\n    }\n    \n    media += c[i];\n  }\n\n  printf(\"\\nMax in c: %d\\n\", max);\n  printf(\"\\nMin in c: %d\\n\", min);\n\n  media = media\/dim; \n\n  printf(\"\\nMedia elementi di c: %lf\\n\", media);\n\n  return 0;\n}"}
{"target":"deessee0","func":"#include<stdio.h>\n\nint calcolaFattoriale(int n)\n{\n    if (n == 1)\n        return 1;\n    else\n        return n * calcolaFattoriale(n - 1);\n}\nvoid stampa_vettore(int a[], int dim)\n{\n\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}\n\nint main(void) {\n    int dim;\n\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n\n    \n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    \n    printf(\"---------------------------------\\n\");\n\n    for(int i=0; i<dim; i++)\n    {\n        a[i] = calcolaFattoriale(a[i]);\n        printf(\"Il fattoriale di a[%d] \u00e8: %d\\n\", i, a[i]);\n    }   \n\n    return 0;\n\n}"}
{"target":"deessee0","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\n\nvoid rimuovi(int a[], int *dim){\n  \n  for(int i=0; i<*dim; i++){\n    \n    for(int j=i+1; j<*dim; j++){\n      \n      if(a[i]==a[j]){\n        \n        for(int k=j; k<*dim-1; k++){\n          a[k] = a[k+1];\n        }\n        \n        *dim -=1;\n        \n        \n        j--;\n      }\n    }\n  }\n}\n\nint main(void) {\n    int dim_a;\n    printf(\"Inserire dimensione a: \");\n    scanf(\"%d\", &dim_a);\n    int *a = malloc(sizeof(int)*dim_a);\n\n    \n    for(int i=0; i<dim_a; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n\n    \n    rimuovi(a, &dim_a);\n\n}"}
{"target":"deessee0","func":"#include<stdio.h>\n\nint main(){\n  int dim;\n  int check = 0;\n\n  \n  printf(\"dammi dim: \");\n  scanf(\"%d\", &dim);\n\n  int arr[dim];\n\n  printf(\"riempi array arr.\\n\");\n  for(int i = 0; i < dim; i++){\n    printf(\"dammi un numero: \");\n    scanf(\"%d\", &arr[i]);\n  }\n\n  for(int i = 0; i < dim; i++){\n  if(arr[i] != arr[dim - i - 1]){\n      check = 1;\n      i = dim; \n    }\n  }\n\n\n  if(check == 0){\n    printf(\"la sequenza \u00e8 palindroma.\\n\");\n  }else{\n    printf(\"la sequenza non \u00e8 palindroma.\\n\");\n  }\n\n  return(0);\n}"}
{"target":"deessee0","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct numero_complesso {\n  float reale; \n  float immaginaria; \n};\n\ntypedef struct numero_complesso NumeroComplesso;\n\n\nNumeroComplesso somma(NumeroComplesso x, NumeroComplesso y){\n  \n  NumeroComplesso s;\n  \n  s.reale = x.reale + y.reale;\n  \n  s.immaginaria = x.immaginaria + y.immaginaria;\n  \n  return s;\n}\n\n \nNumeroComplesso prodotto(NumeroComplesso x, NumeroComplesso y){\n  \n  NumeroComplesso p;\n  \n  p.reale = x.reale*y.reale - x.immaginaria*y.immaginaria;\n  \n  p.immaginaria = x.reale*y.immaginaria + x.immaginaria*y.reale;\n  \n  return p;\n}\n\n\nNumeroComplesso somma_array(NumeroComplesso z[],int dim){\n  \n  NumeroComplesso s;\n  \n  s.reale = z[0].reale;\n  s.immaginaria = z[0].immaginaria;\n\n  for(int i=1; i<dim; i++){\n    \n    s = somma(s, z[i]);\n  }\n\n  \n  return s;\n}\n\n\nvoid stampa_complesso(NumeroComplesso x){\n  \n  printf(\"%.2f + %.2f i\\n\", x.reale, x.immaginaria);\n}\n\nint main() {\n  \n  NumeroComplesso x;\n  printf(\"Inserire parte reale e immaginaria di x: \");\n  scanf(\"%f %f\", &x.reale, &x.immaginaria);\n  NumeroComplesso y;\n  printf(\"Inserire parte reale e immaginaria di y: \");\n  scanf(\"%f %f\", &y.reale, &y.immaginaria);\n\n  \n  printf(\"\\nx = \");\n  stampa_complesso(x);\n\n  \n  printf(\"\\ny = \");\n  stampa_complesso(y);\n\n  \n  NumeroComplesso s = somma(x, y);\n\n  \n  printf(\"\\nx + y = \");\n  stampa_complesso(s);\n\n  \n  NumeroComplesso p = prodotto(x, y);\n\n  \n  printf(\"\\nx*y = \");\n  stampa_complesso(p);\n\n  \n  \n  int n = 5; \n  NumeroComplesso z[n];\n  \n  for(int i=0; i<n; i++){\n    z[i].reale = i;\n    z[i].immaginaria = i+3;\n  }\n\n NumeroComplesso s1 = somma_array(z, n); \n \n printf(\"\\nLa somma di tutti gli elementi nell'array \u00e8:\\ns1 = \");\n stampa_complesso(s1);\n\n\n  return(0);\n}\n"}
{"target":"deessee0","func":"\n\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct triangolo {\n  float beta; \n  float alfa;\n  float gamma;\n  int ab;\n  int bc;\n  int ac; \n};\n\ntypedef struct triangolo Triangolo;\n\nfloat calcolo_perimetro(Triangolo* t)\n{\n\n    return  (t->ab + t->bc + t->ac);\n}\n\nvoid similitudine(Triangolo t1, Triangolo* t2)\n{\n    if((t1.alfa == t2->alfa) && (t1.beta == t2->beta) && (t1.gamma == t2->gamma))\n    {\n        printf(\"\\n0 - l'equivalenza \u00e8 vera\");\n    } else {\n        printf(\"\\n1 - l'equivalenza \u00e8 falsa\");\n    }\n    \n}\n\nint main() {\n\n  Triangolo x1;\n  Triangolo x2;\n\n\n\n  printf(\"Inserire angolo alfa: \");\n  scanf(\"%f\", &x1.alfa);\n  \n  printf(\"Inserire angolo beta: \");\n  scanf(\"%f\", &x1.beta);\n\n  printf(\"Inserire angolo gamma: \");\n  scanf(\"%f\", &x1.gamma);\n\n  printf(\"Inserire lato AB: \");\n  scanf(\"%d\", &x1.ab);\n\n  printf(\"Inserire lato BC: \");\n  scanf(\"%d\", &x1.bc);\n\n  printf(\"Inserire lato AC: \");\n  scanf(\"%d\", &x1.ac);\n\n\n\n  printf(\"Inserire angolo alfa: \");\n  scanf(\"%f\", &x2.alfa);\n  \n  printf(\"Inserire angolo beta: \");\n  scanf(\"%f\", &x2.beta);\n\n  printf(\"Inserire angolo gamma: \");\n  scanf(\"%f\", &x2.gamma);\n\n  printf(\"Inserire lato AB: \");\n  scanf(\"%d\", &x2.ab);\n\n  printf(\"Inserire lato BC: \");\n  scanf(\"%d\", &x2.bc);\n\n  printf(\"Inserire lato AC: \");\n  scanf(\"%d\", &x2.ac);\n\n\n    float primo = calcolo_perimetro(&x1);\n    float secondo = calcolo_perimetro(&x2);\n    printf(\"primo: %f\\nsecondo: %f\", primo, secondo);\n    similitudine(x1, &x2);\n  \n\n  return(0);\n}\n"}
{"target":"deessee0","func":"#include <stdio.h>\n\nint decToBin(int dec)\n{\n    float resto;\n    int numeriBinari[100], i = 0;\n\n    while(dec > 0)\n    {\n        numeriBinari[i] = dec % 2;\n        dec = dec\/2;\n        i++;\n    }\n\n    for(int j = i-1; j>=0; j--)\n    {\n        printf(\"%d\",numeriBinari[j]);\n    }\n\n    return resto;\n}\n\n\nint main(){\n    int n;\n    printf(\"Giac: \");\n    scanf(\"%d\",&n);\n\n    int risultato = decToBin(n);\n    printf(\"\\nrisultato = %d\", risultato);\n        \n\n    return 0;\n}\n"}
{"target":"deessee0","func":"#include <stdio.h>\n\nint mcd(int a, int b)\n{\n    int r = a % b;\n\n    if(r == 0){\n\n        return b;\n\n    } else { \n        \n        return mcd(b, r);\n    \n    }\n}\n\nint main() {\n  \n    int a, b;\n  int risultato;\n\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n  \n    risultato = mcd(a, b);\n  printf( \"Risultato: %d\\n\", risultato ); \n\n    return 0;\n}\n"}
{"target":"deessee0","func":"#include <stdio.h>\nint pot_ricorsivo(int base, int esponente);\n\nint main(void) {\n  int a, b;\n  int risultato;\n\n  printf(\"Base: \");\n  scanf(\"%d\", &a);\n\n  printf(\"Esponente: \");\n  scanf(\"%d\", &b);\n\n  if (b > 0) {\n    risultato = pot_ricorsivo(a,b);\n    printf( \"Risultato: %d\\n\", risultato ); \n  } else {\n    printf(\"Inserisci una potenza maggiore di 0\");\n  }\n \n  return 0;\n}\n\nint pot_ricorsivo(int base, int esponente)\n{\n\n    if (esponente == 1)\n          return base;\n \n    return base*pot_ricorsivo(base, esponente-1);\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\ntypedef long long int ll;\nstruct Queue{\n    int* arr;\n    int front,rear;\n    int cap,size;\n};\nstruct Queue* createQueue(int cap)\n{\n    struct Queue* queue=(struct Queue*)malloc(sizeof(struct Queue));\n    queue->front=-1;\n    queue->rear=-1;\n    queue->cap=cap;\n    queue->size=0;\n    queue->arr=(int*)malloc(cap*sizeof(int));\n    return queue;\n}\nint isEmpty(struct Queue* queue)\n{\n    return (queue->size==0);\n}\nint isFull(struct Queue* queue)\n{\n    if (queue->size==queue->cap)\n        return 1;\n    return 0;\n}\nvoid enqueue(struct Queue* queue,int ele)\n{\n    if (isFull(queue))\n    {\n        \n        return;\n    }\n    if (queue->front==-1)\n    {\n        queue->front=0;\n    }\n    queue->rear=(queue->rear+1)%queue->cap;\n    queue->arr[queue->rear]=ele;\n    queue->size++;\n    \n    return;\n}\nint dequeue(struct Queue* queue)\n{\n    if (isEmpty(queue))\n        return -1;\n    int ele=queue->arr[queue->front];\n    if (queue->front==queue->rear)\n    {\n        queue->front=-1;\n        queue->rear=-1;\n    }\n    queue->front=(queue->front+1)%queue->cap;\n    queue->size--;\n    return ele;\n}\nint** makeGraph(int v)\n{\n    int** graph=(int**)malloc(v*sizeof(int*));\n    FOR(i,0,v)\n    {\n        graph[i]=(int*)malloc(v*sizeof(int));\n    }\n    FOR(i,0,v)\n    {\n        FOR(j,0,v)\n        {\n            graph[i][j]=0;\n        }\n    }\n    int e;\n    scanf(\"%d\",&e);\n    FOR(i,0,e)\n    {\n        int src, dest;\n        scanf(\"%d %d\",&src,&dest);\n        graph[src][dest]=1;\n        graph[dest][src]=1;\n    }\n    return graph;\n}\nvoid bfs(int** graph,int* visited,int v,int src)\n{\n    \n    struct Queue* queue=createQueue(10000);\n    enqueue(queue,src);\n    int count=0;\n    while(!isEmpty(queue))\n    {\n        \n        int p=dequeue(queue);\n        visited[p]=1;\n        printf(\"%d \",p);\n        \n        count+=1;\n        FOR(i,0,v)\n        {\n            if(graph[p][i])\n            {\n                if(!visited[i])\n                {\n                    \n                    enqueue(queue,i);\n                }\n            }\n        }\n    }\n    return;\n}\nint main()\n{\n    int v;\n    scanf(\"%d\",&v);\n    int** graph=makeGraph(v);\n    int* visited=(int* )malloc(v*sizeof(int));\\\n    FOR(i,0,v)\n        visited[i]=0;\n    \n    FOR(i,0,v)\n    {\n        if(!visited[i])\n        {\n            bfs(graph,visited,v,i);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include <stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct Node\n{\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\nstruct Node* BSTInsert(struct Node** root,int data)\n{\n    if(!*root)\n    {\n        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));\n        newNode->data=data;\n        newNode->left=NULL;\n        newNode->right=NULL;\n        return newNode;\n    }\n    else\n    {\n        if((*root)->data>data)\n        {\n            (*root)->left=BSTInsert(&((*root)->left),data);\n        }\n        else if((*root)->data<data)\n        {\n            (*root)->right=BSTInsert(&((*root)->right),data);\n        }\n        else\n        {\n            printf(\"The element already exists in the BST\\n\");\n        }\n    }\n    return *root;\n    \n}\nvoid inorder(struct Node* root)\n{\n    if(!root)\n        return;\n    inorder(root->left);\n    printf(\"%d \",root->data);\n    inorder(root->right);\n    return;\n}\nvoid preorder(struct Node* root)\n{\n    if(!root)\n        return;\n    printf(\"%d \",root->data);\n    preorder(root->left);\n    preorder(root->right);\n    return;\n}\nvoid postorder(struct Node* root)\n{\n    if(!root)\n        return;\n    postorder(root->left);\n    postorder(root->right);\n    printf(\"%d \",root->data);\n    return;\n}\nint main()\n{\n    int n;\n    int k;\n    struct Node* root=NULL;\n    printf(\"Please enter the number of nodes you want to insert\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Please enter the elements\\n\");\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&k);\n        root=BSTInsert(&root,k);\n    }\n    inorder(root);\n    printf(\"\\n\");\n    preorder(root);\n    printf(\"\\n\");\n    postorder(root);\n    printf(\"\\n\");\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdlib.h>\n#include<stdio.h>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\nint* takeInput(int n)\n{\n    int* arr=(int*)malloc(n*sizeof(int));\n    int k;\n    FOR(i,0,n)\n    {\n        scanf(\"%d\",&k);\n        arr[i]=k;\n    }\n    return arr;\n}\nvoid bubbleSort(int n,int* arr)\n{\n    FOR(i,0,n-1)\n    {\n        FOR(j,0,n-i-1)\n        {\n            if(arr[j]>arr[j+1])\n            {\n                arr[j]=arr[j]^arr[j+1];\n                arr[j+1]=arr[j]^arr[j+1];\n                arr[j]=arr[j]^arr[j+1];\n            }\n        }\n    }\n}\nint main()\n{\n    int n;\n    scanf(\"%d\\n\",&n);\n    int* arr=takeInput(n);\n    bubbleSort(n,arr);\n    FOR(i,0,n)\n    {\n        printf(\"%d\\t\",arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\nint GCD(int a ,int b)\n{\n    int c;\n    int opcount=0;\n    if(b<a)\n    {   \n        a=a^b;\n        b=a^b;\n        a=a^b;\n    }\n    c=a;\n    while(1)\n    {\n        opcount++;\n        if(a%c==0 && b%c==0)\n        {\n            printf(\"opcount: %d\\n\",opcount);\n            return c;\n        }\n        c-=1;\n    }\n\n}\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",GCD(a,b));\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\ntypedef long long int ll;\nll** makeGraph(ll v)\n{\n    ll e;\n    ll** graph=(ll**)malloc(v*sizeof(ll*));\n    FOR(i,0,v)\n    {\n        graph[i]=malloc(v*sizeof(ll));\n    }\n    FOR(i,0,v)\n    {\n        FOR(j,0,v)\n        {\n            graph[i][j]=0;\n        }\n    }\n    scanf(\"%lld\",&e);\n    ll src,dest;\n    FOR(i,0,e)\n    {\n        scanf(\"%lld %lld\",&src,&dest);\n        graph[src][dest]=1;\n        graph[dest][src]=1;\n    }\n    return graph;\n}\nvoid dfs(ll** graph, ll* visited, ll v, ll src)\n{\n    visited[src]=1;\n    printf(\"%lld \",src);\n    \n    FOR(i,0,v)\n    {\n        if(graph[src][i])\n        {\n            if(!visited[i])\n            {\n                dfs(graph,visited,v,i);\n            }\n        }\n    }\n    return;\n}\nint main()\n{\n    ll v;\n    scanf(\"%lld\",&v);\n    ll** graph=makeGraph(v);\n    ll* visited=(ll*)malloc(v*sizeof(ll));\n    FOR(i,0,v)\n    {\n        visited[i]=0;\n    }\n    FOR(i,0,v)\n    {\n        if(!visited[i])\n        {\n            dfs(graph,visited,v,i);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n\nstruct adjLNode\n{\n    int dest;\n    struct adjLNode* next;\n\n};\nstruct adjList\n{\n    struct adjLNode* head;\n};\nstruct Graph\n{\n    int V;\n    struct adjList* arr;\n};\nstruct Graph* createGraph(int V)\n{\n    struct Graph* graph=(struct Graph*)malloc(sizeof(struct Graph));\n    graph->V=V;\n    graph->arr=(struct adjList*)malloc(V*sizeof(struct adjList));\n    for(int i=0;i<V;i++)\n    {\n        graph->arr[i].head=NULL;\n    }\n    return graph;\n}\nvoid addEdge(struct Graph* graph,int src,int dst)\n{\n    struct adjLNode* newNode=(struct adjLNode*)malloc(sizeof(struct adjLNode));\n    newNode->dest=dst;\n    newNode->next=graph->arr[src].head;\n    graph->arr[src].head=newNode;\n    struct adjLNode* newNode2=(struct adjLNode*)malloc(sizeof(struct adjLNode));\n    newNode2->dest=src;\n    newNode2->next=graph->arr[dst].head;\n    graph->arr[dst].head=newNode2;\n\n}\nvoid printGraph(struct Graph* graph)\n{\n    for(int i=0;i<graph->V;i++)\n    {\n        struct adjLNode* temp=graph->arr[i].head;\n        printf(\"The connected vertices to the vertex %d are- \\n\",i);\n        while(temp)\n        {\n            printf(\"%d \",temp->dest);\n            temp=temp->next;\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    int V;\n    printf(\"Please enter the number of vertices to your graph\\n\");\n    scanf(\"%d\",&V);\n    struct Graph* graph=createGraph(V);\n    int n;\n    printf(\"Please enter the number of Edges you want the graph to have\\n\");\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        int src,dst;\n        scanf(\"%d %d\",&src,&dst);\n        addEdge(graph,src,dst);\n    }\n    printGraph(graph);\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\nint power(int a,int b)\n{\n    int ans=1;\n    for(int i=0;i<b;i++)\n    {\n        ans*=a;\n    }\n    return ans;\n}\nint main()\n{\n    int sieve[10000];\n    for(int i=0;i<10001;i++)\n    {\n        sieve[i]=0;\n    }\n    sieve[1]=1;\n    sieve[0]=1;\n    int count=0;\n    for(int i=2;i<10001;i++)\n    {\n        if(sieve[i]==0)\n        {\n            count+=1;\n            for(int j=i*i;j<10001;j+=i)\n            {\n                sieve[j]=1;\n            }\n        }\n    }\n    int primes[count];\n    int j=0;\n    for(int i=0;i<10001;i++)\n    {\n        if(sieve[i]==0)\n        {\n            primes[j]=i;\n            j+=1;\n        }\n    }\n    \n    int a[count];\n    int b[count];\n    int c,d;\n    scanf(\"%d %d\",&c,&d);\n    int x,y;\n    x=c;\n    y=d;\n    int count1=0;\n    while(c>0)\n    {\n        int counts=0;\n        while(c>0)\n        {\n            if(c%primes[count1]!=0)\n            {\n                a[count1]=counts;\n                count1+=1;\n                break;\n            }\n            else\n            {\n                c\/=primes[count1];\n                counts+=1;\n            }\n        }\n        if(count1==count)\n        {\n            break;\n        }\n    }\n    int count2=0;\n    while(d>0)\n    {\n        int counts=0;\n        while(d>0)\n        {\n            if(d%primes[count2]!=0)\n            {\n                b[count2]=counts;\n                count2+=1;\n                break;\n            }\n            else\n            {\n                d\/=primes[count2];\n                counts+=1;\n            }\n        }\n        if(count2==count)\n        {\n            break;\n        }\n    }\n    \n    int pow;\n    int gcd=1;\n    for(int i=0;i<count;i++)\n    {\n        if(b[i]<a[i])\n        {\n            pow=b[i];\n        }\n        else\n        {\n            pow=a[i];\n        }\n        gcd*=(power(primes[i],pow));\n    }\n    printf(\"The GCD is %d \\n\",gcd);\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nint main()\n{\n    char str[50],substr[50];\n    int a,b,c,k=0,flag=0;\n    clock_t t1,t2;\n\n    printf(\"\\nEnter a string: \");\n    scanf(\"%[^\\n]%*c\",str);\n\n    printf(\"\\nEnter the substring to search: \");\n    scanf(\"%[^\\n]%*c\",substr);\n\n    t1=clock();\n    int opcount=0;\n    for (a=0;a<strlen(str);a++)\n    {\n        ++opcount;\n        c=a;\n        if (str[a]==substr[k])\n        {\n            for (b=0;b<=strlen(substr);b++)\n            {\n                ++opcount;\n                if (b==strlen(substr))\n                {\n                    flag=1;\n                    break;\n                }\n                if (str[c]==substr[b])\n                    c++;             \n                else if (str[c]!=substr[b])\n                {\n                    flag=0;\n                    break;\n                }             \n            }\n        }\n        if ( flag==1 ) break;\n    }\n    t2=clock();\n    printf(\"\\ntime taken is %ld\\n\",(t2-t1));\n\n    printf(\"\\nOpcount: %d\",opcount);\n    if (flag==1)\n        printf(\"\\nfound\\n\");\n    else \n        printf(\"\\nnot found\\n\");\n    \n    return 0;\n\n}\n"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>\n#include<string.h>\n\nint main(int argc,char* argv[]){\n    int rank,size;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=2){\n        printf(\"\\nUse 2 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"Enter string to toggle\\n\");\n        gets(st);\n        printf(\"\\nProcess[%d]: Sending string %s\\n\",rank,st);\n        MPI_Ssend(st,9,MPI_CHAR,1,0,MPI_COMM_WORLD);\n        MPI_Recv(res,9,MPI_CHAR,1,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received string %s\\n\",rank,res);\n    }else{\n        MPI_Recv(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received string %s\\n\",rank,st);\n    for(int i=0;i<strlen(st);i++){\n        if(st[i]>='a'&&st[i]<='z') st[i]-=32;\n        else if(st[i]>='A'&&st[i]<='Z') st[i]+=32;\n    }\n    printf(\"\\nProcess[%d]: Sending string %s\\n\",rank,st);\n        MPI_Ssend(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>t\n#include<string.h>\n\nint main(int argc,char* argv[]){\n    int rank,size,num;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=4){\n        printf(\"\\nUse 4 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"\\nProcess[%d]: Sending numbers\\n\",rank);\n        num=1;\n        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);\n        num=2;\n        MPI_Send(&num,1,MPI_INT,2,0,MPI_COMM_WORLD);\n        num=3;\n        MPI_Send(&num,1,MPI_INT,3,0,MPI_COMM_WORLD);\n        \n    }else{\n        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received %d\\n\",rank,num);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<mpi.h>\n#include<stdlib.h>\nint main(int argc, char* argv[])\n{\n    int rank, size;\n    int k;\n    int buff_size=MPI_BSEND_OVERHEAD+sizeof(int);\n    char* buff=(char*)malloc(buff_size*sizeof(int));\n    MPI_Init(&argc, &argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    int arr[7];\n    if(size!=8)\n    {\n        printf(\"\\nUse 8 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0)\n    {\n        MPI_Buffer_attach(buff,buff_size);\n        printf(\"Please enter 7 integers.\\n\");\n        for(int i=0;i<7;i++)\n        {\n            scanf(\"%d\",&arr[i]);\n        }\n        printf(\"Process[%d] sending the elements.\\n\",rank);\n        for(int i=1;i<8;i++)\n        {\n            MPI_Bsend(&arr[i-1],1,MPI_INT,i,0,MPI_COMM_WORLD);\n        }\n    }\n    else\n    {\n        MPI_Recv(&k,1,MPI_INT,0,0,MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        if(rank%2==0)\n        {\n            printf(\"Process[%d] recieved: %d and the square is: %d \\n\",rank, k,k*k);\n        }\n        else\n        {\n            printf(\"Process[%d] recieved: %d and the cube is: %d \\n\",rank, k,k*k*k);\n        }\n    }\n    MPI_Buffer_detach(buff, &buff_size);\n    MPI_Finalize();\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>\n\nlong fact(int a){\n    if(a==0) return 1;\n    return a*fact(a-1);\n}\n\nint main(int argc,char* argv[]){\n    int rank,size,*a=NULL,c;\n    long res,*b=NULL;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    a=(int*)malloc(size*sizeof(int));\n    b=(long*)malloc(size*sizeof(long));\n    if(rank==0){\n        printf(\"Enter %d numbers.\\n\",size);\n        for(int i=0;i<size;i++)\n            scanf(\"%d\",&a[i]);\n    }\n    MPI_Scatter(a,1,MPI_INT,&c,1,MPI_INT,0,MPI_COMM_WORLD);\n    res=fact(c);\n    printf(\"Process[%d]: Factorial of %d is %ld\\n\",rank,c,res);\n    MPI_Gather(&res,1,MPI_LONG,b,1,MPI_LONG,0,MPI_COMM_WORLD);\n    if(rank==0){\n        res=0;\n        for(int i=0;i<size;i++) res+=b[i];\n        printf(\"Process[%d]: The sum of all factorials is %ld\\n\",rank,res);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>\n\nint main(int argc,char* argv[]){\n    int rank,size,*a=NULL,*c=NULL;\n    float res,*b=NULL;\n    if(argc<1){\n        printf(\"Enter m as command line argument\");\n        exit(EXIT_FAILURE);\n    }\n    MPI_Init(&argc,&argv);\n    int m=atoi(argv[1]);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    a=(int*)malloc(m*size*sizeof(int));\n    b=(float*)malloc(size*sizeof(float));\n    c=(int*)malloc(m*sizeof(int));\n    if(rank==0){\n        printf(\"Enter %d numbers.\\n\",m*size);\n        for(int i=0;i<m*size;i++)\n            scanf(\"%d\",&a[i]);\n    }\n    MPI_Scatter(a,m,MPI_INT,c,m,MPI_INT,0,MPI_COMM_WORLD);\n    res=0;\n    for(int i=0;i<m;i++){\n        res+=c[i];\n    }\n    res\/=m;\n    printf(\"Process[%d]: Average is %f\\n\",rank,res);\n    MPI_Gather(&res,1,MPI_FLOAT,b,1,MPI_FLOAT,0,MPI_COMM_WORLD);\n    if(rank==0){\n        res=0;\n        for(int i=0;i<size;i++) res+=b[i];\n        res\/=size;\n        printf(\"Process[%d]: The overall average is %f\\n\",rank,res);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>\n#include<string.h>\nint main(int argc, char* argv[])\n{\n    int rank,size;\n    int res;\n    int s;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    char st[100];\n    char* c=(char*)malloc(sizeof(char)*100);\n    int* b=(int*)malloc(size*sizeof(int));\n    if(rank==0)\n    {\n        scanf(\"%s\",st);\n        int k=strlen(st);\n        if(k%size!=0)\n        {\n            printf(\"String length should be divisible by the number of processes.\");\n            return 0;\n        }\n        s=k\/size;\n    }\n    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);\n    MPI_Scatter(st,s,MPI_CHAR,c,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    res=0;\n    for(int i=0;i<s;i++)\n    {\n        \n        if(c[i]=='a'||c[i]=='e'||c[i]=='i'||c[i]=='o'||c[i]=='u')\n            continue;\n        res+=1;\n    }\n    \n    MPI_Gather(&res,1,MPI_INT,b,1,MPI_INT,0,MPI_COMM_WORLD);\n    if(rank==0)\n    {\n        res=0;\n        for(int i=0;i<size;i++)\n        {\n            res+=b[i];\n        }\n        printf(\"The total number of non vowels is:%d\\n\",res);\n    }   \n    MPI_Finalize();\n}   "}
{"target":"Dhruvik-Chevli","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<mpi.h>\n#include<string.h>\nint main(int argc, char* argv[])\n{\n    int rank,size;\n    int res;\n    int s;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    char st[100];\n    char st1[100];\n    char* a=(char*)malloc(sizeof(char)*100);\n    char* b=(char*)malloc(100*sizeof(char));\n    char* c=(char*)malloc(199*sizeof(char));\n    char* fst=(char*)malloc(sizeof(char)*200);\n    if(rank==0)\n    {\n        scanf(\"%s\",st);\n        int k=strlen(st);\n        if(k%size!=0)\n        {\n            printf(\"String length should be divisible by the number of processes.\");\n            return 0;\n        }\n        s=k\/size;\n        scanf(\"%s\",st1);\n    }\n    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);\n    MPI_Scatter(st,s,MPI_CHAR,a,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    res=0;\n    MPI_Scatter(st1,s,MPI_CHAR,b,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    for(int i=0;i<s;i++)\n    {\n        c[i*2]=a[i];\n        c[i*2+1]=b[i];\n    }\n    MPI_Gather(c,2*s,MPI_CHAR,fst,2*s,MPI_CHAR,0,MPI_COMM_WORLD);\n    if(rank==0)\n    {\n        printf(\"%s\\n\",fst);\n    }   \n    MPI_Finalize();\n}   "}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\nint main(){\n  int n, aux;\n  int cont = 0;\n  \n  scanf(\"%d\", &n);\n  \n  if(n < 1 || n > 1000000)\n    return 0;\n\n\n  while(n>0){\n    \n    if(n - 5  >= 0)\n      aux = 5;\n\n    else if(n - 4 >= 0)\n      aux = 4;\n\n    else if(n - 3 >= 0)\n      aux = 3;\n\n    else if(n - 2 >= 0)\n      aux = 2;\n\n    else if(n - 1 >= 0)\n      aux = 1;\n    \n\n    n -= aux;\n    cont++;\n  }\n\n  printf(\"%d\\n\", cont);\n  \n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\nint main(){\n  int n, k, aux, aux2;\n  int cont = 0;\n  \n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  \n  if(k < 1 || k > 50 ||n < 1\n     || n > 50 || k > n)\n    return 0;\n \n  for(int i = 1; i <= n; i++){\n\n    if(i <= k){\n      scanf(\"%d\", &aux);\n      if(aux >0)\n    cont++;\n      else\n    break;\n    }\n    \n    else if(i>k){\n      scanf(\"%d\", &aux2);\n      if(aux2 == aux)\n    cont++;\n    }\n    \n  }\n  \n  printf(\"%d\\n\", cont);\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\nvoid change(char s[], int i, int j);\n\nint main(){\n  int n, t;\n  \n  scanf(\"%d\", &n);\n  scanf(\"%d\", &t);\n\n  char s[n];\n  \n  if(n < 1 || t < 1\n     || n > 50 || t > 50)\n    return 0;\n  \n  scanf(\"%s\", s);\n  for(int j = 1; j <=t; j++)\n    for(int i = 0; i < n; i++)\n      if(i+1 < n)\n    if(s[i] == 'B' && s[i+1] == 'G'){\n      change(s, i, i+1);\n      i = i+1;\n    }\n  printf(\"%s\\n\", s);\n}\n\nvoid change(char s[], int i, int j){\n  char aux = s[i];\n  s[i] = s[j];\n  s[j] = aux;\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\nvoid change(int vector[],int i, int j);\nvoid quicksort(int vector[],int inf, int sup);\n\nint main(){\n  int x[4];\n  int a,b,c;\n  \n  for(int i = 0; i < 4; i++)\n    scanf(\"%d\", &x[i]);\n\n  quicksort(x, 0, 3);\n\n  b = (x[2] - x[1] + x[0]) \/ 2;\n  a = x[2] - b;\n  c = x[0]- b;\n  printf(\"%d %d %d\\n\", a, b, c);\n\n}\n\nvoid change(int vector[], int i, int j){\n  int aux;\n  \n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}\n\n\nvoid quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  \n  i = inf;\n  j = sup;\n  x = vector[(i+j)\/2];\n  \n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  \n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}\n\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n \n\n\nint get_numbers(int n, int max, int ns[], int i);\nvoid imprime(int ns[]);\nint check_number(int n, int ns[], int i);\nint valid_array(int ns[], int x);\nvoid quicksort(int vector[], int inf, int sup);\nvoid change(int vector[], int i, int j);\n  \nint main(){\n  int t, x;\n\n  scanf(\"%d\", &t);\n\n  for(int i = 1; i <= t; i++){\n    int numbers[9] = {0};\n    \n    scanf(\"%d\", &x);\n    \n    if(x < 10)\n      printf(\"%d\\n\", x);\n    \n    else{\n      \n      if(x > 45)\n        printf(\"-%d\\n\", 1);\n      \n      else{\n    get_numbers(x, 9, numbers, 0);\n    quicksort(numbers, 0, 9);\n    imprime(numbers);\n    }\n    }\n  }\n \n}\n\n\nint get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n\n  if(i == 10)\n    return 0;\n\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}\n\n\nint check_number(int n, int ns[], int i){\n  for(int j = 0; j <= i; j++)\n    if( n == ns[j])\n      return 0;\n  return 1;\n}\n\n\n\nint valid_array(int ns[], int x){\n  int sum;\n\n  sum = 0;\n  for(int i = 0; i < 9; i++)\n    sum += ns[i];\n  return (sum == x)? 1 : 0;\n}\n\n\nvoid imprime(int ns[]){\n  for(int i = 0; i < 9; i++)\n    if(ns[i] != 0)\n      printf(\"%d\", ns[i]);\n  printf(\"\\n\");\n}\n\n\n\nvoid change(int vector[], int i, int j){\n  int aux;\n  \n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}\n\nvoid quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  \n  i = inf;\n  j = sup;\n  x = vector[(i+j)\/2];\n  \n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  \n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n \n\n\nint get_numbers(int n, int max, int ns[], int i);\nvoid imprime(int ns[]);\nint check_number(int n, int ns[], int i);\nint valid_array(int ns[], int x);\nvoid quicksort(int vector[], int inf, int sup);\nvoid change(int vector[], int i, int j);\n  \nint main(){\n  int t, x;\n\n  scanf(\"%d\", &t);\n\n  for(int i = 1; i <= t; i++){\n    int numbers[9] = {0};\n    \n    scanf(\"%d\", &x);\n    \n    if(x < 10)\n      printf(\"%d\\n\", x);\n      else{\n    if(get_numbers(x, 9, numbers, 0)){\n      quicksort(numbers, 0, 9);\n      imprime(numbers);\n    }\n    else\n      printf(\"-%d\\n\", 1);\n      }\n  }\n \n}\n\n\n\nint get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n\n  if(i == 10)\n    return 0;\n\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}\n\n\nint check_number(int n, int ns[], int i){\n  for(int j = 0; j <= i; j++)\n    if( n == ns[j])\n      return 0;\n  return 1;\n}\n\n\n\nint valid_array(int ns[], int x){\n  int sum;\n\n  sum = 0;\n  for(int i = 0; i < 9; i++)\n    sum += ns[i];\n  return (sum == x)? 1 : 0;\n}\n\n\nvoid imprime(int ns[]){\n  for(int i = 0; i < 9; i++)\n    if(ns[i] != 0)\n      printf(\"%d\", ns[i]);\n  printf(\"\\n\");\n}\n\n\n\nvoid change(int vector[], int i, int j){\n  int aux;\n  \n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}\n\nvoid quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  \n  i = inf;\n  j = sup;\n  x = vector[(i+j)\/2];\n  \n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  \n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\n#define IN 1\n#define OUT 0\nmain(){\n  int c, state, aux, cont;\n  int wlong[10];\n  state = OUT;\n  cont = aux = 0;\n  for(int i = 0; i < 10; i++)\n    wlong[i] = 0;\n  \n  while((c = getchar()) != EOF){\n    if(c == 11 || c == 32 || c == 10){\n      state = OUT;\n      if(cont < 10){\n    aux = cont - 1;\n    wlong[aux]++;\n      }\n      else\n    wlong[9]++;\n    }\n    else {\n      if(state == OUT){\n      state = IN;\n      cont = 0;\n      }\n      cont++;\n    }\n  }\n  \n  for(int i = 0; i < 10; i++){\n    int r = i+1;\n    if(i < 9)\n      printf(\" %2d :\", r);\n    else\n      printf(\" +%d :\", i);\n    for(int l = 0; l < wlong[i]; l++)\n    printf( \"-\");    \n    printf(\"\\n\");\n  }\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n#define IN 1\n#define OUT 0\nmain(){\n  int c, state, aux, cont;\n  int wlong[10];\n  state = OUT;\n  cont  = aux = 0;\n  for(int i = 0; i < 10; i++)\n    wlong[i] = 0;\n  \n  while((c = getchar()) != EOF){\n    if(c == 11 || c == 32 || c == 10){\n      state = OUT;\n      if(cont < 10){\n    aux = cont - 1;\n    wlong[aux]++;\n      }\n      else\n    wlong[9]++;\n    }\n    else {\n      if(state == OUT){\n      state = IN;\n      cont = 0;\n      }\n      cont++;\n    }\n  }\n\n\n  aux = 0;\n  int e = 9;\n  for(int i = 0; i < 5; i++){\n    if(wlong[i] > wlong[e] && wlong[i] > aux)\n      aux = wlong[i];\n    else if(wlong[e] > aux)\n      aux = wlong[e];\n    e--;\n  }\n  \n  while(aux >= 1){\n    for(int i = 0; i < 10; i++){\n      if(wlong[i] >= aux)\n    printf(\"  | \");\n      else\n    printf(\"    \");\n    }\n    printf(\"\\n\");\n    aux--;\n  }\n  \n  cont = 0;\n  while(cont < 10){\n    int r = cont+1;\n    if(cont < 9)\n      printf(\" %2d \", r);\n    else\n      printf(\" +%d \\n\", cont);\n    cont++;\n  }\n  \n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\nmain(){\n  int c, aux, cont;\n  int abcd[28];\n  cont  = aux = 0;\n  for(int i = 0; i < 28; i++)\n    abcd[i] = 0;\n  \n  while((c = getchar()) != EOF){\n    switch(c){\n    case 32:\n      break;\n    case 9:\n      break;\n    case 10:\n      break;\n    case 65:\n      abcd[0]++;\n      break;\n    case 66:\n      abcd[1]++;\n      break;\n    case 67:\n      abcd[2]++;\n      break;\n    case 68:\n      abcd[3]++;\n      break;\n    case 69:\n      abcd[4]++;\n      break;\n    case 70:\n      abcd[5]++;\n      break;\n    case 71:\n      abcd[6]++;\n      break;\n    case 72:\n      abcd[7]++;\n      break;\n    case 73:\n      abcd[8]++;\n      break;\n    case 74:\n      abcd[9]++;\n      break;\n    case 75:\n      abcd[10]++;\n      break;\n    case 76:\n      abcd[11]++;\n      break;\n    case 77:\n      abcd[12]++;\n      break;\n    case 78:\n      abcd[13]++;\n      break;\n    case 165:\n      abcd[14]++;\n      break;\n    case 79:\n      abcd[15]++;\n      break;\n    case 80:\n      abcd[16]++;\n      break;\n    case 81:\n      abcd[17]++;\n      break;\n    case 82:\n      abcd[18]++;\n      break;\n    case 83:\n      abcd[19]++;\n      break;\n    case 84:\n      abcd[20]++;\n      break;\n    case 85:\n      abcd[21]++;\n      break;\n    case 86:\n      abcd[22]++;\n      break;\n    case 87:\n      abcd[23]++;\n      break;\n    case 88:\n      abcd[24]++;\n      break;\n    case 89:\n      abcd[25]++;\n      break;\n    case 90:\n      abcd[26]++;\n      break;\n      \n    case 97:\n      abcd[0]++;\n      break;\n    case 98:\n      abcd[1]++;\n      break;\n    case 99:\n      abcd[2]++;\n      break;\n    case 100:\n      abcd[3]++;\n      break;\n    case 101:\n      abcd[4]++;\n      break;\n    case 102:\n      abcd[5]++;\n      break;\n    case 103:\n      abcd[6]++;\n      break;\n    case 104:\n      abcd[7]++;\n      break;\n    case 105:\n      abcd[8]++;\n      break;\n    case 106:\n      abcd[9]++;\n      break;\n    case 107:\n      abcd[10]++;\n      break;\n    case 108:\n      abcd[11]++;\n      break;\n    case 109:\n      abcd[12]++;\n      break;\n    case 110:\n      abcd[13]++;\n      break;\n    case 164:\n      abcd[14]++;\n      break;\n    case 111:\n      abcd[15]++;\n      break;\n    case 112:\n      abcd[16]++;\n      break;\n    case 113:\n      abcd[17]++;\n      break;\n    case 114:\n      abcd[18]++;\n      break;\n    case 115:\n      abcd[19]++;\n      break;\n    case 116:\n      abcd[20]++;\n      break;\n    case 117:\n      abcd[21]++;\n      break;\n    case 118:\n      abcd[22]++;\n      break;\n    case 119:\n      abcd[23]++;\n      break;\n    case 120:\n      abcd[24]++;\n      break;\n    case 121:\n      abcd[25]++;\n      break;\n    case 122:\n      abcd[26]++;\n      break;\n    default:\n      abcd[27]++;\n      break;\n    }      \n  }\n  int r = 97;\n  for(int i = 0; i < 28; i++){\n    if(i < 27 ){\n      if(i != 14)\n    printf(\" %2c :\", r);\n      else{\n    printf(\"  \u00f1 :\");\n    r= r-1;\n      }\n      r++;\n    }\n    else\n      printf(\" Other characters :\");\n    \n    for(int l = 0; l < abcd[i]; l++)\n      printf( \"-\");    \n    printf(\"\\n\");\n  }\n  \n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n#define MAXLINE 1000 \n\nint getlinee(char line[], int maxline);\n\nint main(){\n  int len; \n  int max; \n  char line[MAXLINE];\n\n  max = 0;\n  while((len = getlinee(line, MAXLINE))> 0)\n    if(len > 80)\n      printf(\"%s\\n\", line);\n    \n  return 0;\n}\n\nint getlinee(char s[], int lim){\n  int c, i, j;\n  lim = lim - 2;\n  for(i = 0; (c = getchar()) != EOF && c != '\\n'; i++)\n    if(i < lim){\n      s[i] = c;\n      j = i;\n    }\n  if(j == lim - 1){\n    s[j] = '\\n';\n    j++;\n    s[j] = '\\0';\n    if(i > 0)\n      i++;\n  }\n  else{\n    if(c == '\\n'){\n      s[i] = c;\n      i++;\n    }\n    s[i] = '\\0';\n  }\n  return i;\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n#define MAXLINE 1000\n#define SPACES 8     \n\nint getlinee(void);\nvoid detab(void);\n\nchar line[MAXLINE];\nchar lineS[MAXLINE];\n\nint main (){\n  int len;\n  extern char lineS[];\n  \n  while((len = getlinee())  > 0 ){\n    detab();\n    printf(\"%s\", lineS);\n  }\n}\n\nint getlinee(void){\n  int c, i;\n  extern char line[];\n  \n  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\\n'; i++)\n    line[i] = c;\n  if(c == '\\n'){\n    line[i] = c;\n    ++i;\n  }  \n  line[i] = '\\0';\n  return i;\n}\n\n\nvoid detab(void){\n  extern char line[];\n  extern char lineS[];\n  int i, j;\n  \n  i = j = 0;\n  while(line[i] != '\\0'){\n    if(line[i] == '\\t')\n      for(int l = 0; l < SPACES; l++){\n    lineS[j] = ' ';\n    ++j;\n      }\n    else{\n      lineS[j] = line[i];\n      ++j;\n    }\n    ++i;\n  }\n  lineS[j] = '\\0';\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n#define MAXLINE 1000\n#define SPACES 8     \n\nint getlinee(void);\nvoid entab(void);\n\nchar line[MAXLINE];\nchar lineS[MAXLINE];\n\nmain(){\n  int len;\n  extern char lineS[];\n\n  while(getlinee() > 0 ){\n    entab();\n    printf(\"%s\", lineS);\n  }\n}\n\nint getlinee(void){\n  int c, i;\n  extern char line[];\n  \n  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\\n'; i++)\n    line[i] = c;\n  if(c == '\\n'){\n    line[i] = c;\n    ++i;\n  }  \n  line[i] = '\\0';\n  return i;\n}\n\n\nvoid entab(void){\n  extern char line[];\n  extern char lineS[];\n  int i, j, cont, aux;\n  \n  i = j = 0;\n  while(line[i] != '\\0'){\n    if(line[i] == ' '){\n      aux = i;\n      cont = 0;\n      while(line[aux] == ' '){\n    ++cont;\n    ++aux;\n      }\n      if(cont % 8 == 0)\n    while(cont > 0){\n      lineS[j] = '\\t';\n      ++j;\n      cont = cont - 8;\n    }\n      else{\n    if(cont > 8){\n      while(cont >= 8){\n        lineS[j] = '\\t';\n        ++j;\n        cont = cont - 8;\n      }\n      for(int l = 0; l < cont; l++){\n        lineS[j] = ' ';\n        ++j;\n      }\n    }\n    else\n      for(int l = 0; l < cont; l++){\n        lineS[j] = ' ';\n        ++j;\n      }\n      }\n      i = aux;\n    }\n    else{\n      lineS[j] = line[i];\n      ++j;\n      ++i;\n    }\n  }\n  lineS[j] = '\\0';\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <limits.h>\n\nint raise(int b, int n);\nlong l_raise(int base, int n);\nvoid main(){\n  printf(\"\\n\");\n  printf(\"Range values from standard headers:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [%d, %d]\\n\", CHAR_MIN, CHAR_MAX);\n  printf(\"short : [%d, %d]\\n\", SHRT_MIN, SHRT_MAX);\n  printf(\"int   : [%d, %d]\\n\", INT_MIN, INT_MAX);\n  printf(\"long  : [%ld, %ld]\\n\\n\", LONG_MIN, LONG_MAX);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", UCHAR_MAX);\n  printf(\"short : [0, %d]\\n\", USHRT_MAX);\n  printf(\"int   : [0, %u]\\n\", UINT_MAX);\n  printf(\"long  : [0, %lu]\\n\", ULONG_MAX);\n  printf(\"\\n\");\n  \n  printf(\"Range values by direct computation:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [-%d, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(char)*CHAR_BIT - 1) - 1);\n  \n  printf(\"short : [-%d, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(short)*CHAR_BIT - 1) - 1);\n  \n  printf(\"int   : [%d, %d]\\n\", raise(2, sizeof(int)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(int)*CHAR_BIT - 1) - 1);\n\n  printf(\"long  : [-%lu, %lu]\\n\\n\",\n     l_raise(2, sizeof(long)*CHAR_BIT - 1 ) ,\n     l_raise(2, sizeof(long)*CHAR_BIT - 1) - 1);\n\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT) - 1);\n  printf(\"short : [0, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT) - 1);\n  printf(\"int   : [0, %u]\\n\", raise(2, sizeof(int)*CHAR_BIT) - 1);\n  printf(\"long  : [0, %lu]\\n\", (unsigned long)(raise(2, sizeof(long)*CHAR_BIT))-1);\n}\n\nint raise(int base, int n){\n  if(n == 0)\n    return 1;\n  else{\n    return base * raise(base, n-1);\n  }\n}\n\nlong l_raise(int base, int n){\n  if(n == 0)\n    return 1;\n  else{\n    return base * l_raise(base, n-1);\n  }\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\nint htoi(char s[]);\nint hexa_to_int(char s);\nint get_decimal(int hexa[], int cont);\nint eleva(int base, int exp);\n\nvoid main(){\n  char s[100];\n  int res;\n  \n  scanf(\"%s\", s);\n  res = htoi(s);\n  if(res >= 0)\n    printf(\"%d\\n\",res);\n  else\n    printf(\"Invalid Input\\n\");\n}\n\n\nint htoi(char s[]){\n  int cont = 0;\n\n  if(s[0] != '0' || (s[1] != 'x' && s[1] != 'X'))\n     return -1;\n    \n  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')\n    || (s[i] >= 'A' && s[i] <= 'F'); i++, cont++)\n    ;\n  \n  int hexa[cont];\n  \n  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')\n    || (s[i] >= 'A' && s[i] <= 'F'); i++)\n    hexa[i-2] = hexa_to_int(s[i]);\n  \n  return get_decimal(hexa, cont);\n}\n\n\nint hexa_to_int(char s){\n  if(s == 'a' || s == 'A')\n    return 10;\n  if(s == 'b' || s == 'B')\n    return 11;\n  if(s == 'c' || s == 'C')\n    return 12;\n  if(s == 'd' || s == 'D')\n    return 13;\n  if(s == 'e' || s == 'E')\n    return 14;\n  if(s == 'f' || s == 'F')\n    return 15;\n  return s - '0';\n}\n\n\nint get_decimal(int hexa[], int cont){\n  int res = 0;\n  int exp = cont-1;\n  \n  for(int i = 0; i < cont; i++){\n    res += hexa[i] * eleva(16, exp--);\n  }\n  return res;\n}\n\n\nint eleva(int base, int exp){\n  if(exp == 0)\n    return 1;\n  else\n    return base * eleva(base, exp -1);\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n\nint binsearchv2(int x, int v[], int n);\nint binsearch(int x, int v[], int n);\nvoid selection_sort(int a[], int n);\nvoid change(int a[], int b, int c);\n\nint main(){\n  int x, r, rv2, n;\n  clock_t start, end;\n  double time;\n\n  printf(\"Size of the array\\n\");\n  scanf(\"%d\", &n);\n  int array[n];\n  \n  for(int i = 0; i < n; i++)\n    array[i] = rand() % n+1;\n  selection_sort(array, n);\n  \n  printf(\"============================\\n\");\n  for(int i = 0; i < n; i++)\n    printf(\"%d \", array[i]);\n  printf(\"\\n============================\\n\");\n  \n  printf(\"\\nNumber you're looking for: \");\n  scanf(\"%d\", &x);\n\n  start = clock();\n  r = binsearch(x, array, n);\n  r == -1 ? printf(\"\\n%d was not found\\n\", x) : printf(\"\\n%d was found on %d\\n\", x, r);\n  end = clock();\n  time = (double) (end-start)\/ CLOCKS_PER_SEC;\n  printf(\"On an array of %d elements, binsearch takes: %f segs\\n\", n, time);\n\n  start = clock();\n  rv2 = binsearchv2(x, array, n);\n  rv2 == -1 ? printf(\"\\n%d was not found\\n\", x) : printf(\"\\n%d was found on %d\\n\", x, rv2);\n  end = clock();\n  time = (double) (end-start)\/ CLOCKS_PER_SEC;\n  printf(\"On an array of %d elements, binsearchV2 takes: %f segs\\n\", n, time);\n}\n\n\nint binsearch(int x, int v[], int n){\n  int low, high, mid;\n  \n  low = 0;\n  high = n-1;\n  while(low <= high){\n    mid = (low+high) \/2;\n    if(x < v[mid])\n      high = mid - 1;\n    else if(x > v[mid])\n      low = mid + 1;\n    else \n      return mid;\n  }\n  return -1; \n}\n\n\n\nint binsearchv2(int x, int v[], int n){\n  int low, high, mid;\n  \n  low = 0;\n  high = n-1;\n  while(low < high){\n    mid = (low+high)\/2;\n    if(x < v[mid])\n      high = mid-1;\n    else\n      low = mid+1;\n  }\n\n  \n  if(v[low-1] == x)\n    return low-1;\n  else if(v[low] == x)\n    return low;\n  else if(v[low+1] == x)\n    return low+1;\n  \n  return -1; \n}\n\nvoid selection_sort(int a[], int n){\n  int smallest;\n  int k;\n  \n  for(int i = 0; i < n - 1; i++){\n    smallest = a[i];\n    k = i;\n    for(int j = i+1; j < n; j++)\n      if(a[j] < smallest){\n    smallest = a[j];\n    k = j;\n      }\n    if(i != k)\n      change(a, i, k);\n  }\n}\n\nvoid change(int a[], int b, int c){\n  int aux = a[b];\n  a[b] = a[c];\n  a[c] = aux;\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n\n\n#define MAXLINE 1000\n\nint getlinee(char line[]);\nvoid escape(char s[], char t[]);\nvoid inverse_escape(char s[], char t[]);\n\nint main(){\n  char s[MAXLINE];\n  char t[MAXLINE];\n  char r[MAXLINE];\n  int len = getlinee(s);\n\n  escape(s, t);\n  inverse_escape(t, r);\n  printf(\"word received:%s\", s);\n  printf(\"after escape:%s\\n\", t);\n  printf(\"inverse_escape:%s\", r);\n}\n\n\n\nint getlinee(char line[]){\n  int c, i;\n  \n  for(i = 0; i < MAXLINE - 1 && ( c = getchar()) != EOF && c != '\\n'; i++)\n    line[i] = c;\n  if(c == '\\n'){\n    line[i] = c;\n    ++i;\n  }  \n  line[i] = '\\0';\n  return i;\n}\n\n\nvoid escape(char s[], char t[]){\n  int i, j;\n\n  j = 0;\n  for(i = 0; s[i] != '\\0'; i++)\n    switch(s[i]){\n    case '\\n':\n      t[j++] = '\\\\';\n      t[j++] = 'n';\n      break;\n    case '\\t':\n      t[j++] = '\\\\';\n      t[j++] = 't';\n      break;\n    case '\\a':\n      \n      t[j++] = '\\\\';\n      t[j++] = 'a';\n      break;\n    case '\\b':\n      t[j++] = '\\\\';\n      t[j++] = 'b';\n      break;\n    case '\\f':\n      t[j++] = '\\\\';\n      t[j++] = 'f';\n      break;\n    case '\\r':\n      t[j++] = '\\\\';\n      t[j++] = 'r';\n      break;\n    case '\\v':\n      t[j++] = '\\\\';\n      t[j++] = 'v';\n      break;\n    case '\\\\':\n      t[j++] = '\\\\';\n      t[j++] = '\\\\';\n      break;\n    case '\\?':\n      t[j++] = '\\\\';\n      t[j++] = '?';\n      break;\n    case '\\'':\n      t[j++] = '\\\\';\n      t[j++] = '\\'';\n      break;\n    case '\\\"':\n      t[j++] = '\\\\';\n      t[j++] ='\\\"';\n      break;\n    default:\n      t[j++] = s[i];\n      break;\n    }\n  t[j] = '\\0';\n}\n\n\nvoid inverse_escape(char s[], char t[]){\n  int i, j;\n  \n  j = 0;\n  for(i = 0; s[i] != '\\0'; i++)\n    switch(s[i]){\n    case '\\\\':\n      switch(s[++i]){\n      case 'n':\n    t[j++] = '\\n';\n    break;\n      case 't':\n    t[j++] = '\\t';\n    break;\n      case 'a':\n    t[j++] = '\\a';\n    break;\n      case 'b':\n    t[j++] = '\\b';\n    break;\n      case 'f':\n    t[j++] = '\\f';\n    break;\n      case 'r':\n    t[j++] = '\\r';\n    break;\n      case 'v':\n    t[j++] = '\\v';\n    break;\n      case '\\\\':\n    t[j++] = '\\\\';\n    break;\n      case '?':\n    t[j++] = '\\?';\n    break;\n      case '\\'':\n    t[j++] = '\\'';\n    break;\n      case '\"':\n    t[j++] = '\\\"';\n    break;\n      }\n      break;\n    default:\n      t[j++] = s[i];\n      break;\n    }\n  t[j] = '\\0';\n}\n"}
{"target":"DiegoMendezMedina","func":"#include <stdio.h>\n\n#define MAXLINE 10000     \n\nint max;                  \nchar line [MAXLINE];      \nchar longest [MAXLINE];   \n\nint getlinee(void);\nvoid copy(void);\n\n\nint main(){\n  int len;\n  extern int max;\n  extern char longest [];\n\n  max = 0;\n  while((len = getlinee()) > 0)\n    if(len > max){\n      max = len;\n      copy();\n    }\n  if(max > 0)\n    printf(\"%s\\n\", longest);\n  return 0;\n}\n\n\nint getlinee(void){\n  int c, i;\n  extern char line[];\n\n  for(i = 0; i < MAXLINE -1\n    && (c = getchar()) != EOF && c != '\\n'; ++i)\n    line[i] = c;\n\n  if (c == '\\n'){\n    line[i] = c;\n    ++i;\n  }\n  line[i] = '\\0';\n  return i;\n}\n\n\nvoid copy(void){\n  int i;\n  extern char line[], longest[];\n\n  i = 0;\n  while((longest[i] = line[i]) != '\\0')\n    ++i;\n}\n"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid ngerearrange(int *arr, int n)\n{\n    int i, j;\n    for (i=0; i<n; i++)\n    {\n        for (j = i+1; j<n; j++)\n        {\n            if (*(arr + i) < *(arr + j))\n            {\n                *(arr + i) = *(arr + j);\n                break;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n\n    ngerearrange(arr, n);\n    printf(\"Rearranged Array : \\n\");\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n\n}"}
{"target":"dishanp","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n      int *a,n,i,j,t;\n      printf(\"Number of elements : \");\n      scanf(\"%d\",&n);\n      a=(int *)calloc(n, sizeof(int));\n      printf(\"\\nEnter %d Numbers: \\n\\n\",n);\n      for(i=0;i<=n-1;i++)\n      {\n            scanf(\"%d\", (a+i));\n      }\n      for(i=0;i<n-1;i++)\n      {\n            for(j=0;j<n-i-1;j++)\n            {\n                  if(*(a+j)>*(a+j+1))\n                  {\n                        t=*(a+j);\n                        *(a+j)=*(a+j+1);\n                        *(a+j+1)=t;\n                  }\n            }\n      }\n      printf(\"\\nAscending Order: \\n\");\n      for(i=0;i<n;i++)\n      printf(\"%d\\t\",*(a+i));\n      printf(\"\\n\") ;\n      return 0;\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\nint num = 0;\nint** readmatrix(int **A, int m, int n)\n{\n    A = (int**)malloc(m * sizeof(int*));\n    num = 0;\n    for(int i = 0 ; i < m ; i++)\n    {\n         A[i] = (int*)malloc(n * sizeof(int));\n    }\n    printf(\"Enter elements : \\n\");\n    for (int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            scanf(\"%d\", &A[i][j]);\n            if(A[i][j] != 0)\n                num++;\n        }\n    }\n    return A;\n}\nint** createsparserow(int **p, int m, int n)\n{\n    int r = num + 1;\n    int **sparse = (int**)malloc(r * sizeof(int*));\n    for(int i = 0 ; i < r ; i++)\n    {\n        sparse[i] = (int*)malloc(3 * sizeof(int));\n    }\n    sparse[0][0] = m;\n    sparse[0][1] = n;\n    sparse[0][2] = num;\n\n    int k = 1;\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            if(p[i][j] != 0)\n            {\n                sparse[k][0] = i;\n                sparse[k][1] = j;\n                sparse[k][2] = p[i][j];\n                k++;\n            }\n        }\n    }\n    return sparse;\n}\n\nint** createsparsecol(int **p, int m, int n)\n{\n    int c = num + 1;\n    int **sparse = (int**)malloc(3 * sizeof(int*));\n    for(int i = 0 ; i < 3 ; i++)\n    {\n        sparse[i] = (int*)malloc(c * sizeof(int));\n    }\n    sparse[0][0] = m;\n    sparse[1][0] = n;\n    sparse[2][0] = num;\n\n    int k = 1;\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            if(p[i][j] != 0)\n            {\n                sparse[0][k] = i;\n                sparse[1][k] = j;\n                sparse[2][k] = p[i][j];\n                k++;\n            }\n        }\n    }\n    return sparse;\n}\n\nvoid displayrowmajor(int **sp)\n{\n    printf(\"\\nRow Major Representation : \\n\\n\");\n    printf(\"\\tRows\\t\\tColumns\\t\\tValues\\n\");\n    for(int i = 0 ; i < num + 1 ; i++)\n    {\n        for(int j = 0 ; j < 3 ; j++)\n        {\n            printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nvoid displaycolmajor(int **sp)\n{\n    printf(\"\\nColumn Major Representation : \\n\\n\");\n    for(int i = 0 ; i < 3 ; i++)\n    {\n        for(int j = -1 ; j < num + 1 ; j++)\n        {\n            if(i == 0 && j == -1)\n                printf(\"Row\\t\");\n            else if(i == 1 && j == -1)\n                printf(\"Col\\t\");\n            else if(i == 2 && j == -1)\n                printf(\"Val\\t\");\n            else\n                printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int m, n;\n    printf(\"Enter number of rows and columns : \");\n    scanf(\"%d%d\", &m, &n);\n    int **A = NULL, **sparserow = NULL, **sparsecol = NULL;\n    A = readmatrix(A, m, n);\n    sparserow = createsparserow(A, m, n);\n    sparsecol = createsparsecol(A, m, n);\n    displayrowmajor(sparserow);\n    displaycolmajor(sparsecol);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int m, n;\n    printf(\"Enter number of rows (m) : \");\n    scanf(\"%d\", &m);\n    printf(\"Enter number of columns (n) : \");\n    scanf(\"%d\", &n);\n    int **mat;\n    mat = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < n ; i++)\n    {\n        mat[i] = malloc(n*sizeof(int));\n    }\n\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"Enter element at row %d, column %d : \", i, j);\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    printf(\"Before swapping : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    int f = 0;\n    int l = n - 1;\n    int temp;\n    while(f < l)\n    {\n        for(int i = 0; i < m ; i++)\n        {\n            temp = mat[i][f];\n            mat[i][f] = mat[i][l];\n            mat[i][l] = temp;\n        }\n        f++;\n        l--;\n    }\n\n    printf(\"After Swapping : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n\nint main()\n{\n   int i,n,a[100];\n\n\n   printf(\"number of elements to store in the array :\");\n   scanf(\"%d\",&n);\n\n   printf(\"Input %d number of elements in the array :\\n\",n);\n   for(i=0;i<n;i++)\n      {\n      printf(\"element - %d : \",i);\n      scanf(\"%d\",&a[i]);\n      }\n\n   printf(\"\\nvalues oF the array are : \\n\");\n   for(i=0;i<n;i++)\n     {\n       printf(\"% 5d\",a[i]);\n     }\n\n   printf(\"\\n values of array in reverse are :\\n\");\n   for(i=n-1;i>=0;i--)\n      {\n       printf(\"% 5d\",a[i]);\n      }\n   printf(\"\\n\\n\");\n}\n"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid rearrange(int *arr, int n)\n{\n    int i = -1, j = 0;\n    int t;\n    while (j != n)\n    {\n        if (arr[j] % 2 == 0)\n        {\n            i++;\n            \n            swap(&arr[i], &arr[j]);\n        }\n        j++;\n    }\n}\nint main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Original array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    rearrange(arr, n);\n    printf(\"\\nRearranged array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint mindist(int *arr, int n, int x, int y)\n{\n    int d = 100;\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(x == *(arr + i))\n        {\n            for(int j = i ; j < n ; j++)\n            {\n                if(y == *(arr + j) && d > (j - i))\n                {\n                    d = j - i ;\n                }\n            }\n        }\n    }\n    return d;\n}\nint main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Enter x & y : \");\n    scanf(\"%d%d\", &x,&y);\n\n    z = mindist(arr, n, x, y) ;\n    printf(\"The minimum distance between %d & %d : %d\\n\", x, y, z);\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid delete(struct node *p, int key)\n{\n    int index = 1;\n    struct node *q = NULL;\n\n    if(first->data == key)\n    {\n        printf(\"\\nKey found at node : %d\\n\\n\", index);\n    }\n    else\n    {\n        while(p->data != key)\n        {\n            q = p;\n            p = p->next;\n            index++;\n            if(p->next ==NULL && p->data != key)\n            {\n                printf(\"\\nKey is not present in list\\n\");\n            }\n        }\n        printf(\"Key found at node : %d\\n\", index);\n\n        q->next = p->next;\n        p->next = first;\n        first = p;\n        printf(\"Key moved to head\\n\\nNew list : \");\n        display(first);\n    }\n}\n\nint main()\n{\n    int n, key, index;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    \n    \n\n    printf(\"Enter key to be searched : \");\n    scanf(\"%d\", &key);\n    delete(first, key);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct element\n{\n    int row;\n    int col;\n    int x;\n};\nstruct sparse\n{\n    int r;\n    int c;\n    int num;\n    struct element *ele;\n};\nint main()\n{\n    struct sparse s;\n    int *A;\n    int n, m;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Diagonal Matrix\\n2 : Lower Triangular Matrix\\n\");\n    printf(\"3 : for Upper Triangular Matrix\\n4 : Tri-diagonal Matrix\\n\");\n    printf(\"5 : Toeplitz Matrix\\n6 : Symmetric Matrix\\n7 : Sparse Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions (same m & n values for options 1-6: \");\n    scanf(\"%d%d\",&m, &n);\n\n    switch(choice)\n    {\n        case 1 :\n        size = n;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i == j)\n                {\n                    A[i - 1] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i == j)\n                {\n                    printf(\"%d \", A[i - 1]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 2 :\n        size = n*(n + 1) \/ 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                {\n                    \n                    A[i*(i-1)\/2 + (j-1)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                {\n                    printf(\"%d \", A[i*(i-1)\/2 + (j-1)]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 3 :\n        size = n * (n + 1) \/ 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                {\n                    \n                    A[(n*(i-1) - (i-1)*(i-2)\/2) + (j-i)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                {\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)\/2) + (j-i)]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 4 :\n        size = (3 * n) - 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if((i - j) == 1)\n                    A[i-2] = t;\n                else if((i - j) == 0)\n                    A[n - 1 + i - 1] = t;\n                else if((i - j) == -1)\n                    A[(2*n) - 1 + i - 1] = t;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if((i - j) == 1)\n                    printf(\"%d \", A[i - 2]);\n                else if((i - j) == 0)\n                    printf(\"%d \", A[n - 1 + i - 1]);\n                else if((i - j) == -1)\n                    printf(\"%d \", A[(2*n) - 1 + i - 1]);\n                else\n                    printf(\"0 \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 5 :\n        size = (2 * n) - 1;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[j - i] = t;\n                else if(j < i)\n                    A[n + i - j - 1] = t;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[j - i]);\n                else if(j < i)\n                    printf(\"%d \", A[n + i - j - 1]);\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 6 :\n        size = n*(n + 1) \/ 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                {\n                    \n                    A[i*(i-1)\/2 + (j-1)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        int temp1,temp2;\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                {\n                    printf(\"%d \", A[i*(i-1)\/2 + (j-1)]);\n                }\n                else\n                {\n                    temp1 = i;\n                    temp2 = j;\n                    printf(\"%d \", A[temp2*(temp2-1)\/2 + (temp1-1)]);\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 7 :\n        s.r = m;\n        s.c = n;\n        int k = 0;\n        printf(\"\\nEnter number of non-zero elements : \");\n        scanf(\"%d\", &s.num);\n        s.ele = (struct element *)malloc(s.num*sizeof(struct element));\n        printf(\"\\nEnter all elements : \\n\");\n        for(int i = 1 ; i <= s.r ; i++)\n        {\n            for(int j = 1 ; j <= s.c ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(t != 0)\n                {\n                    s.ele[k].row = i;\n                    s.ele[k].col = j;\n                    s.ele[k].x = t;\n                    k++;\n                }\n            }\n        }\n        printf(\"\\nColumnar representation of the Sparse Matrix : \\n\");\n        printf(\"%d \", s.r);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].row);\n        }\n        printf(\"\\n%d \", s.c);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].col);\n        }\n        printf(\"\\n%d \", s.num);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].x);\n        }\n        printf(\"\\nDisplaying matrix from stored columnar representation : \\n\");\n        k = 0;\n        for(int i = 1 ; i <= s.r ; i++)\n        {\n            for(int j = 1 ; j <= s.c ; j++)\n            {\n                if(i == s.ele[k].row && j == s.ele[k].col)\n                {\n                    printf(\"%d \", s.ele[k].x);\n                    k++;\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int m, n;\n    printf(\"Enter dimensions (m,n) : \");\n    scanf(\"%d%d\", &m, &n);\n    int **p = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < m ; i++)\n    {\n        p[i] = (int*)malloc(n*sizeof(int));\n    }\n\n    printf(\"Enter elements : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n\n    printf(\"\\nThe matrix : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", p[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\nvoid reverse (int * data, int n)\n{\n      int i , j;\n      for (i = 0 , j = n-1; i < j ; i++, j--)\n      {\n            int temp = *(data + i) ;\n            *(data + i) = *(data + j) ;\n            *(data + j) = temp ;\n      }\n}\nint main()\n{\n      int i, j, n,*data;\n      printf(\"No of elements : \");\n      scanf(\"%d\", &n);\n      data = (int*) calloc(n, sizeof(int));\n      if(data == NULL)\n      {\n            printf(\"Error\");\n            return 1 ;\n      }\n      printf(\"\\n\");\n      for(i = 0; i < n; ++i)\n      {\n            printf(\"Enter Number %d: \", i + 1);\n            scanf(\"%d\", data + i);\n      }\n      reverse(data, n);\n\n\n      printf(\"\\n\");\n      for(i = 0; i < n; ++i)\n      {\n            printf(\"%d \", *(data + i));\n      }\n            printf(\"\\n\");\n}"}
{"target":"dishanp","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    int min1 = *arr;\n    int max1 = *arr;\n    int min2 = *arr;\n    int max2 = *arr;\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(max1 < *(arr + i))\n        {\n            max2 = max1;\n            max1 = *(arr + i);\n        }\n        \n        else if(max2 < *(arr +i) && *(arr +i) != max1)\n        {\n            max2 = *(arr +i);\n        }\n        if(min1 > *(arr +i))\n        {\n            min2 = min1;\n            min1 = *(arr + i);\n        }\n        else if(min2 > *(arr +i) && *(arr +i) != min1)\n        {\n            min2 = *(arr +i);\n        }\n    }\n    printf(\"Second smallest element : %d\\n\", min2);\n    printf(\"Second largest element : %d\\n\", max2);\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Distance\n{\n   int km;\n   float m;\n} d1, d2, result;\n\nvoid convert (struct Distance * r)\n{\n    \n   while (r->m > 1000.0)\n   {\n      r->m = r->m - 1000.0;\n      r->km++;\n   }\n}\nint main()\n{\n   printf(\"Enter 1st distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d1.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d1.m);\n   printf(\"\\nEnter 2nd distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d2.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d2.m);\n\n   result.km = d1.km + d2.km;\n   result.m = d1.m + d2.m;\n\n   convert(&result);\n\n   printf(\"\\nSum of distances = %dkm %.1fm\\n\", result.km, result.m);\n   return 0;\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid count_key(struct node *p, int key)\n{\n    int counter = 0;\n    while(p)\n    {\n        if(p->data == key)\n            counter++;\n        p = p->next;\n    }\n    printf(\"Occurences of %d : %d\\n\", key, counter);\n}\n\nint main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n\n    create(A, n);\n    printf(\"Enter key : \");\n    scanf(\"%d\", &key);\n    count_key(first, key);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid printPoly(int poly[], int n)\n{\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d\", poly[i]);\n        if (i != 0)\n            printf(\"x^%d\", i) ;\n        if (i != n-1)\n            printf(\" + \");\n    }\n    printf(\"\\n\");\n}\n\nint *add(int A[], int B[], int n, int m)\n{\n    int max;\n    if(m>n)\n        max = m;\n    else\n        max = n;\n    int *sum = (int*)malloc(max*sizeof(int));\n\n    for (int i = 0; i<n; i++)\n        sum[i] = A[i];\n\n    for (int i=0; i<m; i++)\n        sum[i] += B[i];\n\n    printPoly(sum, max);\n    return sum;\n}\n\nint main()\n{\n    int n, m;\n    printf(\"Enter number of terms for P1: \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    printf(\"\\nFirst polynomial : \");\n    printPoly(A, n);\n\n    printf(\"\\nEnter number of terms for P2: \");\n    scanf(\"%d\", &m);\n    int B[m];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < m ; i++)\n        scanf(\"%d\", &B[i]);\n    printf(\"\\nSecond polynomial : \");\n    printPoly(B, m);\n\n    printf(\"\\nSum of P1 and P2 : \");\n    int *sum = add(A, B, n, m);\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\nvoid swapval(int a , int b)\n{\n    int t = a;\n    a = b;\n    b = t;\n    printf(\"\\n\\nAfter swapping by value : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n}\nvoid swapref(int *a , int *b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nint main()\n{\n    int a, b ;\n    printf(\"Enter 2 variables a & b: \");\n    scanf(\"%d%d\", &a, &b);\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n    swapval(a, b);\n\n    swapref(&a, &b);\n    printf(\"\\n\\nAfter swapping by reference : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n    printf(\"\\n\");\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n\n\nint main()\n{\n    int source[100], dest[100];\n    int i, size;\n\n    printf(\"Enter the size of the array : \");\n    scanf(\"%d\", &size);\n\n    printf(\"Enter elements of source array : \");\n    for(i=0; i<size; i++)\n    {\n        scanf(\"%d  \", &source[i]);\n    }\n\n    for(i=0; i<size; i++)\n    {\n        dest[i] = source[i];\n    }\n\n    printf(\"\\nElements of source array are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d. \", source[i]);\n    }\n\n    printf(\"\\nElements of dest array are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d  \", dest[i]);\n    }\n\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\nvoid rearrange(int *arr, int n)\n{\n    int i = 0, j = n-1;\n    while (i < j)\n    {\n        while (arr[i]%2 == 0 && i < j)\n            i++;\n\n        while (arr[j]%2 == 1 && i< j)\n            j--;\n\n        if (i < j)\n        {\n            swap(&arr[i], &arr[j]);\n            i++;\n            j--;\n        }\n    }\n}\n\nint main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int l = 0 ; l < n ; l++)\n    {\n        printf(\"Enter element no %d :\", l+1);\n        scanf(\"%d\", arr + l);\n    }\n\n    rearrange(arr, n);\n    printf(\"Rearranged array : \\n\");\n    for(int m = 0 ; m < n ; m++)\n    {\n        printf(\"%d\", *(arr + m));\n    }\n    printf(\"\\n\");\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node* next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *last, *t;\n    int i;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid check_empty(struct node *p)\n{\n    if(!p)\n    {\n        printf(\"\\nList is empty\\n\");\n    }\n    else\n    {\n        printf(\"\\nList is not empty\\n\");\n    }\n}\n\nint length(struct node *p)\n{\n    int len = 0;\n    while(p)\n    {\n        len++;\n        p = p->next;\n    }\n    return len;\n}\n\nvoid insert(struct node *p, int index, int x)\n{\n    if(index < 0 || index > length(first))\n    {\n        printf(\"\\nInvalid index\\n\");\n        return;\n    }\n    struct node *t = (struct node*)malloc(sizeof(struct node));\n    t->data = x;\n\n    if(index == 0)\n    {\n        t->next = first;\n        first = t;\n    }\n    else\n    {\n        for(int i = 0; i < index - 1 ; i++)\n            p = p->next;\n        t->next = p->next;\n        p->next = t;\n    }\n}\n\nint delete_index(struct node *p, int index)\n{\n    if(index < 0 || index > length(first))\n    {\n        printf(\"\\nInvalid index\\n\");\n        return -1;\n    }\n\n    struct node *q = p;\n    int x = 0;\n\n    if(index == 1)\n    {\n        q = first;\n        x = first->data;\n        first = first->next;\n        free(q);\n        return x;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1; i++)\n        {\n            q = p;\n            p = p->next;\n        }\n        q->next = p->next;\n        x = p->data;\n        free(p);\n        return x;\n    }\n}\n\nint delete_key(struct node *p, int key)\n{\n    int index = 1;\n    struct node *q = NULL;\n\n    if(first->data == key)\n    {\n        q = first;\n        if(first->next != NULL)\n            first = first->next;\n        else\n            first = NULL;\n        free (q);\n        return index;\n\n    }\n    else\n    {\n        while(p->data != key)\n        {\n            q = p;\n            p = p->next;\n            index++;\n            if(p->next ==NULL && p->data != key)\n            {\n                printf(\"\\nKey is not present in list\\n\");\n                return -1;\n            }\n        }\n        q->next = p->next;\n        free(p);\n        return index;\n    }\n}\n\nint search(struct node *p, int key)\n{\n    int index = 1;\n    while(p)\n    {\n        if(key == p->data)\n        {\n            return index;\n        }\n        else\n        {\n            p = p->next;\n            index++;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int n,choice, index, x, key, len;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n\n    create(A, n);\n    do\n    {\n        printf(\"\\n\\n1 : Traversal of the list\\n2 : Check if the list is empty\\n\");\n        printf(\"3 : Insert a node at the certain position\\n4 : Delete a node at the certain position\\n\");\n        printf(\"5 : Delete a node for the given key\\n6 : Count the total number of nodes\\n\");\n        printf(\"7 : Search for an element in the linked list\\n8: EXIT\\n\");\n        printf(\"\\nEnter Choice : \");\n        scanf(\"%d\", &choice);\n\n        switch(choice)\n        {\n            case 1 :\n                display(first);\n                break;\n\n            case 2 :\n                check_empty(first);\n                break;\n\n            case 3 :\n                printf(\"\\nEnter position (0 for after zero nodes, 1 for after 1 node and so on..) : \");\n                scanf(\"%d\", &index);\n                printf(\"Enter data : \");\n                scanf(\"%d\", &x);\n                insert(first, index, x);\n                printf(\"New list : \");\n                display(first);\n                break;\n\n            case 4 :\n                printf(\"\\nEnter position (1 for 1st node, 2 for 2nd node and so on..): \");\n                scanf(\"%d\", &index);\n                x = delete_index(first, index);\n                printf(\"Data deleted at position %d : %d\\n\", index, x);\n                printf(\"New list : \");\n                display(first);\n                break;\n\n            case 5 :\n                printf(\"\\nEnter key : \");\n                scanf(\"%d\", &key);\n                index = delete_key(first, key);\n                if(index != -1)\n                {\n                    printf(\"% deleted at position : %d\\n\", key, index);\n                    printf(\"New list : \");\n                    display(first);\n                }\n                break;\n\n            case 6 :\n                len = length(first);\n                printf(\"\\nNumber of nodes : %d\\n\", len);\n                break;\n\n            case 7 :\n                printf(\"\\nEnter key : \");\n                scanf(\"%d\", &key);\n                index = search(first, key);\n                if(index != -1)\n                {\n                    printf(\"Element is present at position %d\\n\", index);\n                }\n                break;\n        }\n    }while(choice != 8);\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid reverse_m(struct node *p, int m)\n{\n    int counter = 0;\n    struct node *q = NULL;\n    struct node *r = NULL;\n\n    \n    while(counter < m)\n    {\n        r = q;\n        q = p;\n        p = p->next;\n        q->next = r;\n        counter++;\n    }\n    first = q;\n    \n    \n\n    \n    while(q->next != NULL)\n    {\n        q = q->next;\n    }\n    q->next = p;\n}\n\nint main()\n{\n    int n, m;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n\n    create(A, n);\n    printf(\"Enter value of m : \");\n    scanf(\"%d\", &m);\n    reverse_m(first, m);\n    display(first);\n\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid printPoly(int poly[], int n)\n{\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d\", poly[i]);\n        if (i != 0)\n            printf(\"x^%d\", i) ;\n        if (i != n-1)\n            printf(\" + \");\n    }\n    printf(\"\\n\");\n}\n\nint *multiply(int A[], int B[], int n, int m)\n{\n    int *prod = (int*)malloc((n + m - 1)*sizeof(int));\n\n    for (int i = 0; i < n + m - 1; i++)\n        prod[i] = 0;\n\n\n    for (int i = 0 ; i < n; i++)\n    {\n        for (int j = 0 ; j < m ; j++)\n            prod[i+j] += A[i]*B[j];\n    }\n\n    printPoly(prod, n+m-1);\n    return prod;\n}\n\nint main()\n{\n    int n, m;\n    printf(\"Enter number of terms for P1: \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    printf(\"\\nFirst polynomial : \");\n    printPoly(A, n);\n\n    printf(\"\\nEnter number of terms for P2: \");\n    scanf(\"%d\", &m);\n    int B[m];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < m ; i++)\n        scanf(\"%d\", &B[i]);\n    printf(\"\\nSecond polynomial : \");\n    printPoly(B, m);\n\n    printf(\"\\nProduct : \");\n    int *prod = multiply(A, B, n, m);\n\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n\nint main()\n{\n    int arr[100];\n    int i, j, n, count = 0;\n\n    printf(\"Enter size of the array : \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter elements in array : \");\n    for(i=0; i<n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    for(i=0; i<n; i++)\n    {\n        for(j=i+1; j<n; j++)\n        {\n            if(arr[i] == arr[j])\n            {\n                count++;\n                break;\n            }\n        }\n    }\n\n    printf(\"\\nTotal number of duplicate elements found in array = %d\", count);\n\n    return 0;\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid ngerearrange( int *arr, int n)\n{\n    int i, j;\n    for (i=0; i<n; i++)\n    {\n        for (j = i+1; j<n; j++)\n        {\n            if (*(arr + i) < *(arr + j))\n            {\n                *(arr + i) = *(arr + j);\n                break;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n\n    ngerearrange(arr, n);\n    printf(\"Rearranged Array : \\n\");\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\nstruct node\n{\n    int data;\n    struct node* next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    int i;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    \n    for(i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid reversedisplay(struct node *p)\n{\n    if(p)\n    {\n        reversedisplay(p->next);\n        printf(\"%d \", p->data);\n    }\n}\n\nint main()\n{\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    printf(\"\\nThe list : \");\n    display(first);\n    printf(\"\\n\");\n    printf(\"The elements in reverse are : \");\n    reversedisplay(first);\n    printf(\"\\n\");\n}\n\n\n"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid remduplicates(struct node *p)\n{\n    struct node *q, *r, *t;\n    while(p)\n    {\n        q = p->next;\n        r = p;\n\n        while(q)\n        {\n            if(p->data == q->data)\n            {\n                r->next = q->next;\n                t = q;\n                free(t);\n                q = q->next;\n            }\n            else\n            {\n                r = q;\n                q = q->next;\n            }\n        }\n        p = p->next;\n    }\n}\n\nint main()\n{\n    int n, m;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n    remduplicates(first);\n    display(first);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int *A;\n    int n;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Lower Triangular Matrix\\n\");\n    printf(\"2 : Upper Triangular Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions : \");\n    scanf(\"%d\", &n);\n\n    switch(choice)\n    {\n        case 1 :\n        size = n*(n + 1) \/ 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                    A[i*(i-1)\/2 + (j-1)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                    printf(\"%d \", A[i*(i-1)\/2 + (j-1)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n\n        case 2 :\n        size = n * (n + 1) \/ 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[(n*(i-1) - (i-1)*(i-2)\/2) + (j-i)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)\/2) + (j-i)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n    }\n\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n\nint main()\n{\n    int arr1[100], n,counter=0;\n    int i, j, k;\n\n       printf(\"Number of elements to be stored in the array :\");\n       scanf(\"%d\",&n);\n\n       printf(\"Input %d elements in the array :\\n\",n);\n       for(i=0;i<n;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr1[i]);\n        }\n\n    printf(\"\\nThe unique elements found in the array are : \\n\");\n    for(i=0; i<n; i++)\n    {\n        counter=0;\n\n        for(j=0; j<i-1; j++)\n        {\n            if(arr1[i]==arr1[j])\n            {\n                counter++;\n            }\n        }\n       for(k=i+1; k<n; k++)\n        {\n            if(arr1[i]==arr1[k])\n            {\n                counter++;\n            }\n        }\n       if(counter==0)\n        {\n          printf(\"%d \",arr1[i]);\n        }\n    }\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid rearrange( int *arr, int n)\n{\n    int *aux =(int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(i == 0)\n        *(aux + i) = *(arr + i) * (*(arr + i+1));\n        else if(i == (n - 1))\n        *(aux + i) = *(arr + i) * (*(arr + i-01));\n        else\n        *(aux + i) = (*(arr + i-1))  * (*(arr + i + 1));\n    }\n    for(int i = 0 ; i < n ; i++)\n    {\n        *(arr + i) = *(aux + i);\n    }\n}\nint main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    rearrange(arr, n);\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid sortinsert(struct node *p, int key)\n{\n    struct node *t, *q;\n    t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n\n    while(p && p->data < key)\n    {\n        q = p;\n        p = p->next;\n    }\n    \n    if(p == first)\n    {\n        t->next = first;\n        first = t;\n    }\n    else\n    {\n        t->next = p;\n        q->next = t;\n    }\n}\n\nint main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n\n    printf(\"Enter key : \");\n    scanf(\"%d\", &key);\n    sortinsert(first, key);\n    display(first);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Distance\n{\n   int km;\n   float m;\n} d1, d2, result;\n\nvoid convert (struct Distance * r)\n{\n\n   if (r->m > 1000.0)\n   {\n      r->m = r->m - 1000.0;\n      r->km++;\n   }\n}\nint main()\n{\n   printf(\"Enter 1st distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d1.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d1.m);\n   printf(\"\\nEnter 2nd distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d2.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d2.m);\n\n   result.km = d1.km + d2.km;\n   result.m = d1.m + d2.m;\n\n   convert(&result);\n\n   printf(\"\\nSum of distances = %dkm %.1fm\\n\", result.km, result.m);\n   return 0;\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\nint main()\n{\n    int arr1[100], arr2[100], arr3[200];\n    int n1, n2, n3;\n    int i, k;\n       printf(\"number of elements to be stored in the first array :\");\n       scanf(\"%d\",&n1);\n\n       printf(\"Input %d elements in the array :\\n\",n1);\n       for(i=0;i<n1;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr1[i]);\n        }\n       printf(\"Input the number of elements to be stored in the second array :\");\n       scanf(\"%d\",&n2);\n\n       printf(\"Input %d elements in the array :\\n\",n2);\n       for(i=0;i<n2;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr2[i]);\n        }\n    n3 = n1 + n2;\n    for(i=0;i<n1; i++)\n        {\n            arr3[i] = arr1[i];\n        }\n       int j = 0 ;\n     while(j<n2)\n        {\n            arr3[i] = arr2[j];\n            i++;\n            j++;\n        }\n   for(i=0;i<n3; i++)\n        {\n           for(k=0;k<n3-1;k++)\n             {\n\n                if(arr3[k]<=arr3[k+1])\n                 {\n                     \n                   j=arr3[k+1];\n                   arr3[k+1]=arr3[k];\n                   arr3[k]=j;\n                 }\n              }\n         }\n\n     printf(\"\\nThe merged array in decending order is :\\n\");\n    for(i=0; i<n3; i++)\n    {\n        printf(\"%d   \", arr3[i]);\n    }\n    printf(\"\\n\");\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\nvoid rowsort(int **mat, int m, int n)\n{\n    for (int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n - 1 ; j++)\n        {\n            for (int k = j + 1 ; k < n ; k++)\n            {\n                if (mat[i][j] > mat[i][k])\n                swap(&mat[i][j], &mat[i][k]);\n            }\n        }\n    }\n}\nvoid colsort(int **mat, int m , int n)\n{\n    for (int j = 0 ; j < n ; j++)\n    {\n        for (int i = 0 ; i < m - 1 ; i++)\n        {\n            for (int k = i + 1 ; k < m ; k++)\n            {\n                if (mat[i][j] < mat[k][j])\n                swap(&mat[i][j], &mat[k][j]);\n            }\n        }\n    }\n}\nint main()\n{\n    int m, n;\n    printf(\"Enter number of rows : \");\n    scanf(\"%d\", &m);\n    printf(\"Enter number of columns : \");\n    scanf(\"%d\", &n);\n\n    int **mat ;\n    mat = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < m ; i++)\n    {\n        mat[i] = (int*)malloc(n*sizeof(int));\n    }\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"Enter element at row %d, column %d : \", i, j);\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    printf(\"Before sorting : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    rowsort(mat, m ,n);\n    printf(\"After Sorting Rows : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    colsort(mat, m, n);\n    printf(\"After Sorting Columns : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first;\n\nstruct node_freq\n{\n    int data;\n    int freq;\n    struct node_freq *next;\n}*head;\n\nvoid create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}\n\nvoid insert(struct node_freq *p, int index, int key)\n{\n    struct node_freq *t = (struct node_freq *)malloc(sizeof(struct node_freq));\n    t->data = key;\n    t->freq = 0;\n\n    if(index == 0)\n    {\n        t->next = head;\n        head = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}\n\nvoid display_freq(struct node_freq *p)\n{\n    while(p)\n    {\n        printf(\"Frequency of element %d is %d\\n\", p->data, p->freq);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid frequency(struct node *p)\n{\n    struct node *q;\n    int c = 0, counter;\n    while(p)\n    {\n        counter = 0;\n        q = p->next;\n\n        while(q)\n        {\n            if(p->data == q->data)\n            counter++;\n            q = q->next;\n        }\n        if(counter == 0)\n        {\n            insert(head, c, p->data);\n            c++;\n        }\n        p = p->next;\n    }\n    \n    \n\n\n    struct node_freq *r = head;\n    while(r)\n    {\n        p = first;\n        while(p)\n        {\n            if(r->data == p->data)\n                r->freq++;\n            p = p ->next;\n        }\n        r = r->next;\n    }\n\n    display_freq(head);\n}\n\nint main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n\n    create(A, n);\n    frequency(first);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n\nint main()\n{\n    int a[1000],i,n,min,max;\n\n    printf(\"Enter size of the array : \");\n    scanf(\"%d\",&n);\n\n    printf(\"Enter elements in array : \");\n    for(i=0; i<n; i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n\n    min=max=a[0];\n    for(i=1; i<n; i++)\n    {\n         if(min>a[i])\n          min=a[i];\n           if(max<a[i])\n            max=a[i];\n    }\n    printf(\"minimum of array is : %d\",min);\n    printf(\"\\nmaximum of array is : %d\",max);\n\n\n    return 0;\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int *arr;\n    int n, k, temp;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Enter k : \");\n    scanf(\"%d\", &k);\n    \n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        for(int j = 0; j < n - 1 - i; j ++)\n        {\n            if(arr[j] > arr[j+1])\n            {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    printf(\"The kth smallest element : %d\\n\", arr[k-1]);\n    printf(\"The kth largest element : %d\\n\", arr[n-k]);\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*first = NULL, *even = NULL, *odd = NULL;\nstruct node *create(int A[], int n)\n{\n    struct node *p, *t, *last;\n    p = (struct node*)malloc(sizeof(struct node));\n    p->data = A[0];\n    p->next = NULL;\n    last = p;\n\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n    return p;\n}\n\nvoid display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nvoid inserteven(struct node *p, int index, int key)\n{\n    struct node *t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n\n    if(index == 0)\n    {\n        t->next = even;\n        even = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}\n\nvoid insertodd(struct node *p, int index, int key)\n{\n    struct node *t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n\n    if(index == 0)\n    {\n        t->next = odd;\n        odd = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}\n\nvoid convert(struct node *p)\n{\n    int ce = 0, co = 0;\n    while(p)\n    {\n        if(p->data%2 == 0)\n        {\n            inserteven(even, ce, p->data);\n            ce++;\n        }\n        else\n        {\n            insertodd(odd, co, p->data);\n            co++;\n        }\n        p = p->next;\n    }\n\n    first = even;\n    p = first;\n    while(p->next != NULL)\n        p = p->next;\n    p->next = odd;\n}\n\nint main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    first = create(A, n);\n    convert(first);\n    display(first);\n}"}
{"target":"dishanp","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    int max = arr[0];\n    int c = 0;\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(max == arr[i])\n        {\n            c++;\n        }\n        if(max < arr[i])\n        {\n            max = arr[i];\n        }\n    }\n    printf(\"Largest element is %d and it appears %d times\\n\", max, c);\n\n}"}
{"target":"dishanp","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid segregate (int *arr, int n)\n{\n    int i = 0;\n    int j = n - 1;\n    while(i < j)\n    {\n        while(arr[i] == 0 && i < j)\n        i++;\n\n        while(arr[j] == 1 && i < j)\n        j--;\n\n        if(arr[i] != 0 && arr[j] != 1 && i < j)\n        {\n            swap(&arr[i], &arr[j]);\n            i++;\n            j--;\n        }\n    }\n}\n\nint main()\n{\n    int *arr, n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element %d : \", i+1);\n        scanf(\"%d\", &arr[i]);\n    }\n    segregate(arr, n);\n    printf(\"Segregated array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n}"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int index;\n\nint **M;\n\nint **init_matrix(int n) {\n    int **matrix = (int **)malloc(sizeof(int *) * n);\n    for(int i = 0; i < n; i++) {\n        matrix[i] = (int *)malloc(sizeof(int) * n);\n    }\n    \n    return matrix;\n}\n\nint minimum(int i, int j, int **M, int *d) {\n    int min = 999, index = 0;\n\n    for(int k = i; k <= j -1; k++) {\n        if(M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j] < min) {\n            min = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];\n            index = k;\n        }\n    }\n    return index;\n}\n\n\nint minmult(int n, int *d, int **P) {\n    index i, j, k, diagonal;\n\n    for(int i = 1; i <= n; i++)\n        M[i][i] = 0;\n\n    for(diagonal = 1; diagonal <= n - 1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = minimum(i, j, M, d);\n            M[i][j] = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];\n            P[i][j] = k;\n        }\n    }\n    \n    printf(\"M = \\n\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++)\n            printf(\"%-4d\", M[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    return M[1][n];\n}\n\nvoid order(index i, index j, int **P) {\n    int k;\n\n    if(i == j) printf(\"A%d \", i);\n    else {\n        k = P[i][j];\n        printf(\"( \");\n        order(i, k, P);\n        order(k+1, j, P);\n        printf(\") \");\n    }\n}\n        \n\nvoid main() {\n    int n;\n\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    int **A = init_matrix(n);\n    int **P = init_matrix(n + 1);\n    M = init_matrix(n + 1);\n\n    int *d = (int *)malloc(sizeof(int) * (n + 1));\n\n    for(int i = 0; i < n; i++) {\n        printf(\"A%d = \", i);\n        scanf(\"%d %d\", &A[i][0], &A[i][1]);\n    }\n    printf(\"\\n\");\n    \n    d[0] = A[0][0];\n    for(int i = 0; i < n; i++)\n        d[i + 1] = A[i][1]; \n\n    printf(\"bestcase = %d\\n\\n\", minmult(n, d, P));\n\n    printf(\"P = \\n\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++)\n            printf(\"%4d\", P[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    printf(\"order = \");\n    order(0, n, P);\n    printf(\"\\n\");\n\n    printf(\"\\n\");\n    for(int diagonal = 1; diagonal <= n - 1; diagonal++) {\n        for(int i = 1; i <= n - diagonal; i++) {\n            int j = i + diagonal;\n            printf(\"M[%d][%d] = \", i, j);\n            order(i, j, P);\n            printf(\"= %d\\n\", M[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 9999\n\ntypedef int number;\ntypedef int index;\n\ntypedef struct _Edge {\n    int j;\n    int touch;\n    int length;\n} edge;\n\ntypedef edge set_of_edges;\n\nvoid dijkstra(int n, number **W, set_of_edges *F) {\n    index i, vnear;\n    edge e;\n    index touch[n];\n    number length[n];\n\n    for(i = 1; i < n; i++) {\n        touch[i] = 1;\n        length[i] = W[0][i];\n    }\n\n    for(int j = 0; j < n-1; j++) {\n        int min = INF;\n        for(i = 1; i < n; i++) {\n            if(0 <= length[i] && length[i] <= min) {\n                min = length[i];\n                vnear = i;\n            }\n        }\n        \n        e.j = vnear;\n        e.touch = touch[vnear];\n        e.length = length[vnear];\n\n        F[vnear].j = e.j;\n        F[vnear].touch = e.touch;\n        F[vnear].length = e.length;\n\n        \n        for(i = 1; i < n; i++) {\n            if(length[vnear] + W[vnear][i] < length[i]) {\n                length[i] = length[vnear] + W[vnear][i];\n                touch[i] = vnear + 1;\n            }\n        }\n        length[vnear] = -1;\n    }\n}\n\nint main() {\n    int num_of_Vertex;\n\n    printf(\"-----input-----\\n\");\n    printf(\"num of Vertex = \");\n    scanf(\"%d\", &num_of_Vertex);\n\n    edge F[num_of_Vertex];\n    number **W = (int **)malloc(sizeof(int) * num_of_Vertex);\n    for(int i = 0; i < num_of_Vertex; i++)\n        W[i] = (int *)malloc(sizeof(int) * num_of_Vertex);\n\n    printf(\"insert weight graph\\n\");\n    for(int i = 0; i < num_of_Vertex; i++)\n        for(int j = 0; j < num_of_Vertex; j++)\n            scanf(\"%d\", &W[i][j]);\n\n    dijkstra(num_of_Vertex, W, F);\n\n    printf(\"\\n-----output-----\\n\");\n    for(int i = 1; i < num_of_Vertex; i++) \n        printf(\"1 -> %d, length = %d, touch = %d\\n\",\n                F[i].j + 1, F[i].length, F[i].touch);\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid floyd2(int n, int **W, int **D, int **P) {\n    int i, j, k; \n\n    for(i = 0; i <= n; i++) \n        for(j = 0; j <= n; j++) \n            P[i][j] = 0;\n\n    for(i = 0; i <= n; i++) \n        for(j = 0; j <= n; j++) \n            D[i][j] = W[i][j]; \n\n    for(k = 1; k <= n; k++) \n        for(i = 1; i <= n; i++)\n            for(j = 1; j <= n; j++)\n                if(D[i][k] + D[k][j] < D[i][j]) { \n                    P[i][j] = k; \n                    D[i][j] = D[i][k] + D[k][j]; \n                }\n}\n\nvoid path(int q, int r, int **P) {\n    if(P[q][r] != 0) { \n        path(q, P[q][r], P); \n        printf(\"v%d -> \", P[q][r]);\n        path(P[q][r], r, P);\n    }\n}\n\nint** init_matrix(int size) { \n    int **matrix = (int**)malloc(sizeof(int*) * size); \n    for(int i = 0; i < size; i++) {\n        matrix[i] = (int*)malloc(sizeof(int) * size);\n        memset(matrix[i], 0, sizeof(int)*size); \n    }\n\n    return matrix;\n}\n\nvoid main() {\n\n    int n = 5; \n    int **W = init_matrix(n + 1); \n    int **D = init_matrix(n + 1); \n    int **P = init_matrix(n + 1);\n\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n\n    floyd2(n, W, D, P); \n\n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++)\n            printf(\"%d \", D[i][j]);\n        printf(\"\\n\");\n    }\n        \n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++)\n            printf(\"%d \", P[i][j]);\n        printf(\"\\n\");\n    }\n    \n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++) {\n            if(P[i][j] != 0) {\n                printf(\"Path v%d ~ v%d: v%d -> \", i, j, i); \n                path(i, j, P);\n                printf(\"v%d\\n\", j);\n            }\n        }\n    }\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nint n, *vindex, **W;\nbool promising(int);\n\nvoid hamiltonian(int i) {\n    for(int j = 1; j <= n-1; j++)\n        printf(\"%d \", vindex[j]);\n    printf(\"\\n\");\n\n    if(promising(i)) {\n        if(i == n-1) {\n            printf(\"vindex = \");\n            for(int j = 1; j <= n-1; j++)\n                printf(\"%d \", vindex[j]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int j = 2; j <= n; j++) {\n                vindex[i+1] = j;\n                hamiltonian(i+1);\n            }\n        }\n    }\n}\n\nbool promising(int i) {\n    int j = 1;\n    bool swtch;\n\n    if(i == n-1 && !W[vindex[n-1]][vindex[0]])\n        swtch = false;\n    else if(i > 0 && !W[vindex[i-1]][vindex[i]])\n        swtch = false;\n    else {\n        swtch = true;\n\n        while(j < i && swtch) {\n            if(vindex[i] == vindex[j]) swtch = false;\n            j++;\n        }\n    }\n    \n    return swtch;\n}\n\nvoid main() {\n    \n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++) {\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n        memset(W[i], 0, sizeof(int) * (n+1));\n    }\n    vindex = (int *)malloc(sizeof(int) * (n+1));\n    vindex[0] = 1;\n\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n\n    hamiltonian(0);\n}\n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef int index;\n#define YES 1\n#define NO 0\n\nint n, W, maxprofit, numbest;\nint *bestset, *include, *p, *w;\n\nbool promising(int, int, int);\n\nvoid knapsack(index i, int profit, int weight) {\n    printf(\"index\\t = %d\\n\", i);\n    printf(\"profit\\t = %d\\n\", profit);\n    printf(\"weight\\t = %d\\n\", weight);\n\n    if((weight <= W) && (profit > maxprofit)) {\n        maxprofit = profit;\n        numbest = i;\n        for(int j = 1; j <= n; j++)\n            bestset[j] = include[j];\n        printf(\"maxprofit = %d\\n\", maxprofit);\n    }\n\n    if(promising(i, profit, weight)) {\n        include[i+1] = YES;\n        knapsack(i+1, profit+p[i+1], weight+w[i+1]);\n        include[i+1] = NO;\n        knapsack(i+1, profit, weight);\n    }\n}\n\nbool promising(index i, int profit, int weight) {\n    index j, k;\n    int totweight;\n    float bound;\n\n    if(weight >= W) {\n        printf(\"x\\n\");\n        printf(\"\\n\");\n        return false;\n    }\n    else {\n        j = i+1;\n        bound = profit;\n        totweight = weight;\n        while((j <= n) && (totweight + w[j] <= W)) {\n            totweight = totweight + w[j];\n            bound = bound + p[j];\n            j++;\n        }\n\n        k = j;\n        if(k <= n) \n            bound = bound + (W-totweight) * p[k] \/ w[k];\n        printf(\"bound\\t = %.0f\\n\", bound);\n\n        if(bound > maxprofit) {\n            printf(\"\\n\");\n            return true;\n        }\n        else {\n            printf(\"x\\n\\n\");\n            return false;\n        }\n\n        return bound > maxprofit;\n    }\n}\n\n\nvoid main() {\n\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    bestset = (int *)malloc(sizeof(int) * n + 1);\n    include = (int *)malloc(sizeof(int) * n + 1);\n    \n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n\n    knapsack(0, 0, 0);\n\n    printf(\"bestset[1..n] = \");\n    for(int i = 1; i <= numbest; i++)\n        printf(\"%d \", bestset[i]);\n    printf(\"\\n\");\n\n    free(w);\n    free(p);\n    free(bestset);\n    free(include);\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nint n, *p, *w, W, maxprofit;\n\ntypedef struct node {\n    int level;\n    int profit;\n    int weight;\n    float bound;\n} node;\n\nint front = -1;\nint rear = -1;\nnode queue[MAX];\n\nbool empty() {\n    if(front == rear) return true;\n    else return false;\n}\n\nvoid insert(node v) {\n    rear = rear+1;\n    queue[rear].level = v.level;\n    queue[rear].profit = v.profit;\n    queue[rear].weight = v.weight;\n    queue[rear].bound = v.bound;\n}\n\nvoid rmove(node *v) {\n    front = front+1;\n    v->level = queue[front].level;\n    v->profit = queue[front].profit;\n    v->weight = queue[front].weight;\n    v->bound = queue[front].bound;\n}\n\nfloat bound(node u) {\n    int j, k, totweight;\n    float result;\n\n    if(u.weight >= W) return 0;\n    else {\n        result = u.profit; j = u.level + 1; totweight = u.weight;\n        while((j <= n) && (totweight + w[j] <= W)) {\n            totweight = totweight + w[j];\n            result = result + p[j];\n            j++;\n        }\n        k = j;\n        if(k <= n) result = result + (W - totweight) * p[k] \/ w[k];\n        return result;\n    }\n}\n\nvoid knapsack3() {\n    node u, v;\n    v.level = 0; v.profit = 0; v.weight = 0; v.bound = bound(v);\n    maxprofit = 0;\n    insert(v);\n    \n    while(!empty()) {\n        rmove(&v);\n\n        printf(\"%d profit: %3d weight: %3d bound: %3d maxprofit: %3d bound: %3d\\n\",\n                v.level, v.profit, v.weight, (int)bound(v), maxprofit, (int)v.bound);\n\n        if(v.bound > maxprofit) {\n            u.level = v.level + 1;\n            u.profit = v.profit + p[u.level];\n            u.weight = v.weight + w[u.level];\n\n            if((u.weight <= W) && (u.profit > maxprofit))\n                maxprofit = u.profit;\n\n            u.bound = bound(u);\n\n            if(bound(u) > (float)maxprofit) insert(u);\n\n            u.weight = v.weight;\n            u.profit = v.profit;\n            u.bound = bound(u);\n\n            if(u.bound > (float)maxprofit) insert(u);\n        }\n    }\n}\n            \n\n\n\n\nvoid main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    \n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n\n    knapsack3();\n\n    printf(\"maxprofit = %d\\n\", maxprofit);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef int set_pointer;\n\ntypedef struct _Edge {\n    int ui;\n    int uj;\n    int distance;\n} edge;\ntypedef edge set_of_edges;\n\ntypedef struct _Universe {\n    int parent;\n    int depth;\n} universe;\nuniverse *U;\n\nvoid makeset(int i) {\n    U[i].parent = i;\n    U[i].depth = 0;\n}\n\nset_pointer find(int i) {\n    int j;\n    j = i;\n    while(U[j].parent != j)\n        j = U[j].parent;\n\n    return j;\n}\n\nvoid merge(set_pointer p, set_pointer q) {\n    if(U[p].depth == U[q].depth) {\n        U[p].depth += 1;\n        U[q].parent = p;\n    }\n    else if(U[p].depth < U[q].depth) U[p].parent = q;\n    else U[q].parent = p;\n}\n\nbool equal(set_pointer p, set_pointer q) {\n    if(p == q) return true;\n    else return false;\n}\n\nvoid initial(int n) {\n    int i;\n    for(i = 0; i < n; i++) makeset(i);\n}\n\nint compare(const void *a, const void *b) {\n    edge *u = (edge *)a;\n    edge *v = (edge *)b;\n\n    if(u->distance < v->distance) return -1;\n    if(u->distance > v->distance) return 1;\n    return 0;\n}\n\nint num_of_Vertex, num_of_Edges;\nvoid kruskal(int n, int m, set_of_edges *E, set_of_edges *F) {\n    int i, j;\n    set_pointer p, q;\n    edge e;\n\n    qsort(E, num_of_Edges, sizeof(edge), compare);\n    initial(num_of_Vertex);\n\n    while(n < num_of_Vertex) {\n        e.ui = E[m].ui;\n        e.uj = E[m].uj;\n        e.distance = E[m].distance;\n\n        i = e.ui;\n        j = e.uj;\n\n        p = find(i);\n        q = find(j);\n\n        if(!equal(p, q)) {\n            merge(p, q);\n            F[n-1].ui = e.ui;\n            F[n-1].uj = e.uj;\n            F[n-1].distance = e.distance;\n\n            n++;\n        }\n\n        m++;\n    }\n}\n\nint main() {\n   printf(\"-----input-----\\n\");\n   printf(\"num of Vertex = \");\n   scanf(\"%d\", &num_of_Vertex);\n   printf(\"num of Edges = \");\n   scanf(\"%d\", &num_of_Edges);\n\n   U = (universe *)malloc(sizeof(universe) * num_of_Vertex);\n   edge *E = (edge *)malloc(sizeof(edge) * num_of_Edges);\n   edge *F = (edge *)malloc(sizeof(edge) * num_of_Edges);\n\n   for(int i = 0; i < num_of_Edges; i++) {\n       printf(\"insert edge = \");\n       scanf(\"%d %d %d\", &E[i].ui, &E[i].uj, &E[i].distance);\n   }\n\n   kruskal(1, 0, E, F);\n\n   int value = 0; \n   printf(\"\\n-----output-----\\n\");\n   for(int i = 0; i < num_of_Vertex -1; i++) {\n        printf(\"v%d - v%d = %d\\n\", F[i].ui, F[i].uj, F[i].distance);\n        value += F[i].distance;\n   }\n   printf(\"minimum spannig tree value = %d\\n\", value);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nint n, m, **W, *vcolor;\n\nbool promising(int i) {\n    bool swtch = true;\n    int j = 1;\n\n    while(j < i && swtch) {\n        if(W[i][j] && vcolor[i] == vcolor[j]) swtch = false;\n        j++;\n    }\n\n    return swtch;\n}\n\nvoid m_coloring(int i) {\n    \n    for(int color = 1; color <= n; color++)\n        printf(\"%d \", vcolor[color]);\n    printf(\"\\n\");\n\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"volor = \");\n            for(int color = 1; color <= n; color++)\n                printf(\"%d \", vcolor[color]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int color = 1; color <= m; color++) {\n                vcolor[i+1] = color;\n                m_coloring(i+1);\n            }\n        }\n    }\n}\n\nvoid main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"m = \");\n    scanf(\"%d\", &m);\n    printf(\"\\n\");\n\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++)\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n    vcolor = (int *)malloc(sizeof(int) * (n+1));\n    memset(vcolor, 0, sizeof(int) * (n+1));\n\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n\n    m_coloring(0);\n}\n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\nint n;\nint *col;\n\nbool promising(int i) {\n    bool swtch = true;\n    int k = 1;\n    \n    while(k < i && swtch) {\n        if(col[i] == col[k] || abs(col[i] - col[k]) == abs(i - k))\n            swtch = false;\n        k++;\n    }\n    return swtch;\n}\n\nvoid queens(int i) {\n    for(int j = 1; j <= n; j++)\n        printf(\"%d \", col[j]);\n    printf(\"\\n\");\n\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"\\nSolution = \");\n            for(int j = 1; j <= n; j++)\n                printf(\"%d \", col[j]);\n            printf(\"\\n\");\n            exit(1);\n        }\n        else {\n            for(int j = 1; j <= n; j++) {\n                col[i+1] = j;\n                queens(i+1);\n            }\n        }\n    }\n}\n\nvoid main() {\n    \n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    col = (int *)malloc(sizeof(int) * (n + 1));\n\n    queens(0);\n\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int index;\n\nfloat sum(int i, int j, float *p) {\n    float result = 0;\n\n    for(int k = i; k <= j; k++)\n        result += p[k];\n\n    return result;\n}\n\nint min(int i, int j, float **A, float *p) {\n    int index;\n    float min = 999;\n    \n    for(int k = i; k <= j; k++) {\n        if(A[i][k-1] + A[k+1][j] + sum(i, j, p) < min) {\n            min = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            index = k;\n        }\n    }\n\n    return index;\n}\n\nvoid optsearchtree(int n, float *p, float *minavg, index **R) {\n    index i, j, k, diagonal;\n    float **A = (float **)malloc(sizeof(float *) * (n + 2));\n    for(int t = 0; t < n + 2; t++)\n        A[t] = (float *)malloc(sizeof(float) * (n + 1));\n\n    for(i = 1; i <= n; i++) {\n        A[i][i-1] = 0;\n        A[i][i] = p[i];\n        R[i][i] = i;\n        R[i][i-1] = 0;\n    }\n\n    A[n+1][n] = 0;\n    R[n+1][n] = 0;\n\n    for(diagonal = 1; diagonal <= n-1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = min(i, j, A, p);\n            A[i][j] = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            R[i][j] = k;\n        }\n    }\n\n    printf(\"A = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%.3f \", A[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    *minavg = A[1][n];\n}\n\nvoid main() {\n    int n;\n    float minavg;\n\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    float *p = (float *)malloc(sizeof(float) * (n + 1));\n    int **R = (int **)malloc(sizeof(int *) * (n + 2));\n    for(int i = 0; i < n + 2; i++)\n        R[i] = (int *)malloc(sizeof(int) * (n + 1));\n\n    for(int i = 1; i <= n; i++) {\n        printf(\"Key[%d] = \", i);\n        scanf(\"%f\", &p[i]);\n    }\n    printf(\"\\n\");\n\n    optsearchtree(n, p, &minavg, R);\n    \n    printf(\"minavg = %.3f\\n\\n\", minavg);\n\n    printf(\"R = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%d \", R[i][j]);\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct set_of_edges {\n    int from;\n    int end;\n    int distance;\n} edge;\n\nint *nearest, *distance;\n\nvoid prim(int n, int **W, edge *F) {\n    int i, vnear, min;\n    edge e;\n\n    for(i = 2; i <= n; i++) {\n        nearest[i] = 1;\n        distance[i] = W[1][i];\n    }\n\n    printf(\"nearest = \");\n    for(i = 2; i <= n; i++) printf(\"%d \", nearest[i]);\n    printf(\"\\ndistance = \");\n    for(i = 2; i <= n; i++) printf(\"%d \", distance[i]);\n    printf(\"\\n\\n\");\n\n    for(int j = 0; j < n -1; j++) {\n        min = 999;\n        for(i = 2; i <= n; i++) \n            if(0 <= distance[i] && distance[i] <= min) {\n                min = distance[i];\n                vnear = i;\n            }\n        \n        e.from = nearest[vnear];\n        e.end = vnear;\n        e.distance = distance[vnear];\n\n        F[j].from = e.from;\n        F[j].end = e.end;\n        F[j].distance = e.distance;\n\n        distance[vnear] = -1;\n\n        printf(\"path : V%d -> V%d distance %d\\n\\n\", e.from, e.end, e.distance);\n\n        for(i = 2; i <= n; i++)\n            if(W[i][vnear] < distance[i]) {\n                distance[i] = W[i][vnear];\n                nearest[i] = vnear;\n            }\n\n        printf(\"nearest = \");\n        for(i = 2; i <= n; i++) printf(\"%d \", nearest[i]);\n        printf(\"\\ndistance = \");\n        for(i = 2; i <= n; i++) printf(\"%d \", distance[i]);\n        printf(\"\\n\\n\");\n\n    }\n}\nvoid main() {\n    int n = 0;\n\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    int **W = (int **)malloc(sizeof(int *) * (n + 1));\n    for(int i = 0; i <= n; i++)\n        W[i] = (int *)malloc(sizeof(int) * (n + 1));\n    nearest = (int *)malloc(sizeof(int) * (n + 1));\n    distance = (int *)malloc(sizeof(int) * (n + 1));\n    edge *F = (edge *)malloc(sizeof(edge) * n);\n\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++) \n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n\n    prim(n, W, F);\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint W;\nint *w, *include, *save;\n\nbool promising(int i, int weight, int total) {\n    if(! ((weight + total >= W) && (weight == W || weight + w[i+1] <= W))) {\n        if(weight + total >= W) printf(\"weight + total >= W\\n\");\n        else if(weight == W || weight + w[i+1] <= W) {\n            if (!(weight + w[i+1] <= W)) printf(\"weight + w[i+1] <= W\\n\");\n            else if(!(weight == W)) printf(\"weight == W\\n\");\n        }\n    }\n    else if(weight == W) printf(\" <- this is the solution\\n\");\n    else printf(\"\\n\");\n\n    return (weight + total >= W)\n        && (weight == W || weight + w[i+1] <= W);\n}\n\nvoid sum_of_subsets(int i, int weight, int total) {\n    printf(\"total: %d\\n\", total);\n    for(int j = 1; j <= i; j++)\n        printf(\"%d \", include[j]);\n\n    if(promising(i, weight, total)) {\n        if(weight == W) {\n            for(int j = 1; j <= i; j++)\n                save[i] = include[i];\n        }\n        else {\n            include[i+1] = 1;\n            sum_of_subsets(i+1, weight + w[i+1], total - w[i+1]);\n            include[i+1] = 0;\n            sum_of_subsets(i+1, weight, total - w[i+1]);\n        }\n    }\n}\n\nvoid main() {\n    int n, total;\n\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    printf(\"\\n\");\n\n    w = (int *)malloc(sizeof(int) * (n+1));\n    include = (int *)malloc(sizeof(int) * (n+1));\n    save = (int *)malloc(sizeof(int) * (n+1));\n\n    for(int i = 1; i <= n; i++) {\n        printf(\"w[%d] : \", i);\n        scanf(\"%d\", &w[i]);\n    }\n    printf(\"\\n\");\n\n    for(int i = 1; i <= n; i++) total += w[i];\n\n    sum_of_subsets(0, 0, total);\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n    int rfd, wfd;\n    char buffer[101];\n    size_t count;\n\n    if((rfd = open(argv[1], O_RDONLY)) == -1) {\n        perror(\"rfd file opening error\");\n        return 1;\n    }\n    if((wfd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0751)) == -1) {\n        perror(\"wfd file openning error\");\n        return 1;\n    }\n    while((count = read(rfd, buffer, 100)) > 0) {\n        if(write(wfd, buffer, count) < count) {\n            perror(\"file copying error\");\n            close(rfd);\n            close(wfd);\n            return 1;\n        }\n    }\n\n    puts(\"file copying success\");\n\n    close(rfd);\n    close(wfd);\n\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n    FILE *fp;\n\n    fp = fopen(argv[1], \"r+\");\n\n    long offset = atol(argv[2]);\n    int deletelen = atoi(argv[3]);\n\n    fseek(fp, 0, SEEK_END);\n    int filelen = ftell(fp);\n    char *buf = malloc(sizeof(char) * (filelen - offset - deletelen) +1);\n    char ch;\n    int count = 0;\n\n    fseek(fp, offset + deletelen, SEEK_SET);\n\n    while((ch = fgetc(fp)) != EOF) {\n        buf[count] = ch;\n        count++;\n    }\n\n    fseek(fp, offset, SEEK_SET);\n\n    fwrite(buf, sizeof(char), strlen(buf), fp);\n\n    truncate(argv[1], filelen - deletelen);\n\n    fclose(fp);\n    free(buf);\n\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n\n    int fd;\n    int offset = atoi(argv[2]);\n    int deletebyte = atoi(argv[3]);\n    int filelen, templen;\n    char *temp;\n\n    if((fd = open(argv[1], O_RDWR)) == -1) {\n        perror(\"file openning error\");\n        return 1;\n    }\n\n    if((filelen = lseek(fd, 0, SEEK_END)) == -1) {\n        perror(\"lseek END error\");\n        close(fd);\n        return 1;\n    }\n\n    templen = filelen - offset - deletebyte;\n    temp = malloc(sizeof(char) * templen + 1);\n\n    if(lseek(fd, offset +deletebyte, SEEK_SET) == -1) {\n        perror(\"lseek error\");\n        close(fd);\n        return 1;\n    }\n    \n    read(fd, temp, templen);\n    \n    if(lseek(fd, offset, SEEK_SET) == -1) {\n        perror(\"lseek error\");\n        close(fd);\n        return 1;\n    }\n\n    write(fd, temp, templen);\n\n    if(truncate(argv[1], filelen - deletebyte) == -1) {\n        perror(\"truncate error\");\n        close(fd);\n        return 1;\n    }\n\n    puts(\"file delete success\");\n\n    close(fd);\n    free(temp);\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"flash.h\"\n#include \"fdevicedriver.c\"\n#include <unistd.h>\n#include <sys\/types.h>\n\nFILE *flashfp;\n\nvoid optionC(char *fileName, int blocks);\nint optionW(char *fileName, int ppn, char *sectordata, char *sparedata);\nint optionR(char* fileName, int ppn);\nint emptyPage(int ppn);\nint emptyBlock();\nvoid copyBlock(int from, int to, int except);\nvoid copyPage(int from, int to);\nvoid insertPage(int ppn, char *sectordata, char *sparedata);\n\nchar pagebuf[PAGE_SIZE];\n\nint main(int argc, char *argv[])\n{   \n    char option = argv[1][0];\n    switch(option) {\n        case 'c' : optionC(argv[2], atoi(argv[3]));\n                   break;\n        case 'w' : optionW(argv[2], atoi(argv[3]), argv[4], argv[5]);\n                   break;\n        case 'r' : optionR(argv[2], atoi(argv[3]));\n                   break;\n        case 'e' : flashfp = fopen(argv[2], \"r+t\");\n                   dd_erase(atoi(argv[3]));\n                   break;\n    }\n    return 0;\n}\n\nvoid optionC(char *fileName, int blocks) {\n    int fileMemory = blocks * BLOCK_SIZE;\n    flashfp = fopen(fileName, \"w+t\");\n    truncate(fileName, fileMemory);\n    for(int i = 0; i < blocks; i++)\n        dd_erase(i);\n}\n\nint optionW(char *fileName, int ppn, char *sectordata, char *sparedata) {\n    char ch;\n    flashfp = fopen(fileName, \"r+t\");\n    int ppnBlock = ppn \/ 4;\n    fseek(flashfp, PAGE_SIZE * ppn, SEEK_SET);\n    if(ch = fgetc(flashfp) != 0xFF) {\n        int emptyBlockIndex = emptyBlock();\n        copyBlock(ppnBlock, emptyBlockIndex, ppn);\n        dd_erase(ppnBlock);\n        copyBlock(emptyBlockIndex, ppnBlock, ppn);\n        dd_erase(emptyBlockIndex);\n        insertPage(ppn, sectordata, sparedata);\n    }\n    else insertPage(ppn, sectordata, sparedata); \n}\n\nint optionR(char* fileName, int ppn) {\n    flashfp = fopen(fileName, \"r+t\");\n    dd_read(ppn, pagebuf);\n    for(int i = 0; i < SECTOR_SIZE && pagebuf[i] != (char)0xFF; i++)\n        printf(\"%c\", pagebuf[i]);\n    printf(\" \");\n    for(int i = SECTOR_SIZE; i < PAGE_SIZE && pagebuf[i] != (char)0xFF; i++)\n        printf(\"%c\", pagebuf[i]);\n}\n\nint emptyBlock() {\n    fseek(flashfp, 0, SEEK_END);\n    int blocks = ftell(flashfp) \/ BLOCK_SIZE;\n    int emptyBlock;\n    char ch;\n    for(int i = 0; i < blocks; i++) {\n        int emptyPageNum = 0;\n        for(int j = 0; j < PAGE_NUM; j++) {\n            fseek(flashfp, (BLOCK_SIZE * i) + (PAGE_SIZE * j), SEEK_SET);\n            if((ch = fgetc(flashfp)) != 0xFF) emptyPageNum++;\n            if(emptyPageNum == PAGE_NUM) emptyBlock = i;\n        }\n    }\n    return emptyBlock;\n}\n\nvoid copyBlock(int from, int to, int except) {\n    for(int i = 0; i < PAGE_NUM; i++) {\n        int fromPpn = from * PAGE_NUM + i;\n        int toPpn = to * PAGE_NUM + i;\n        if(fromPpn == except) i++;\n        copyPage(fromPpn, toPpn);\n    }\n}      \n\nvoid copyPage(int from, int to) {\n    dd_read(from, pagebuf);\n    dd_write(to, pagebuf);\n}\n\nvoid insertPage(int ppn, char *sectordata, char *sparedata) {\n    memset(pagebuf, (char)0xFF, PAGE_SIZE);\n    memcpy(pagebuf, sectordata, strlen(sectordata));\n    memcpy(pagebuf + SECTOR_SIZE, sparedata, strlen(sparedata));\n    dd_write(ppn, pagebuf);\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"person.h\"\n\nint heapsize = 0;\nvoid swap(Person *x, Person *y) {\n    Person temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid insert_heap(Person *person, Person *p) {\n    int i = ++heapsize;\n\n    memcpy(&person[i], p, sizeof(Person));\n\n    while((i != 1) && (strcmp(person[i].sn, person[i\/2].sn) == -1)) {\n        swap(&person[i], &person[i\/2]);\n        i = i\/2;\n    }\n\n}\n\nPerson delete_heap(Person *person) {\n    int parent, child;\n    Person item, temp;\n\n    item = person[1];\n    temp = person[heapsize--];\n    parent = 1;\n    child = 2;\n\n    while(child <= heapsize) {\n        if((child < heapsize) && (strcmp(person[child].sn, person[child+1].sn) == 1)) {\n            child++;\n        }\n        if(strcmp(temp.sn, person[child].sn) == -1)\n            break;\n        swap(&person[parent], &person[child]);\n        parent = child;\n        child *= 2;\n    }\n\n    person[parent] = temp;\n\n    return item;\n}\n\nvoid readPage(FILE *fp, char *pagebuf, int pagenum) {\n    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);\n    fread(pagebuf, sizeof(char), PAGE_SIZE, fp);\n}\n\nvoid writePage(FILE *fp, const char *pagebuf, int pagenum) {\n    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);\n    fwrite(pagebuf, sizeof(char), PAGE_SIZE, fp);\n}\n\n\nvoid pack(char *recordbuf, const Person *p) {\n    sprintf(recordbuf, \"%s#%s#%s#%s#%s#%s#\", p -> sn, p -> name, p -> age,  p -> addr, p -> phone, p -> email);\n    memset(recordbuf + strlen(recordbuf), (char)0xFF, RECORD_SIZE - strlen(recordbuf));\n}\n\nvoid unpack(const char *recordbuf, Person *p) {\n    sscanf(recordbuf, \"%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#\",\n    p -> sn, p -> name, p -> age, p -> addr, p -> phone, p -> email);\n}\n\nvoid setHeadPage(char *pagebuf, int pageNum, int recordNum, int deletePageNum, int deleteRecordNum) {\n    memset(pagebuf, 0xFF, PAGE_SIZE);\n    memcpy(pagebuf, &pageNum, sizeof(int));\n    memcpy(pagebuf+4, &recordNum, sizeof(int));\n    memcpy(pagebuf+8, &deletePageNum, sizeof(int));\n    memcpy(pagebuf+12, &deleteRecordNum, sizeof(int));\n}\n\nint main(int argc, char* argv[]) {\n    \n    FILE *fp1;\n    FILE *fp2;\n\n    fp1 = fopen(argv[2], \"r+\");\n    fp2 = fopen(argv[3], \"w+\");\n\n\n    char pagebuf[PAGE_SIZE + 1] = { }; \n    memset(pagebuf, (char)0xFF, PAGE_SIZE);\n    char *recordbuf = malloc(sizeof(char) * RECORD_SIZE);\n\n    int pageNum;\n    int recordNum;\n    int recordPerPage = PAGE_SIZE \/ RECORD_SIZE;\n    int recordCount = 0;\n    int recordCount_2 = 0;\n\n    readPage(fp1, pagebuf, 0);\n    memcpy(&pageNum, pagebuf, sizeof(int));\n    memcpy(&recordNum, pagebuf+4, sizeof(int));\n\n    char filebuf[PAGE_SIZE * pageNum + 1];\n    Person person[recordPerPage * pageNum];\n    Person *p = (Person*)malloc(sizeof(Person));\n\n    for(int i = 1; i < pageNum; i++) {\n        readPage(fp1, pagebuf, i);\n        for(int j = 0; j < recordPerPage; j++) {\n            if(recordCount == recordNum) break;\n            recordCount++;\n            int index = j * RECORD_SIZE;\n            int position = (i-1) * recordPerPage + j;\n            memcpy(recordbuf, pagebuf + index, RECORD_SIZE);\n            if(recordbuf[0] == '*' || recordbuf[0] == (char)0xFF) continue;\n            unpack(recordbuf, p);\n            insert_heap(person, p);\n            recordCount_2++;\n        }\n    }\n\n    recordCount = 0;\n    readPage(fp1, pagebuf, 0);\n    if(recordCount_2 % 2 == 0) pageNum = recordCount_2 \/ recordPerPage + 1;\n    else pageNum = recordCount_2 \/ recordPerPage + 2;\n    setHeadPage(pagebuf, pageNum, recordCount_2, -1, -1);\n    writePage(fp2, pagebuf, 0);\n\n    for(int i = 1; i < pageNum; i++) {\n        memset(pagebuf, (char)0xFF, PAGE_SIZE);\n        for(int j = 0; j < recordPerPage; j++) {\n            if(recordCount == recordCount_2) break;\n            recordCount++;\n            int index = j * RECORD_SIZE;\n            int position = (i-1) * recordPerPage + j;\n            memset(recordbuf, (char)0xFF, RECORD_SIZE);\n            Person temp = delete_heap(person);\n            pack(recordbuf, &temp);\n            memcpy(pagebuf + index, recordbuf, RECORD_SIZE);\n        }\n        writePage(fp2, pagebuf, i);\n    }\n}\n    \n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n\n    FILE *fp;\n\n    fp = fopen(argv[1], \"r+\");\n\n    long offset = atol(argv[2]);\n    int datalen = strlen(argv[3]);\n    fseek(fp, 0, SEEK_END);\n    long filelen = ftell(fp);\n    char *buf = malloc(sizeof(char) * (filelen - offset) +1);\n    char ch;\n    int count = 0;\n\n    fseek(fp, offset, SEEK_SET);\n\n    while((ch = fgetc(fp)) != EOF) {\n        buf[count] = ch;\n        count++;\n    }\n\n    fseek(fp, offset, SEEK_SET);\n\n    fwrite(argv[3], sizeof(char), datalen, fp);\n    fwrite(buf, sizeof(char), strlen(buf), fp);\n\n    fclose(fp);\n    free(fp);\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n\n    int fd;\n    int offset = atoi(argv[2]);\n    int inputlen = strlen(argv[3]);\n    int  filelen, diflen; \n    char *temp;\n    \n    if((fd = open(argv[1], O_RDWR)) == -1) {\n        perror(\"file openning error\");\n        return 1;\n    }\n\n    if((filelen = lseek(fd, 0, SEEK_END)) == -1) {\n        perror(\"lseek END error\");\n        close(fd);\n        return 1;\n    }\n\n    diflen = filelen - offset;\n    temp = malloc(sizeof(char) * diflen + 1);\n\n    if(lseek(fd, offset, SEEK_SET) == -1) {\n        perror(\"lseek offset error\");\n        close(fd);\n        return 1;\n    }\n\n    read(fd, temp, diflen);\n\n\n    if(lseek(fd, offset, SEEK_SET) == -1) {\n        perror(\"lseek offset error\");\n        close(fd);\n        return 1;\n    }\n\n    write(fd, argv[3], inputlen);\n    write(fd, temp, diflen);\n\n    puts(\"file insert success\");\n\n    close(fd);\n    free(temp);\n    return 0;\n}    \n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n\n    int wfd, rfd;\n    char buffer[101];\n    size_t count;\n\n    if((wfd = open(argv[1], O_RDWR)) == -1) {\n        perror(\"file1 openning error\");\n        return 1;\n    }\n\n    if((rfd = open(argv[2], O_RDONLY)) == -1) {\n        perror(\"file2 openning error\");\n        return 1;\n    }\n\n    if(lseek(wfd, 0, SEEK_END) == -1) {\n        perror(\"lseek END error\");\n        close(rfd);\n        close(wfd);\n        return 1;\n    }\n\n    while((count = read(rfd, buffer, 100)) > 0) {\n        if(write(wfd, buffer, count) < count) {\n            perror(\"file merge error\");\n            close(rfd);\n            close(wfd);\n            return 1;\n        }\n    }\n\n    puts(\"file merge success\");\n\n    close(rfd);\n    close(wfd);\n\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n\n    int fd;\n    int offset = atoi(argv[2]);\n    int len = strlen(argv[3]);\n\n    if((fd = open(argv[1], O_RDWR)) == -1) {\n        perror(\"rfd file openning error\");\n        return 1;\n    }\n\n    if(lseek(fd, offset, SEEK_SET) == -1) {\n        perror(\"lseek error\");\n        close(fd);\n        return 1;\n    }\n\n    write(fd, argv[3], len);\n\n    puts(\"file overwrite success\");\n\n    close(fd);\n\n    return 0;\n}\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    \n    char c;\n    int rfd;\n    int offset = atoi(argv[2]);\n    int readbyte = atoi(argv[3]);\n    int count = 0;\n\n    if((rfd = open(argv[1], O_RDONLY)) == -1) {\n        perror(\"file openning error\");\n        return 1;\n    }\n\n    if(lseek(rfd, offset, SEEK_SET) == -1) {\n        perror(\"lseek error\");\n        close(rfd);\n        return 1;\n    }\n    \n    while(read(rfd, &c, 1) !=0 && count < readbyte) {\n        write(1, &c, 1);\n        count++;\n    }\n\n    puts(\"file read success\");\n\n    close(rfd);\n    \n    return 0;\n}\n    \n\n\n"}
{"target":"dle2005","func":"#include <stdio.h>\n#include <sys\/types.h>\n#include <sys\/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SUFFLE_NUM 10000\n\nvoid GenRecordSequence(int *list, int n);\nvoid swap(int *a, int *b);\n\nint main(int argc, char* argv[]) {\n\n    FILE *fp = fopen(argv[1], \"r\");\n\n    struct timeval startTime, endTime;\n    int diffTime;\n\n    int *read_order_list;\n    int num_of_records;\n    int i;\n    char buffer[101];\n\n    fseek(fp, 0, SEEK_END);\n    num_of_records = ftell(fp) \/ 100;\n    read_order_list = malloc(sizeof(int) * num_of_records +1);\n\n    GenRecordSequence(read_order_list, num_of_records);\n\n    gettimeofday(&startTime, NULL);\n\n    for(i=0; i<num_of_records; i++) {\n        fseek(fp, read_order_list[i]*100, SEEK_SET);\n        fread(buffer, sizeof(char), 100, fp);\n        memset(buffer, 0, 100);\n    }\n\n    gettimeofday(&endTime, NULL);\n    diffTime = (endTime.tv_usec - startTime.tv_usec) * 1000;\n    printf(\"#records: %d timecost: %d us\\n\", num_of_records, diffTime);\n\n    return 0;\n}\n\nvoid GenRecordSequence(int *list, int n) {\n\n    int i, j, k;\n\n    srand((unsigned int)time(0));\n\n    for(i=0; i<n; i++)\n        list[i] = i;\n\n    for(i=0; i<SUFFLE_NUM; i++) {\n        j = rand() % n;\n        k = rand() % n;\n        swap(&list[j], &list[k]);\n    }\n\n    return;\n}\n\nvoid swap(int *a, int *b) {\n    \n    int tmp;\n\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n\n    return;\n}\n"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mulprec.h\"\n\nint setSign(struct NUMBER *, int);\nint getSign(struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a;\n    clearByZero(&a);\n    dispNumberZeroSuppress(&a);\n    setSign(&a, -1);\n    dispNumberZeroSuppress(&a);\n\n    return 0;\n}\n\n\nint setSign(struct NUMBER *a, int s) {\n    if(s == 1){\n        a->sign = 1;\n    } else if(s == -1){\n        a->sign = -1;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint getSign(struct NUMBER *a) {\n    if(a->sign == 1){ \n        return 1;\n    }\n    \n    return -1;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <math.h>\n\nint bisection(double, double, double *);\ndouble f(double);\nint sgn(double);\n\nint main(int argc, char ** argv)\n{\n    double a, b; \n    double x; \n    int r; \n\n    a = 1.0;\n    b = 4.0;\n    r = bisection(a, b, &x);\n    printf(\"x = %lf\\n\", x);\n    printf(\"\u623b\u308a\u5024 = %d\\n\", r);\n\n    return 0;\n}\n\n\nint bisection(double a,double b, double *x) {\n    double e; \n    double d; \n    double fx; \n    int as, bs, cs; \n\n    e = 1.e-7;\n    as = sgn(f(a)); \n    bs = sgn(f(b)); \n\n    if(as == bs){ \n        return -1; \n    }\n    \n    while(1){\n        d = (a + b) \/ 2.0;\n        fx = f(d);\n        cs = sgn(fx);\n        printf(\"now a = %lf\\n\", a);\n        printf(\"now b = %lf\\n\", b);\n        if(cs == as){\n            a = d;\n        }\n        if(cs == bs){\n            b = d;\n        }\n        if(fx == 0.0){ \n            break;\n        }\n        if(fabs(a - b) < e){ \n            break;\n        }\n    }\n\n    *x = d;\n    return 0;\n}\n\n\ndouble f(double x) {\n    return (cos(x\/2));\n}\n\n\nint sgn(double g) {\n    if(g < 0.0){\n        return -1;\n    }\n    if(g > 0.0){\n        return 1;\n    }\n    return 0;\n}"}
{"target":"earth429","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c, d, e;\n    int r;     \n\n    srandom(time(NULL)); \n\n    clearByZero(&a); \n    printf(\"a = \"); \n    dispNumberZeroSuppress(&a);\n    printf(\"\\n\");\n\n    setRnd(&b, 10); \n    printf(\"b = \"); \n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\");\n\n    copyNumber(&b, &c); \n    printf(\"c = \"); \n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\");\n\n    r = mulBy10(&b, &d); \n    printf(\"b * 10 = \"); \n    dispNumberZeroSuppress(&d);\n    printf(\", r = %d\\n\", r);\n\n    r = divBy10(&c, &e); \n    printf(\"c \/ 10 = \"); \n    dispNumberZeroSuppress(&e);\n    printf(\", r = %d\\n\", r);\n\n    printf(\"a == 0? --> %d\\n\", isZero(&a)); \n    printf(\"b == 0? --> %d\\n\", isZero(&b));\n    printf(\"c == 0? --> %d\\n\", isZero(&c));\n    printf(\"d == 0? --> %d\\n\", isZero(&d));\n    printf(\"e == 0? --> %d\\n\", isZero(&e));\n\n    return (0);\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint curt(struct NUMBER *, struct NUMBER *);\n\n\n\n        \n        multiple(&ox, &two, &dx); \n        \n\nint main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int j, r;\n    \n\n    srandom(time(NULL));\n\n    r = 27;\n    setInt(&r1, r);\n    \n    curt(&r1, &ans);\n    printf(\"r:%d\\nr1:\", r);\n    dispNumberZeroSuppress(&ans);\n    puts(\"\");\n\n    \n\n    return 0;\n}\n\n\nint curt(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER x, ox, tx, px, dx, zero, one, two, three, quotient, sum, rest; \n    setInt(&zero, 0);\n    setInt(&one, 1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n\n    quickDivide(a, &two, &x, &rest);\n    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ \n        copyNumber(a, b);\n        return 0;\n    }\n    if (numComp(&x, &zero) == -1){ \n        return -1;\n    }\n\n    copyNumber(&x, &ox);\n\n    while(1){\n        copyNumber(&ox, &tx); \n        copyNumber(&x, &ox); \n        power(&ox, &two, &px); \n        quickDivide(a, &px, &quotient, &rest);\n        multiple(&ox, &two, &dx); \n        add(&dx, &quotient, &sum);\n        quickDivide(&sum, &three, &x, &rest);\n\n        if(numComp(&x, &ox) == 0){ \n            break;\n        }\n        if(numComp(&x, &tx) == 0){ \n            if(numComp(&ox, &x) == -1){ \n                copyNumber(&ox, &x);\n            }\n            break;\n        }\n    }\n\n    copyNumber(&x, b);\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint decrement(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n\n    setInt(&a, 1);\n\n    return_val = decrement(&a, &b);\n    dispNumberZeroSuppress(&a);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint decrement(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n\n    setInt(&one, 1);\n    r = sub(a, &one, b);\n\n    return r;\n}"}
{"target":"earth429","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define KETA 10\n\nstruct NUMBER{\n    int n[KETA]; \n    int sign; \n};\n\nvoid clearByZero(struct NUMBER *);\nvoid dispNumber(struct NUMBER *);\nvoid setRnd(struct NUMBER *, int);\nvoid copyNumber(struct NUMBER *, struct NUMBER *);\nvoid getAbs(struct NUMBER *, struct NUMBER *);\nint isZero(struct NUMBER *);\nint mulBy10(struct NUMBER *, struct NUMBER *);\nint divBy10(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a;\n    struct NUMBER b, c, d;\n\n    srandom(time(NULL));\n\n    clearByZero(&a);\n    clearByZero(&b);\n    clearByZero(&c);\n    clearByZero(&d);\n\n    printf(\"a = \");\n    dispNumber(&a);\n    printf(\"\\n\");\n    printf(\"b = \");\n    dispNumber(&b);\n    printf(\"\\n\");\n    printf(\"c = \");\n    dispNumber(&c);\n    printf(\"\\n\");\n    printf(\"d = \");\n    dispNumber(&d);\n    printf(\"\\n\");\n\n    setRnd(&a, 3);\n\n    printf(\"a = \");\n    dispNumber(&a);\n    printf(\"\\n\");\n\n\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&a, &b));\n\n    printf(\"b = \");\n    dispNumber(&b);\n    printf(\"\\n\");\n\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&b, &c));\n\n    printf(\"c = \");\n    dispNumber(&c);\n    printf(\"\\n\");\n\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&c, &d));\n\n    printf(\"d = \");\n    dispNumber(&d);\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\nvoid clearByZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n\n    a->sign = 1;\n}\n\n\nvoid dispNumber(struct NUMBER *a){\n    int i;\n\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}\n\n\nvoid setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n\n    judge = random() % 2; \n\n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}\n\n\nvoid copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    b->sign = a->sign;\n\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}\n\n\nvoid getAbs(struct NUMBER *a, struct NUMBER *b){\n    copyNumber(a, b);\n    b->sign = 1;\n}\n\n\nint isZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nint mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n\n    b->n[0] = 0;\n\n    return 0;\n}\n\n\nint divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n\n    b->sign = a->sign; \n\n    remainder = a->sign * a->n[0]; \n\n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n\n    b->n[KETA -1] = 0;\n\n    return remainder;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint divide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c, d;\n    int return_val;\n    int x, y;\n\n    x = 5;\n    y = 3;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    printf(\"x = %d\\ny = %d\\nx \/ y = %d\\nx %% y = %d\", x, y, x \/ y, x % y);\n\n    return_val = divide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    dispNumberZeroSuppress(&d);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n\n    clearByZero(c);\n    clearByZero(d);\n\n    if(isZero(b) != -1){ \n        return -1;\n    }\n\n    copyNumber(a, &n);\n\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\nint doubleCos(double *, double, int);\ndouble factorial(double n) {\n    if (n > 0) {\n        return n * factorial(n - 1);\n    } else {\n        return 1;\n    }\n}\n\nint main(int argc, char **argv)\n{\n    double a;\n    double theta = 3.14;\n    int n = 100;\n    int return_val;\n\n    return_val = doubleCos(&a, theta, n);\n    printf(\"a = %f\\ntheta = %f\\n\", a, theta);\n    printf(\"cos = %f\\n\", cos(theta));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint doubleCos(double *a, double theta, int n) {\n    int i;\n\n    for (i = 0; i < n;i++){\n        \n        *a += pow(-1, i) \/ factorial(2 * i) * pow(theta, 2 * i);\n        \n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\nint doubleLog(double *, double, int);\n\nint main(int argc, char **argv)\n{\n    double a;\n    double x = 4.0;\n    int n = 1000;\n    int return_val;\n\n    return_val = doubleLog(&a, x, n);\n    printf(\"a = %f\\nx = %f\\n\", a, x);\n    printf(\"log = %f\\n\", log(x));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint doubleLog(double *a, double x, int n) {\n    int i;\n\n    for (i = 0; i < n;i++){\n        \n        *a += 2 \/ (2 * i + 1) * pow((x - 1) \/ (x + 1), 2 * i + 1);\n        \n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\nint doubleSin(double *, double, int);\ndouble factorial(double n) {\n    if (n > 0) {\n        return n * factorial(n - 1);\n    } else {\n        return 1;\n    }\n}\n\nint main(int argc, char **argv)\n{\n    double a;\n    double theta = 1.57;\n    int n = 100;\n    int return_val;\n\n    return_val = doubleSin(&a, theta, n);\n    printf(\"a = %f\\ntheta = %f\\n\", a, theta);\n    printf(\"sin = %f\\n\", sin(theta));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint doubleSin(double *a, double theta, int n) {\n    int i;\n\n    for (i = 0; i < n;i++){\n        \n        *a += pow(-1, i) \/ factorial(2 * i + 1) * pow(theta, 2 * i + 1);\n        printf(\"now = %f\\n\", *a);\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint factorial(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    int x;\n\n    x = 5;\n\n    setInt(&a, x);\n\n    return_val = factorial(&a, &b);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint factorial(struct NUMBER *a, struct NUMBER *b) {\n    \n    if(getSign(a) == -1){ \n        return -2;\n    }\n\n    struct NUMBER tmp1, tmp2, num;\n    setInt(&num, 1);\n    int flag = 0;\n\n    clearByZero(b);\n\n    while(1){\n        if(flag == 0){\n            flag++;\n            increment(&num, &tmp1);\n            multiple(&num, &tmp, b);\n            copyNumber(&tmp, &num);\n        } else {\n            increment(&num, &tmp1);\n            multiple(b, &tmp1, &tmp2);\n            copyNumber(&tmp2, b);\n        }\n\n        if(numComp(&tmp1, a) == 0){ \n            break;\n        }\n    }\n\n    return 0;\n\n    \n        \n    \n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint gcd(struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n\n    x = 1357911;\n    y = 246810;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    return_val = gcd(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint gcd(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER tmp, at, bt;\n\n    getAbs(a, &tmp);\n    copyNumber(&tmp, a);\n    copyNumber(&tmp, &at);\n    getAbs(b, &tmp);\n    copyNumber(&tmp, b);\n    copyNumber(&tmp, &bt);\n    clearByZero(c);\n\n    if(isZero(a) != -1 && isZero(b) != -1){ \n        return 0;\n    } else if(isZero(b) != -1) { \n        copyNumber(a, c);\n        return 0;\n    }\n\n    while(isZero(&tmp) == -1){\n        divide(a, b, c, &tmp);\n        copyNumber(b, a);\n        copyNumber(&tmp, b);\n    }\n\n    \n    copyNumber(a, c);\n    copyNumber(&at, a);\n    copyNumber(&bt, b);\n\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint increment(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n\n    setInt(&a, 1);\n\n    return_val = increment(&a, &b);\n    dispNumberZeroSuppress(&a);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint increment(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n\n    setInt(&one, 1);\n    r = add(a, &one, b);\n\n    return r;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint isPrime(struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n\n    x = 1357911;\n    y = 246810;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    return_val = gcd(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint isPrime(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER tmp;\n    \n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nvoid tailCall(struct NUMBER *, struct NUMBER *, struct NUMBER *);\nint factorial(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    int x;\n\n    x = 0;\n\n    setInt(&a, x);\n\n    printf(\"x = %d\\n\", x);\n    return_val = factorial(&a, &b);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nvoid tailCall(struct NUMBER *a, struct NUMBER *b, struct NUMBER *sofar){\n    struct NUMBER one, tmp1, tmp2;\n    setInt(&one, 1);\n    if(numComp(a, &one) != 1){ \n        copyNumber(sofar, b);\n    } else {\n        multiple(a, sofar, &tmp1);\n        decrement(a, &tmp2);\n        tailCall(&tmp2, b, &tmp1); \n    }\n}\n\n\nint factorial(struct NUMBER *a, struct NUMBER *b) {\n    if(isZero(a) != -1){ \n        setInt(b, 1);\n        return 0;\n    } else if(getSign(a) == -1){ \n        return -2;\n    }\n\n    struct NUMBER one;\n    setInt(&one, 1);\n\n    if(numComp(a, &one) == 0){ \n        setInt(b, 1);\n        return 0;\n    }\n\n    clearByZero(b);\n\n    tailCall(a, b, &one);\n\n    return 0;\n\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint multiple(struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    \n    int x, y;\n    int i;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < 10;i++){\n        x = (random() % 1000);\n        y = (random() % 1000);\n\n        setInt(&a, x);\n        setInt(&b, y);\n\n        printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n        dispNumberZeroSuppress(&a);\n        puts(\"\");\n        dispNumberZeroSuppress(&b);\n        puts(\"\");\n\n        multiple(&a, &b, &c);\n        setText(&c, x * y);\n        checkText();\n    }\n        \n\n    \n\n    return 0;\n}\n\n\nint multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER a_abs, b_abs, d, tmp;\n\n    clearByZero(c);\n\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        for (i = 0; i < KETA;i++){\n            bi = b->n[i];\n            h = 0;\n            clearByZero(&d);\n            for (j = 0; j < KETA;j++){\n                aj = a->n[j];\n                e = aj * bi + h; \n                if(j + i < KETA){ \n                    d.n[j + i] = (e % 10); \n                    e \/= 10;\n                    h = e; \n                }\n                \n            }\n            if(h != 0){ \n                return -1;\n            }\n            add(c, &d, &tmp);\n            copyNumber(&tmp, c);\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        multiple(a, &b_abs, c);\n        setSign(c, -1);\n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        multiple(&a_abs, b, c);\n        setSign(c, -1);\n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(a, &a_abs);\n        getAbs(b, &b_abs);\n        multiple(&a_abs, &b_abs, c);\n    }\n\n    return 0; \n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint lcm(struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n\n    x = 98765;\n    y = 43210;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    return_val = lcm(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint lcm(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER tmp, tmp2;\n    gcd(a, b, c);\n\n    if(isZero(c) != -1){ \n        return 0;\n    }\n\n    divide(a, c, &tmp, &tmp2);\n    dispNumberZeroSuppress(&tmp);\n    dispNumberZeroSuppress(b);\n    multiple(&tmp, b, c);\n\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\n\nvoid clearByZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n\n    setSign(a, 1);\n}\n\n\nvoid dispNumber(struct NUMBER *a){\n    int i;\n\n    if(getSign(a) == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}\n\n\nvoid dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n\n    if(getSign(a) == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n\n        if(i == 0){\n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%2d\", a->n[i]);\n    } \n}\n\n\nvoid setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n\n    clearByZero(a);\n\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n\n    judge = random() % 2; \n\n    switch (judge) {\n        case 1:\n            setSign(a, 1);\n            break;\n        case 0:\n            setSign(a, -1);\n            break;\n    }\n}\n\n\nvoid copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    clearByZero(b);\n\n    setSign(b, getSign(a));\n\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}\n\n\nvoid getAbs(struct NUMBER *a, struct NUMBER *b){\n    copyNumber(a, b);\n    setSign(b, 1); \n}\n\n\nint isZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nint mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    clearByZero(b);\n\n    setSign(b, getSign(a)); \n\n    \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n\n    b->n[0] = 0;\n\n    return 0;\n}\n\n\nint divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n\n    clearByZero(b);\n\n    setSign(b, getSign(a)); \n\n    remainder = getSign(a) * a->n[0]; \n\n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n\n    b->n[KETA - 1] = 0;\n\n    return remainder;\n}\n\n\nint setInt(struct NUMBER *a, int x) {\n    int digit = 1; \n    int i;\n\n    for (int i = x; i >= 10; i \/= 10) { \n        digit++;\n        if(digit > KETA) {\n            return -1;\n        }\n    }\n\n    clearByZero(a);\n\n    if(x > 0){\n        setSign(a, 1);\n    } else {\n        setSign(a, -1);\n    }\n\n    x = abs(x);\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = x % 10;\n        x \/= 10;\n    }\n\n    \n    \n\n    return 0;\n}\n\n\nvoid setText(struct NUMBER *a, int x) {\n    FILE *fp;\n    int i;\n\n    if ((fp = fopen(\"check.txt\", \"a\")) == NULL) {\n        printf(\"\u30d5\u30a1\u30a4\u30eb\u3092\u30aa\u30fc\u30d7\u30f3\u3067\u304d\u307e\u305b\u3093\u3002\\n\");\n    } else {\n        \n        fprintf(fp, \"%d\\t\", x);\n        \n        for (i = KETA - 1; i >= 0; i--) {\n            if(getSign(a) != 0){\n                break;\n            }\n\n            if(i == 0){\n                fprintf(fp, \"%d\", a->n[i]);\n            }\n        }\n        for (; i >= 0;i--) {\n            fprintf(fp, \"%d\", a->n[i]);\n        }\n        fprintf(fp, \"\\n\");\n\n        fclose(fp);\n    }\n}\n\n\nvoid checkText() {\n    FILE *fp;\n    int i;\n    int int_num;\n    int mul_num;\n\n    if ((fp = fopen(\"check.txt\", \"r\")) == NULL) {\n        printf(\"\u30d5\u30a1\u30a4\u30eb\u3092\u30aa\u30fc\u30d7\u30f3\u3067\u304d\u307e\u305b\u3093\u3002\\n\");\n    } else {\n        for (i = 0; i < TRY;i++){\n            \n            fscanf(fp, \"%d\", &int_num);\n            \n            fscanf(fp, \"%d\\n\", &mul_num);\n\n            if(int_num != mul_num){\n                printf(\"\u5024\u304c\u9055\u3044\u307e\u3059\\nint = %d\\nmul = %d\", int_num, mul_num);\n            }\n        }\n        fclose(fp);\n    }\n    \n}\n\n\nint setSign(struct NUMBER *a, int s) {\n    if(s == 1){\n        a->sign = 1;\n    } else if(s == -1){\n        a->sign = -1;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint getSign(struct NUMBER *a) {\n    if(a->sign == 1){ \n        return 1;\n    }\n    \n    return -1;\n}\n\n\nint numComp(struct NUMBER *a, struct NUMBER *b) {\n    int sa = getSign(a);\n    int sb = getSign(b);\n    int i;\n\n    if(sa > sb){ \n        return 1;\n    }\n\n    if(sa < sb){ \n        return -1;\n    }\n\n    if(sa == 1 && sb == 1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return 1;\n            } else if(a->n[i] < b->n[i]){\n                return -1;\n            }\n        }\n\n        return 0; \n    }\n\n    if(sa == -1 && sb == -1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return -1;\n            } else if(a->n[i] < b->n[i]){\n                return 1;\n            }\n        }\n\n        return 0; \n    }\n\n    \n    return 100;\n}\n\n\nint add(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int d; \n    int e = 0; \n    int i;\n    struct NUMBER a_abs, b_abs; \n\n    clearByZero(c);\n\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        for (i = 0; i < KETA;i++){\n            d = a->n[i] + b->n[i] + e;\n            c->n[i] = d % 10;\n            e = (d - c->n[i]) \/ 10; \n        }\n\n        if(e != 0){ \n            return -1;\n        }\n\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        sub(a, &b_abs, c);\n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        sub(b, &a_abs, c);\n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(a, &a_abs);\n        getAbs(b, &b_abs);\n        add(&a_abs, &b_abs, c);\n        setSign(c, -1);\n    }\n\n    return 0;\n}\n\n\nint sub(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int h = 0;\n    int i;\n    int return_val;\n    int x, y; \n    struct NUMBER a_abs, b_abs; \n\n    clearByZero(c);\n\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        return_val = numComp(a, b); \n\n        switch (return_val)\n        {\n        case 1: \n            for (i = 0; i < KETA;i++){\n                x = a->n[i] - h;\n                y = b->n[i];\n                if(a->n[i] < b->n[i]){\n                    c->n[i] = 10 + x - y;\n                    h = 1; \n                } else if(a->n[i] >= b->n[i]){\n                    c->n[i] = x - y;\n                    h = 0; \n                }\n            }\n            if(h != 0){ \n                return -1;\n            }\n            return 0; \n        case -1: \n            sub(b, a, c);\n            setSign(c, -1);\n            return 0;\n        case 0: \n            return 0;\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        add(&a_abs, b, c);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    }\n\n    return 100; \n}\n\n\nint increment(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n\n    setInt(&one, 1);\n    r = add(a, &one, b);\n\n    return r;\n}\n\n\nint decrement(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n\n    setInt(&one, 1);\n    r = sub(a, &one, b);\n\n    return r;\n}\n\n\n\nint multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    int flag_a = 0; \n    int flag_b = 0; \n\n    clearByZero(c);\n\n    for (i = 0; i < KETA;i++){\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j <= KETA;j++){\n            aj = a->n[j];\n            e = aj * bi + h; \n            d.n[j] = (e % 10); \n            e \/= 10;\n            h = (e % 10); \n            e \/= 10;\n            if(i == KETA && h != 0){ \n                return -1;\n            }\n        }\n        add(c, &d, c);\n    }\n\n    \n\n    return 0; \n}\n\n\nint divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n\n    clearByZero(c);\n    clearByZero(d);\n\n    if(isZero(b) != -1){ \n        return -1;\n    }\n\n    copyNumber(a, &n);\n\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\n\nvoid clearByZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n\n    a->sign = 1;\n}\n\n\nvoid dispNumber(struct NUMBER *a){\n    int i;\n\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}\n\n\nvoid dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n\n    if(a->sign == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n\n        if(i == 0){\n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%2d\", a->n[i]);\n    } \n}\n\n\nvoid setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n\n    clearByZero(a);\n\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n\n    judge = random() % 2; \n\n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}\n\n\nvoid copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    clearByZero(b);\n\n    b->sign = a->sign;\n\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}\n\n\nvoid getAbs(struct NUMBER *a, struct NUMBER *b){\n    copyNumber(a, b);\n    b->sign = 1; \n}\n\n\nint isZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nint mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n\n    clearByZero(b);\n\n    b->sign = a->sign; \n\n    \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n\n    \n\n    b->n[0] = 0;\n\n    return 0;\n}\n\n\nint divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n\n    clearByZero(b);\n\n    b->sign = a->sign; \n\n    remainder = a->sign * a->n[0]; \n\n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n\n    b->n[KETA - 1] = 0;\n\n    return remainder;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint multiple(struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\nint x, y;\n\n    x = 16;\n    y = 16;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n\n    return_val = multiple(&a, &b, &c);\n    printf(\"\\n\");\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    \n    \n\n    clearByZero(c);\n    dispNumberZeroSuppress(a);\n    dispNumberZeroSuppress(b);\n\n    for (i = 0; i < KETA;i++){\n        printf(\"i\u306f\u3053\u3053\u3067\u3059\u3088%d\\n\", i);\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j < KETA;j++){\n            aj = a->n[j];\n            printf(\"aj:%d\\nbi%d\\n\", aj, bi);\n            \n            \n            \n            \n            \n            e = aj * bi + h; \n            printf(\"e:%d\\n\", e); \n            if(j + i < KETA){\n                d.n[j + i] = (e % 10); \n                printf(\"dl:\");\n                dispNumberZeroSuppress(&d);\n                puts(\"\");\n                e \/= 10;\n                h = e; \n            }\n        }\n\n        if(h != 0){ \n            return -1;\n        }\n        printf(\"c:\");\n        dispNumberZeroSuppress(c);\n        printf(\"d:\");\n        dispNumberZeroSuppress(&d);\n        puts(\"\");\n        add(c, &d, &tmp);\n        copyNumber(&tmp, c);\n    }\n\n    \n\n    return 0; \n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <math.h>\n\ndouble newton(double);\ndouble f(double);\ndouble fdash(double);\n\nint main(int argc, char *argv)\n{\n    double x;\n    double x0;\n    int i;\n\n    for (i = -5; i <= 5;i++){\n        x0 = (double)i;\n        x = newton(x0);\n        printf(\"x0 = %10.6lf, x = %10.6lf\\n\", x0, x); \n        printf(\"f(x) = %10.6lf\\n\", f(x));\n    }\n\n    return 0;\n}\n\n\ndouble newton(double x0) {\n    double x; \n    double b; \n    double e; \n\n    e = 1.e-7;\n    x = x0;\n    b = x0;\n\n    while(1){\n        b = x; \n        x = b - (f(b) \/ fdash(b));\n        printf(\"now x = %10.6lf\\n\", x);\n\n        if(fabs(x - b) < e){ \n            break;\n        }\n    }\n\n    return x;\n}\n\n\ndouble f(double x) {\n    return (x * x + 4 * x + 5);\n}\n\n\ndouble fdash(double x) {\n    return (2 * x + 4);\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <math.h>\n\ndouble newton(double);\ndouble f(double);\ndouble fdash(double);\n\nint main(int argc, char *argv)\n{\n    double x;\n    double x0;\n    int i;\n\n    for (i = -5; i <= 5;i++){\n        x0 = (double)i;\n        x = newton(x0);\n        printf(\"x0 = %10.6lf, x = %10.6lf\\n\", x0, x); \n    }\n\n    return 0;\n}\n\n\ndouble newton(double x0) {\n    double x; \n    double b; \n    double e; \n\n    e = 1.e-7;\n    x = x0;\n    b = x0;\n\n    while(1){\n        b = x; \n        x = b - (f(b) \/ fdash(b));\n\n        if(fabs(x - b) < e){ \n            break;\n        }\n    }\n\n    return x;\n}\n\n\ndouble f(double x) {\n    return (x * x * x - 9 * x);\n}\n\n\ndouble fdash(double x) {\n    return (3 * x * x - 9.0);\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mulprec.h\"\n\nint numComp(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n\n    srandom(time(NULL));\n\n    clearByZero(&a);\n    clearByZero(&b);\n\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    setInt(&b, -1);\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    setInt(&a, -1);\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint numComp(struct NUMBER *a, struct NUMBER *b) {\n    int sa = getSign(a);\n    int sb = getSign(b);\n    int i;\n\n    if(sa > sb){ \n        return 1;\n    }\n\n    if(sa < sb){ \n        return -1;\n    }\n\n    if(sa == 1 && sb == 1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return 1;\n            } else if(a->n[i] < b->n[i]){\n                return -1;\n            }\n        }\n\n        return 0; \n    }\n\n    if(sa == -1 && sb == -1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return -1;\n            } else if(a->n[i] < b->n[i]){\n                return 1;\n            }\n        }\n\n        return 0; \n    }\n\n    \n    return 100;\n}"}
{"target":"earth429","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mulprec.h\"\n\nint power(struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    \n    int x, y;\n    int i;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < TRY;i++){\n        x = (random() % 10);\n        y = (random() % 10);\n\n        setInt(&a, x);\n        setInt(&b, y);\n\n        power(&a, &b, &c);\n        \n\n        setText(&c, pow(x, y));\n        checkText();\n    }\n\n    \n\n    return 0;\n}\n\n\nint power(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER i, tmp, i_tmp;\n    setInt(&i, 1);\n    clearByZero(c);\n\n    if(isZero(b) != -1){ \n        setInt(c, 1);\n        return 0;\n    } else if(numComp(b, &i) == 0){ \n        copyNumber(a, c);\n        return 0;\n    }\n\n    copyNumber(a, &tmp);\n\n    while(1){\n        \n        if(numComp(&i, b) != -1){ \n            break;\n        }\n        multiple(a, &tmp, c);\n        copyNumber(c, &tmp);\n\n        increment(&i, &i_tmp);\n        copyNumber(&i_tmp, &i);\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint quickDivide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d;\n    \n    int x, y;\n    \n\n    x = 49585;\n    y = 98;\n\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    printf(\"x = %d\\ny = %d\\nx \/ y = %d\\nx %% y = %d\\n\", x, y, x \/ y, x % y);\n\n    quickDivide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    puts(\"\");\n    dispNumberZeroSuppress(&d);\n    puts(\"\");\n\n    \n\n    double t2 = time(NULL);\n    printf(\"\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    \n    return 0;\n}\n\n\nint quickDivide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER tmp1, tmp2, a_tmp, e;\n\n    if(isZero(b) != -1){ \n        return -1;\n    }\n\n    \n    if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &tmp1);\n        divide(a, &tmp1, c, d);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &tmp1);\n        divide(&tmp1, b, c, d);\n        setSign(c, -1);\n        setSign(d, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0) { \n        getAbs(a, &tmp1);\n        getAbs(b, &tmp2);\n        divide(&tmp1, &tmp2, c, d);\n        setSign(d, -1);\n        return 0; \n    }\n\n    clearByZero(c); \n    copyNumber(a, &a_tmp);\n    clearByZero(d);\n\n    while(1){\n        if(numComp(&a_tmp, b) >= 0){ \n            copyNumber(b, d); \n            setInt(&e, 1); \n            while(1){ \n                if(numComp(&a_tmp, d) >= 0){\n                    mulBy10(d, &tmp1);\n                    copyNumber(&tmp1, d);\n                    mulBy10(&e, &tmp2);\n                    copyNumber(&tmp2, &e);\n                } else { \n                    divBy10(d, &tmp1); \n                    copyNumber(&tmp1, d);\n                    divBy10(&e, &tmp2);\n                    copyNumber(&tmp2, &e);\n                    break;\n                }\n            }\n            sub(&a_tmp, d, &tmp1); \n            copyNumber(&tmp1, &a_tmp);\n            add(c, &e, &tmp2); \n            copyNumber(&tmp2, c);\n            \n            printf(\"c:\");\n            dispNumberZeroSuppress(c);\n            puts(\"\");\n            printf(\"d:\");\n            dispNumberZeroSuppress(d);\n            puts(\"\");\n            printf(\"a_tmp:\");\n            dispNumberZeroSuppress(&a_tmp);\n            puts(\"\");\n        } else if(numComp(&a_tmp, b) < 0){ \n            copyNumber(&a_tmp, d);\n            break; \n        }\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mulprec.h\"\n\nint setInt(struct NUMBER *, int);\nvoid setText(struct NUMBER *, int);\nvoid checkText();\nvoid dispNumberNormal(struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    int i;\n    srandom(time(NULL));\n    struct NUMBER a;\n    setInt(&a, -101);\n    dispNumberZeroSuppress(&a);\n    for (i = 0; i < TRY;i++){\n        \n        \n        \n\n        \n\n        \n        \n        \n        \n    }\n    \n        \n\n    return 0;\n}\n\n\nint setInt(struct NUMBER *a, int x) {\n    int i;\n\n    clearByZero(a);\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = x % 10;\n        x = x \/ 10;\n    }\n\n    if(x > 0){\n        setSign(a, 1);\n    } else {\n        setSign(a, -1);\n    }\n\n        \n        return 0;\n}\n\n\nvoid setText(struct NUMBER *a, int x) {\n    FILE *fp;\n    int i;\n\n    if ((fp = fopen(\"check.txt\", \"a\")) == NULL) {\n        printf(\"\u30d5\u30a1\u30a4\u30eb\u3092\u30aa\u30fc\u30d7\u30f3\u3067\u304d\u307e\u305b\u3093\u3002\\n\");\n    } else {\n        \n        fprintf(fp, \"%d\\t\", x);\n        \n        for (i = KETA - 1; i >= 0; i--) {\n            if(a->n[i] != 0){\n                break;\n            }\n\n            if(i == 0){\n                fprintf(fp, \"%d\", a->n[i]);\n            }\n        }\n        for (; i >= 0;i--) {\n            fprintf(fp, \"%d\", a->n[i]);\n        }\n        fprintf(fp, \"\\n\");\n\n        fclose(fp);\n    }\n}\n\n\nvoid checkText() {\n    FILE *fp;\n    int i;\n    int int_num;\n    int mul_num;\n\n    if ((fp = fopen(\"check.txt\", \"r\")) == NULL) {\n        printf(\"\u30d5\u30a1\u30a4\u30eb\u3092\u30aa\u30fc\u30d7\u30f3\u3067\u304d\u307e\u305b\u3093\u3002\\n\");\n    } else {\n        for (i = 0; i < TRY;i++){\n            \n            fscanf(fp, \"%d\", &int_num);\n            \n            fscanf(fp, \"%d\\n\", &mul_num);\n\n            printf(\"int = %d\\nmul = %d\\n\\n\", int_num, mul_num);\n        }\n\n        fclose(fp);\n    }\n    \n}\n\n\nvoid dispNumberNormal(struct NUMBER *a){\n    int i;\n\n    \n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n\n        if(i == 0){\n            printf(\"%d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%d\", a->n[i]);\n    } \n}\n\n"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint simpleDivide(int, int, int *, int *);\n\nint main(int argc, char **argv)\n{\n    int a = 7;\n    int b = -3;\n    int c, d, return_val;\n\n    return_val = simpleDivide(a, b, &c, &d);\n    printf(\"c = %d\\n\", c);\n    printf(\"d = %d\\n\", d);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint simpleDivide(int x, int y, int * z, int * w){\n    int k;\n    int x_abs, y_abs;\n\n    if(y == 0){\n        return -1;\n    }\n\n    if(x == 0){\n        z = 0;\n        w = 0;\n        return 0;\n    }\n    \n    if(x > 0 && y > 0){\n        k = 0;\n        while(1){\n            if(x < y){\n                break;\n            }\n            x -= y;\n            k++;\n        }\n        *z = k; \n        *w = x; \n    } else if(x > 0 && y < 0){\n        y_abs = abs(y);\n        simpleDivide(x, y_abs, z, w);\n        *z *= -1;\n        *w *= -1;\n    } else if(x < 0 && y > 0){\n        x_abs = abs(x);\n        simpleDivide(x_abs, y, z, w);\n        *z *= -1;\n        *w *= -1;\n    } else {\n        x_abs = abs(x);\n        y_abs = abs(y);\n        simpleDivide(x_abs, y_abs, z, w);\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint simpleMultiple(int, int, int *);\n\nint main(int argc, char **argv)\n{\n    int a = -5;\n    int b = -3;\n    int c, return_val;\n\n    return_val = simpleMultiple(a, b, &c);\n    printf(\"c = %d\\n\",c);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n\n    return 0;\n}\n\n\nint simpleMultiple(int a, int b, int *c) {\n    int i = 1;\n    int tmp;\n    int flag_a = 0; \n    int flag_b = 0; \n\n    if(a < 0){\n        a = abs(a);\n        flag_a++;\n    } else if(b < 0){\n        b = abs(b);\n        flag_b++;\n    }\n\n    if(a < b){\n        tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    *c = a;\n\n    while(1){\n        *c += a;\n        i++;\n\n        if(i == b){\n            break;\n        }\n    }\n\n    if(flag_a != 0 && flag_b != 0){\n        \n    } else if(flag_a != 0){\n        *c *= -1;\n    } else if(flag_b != 0){\n        *c *= -1;\n    }\n\n    return 0; \n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint sqrt_newton(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int i, j, r;\n    double r2;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < 10;i++){\n        r = random();\n        setInt(&r1, r);\n        for (j = 0; j < 10;j++){\n            mulBy10(&r1, &tmp);\n            copyNumber(&tmp, &r1);\n        }\n        sqrt_newton(&r1, &ans);\n        printf(\"r1:\");\n        dispNumberZeroSuppress(&ans);\n        puts(\"\");\n        r2 = sqrt((double)r);\n        printf(\"r2:%f\\n\", r2);\n    }\n\n    return 0;\n}\n\n\nint sqrt_newton(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER x, ox, tx, zero, one, two, quotient, sum, rest; \n    clearByZero(b);\n    setInt(&zero, 0);\n    setInt(&one, 1);\n    setInt(&two, 2);\n\n    quickDivide(a, &two, &x, &rest);\n    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ \n        copyNumber(a, b);\n        return 0;\n    }\n    if (numComp(&x, &zero) == -1){ \n        return -1;\n    }\n\n    copyNumber(&x, &ox);\n    \n\n    while(1){\n        copyNumber(&ox, &tx);\n        copyNumber(&x, &ox);\n        quickDivide(a, &ox, &quotient, &rest);\n        add(&ox, &quotient, &sum);\n        quickDivide(&sum, &two, &x, &rest);\n\n        if(numComp(&x, &ox) == 0){ \n            break;\n        }\n        if(numComp(&x, &tx) == 0){ \n            if(numComp(&ox, &x) == -1){ \n                copyNumber(&ox, &x);\n            }\n            break;\n        }\n        \n    }\n\n    copyNumber(&x, b);\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\nint sqrt_newton(int);\n\nint main(int argc, char **argv)\n{\n    int i, r, r1, r2, d;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < 10;i++){\n        r = random();\n        r1 = sqrt_newton(r);\n        r2 = (int)sqrt((double)r);\n        d = r1 - r2;\n        printf(\"%6d - %6d = %d\\n\", r1, r2, d);\n    }\n\n    return 0;\n}\n\nint sqrt_newton(int N) {\n    int x;\n    int b;\n    int c;\n\n    x = N \/ 2;\n    if(x == 0){ \n        return N;\n    }\n    if(x < 0){ \n        return -1;\n    }\n\n    b = x;\n    c = x;\n\n    while(1){\n        c = b;\n        b = x;\n        x = (b + (N \/ b)) \/ 2;\n\n        if(x == b){ \n            break;\n        }\n        if(x == c){ \n            if(b < x){ \n                x = b;\n            }\n            break;\n        }\n    }\n\n    return (x);\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\n\nint main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    \n    int x, y;\n\n    x = 521;\n    y = 23;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    printf(\"x = %d\\ny = %d\\nx - y = %d\\n\", x, y, x - y);\n    sub(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n\n    \n\n        \n\n    return 0;\n}\n\n\nint sub(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int h = 0;\n    int i;\n    int return_val;\n    int x, y; \n    struct NUMBER a_abs, b_abs; \n\n    clearByZero(c);\n\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        return_val = numComp(a, b); \n\n        switch (return_val)\n        {\n        case 1: \n            for (i = 0; i < KETA;i++){\n                x = a->n[i] - h;\n                y = b->n[i];\n                if(x < y){\n                    c->n[i] = 10 + x - y;\n                    h = 1; \n                } else if(x >= y){\n                    c->n[i] = x - y;\n                    h = 0; \n                }\n            }\n            if(h != 0){ \n                return -1;\n            }\n            return 0; \n        case -1: \n            sub(b, a, c);\n            setSign(c, -1);\n            return 0;\n        case 0: \n            return 0;\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        add(&a_abs, b, c);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    }\n\n    return 100; \n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint neipia(struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    \n    \n    double t1 = time(NULL);\n\n    struct NUMBER a, b, c, d, one, two, three, a_tmp;\n    int val;\n\n    setInt(&one ,1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n\n    setInt(&b, 500); \n\n    printf(\"\u30cd\u30a4\u30d4\u30a2\u6570\u8a08\u7b97\u958b\u59cb\\n\");\n    neipia(&a, &b);\n    dispNumber(&a);\n    \n    \n    val = getDigit(&a);\n    printf(\"\\nval1:%d\\n\", val);\n    compareNumber(&a, \"neipia.txt\", val);\n    \n    \n    double t3 = time(NULL);\n    printf(\"\\n\u9014\u4e2d\u6642\u9593:%f\\n\", t3 - t1);\n    printf(\"\\n\u5e73\u65b9\u6839\u8a08\u7b97\u958b\u59cb\\n\");\n    divBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    sqrt_newton(&a, &c);\n    dispNumberZeroSuppress(&c);\n    val = getDigit(&c);\n    printf(\"\\nval2:%d\\n\", val);\n    compareNumber(&c, \"sqrtE.txt\", val);\n    t3 = time(NULL);\n    printf(\"\\n\u9014\u4e2d\u6642\u9593:%f\\n\", t3 - t1);\n    printf(\"\\n\u4e09\u4e57\u6839\u8a08\u7b97\u958b\u59cb\\n\");\n    \n    \n    \n    \n\n\n    \n\n    mulBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    curt(&a, &d);\n    dispNumberZeroSuppress(&d);\n    val = getDigit(&d);\n    printf(\"\\nval3:%d\\n\", val);\n    compareNumber(&d, \"curtE.txt\", val);\n    \n    \n    \n\n    \n    \n    \n    \n\n    double t2 = time(NULL);\n    printf(\"\\n\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    \n    return 0;\n}\n\n\nint neipia(struct NUMBER *a, struct NUMBER *b)\n{\n    struct NUMBER  n, one, divid, divided, quotient, rest;\n    \n    \n    \n    clearByZero(&divided);\n    \n    clearByZero(a);\n\n    divided.n[KETA-1] = 1;\n    setInt(&n,2);\n    setInt(&divid,2);\n    if(numComp(&n,b) == 1){\n        return -1;\n    }\n    setInt(&one,1);\n    multiple(&n,&divided,a);\n    \n    while(1){\n        quickDivide(&divided,&divid,&quotient,&rest);\n        add(a,&quotient,&rest);\n        copyNumber(&rest, a);\n        \n        if(numComp(b,&n) == 0){\n            break;\n        }\n        add(&n,&one,&rest);\n        copyNumber(&rest, &n);\n        multiple(&divid,&n,&rest);\n        copyNumber(&rest, &divid);\n\n        \n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"mulprec.h\"\n\nint divide(struct NUMBER *, struct NUMBER *, struct NUMBER *, struct NUMBER *);\n\nint main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d;\n    \n    int x, y;\n    int i;\n\n    x = 100000000;\n    y = 2;\n\n    setInt(&a, x);\n    setInt(&b, y);\n\n    printf(\"x = %d\\ny = %d\\nx \/ y = %d\\nx %% y = %d\\n\", x, y, x \/ y, x % y);\n    dispNumberZeroSuppress(&a);\n    puts(\"\");\n    dispNumberZeroSuppress(&b);\n    puts(\"\");\n\n    divide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    puts(\"\");\n    dispNumberZeroSuppress(&d);\n    puts(\"\");\n\n    \n\n    double t2 = time(NULL);\n    printf(\"\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    return 0;\n}\n\n\nint divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n\n    \n    if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &p);\n        divide(a, &p, c, d);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &p);\n        divide(&p, b, c, d);\n        setSign(c, -1);\n        setSign(d, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0) { \n        getAbs(a, &p);\n        getAbs(b, &q);\n        divide(&p, &q, c, d);\n        setSign(d, -1);\n        return 0; \n    }\n\n    clearByZero(c);\n    clearByZero(d);\n\n    if(isZero(b) != -1){ \n        return -1;\n    }\n\n    copyNumber(a, &n);\n\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n\n    return 0;\n}"}
{"target":"earth429","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define KETA 15\n\nstruct NUMBER{\n    int n[KETA]; \n    int sign; \n};\n\nvoid dispNumberZeroSuppress(struct NUMBER *);\n\nvoid dispNumber(struct NUMBER *a){\n    int i;\n\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}\n\n\nvoid clearByZero(struct NUMBER *a){\n    int i;\n\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n\n    a->sign = 1;\n}\n\n\nvoid setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n\n    clearByZero(a);\n\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n\n    judge = random() % 2; \n\n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}\n\nint main(int argc, char **argv)\n{\n    srandom(time(NULL));\n    struct NUMBER a;\n\n    setRnd(&a, 10);\n\n    printf(\"a = \"); \n    dispNumberZeroSuppress(&a);\n    printf(\"\\n\");\n\n    printf(\"a\u3042\u308a = \"); \n    dispNumber(&a);\n    printf(\"\\n\");\n\n}\n\n\nvoid dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n\n    if(a->sign == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            \n            break;\n        }\n\n        if(i == 0){\n            \n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        \n        printf(\"%2d\", a->n[i]);\n    } \n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/types.h>\n#include <sys\/uio.h>\n\nint main()\n{\n    int fd, pipe_fd[2];\n    char buf[140];\n    int childpid, status;\n\n    fd = open(\"mypipe2.c\", O_RDONLY);\n    if (pipe(pipe_fd) == -1) { \n        perror(\"pipe\");\n        exit(1);\n    }\n\n    if ((childpid = fork()) == -1) {\n        perror(\"Can't fork\");\n        exit(1);\n    } else {\n        if (childpid != 0) { \n            read(fd, buf, sizeof(buf));\n            write(pipe_fd[1], buf, sizeof(buf));\n            wait(&status);\n        } else { \n            read(pipe_fd[0], buf, sizeof(buf));\n            write(1, buf, sizeof(buf));\n        }\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint main()\n{\n    int i;\n    int childpid;\n    int status;\n    char buf[BUFSIZ];\n    char prompt[16] = \"prompt> \";\n    char **ap, *argv[10], *inputstring;\n    printf(\"%s\", prompt);\n    while (fgets(buf, BUFSIZ, stdin) != NULL) {\n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n        \n        \n        if ((childpid = fork()) == 0) {\n            \n            execv(argv[0], argv);\n            exit(0);\n        } else {\n            wait(&status);\n        }\n        printf(\"%s\", prompt);\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint main()\n{\n    int i;\n    int childpid;\n    int status;\n    char buf[BUFSIZ];\n    char prompt[16] = \"prompt> \";\n    char **ap, *argv[10], *inputstring;\n    printf(\"%s\", prompt);\n    while (fgets(buf, BUFSIZ, stdin) != NULL) {\n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n        \n        \n        if ((childpid = fork()) == 0) {\n            \n            execv(argv[0], argv);\n            sleep(30); \n            exit(0);\n        } else {\n            wait(&status);\n            printf(\"%04x\\n\", status); \n        }\n        printf(\"%s\", prompt);\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <signal.h>\n\nvoid sigint_catcher() { \n    kill(getpid() + 1, SIGINT); \n}\n\nint main()\n{\n    int i;\n    int childpid;\n    int status;\n    char buf[BUFSIZ];\n    char dirbuf[BUFSIZ];\n    char arrow[4] = \"> \"; \n    char **ap, *argv[10], *inputstring;\n    getcwd(dirbuf, BUFSIZ); \n    printf(\"%s\", dirbuf);   \n    printf(\"%s\", arrow);\n    signal(SIGINT, sigint_catcher); \n    while (fgets(buf, BUFSIZ, stdin) != NULL) {\n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n        \n        if (strcmp(argv[0], \"k\") == 0) { \n            kill(atoi(argv[1]), SIGINT); \n        } else if (strcmp(argv[0], \"s\") == 0) { \n            kill(atoi(argv[1]), SIGSTOP); \n        } else if (strcmp(argv[0], \"c\") == 0) { \n            kill(atoi(argv[1]), SIGCONT); \n        } else if (strcmp(argv[0], \"cd\") == 0) { \n            if (argv[1] == NULL) { \n                chdir(getenv(\"HOME\")); \n            } else {\n                chdir(argv[1]); \n            }\n        } else if (strcmp(argv[0], \"exit\") == 0) { \n            exit(0); \n        } else if ((childpid = fork()) == 0) { \n            \n            execv(argv[0], argv); \n            exit(0); \n        } else {\n            \n            wait(&status); \n            printf(\"status:%04x\\n\", status); \n        }\n        getcwd(dirbuf, BUFSIZ); \n        printf(\"%s\", dirbuf);   \n        printf(\"%s\", arrow);\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <signal.h>\n\nvoid sigint_catcher() { \n    printf(\"-----SIGINT was sent to the childprocess!-----\\n\");\n    kill(getpid() + 1, SIGINT); \n}\n\nint main()\n{\n    int i;\n    int childpid;\n    int status;\n    char buf[BUFSIZ];\n    char prompt[16] = \"prompt> \";\n    char **ap, *argv[10], *inputstring;\n    printf(\"%s\", prompt);\n    signal(SIGINT, sigint_catcher); \n    while (fgets(buf, BUFSIZ, stdin) != NULL) {\n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n        \n        if ((childpid = fork()) == 0) { \n            \n            execv(argv[0], argv); \n            exit(0); \n        } else {\n            \n            wait(&status); \n            printf(\"status:%04x\\n\", status); \n        }\n        printf(\"%s\", prompt);\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <signal.h>\n\nvoid sigint_catcher() { \n    kill(getpid() + 1, SIGINT); \n}\n\nint main()\n{\n    int i;\n    int childpid, status; \n    int fd, pipe_fd[2]; \n    int chpid1, chpid2, status1, status2; \n    int pipe_flag = 0; \n    char dirbuf[BUFSIZ]; \n    char arrow[4] = \"> \"; \n    char buf[BUFSIZ]; \n    char **ap, *argv[10], *inputstring;\n    getcwd(dirbuf, BUFSIZ); \n    printf(\"%s\", dirbuf);   \n    printf(\"%s\", arrow);\n    signal(SIGINT, sigint_catcher); \n    while (fgets(buf, BUFSIZ, stdin) != NULL) { \n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n\n        \n        i = 0;\n        pipe_flag = 0;\n        \n        while (argv[i] != NULL) {\n            puts(\"me\");\n            if (strcmp(argv[i], \"|\") == 0) { \n            puts(\"neko\");\n                argv[i] = '\\0'; \n                pipe_flag++; \n                break;\n            }\n            i++;\n        }\n\n        if (strcmp(argv[0], \"k\") == 0) { \n            kill(atoi(argv[1]), SIGINT); \n        } else if (strcmp(argv[0], \"s\") == 0) { \n            kill(atoi(argv[1]), SIGSTOP); \n        } else if (strcmp(argv[0], \"c\") == 0) { \n            kill(atoi(argv[1]), SIGCONT); \n        } else if (strcmp(argv[0], \"cd\") == 0) { \n            if (argv[1] == NULL) { \n                chdir(getenv(\"HOME\")); \n            } else {\n                chdir(argv[1]); \n            }\n        } else if (strcmp(argv[0], \"exit\") == 0) { \n            exit(0); \n        } else {  \n            if (pipe_flag != 0) {\n                \n                puts(\"me!\");\n                pipe_flag = 0;\n                for (i = 0; i < 10; i++) {\n                    if (argv[i] == NULL && pipe_flag != 0) {\n                        exit(0); \n                    } else if (argv[i] == NULL) {\n                        pipe_flag++; \n                        printf(\"\\n\");\n                    } else {\n                        printf(\"argv[%d]: %s\\n\", i, argv[i]);\n                    }\n                }\n            } else {\n                \n                if ((childpid = fork()) == 0) {\n                    \n                    execvp(argv[0], &argv[0]); \n                    exit(0); \n                } else {\n                    \n                    wait(&status); \n                    printf(\"status:%04x\\n\", status); \n                }\n            }\n        }\n        getcwd(dirbuf, BUFSIZ); \n        printf(\"%s\", dirbuf);   \n        printf(\"%s\", arrow);\n    }\n}"}
{"target":"earth429","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n#include <signal.h>\n\nvoid sigint_catcher() { \n    kill(getpid() + 1, SIGINT); \n}\n\nint main()\n{\n    int i;\n    int childpid, status; \n    int pipe_fd[2], pipe_position; \n    int chpid1, chpid2, status1, status2; \n    int pipe_flag = 0; \n    char dirbuf[BUFSIZ]; \n    char arrow[4] = \"> \"; \n    char buf[BUFSIZ]; \n    char **ap, *argv[10], *inputstring;\n    getcwd(dirbuf, BUFSIZ); \n    printf(\"%s\", dirbuf);   \n    printf(\"%s\", arrow);\n    signal(SIGINT, sigint_catcher); \n    while (fgets(buf, BUFSIZ, stdin) != NULL) { \n        buf[strlen(buf) - 1] = '\\0'; \n        inputstring = buf;\n        \n        for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n            if (**ap != '\\0')\n                if (++ap >= &argv[10])\n                    break;\n\n        \n        i = 0;\n        pipe_flag = 0;\n        \n        while (argv[i] != NULL) {\n            if (strcmp(argv[i], \"|\") == 0) { \n                pipe_position = i; \n                argv[i] = '\\0'; \n                pipe_flag++; \n                break;\n            }\n            i++;\n        }\n\n        if (strcmp(argv[0], \"k\") == 0) { \n            kill(atoi(argv[1]), SIGINT); \n        } else if (strcmp(argv[0], \"s\") == 0) { \n            kill(atoi(argv[1]), SIGSTOP); \n        } else if (strcmp(argv[0], \"c\") == 0) { \n            kill(atoi(argv[1]), SIGCONT); \n        } else if (strcmp(argv[0], \"cd\") == 0) { \n            if (argv[1] == NULL) { \n                chdir(getenv(\"HOME\")); \n            } else {\n                chdir(argv[1]); \n            }\n        } else if (strcmp(argv[0], \"exit\") == 0) { \n            exit(0); \n        } else {  \n            if (pipe_flag != 0) {\n                \n                if (pipe(pipe_fd) == -1) { \n                    perror(\"pipe\");\n                    exit(1);\n                }\n                if ((chpid1 = fork()) == 0) { \n                    \n                    close(pipe_fd[0]); \n                    close(1); \n                    dup(pipe_fd[1]); \n                    execvp(argv[0], &argv[0]); \n                    exit(0); \n                } else if ((chpid2 = fork()) == 0) { \n                    \n                    close(pipe_fd[1]); \n                    close(0); \n                    dup(pipe_fd[0]); \n                    execvp(argv[pipe_position + 1], &argv[pipe_position + 1]); \n                    exit(0); \n                } else {\n                    \n                    close(pipe_fd[0]); \n                    close(pipe_fd[1]); \n                    waitpid(chpid1, &status1, 0);    \n                    waitpid(chpid2, &status2, 0);    \n                    printf(\"status1:%04x\\n\", status1); \n                    printf(\"status2:%04x\\n\", status2); \n                }\n            } else {\n                \n                if ((childpid = fork()) == 0) {\n                    \n                    execvp(argv[0], &argv[0]); \n                    exit(0); \n                } else {\n                    \n                    wait(&status); \n                    printf(\"status:%04x\\n\", status); \n                }\n            }\n        }\n        getcwd(dirbuf, BUFSIZ); \n        printf(\"%s\", dirbuf);   \n        printf(\"%s\", arrow);\n    }\n}"}
{"target":"fikepaci","func":"#include \"binary_trees.h\"\n\n\nbst_t *bst_insert(bst_t **tree, int value)\n{\n    bst_t *curr, *new;\n\n    if (tree != NULL)\n    {\n        curr = *tree;\n\n        if (curr == NULL)\n        {\n            new = binary_tree_node(curr, value);\n            if (new == NULL)\n                return (NULL);\n            return (*tree = new);\n        }\n\n        if (value < curr->n) \n        {\n            if (curr->left != NULL)\n                return (bst_insert(&curr->left, value));\n\n            new = binary_tree_node(curr, value);\n            if (new == NULL)\n                return (NULL);\n            return (curr->left = new);\n        }\n        if (value > curr->n) \n        {\n            if (curr->right != NULL)\n                return (bst_insert(&curr->right, value));\n\n            new = binary_tree_node(curr, value);\n            if (new == NULL)\n                return (NULL);\n            return (curr->right = new);\n        }\n    }\n    return (NULL);\n}\n"}
{"target":"fikepaci","func":"#include \"binary_trees.h\"\n\nbst_t *inorder_successor(bst_t *root);\nbst_t *bst_delete(bst_t *root, bst_t *node);\nbst_t *bst_remove_recursive(bst_t *root, bst_t *node, int value);\nbst_t *bst_remove(bst_t *root, int value);\n\n\nbst_t *inorder_successor(bst_t *root)\n{\n    while (root->left != NULL)\n        root = root->left;\n    return (root);\n}\n\n\nbst_t *bst_delete(bst_t *root, bst_t *node)\n{\n    bst_t *parent = node->parent, *successor = NULL;\n\n    \n    if (node->left == NULL)\n    {\n        if (parent != NULL && parent->left == node)\n            parent->left = node->right;\n        else if (parent != NULL)\n            parent->right = node->right;\n        if (node->right != NULL)\n            node->right->parent = parent;\n        free(node);\n        return (parent == NULL ? node->right : root);\n    }\n\n    \n    if (node->right == NULL)\n    {\n        if (parent != NULL && parent->left == node)\n            parent->left = node->left;\n        else if (parent != NULL)\n            parent->right = node->left;\n        if (node->left != NULL)\n            node->left->parent = parent;\n        free(node);\n        return (parent == NULL ? node->left : root);\n    }\n\n    \n    successor = inorder_successor(node->right);\n    node->n = successor->n;\n\n    return (bst_delete(root, successor));\n}\n\n\nbst_t *bst_remove_recursive(bst_t *root, bst_t *node, int value)\n{\n    if (node != NULL)\n    {\n        if (node->n == value)\n            return (bst_delete(root, node));\n        if (node->n > value)\n            return (bst_remove_recursive(root, node->left, value));\n        return (bst_remove_recursive(root, node->right, value));\n    }\n    return (NULL);\n}\n\n\nbst_t *bst_remove(bst_t *root, int value)\n{\n    return (bst_remove_recursive(root, root, value));\n}\n"}
{"target":"fikepaci","func":"#include \"binary_trees.h\"\n\nsize_t height(const binary_tree_t *tree);\nint balance(const binary_tree_t *tree);\navl_t *avl_insert_recursive(avl_t **tree, avl_t *parent,\n        avl_t **new, int value);\navl_t *avl_insert(avl_t **tree, int value);\n\n\nsize_t height(const binary_tree_t *tree)\n{\n    if (tree != NULL)\n    {\n        size_t l = 0, r = 0;\n\n        l = tree->left ? 1 + binary_tree_height(tree->left) : 1;\n        r = tree->right ? 1 + binary_tree_height(tree->right) : 1;\n        return ((l > r) ? l : r);\n    }\n    return (0);\n}\n\n\nint balance(const binary_tree_t *tree)\n{\n    return (tree != NULL ? height(tree->left) - height(tree->right) : 0);\n}\n\n\navl_t *avl_insert_recursive(avl_t **tree, avl_t *parent,\n        avl_t **new, int value)\n{\n    int bfactor;\n\n    if (*tree == NULL)\n        return (*new = binary_tree_node(parent, value));\n\n    if ((*tree)->n > value)\n    {\n        (*tree)->left = avl_insert_recursive(&(*tree)->left, *tree, new, value);\n        if ((*tree)->left == NULL)\n            return (NULL);\n    }\n    else if ((*tree)->n < value)\n    {\n        (*tree)->right = avl_insert_recursive(&(*tree)->right, *tree, new, value);\n        if ((*tree)->right == NULL)\n            return (NULL);\n    }\n    else\n        return (*tree);\n\n    bfactor = balance(*tree);\n    if (bfactor > 1 && (*tree)->left->n > value)\n        *tree = binary_tree_rotate_right(*tree);\n    else if (bfactor < -1 && (*tree)->right->n < value)\n        *tree = binary_tree_rotate_left(*tree);\n    else if (bfactor > 1 && (*tree)->left->n < value)\n    {\n        (*tree)->left = binary_tree_rotate_left((*tree)->left);\n        *tree = binary_tree_rotate_right(*tree);\n    }\n    else if (bfactor < -1 && (*tree)->right->n > value)\n    {\n        (*tree)->right = binary_tree_rotate_right((*tree)->right);\n        *tree = binary_tree_rotate_left(*tree);\n    }\n\n    return (*tree);\n}\n\n\navl_t *avl_insert(avl_t **tree, int value)\n{\n    avl_t *new = NULL;\n\n    if (tree == NULL)\n        return (NULL);\n    if (*tree == NULL)\n    {\n        *tree = binary_tree_node(NULL, value);\n        return (*tree);\n    }\n    avl_insert_recursive(tree, *tree, &new, value);\n    return (new);\n}\n"}
{"target":"fikepaci","func":"#include \"binary_trees.h\"\n\nunsigned char is_leaf(const binary_tree_t *node);\nsize_t depth(const binary_tree_t *tree);\nconst binary_tree_t *get_leaf(const binary_tree_t *tree);\nint is_perfect_recursive(const binary_tree_t *tree,\n        size_t leaf_depth, size_t level);\nint binary_tree_is_perfect(const binary_tree_t *tree);\n\n\nunsigned char is_leaf(const binary_tree_t *node)\n{\n    return ((node->left == NULL && node->right == NULL) ? 1 : 0);\n}\n\n\nsize_t depth(const binary_tree_t *tree)\n{\n    return (tree->parent != NULL ? 1 + depth(tree->parent) : 0);\n}\n\n\nconst binary_tree_t *get_leaf(const binary_tree_t *tree)\n{\n    if (is_leaf(tree) == 1)\n        return (tree);\n    return (tree->left ? get_leaf(tree->left) : get_leaf(tree->right));\n}\n\n\nint is_perfect_recursive(const binary_tree_t *tree,\n        size_t leaf_depth, size_t level)\n{\n    if (is_leaf(tree))\n        return (level == leaf_depth ? 1 : 0);\n    if (tree->left == NULL || tree->right == NULL)\n        return (0);\n    return (is_perfect_recursive(tree->left, leaf_depth, level + 1) &&\n            is_perfect_recursive(tree->right, leaf_depth, level + 1));\n}\n\n\nint binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    if (tree == NULL)\n        return (0);\n    return (is_perfect_recursive(tree, depth(get_leaf(tree)), 0));\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n\nint short_stack_error(unsigned int line_number, char *op);\nint div_error(unsigned int line_number);\nint pop_error(unsigned int line_number);\nint div_error(unsigned int line_number);\nint pchar_error(unsigned int line_number, char *message);\n\n\nint pop_error(unsigned int line_number)\n{\n    fprintf(stderr, \"L%u: can't pop an empty stack\\n\", line_number);\n    return (EXIT_FAILURE);\n}\n\n\nint pint_error(unsigned int line_number)\n{\n    fprintf(stderr, \"L%d: can't pint, stack empty\\n\", line_number);\n    return (EXIT_FAILURE);\n}\n\n\nint short_stack_error(unsigned int line_number, char *op)\n{\n    fprintf(stderr, \"L%u: can't %s, stack too short\\n\", line_number, op);\n    return (EXIT_FAILURE);\n}\n\n\nint div_error(unsigned int line_number)\n{\n    fprintf(stderr, \"L%u: division by zero\\n\", line_number);\n    return (EXIT_FAILURE);\n}\n\n\nint pchar_error(unsigned int line_number, char *message)\n{\n    fprintf(stderr, \"L%u: can't pchar, %s\\n\", line_number, message);\n    return (EXIT_FAILURE);\n}\n"}
{"target":"fikepaci","func":"#include <stdlib.h>\n\nchar *get_int(int num);\nunsigned int _abs(int);\nint get_numbase_len(unsigned int num, unsigned int base);\nvoid fill_numbase_buff(unsigned int num, unsigned int base,\n        char *buff, int buff_size);\n\n\nchar *get_int(int num)\n{\n    unsigned int temp;\n    int length = 0;\n    long num_l = 0;\n    char *ret;\n\n    temp = _abs(num);\n    length = get_numbase_len(temp, 10);\n\n    if (num < 0 || num_l < 0)\n        length++; \n    ret = malloc(length + 1); \n    if (!ret)\n        return (NULL);\n\n    fill_numbase_buff(temp, 10, ret, length);\n    if (num < 0 || num_l < 0)\n        ret[0] = '-';\n\n    return (ret);\n}\n\n\nunsigned int _abs(int i)\n{\n    if (i < 0)\n        return (-(unsigned int)i);\n    return ((unsigned int)i);\n}\n\n\nint get_numbase_len(unsigned int num, unsigned int base)\n{\n    int len = 1; \n\n    while (num > base - 1)\n    {\n        len++;\n        num \/= base;\n    }\n    return (len);\n}\n\n\nvoid fill_numbase_buff(unsigned int num, unsigned int base,\n        char *buff, int buff_size)\n{\n    int rem, i = buff_size - 1;\n\n    buff[buff_size] = '\\0';\n    while (i >= 0)\n    {\n        rem = num % base;\n        if (rem > 9) \n            buff[i] = rem + 87; \n        else\n            buff[i] = rem + '0';\n        num \/= base;\n        i--;\n    }\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n\nvoid monty_push(stack_t **stack, unsigned int line_number);\nvoid monty_pall(stack_t **stack, unsigned int line_number);\nvoid monty_pint(stack_t **stack, unsigned int line_number);\nvoid monty_pop(stack_t **stack, unsigned int line_number);\nvoid monty_swap(stack_t **stack, unsigned int line_number);\n\n\nvoid monty_push(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp, *new;\n    int i;\n\n    new = malloc(sizeof(stack_t));\n    if (new == NULL)\n    {\n        set_op_tok_error(malloc_error());\n        return;\n    }\n\n    if (op_toks[1] == NULL)\n    {\n        set_op_tok_error(no_int_error(line_number));\n        return;\n    }\n\n    for (i = 0; op_toks[1][i]; i++)\n    {\n        if (op_toks[1][i] == '-' && i == 0)\n            continue;\n        if (op_toks[1][i] < '0' || op_toks[1][i] > '9')\n        {\n            set_op_tok_error(no_int_error(line_number));\n            return;\n        }\n    }\n    new->n = atoi(op_toks[1]);\n\n    if (check_mode(*stack) == STACK) \n    {\n        tmp = (*stack)->next;\n        new->prev = *stack;\n        new->next = tmp;\n        if (tmp)\n            tmp->prev = new;\n        (*stack)->next = new;\n    }\n    else \n    {\n        tmp = *stack;\n        while (tmp->next)\n            tmp = tmp->next;\n        new->prev = tmp;\n        new->next = NULL;\n        tmp->next = new;\n    }\n}\n\n\nvoid monty_pall(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n\n    while (tmp)\n    {\n        printf(\"%d\\n\", tmp->n);\n        tmp = tmp->next;\n    }\n    (void)line_number;\n}\n\n\nvoid monty_pint(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pint_error(line_number));\n        return;\n    }\n\n    printf(\"%d\\n\", (*stack)->next->n);\n}\n\n\n\nvoid monty_pop(stack_t **stack, unsigned int line_number)\n{\n    stack_t *next = NULL;\n\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pop_error(line_number));\n        return;\n    }\n\n    next = (*stack)->next->next;\n    free((*stack)->next);\n    if (next)\n        next->prev = *stack;\n    (*stack)->next = next;\n}\n\n\nvoid monty_swap(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp;\n\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"swap\"));\n        return;\n    }\n\n    tmp = (*stack)->next->next;\n    (*stack)->next->next = tmp->next;\n    (*stack)->next->prev = tmp;\n    if (tmp->next)\n        tmp->next->prev = (*stack)->next;\n    tmp->next = (*stack)->next;\n    tmp->prev = *stack;\n    (*stack)->next = tmp;\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n\nvoid monty_add(stack_t **stack, unsigned int line_number);\nvoid monty_sub(stack_t **stack, unsigned int line_number);\nvoid monty_div(stack_t **stack, unsigned int line_number);\nvoid monty_mul(stack_t **stack, unsigned int line_number);\nvoid monty_mod(stack_t **stack, unsigned int line_number);\n\n\nvoid monty_add(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"add\"));\n        return;\n    }\n\n    (*stack)->next->next->n += (*stack)->next->n;\n    monty_pop(stack, line_number);\n}\n\n\nvoid monty_sub(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"sub\"));\n        return;\n    }\n\n    (*stack)->next->next->n -= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}\n\n\nvoid monty_div(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"div\"));\n        return;\n    }\n\n    if ((*stack)->next->n == 0)\n    {\n        set_op_tok_error(div_error(line_number));\n        return;\n    }\n\n    (*stack)->next->next->n \/= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}\n\n\nvoid monty_mul(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"mul\"));\n        return;\n    }\n\n    (*stack)->next->next->n *= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}\n\n\nvoid monty_mod(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"mod\"));\n        return;\n    }\n\n    if ((*stack)->next->n == 0)\n    {\n        set_op_tok_error(div_error(line_number));\n        return;\n    }\n\n    (*stack)->next->next->n %= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n\nvoid monty_nop(stack_t **stack, unsigned int line_number);\nvoid monty_pchar(stack_t **stack, unsigned int line_number);\nvoid monty_pstr(stack_t **stack, unsigned int line_number);\n\n\nvoid monty_nop(stack_t **stack, unsigned int line_number)\n{\n    (void)stack;\n    (void)line_number;\n}\n\n\nvoid monty_pchar(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pchar_error(line_number, \"stack empty\"));\n        return;\n    }\n    if ((*stack)->next->n < 0 || (*stack)->next->n > 127)\n    {\n        set_op_tok_error(pchar_error(line_number,\n                    \"value out of range\"));\n        return;\n    }\n\n    printf(\"%c\\n\", (*stack)->next->n);\n}\n\n\nvoid monty_pstr(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n\n    while (tmp && tmp->n != 0 && (tmp->n > 0 && tmp->n <= 127))\n    {\n        printf(\"%c\", tmp->n);\n        tmp = tmp->next;\n    }\n\n    printf(\"\\n\");\n\n    (void)line_number;\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n#include <string.h>\n\nvoid free_tokens(void);\nunsigned int token_arr_len(void);\nint is_empty_line(char *line, char *delims);\nvoid (*get_op_func(char *opcode))(stack_t**, unsigned int);\nint run_monty(FILE *script_fd);\n\n\nvoid free_tokens(void)\n{\n    size_t i = 0;\n\n    if (op_toks == NULL)\n        return;\n\n    for (i = 0; op_toks[i]; i++)\n        free(op_toks[i]);\n\n    free(op_toks);\n}\n\n\nunsigned int token_arr_len(void)\n{\n    unsigned int toks_len = 0;\n\n    while (op_toks[toks_len])\n        toks_len++;\n    return (toks_len);\n}\n\n\nint is_empty_line(char *line, char *delims)\n{\n    int i, j;\n\n    for (i = 0; line[i]; i++)\n    {\n        for (j = 0; delims[j]; j++)\n        {\n            if (line[i] == delims[j])\n                break;\n        }\n        if (delims[j] == '\\0')\n            return (0);\n    }\n\n    return (1);\n}\n\n\nvoid (*get_op_func(char *opcode))(stack_t**, unsigned int)\n{\n    instruction_t op_funcs[] = {\n        {\"push\", monty_push},\n        {\"pall\", monty_pall},\n        {\"pint\", monty_pint},\n        {\"pop\", monty_pop},\n        {\"swap\", monty_swap},\n        {\"add\", monty_add},\n        {\"nop\", monty_nop},\n        {\"sub\", monty_sub},\n        {\"div\", monty_div},\n        {\"mul\", monty_mul},\n        {\"mod\", monty_mod},\n        {\"pchar\", monty_pchar},\n        {\"pstr\", monty_pstr},\n        {\"rotl\", monty_rotl},\n        {\"rotr\", monty_rotr},\n        {\"stack\", monty_stack},\n        {\"queue\", monty_queue},\n        {NULL, NULL}\n    };\n    int i;\n\n    for (i = 0; op_funcs[i].opcode; i++)\n    {\n        if (strcmp(opcode, op_funcs[i].opcode) == 0)\n            return (op_funcs[i].f);\n    }\n\n    return (NULL);\n}\n\n\nint run_monty(FILE *script_fd)\n{\n    stack_t *stack = NULL;\n    char *line = NULL;\n    size_t len = 0, exit_status = EXIT_SUCCESS;\n    unsigned int line_number = 0, prev_tok_len = 0;\n    void (*op_func)(stack_t**, unsigned int);\n\n    if (init_stack(&stack) == EXIT_FAILURE)\n        return (EXIT_FAILURE);\n\n    while (getline(&line, &len, script_fd) != -1)\n    {\n        line_number++;\n        op_toks = strtow(line, DELIMS);\n        if (op_toks == NULL)\n        {\n            if (is_empty_line(line, DELIMS))\n                continue;\n            free_stack(&stack);\n            return (malloc_error());\n        }\n        else if (op_toks[0][0] == '#') \n        {\n            free_tokens();\n            continue;\n        }\n        op_func = get_op_func(op_toks[0]);\n        if (op_func == NULL)\n        {\n            free_stack(&stack);\n            exit_status = unknown_op_error(op_toks[0], line_number);\n            free_tokens();\n            break;\n        }\n        prev_tok_len = token_arr_len();\n        op_func(&stack, line_number);\n        if (token_arr_len() != prev_tok_len)\n        {\n            if (op_toks && op_toks[prev_tok_len])\n                exit_status = atoi(op_toks[prev_tok_len]);\n            else\n                exit_status = EXIT_FAILURE;\n            free_tokens();\n            break;\n        }\n        free_tokens();\n    }\n    free_stack(&stack);\n\n    if (line && *line == 0)\n    {\n        free(line);\n        return (malloc_error());\n    }\n\n    free(line);\n    return (exit_status);\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n\n\nvoid set_op_tok_error(int error_code)\n{\n    int toks_len = 0, i = 0;\n    char *exit_str = NULL;\n    char **new_toks = NULL;\n\n    toks_len = token_arr_len();\n    new_toks = malloc(sizeof(char *) * (toks_len + 2));\n    if (!op_toks)\n    {\n        malloc_error();\n        return;\n    }\n    while (i < toks_len)\n    {\n        new_toks[i] = op_toks[i];\n        i++;\n    }\n    exit_str = get_int(error_code);\n    if (!exit_str)\n    {\n        free(new_toks);\n        malloc_error();\n        return;\n    }\n    new_toks[i++] = exit_str;\n    new_toks[i] = NULL;\n    free(op_toks);\n    op_toks = new_toks;\n}\n"}
{"target":"fikepaci","func":"#include \"monty.h\"\n#include <string.h>\n\nvoid free_stack(stack_t **stack);\nint init_stack(stack_t **stack);\nint check_mode(stack_t *stack);\n\n\nvoid free_stack(stack_t **stack)\n{\n    stack_t *tmp = *stack;\n\n    while (*stack)\n    {\n        tmp = (*stack)->next;\n        free(*stack);\n        *stack = tmp;\n    }\n}\n\n\nint init_stack(stack_t **stack)\n{\n    stack_t *s;\n\n    s = malloc(sizeof(stack_t));\n    if (s == NULL)\n        return (malloc_error());\n\n    s->n = STACK;\n    s->prev = NULL;\n    s->next = NULL;\n\n    *stack = s;\n\n    return (EXIT_SUCCESS);\n}\n\n"}
{"target":"fikepaci","func":"#include <stdlib.h>\n\nchar **strtow(char *str, char *delims);\nint is_delim(char ch, char *delims);\nint get_word_length(char *str, char *delims);\nint get_word_count(char *str, char *delims);\nchar *get_next_word(char *str, char *delims);\n\n\n\nchar **strtow(char *str, char *delims)\n{\n    char **words = NULL;\n    int wc, wordLen, n, i = 0;\n\n    if (str == NULL || !*str)\n        return (NULL);\n    wc = get_word_count(str, delims);\n\n\n    if (wc == 0)\n        return (NULL);\n    words = malloc((wc + 1) * sizeof(char *));\n    if (words == NULL)\n        return (NULL);\n    while (i < wc)\n    {\n        wordLen = get_word_length(str, delims);\n        if (is_delim(*str, delims))\n        {\n            str = get_next_word(str, delims);\n        }\n        words[i] = malloc((wordLen + 1) * sizeof(char));\n        if (words[i] == NULL)\n        {\n            while (i >= 0)\n            {\n                i--;\n                free(words[i]);\n            }\n            free(words);\n            return (NULL);\n        }\n        n = 0;\n        while (n < wordLen)\n        {\n            words[i][n] = *(str + n);\n            n++;\n        }\n        words[i][n] = '\\0'; \n        str = get_next_word(str, delims);\n        i++;\n    }\n    words[i] = NULL; \n    return (words);\n}\n\n\n\nint is_delim(char ch, char *delims)\n{\n    int i = 0;\n\n    while (delims[i])\n    {\n        if (delims[i] == ch)\n            return (1);\n        i++;\n    }\n    return (0);\n}\n\n\n\nint get_word_length(char *str, char *delims)\n{\n    int wLen = 0, pending = 1, i = 0;\n\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n        {\n            wLen++;\n        }\n        if (wLen > 0 && is_delim(str[i], delims))\n            break;\n        i++;\n    }\n    return (wLen);\n}\n\n\n\nint get_word_count(char *str, char *delims)\n{\n    int wc = 0, pending = 1, i = 0;\n\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n        {\n            pending = 0;\n            wc++;\n        }\n        i++;\n    }\n    return (wc);\n}\n\n\n\nchar *get_next_word(char *str, char *delims)\n{\n    int pending = 0;\n    int i = 0;\n\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n            break;\n        i++;\n    }\n    return (str + i);\n}\n"}
{"target":"fikepaci","func":"#include \"sort.h\"\n\nvoid swap_backward(listint_t *c)\n{\n    listint_t *tmp, *head;\n\n    while (c->prev != NULL)\n    {\n        if (c->n < c->prev->n)\n        {\n            tmp = c->prev->prev;\n            c->prev->next = c->next;\n            c->next = c->prev;\n            c->prev->prev = c;\n            c->prev = tmp;\n            c->next->next->prev = c->next;\n            if (tmp != NULL)\n                tmp->next = c;\n            head = c;\n            while (head->prev != NULL)\n                head = head->prev;\n            print_list(head);\n        }\n        else\n            c = c->prev;\n    }\n}\n\nvoid swap_forward(listint_t *c)\n{\n    listint_t *tmp, *head;\n\n    tmp = c->prev;\n\n    if (tmp != NULL)\n    {\n        tmp->next = c->next;\n        c->next->prev = tmp;\n    }\n    else\n        c->next->prev = NULL;\n    c->prev = c->next;\n    if (c->next->next != NULL)\n    {\n        c->next = c->next->next;\n        c->prev->next = c;\n        c->next->prev = c;\n    }\n    else\n    {\n        c->next->next = c;\n        c->next = NULL;\n    }\n    head = c;\n    while (head->prev != NULL)\n        head = head->prev;\n    print_list(head);\n    swap_backward(c->prev);\n}\n\nvoid insertion_sort_list(listint_t **list)\n{\n    listint_t *c;\n\n    if ((list == NULL) || (*list == NULL) || ((*list)->next == NULL))\n        return;\n    c = *list;\n\n    while (c->next != NULL)\n    {\n        if (c->n > c->next->n)\n        {\n            swap_forward(c);\n        }\n        else\n            c = c->next;\n    }\n    while ((*list)->prev != NULL)\n        *list = (*list)->prev;\n}\n"}
{"target":"fikepaci","func":"#include \"sort.h\"\n\n\nvoid _swap(int *a, int *b)\n{\n    int tmp;\n\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nvoid backward_insertion(int *array, int gap, int act)\n{\n    int i;\n\n    for (i = act - gap; i >= 0; i -= gap, act -= gap)\n    {\n        if (array[i] > array[act])\n            _swap(&array[i], &array[act]);\n        else\n            break;\n    }\n}\n\nvoid shell_sort(int *array, size_t size)\n{\n    unsigned int gap = 1, i, j;\n\n    if (array == NULL)\n        return;\n    if (size < 2)\n        return;\n    while (gap < size \/ 3)\n        gap = gap * 3 + 1;\n\n    while (gap > 0)\n    {\n        for (i = 0, j = gap; j < size; i++, j++)\n        {\n            if (array[i] > array[j])\n            {\n                _swap(&array[i], &array[j]);\n                backward_insertion(array, gap, i);\n            }\n        }\n        print_array(array, size);\n        gap \/= 3;\n    }\n}\n"}
{"target":"fikepaci","func":"#include \"sort.h\"\n\n\nvoid merge_sort(int *array, size_t size)\n{\n    int low;\n    int high;\n    int *temp;\n\n    low = 0;\n    high = size - 1;\n\n    temp = malloc(sizeof(int) * size);\n    if (temp == NULL)\n        return;\n\n    sort(array, low, high, temp);\n\n    free(temp);\n}\n\n\nvoid sort(int *array, int low, int high, int *temp)\n{\n    int mid;\n\n    if (low < high)\n    {\n        mid = (low + high) \/ 2;\n        sort(array, low, mid, temp);\n        sort(array, mid + 1, high, temp);\n        merge(array, low, mid, high, temp);\n    }\n}\n\n\nvoid merge(int *array, int low, int mid, int high, int *temp)\n{\n    int left;\n    int right;\n    int i;\n\n    left = low;\n    right = mid + 1;\n\n    printf(\"Merging...\\n\");\n    printf(\"[left]: \");\n    print_array(&array[low], mid + 1);\n    printf(\"[right]: \");\n    print_array(&array[mid + 1], high - mid);\n\n    for (i = low; left <= mid && right <= high; i++)\n    {\n        if (array[left] <= array[right])\n            temp[i] = array[left++];\n        else\n            temp[i] = array[right++];\n    }\n\n    while (left <= mid)\n        temp[i++] = array[left++];\n\n    while (right <= high)\n        temp[i++] = array[right++];\n\n    for (i = 0; i <= high; i++)\n        array[i] = temp[i];\n\n    printf(\"[Done]: \");\n    print_array(temp, i);\n}\n\n\nint len(int *array)\n{\n    int i;\n\n    for (i = 0; array[i] != '\\0'; i++)\n        ;\n\n    return (i);\n}\n"}
{"target":"fikepaci","func":"#include \"sort.h\"\n\nvoid _swap(int *a, int *b)\n{\n    int tmp;\n\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\nvoid selection_sort(int *array, size_t size)\n{\n    unsigned int i, j, min;\n\n    if (array == NULL || size < 2)\n        return;\n\n    for (i = 0; i < size; i++)\n    {\n        min = i;\n        for (j = i + 1; j < size; j++)\n        {\n            if (array[min] > array[j])\n                min = j;\n        }\n        if (min != i)\n        {\n            _swap(&array[i], &array[min]);\n            print_array(array, size);\n        }\n    }\n\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MAX_STACK_SIZE 10000000\n#define MAX 455\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\n\nint*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int hei;\n    short int dir;\n} element;\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"1\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    element t;\n    int flag;\n} tpoint;\ntpoint queue2[MAX_STACK_SIZE];\nint rear2 = -1;\nint front2 = -1;\nvoid addq2(tpoint item){\n    if(rear2==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue2[++rear2] = item;\n}\ntpoint deleteq2(){\n    if(front2==rear2){\n        fprintf(stderr, \"1\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue2[++front2];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n    short int hei;\n}offsets;\noffsets move[6];\n\n\nint min=10000;\nint n;\n\n\nint bfs(char*** maze,int*** d,int sr,int sc,int sh){\n\n    int laststep=0;\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    \n\n    addq(position);\n    int i,j,k,q;\n    for(i=0;i<n\/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    \n\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        \n\n        \n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        \n        \n        \n        \n        if(laststep!=d[hei][row][col] ){\n            \n            if(front2!=rear2){\n                for(i=front2+1;i<=rear2;i++){\n                    if(queue2[i].flag!=0){\n                        if((queue2[i].flag-d[hei][row][col]+laststep)>=0){\n                            queue2[i].flag-=(d[hei][row][col]-laststep);\n                            \n                            \n                            \n                        }\n                        else queue2[i].flag=0;\n                    }\n                    if(queue2[i].flag==0){\n                        addq(queue2[i].t);\n                        deleteq2();\n                        nr = queue2[i].t.row;\n                        nc = queue2[i].t.col;\n                        nh = queue2[i].t.hei;\n                        \n                        d[nh][nr][nc]=d[hei][row][col]+1;\n                        \n                    }\n                }\n            }\n            laststep=d[hei][row][col];\n        }\n        \n        \n        \n        \n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            \n            \n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                \n                upanddown=1;\n            }\n            \n\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            \n            \n            if(nh>=0){\n                if(maze[nh][nr][nc]=='F'){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    \n                    \n                    if(min>d[nh][nr][nc]){\n                        min = d[nh][nr][nc];\n                    }\n                    \n                    return 1;\n                }\n                if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){\n                    \n                    d[nh][nr][nc]=-1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n\n                        tpoint Tpoint;\n\n                        Tpoint.t=nextposition;\n                        Tpoint.flag=2;\n                        addq2(Tpoint);\n                        \n                        int r = queue2[front2].t.row;\n                        int c = queue2[front2].t.col;\n                        int h = queue2[front2].t.hei;\n                        \n\n\n                }\n                else if (maze[nh][nr][nc]!='X'  && d[nh][nr][nc]==MAX){\n                    \n                    d[nh][nr][nc]=d[hei][row][col]+1;\n\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                    \n                }\n            }\n\n        }\n        \n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){\n                d[nh][nr][nc]=-1;\n                \n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n\n                    tpoint Tpoint;\n                    Tpoint.t=nextposition;\n                    Tpoint.flag=2;\n                    addq2(Tpoint);\n                    \n                    int r = queue2[rear2].t.row;\n                    int c = queue2[rear2].t.col;\n                    int h = queue2[rear2].t.hei;\n                    \n                    \n\n\n            }\n            else if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]==MAX){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n                \n            }\n\n        }\n        if(rear==front){\n            int lastflag=queue2[front2+1].flag;\n            for(i=front2+1;i<=rear2;i++){\n                if(queue2[i].flag==lastflag){\n                    addq(queue2[i].t);\n                    deleteq2();\n                    nr = queue2[i].t.row;\n                    nc = queue2[i].t.col;\n                    nh = queue2[i].t.hei;\n                    \n                    d[nh][nr][nc]=d[hei][row][col]+3;\n                    \n\n                }\n                else{\n                    queue2[i].flag-=lastflag;\n                    \n                }\n            }\n            laststep=lastflag;\n        }\n        \n\n    }\n    return arrive;\n}\n\nvoid path(int ***d,char ***maze,char*** road,int fr,int fc,int fh){\n\n    int row=fr;\n    int col=fc;\n    int hei=fh;\n    int i,j,k,nr,nc,nh;\n    road[hei][row][col]='*';\n\n    \n    while(maze[hei][row][col]!='S'){\n        \n        if ((d[hei][row+1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row+1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            \n            row++;\n        }\n        else if ((d[hei][row-1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row-1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            \n            row--;\n        }\n        else if ((d[hei][row][col+1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col+1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            col++;\n        }\n        else if ((d[hei][row][col-1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col-1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            col--;\n        }\n        else if(maze[hei-1][row][col]=='U' &&((d[hei-1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei-1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){\n            hei--;\n        }\n        else if(maze[hei+1][row][col]=='U' &&((d[hei+1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei+1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){\n            hei++;\n        }\n        road[hei][row][col]='*';\n    }\n}\nint main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    \n    char y;\n    int i,j,k;\n\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=2;control<=100;control++){\n        min=100000;\n        rear=-1;front=-1;\n        rear2=-1;front2=-1;\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            \n            char* bottom = make1darr(MAXLEN);\n            n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n                \n            }\n            char ***maze=make3darr(n\/2+1,n+2,n+2);\n            char ***road=make3darr(n\/2+1,n+2,n+2);\n            char ***mark=make3darr(n\/2+1,n+2,n+2);\n            int ***d=make3darrint(n\/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh,fr,fc,fh;\n            for(i=0;i<n\/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        if(maze[i][j][k]=='F'){\n                            fh=i;\n                            fr=j;\n                            fc=k;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            FILE *wfile;\n            sprintf(name,\"test%d_ans.txt\",control);\n            wfile = fopen(name,\"w\");\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                if(bfs(maze,d,sr,sc,sh)){\n                    \n                    \n                    path(d,maze,road,fr,fc,fh);\n                    \n                    \n                    fprintf(wfile,\"Path length: %d\\n\",min);\n                    fprintf(wfile,\"=====outMaze=====\\n\");\n                    for(i=0;i<n\/2+1;i++){\n                        for(j=i+1;j<n+2-i-1;j++){\n                            for(k=i+1;k<n+2-i-1;k++){\n                                fprintf(wfile,\"%c \",road[i][j][k] );\n                            }\n                            fprintf(wfile,\"\\n\");\n                        }\n                        fprintf(wfile,\"\\n\");\n                    }\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n\n            for(i = 0; i < n\/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(maze[i][j]);\n                }\n            }\n            for(i=0;i < n\/2+1; i++){\n                free(maze[i]);\n            }\n            free(maze);\n            for(i = 0; i < n\/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(mark[i][j]);\n                }\n            }\n            for(i=0;i < n\/2+1; i++){\n                free(mark[i]);\n            }\n            free(mark);\n            for(i = 0; i < n\/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(road[i][j]);\n                }\n            }\n            for(i=0;i < n\/2+1; i++){\n                free(road[i]);\n            }\n            free(road);\n            for(i = 0; i < n\/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(d[i][j]);\n                }\n            }\n            for(i=0;i < n\/2+1; i++){\n                free(d[i]);\n            }\n            free(d);\n        }\n        fclose(pfile);\n\n    }\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX_STACK_SIZE 100000\n#define MAX 401\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar** arr(int rows, int cols){\n    char **x;\n    MALLOC(x,rows*sizeof(*x));\n    int i;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n    }\n    return x;\n}\nint** arrc(int rows, int cols){\n    int **x;\n    MALLOC(x,rows*sizeof(*x));\n    int i;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int dir;\n} element;\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n}offsets;\noffsets move[4];\n\n\nint min=100000;\n\nint bfs(char** maze,int **d,int num,int sx,int sy){\n    int arrive=0;\n\n    queue[0].row = sx; queue[0].col = sy;\n    rear++;\n    \n    int i,j;\n    for(i=0;i<num+2;i++){\n        for(j=0;j<num+2;j++){\n            d[i][j]=MAX;\n        }\n    }\n    d[sx][sy]=0;\n    \n\n    element position;\n    int nr,nc;\n    int row,col;\n    while (rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        \n        if(maze[row][col]=='F'){\n            if(min>d[row][col]){\n                min=d[row][col];\n            }\n            arrive=1;\n            break;\n        }\n        \n        for(i=0;i<4;i++){\n            nr = position.row+move[i].vert;\n            nc = position.col+move[i].horiz;\n            \n            if (maze[nr][nc]!='X' && d[nr][nc]>d[row][col]+1){\n                d[nr][nc]=d[row][col]+1;;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;\n                addq(nextposition);\n            }\n        }\n        \n    }\n    return arrive;\n}\n\nvoid path(int **d,char **maze,char** road,int fx,int fy,int num){\n    int row=fx;\n    int col=fy;\n    int i,j,nr,nc;\n    road[row][col]='*';\n    while(maze[row][col]!='S'){\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            if (d[nr][nc] == d[row][col]-1){\n                \n                row=nr;\n                col=nc;\n                break;\n            }\n        }\n        road[row][col]='*';\n    }\n}\n\nint main(){\n\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    \n    int num,i,j,startx,starty,finalx,finaly;\n    FILE *rptr;\n    rptr = fopen(\"test.txt\",\"r\");\n    if(NULL==rptr){\n        printf(\"Open failure\");\n        return 1;\n    }\n    else{\n        fscanf(rptr,\"%d\\n\",&num);\n        char** maze = arr(num+2,num+2);\n        char** mark = arr(num+2,num+2);\n        char** road = arr(num+2,num+2);\n        int** d = arrc(num+2,num+2);\n        for(i=0;i<num+2;i++){\n            for(j=0;j<num+2;j++){\n                if(i==0 || j==0 || i==num+1 || j==num+1){\n                    \n                    maze[i][j]='X';\n                }\n                else{\n                    fscanf(rptr,\"%c \",&maze[i][j]);\n                    if(maze[i][j]=='S'){\n                        startx=i;\n                        starty=j;\n                    }\n                    if(maze[i][j]=='F'){\n                        finalx=i;\n                        finaly=j;\n                    }\n                }\n                road[i][j]=maze[i][j];\n                mark[i][j]=maze[i][j];\n            }\n        }\n        if(bfs(maze,d,num,startx,starty)){\n            path(d,maze,road,finalx,finaly,num);\n            for(i=1;i<num+2-1;i++){\n                for(j=1;j<num+2-1;j++){\n                    printf(\"%c \",road[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\u6700\u77ed\u8def\u5f91\u70ba%d\\n\",min);\n        }\n        else printf(\"The maze does not have a path\\n\" );\n        for(i = 0; i < num+2; i++) {\n            free(maze[i]);\n        }\n        free(maze);\n        for(i = 0; i < num+2; i++) {\n            free(mark[i]);\n        }\n        free(mark);\n        for(i = 0; i < num+2; i++) {\n            free(road[i]);\n        }\n        free(road);\n        free(d);\n    }\n    fclose(rptr);\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MAX_STACK_SIZE 100000\n#define MAX 455\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\n\nint*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int hei;\n    short int dir;\n} element;\n\nelement stack[MAX_STACK_SIZE];\nint top = -1;\nvoid stackFull(){\n    fprintf(stderr, \"\u5806\u758a\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid push(element item){\n    if(top >=MAX_STACK_SIZE-1){\n        stackFull();\n    }\n    stack [++top] = item;\n}\nelement pop(){\n    if(top==-1){\n        fprintf(stderr, \"\u5806\u758a\u5df2\u7a7a\");\n    }\n    return stack[top--];\n}\n\nelement stack2[MAX_STACK_SIZE];\nint top2 = -1;\nvoid push2(element item){\n    if(top2 >=MAX_STACK_SIZE-1){\n    }\n    stack2 [++top2] = item;\n}\nelement pop2(){\n    \n    return stack2[top2--];\n}\n\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n    short int hei;\n}offsets;\noffsets move[6];\n\n\nint min=10000;\nint n;\n\nint bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    \n\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n\/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    \n\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        \n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        \n\n        if(maze[hei][row][col]=='F'){\n            \n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            \n            arrive=1;\n        }\n        \n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            \n            \n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                \n                upanddown=1;\n            }\n            \n\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            \n            \n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n\n        }\n        \n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n\n        }\n        \n\n    }\n    return arrive;\n}\n\nvoid path(char*** maze,char*** road,char*** mark,int*** d,int sr,int sc,int sh){\n    top=-1;\n    top2=-1;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    position.dir = 0 ;\n    push(position);\n    \n\n    int i,j,k;\n    int nr,nc,nh;\n    int row,col,hei,dir;\n    int found=1;\n\n    while(top>-1){\n        position = pop();\n\n        \n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        dir = position.dir;\n\n\n        \n        if(!found){\n            \n            while(top2>-1){\n                element lastposition = pop2();\n                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;\n\n                \n\n                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){\n                    push2(lastposition);\n                    break;\n                }\n                road[lh][lr][lc]=maze[lh][lr][lc];\n                mark[lh][lr][lc]=maze[lh][lr][lc];\n            }\n        }\n        road[hei][row][col]='*';\n        mark[hei][row][col]='X';\n        push2(position);\n        if(maze[hei][row][col]=='F'){\n            break;\n        }\n\n        \n\n        found=0;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){\n                \n                found=1;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                push(nextposition);\n            }\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){\n\n                    found=1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    if(upanddown==1) nextposition.dir=4;\n                    else nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n\n\n        }\n        \n    }\n}\n\nint main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    \n    char y;\n    int i,j,k;\n\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=1;control<=100;control++){\n        min=100000;\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            \n            char* bottom = make1darr(MAXLEN);\n            n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n                \n            }\n            char ***maze=make3darr(n\/2+1,n+2,n+2);\n            char ***road=make3darr(n\/2+1,n+2,n+2);\n            char ***mark=make3darr(n\/2+1,n+2,n+2);\n            int ***d=make3darrint(n\/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh;\n            for(i=0;i<n\/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            FILE *wfile;\n            sprintf(name,\"4108056029test%d_ans.txt\",control);\n            wfile = fopen(name,\"w\");\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                if(bfs(maze,d,sr,sc,sh)){\n                    path(maze,road,mark,d,sr,sc,sh);\n                    \n                    fprintf(wfile,\"Path length: %d\\n\",min);\n                    fprintf(wfile,\"=====outMaze=====\\n\");\n                    for(i=0;i<n\/2+1;i++){\n                        for(j=i+1;j<n+2-i-1;j++){\n                            for(k=i+1;k<n+2-i-1;k++){\n                                fprintf(wfile,\"%c \",road[i][j][k] );\n                            }\n                            fprintf(wfile,\"\\n\");\n                        }\n                        fprintf(wfile,\"\\n\");\n                    }\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n            free(maze);\n            free(mark);\n            free(road);\n            free(d);\n        }\n        fclose(pfile);\n\n    }\n}\n"}
{"target":"flora0110","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MAX_STACK_SIZE 1000\n#define MAX 455\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\n\nint*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int hei;\n    short int dir;\n} element;\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n    short int hei;\n}offsets;\noffsets move[6];\n\n\nint min;\nint n;\n\nint bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    \n\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n\/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    \n\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        \n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        \n\n        if(maze[hei][row][col]=='F'){\n            \n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            min = d[hei][row][col];\n            \n            arrive=1;\n        }\n        \n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                \n                upanddown=1;\n            }\n            \n\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            \n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n\n        }\n        \n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n\n        }\n        \n\n    }\n    return arrive;\n}\nint pathnum=0;\n\nvoid dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){\n\n    int i,j,k;\n\n    if(count>=(min+5)){\n        return;\n    }\n    else{\n        int i;\n        int nh,nr,nc;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(mark[nh][nr][nc]!='X'){\n                mark[nh][nr][nc]='X';\n                road[nh][nr][nc]='*';\n                if(maze[nh][nr][nc]=='T'){\n                    dfs(maze,mark,road,nr,nc,nh,count+3);\n                }\n\n                else{\n                    dfs(maze,mark,road,nr,nc,nh,count+1);\n                }\n                mark[nh][nr][nc]=maze[nh][nr][nc];\n                road[nh][nr][nc]=maze[nh][nr][nc];\n\n            }\n        }\n        if(maze[hei][row][col]=='U'){\n            if(mark[hei+1][row][col]!='X'){\n                mark[hei+1][row][col]='X';\n                road[hei+1][row][col]='*';\n                if(maze[hei+1][row][col]=='T'){\n\n                    dfs(maze,mark,road,row,col,hei+1,count+3);\n\n                }\n                else if(maze[hei+1][row][col]=='F'){\n                    pathnum++;\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei+1,count+1);\n                }\n                mark[hei+1][row][col]=maze[hei+1][row][col];\n                road[hei+1][row][col]=maze[hei+1][row][col];\n            }\n\n\n\n        }\n        else if(maze[hei][row][col]=='D' && hei>0){\n            if(mark[hei-1][row][col]!='X'){\n\n                mark[hei-1][row][col]='X';\n                road[hei-1][row][col]='*';\n                if(mark[hei-1][row][col]='T'){\n                    dfs(maze,mark,road,row,col,hei-1,count+3);\n                }\n                else{\n\n                    dfs(maze,mark,road,row,col,hei-1,count+1);\n                }\n                mark[hei-1][row][col]=maze[hei-1][row][col];\n                road[hei-1][row][col]=maze[hei-1][row][col];\n            }\n        }\n\n    }\n\n}\n\nint main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    \n    char y;\n    int i,j,k;\n\n    FILE *pfile;\n    char name[50];\n    int control;\n    FILE *wfile;\n    wfile = fopen( \"4108056029output.txt\",\"w\" );\n    if( NULL == wfile ){\n        printf( \"wfile open failure\" );\n        return 1;\n    }\n    else{\n        for(control=1;control<=100;control++){\n            min = 100000;\n            sprintf(name,\"test%d.txt\",control);\n            pfile = fopen(name,\"r\");\n            if(NULL==pfile){\n                printf(\"Open failure\");\n                return 1;\n            }\n            else{\n                printf(\"reading %s\\n\",name);\n                \n                char* bottom = make1darr(MAXLEN);\n                n=0;\n                char y;\n                bottom[n]=fgetc(pfile);\n                while(bottom[n]!='\\n'){\n                    fgetc(pfile);\n                    bottom[++n]=fgetc(pfile);\n                    \n                }\n                char ***maze=make3darr(n\/2+1,n+2,n+2);\n                char ***road=make3darr(n\/2+1,n+2,n+2);\n                char ***mark=make3darr(n\/2+1,n+2,n+2);\n                int ***d=make3darrint(n\/2+1,n+2,n+2);\n                int len=0;\n                int sr,sc,sh;\n                for(i=0;i<n\/2+1;i++){\n                    for(j=0;j<n+2;j++){\n                        for(k=0;k<n+2;k++){\n                            if(j==0 || k==0 || j==n+1 || k==n+1){\n                                maze[i][j][k]='X';\n                            }\n                            else if(i==0 && j==1){\n                                maze[i][j][k]=bottom[k-1];\n                            }\n                            else if(j > len && j <= n-len && k > len && k <= n-len){\n                                fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                            }\n                            else{\n                                maze[i][j][k]='X';\n                            }\n                            if(maze[i][j][k]=='S'){\n                                sh=i;\n                                sr=j;\n                                sc=k;\n                            }\n                            road[i][j][k]=maze[i][j][k];\n                            mark[i][j][k]=maze[i][j][k];\n                        }\n                    }\n                    len++;\n                }\n                fprintf(wfile, \"test %d starts now.\\n\",control );\n                if(bfs(maze,d,sr,sc,sh)){\n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    dfs(maze,mark,road,sr,sc,sh,0);\n                    printf(\"Sortest path : %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n                free(bottom);\n                free(maze);\n                free(mark);\n                free(road);\n                free(d);\n            }\n            fclose(pfile);\n\n        }\n    }\n    fclose(wfile);\n}\n"}
{"target":"flora0110","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MAX_STACK_SIZE 1000\n#define MAX 455\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\n\nint*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int hei;\n    short int dir;\n} element;\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n    short int hei;\n}offsets;\noffsets move[6];\n\n\nint min;\nint n;\n\nint bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    \n\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n\/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    \n\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        \n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        \n\n        if(maze[hei][row][col]=='F'){\n            \n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            min = d[hei][row][col];\n            \n            arrive=1;\n        }\n        \n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                \n                upanddown=1;\n            }\n            \n\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            \n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n\n        }\n        \n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n\n        }\n        \n\n    }\n    return arrive;\n}\nint pathnum=0;\n\nvoid dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){\n\n    int i,j,k;\n\n    if(count>=(min+5)){\n        return;\n    }\n    else{\n        int i;\n        int nh,nr,nc;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(mark[nh][nr][nc]!='X'){\n                mark[nh][nr][nc]='X';\n                road[nh][nr][nc]='*';\n                if(maze[nh][nr][nc]=='T'){\n                    dfs(maze,mark,road,nr,nc,nh,count+3);\n                }\n\n                else{\n                    dfs(maze,mark,road,nr,nc,nh,count+1);\n                }\n                mark[nh][nr][nc]=maze[nh][nr][nc];\n                road[nh][nr][nc]=maze[nh][nr][nc];\n\n            }\n        }\n        if(maze[hei][row][col]=='U'){\n            if(mark[hei+1][row][col]!='X'){\n                mark[hei+1][row][col]='X';\n                road[hei+1][row][col]='*';\n                if(maze[hei+1][row][col]=='T'){\n\n                    dfs(maze,mark,road,row,col,hei+1,count+3);\n\n                }\n                else if(maze[hei+1][row][col]=='F'){\n                    pathnum++;\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei+1,count+1);\n                }\n                mark[hei+1][row][col]=maze[hei+1][row][col];\n                road[hei+1][row][col]=maze[hei+1][row][col];\n            }\n\n\n\n        }\n        else if(maze[hei][row][col]=='D' && hei>0){\n            if(mark[hei-1][row][col]!='X'){\n\n                mark[hei-1][row][col]='X';\n                road[hei-1][row][col]='*';\n                if(mark[hei-1][row][col]='T'){\n                    dfs(maze,mark,road,row,col,hei-1,count+3);\n                }\n                else{\n\n                    dfs(maze,mark,road,row,col,hei-1,count+1);\n                }\n                mark[hei-1][row][col]=maze[hei-1][row][col];\n                road[hei-1][row][col]=maze[hei-1][row][col];\n            }\n        }\n\n    }\n\n}\n\nint main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    \n    char y;\n    int i,j,k;\n\n    FILE *pfile;\n    char name[50];\n    int control;\n    FILE *wfile;\n    wfile = fopen( \"4108056029output.txt\",\"w\" );\n    if( NULL == wfile ){\n        printf( \"wfile open failure\" );\n        return 1;\n    }\n    else{\n        for(control=58;control<=58;control++){\n            min = 100000;\n            sprintf(name,\"test%d.txt\",control);\n            pfile = fopen(name,\"r\");\n            if(NULL==pfile){\n                printf(\"Open failure\");\n                return 1;\n            }\n            else{\n                printf(\"reading %s\\n\",name);\n                \n                char* bottom = make1darr(MAXLEN);\n                n=0;\n                char y;\n                bottom[n]=fgetc(pfile);\n                while(bottom[n]!='\\n'){\n                    fgetc(pfile);\n                    bottom[++n]=fgetc(pfile);\n                    \n                }\n                char ***maze=make3darr(n\/2+1,n+2,n+2);\n                char ***road=make3darr(n\/2+1,n+2,n+2);\n                char ***mark=make3darr(n\/2+1,n+2,n+2);\n                int ***d=make3darrint(n\/2+1,n+2,n+2);\n                int len=0;\n                int sr,sc,sh;\n                for(i=0;i<n\/2+1;i++){\n                    for(j=0;j<n+2;j++){\n                        for(k=0;k<n+2;k++){\n                            if(j==0 || k==0 || j==n+1 || k==n+1){\n                                maze[i][j][k]='X';\n                            }\n                            else if(i==0 && j==1){\n                                maze[i][j][k]=bottom[k-1];\n                            }\n                            else if(j > len && j <= n-len && k > len && k <= n-len){\n                                fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                            }\n                            else{\n                                maze[i][j][k]='X';\n                            }\n                            if(maze[i][j][k]=='S'){\n                                sh=i;\n                                sr=j;\n                                sc=k;\n                            }\n                            road[i][j][k]=maze[i][j][k];\n                            mark[i][j][k]=maze[i][j][k];\n                        }\n                    }\n                    len++;\n                }\n                fprintf(wfile, \"test %d starts now.\\n\",control );\n                if(bfs(maze,d,sr,sc,sh)){\n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    dfs(maze,mark,road,sr,sc,sh,0);\n                    printf(\"Sortest path : %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n                free(bottom);\n                free(maze);\n                free(mark);\n                free(road);\n                free(d);\n            }\n            fclose(pfile);\n\n        }\n    }\n    fclose(wfile);\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MAX_STACK_SIZE 100000\n#define MAX 455\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\n\nint*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\ntypedef struct{\n    short int row;\n    short int col;\n    short int hei;\n    short int dir;\n} element;\n\nelement stack[MAX_STACK_SIZE];\nint top = -1;\nvoid stackFull(){\n    fprintf(stderr, \"\u5806\u758a\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid push(element item){\n    if(top >=MAX_STACK_SIZE-1){\n        stackFull();\n    }\n    stack [++top] = item;\n}\nelement pop(){\n    if(top==-1){\n        fprintf(stderr, \"\u5806\u758a\u5df2\u7a7a\");\n    }\n    return stack[top--];\n}\n\nelement stack2[MAX_STACK_SIZE];\nint top2 = -1;\nvoid push2(element item){\n    if(top2 >=MAX_STACK_SIZE-1){\n    }\n    stack2 [++top2] = item;\n}\nelement pop2(){\n    \n    return stack2[top2--];\n}\n\nelement queue[MAX_STACK_SIZE];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"\u4f47\u5217\u5df2\u6eff\uff0c\u4e0d\u80fd\u518d\u52a0\u5165\u5143\u7d20\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==MAX_STACK_SIZE-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"\u4f47\u5217\u5df2\u7a7a\");\n    }\n    return queue[++front];\n}\n\ntypedef struct{\n    short int vert;\n    short int horiz;\n    short int hei;\n}offsets;\noffsets move[6];\n\n\nint pathnum=0;\nint min=100000;\nint step=0;\nvoid path(char*** maze,char*** mark,char*** road,int sr,int sc,int sh,int n,int pnum){\n    step=0;\n    min=100000;\n    pathnum=0;\n    top=-1;\n    int i,j,k;\n    \n    element position;\n    int row,col,hei,dir;\n    int nr,nc,nh;\n    int countp=0;\n    int found=1;\n    int inproad=0;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    push(position);\n    while(top>-1){\n        \n        position=pop();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        dir = position.dir;\n\n\n        if(!found){\n            \n            while(top2>-1){\n                element lastposition = pop2();\n                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;\n                \n                \n                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){\n\n                    push2(lastposition);\n                    break;\n                }\n                road[lh][lr][lc]=maze[lh][lr][lc];\n                mark[lh][lr][lc]=maze[lh][lr][lc];\n                if(maze[lh][lr][lc]=='T'){\n                    step=step-3;\n                }\n                else step--;\n                if(maze[lh][lr][lc]=='P'){\n                    countp--;\n                }\n                \n            }\n        }\n        mark[hei][row][col]='X';\n        road[hei][row][col]='*';\n        if(maze[hei][row][col]=='T'){\n            step=step+3;\n        }\n        else step++;\n        if(maze[hei][row][col]=='P'){\n            inproad=1;\n            countp++;\n        }\n        if(countp==pnum){\n            inproad=0;\n        }\n        push2(position);\n\n        printf(\"now %d %d %d\\n\",hei,row,col );\n        \n        road[hei][row][col]='@';\n        printf(\"road!! \\n\");\n        for(i=0;i<n\/2+1;i++){\n            for(j=i+1;j<n+2-i-1;j++){\n                for(k=i+1;k<n+2-i-1;k++){\n                    printf(\"%c \",road[i][j][k] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"countp %d\\n\\n\",countp );\n        printf(\"mark!! \\n\");\n        for(i=0;i<n\/2+1;i++){\n            for(j=i+1;j<n+2-i-1;j++){\n                for(k=i+1;k<n+2-i-1;k++){\n                    printf(\"%c \",mark[i][j][k] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"countp %d\\n\\n\",countp );\n        printf(\"step %d\\n\\n\",step );\n        road[hei][row][col]='*';\n        \n        if(maze[hei][row][col]=='F' && countp==pnum){\n            pathnum++;\n            if(min>step){\n                min=step;\n\n            }\n            printf(\"finally------------------------------------------------\\n\" );\n            \n            printf(\"road!! \\n\");\n            for(i=0;i<n\/2+1;i++){\n                for(j=i+1;j<n+2-i-1;j++){\n                    for(k=i+1;k<n+2-i-1;k++){\n                        printf(\"%c \",road[i][j][k] );\n                    }\n                    printf(\"\\n\");\n                }\n                printf(\"\\n\");\n            }\n            printf(\"countp %d pnum %d\\n\",countp,pnum );\n            printf(\"step %d\\n\\n\",step );\n            printf(\"pathnum %d\\n\",pathnum );\n            \n\n            \n        }\n        \n        found=0;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[nh][nr][nc]=='P'){\n                    found=1;\n                    \n\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[nh][nr][nc]!='X'){\n                    found=1;\n                    \n\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                    push(nextposition);\n                }\n            }\n\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='P'){\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[hei+1][row][col]=='P'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[hei+1][row][col]!='X'){\n                    \n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;\n                    push(nextposition);\n                }\n            }\n\n\n\n\n        }\n        if((maze[hei][row][col]=='D'  || maze[hei][row][col]=='P')&& hei>0){\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[hei-1][row][col]=='P'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[hei-1][row][col]!='X'){\n                    \n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n        }\n    }\n\n}\n\n\n\nint main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    \n    int n=0;\n    char y;\n    int i,j,k;\n\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=2;control<=2;control++){\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            \n            char* bottom = make1darr(MAXLEN);\n            int n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n                \n            }\n            char ***maze=make3darr(n\/2+1,n+2,n+2);\n            char ***road=make3darr(n\/2+1,n+2,n+2);\n            char ***mark=make3darr(n\/2+1,n+2,n+2);\n            int ***d=make3darrint(n\/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh;\n            int pnum=0;\n            for(i=0;i<n\/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        if(maze[i][j][k]=='P'){\n                            pnum++;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            \n            FILE *wfile;\n            wfile = fopen( \"4108056029output.txt\",\"a\" );\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                fprintf(wfile, \"test%d Starts now.\\n\",control );\n\n                \n                if(1){\n                    \n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    path(maze,mark,road,sr,sc,sh,n,pnum);\n                    printf(\"Shortest path: %d, The number of different paths: %d\\n\\n\",min-1,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, The number of different paths: %d\\n\\n\",min-1,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n            free(maze);\n            free(mark);\n            free(road);\n            free(d);\n        }\n        fclose(pfile);\n\n    }\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\ntypedef struct\n{\n    short int vert,horiz;\n}offsets;\noffsets move[4];\n\ntypedef struct\n{\n    short int row,col;\n}element;\nelement position;\n\nelement queue[1000];\nint rear = -1;\nint front = -1;\nvoid queueFull(){\n    fprintf(stderr, \"queue is full\");\n    exit(EXIT_FAILURE);\n}\nvoid addq(element item){\n    if(rear==100000-1){\n        queueFull();\n    }\n    queue[++rear] = item;\n}\nelement deleteq(){\n    if(front==rear){\n        fprintf(stderr, \"queue is empty\");\n    }\n    return queue[++front];\n}\nint bfs(char *maze,int *d,int n)\n{\n    printf(\"haha\\n\");\n    int row,col,nr,nc,i,j;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            d[i*n+j]=401;\n            if(maze[i*n+j]=='F')\n            {\n                d[i*n+j] = 0;\n            }\n        }\n    }\n\n    while(front!=rear){\n        printf(\"haha\\n\");\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n\n                printf(\"%3d \", d[i*n+j]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n        position = deleteq();\n        row=position.row;\n        col=position.col;\n        if(maze[row*n+col] == 'F')\n            return 1;\n        for(i=0;i<4;i++)\n        {\n            nr=row+move[i].vert;\n            nc=col+move[i].horiz;\n            if(maze[nr*n+nc] != 'X' && d[nr*n+nc] > d[row*n+col]+1)\n            {\n                d[nr*n+nc]=  d[row*n+col]+1;\n                position.row = nr;\n                position.col = nc;\n                addq(position);\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n\nFILE *p1;\n\nint main() {\n    char a[1000]={};\n    int x=0,i,j=1,n=0,row=0,col=0;\n    char maze[n+2][n+2],mark[n+2][n+2];\n    int num_maze[n+2][n+2];\n    p1=fopen(\"test.txt\",\"r\");\n    if(p1==NULL)\n    {\n        printf(\"p1 error\");\n    }\n        fscanf(p1,\"%d\\n\",&n);\n    printf(\"n:%d\\n\",n);\n    for(i=0; i<n*n ;i++)\n    {\n        a[i]=fgetc(p1);\n        printf(\"%c \", a[i]);\n        fgetc(p1);\n        if(i%n==n-1){\n            fgetc(p1);\n            printf(\"\\n\");\n        }\n\n    }\n    printf(\"----------------\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n\n            printf(\"%c \", a[i*n+j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    printf(\"----------------\\n\");\n    char ans[n+2][n+2];\n    for(i =0;i<n+2;i++)\n    {\n        for( j=0;j<n+2;j++)\n        {\n            if(i == 0  || i == n+1 || j == 0  || j == n+1 )\n            {\n                mark[i][j] = 'X';\n                maze[i][j] = 'X';\n            }\n            else\n            {\n                mark[i][j] = a[x];\n                maze[i][j] = a[x];\n                x++;\n                \n                \n                \n            }\n            \n            \n            \n            \n            printf(\"%c \", maze[i][j]);\n            ans[i][j]=maze[i][j];\n        }\n        \n        printf(\"\\n\");\n    }\n    \n    printf(\"\\n\");\n    for(i=0;i<n+2;i++)\n    {\n        for(j=0;j<n+2;j++)\n        {\n\n            printf(\"%c \", ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for(i=0; i<n+2 ;i++)\n    {\n        for( j=0;j<n+2;j++)\n        {\n            if(mark[i][j]== 'S')\n            {\n\n                mark[i][j] = '*';\n                maze[i][j] = '*';\n                position.row = i;\n                position.col = j;\n                row = position.row;\n                col = position.col;\n                addq(position);\n                printf(\"rear %d \",rear);\n            }\n        }\n    }\n\n\n    if(bfs(&maze[0][0],&num_maze[0][0],n+2)==1){\n        for(i=0;i<n+2;i++)\n        {\n            for(j=0;j<n+2;j++)\n            {\n\n                printf(\"%3d \", num_maze[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else{\n        printf(\"not exit\");\n    }\n\n\n\n\n\n\n\n\n    return 0;\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\nint main(){\n    FILE *ans;\n    FILE *myans;\n    char name[50];\n    ans=fopen(\"output_20201011.txt\",\"r\");\n    myans=fopen(\"4108056029output.txt\",\"r\");\n\n    if(NULL==ans || NULL == myans){\n        printf(\"Open failure\\n\");\n        if(NULL == myans){\n            printf(\"my ans Open failure\\n\");\n        }\n        if(NULL == ans){\n            printf(\"ans Open failure\\n\");\n        }\n        return 1;\n    }\n\n    else{\n        int nans,nmy,i;\n        int ansmin,ansLimit,anspathnum;\n        int min,Limit,pathnum;\n        for(i=0;i<100;i++){\n            fscanf(ans,\"test %d starts now.\",&nans);\n            \n            char y=fgetc(ans);\n            \n            fscanf(ans,\"Shortest path: %d, The number of different paths: %d\",&ansmin,&anspathnum);\n            \n            y=fgetc(ans);\n            \n            y=fgetc(ans);\n            \n\n            fscanf(myans,\"test %d starts now.\",&nmy);\n            \n\n            char x =fgetc(myans);\n            \n            fscanf(myans,\"Shortest path: %d, The number of different paths: %d\",&min,&pathnum);\n            \n            x=fgetc(myans);\n            \n            x=fgetc(myans);\n            \n            if(min!=ansmin){\n                printf(\"Shortest path error in test%d\\n\",nmy);\n                printf(\"ans's min : %d   my min : %d\\n\\n\",ansmin,min );\n            }\n            if(pathnum!=anspathnum){\n                printf(\"pathnum error in test%d\\n\",nmy);\n                printf(\"ans's  : %d   my  : %d\\n\\n\",anspathnum,pathnum );\n            }\n        }\n\n\n\n    }\n    fclose(ans);\n    fclose(myans);\n\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\nint main(){\n    FILE *ans;\n    FILE *myans;\n    int control;\n    char ansname[50],myansname[50];\n    FILE *pfile;\n    char name[50];\n\n    for(control=1;control<=100;control++){\n        sprintf(ansname,\"test%d_ans.txt\",control);\n        sprintf(myansname,\"4108056029test%d_ans.txt\",control);\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        ans=fopen(ansname,\"r\");\n        myans=fopen(myansname,\"r\");\n        if(NULL==ans || NULL == myans){\n            printf(\"Open failure\\n\");\n            if(NULL == myans){\n                printf(\"my ans Open failure\\n\");\n            }\n            if(NULL == ans){\n                printf(\"ans Open failure\\n\");\n\n            }\n            return 1;\n        }\n\n        else{\n            int i,j,k;\n            int nans,nmy;\n            fscanf(ans,\"%*[a-zA-Z] %*[a-zA-Z]: \");\n            fscanf(ans,\"%d\",&nans);\n            printf(\"%d: %d \",control,nans );\n            fscanf(myans,\"%*[a-zA-Z] %*[a-zA-Z]: \");\n            fscanf(myans,\"%d\",&nmy);\n            printf(\"%d\\n\",nmy );\n            if(nans!=nmy){\n                printf(\"path length error in test%d\\n\",control);\n                printf(\"ans : %d   myans : %d\\n\\n\",nans,nmy );\n            }\n\n            fscanf(ans,\"%*s\");\n            \n            \n            fscanf(myans,\"%*s\");\n            \n            char* ansb = make1darr(MAXLEN);\n            char* myb = make1darr(MAXLEN);\n            char* bottom = make1darr(MAXLEN);\n            int n=0;\n            char y;\n            fgetc(ans);\n            fgetc(myans);\n            \n            \n            \n            ansb[n]=fgetc(ans);\n            myb[n]=fgetc(myans);\n            bottom[n]=fgetc(pfile);\n            \n            while(ansb[n]!='\\n' || myb[n]!='\\n'){\n                fgetc(ans);\n                fgetc(myans);\n                fgetc(pfile);\n                ansb[++n]=fgetc(ans);\n                myb[n]=fgetc(myans);\n                bottom[n]=fgetc(pfile);\n            }\n            \n            int len=0;\n            char ansm[n\/2+1][n][n],mym[n\/2+1][n][n],maze[n\/2+1][n][n];\n            for(i=0;i<n\/2+1;i++){\n                for(j=0;j<n;j++){\n                    for(k=0;k<n;k++){\n                        if(i==0 && j==0){\n                            \n                            ansm[i][j][k]=ansb[k];\n                            mym[i][j][k]=myb[k];\n                            maze[i][j][k]=bottom[k];\n\n                        }\n                        else if(j >= len && j < n-len && k >= len && k < n-len){\n                            \n\n                            fscanf(ans,\"%c \",&ansm[i][j][k]);\n                            \n                            fscanf(myans,\"%c \",&mym[i][j][k]);\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n\n                        }\n                        else{\n                            \n                            mym[i][j][k]='X';\n                            ansm[i][j][k]='X';\n                            maze[i][j][k]='X';\n                        }\n\n                    }\n                }\n                len++;\n            }\n            \n            int check=0,counter=0;\n            int hei[10],row[10],col[10];\n            char ans[10],myans[10];\n            for(i=0;i<n\/2+1;i++){\n                for(j=0;j<n;j++){\n                    for(k=0;k<n;k++){\n                        if(mym[i][j][k]!=ansm[i][j][k]){\n                            \n                            \n                            row[counter]=j;\n                            col[counter]=k;\n                            hei[counter]=i;\n                            ans[counter]=ansm[i][j][k];\n                            myans[counter]=mym[i][j][k];\n                            counter++;\n                            check=1;\n                        }\n                    }\n                    \n                }\n                \n            }\n\n            if(check){\n                if((((row[0]+1==row[1]  || row[0]-1==row[1]) && (col[0]+1==col[1] ||  col[0]-1==col[1])) &&(ans[0]==myans[1]&&ans[1]==myans[0])&&counter==2)){\n                    \n                }\n                else {\n\n                    printf(\"map error\\n\");\n                    for(i=0;i<counter;i++){\n                        printf(\"in %d %d %d\\n\",hei[i],row[i],col[i]);\n                        printf(\"ans : %c  myans : %c\\n\", ans[i],myans[i]);\n                    }\n                    printf(\"\\n----------myans & ans---------\\n\" );\n                    for(i=0;i<n\/2+1;i++){\n                        for(j=0;j<n;j++){\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",mym[i][j][k] );\n                            }\n                            printf(\"    \");\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",ansm[i][j][k] );\n                            }\n                            printf(\"    \");\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",maze[i][j][k] );\n                            }\n                            printf(\"\\n\");\n                        }\n                        printf(\"\\n\");\n                    }\n\n                }\n\n            }\n        }\n        fclose(ans);\n        fclose(myans);\n    }\n\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAXLEN 14\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\nchar* make1darr(int n){\n    char *x;\n    MALLOC(x,n*sizeof(*x));\n    return x;\n}\nchar*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}\nint main(){\n    FILE *ans;\n    FILE *myans;\n    char name[50];\n    ans=fopen(\"output_20201011.txt\",\"r\");\n    myans=fopen(\"4108056029output.txt\",\"r\");\n\n    if(NULL==ans || NULL == myans){\n        printf(\"Open failure\\n\");\n        if(NULL == myans){\n            printf(\"my ans Open failure\\n\");\n        }\n        if(NULL == ans){\n            printf(\"ans Open failure\\n\");\n        }\n        return 1;\n    }\n\n    else{\n        int nans,nmy,i;\n        int ansmin,ansLimit,anspathnum;\n        int min,Limit,pathnum;\n        for(i=0;i<100;i++){\n            fscanf(ans,\"test %d starts now.\",&nans);\n            \n            char y=fgetc(ans);\n            \n            fscanf(ans,\"Shortest path: %d, Limit: %d, The number of different paths: %d\",&ansmin,&ansLimit,&anspathnum);\n            \n            y=fgetc(ans);\n            \n            y=fgetc(ans);\n            \n\n            fscanf(myans,\"test %d starts now.\",&nmy);\n            \n\n            char x =fgetc(myans);\n            \n            fscanf(myans,\"Shortest path: %d, Limit: %d, The number of different paths: %d\",&min,&Limit,&pathnum);\n            \n            x=fgetc(myans);\n            \n            x=fgetc(myans);\n            \n            if(min!=ansmin){\n                printf(\"Shortest path error in test%d\\n\",nmy);\n                printf(\"ans's min : %d   my min : %d\\n\\n\",ansmin,min );\n            }\n            if(pathnum!=anspathnum){\n                printf(\"pathnum error in test%d\\n\",nmy);\n                printf(\"ans's  : %d   my  : %d\\n\\n\",anspathnum,pathnum );\n            }\n        }\n\n\n\n    }\n    fclose(ans);\n    fclose(myans);\n\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\ntypedef struct List* listpointer;\ntypedef struct List{\n    int data;\n    listpointer pre;\n    listpointer next;\n}list;\nlistpointer first;\nint main(){\n    int i;\n    listpointer last,plat;\n    first=(listpointer)malloc(sizeof(list));\n    first->data=64;\n    last=first;\n    for(i=1;i<20;i++){\n        plat=(listpointer)malloc(sizeof(list));\n        plat->data=64;\n        plat->pre=last;\n        last->next=plat;\n        last=plat;\n    }\n    first->pre=plat;\n    plat->next=first;\n    FILE* rptr;\n    FILE* wfile;\n    rptr=fopen(\"test2-1.txt\",\"r\");\n    wfile=fopen(\"output2-1.txt\",\"w\");\n    if(rptr==NULL || wfile==NULL){\n        printf(\"open failure\\n\");\n        return 1;\n    }\n    else{\n        char control;\n        control=fgetc(rptr);\n        while(control!='\\n' && control!=EOF){\n            switch (control) {\n                case '+':\n                    first->data = ((first->data)+1)%64 +64;\n                    break;\n                case '-':\n                    first->data = (first->data)-1;\n                    if(first->data<64){\n                        first->data = first->data-64+91;\n                    }\n                    break;\n                case '>':\n                    first=first->next;\n                    break;\n                case '<':\n                    first=first->pre;\n                    break;\n                case '.':\n                    if(first->data==64){\n                        printf(\" \");\n                        fprintf(wfile,\" \");\n                    }\n                    else{\n                        printf(\"%c\",first->data);\n                        fprintf(wfile,\"%c\",first->data);\n                    }\n            }\n            control=fgetc(rptr);\n        }\n    }\n    fclose(wfile);\n    fclose(rptr);\n}\n"}
{"target":"flora0110","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#define MALLOC(p,s)\\\n    if(!((p)=malloc(s))){\\\n        fprintf(stderr,\"Insufficient memory\");\\\n        exit(EXIT_FAILURE);\\\n    }\ntypedef struct howto{\n    int toplat;\n    int tostat;\n}howto;\n\nint min;\nhowto fewstep(int now,int target,int* plat){\n    min=-1;\n    int i;\n    howto ans;\n    int sum;\n    int toplat,tostat;\n    int right,left;\n    int pr,pl;\n    for(i=0;i<20;i++){\n        if(i-now<0){\n            pr=i+1+19-now;\n        }\n        else{\n            pr=i-now;\n        }\n        if(now-i<0){\n            pl=i+1+19-now;\n        }\n        else{\n            pl=now-i;\n        }\n        toplat= (pr<pl)? pr:-pl;\n        if(target-plat[i]<0){\n            right = (90-plat[i])+1+target-64;\n        }\n        else{\n            right=target-plat[i];\n        }\n        if(plat[i]-target<0){\n            left = plat[i]-64+1+90-target;\n        }\n        else{\n            left=plat[i]-target;\n        }\n        tostat= (right<left)? right:-left;\n        sum=abs(tostat)+abs(toplat);\n        if(min==-1 || sum<min){\n            min=sum;\n            ans.toplat=toplat;\n            ans.tostat=tostat;\n        }\n    }\n    return ans;\n}\n\ntypedef struct howto2{\n    int toplat;\n    int tostat;\n    int toplat2;\n    int tostat2;\n\n}howto2;\nhowto2 fewstep2(int now,int target,int target2,int* plat){\n    min=-1;\n    int i,j;\n    howto2 ans;\n    int sum;\n    int toplat,tostat;\n    int right,left;\n    int pr,pl;\n    int sum2;\n    int toplat2,tostat2;\n    int right2,left2;\n    int pr2,pl2;\n    int temp;\n    for(i=0;i<20;i++){\n        if(i-now<0){\n            pr=i+1+19-now;\n        }\n        else{\n            pr=i-now;\n        }\n        if(now-i<0){\n            pl=i+1+19-now;\n        }\n        else{\n            pl=now-i;\n        }\n        toplat= (pr<pl)? pr:-pl;\n        \n        if(target-plat[i]<0){\n            right = (90-plat[i])+1+target-64;\n        }\n        else{\n            right=target-plat[i];\n        }\n        if(plat[i]-target<0){\n            left = plat[i]-64+1+90-target;\n        }\n        else{\n            left=plat[i]-target;\n        }\n        tostat= (right<left)? right:-left;\n        \n        sum=abs(tostat)+abs(toplat);\n        \n        temp=plat[i];\n        plat[i]=target;\n        \n\n        for(j=0;j<20;j++){\n\n            \n            if(j-i<0){\n                pr2=j+1+19-i;\n            }\n            else{\n                pr2=j-i;\n            }\n            \n            if(i-j<0){\n                pl2=j+1+19-i;\n            }\n            else{\n                pl2=i-j;\n            }\n            \n            toplat2= (pr2<pl2)? pr2:-pl2;\n            \n            if(target2-plat[j]<0){\n                right2 = (90-plat[j])+1+target2-64;\n            }\n            else{\n                right2=target2-plat[j];\n            }\n            if(plat[j]-target2<0){\n                left2 = plat[j]-64+1+90-target2;\n            }\n            else{\n\n                left2=plat[j]-target2;\n            }\n            \n\n            tostat2= (right2<left2)? right2:-left2;\n            \n            sum2=abs(tostat2)+abs(toplat2);\n            \n            \n            if(min==-1 || sum+sum2<min){\n                min=sum+sum2;\n                ans.toplat=toplat;\n                ans.tostat=tostat;\n                ans.toplat2=toplat2;\n                ans.tostat2=tostat2;\n            }\n\n        }\n        plat[i]=temp;\n    }\n    return ans;\n}\nint main(){\n    int i;\n    int *plat=malloc(20*sizeof(int));\n    int *plat2=malloc(20*sizeof(int));\n    for(i=0;i<20;i++){\n        plat[i]=64;\n        plat2[i]=plat[i];\n    }\n    FILE* rptr;\n    FILE* wfile;\n    rptr=fopen(\"test2-2.txt\",\"r\");\n    wfile=fopen(\"output2-2.txt\",\"w\");\n    if(rptr==NULL || wfile==NULL){\n        printf(\"open failure\\n\");\n        return 1;\n    }\n    else{\n        min = -1;\n        int now=0;\n        int now2=0;\n        char target;\n        char lasttarget;\n        howto ans;\n        howto2 ans2;\n        int i;\n        int count=1;\n        char *command;\n        char *command2;\n        MALLOC(command,10000*sizeof(char));\n        MALLOC(command2,10000*sizeof(char));\n        target=fgetc(rptr);\n        int totalstep=0;\n        int totalstep2=0;\n        int j1=0,j2=0;\n        while(target!='\\n' && target!=EOF){\n            if(target==' '){\n                target='@';\n                \n            }\n            ans=fewstep(now,target,plat);\n            now+=ans.toplat;\n            plat[now]=target;\n            for(i=0;i<abs(ans.toplat);i++){\n                if(ans.toplat>0){\n                    \n                    command[j1++]='>';\n                }\n                else{\n                    \n                    command[j1++]='<';\n                }\n                totalstep++;\n            }\n            for(i=0;i<abs(ans.tostat);i++){\n                if(ans.tostat>0){\n                    \n                    command[j1++]='+';\n                }\n                else{\n                    \n                    command[j1++]='-';\n                }\n                totalstep++;\n            }\n            \n            command[j1++]='.';\n            totalstep++;\n            \n            if(count==1){\n                lasttarget=target;\n                count++;\n            }\n            else if(count==2){\n                count=1;\n                ans2=fewstep2(now2,lasttarget,target,plat2);\n                now2+=ans2.toplat;\n                plat2[now2]=lasttarget;\n                for(i=0;i<abs(ans2.toplat);i++){\n                    if(ans2.toplat>0){\n                        \n                        command2[j2++]='>';\n                    }\n                    else{\n                        \n                        command2[j2++]='<';\n                    }\n                    totalstep2++;\n                }\n                for(i=0;i<abs(ans2.tostat);i++){\n                    if(ans2.tostat>0){\n                        \n                        command2[j2++]='+';\n                    }\n                    else{\n                        \n                        command2[j2++]='-';\n                    }\n                    totalstep2++;\n                }\n                \n                \n                command2[j2++]='.';\n                totalstep2++;\n                now2+=ans2.toplat2;\n                plat2[now2]=target;\n                for(i=0;i<abs(ans2.toplat2);i++){\n                    if(ans2.toplat2>0){\n                        \n                        command2[j2++]='>';\n                    }\n                    else{\n                        \n                        command2[j2++]='<';\n                    }\n                    totalstep2++;\n                }\n                for(i=0;i<abs(ans2.tostat2);i++){\n                    if(ans2.tostat2>0){\n                        \n                        command2[j2++]='+';\n                    }\n                    else{\n                        \n                        command2[j2++]='-';\n                    }\n                    totalstep2++;\n                }\n                \n                command2[j2++]='.';\n                totalstep2++;\n                \n                \n            }\n\n            target=fgetc(rptr);\n        }\n        if(count==2){\n            \n            ans=fewstep(now2,target,plat2);\n            now2+=ans.toplat;\n            plat2[now2]=target;\n            for(i=0;i<abs(ans.toplat);i++){\n                if(ans.toplat>0){\n                    \n                    command2[j2++]='>';\n                }\n                else{\n                    \n                    command2[j2++]='<';\n                }\n                totalstep2++;\n            }\n            for(i=0;i<abs(ans.tostat);i++){\n                if(ans.tostat>0){\n                    \n                    command2[j2++]='+';\n                }\n                else{\n                    \n                    command2[j2++]='-';\n                }\n                totalstep2++;\n            }\n            \n            command2[j2++]='.';\n            totalstep2++;\n        }\n        printf(\"\\ntotalstep1 %d \\n\",totalstep );\n        if(totalstep<=totalstep2){\n            for(i=0;i<j1;i++){\n                printf(\"%c\",command[i]);\n                fprintf(wfile,\"%c\",command[i]);\n            }\n            \n            fprintf(wfile,\"\\ntotalstep :%d\\n\",totalstep );\n        }\n        else{\n            for(i=0;i<j2;i++){\n                printf(\"%c\",command2[i]);\n                fprintf(wfile,\"%c\",command2[i]);\n            }\n            \n            fprintf(wfile,\"\\ntotalstep :%d\\n\",totalstep );\n        }\n    }\n    fclose(rptr);\n    fclose(wfile);\n}\n"}
{"target":"flora0110","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct Treenode* nodepointer;\nint max(int a,int b){\n    if(a>b){\n        return a;\n    }\n    else return b;\n}\ntypedef struct Treenode{\n    int sum;\n    int ls;\n    int rs;\n    int max;\n    nodepointer left;\n    nodepointer right;\n}node;\nnode* build(int l,int r,int* arr){\n    node* ptr=(node*)malloc(sizeof(node));\n    if(r==l){\n        ptr->sum=arr[l];\n        ptr->ls=arr[l];\n        ptr->rs=arr[l];\n        ptr->max=arr[l];\n        return ptr;\n    }\n    else{\n        int m=(l+r)\/2;\n        node* leftn=build(l,m,arr);\n        node* rightn=build(m+1,r,arr);\n        ptr->sum=leftn->sum+rightn->sum;\n        ptr->ls=max(leftn->ls,leftn->sum+rightn->ls);\n        ptr->rs=max(rightn->rs,rightn->sum+leftn->rs);\n        ptr->max=max(max(rightn->max,leftn->max),leftn->rs+rightn->ls);\n        ptr->left=leftn;\n        ptr->right=rightn;\n        return ptr;\n    }\n}\nvoid modify(int x,int value,int l,int r,node* ptr){\n    if(l==r){\n        ptr->sum=value;\n        ptr->ls=value;\n        ptr->rs=value;\n        ptr->max=value;\n        return;\n    }\n    int m=(r+l)\/2;\n    if(x<=m){\n        modify(x,value,l,m,ptr->left);\n    }\n    else{\n        modify(x,value,m+1,r,ptr->right);\n    }\n    ptr->sum=ptr->left->sum+ptr->right->sum;\n    ptr->ls=max(ptr->left->ls,ptr->left->sum+ptr->right->ls);\n    ptr->rs=max(ptr->right->rs,ptr->right->sum+ptr->left->rs);\n    ptr->max=max(max(ptr->right->max,ptr->left->max),ptr->left->rs+ptr->right->ls);\n    return;\n}\ntypedef struct imfor{\n    int sum;\n    int ls;\n    int rs;\n    int max;\n}imfor;\nimfor find(int a,int b,int l,int r,node* ptr){\n    imfor im;\n    if(a==l && b==r){\n        im.sum=ptr->sum;\n        im.ls=ptr->ls;\n        im.rs=ptr->rs;\n        im.max=ptr->max;\n        return im;\n    }\n    int m=(l+r)\/2;\n    if(b<=m){\n        im = find(a,b,l,m,ptr->left);\n        return im;\n    }\n    if(a>m){\n        im = find(a,b,m+1,r,ptr->right);\n        return im;\n    }\n    else{\n        imfor leftim=find(a,m,l,m,ptr->left);\n        imfor rightim=find(m+1,b,m+1,r,ptr->right);\n        im.sum=leftim.sum+rightim.sum;\n        im.ls=max(leftim.ls,leftim.sum+rightim.ls);\n        im.rs=max(rightim.rs,rightim.sum+leftim.rs);\n        im.max=max(max(rightim.max,leftim.max),leftim.rs+rightim.ls);\n        return im;\n    }\n}\nint main(){\n    FILE *rptr;\n    FILE *wptr;\n    rptr=fopen(\"test3.txt\",\"r\");\n    wptr=fopen(\"output1-1.txt\",\"w\");\n    if(rptr==NULL ||wptr==NULL){\n        printf(\"open error\\n\");\n        return 0;\n    }\n    int i,j;\n    int t,n,m;\n    fscanf(rptr,\"%d\\n\",&t);\n    printf(\"t: %d\\n\",t);\n    node* root;\n    int* arr;\n    for(i=0;i<t;i++){\n        fscanf(rptr,\"%d\\n\",&n);\n        printf(\"n: %d\\n\",n);\n        arr=(int*)malloc((n+1)*sizeof(int));\n        arr[0]=0;\n        for(j=1;j<n;j++){\n            fscanf(rptr,\"%d \",&arr[j]);\n        }\n        fscanf(rptr,\"%d\\n\",&arr[n]);\n        root=build(1,n,arr);\n        fscanf(rptr,\"%d\\n\",&m);\n        printf(\"m: %d\\n\",m);\n        char c;\n        int n1,n2;\n        for(j=0;j<m;j++){\n            fscanf(rptr,\"%c \",&c);\n            fscanf(rptr,\"%d %d\\n\",&n1,&n2);\n            if(c=='M'){\n                modify(n1,n2,1,n,root);\n            }\n            else if(c=='P'){\n                imfor ans=find(n1,n2,1,n,root);\n                fprintf(wptr,\"%d\\n\",ans.max);\n            }\n        }\n\n    }\n    fclose(wptr);\n    fclose(rptr);\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\ntypedef struct position{\n    int row;\n    int col;\n    int mirror;\n}position;\ntypedef struct Orien{\n    int row;\n    int col;\n}Orien;\nOrien orien[4];\nvoid mark(char**,int**,int,int,int,int,int,int,int,int,int);\n\nint n;\nint main(){\n    FILE* rptr;\n    FILE* wptr;\n    rptr=fopen(\"test4.txt\",\"r\");\n    if(rptr==NULL){\n        printf(\"error\\n\");\n        return 0;\n    }\n    \n    orien[0].row=1;\n    orien[0].col=0;\n    orien[1].row=0;\n    orien[1].col=-1;\n    orien[2].row=-1;\n    orien[2].col=0;\n    orien[3].row=0;\n    orien[3].col=1;\n    int v,z,g;\n    fscanf(rptr,\"%d %d %d\\n\",&v,&z,&g);\n    fscanf(rptr,\"%d\\n\",&n);\n    int** see=(int**)malloc((n*4)*sizeof(int*));\n    int i,j;\n    for(i=0;i<n*4;i++){\n        see[i]=(int*)malloc(4*sizeof(int));\n        fscanf(rptr,\"%d \",&see[i][0]);\n        if(i<n){\n            see[i][1]=1;\n            see[i][2]=i+1;\n            see[i][3]=0;\n        }\n        else if(i<2*n){\n            see[i][1]=n;\n            see[i][2]=i-n+1;\n            see[i][3]=2;\n        }\n        else if(i<3*n){\n            see[i][1]=i-2*n+1;\n            see[i][2]=1;\n            see[i][3]=3;\n        }\n        else{\n            see[i][1]=i-n*3+1;\n            see[i][2]=n;\n            see[i][3]=1;\n        }\n    }\n    char **ans=(char**)malloc((n+2)*sizeof(char*));\n    for(i=0;i<n+2;i++){\n        ans[i]=(char*)malloc((n+2)*sizeof(char));\n        for(j=0;j<n+2;j++){\n            if(i==0 || j==0 || i==n+1 || j==n+1){\n                ans[i][j]='x';\n            }\n            else{\n                fscanf(rptr,\"%c\",&ans[i][j]);\n            }\n        }\n        if(i!=0 &&i!=n+1){\n            fgetc(rptr);\n        }\n    }\n    mark(ans,see,0,v,z,g,see[0][0],1,1,0,0);\n    free(see);\n    free(ans);\n    for(i=0;i<n+2;i++){\n        free(ans[i]);\n    }\n    for(i=0;i<3;i++){\n        free(see[i]);\n    }\n    fclose(rptr);\n}\n\nvoid mark(char** ans,int** see,int seen,int v,int z,int g,int monsta,int row,int col,int mirror,int dir){\n    int i,j;\n    char origin=ans[row][col];\n    if(v<0||z<0||g<0||monsta<0 || monsta>see[seen][0]){\n        return;\n    }\n    if(ans[row][col]=='x' && monsta!=0){\n        return;\n    }\n    if(ans[row][col]=='x' && monsta==0){\n        if(seen==4*n-1){\n            \n            for(i=0;i<n+2;i++){\n                for(j=0;j<n+2;j++){\n                    printf(\"%c\",ans[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            return;\n        }\n        mark(ans,see,seen+1,v,z,g,see[seen+1][0],see[seen+1][1],see[seen+1][2],0,see[seen+1][3]);\n        return;\n    }\n    if(ans[row][col]=='\\\\'){\n        mirror=1;\n        switch (dir) {\n            case 0: dir=3;break;      case 1: dir=2;break;     case 2: dir=1;break;    case 3: dir=0;break;\n        }\n    }\n    else if(ans[row][col]=='\/'){\n        mirror=1;\n        switch (dir) {\n            case 0: dir=1;break;  case 1: dir=0;break;  case 2: dir=3;break;  case 3: dir=2;break;\n        }\n    }\n    int nextrow=row+orien[dir].row,nextcol=col+orien[dir].col,nextmonsta=monsta;\n    if(ans[row][col]=='Z'||ans[row][col]=='G'||ans[row][col]=='V'){\n        if(ans[row][col]=='Z') nextmonsta--;\n        if(mirror==1 && ans[row][col]=='G') nextmonsta--;\n        else if(mirror==0 && ans[row][col]=='V') nextmonsta--;\n        mark(ans,see,seen,v,z,g,nextmonsta,nextrow,nextcol,mirror,dir);\n    }\n    else if(ans[row][col]=='.'){\n        ans[row][col]='Z';\n        mark(ans,see,seen,v,z-1,g,monsta-1,nextrow,nextcol,mirror,dir);\n        if(mirror==1){\n            ans[row][col]='G';\n            mark(ans,see,seen,v,z,g-1,monsta-1,nextrow,nextcol,mirror,dir);\n            ans[row][col]='V';\n            mark(ans,see,seen,v-1,z,g,monsta,nextrow,nextcol,mirror,dir);\n        }\n        else if(mirror==0){\n            ans[row][col]='G';\n            mark(ans,see,seen,v,z,g-1,monsta,nextrow,nextcol,mirror,dir);\n            ans[row][col]='V';\n            mark(ans,see,seen,v-1,z,g,monsta-1,nextrow,nextcol,mirror,dir);\n        }\n    }\n    else mark(ans,see,seen,v,z,g,monsta,nextrow,nextcol,mirror,dir);\n    ans[row][col]=origin;\n    return;\n}\n"}
{"target":"flora0110","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct all{\n    int *ori;\n    int *chan_to;\n}All;\nint at_where(char**,char*,int*);\nint pass(All*,int*,int,int,int);\nint main(){\n    FILE* rptr;\n    rptr=fopen(\"test8.txt\",\"r\");\n    if(rptr==NULL){\n        printf(\"error\\n\");\n        return 0;\n    }\n    int n,i,j;\n    fscanf(rptr,\"%d\\n\",&n);\n    char* token;\n    const char* delim = \" \";\n    All* all=(All*)malloc(300*sizeof(All));\n    int alln=0;\n    char **obj=(char**)malloc(18000*sizeof(char*));\n    int objn=0;\n    int flyat,pigat;\n    int* ori;\n    int* chan_to;\n    for(i=0;i<n;i++){\n        char str[300];\n        fgets(str,300,rptr);\n        token = strtok(str,delim);\n        int chan=0;\n        ori=(int*)malloc(18000*sizeof(int));\n        chan_to=(int*)malloc(18000*sizeof(int));\n        int orin=0,chan_ton=0;\n        int isthat=0;\n        while( token != NULL ){\n            if('Z'>=token[0] && token[0]>='A'){\n                if(token[strlen(token)-1]=='\\n') token[strlen(token)-1]='\\0';\n                int at=at_where(obj,token,&objn);\n                if(chan==0){\n                    ori[orin++]=at;\n                }\n                else if(chan==1){\n                    chan_to[chan_ton++]=at;\n                }\n                if (strlen(token)==3 && strncmp(\"FLY\",token,strlen(token))==0) flyat=at;\n                else if (strlen(token)==4 && strncmp(\"PIGS\",token,strlen(token))==0) pigat=at;\n\n            }\n            if((strlen(token)==3 && strncmp(\"are\",token,strlen(token))==0)||\\\n                (strlen(token)==3 && strncmp(\"can\",token,strlen(token))==0) && isthat==0 ||\\\n                (strlen(token)==4 && strncmp(\"have\",token,strlen(token))==0)){\n                chan=1;\n            }\n            if(strlen(token)==4 && strncmp(\"that\",token,strlen(token))==0){\n                isthat=1;\n            }\n            if(strlen(token)==3 && strncmp(\"can\",token,strlen(token))==0 && isthat==1){\n                isthat=0;\n            }\n            token=strtok(NULL,delim);\n        }\n        ori[orin]=-1;\n        chan_to[chan_ton]=-1;\n        all[alln].ori=ori;\n        all[alln++].chan_to=chan_to;\n    }\n    int *test=(int*)malloc((objn+1)*sizeof(int));\n    memset(test,0,objn+1);\n    test[pigat]=1;\n    int allcheck=pass(all,test,alln,flyat,pigat);\n    while(allcheck!=0 && allcheck!=2){\n        allcheck=pass(all,test,alln,flyat,pigat);\n    }\n    if(allcheck==2){\n        printf(\"All pigs can fly\\n\");\n    }\n    else{\n        for(i=0;i<objn;i++){\n            for(j=0;j<objn;j++){\n                test[j]=0;\n                if(j==i) test[j]=1;\n            }\n            allcheck=pass(all,test,alln,flyat,pigat);\n            while(allcheck!=0 && allcheck!=2){\n                allcheck=pass(all,test,alln,flyat,pigat);\n            }\n            if(allcheck==2) {\n                break;\n            }\n        }\n        if(allcheck==2){\n            printf(\"Some pigs can fly\\n\");\n        }\n        else{\n            printf(\"No pigs can fly\\n\");\n        }\n    }\n}\nint pass(All all[300],int* test,int alln,int flyat,int pigat){\n    int i,j,allcheck=0;\n    for(i=0;i<alln;i++){\n        int check=1;\n        for(j=0;all[i].ori[j]!=-1;j++){\n            if(test[all[i].ori[j]]==0) {\n                check=0;\n                break;\n            }\n        }\n        if(check){\n            for(j=0;all[i].chan_to[j]!=-1;j++){\n                if(test[all[i].chan_to[j]]==0) allcheck=1;\n                test[all[i].chan_to[j]]=1;\n            }\n        }\n    }\n    if(test[flyat]==1 && test[pigat]==1){\n        return 2;\n    }\n    else {\n        return allcheck;\n    }\n}\nint at_where(char** obj,char* token,int* objn){\n    int i,j,check=0;\n    char *new=(char*)malloc(300*sizeof(char));\n    for(i=0;i<strlen(token);i++){\n        new[i]=token[i];\n    }\n    new[i]='\\0';\n    for(i=0;i<*objn;i++){\n        if(strcmp(obj[i],token)==0 && strncmp(obj[i],token,strlen(token))==0){\n            check=1;\n            return i;\n        }\n    }\n    if(!check){\n        obj[(*objn)++]=new;\n        return (*objn)-1;\n    }\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state,\n  DemoFOTAUpdateWorkflowEngine_activating__state,\n  DemoFOTAUpdateWorkflowEngine_reverting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);\n}\n\nvoid fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            \n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateActivation();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateReversion();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          \n          \n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          \n          \n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);\n}\n\nvoid fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n}\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            \n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflowNVSFlashPersistence.h\"\n\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include \"nvs_flash.h\"\n#include <stdlib.h>\n\nvoid saveState(int16_t state)\n{\n  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));\n  if (nvsHandle == NULL) \n  {\n    return;\n  }\n  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READWRITE, nvsHandle) == ESP_OK) \n  {\n    nvs_set_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t) state));\n    nvs_commit(*nvsHandle);\n    nvs_close(*nvsHandle);\n    free(nvsHandle);\n    return;\n  }\n  free(nvsHandle);\n  printf(\"Failed write statemachine state to NVS\\n\");\n}\n\nint16_t loadState(void)\n{\n  int16_t state = 0;\n  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));\n  if (nvsHandle == NULL) \n  {\n    return 0;\n  }\n  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READONLY, nvsHandle) == ESP_OK) \n  {\n    nvs_get_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t *)(&state)));\n  }\n  nvs_close(*nvsHandle);\n  free(nvsHandle);\n  \n  if (state == -1) \n  {\n    return 0;\n  }\n  return state;\n}\n"}
{"target":"fotahub","func":"\n#include \"Main.h\"\n\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"SinglePartitionDemoFirmwareUpdateInfoSerialReader.h\"\n#include \"BlinkDrv.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include \"freertos\/FreeRTOS.h\"\n#include \"freertos\/task.h\"\n\nvoid app_main(void)\n{\n  nvs_init();\n  uart_init(UART_UNIT, &UART_CONFIG, UART_TX_PIN, UART_RX_PIN);\n  blink_init(BLINK_PERIOD);\n  wifi_init();\n  \n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &ESP32_FOTA_UPDATE_CLIENT_CONFIG);\n  \n  wifiStation_connect(WIFI_STATION_SSID, WIFI_STATION_PASSPHRASE);\n  \n  xTaskCreate(&demoTasks,\"demoTasks\",TASK_DEFAULT_STACK_SIZE * 5,NULL,10,NULL);\n}\n\nvoid demoTasks(void *args)\n{\n  while (true)\n  {\n    uart_recvTask();\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n    blink_run();\n    vTaskDelay(10);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoSerialReader.h\"\n\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"BinHexConverter.h\"\n#include \"FotaHub.h\"\n#include \"DemoProductInfo.h\"\n#include \"ctype.h\"\n#include <stdlib.h>\n#include <string.h>\n\nenum FirmwareUpdateInfoParser__inevents {\n  FirmwareUpdateInfoParser_characterReceived__event,\n  FirmwareUpdateInfoParser_updateInfoPickedUp__event\n};\ntypedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;\n\nenum FirmwareUpdateInfoParser__states {\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,\n  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,\n  FirmwareUpdateInfoParser_yielding__state\n};\ntypedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;\n\nstruct FirmwareUpdateInfoParser__data {\n  FirmwareUpdateInfoParser__states_t __currentState;\n  size_t characterIdx;\n};\ntypedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;\n\nstatic void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);\n\nstatic bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);\n\nstatic char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic FirmwareUpdateInfoParser__data_t updateInfoParser;\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  \n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}\n\nvoid firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}\n\nstatic void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)\n{\n  instance->characterIdx = 0;\n  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n}\n\nstatic bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            \n            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) \n          {\n            \n            \n            updateVersion[instance->characterIdx] = '\\0';\n            instance->characterIdx = 0;\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) \n          {\n            \n            printf(\"Firmware update request with missing version received\\n\");\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            printf(\"Empty firmware update request received\\n\");\n            instance->characterIdx = 0;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            instance->characterIdx = 0;\n            \n            \n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != LF) \n          {\n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF) \n          {\n            \n            memset(updateVersion, 0, sizeof(updateVersion));\n            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            \n            if (((instance->characterIdx & (1)) == 0)) \n            {\n              \n              updateVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;\n            }\n            else\n            {\n              \n              (updateVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));\n            }\n            instance->characterIdx++;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;\n            break;\n          }\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            printf(\"Received firmware update verification data too long (max. length = %d)\\n\", getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_yielding__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:\n        {\n          \n          instance->characterIdx = 0;\n          \n          \n          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoSerialReader.h\"\n\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"BinHexConverter.h\"\n#include \"FotaHub.h\"\n#include \"DemoProductInfo.h\"\n#include \"ctype.h\"\n#include <stdlib.h>\n#include <string.h>\n\nenum FirmwareUpdateInfoParser__inevents {\n  FirmwareUpdateInfoParser_characterReceived__event,\n  FirmwareUpdateInfoParser_updateInfoPickedUp__event\n};\ntypedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;\n\nenum FirmwareUpdateInfoParser__states {\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,\n  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,\n  FirmwareUpdateInfoParser_yielding__state\n};\ntypedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;\n\nstruct FirmwareUpdateInfoParser__data {\n  FirmwareUpdateInfoParser__states_t __currentState;\n  size_t characterIdx;\n};\ntypedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;\n\nstatic void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);\n\nstatic bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);\n\nstatic char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic FirmwareUpdateInfoParser__data_t updateInfoParser;\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  \n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}\n\nvoid firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}\n\nstatic void FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)\n{\n  instance->characterIdx = 0;\n  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n}\n\nstatic bool FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            \n            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) \n          {\n            \n            \n            updateVersion[instance->characterIdx] = '\\0';\n            instance->characterIdx = 0;\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) \n          {\n            \n            printf(\"Firmware update request with missing version received\\n\");\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            printf(\"Empty firmware update request received\\n\");\n            instance->characterIdx = 0;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            instance->characterIdx = 0;\n            \n            \n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != LF) \n          {\n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF) \n          {\n            \n            memset(updateVersion, 0, sizeof(updateVersion));\n            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            \n            if (((instance->characterIdx & (1)) == 0)) \n            {\n              \n              updateVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;\n            }\n            else\n            {\n              \n              (updateVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));\n            }\n            instance->characterIdx++;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;\n            break;\n          }\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            printf(\"Received firmware update verification data too long (max. length = %d)\\n\", getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_yielding__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:\n        {\n          \n          instance->characterIdx = 0;\n          \n          \n          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"fotahub","func":"\n#include \"UARTDefinitions.h\"\n\nuart_config_t const UART_BASIC_CONFIG_DEFAULT_FOR_115200_Bd = \n{\n  .baud_rate = UART_BAUDRATE_115200, \n  .data_bits = UART_DATA_8_BITS, \n  .parity = UART_PARITY_DISABLE, \n  .stop_bits = UART_STOP_BITS_1, \n  .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, \n  .rx_flow_ctrl_thresh = 122\n};\n\nUARTPinConfig_t const UART0_PIN_CONFIG_DEFAULT = \n{\n  .tx = GPIO_NUM_1, \n  .rx = GPIO_NUM_3, \n  .rts = GPIO_NUM_22, \n  .cts = GPIO_NUM_19\n};\n\n\nUARTPinConfig_t const UART1_PIN_CONFIG_DEFAULT = \n{\n  .tx = GPIO_NUM_4, \n  .rx = GPIO_NUM_5, \n  .rts = GPIO_NUM_21, \n  .cts = GPIO_NUM_18\n};\n\n\nUARTPinConfig_t const UART2_PIN_CONFIG_DEFAULT = \n{\n  .tx = GPIO_NUM_17, \n  .rx = GPIO_NUM_16, \n  .rts = GPIO_NUM_26, \n  .cts = GPIO_NUM_23\n};\n"}
{"target":"fotahub","func":"\n#include \"UARTDrv.h\"\n\n#include \"freertos\/FreeRTOS.h\"\n#include <stdlib.h>\n\nstatic uart_port_t uartUnit;\n\nvoid uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  \n  uart_param_config(unit, config);\n  \n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  \n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  \n  uart_set_mode(unit, UART_MODE_UART);\n}\n\nvoid uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  \n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  \n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 \/ portTICK_RATE_MS);\n  \n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"UARTDrv.h\"\n\n#include \"freertos\/FreeRTOS.h\"\n#include <stdlib.h>\n\nstatic uart_port_t uartUnit;\n\nvoid uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  \n  uart_param_config(unit, config);\n  \n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  \n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  \n  uart_set_mode(unit, UART_MODE_UART);\n}\n\nvoid uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  \n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  \n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 \/ portTICK_RATE_MS);\n  \n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"WiFiHelper.h\"\n\nstatic esp_err_t setMode(wifi_mode_t mode, bool enable);\n\nesp_err_t enableStationMode(void)\n{\n  return setMode(WIFI_MODE_STA, true);\n}\n\nesp_err_t disableStationMode(void)\n{\n  return setMode(WIFI_MODE_STA, false);\n}\n\nesp_err_t enableAccessPointMode(void)\n{\n  return setMode(WIFI_MODE_AP, true);\n}\n\nesp_err_t disableAccessPointMode(void)\n{\n  return setMode(WIFI_MODE_AP, false);\n}\n\nstatic esp_err_t setMode(wifi_mode_t mode, bool enable)\n{\n  wifi_mode_t currentMode;\n  esp_err_t error = ESP_OK;\n  \n  esp_wifi_get_mode(&currentMode);\n  printf(\"Old wifi mode: %u\\n\", ((uint32_t)((currentMode))));\n  \n  bool isEnabled = (currentMode & mode) != 0;\n  if (isEnabled != enable) \n  {\n    if (enable) \n    {\n      error = esp_wifi_set_mode(((wifi_mode_t)((currentMode | mode))));\n    }\n    else\n    {\n      wifi_mode_t nextMode = ((wifi_mode_t)((currentMode & (~mode))));\n      if (nextMode == WIFI_MODE_NULL) \n      {\n        \n        esp_wifi_set_mode(WIFI_MODE_NULL);\n        error = esp_wifi_stop();\n      }\n      else\n      {\n        error = esp_wifi_set_mode(nextMode);\n      }\n    }\n  }\n  return error;\n}\n\nbool getIPConfig(IPConfig_t *pIPConfig, wifi_mode_t mode)\n{\n  if (pIPConfig == NULL) \n  {\n    return false;\n  }\n  tcpip_adapter_ip_info_t info;\n  if (tcpip_adapter_get_ip_info((mode == WIFI_MODE_AP) ? (TCPIP_ADAPTER_IF_AP) : (TCPIP_ADAPTER_IF_STA), &info) == ESP_OK) \n  {\n    pIPConfig->localIPAddress = info.ip.addr;\n    pIPConfig->gatewayIPAddress = info.gw.addr;\n    pIPConfig->subnetMask = info.netmask.addr;\n    return true;\n  }\n  return false;\n}\n"}
{"target":"fotahub","func":"\n#include \"WiFiStationDrv.h\"\n\n#include \"FotaHub.h\"\n#include \"esp_event_loop.h\"\n#include \"esp_wifi.h\"\n#include <string.h>\n\nstatic esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event);\n\nvoid wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}\n\nbool wifiStation_connect(char const *ssid, char const *passphrase)\n{\n  wifi_config_t config = \n  {\n    .sta = \n    {\n      .bssid_set = false\n    }\n  };\n  size_t ssidLen = strlen(ssid);\n  memcpy(config.sta.ssid, ssid, ssidLen);\n  if (ssidLen < sizeof(config.sta.ssid)) \n  {\n    config.sta.ssid[ssidLen] = 0;\n  }\n  size_t passphraseLen = strlen(passphrase);\n  memcpy(config.sta.password, passphrase, passphraseLen);\n  if (passphraseLen < sizeof(config.sta.password)) \n  {\n    config.sta.password[passphraseLen] = 0;\n  }\n  \n  esp_wifi_set_config(WIFI_IF_STA, &config);\n  esp_wifi_start();\n  esp_wifi_connect();\n  \n  return true;\n}\n\nstatic esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}\n"}
{"target":"fotahub","func":"\n#include \"WiFiStationDrv.h\"\n\n#include \"FotaHub.h\"\n#include \"esp_event_loop.h\"\n#include \"esp_wifi.h\"\n#include <string.h>\n\nstatic esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event);\n\nvoid wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}\n\nbool wifiStation_connect(char const *ssid, char const *passphrase)\n{\n  wifi_config_t config = \n  {\n    .sta = \n    {\n      .bssid_set = false\n    }\n  };\n  size_t ssidLen = strlen(ssid);\n  memcpy(config.sta.ssid, ssid, ssidLen);\n  if (ssidLen < sizeof(config.sta.ssid)) \n  {\n    config.sta.ssid[ssidLen] = 0;\n  }\n  size_t passphraseLen = strlen(passphrase);\n  memcpy(config.sta.password, passphrase, passphraseLen);\n  if (passphraseLen < sizeof(config.sta.password)) \n  {\n    config.sta.password[passphraseLen] = 0;\n  }\n  \n  esp_wifi_set_config(WIFI_IF_STA, &config);\n  esp_wifi_start();\n  esp_wifi_connect();\n  \n  return true;\n}\n\nstatic esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}\n"}
{"target":"fotahub","func":"\n#include \"BinHexConverter.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase);\n\nstatic inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}\n\nuint8_t ICACHE_FLASH_ATTR convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}\n\nsize_t ICACHE_FLASH_ATTR convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}\n\nuint8_t ICACHE_FLASH_ATTR convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}\n\nsize_t ICACHE_FLASH_ATTR convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}\n\nsize_t ICACHE_FLASH_ATTR convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  os_memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"BinHexConverter.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase);\n\nstatic inline char ICACHE_FLASH_ATTR convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}\n\nuint8_t ICACHE_FLASH_ATTR convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}\n\nsize_t ICACHE_FLASH_ATTR convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}\n\nuint8_t ICACHE_FLASH_ATTR convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}\n\nsize_t ICACHE_FLASH_ATTR convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}\n\nsize_t ICACHE_FLASH_ATTR convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  os_memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"BlinkDrv.h\"\n\n#include <eagle_soc.h>\n#include <gpio.h>\n\nstatic uint16_t currentTick;\n\nstatic uint16_t expirationTick;\n\nvoid ICACHE_FLASH_ATTR blink_init(uint16_t runPeriod, uint16_t blinkPeriod)\n{\n  PIN_FUNC_SELECT(BLINK_PIN_NAME,BLINK_FUNC_GPIO);\n  \n  currentTick = 0;\n  expirationTick = (blinkPeriod >> 1) \/ runPeriod;\n}\n\nvoid ICACHE_FLASH_ATTR blink_run(void)\n{\n  if (currentTick == expirationTick) \n  {\n    uint32_t state = GPIO_INPUT_GET(BLINK_PIN);\n    (state ^= (0x01u));\n    GPIO_OUTPUT_SET(BLINK_PIN,state);\n    \n    currentTick = 0;\n  }\n  else\n  {\n    currentTick++;\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"BlinkDrv.h\"\n\n#include <eagle_soc.h>\n#include <gpio.h>\n\nstatic uint16_t currentTick;\n\nstatic uint16_t expirationTick;\n\nvoid ICACHE_FLASH_ATTR blink_init(uint16_t runPeriod, uint16_t blinkPeriod)\n{\n  PIN_FUNC_SELECT(BLINK_PIN_NAME,BLINK_FUNC_GPIO);\n  \n  currentTick = 0;\n  expirationTick = (blinkPeriod >> 1) \/ runPeriod;\n}\n\nvoid ICACHE_FLASH_ATTR blink_run(void)\n{\n  if (currentTick == expirationTick) \n  {\n    uint32_t state = GPIO_INPUT_GET(BLINK_PIN);\n    (state ^= (0x01u));\n    GPIO_OUTPUT_SET(BLINK_PIN,state);\n    \n    currentTick = 0;\n  }\n  else\n  {\n    currentTick++;\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateSelfTest.h\"\n\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <time.h>\n\nstatic bool ICACHE_FLASH_ATTR runRandomSelfTest(uint8_t successRate);\n\nvoid ICACHE_FLASH_ATTR fotaUpdateSelfTest_init(void)\n{\n  srand(((uint32_t)(time(NULL))));\n}\n\nstatic bool ICACHE_FLASH_ATTR runRandomSelfTest(uint8_t successRate)\n{\n  if (((uint8_t)((os_random() % 100))) >= (successRate)) \n  {\n    os_printf(\"Firmware self test failed (reason: simulated pseudo-random failure)\\n\");\n    return false;\n  }\n  return true;\n}\n\nvoid ICACHE_FLASH_ATTR validateFirmwareUpdateActivation(void)\n{\n  os_printf(\"Validating firmware update\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) \n  {\n    os_printf(\"Firmware update successfully activated\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);\n  }\n  else\n  {\n    os_printf(\"Firmware update activation failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);\n  }\n}\n\nvoid ICACHE_FLASH_ATTR validateFirmwareUpdateReversion(void)\n{\n  os_printf(\"Validating previous firmware\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) \n  {\n    os_printf(\"Firmware update successfully reverted\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);\n  }\n  else\n  {\n    os_printf(\"Firmware update reversion failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state,\n  DemoFOTAUpdateWorkflowEngine_activating__state,\n  DemoFOTAUpdateWorkflowEngine_reverting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);\n\nstatic bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid ICACHE_FLASH_ATTR fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid ICACHE_FLASH_ATTR fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n\nstatic bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          os_printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) == 0) \n          {\n            \n            os_printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateActivation();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateReversion();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          \n          \n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          \n          \n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  os_printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  os_printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid ICACHE_FLASH_ATTR fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid ICACHE_FLASH_ATTR fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n}\n\nstatic bool ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          os_printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (os_strcmp((*((char **)((arguments[0])))), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION))) == 0) \n          {\n            \n            os_printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  os_printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void ICACHE_FLASH_ATTR DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  os_printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <c_types.h>\n#include <osapi.h>\n#include \"SPIFlashHelper.h\"\n#include \"user_config.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include <mem.h>\n\nvoid ICACHE_FLASH_ATTR saveState(int16_t state)\n{\n  uint16_t sector = getFlashSector(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);\n  if (spi_flash_erase_sector(sector) != SPI_FLASH_RESULT_OK) \n  {\n    os_printf(\"Failed to erase NVS sector %d\\n\", DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);\n  }\n  if (spi_flash_write(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS, ((uint32_t *)(&state)), ((uint32_t)(sizeof(state)))) != SPI_FLASH_RESULT_OK) \n  {\n    os_printf(\"Failed write statemachine state to NVS sector %d\\n\", DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS);\n  }\n}\n\nint16_t ICACHE_FLASH_ATTR loadState(void)\n{\n  int16_t state = 0;\n  if (spi_flash_read(DEMO_FOTA_UPDATE_STATE_FLASH_SECTOR_ADDRESS, ((uint32_t *)(&state)), ((uint32_t)(sizeof(state)))) != SPI_FLASH_RESULT_OK) \n  {\n    return 0;\n  }\n  \n  if (state == -1) \n  {\n    return 0;\n  }\n  return state;\n}\n"}
{"target":"fotahub","func":"\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"BinHexConverter.h\"\n#include \"FotaHub.h\"\n#include \"DemoProductInfo.h\"\n#include \"ctype.h\"\n#include <stdlib.h>\n#include <string.h>\n\nenum FirmwareUpdateInfoParser__inevents {\n  FirmwareUpdateInfoParser_characterReceived__event,\n  FirmwareUpdateInfoParser_updateInfoPickedUp__event\n};\ntypedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;\n\nenum FirmwareUpdateInfoParser__states {\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,\n  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,\n  FirmwareUpdateInfoParser_yielding__state\n};\ntypedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;\n\nstruct FirmwareUpdateInfoParser__data {\n  FirmwareUpdateInfoParser__states_t __currentState;\n  size_t characterIdx;\n  size_t partitionIdx;\n  uint8_t *pCurrentVerificationData;\n};\ntypedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;\n\nstatic void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);\n\nstatic bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);\n\nstatic char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData[UPDATE_PARTITION_COUNT] = { NULL, NULL };\n\nstatic FirmwareUpdateInfoParser__data_t updateInfoParser;\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  \n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData[0] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));\n  updateVerificationData[1] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));\n  os_memset(updateVerificationData[0], 0, updateVerificationDataSize);\n  os_memset(updateVerificationData[1], 0, updateVerificationDataSize);\n}\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    os_printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}\n\nstatic void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)\n{\n  instance->characterIdx = 0;\n  instance->partitionIdx = 0;\n  instance->pCurrentVerificationData = updateVerificationData[0];\n  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n}\n\nstatic bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            \n            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) \n          {\n            \n            \n            updateVersion[instance->characterIdx] = '\\0';\n            instance->characterIdx = 0;\n            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            os_printf(\"Received firmware update version too long (max. length = %d)\\n\", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing version received\\n\");\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Empty firmware update request received\\n\");\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            \n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != LF) \n          {\n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF) \n          {\n            \n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            \n            if (((instance->characterIdx & (1)) == 0)) \n            {\n              \n              instance->pCurrentVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;\n            }\n            else\n            {\n              \n              (instance->pCurrentVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));\n            }\n            instance->characterIdx++;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            instance->characterIdx = 0;\n            instance->partitionIdx++;\n            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx == UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;\n            break;\n          }\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            os_printf(\"Received firmware update verification data #%d too long (max. length = %d)\\n\", instance->partitionIdx + 1, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx >= UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            os_printf(\"Firmware update request with too many verifications data received (max. # = %d)\\n\", UPDATE_PARTITION_COUNT);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 1);\n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 2);\n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_yielding__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:\n        {\n          \n          instance->characterIdx = 0;\n          instance->partitionIdx = 0;\n          \n          \n          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  if (pUpdateInfo->partitionIdx >= 0 && pUpdateInfo->partitionIdx < UPDATE_PARTITION_COUNT) \n  {\n    *ppVerificationData = updateVerificationData[((size_t)(pUpdateInfo->partitionIdx))];\n  }\n  else\n  {\n    *ppVerificationData = NULL;\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"BinHexConverter.h\"\n#include \"FotaHub.h\"\n#include \"DemoProductInfo.h\"\n#include \"ctype.h\"\n#include <stdlib.h>\n#include <string.h>\n\nenum FirmwareUpdateInfoParser__inevents {\n  FirmwareUpdateInfoParser_characterReceived__event,\n  FirmwareUpdateInfoParser_updateInfoPickedUp__event\n};\ntypedef enum FirmwareUpdateInfoParser__inevents FirmwareUpdateInfoParser__inevents_t;\n\nenum FirmwareUpdateInfoParser__states {\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state = 0,\n  FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state,\n  FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state,\n  FirmwareUpdateInfoParser_yielding__state\n};\ntypedef enum FirmwareUpdateInfoParser__states FirmwareUpdateInfoParser__states_t;\n\nstruct FirmwareUpdateInfoParser__data {\n  FirmwareUpdateInfoParser__states_t __currentState;\n  size_t characterIdx;\n  size_t partitionIdx;\n  uint8_t *pCurrentVerificationData;\n};\ntypedef struct FirmwareUpdateInfoParser__data FirmwareUpdateInfoParser__data_t;\n\nstatic void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance);\n\nstatic bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments);\n\nstatic char updateVersion[MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData[UPDATE_PARTITION_COUNT] = { NULL, NULL };\n\nstatic FirmwareUpdateInfoParser__data_t updateInfoParser;\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  \n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData[0] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));\n  updateVerificationData[1] = ((uint8_t *)(os_malloc(updateVerificationDataSize)));\n  os_memset(updateVerificationData[0], 0, updateVerificationDataSize);\n  os_memset(updateVerificationData[1], 0, updateVerificationDataSize);\n}\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    os_printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}\n\nvoid ICACHE_FLASH_ATTR firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}\n\nstatic void ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__init(FirmwareUpdateInfoParser__data_t *instance)\n{\n  instance->characterIdx = 0;\n  instance->partitionIdx = 0;\n  instance->pCurrentVerificationData = updateVerificationData[0];\n  instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n}\n\nstatic bool ICACHE_FLASH_ATTR FirmwareUpdateInfoParser__execute(FirmwareUpdateInfoParser__data_t *instance, FirmwareUpdateInfoParser__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx < MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            \n            updateVersion[instance->characterIdx++] = ((char)((*((uint8_t *)((arguments[0]))))));\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx > 0) \n          {\n            \n            \n            updateVersion[instance->characterIdx] = '\\0';\n            instance->characterIdx = 0;\n            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) != COLON && isspace((*((uint8_t *)((arguments[0]))))) == 0 && instance->characterIdx >= MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH - 1) \n          {\n            \n            os_printf(\"Received firmware update version too long (max. length = %d)\\n\", MAX_DEMO_FIRMWARE_UPDATE_VERSION_LENGTH);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COLON && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing version received\\n\");\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Empty firmware update request received\\n\");\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data received\\n\");\n            memset(updateVersion, 0, sizeof(updateVersion));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            \n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if ((*((uint8_t *)((arguments[0])))) != LF) \n          {\n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF) \n          {\n            \n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_characterReceived__event:\n        {\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx < getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            \n            if (((instance->characterIdx & (1)) == 0)) \n            {\n              \n              instance->pCurrentVerificationData[instance->characterIdx >> 1] = convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0]))))))) << 4;\n            }\n            else\n            {\n              \n              (instance->pCurrentVerificationData[instance->characterIdx >> 1] |= (convertHexDigitToBinValue(((char)((*((uint8_t *)((arguments[0])))))))));\n            }\n            instance->characterIdx++;\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            instance->characterIdx = 0;\n            instance->partitionIdx++;\n            instance->pCurrentVerificationData = updateVerificationData[instance->partitionIdx];\n            \n            \n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx == UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            instance->__currentState = FirmwareUpdateInfoParser_yielding__state;\n            break;\n          }\n          if (isxdigit((*((uint8_t *)((arguments[0]))))) != 0 && instance->characterIdx >= getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n          {\n            \n            os_printf(\"Received firmware update verification data #%d too long (max. length = %d)\\n\", instance->partitionIdx + 1, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 1);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == COMMA && instance->characterIdx > 0 && instance->partitionIdx >= UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            os_printf(\"Firmware update request with too many verifications data received (max. # = %d)\\n\", UPDATE_PARTITION_COUNT);\n            \n            \n            instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingBadCharacters__state;\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx == 0) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 1);\n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n            break;\n          }\n          if ((*((uint8_t *)((arguments[0])))) == LF && instance->characterIdx > 0 && instance->partitionIdx < UPDATE_PARTITION_COUNT - 1) \n          {\n            \n            os_printf(\"Firmware update request with missing verification data #%d received\\n\", instance->partitionIdx + 2);\n            memset(updateVersion, 0, sizeof(updateVersion));\n            os_memset(updateVerificationData[0], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            os_memset(updateVerificationData[1], 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n            instance->characterIdx = 0;\n            instance->partitionIdx = 0;\n            \n            if (instance->__currentState == FirmwareUpdateInfoParser_receiving_receivingUpdateVerificationData__state) \n            {\n              \n              instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case FirmwareUpdateInfoParser_yielding__state:\n    {\n      switch (event)\n      {\n        case FirmwareUpdateInfoParser_updateInfoPickedUp__event:\n        {\n          \n          instance->characterIdx = 0;\n          instance->partitionIdx = 0;\n          \n          \n          instance->__currentState = FirmwareUpdateInfoParser_receiving_receivingUpdateVersion__state;\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nvoid ICACHE_FLASH_ATTR fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  if (pUpdateInfo->partitionIdx >= 0 && pUpdateInfo->partitionIdx < UPDATE_PARTITION_COUNT) \n  {\n    *ppVerificationData = updateVerificationData[((size_t)(pUpdateInfo->partitionIdx))];\n  }\n  else\n  {\n    *ppVerificationData = NULL;\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"UARTDrv.h\"\n\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n#include <user_interface.h>\n#include <ets_sys.h>\n\nstatic void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent);\n\nstatic uint8_t uartUnit;\n\nvoid ICACHE_FLASH_ATTR one_uart_init(uint8_t unit, UartBautRate baudrate)\n{\n  uartUnit = unit;\n  system_os_task(&uart_recvTask, uart_recvTaskPrio, uart_recvTaskQueue, uart_recvTaskQueueLen);\n  \n  UartDev.baut_rate = baudrate;\n  uart_config(unit);\n  \n  ETS_UART_INTR_ENABLE();\n}\n\nstatic void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent)\n{\n  if (pEvent->sig == uart_recvTaskSignal) \n  {\n    \n    uint32_t uartStatus = READ_PERI_REG(UART_STATUS(uartUnit));\n    uint8_t rxFIFOLength = UART_RXFIFO_DATA_LEN(uartStatus);\n    \n    \n    for ( int16_t __i = 0 ; __i < rxFIFOLength; __i++ )\n    {\n      uint32_t uartFifo = READ_PERI_REG(UART_FIFO(uartUnit));\n      uint8_t rxChar = UART_RXFIFO_DATA(uartFifo);\n      firmwareUpdateInfoReader_onCharacterReceived(rxChar);\n    }\n    \n    \n    WRITE_PERI_REG(UART_INT_CLR(uartUnit),UART_RXFIFO_FULL_INT_CLR | UART_RXFIFO_TOUT_INT_CLR);\n    \n    \n    uart_rx_intr_enable(uartUnit);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"UARTDrv.h\"\n\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n#include <user_interface.h>\n#include <ets_sys.h>\n\nstatic void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent);\n\nstatic uint8_t uartUnit;\n\nvoid ICACHE_FLASH_ATTR one_uart_init(uint8_t unit, UartBautRate baudrate)\n{\n  uartUnit = unit;\n  system_os_task(&uart_recvTask, uart_recvTaskPrio, uart_recvTaskQueue, uart_recvTaskQueueLen);\n  \n  UartDev.baut_rate = baudrate;\n  uart_config(unit);\n  \n  ETS_UART_INTR_ENABLE();\n}\n\nstatic void ICACHE_FLASH_ATTR uart_recvTask(os_event_t *pEvent)\n{\n  if (pEvent->sig == uart_recvTaskSignal) \n  {\n    \n    uint32_t uartStatus = READ_PERI_REG(UART_STATUS(uartUnit));\n    uint8_t rxFIFOLength = UART_RXFIFO_DATA_LEN(uartStatus);\n    \n    \n    for ( int16_t __i = 0 ; __i < rxFIFOLength; __i++ )\n    {\n      uint32_t uartFifo = READ_PERI_REG(UART_FIFO(uartUnit));\n      uint8_t rxChar = UART_RXFIFO_DATA(uartFifo);\n      firmwareUpdateInfoReader_onCharacterReceived(rxChar);\n    }\n    \n    \n    WRITE_PERI_REG(UART_INT_CLR(uartUnit),UART_RXFIFO_FULL_INT_CLR | UART_RXFIFO_TOUT_INT_CLR);\n    \n    \n    uart_rx_intr_enable(uartUnit);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <c_types.h>\n#include <osapi.h>\n#include \"user_config.h\"\n#include \"WiFiStationDrv.h\"\n#include \"UARTDrv.h\"\n#include \"UserLoopDrv.h\"\n#include \"BlinkDrv.h\"\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <user_interface.h>\n#include \"user_loop.h\"\n#include \"user_pre_init_default.h\"\n\nvoid ICACHE_FLASH_ATTR user_init(void)\n{\n  one_uart_init(UART_UNIT, UART_BAUDRATE);\n  \n  os_printf(\"\\n--------------------------------------------------------------------------\\n\");\n  os_printf(\"Running %s %s firmware from partition %d\\n\", ((char *)(DEMO_PRODUCT_NAME)), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION)), system_upgrade_userbin_check() + 1);\n  os_printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  userLoop_init();\n  blink_init(USER_LOOP_INTERVAL, BLINK_PERIOD);\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotaUpdateSelfTest_init();\n  fotahub_init(((char *)(DEMO_PRODUCT_ID)), ((char *)(DEMO_PRODUCT_NAME)), &ESP8266_FOTA_UPDATE_CLIENT_CONFIG, 0xFAu);\n  \n  wifiStation_connect(((char *)(WIFI_STATION_SSID)), ((char *)(WIFI_STATION_PASSWORD)));\n}\n\nvoid ICACHE_FLASH_ATTR user_loop(void)\n{\n  firmwareUpdateInfoReader_run();\n  fotahub_run();\n  blink_run();\n}\n"}
{"target":"fotahub","func":"\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <c_types.h>\n#include <osapi.h>\n#include \"user_config.h\"\n#include \"WiFiStationDrv.h\"\n#include \"UARTDrv.h\"\n#include \"UserLoopDrv.h\"\n#include \"BlinkDrv.h\"\n#include \"MultiPartitionDemoFirmwareUpdateInfoSerialReader.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <user_interface.h>\n#include \"user_loop.h\"\n#include \"user_pre_init_default.h\"\n\nvoid ICACHE_FLASH_ATTR user_init(void)\n{\n  one_uart_init(UART_UNIT, UART_BAUDRATE);\n  \n  os_printf(\"\\n--------------------------------------------------------------------------\\n\");\n  os_printf(\"Running %s %s firmware from partition %d\\n\", ((char *)(DEMO_PRODUCT_NAME)), ((char *)(DEMO_PRODUCT_FIRMWARE_VERSION)), system_upgrade_userbin_check() + 1);\n  os_printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  userLoop_init();\n  blink_init(USER_LOOP_INTERVAL, BLINK_PERIOD);\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(((char *)(DEMO_PRODUCT_ID)), ((char *)(DEMO_PRODUCT_NAME)), &ESP8266_FOTA_UPDATE_CLIENT_CONFIG, 0xFAu);\n  \n  wifiStation_connect(((char *)(WIFI_STATION_SSID)), ((char *)(WIFI_STATION_PASSWORD)));\n}\n\nvoid ICACHE_FLASH_ATTR user_loop(void)\n{\n  firmwareUpdateInfoReader_run();\n  fotahub_run();\n  blink_run();\n}\n"}
{"target":"fotahub","func":"\n#include \"user_pre_init_default.h\"\n\n#include <user_interface.h>\n\n\n\nstatic void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap);\n\nstatic void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void);\n\nstatic partition_item_t partitionTable[] = \n{\n  { SYSTEM_PARTITION_BOOTLOADER, 0x0u, 0x1000u }, \n  { SYSTEM_PARTITION_OTA_1, 0x1000u, SYSTEM_PARTITION_OTA_SIZE }, \n  { SYSTEM_PARTITION_OTA_2, 0x101000u, SYSTEM_PARTITION_OTA_SIZE }, \n  { SYSTEM_PARTITION_RF_CAL, 0x3fb000u, 0x1000u }, \n  { SYSTEM_PARTITION_PHY_DATA, 0x3fc000u, 0x1000u }, \n  { SYSTEM_PARTITION_SYSTEM_PARAMETER, 0x3fd000u, 0x3000u }\n};\n\nstatic void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap)\n{\n  \n  switch (flashSizeMap)\n  {\n    case FLASH_SIZE_16M_MAP_1024_1024:\n    {\n      partitionTable[3].addr = 0x1fb000u;\n      partitionTable[4].addr = 0x1fc000u;\n      partitionTable[5].addr = 0x1fd000u;\n      break;\n    }\n    case FLASH_SIZE_32M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      break;\n    }\n    case FLASH_SIZE_16M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      partitionTable[3].addr = 0x1fb000u;\n      partitionTable[4].addr = 0x1fc000u;\n      partitionTable[5].addr = 0x1fd000u;\n      break;\n    }\n    case FLASH_SIZE_8M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      partitionTable[3].addr = 0xfb000u;\n      partitionTable[4].addr = 0xfc000u;\n      partitionTable[5].addr = 0xfd000u;\n      break;\n    }\n    default: {\n      \n    }\n  }\n}\n\nstatic void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void)\n{\n  partitionTable[1].size = 0x7A000u;\n  partitionTable[2].addr = 0x81000u;\n  partitionTable[2].size = 0x7A000u;\n  \n}\n\nvoid ICACHE_FLASH_ATTR user_pre_init(void)\n{\n  enum flash_size_map flashSizeMap = system_get_flash_size_map();\n  if (flashSizeMap < 2) \n  {\n    os_printf(\"The flash map is not supported\\n\");\n    while (true)\n    {\n    }\n  }\n  \n  initPartitionTable(flashSizeMap);\n  \n  if (!system_partition_table_regist(partitionTable, sizeof(partitionTable) \/ sizeof(partitionTable[0]), flashSizeMap)) \n  {\n    os_printf(\"system_partition_table_regist fail\\n\");\n    while (true)\n    {\n    }\n  }\n}\n\nuint32_t user_iram_memory_is_enabled(void)\n{\n  return 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"user_pre_init_default.h\"\n\n#include <user_interface.h>\n\n\n\nstatic void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap);\n\nstatic void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void);\n\nstatic partition_item_t partitionTable[] = \n{\n  { SYSTEM_PARTITION_BOOTLOADER, 0x0u, 0x1000u }, \n  { SYSTEM_PARTITION_OTA_1, 0x1000u, SYSTEM_PARTITION_OTA_SIZE }, \n  { SYSTEM_PARTITION_OTA_2, 0x101000u, SYSTEM_PARTITION_OTA_SIZE }, \n  { SYSTEM_PARTITION_RF_CAL, 0x3fb000u, 0x1000u }, \n  { SYSTEM_PARTITION_PHY_DATA, 0x3fc000u, 0x1000u }, \n  { SYSTEM_PARTITION_SYSTEM_PARAMETER, 0x3fd000u, 0x3000u }\n};\n\nstatic void ICACHE_FLASH_ATTR initPartitionTable(enum flash_size_map flashSizeMap)\n{\n  \n  switch (flashSizeMap)\n  {\n    case FLASH_SIZE_16M_MAP_1024_1024:\n    {\n      partitionTable[3].addr = 0x1fb000u;\n      partitionTable[4].addr = 0x1fc000u;\n      partitionTable[5].addr = 0x1fd000u;\n      break;\n    }\n    case FLASH_SIZE_32M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      break;\n    }\n    case FLASH_SIZE_16M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      partitionTable[3].addr = 0x1fb000u;\n      partitionTable[4].addr = 0x1fc000u;\n      partitionTable[5].addr = 0x1fd000u;\n      break;\n    }\n    case FLASH_SIZE_8M_MAP_512_512:\n    {\n      adjustPartitionTableDataForFlashSize_512();\n      partitionTable[3].addr = 0xfb000u;\n      partitionTable[4].addr = 0xfc000u;\n      partitionTable[5].addr = 0xfd000u;\n      break;\n    }\n    default: {\n      \n    }\n  }\n}\n\nstatic void ICACHE_FLASH_ATTR adjustPartitionTableDataForFlashSize_512(void)\n{\n  partitionTable[1].size = 0x7A000u;\n  partitionTable[2].addr = 0x81000u;\n  partitionTable[2].size = 0x7A000u;\n  \n}\n\nvoid ICACHE_FLASH_ATTR user_pre_init(void)\n{\n  enum flash_size_map flashSizeMap = system_get_flash_size_map();\n  if (flashSizeMap < 2) \n  {\n    os_printf(\"The flash map is not supported\\n\");\n    while (true)\n    {\n    }\n  }\n  \n  initPartitionTable(flashSizeMap);\n  \n  if (!system_partition_table_regist(partitionTable, sizeof(partitionTable) \/ sizeof(partitionTable[0]), flashSizeMap)) \n  {\n    os_printf(\"system_partition_table_regist fail\\n\");\n    while (true)\n    {\n    }\n  }\n}\n\nuint32_t user_iram_memory_is_enabled(void)\n{\n  return 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"WiFiStationDrv.h\"\n\n#include \"FotaHub.h\"\n#include <user_interface.h>\n#include <string.h>\n\nstatic void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt);\n\nbool ICACHE_FLASH_ATTR wifiStation_connect(char const *ssid, char const *password)\n{\n  wifi_set_event_handler_cb(&wifiEventHandlerCallback);\n  \n  uint8_t currentMode = wifi_get_opmode();\n  currentMode = ((currentMode |= (STATION_MODE)));\n  currentMode = ((currentMode &= ~(SOFTAP_MODE)));\n  if (!wifi_set_opmode_current(currentMode)) \n  {\n    os_printf(\"Failed to activate Wi-Fi station mode\\n\");\n    return false;\n  }\n  \n  struct station_config config = { 0 };\n  size_t ssidLen = os_strlen(ssid);\n  os_memcpy(config.ssid, ssid, ssidLen);\n  if (ssidLen < sizeof(config.ssid)) \n  {\n    config.ssid[ssidLen] = 0;\n  }\n  size_t passwordLen = os_strlen(password);\n  os_memcpy(config.password, password, passwordLen);\n  if (passwordLen < sizeof(config.password)) \n  {\n    config.password[passwordLen] = 0;\n  }\n  if (!wifi_station_set_config_current(&config)) \n  {\n    os_printf(\"Failed to set Wi-Fi station configuration\\n\");\n    return false;\n  }\n  \n  \n  wifi_station_connect();\n  return true;\n}\n\nstatic void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt)\n{\n  switch (sys_evt->event)\n  {\n    case EVENT_STAMODE_CONNECTED:\n    {\n      \n      break;\n    }\n    case EVENT_STAMODE_DISCONNECTED:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    case EVENT_STAMODE_AUTHMODE_CHANGE:\n    {\n      \n      break;\n    }\n    case EVENT_STAMODE_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case EVENT_STAMODE_DHCP_TIMEOUT:\n    {\n      os_printf(\"Failed to obtain Wi-Fi station IP address\\n\");\n      break;\n    }\n    case EVENT_SOFTAPMODE_PROBEREQRECVED:\n    {\n      \n      break;\n    }\n    case EVENT_OPMODE_CHANGED:\n    {\n      \n      break;\n    }\n    default: {\n      os_printf(\"Unexpected Wi-Fi event encountered: %d\\n\", sys_evt->event);\n      break;\n    }\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"WiFiStationDrv.h\"\n\n#include \"FotaHub.h\"\n#include <user_interface.h>\n#include <string.h>\n\nstatic void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt);\n\nbool ICACHE_FLASH_ATTR wifiStation_connect(char const *ssid, char const *password)\n{\n  wifi_set_event_handler_cb(&wifiEventHandlerCallback);\n  \n  uint8_t currentMode = wifi_get_opmode();\n  currentMode = ((currentMode |= (STATION_MODE)));\n  currentMode = ((currentMode &= ~(SOFTAP_MODE)));\n  if (!wifi_set_opmode_current(currentMode)) \n  {\n    os_printf(\"Failed to activate Wi-Fi station mode\\n\");\n    return false;\n  }\n  \n  struct station_config config = { 0 };\n  size_t ssidLen = os_strlen(ssid);\n  os_memcpy(config.ssid, ssid, ssidLen);\n  if (ssidLen < sizeof(config.ssid)) \n  {\n    config.ssid[ssidLen] = 0;\n  }\n  size_t passwordLen = os_strlen(password);\n  os_memcpy(config.password, password, passwordLen);\n  if (passwordLen < sizeof(config.password)) \n  {\n    config.password[passwordLen] = 0;\n  }\n  if (!wifi_station_set_config_current(&config)) \n  {\n    os_printf(\"Failed to set Wi-Fi station configuration\\n\");\n    return false;\n  }\n  \n  \n  wifi_station_connect();\n  return true;\n}\n\nstatic void ICACHE_FLASH_ATTR wifiEventHandlerCallback(System_Event_t *sys_evt)\n{\n  switch (sys_evt->event)\n  {\n    case EVENT_STAMODE_CONNECTED:\n    {\n      \n      break;\n    }\n    case EVENT_STAMODE_DISCONNECTED:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    case EVENT_STAMODE_AUTHMODE_CHANGE:\n    {\n      \n      break;\n    }\n    case EVENT_STAMODE_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case EVENT_STAMODE_DHCP_TIMEOUT:\n    {\n      os_printf(\"Failed to obtain Wi-Fi station IP address\\n\");\n      break;\n    }\n    case EVENT_SOFTAPMODE_PROBEREQRECVED:\n    {\n      \n      break;\n    }\n    case EVENT_OPMODE_CHANGED:\n    {\n      \n      break;\n    }\n    default: {\n      os_printf(\"Unexpected Wi-Fi event encountered: %d\\n\", sys_evt->event);\n      break;\n    }\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"BinHexConverter.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}\n\nuint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}\n\nsize_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}\n\nuint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}\n\nsize_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}\n\nsize_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"BinHexConverter.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}\n\nuint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}\n\nsize_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}\n\nuint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}\n\nsize_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}\n\nsize_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateSelfTest.h\"\n\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <time.h>\n\nstatic bool runRandomSelfTest(uint8_t successRate);\n\nvoid fotaUpdateSelfTest_init(void)\n{\n  srand(((uint32_t)(time(NULL))));\n}\n\nstatic bool runRandomSelfTest(uint8_t successRate)\n{\n  if (((uint8_t)((rand() % 100))) >= (successRate)) \n  {\n    printf(\"Firmware self test failed (reason: simulated pseudo-random failure)\\n\");\n    return false;\n  }\n  return true;\n}\n\nvoid validateFirmwareUpdateActivation(void)\n{\n  printf(\"Validating firmware update\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully activated\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update activation failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);\n  }\n}\n\nvoid validateFirmwareUpdateReversion(void)\n{\n  printf(\"Validating previous firmware\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully reverted\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update reversion failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state,\n  DemoFOTAUpdateWorkflowEngine_activating__state,\n  DemoFOTAUpdateWorkflowEngine_reverting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);\n}\n\nvoid fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            \n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateActivation();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateReversion();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          \n          \n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          \n          \n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine);\n}\n\nvoid fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n}\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            \n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflowFilePersistence.h\"\n\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n\nvoid saveState(int16_t state)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"wb\");\n  if (file == NULL) \n  {\n    printf(\"Failed to open %s for writing\\n\", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    return;\n  }\n  if (fwrite(&state, sizeof(state), 1, file) != 1) \n  {\n    printf(\"Failed to write statemachine state %hi to %s\\n\", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    fclose(file);\n    return;\n  }\n  fclose(file);\n}\n\nint16_t loadState(void)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"rb\");\n  if (file == NULL) \n  {\n    return 0;\n  }\n  int16_t state = 0;\n  if (fread(&state, sizeof(state), 1, file) != 1) \n  {\n    fclose(file);\n    return 0;\n  }\n  fclose(file);\n  return state;\n}\n"}
{"target":"fotahub","func":"\n#include \"Main.h\"\n\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n#include \"DemoFOTAUpdateWorkflowFilePersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <string.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <limits.h>\n\nint32_t main(int32_t argc, char *argv[])\n{\n  \n  char *programDir = dirname(strdup(argv[0]));\n  chdir(programDir);\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotaUpdateSelfTest_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  \n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  \n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  \n  char *separator = (strlen(programDir) > 0) ? (\"\/\") : (\"\");\n  printf(\"Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\\n\", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  \n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"Main.h\"\n\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <string.h>\n#include <libgen.h>\n#include <unistd.h>\n\nint32_t main(int32_t argc, char *argv[])\n{\n  \n  char *programDir = dirname(strdup(argv[0]));\n  chdir(programDir);\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  \n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  \n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  \n  char *separator = (strlen(programDir) > 0) ? (\"\/\") : (\"\");\n  printf(\"Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\\n\", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  \n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n\n#include \"BinHexConverter.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"ctype.h\"\n#include <errno.h>\n#include <unistd.h>\n\nstatic bool isWhitespace(char *str);\n\nstatic bool createFirmwareUpdateInfoFile(void);\n\nstatic void openFirmwareUpdateInfoFileInVSCode(void);\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString);\n\nstatic char lastUpdateInfoString[260 + 1] = { 0 };\n\nstatic char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  \n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  \n  openFirmwareUpdateInfoFileInVSCode();\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  \n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  \n  \n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  \n  \n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  \n  \n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}\n\nstatic bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"w\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"\/usr\/bin\/code\");\n  }\n  \n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    \n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      \n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  \n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and\/or verification data entered\\n\");\n    return false;\n  }\n  \n  \n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  \n  \n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  \n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n\n#include \"BinHexConverter.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"ctype.h\"\n#include <errno.h>\n#include <unistd.h>\n\nstatic bool isWhitespace(char *str);\n\nstatic bool createFirmwareUpdateInfoFile(void);\n\nstatic void openFirmwareUpdateInfoFileInVSCode(void);\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString);\n\nstatic char lastUpdateInfoString[260 + 1] = { 0 };\n\nstatic char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  \n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  \n  openFirmwareUpdateInfoFileInVSCode();\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  \n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  \n  \n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  \n  \n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  \n  \n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}\n\nstatic bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"w\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"\/usr\/bin\/code\");\n  }\n  \n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    \n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      \n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  \n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and\/or verification data entered\\n\");\n    return false;\n  }\n  \n  \n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  \n  \n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  \n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"fotahub","func":"\n#include \"BinHexConverter.h\"\n\n#include <stdio.h>\n#include <string.h>\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase);\n\nstatic inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}\n\nuint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}\n\nsize_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}\n\nuint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}\n\nsize_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}\n\nsize_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateSelfTest.h\"\n\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <time.h>\n\nstatic bool runRandomSelfTest(uint8_t successRate);\n\nvoid fotaUpdateSelfTest_init(void)\n{\n  srand(((uint32_t)(time(NULL))));\n}\n\nstatic bool runRandomSelfTest(uint8_t successRate)\n{\n  if (((uint8_t)((rand() % 100))) >= (successRate)) \n  {\n    printf(\"Firmware self test failed (reason: simulated pseudo-random failure)\\n\");\n    return false;\n  }\n  return true;\n}\n\nvoid validateFirmwareUpdateActivation(void)\n{\n  printf(\"Validating firmware update\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully activated\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update activation failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);\n  }\n}\n\nvoid validateFirmwareUpdateReversion(void)\n{\n  printf(\"Validating previous firmware\\n\");\n  \n  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully reverted\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update reversion failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);\n  }\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflow.h\"\n\n#include \"DemoProductInfo.h\"\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include <string.h>\n\nenum DemoFOTAUpdateWorkflowEngine__inevents {\n  DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event,\n  DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__inevents DemoFOTAUpdateWorkflowEngine__inevents_t;\n\nenum DemoFOTAUpdateWorkflowEngine__states {\n  DemoFOTAUpdateWorkflowEngine_idle__state = 0,\n  DemoFOTAUpdateWorkflowEngine_connected__state,\n  DemoFOTAUpdateWorkflowEngine_downloading__state,\n  DemoFOTAUpdateWorkflowEngine_restarting__state,\n  DemoFOTAUpdateWorkflowEngine_activating__state,\n  DemoFOTAUpdateWorkflowEngine_reverting__state\n};\ntypedef enum DemoFOTAUpdateWorkflowEngine__states DemoFOTAUpdateWorkflowEngine__states_t;\n\nstruct DemoFOTAUpdateWorkflowEngine__data {\n  DemoFOTAUpdateWorkflowEngine__states_t __currentState;\n  FirmwareUpdateInfo_t updateInfo;\n};\ntypedef struct DemoFOTAUpdateWorkflowEngine__data DemoFOTAUpdateWorkflowEngine__data_t;\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution);\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance);\n\nstatic DemoFOTAUpdateWorkflowEngine__data_t updateWorkflowEngine;\n\nvoid fotaUpdateWorkflow_init(void)\n{\n  DemoFOTAUpdateWorkflowEngine__init(&updateWorkflowEngine, false);\n}\n\nvoid fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}\n\nvoid fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}\n\nvoid fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}\n\nstatic void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n\nstatic bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          \n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          \n          \n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            \n            \n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            \n            \n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            \n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            \n            \n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            \n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateActivation();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            \n            bool __transitionResult = true;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            \n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            \n            \n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              \n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            \n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            \n            validateFirmwareUpdateReversion();\n            \n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n              \n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          \n          \n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          \n          \n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_connected_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Ready for firmware over-the-air update\\n\");\n}\n\nstatic inline void DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  printf(\"Waiting for restart\\n\");\n}\n"}
{"target":"fotahub","func":"\n#include \"DemoFOTAUpdateWorkflowFilePersistence.h\"\n\n#include \"DemoFOTAUpdateWorkflowPersistence.h\"\n\nvoid saveState(int16_t state)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"wb\");\n  if (file == NULL) \n  {\n    printf(\"Failed to open %s for writing\\n\", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    return;\n  }\n  if (fwrite(&state, sizeof(state), 1, file) != 1) \n  {\n    printf(\"Failed to write statemachine state %hi to %s\\n\", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    fclose(file);\n    return;\n  }\n  fclose(file);\n}\n\nint16_t loadState(void)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"rb\");\n  if (file == NULL) \n  {\n    return 0;\n  }\n  int16_t state = 0;\n  if (fread(&state, sizeof(state), 1, file) != 1) \n  {\n    fclose(file);\n    return 0;\n  }\n  fclose(file);\n  return state;\n}\n"}
{"target":"fotahub","func":"\n#include \"Main.h\"\n\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n#include \"DemoFOTAUpdateWorkflowFilePersistence.h\"\n#include \"DemoFOTAUpdateSelfTest.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <string.h>\n#include <limits.h>\n#include <direct.h>\n\nstatic char *dirname(char *path);\n\nint32_t main(int32_t argc, char *argv[])\n{\n  \n  char *programDir = dirname(_strdup(argv[0]));\n  _chdir(programDir);\n  \n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotaUpdateSelfTest_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  \n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  \n  firmwareUpdateInfoReader_explain(programDir);\n  \n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}\n\nstatic char *dirname(char *path)\n{\n  char *lastSeparator = strrchr(path, '\\\\');\n  if (lastSeparator != NULL) \n  {\n    *lastSeparator = '\\0';\n    return path;\n  }\n  else\n  {\n    *path = '\\0';\n  }\n  return path;\n}\n"}
{"target":"fotahub","func":"\n#include \"Main.h\"\n\n#include \"Configuration.h\"\n#include \"DemoFOTAUpdateWorkflow.h\"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <string.h>\n#include <limits.h>\n#include <direct.h>\n\nstatic char *dirname(char *path);\n\nint32_t main(int32_t argc, char *argv[])\n{\n  \n  char *programDir = dirname(_strdup(argv[0]));\n  _chdir(programDir);\n  \n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  \n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  \n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  \n  firmwareUpdateInfoReader_explain(programDir);\n  \n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}\n\nstatic char *dirname(char *path)\n{\n  char *lastSeparator = strrchr(path, '\\\\');\n  if (lastSeparator != NULL) \n  {\n    *lastSeparator = '\\0';\n    return path;\n  }\n  else\n  {\n    *path = '\\0';\n  }\n  return path;\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n\n#include \"BinHexConverter.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"ctype.h\"\n#include <errno.h>\n\nstatic bool isWhitespace(char *str);\n\nstatic char *separator(void);\n\nstatic bool createFirmwareUpdateInfoFile(void);\n\nstatic bool canOpenFirmwareUpdateInfoFile(void);\n\nstatic void openFirmwareUpdateInfoFile(void);\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString);\n\nstatic char lastUpdateInfoString[260 + 1] = { 0 };\n\nstatic char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}\n\nstatic char *separator(void)\n{\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    return \"\\\\\";\n  }\n  else\n  {\n    return \"\/\";\n  }\n}\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  \n  \n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  \n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}\n\nvoid firmwareUpdateInfoReader_explain(char *programDir)\n{\n  \n  char *sep = (strlen(programDir) > 0) ? (separator()) : (\"\");\n  printf(\"Waiting for firmware update info to be entered and saved in '%s%s%s' file\\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\\n\", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  printf(\"Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \\n\");\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  \n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  \n  \n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  \n  \n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  \n  \n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}\n\nstatic bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool canOpenFirmwareUpdateInfoFile(void)\n{\n  \n  char *os = getenv(\"OS\");\n  char command[260 + 1] = \"\";\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(command, sizeof(command), \"powershell -command \\\"where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\\\"\");\n  }\n  else\n  {\n    snprintf(command, sizeof(command), \"which code | wc -l\");\n  }\n  \n  \n  FILE *commandPipe = popen(command, \"r\");\n  if (commandPipe == NULL) \n  {\n    printf(\"Failed to run '%s' command: %s (error code: %i)\\n\", command, strerror(errno), errno);\n    return false;\n  }\n  \n  \n  int32_t count = 0;\n  if (fscanf(commandPipe, \"%d\", &count) != 1) \n  {\n    pclose(commandPipe);\n    return false;\n  }\n  pclose(commandPipe);\n  return count > 0;\n}\n\nstatic void openFirmwareUpdateInfoFile(void)\n{\n  \n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    \n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      \n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  \n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and\/or verification data entered\\n\");\n    return false;\n  }\n  \n  \n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  \n  \n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  \n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"fotahub","func":"\n#include \"SinglePartitionDemoFirmwareUpdateInfoFileReader.h\"\n\n#include \"BinHexConverter.h\"\n#include \"DemoProductInfo.h\"\n#include \"FotaHub.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"ctype.h\"\n#include <errno.h>\n\nstatic bool isWhitespace(char *str);\n\nstatic char *separator(void);\n\nstatic bool createFirmwareUpdateInfoFile(void);\n\nstatic bool canOpenFirmwareUpdateInfoFile(void);\n\nstatic void openFirmwareUpdateInfoFile(void);\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize);\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString);\n\nstatic char lastUpdateInfoString[260 + 1] = { 0 };\n\nstatic char updateVersion[MAX_UPDATE_VERSION_LENGTH + 1] = { 0 };\n\nstatic uint8_t *updateVerificationData = NULL;\n\nstatic bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}\n\nstatic char *separator(void)\n{\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    return \"\\\\\";\n  }\n  else\n  {\n    return \"\/\";\n  }\n}\n\nvoid firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  \n  \n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  \n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}\n\nvoid firmwareUpdateInfoReader_explain(char *programDir)\n{\n  \n  char *sep = (strlen(programDir) > 0) ? (separator()) : (\"\");\n  printf(\"Waiting for firmware update info to be entered and saved in '%s%s%s' file\\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\\n\", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  printf(\"Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \\n\");\n}\n\nvoid firmwareUpdateInfoReader_run(void)\n{\n  \n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  \n  \n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  \n  \n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  \n  \n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}\n\nstatic bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool canOpenFirmwareUpdateInfoFile(void)\n{\n  \n  char *os = getenv(\"OS\");\n  char command[260 + 1] = \"\";\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(command, sizeof(command), \"powershell -command \\\"where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\\\"\");\n  }\n  else\n  {\n    snprintf(command, sizeof(command), \"which code | wc -l\");\n  }\n  \n  \n  FILE *commandPipe = popen(command, \"r\");\n  if (commandPipe == NULL) \n  {\n    printf(\"Failed to run '%s' command: %s (error code: %i)\\n\", command, strerror(errno), errno);\n    return false;\n  }\n  \n  \n  int32_t count = 0;\n  if (fscanf(commandPipe, \"%d\", &count) != 1) \n  {\n    pclose(commandPipe);\n    return false;\n  }\n  pclose(commandPipe);\n  return count > 0;\n}\n\nstatic void openFirmwareUpdateInfoFile(void)\n{\n  \n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}\n\nstatic bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    \n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      \n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}\n\nstatic bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  \n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and\/or verification data entered\\n\");\n    return false;\n  }\n  \n  \n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  \n  \n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  \n  return true;\n}\n\nvoid fotahub_onProvideFirmwareUpdateVerificationInfo(FirmwareUpdateInfo_t const *pUpdateInfo, FOTAUpdateVerificationAlgorithm_t *pVerificationAlgorithm, uint8_t const  **ppVerificationData)\n{\n  *pVerificationAlgorithm = DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM;\n  *ppVerificationData = updateVerificationData;\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    struct sockaddr_in dnss;\n    int sockid,rval;\n    char sym[20],IP[20];\n    int slen;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    dnss.sin_family=AF_INET;\n    dnss.sin_port=htons(atoi(argv[2]));\n    dnss.sin_addr.s_addr=inet_addr(argv[1]);\n    printf(\"\\nEnter the symbolic name of resource : \");\n    scanf(\"%s\",sym);\n    rval=sendto(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnss,sizeof(dnss));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nWaiting to receive from DNS Server\\n\");\n    slen=sizeof(dnss);\n    strncpy(IP,\" \",20);\n    rval=recvfrom(sockid,IP,sizeof(IP),0,(struct sockaddr*)&dnss,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEquivalent IP adrress of %s is %s\\n\",sym,IP);\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    struct sockaddr_in dnss,dnsc;\n    int rval,sockid,flag=0,clen;\n    char sym[20],IP[20],dnsFile[20],dnsName[20];\n    FILE *fptr;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    dnss.sin_family=AF_INET;\n    dnss.sin_port=htons(atoi(argv[2]));\n    dnss.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    rval=bind(sockid,(struct sockaddr*)&dnss,sizeof(dnss));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nDNS Server waiting for request\\n\");\n    printf(\"\\nEnter the DNS file name : \");\n    scanf(\"%s\",dnsFile);\n    \n    fptr=fopen(dnsFile,\"r\");\n    if(fptr==NULL)\n    {\n        perror(\"FILE-OPEN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(dnsc);\n    rval=recvfrom(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnsc,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        fclose(fptr);\n        exit(1);\n    }\n    printf(\"\\nIP requested for %s\\n\",sym);\n    while((fscanf(fptr,\"%s%s\",dnsName,IP) != EOF) )\n    {\n        if(strcmp(dnsName,sym)==0)\n        {\n            rval=sendto(sockid,IP,sizeof(IP),0,(struct\n            sockaddr*)&dnsc,clen);\n            if(rval==-1)\n            {\n                perror(\"MSG-SND-ERR:\");\n                fclose(fptr);\n                close(sockid);\n                exit(1);\n            }\n            flag=1;\n        }\n        printf(\"\\n flag value in loop is %d\\n\",flag);\n        if(flag==1) \n        break;\n    }\n    if(flag==0)\n    {\n        printf(\"\\n invalid domain name case\\n\");\n        rval=sendto(sockid,\"NOT FOUND\",sizeof(\"NOT FOUND\"),0,(struct\n        sockaddr*)&dnsc,clen);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n            fclose(fptr);\n            close(sockid);\n            exit(1);\n        }\n    }\n    fclose(fptr);\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/socket.h>\n#include<sys\/types.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    int sockid,rval,count=0,tlen;\n    char msg[100];\n    struct sockaddr_in lis,talk;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    lis.sin_family=AF_INET;\n    lis.sin_port=htons(atoi(argv[2]));\n    lis.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    rval=bind(sockid,(struct sockaddr*)&lis,sizeof(lis));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nThe Listener is ready to accept messages\\n\");\n    tlen=sizeof(talk);\n    while(1)\n    {\n        strncpy(msg,\" \",100);\n        rval=recvfrom(sockid,msg,sizeof(msg),0,(struct sockaddr*)&talk,&tlen);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n            close(sockid);\n            exit(1);\n        }\n        printf(\"\\nMessage %d read is %s\\n\",++count,msg);\n        if(!strcmp(msg,\"EXIT\"))\n        break;\n    }\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/types.h>\n#include<sys\/ipc.h>\n#include<sys\/msg.h>\ntypedef struct msg\n{\n    long id;\n    char txt[10];\n}message;\nvoid main()\n{\n    int mqid,rval,msgid;\n    message m1;\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    printf(\"Enter the msgid : \");\n    scanf(\"%d\",&msgid);\n    m1.id=msgid;\n    printf(\"Enter the message : \");\n    scanf(\"%s\",m1.txt);\n    rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n    if(rval==-1)\n    perror(\"\\nMessage not sent\\n\");\n    else\n    printf(\"\\nMessage Sent successfully\\n\");\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<sys\/types.h>\n#include<semaphore.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<pthread.h>\n#include<sys\/shm.h>\n#include<sys\/ipc.h>\n#include<sys\/msg.h>\ntypedef struct msg\n{\n    long id;\n    char txt[10];\n}message;\nvoid main(int argc, char* argv[])\n{\n\n    int label, mem_size;\n    int shmid,sval,inval,rval,mqid,pid;\n    int msgid; \n    sem_t *s;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s LabelForResources MemorySize(inbytes)\\n\",argv[0]);\n        exit(1);\n    }\n    label=atoi(argv[1]);\n    mqid=msgget((key_t)label,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MSG-Q-CRE-ERR:\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    mem_size=atoi(argv[2]); \n    shmid=shmget((key_t)label,mem_size,IPC_CREAT|0666);\n    if(shmid==-1)\n    {\n        perror(\"SHM_MEM-CRE-ERR:\");\n        msgctl(mqid,IPC_RMID,0);\n        exit(1);\n    }\n    system(\"ipcs -m\");\n    s=(sem_t*)shmat(shmid,0,0);\n    if(s==NULL)\n    {\n        perror(\"SHM-AT-ERR:\");\n        shmctl(shmid,IPC_RMID,0);\n        shmdt(s);\n        msgctl(mqid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nEnter the initialization value for the semaphore :\");\n    scanf(\"%d\",&inval);\n    rval=sem_init(s,1,inval);\n    if(rval==-1)\n    {\n        perror(\"Unable to initialize semaphore value:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(s,&sval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after initialization is %d\\n\",sval);\n    printf(\"\\nEnter the message ID to be used between parent and child: \");\n    scanf(\"%d\",&msgid);\n    pid=fork();\n    if(pid==-1)\n    {\n        perror(\"FRK-ERR:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    if(pid==0)\n    {\n        message m1;\n        printf(\"\\nCHILD : pid = %d\\n\",getpid());\n        rval=sem_wait(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-WAIT-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nCHILD : Enter the message to be sent to parent : \");\n        scanf(\"%s\",m1.txt);\n        m1.id=msgid;\n        rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }       \n        rval=sem_post(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-POST-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        exit(1);\n    }\n    else\n    {\n        message m2;\n        rval=sem_wait(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-WAIT-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nPARENT : Waiting to receive message from child\\n\");\n        rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nPARENT : Message received is : %s\\n\",m2.txt);\n        rval=sem_post(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-POST-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n    }\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/types.h>\n#include<sys\/ipc.h>\n#include<sys\/msg.h>\ntypedef struct msg\n{\n    long id;\n    char txt[10];\n}message;\nvoid main()\n{\n    int mqid,rval,msgid;\n    message m2;\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    printf(\"\\nEnter the msgid :\");\n    scanf(\"%d\",&msgid);\n    rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n    if(rval==-1)\n    {\n        perror(\"No message read\");\n        msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n        exit(1);\n    }\n    printf(\"\\nMessage entered : %s\\n\",m2.txt);\n    msgctl(mqid,IPC_RMID,0);\n    system(\"ipcs -q\");\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<pthread.h>\n#include<sys\/types.h>\n#include<semaphore.h>\n#include<sys\/shm.h>\n#include<sys\/ipc.h>\nvoid main(int argc,char* argv[])\n{\n    int shmid,rval,sval,csval;\n    sem_t *sem_phore;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s labelForSHM ByteSize\\n\",argv[0]);\n        exit(0);\n    }\n    shmid=shmget((key_t)atoi(argv[1]),atoi(argv[2]),IPC_CREAT|0666);\n    if(shmid==-1)\n    {\n        perror(\"SHM-CRE-ERR:\");\n        exit(1);\n    }\n    sem_phore=(sem_t*)shmat(shmid,0,0);\n    if(!sem_phore)\n    {\n        perror(\"SHM-ATT-ERR:\");\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nEnter the initial value for the semaphore: \");\n    scanf(\"%d\",&sval);\n    rval=sem_init(sem_phore,1,sval);\n    if(rval==-1)\n    {\n        perror(\"Unable to initialize semaphore:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get value of the semaphore: \");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nInitialized value of semaphore is %d\\n\",csval);\n    rval=sem_wait(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"WAIT-FAILURE:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after wait is %d\\n\",csval);\n    rval=sem_post(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value: \");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after signal operation is %d\\n\",csval);\n    rval=sem_destroy(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"SEM-DESTROY-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=shmdt(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"SHM-DETACH-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=shmctl(shmid,IPC_RMID,0);\n    if(rval==-1)\n    {\n        perror(\"SHM-REM-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    system(\"ipcs -m\");\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h> \n#include<sys\/socket.h> \n#include<stdlib.h> \n#include<netinet\/in.h> \n#include<sys\/types.h> \n#include<arpa\/inet.h>\n#include<time.h> \n#include<string.h> \nint main() \n{ \nint sockfd; \nstruct sockaddr_in serv_addr; \ntime_t  now; \nchar timestr[100]; \nchar a[50],a1[50]; \nsockfd=socket(AF_INET,SOCK_STREAM,0); \nif(sockfd<0) \n{ \nprintf(\"\\n Socket Failed\"); \nexit(0); \n} \nserv_addr.sin_family=AF_INET; \nserv_addr.sin_addr.s_addr=inet_addr(\"192.168.125.129\"); \nserv_addr.sin_port=htons(13); \nif(connect(sockfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr))<0) \n{ \nprintf(\"\\n Connection Failed\"); \nexit(0); \n} \ntime(&now); \nsprintf(timestr,\"%s\",ctime(&now)); \nprintf(\"%s\",timestr); \n \n \n \n\n \nclose(sockfd); \n} \n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<sys\/uio.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    int sockid,rval;\n    char a1[50],a2[50],b1[50],b2[50];\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    struct iovec iov[2]; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"CONN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEnter the first message : \");\n    scanf(\"%s\",a1);\n    printf(\"\\nEnter the second message : \");\n    scanf(\"%s\",a2);\n    iov[0].iov_base=a1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=a2;  \n    iov[1].iov_len=50;  \n    writev(sockid,&iov[0],2); \n    printf(\"Message sent successfully\\n\");\n    iov[0].iov_base=b1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=b2;  \n    iov[1].iov_len=50;  \n    readv(sockid,&iov[0],2);  \n    printf(\"Server response is :  %s \\n %s\\n\",b1,b2); \n\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<sys\/uio.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    struct iovec iov[2];\n    char b1[50],b2[50]; \n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    if(sid1<0)\n    {\n        printf(\"Connection Failed\");\n    }\n    iov[0].iov_base=b1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=b2; \n    iov[1].iov_len=50;  \n    readv(sid1,&iov[0],2);  \n    printf(\"Client Message is %s \\n %s\\n\",b1,b2);  \n    writev(sid1,&iov[0],2); \n    printf(\"Response Sent\\n\");\n    close(sid);\n    close(sid1);\n}\n"}
{"target":"GirijalaAditya","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <sys\/time.h>\n\n#include<sys\/select.h>\n#include <unistd.h>\n\nvoid main() \n{\n    fd_set readfd;\n        char ch;\n    FD_ZERO(&readfd);\n    FD_SET(0,&readfd);\n    struct timeval tm;\n    tm.tv_sec=5;\n    tm.tv_usec=3000000;\n    \n    int ret=select(1,&readfd,NULL,NULL,&tm);\n    if(ret==-1)\n    {\n        printf(\"SEL-ERR\");\n        exit(0);\n    }\n    else if(ret==0)\n    {\n    printf(\"Timeout Occured\");\n    }\n    else\n    {   \n        if(FD_ISSET(0,&readfd))\n        {\n            scanf(\"%c\",&ch);\n            printf(\"The character is %c\\n\",ch);\n    \n        }\n    }   \n}\n"}
{"target":"GirijalaAditya","func":"#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<sys\/select.h>\n#include<sys\/time.h>\n#include<arpa\/inet.h>\n#include<netinet\/in.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    fd_set rdfs;\n    int rval,sockid;\n    char buf1[3],buf2[30];\n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    struct timeval tv;\n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    \n    \n    rval=connect(sockid,(struct sockaddr *)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"CONNECT_ERR\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\n Enter the data to send:\\t\");\n    scanf(\"%s\",buf1);\n    send(sockid,(char *) buf1,sizeof(buf1),0);\n    do\n    {\n        FD_ZERO(&rdfs);\n        FD_SET(sockid,&rdfs);\n        rval=select(sockid+1,&rdfs,NULL,NULL,NULL);\n        printf(\"\\nrval of select = %d\\n\",rval);\n    }while(rval==-1);\n    if(rval>0)\n    {\n        if(FD_ISSET(sockid,&rdfs))\n        {\n            rval=recv(sockid,(char *)buf2,sizeof(buf2),0);\n            if(rval==0)\n            printf(\"\\nNo response from server\\n\");\n            else\n            printf(\"\\nServer Response is %s\\n\",buf2);\n        }\n    }\n    else\n    perror(\"SELECT_ERR\");\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<sys\/select.h>\n#include<sys\/time.h>\n#include<arpa\/inet.h>\n#include<netinet\/in.h>\n#include<netinet\/ip.h>\n#include<string.h>\n\nvoid main(int argc,char* argv[])\n{\n    \n    int rval,sockid;\n    \n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s,c;\n    \n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    char msg[30];\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s)); \n    if(rval==-1)  \n    {   \n        perror(\"CONN-ERR:\");   \n        close(sockid);   \n        exit(1);\n    }\n    printf(\"\\nEnter the request message : \");  \n    scanf(\"%s\",msg);  \n    send(sockid,msg,sizeof(msg),0); \n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<sys\/select.h>\n#include<sys\/time.h>\n#include<arpa\/inet.h>\n#include<netinet\/in.h>\n#include<netinet\/ip.h>\n#include<string.h>\n#define STDIN 1\nvoid main(int argc,char* argv[])\n{\n    \n    int rval,sockid;\n    \n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s,c;\n    \n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    \n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s)); \n    if(rval==-1)  \n    {   \n        perror(\"BIND-ERR:\");   \n        close(sockid);   \n        exit(1);  \n    }   \n    rval=listen(sockid,5);\n    if(rval==-1)  \n    {   \n        perror(\"LISTEN-ERR:\");   \n        close(sockid);   \n        exit(1);  \n    }  \n    fd_set rdfs,copy;\n    FD_ZERO(&rdfs);\n    FD_SET(STDIN,&rdfs);\n    FD_SET(sockid,&rdfs);\n    int maxfd=STDIN>=sockid?STDIN:sockid;\n    maxfd=maxfd+1;\n    char msg[100];\n    struct timeval tm;\n    int ret;\n\n\n    while(1)\n    {\n        copy=rdfs;\n        tm.tv_sec=5;\n        tm.tv_usec=5000000;\n        ret=select(maxfd,&copy,NULL,NULL,&tm);\n        if(ret==-1)\n        perror(\"SEL-ERR\");\n        if(ret==0)\n        printf(\"Timeout occured\");\n        else\n        {\n            if(FD_ISSET(STDIN,&copy))\n            {\n                scanf(\"%s\",msg);\n                printf(\"Message is:%s\\n\",msg);\n            }\n            if(FD_ISSET(sockid,&copy))\n            {\n                int clen=sizeof(c);  \n                int sid1=accept(sockid,(struct sockaddr*)&c,&clen); \n                if(sid1==-1)\n                {\n                    perror(\"ACC-ERR\");\n                    exit(0);\n                }\n                FD_SET(sid1,&rdfs);\n                maxfd=maxfd>=sid1?maxfd:sid1;\n                maxfd=maxfd+1;\n                int k=recv(sid1,msg,sizeof(msg),0);\n                msg[k]='\\0';\n                printf(\"Message from client is:%s\\n\",msg);\n                close(sid1);\n                FD_CLR(sid1,&rdfs);\n            }\n        }\n     \n    }\n    close(sockid);          \n}\n\n\n\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/types.h>\n#include<sys\/ipc.h>\n#include<sys\/msg.h>\ntypedef struct msg\n{\n    long id;\n    char txt[10];\n}message;\nvoid main()\n{\n    int mqid,pid,rval,msgid;\n    system(\"clear\");\n    printf(\"\\nBasic operations on message queues\\n\");\n    printf(\"\\nPP : process id is %d\\n\",getpid());\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"PP : MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    pid=fork();\n    if(pid==-1)\n    {\n        perror(\"PP : FRK-ERR\");\n        msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n        exit(1);\n    }   \n    if(pid==0)\n    {\n        message m1;\n        printf(\"\\nCP : In child process\\tpid=%d\\n\",getpid());\n        printf(\"\\nCP : Parent process id\\tppid=%d\\n\",getppid());\n        printf(\"\\nEnter the message : \");\n        scanf(\"%s\",m1.txt);\n        rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n        if(rval==-1)\n        perror(\"\\nCP : Unable to send message\\n\");\n        else\n        printf(\"\\nCP : message successfully sent\\n\");\n    }\n    else\n    {\n        message m2;\n        rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n        if(rval==-1)\n        perror(\"\\nPP : No message read\\n\");\n        else\n        printf(\"\\n PP : Client message read from queue is %s\\n\",m2.txt);\n        rval=msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n    }\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<string.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/tcp.h>\nvoid main()\n{\n    int sockopt,sockid,optlen,gs;\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_TYPE,&sockopt,&optlen);\n    if(gs==-1)\n    {\n        perror(\"GETSOCK-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    switch(sockopt)\n    {\n        case SOCK_DGRAM:printf(\"\\nDatagram Socket\\n\");\n                break;\n        case SOCK_STREAM:printf(\"\\nStream Socket\\n\");\n                break;\n        case SOCK_RAW:printf(\"\\nRaw Socket\\n\");\n                break;\n        default:printf(\"\\nUnknown Socket type\\n\");\n    }\n\n    \n\n\n    sockopt=2048;\n    optlen=sizeof(sockopt);\n    gs=setsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nSend Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"SND-BUF-ERR:\");\n\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nSend buffer size is %d\\n\",sockopt);\n    else\n    perror(\"SND-BUF-ERR:\");\n\n    \n    \n    sockopt=2048;\n    optlen=sizeof(sockopt);\n    gs=setsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nReceive Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"RCV-BUF-ERR:\");\n\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nReceive Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"RCV-BUF-ERR:\");\n\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,IPPROTO_TCP,TCP_MAXSEG,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nTCP MAX Segment size is %d\\n\",sockopt);\n    else\n    perror(\"TCP-SEG-ERR:\");\n\n    optlen=sizeof(sockopt);\n    sockopt=1;\n    gs=setsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nNODELAY FLAG is set\\n\");\n    else\n    perror(\"TCP-NODELAY-ERR:\");\n\n\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,&optlen);\n    if(gs!=-1)\n    if(sockopt==1)\n    printf(\"\\nNODELAY flag is set\\n\");\n    else\n    printf(\"\\nNODELAY flag not set\\n\");\n    else\n    perror(\"TCP-NODELAY-ERR:\");\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<string.h>\nvoid main(int argc,char* argv[])\n{\n    int rval,sockid,itr,i;\n    char msg[100];\n    struct sockaddr_in lis;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    lis.sin_family=AF_INET;\n    lis.sin_port=htons(atoi(argv[2]));\n    lis.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nEnter the number of messages to be sent: \");\n    scanf(\"%d\",&itr);\n    for(i=1;i<=itr;i++)\n    {\n        strncpy(msg,\" \",100);\n        printf(\"Enter the message %d : \",i);\n        scanf(\"%s\",msg);\n        rval=sendto(sockid,msg,sizeof(msg),0,(struct sockaddr*)&lis,sizeof(lis));\n        if(rval<=0)\n        {\n            perror(\"MSG-SND-ERR:\");\n            close(sockid);\n            exit(1);\n        }\n        printf(\"\\nMessage sent successfully\\n\");\n        if(strcmp(msg,\"EXIT\")==0)\n        {\n            close(sockid);\n            exit(1);\n        }\n    }\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char* argv[])\n{\n    int sockid,rval;\n    char m1[20],m2[20];\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"CONN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    rval=send(sockid,m1,sizeof(m1),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    rval=recv(sockid,m2,sizeof(m2),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nServer response is : %s\\n\",m2);\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<time.h>\n#include<string.h>\nvoid main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    time_t t=time(0);\n    struct sockaddr_in s,c;\n    char buffer[20],smsg[30];\n    strcpy(smsg,ctime(&t));\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    strcpy(smsg,ctime(&t));\n    rval=send(sid1,smsg,sizeof(smsg),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char*argv[])\n{\n    int sid,sid1,rval,itr,i,pid;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    printf(\"\\nEnter the number of clients to serve\/ server iterations : \");\n    scanf(\"%d\",&itr);\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    for(i=1;i<=itr;i++)\n    {\n        clen=sizeof(c);\n        sid1=accept(sid,(struct sockaddr*)&c,&clen);\n        if(sid1==-1)\n        {\n            perror(\"ACCEPT-ERR:\");\n            close(sid);\n            exit(1);\n        }\n        pid=fork();\n        if(pid==-1)\n        {\n            perror(\"FRK-ERR:\");\n            close(sid1);\n            close(sid);\n            exit(1);\n        }\n        if(pid==0) \n        {\n        \n        \n            \n            rval=recv(sid1,buffer,sizeof(buffer),0);\n            if(rval==-1)\n            {\n                perror(\"MSG-RCV-ERR:\");\n            }\n            else\n            {\n                printf(\"\\nClient request is %s\\n\",buffer);\n            }\n            rval=send(sid1,buffer,sizeof(buffer),0);\n            if(rval==-1)\n            {\n                perror(\"MSG-SND-ERR:\");\n            }\n            else\n            {\n                printf(\"\\nResponse sent\\n\");\n            }\n            close(sid1);\n            exit(0);\n        }\n        else \n    \n    \n    \n        close(sid1);\n    }\n    close(sid);\n    exit(0);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char*argv[])\n{\n    int sid,sid1,rval,itr,i;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    printf(\"\\nEnter the number of clients to serve\/ server iterations : \");\n    scanf(\"%d\",&itr);\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    for(i=1;i<=itr;i++)\n    {\n        clen=sizeof(c);\n        sid1=accept(sid,(struct sockaddr*)&c,&clen);\n        rval=recv(sid1,buffer,sizeof(buffer),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n        }\n        else\n        {\n            printf(\"\\nClient request is %s\\n\",buffer);\n        }\n        rval=send(sid1,buffer,sizeof(buffer),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n        }\n        else    \n        {\n            printf(\"\\nResponse sent\\n\");\n        }\n        close(sid1);\n    }\n    close(sid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    rval=send(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<sys\/types.h>\n#include<string.h>\n#include<unistd.h>\n#include<arpa\/inet.h>\nvoid main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage received is : %s\\n\",m2);\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<sys\/types.h>\n#include<string.h>\n#include<unistd.h>\n#include<arpa\/inet.h>\nvoid main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nServer Response is : %s\\n\",m2);\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\n#include<time.h>\n#include<string.h>\n\nvoid main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20],smsg[30];\n    time_t t;\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }   \n    else\n    {\n        printf(\"\\nClient Request is : %s\\n\",buffer);\n    }\n    t=time(0);\n    strcpy(smsg,ctime(&t));\n    rval=sendto(sockid,smsg,sizeof(smsg),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}\n"}
{"target":"GirijalaAditya","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<sys\/types.h>\n#include<sys\/socket.h>\n#include<netinet\/in.h>\n#include<arpa\/inet.h>\n#include<unistd.h>\nvoid main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20];\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nRequest received\\nRequest message is : %s\\n\",buffer);\n    }\n    rval=sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>     \n\n#include <sys\/socket.h>\n#include <arpa\/inet.h>  \n#include <netinet\/in.h>\n\n#include <signal.h>\n#include <errno.h>\n\n#define BUFSIZE 1024\n#define LO \"127.0.0.1\"\n#define PORT 8080\n\n\nvoid str_trim_lf(char *arr, int length);\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr);\nvoid send_recv(int i, int sockfd, char name[32], fd_set* master);\n\nint main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char new_entry_message[42];\n\n    \n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    connect_request(&sockfd, &server_addr);\n\n    \n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    send(sockfd, new_entry_message, 32, 0);\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    \n    \n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n\n    \n    printf(\"\\n--------------------- WELCOME TO THE CHATROOM ---------------------\\n\");\n\n    fdmax = sockfd;\n\n    while (1)\n    {\n        \n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        \n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n               send_recv(i, sockfd, name, &master);\n    }\n    \n    printf(\"Bye\\n\");\n    close(sockfd);\n    return 0;\n}\n\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = inet_addr(LO);\n\n    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"connect\");\n        exit(1);\n    }\n}\n\nvoid send_recv(int i, int sockfd, char name[32], fd_set* master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE+32]=\"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        str_trim_lf(in_buf, BUFSIZE);\n\n        sprintf(send_buf, \"%s > %s\", name, in_buf);\n\n        if (strncmp(in_buf,\"tata\", 4) == 0)\n        {\n            sprintf(disconnect_mssge,\"%s left the chat.\", name);\n            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, send_buf, strlen(send_buf), 0);\n        bzero(send_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);\n        recv_buf[nbyte_recvd] = '\\0';\n        printf(\"%s\\n\", recv_buf);\n    }\n}\n\n\nvoid str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        \n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}\n\n"}
{"target":"gokulsreekumar","func":"#include <netdb.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys\/socket.h> \n#define MAX 80 \n#define PORT 8080 \n#define SA struct sockaddr \n\n\nvoid comm(int sockfd) \n{ \n    char buff[MAX]; \n    int n; \n    while(1) { \n        bzero(buff, sizeof(buff)); \n        printf(\"Write Client's Message: \"); \n        n = 0; \n        while ((buff[n++] = getchar()) != '\\n'); \n        write(sockfd, buff, sizeof(buff)); \n        bzero(buff, sizeof(buff)); \n        read(sockfd, buff, sizeof(buff)); \n        printf(\"Server: %s\\n\", buff); \n        if ((strncmp(buff, \"close\", 5)) == 0) { \n            printf(\"Client Exited\\n\"); \n            break; \n        } \n    } \n} \n\nint main() \n{ \n    int sockfd, connfd; \n    struct sockaddr_in servaddr, cli; \n\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0); \n    if (sockfd == -1) { \n        printf(\"socket creation failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully created..\\n\"); \n    bzero(&servaddr, sizeof(servaddr)); \n\n    \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); \n    servaddr.sin_port = htons(PORT); \n\n    \n    if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) != 0) { \n        printf(\"connection with the server failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"connected to the server..\\n\"); \n\n    \n    comm(sockfd); \n\n    \n    close(sockfd); \n} \n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h> \n\n#include <sys\/socket.h>\n#include <arpa\/inet.h> \n#include <netinet\/in.h>\n\n#include <signal.h>\n#include <errno.h>\n\n#define BUFSIZE 1024\n#define LO \"127.0.0.1\"\n#define PORT 8080\n\n\n\n\n\n\n\nstruct message\n{\n    int type;\n    char name[32];\n    char data[BUFSIZE];\n};\n\nvoid trim_newline(char *arr, int length);\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr);\nvoid send_recv(int i, int sockfd, char name[32], fd_set *master);\n\nint main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char password[32];\n    char new_entry_message[45];\n\n    \n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    trim_newline(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"Please enter your password: \");\n    fgets(password, 32, stdin);\n    trim_newline(password, strlen(password));\n\n    \n    connect_request(&sockfd, &server_addr);\n\n    \n    struct message new_member_message;\n    new_member_message.type = 1;\n    strcpy(new_member_message.name, name);\n    strcpy(new_member_message.data, password);\n    send(sockfd, &new_member_message, sizeof(struct message), 0);\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    \n    \n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n\n    printf(\"\\nWelcome to Project COBRA\\n\");\n\n    fdmax = sockfd;\n    while (1)\n    {\n        \n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        \n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n                send_recv(i, sockfd, name, &master);\n    }\n    close(sockfd);\n    return 0;\n}\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = inet_addr(LO);\n\n    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"connect\");\n        exit(1);\n    }\n}\nint cnt = 0;\nvoid send_recv(int i, int sockfd, char name[32], fd_set *master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE + 32] = \"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    struct message send_message, recv_message;\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        trim_newline(in_buf, BUFSIZE);\n\n        \n        send_message.type = 0;\n        strcpy(send_message.name, name);\n        sprintf(send_message.data, \"%s\", in_buf);\n\n        if (strncmp(in_buf, \"bye\", 3) == 0)\n        {\n            send_message.type = 2;\n            sprintf(send_message.data, \"left the discussion\");\n            send(sockfd, &send_message, sizeof(struct message), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, &send_message, sizeof(struct message), 0);\n        bzero(in_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, &recv_message, sizeof(struct message), 0);\n        if (nbyte_recvd == 0) {\n            close(sockfd);\n            exit(1);\n        }\n        if (recv_message.type == 0)\n        {\n            printf(\"[%s]: %s\\n\", recv_message.name, recv_message.data);\n        }\n        else if (recv_message.type == 1)\n        {\n            printf(\"%s joined the chat!\\n\", recv_message.name);\n        }\n        else if (recv_message.type == 2)\n        {\n            printf(\"%s left the chat!\\n\", recv_message.name);\n        }\n        else if (recv_message.type == 3)\n        {\n            printf(\"%d. %s is present\\n\", ++cnt, recv_message.name);\n        }\n        else if (recv_message.type == 4) \n        {\n            printf(\"Sorry Wrong Password. Try Again to Enter\\n\");\n            close(sockfd);\n            exit(0);\n        }\n    }\n}\n\nvoid trim_newline(char *arr, int length)\n{\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        \n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>     \n\n#include <sys\/socket.h>\n#include <arpa\/inet.h>  \n#include <netinet\/in.h>\n\n#include <signal.h>\n#include <errno.h>\n\n#define BUFSIZE 1024\n#define LO \"127.0.0.1\"\n#define PORT 8080\n\n\nvoid str_trim_lf(char *arr, int length);\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr);\nvoid send_recv(int i, int sockfd, char name[32], fd_set* master);\n\nint main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char new_entry_message[42];\n\n    \n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    connect_request(&sockfd, &server_addr);\n\n    \n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    send(sockfd, new_entry_message, 32, 0);\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    \n    \n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n\n    \n    printf(\"\\n--------------------- WELCOME TO THE CHATROOM ---------------------\\n\");\n\n    fdmax = sockfd;\n\n    while (1)\n    {\n        \n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        \n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n               send_recv(i, sockfd, name, &master);\n    }\n    \n    printf(\"Bye\\n\");\n    close(sockfd);\n    return 0;\n}\n\n\nvoid connect_request(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = inet_addr(LO);\n\n    if (connect(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"connect\");\n        exit(1);\n    }\n}\n\nvoid send_recv(int i, int sockfd, char name[32], fd_set* master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE+32]=\"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        str_trim_lf(in_buf, BUFSIZE);\n\n        sprintf(send_buf, \"%s > %s\", name, in_buf);\n\n        if (strncmp(in_buf,\"tata\", 4) == 0)\n        {\n            sprintf(disconnect_mssge,\"%s left the chat.\", name);\n            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, send_buf, strlen(send_buf), 0);\n        bzero(send_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);\n        recv_buf[nbyte_recvd] = '\\0';\n        printf(\"%s\\n\", recv_buf);\n    }\n}\n\n\nvoid str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        \n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}\n\n"}
{"target":"gokulsreekumar","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <netdb.h>\n#include <sys\/types.h>\n#include <netinet\/in.h>\n#include <sys\/socket.h>\n\n#include <arpa\/inet.h>\n\n#define PORT \"8888\" \n\n#define MAXDATASIZE 100 \n\n\nvoid *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}\n\nint main(int argc, char *argv[])\n{\n    int sockfd, numbytes;  \n    char buf[MAXDATASIZE];\n    struct addrinfo hints, *servinfo, *p;\n    int rv;\n    char s[INET6_ADDRSTRLEN];\n\n    if (argc != 2) {\n        fprintf(stderr,\"usage: client hostname\\n\");\n        exit(1);\n    }\n\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    if ((rv = getaddrinfo(argv[1], PORT, &hints, &servinfo)) != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(rv));\n        return 1;\n    }\n\n    \n    for(p = servinfo; p != NULL; p = p->ai_next) {\n        if ((sockfd = socket(p->ai_family, p->ai_socktype,\n                p->ai_protocol)) == -1) {\n            perror(\"client: socket\");\n            continue;\n        }\n\n        if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {\n            perror(\"client: connect\");\n            close(sockfd);\n            continue;\n        }\n\n        break;\n    }\n\n    if (p == NULL) {\n        fprintf(stderr, \"client: failed to connect\\n\");\n        return 2;\n    }\n\n    inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr),\n            s, sizeof s);\n    printf(\"client: connecting to %s\\n\", s);\n\n    freeaddrinfo(servinfo); \n\n    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {\n        perror(\"recv\");\n        exit(1);\n    }\n\n    buf[numbytes] = '\\0';\n\n    printf(\"client: received '%s'\\n\",buf);\n\n    close(sockfd);\n\n    return 0;\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <string.h> \n#include <unistd.h>     \n\n#include <sys\/socket.h> \n#include <arpa\/inet.h>  \n\n#include <pthread.h>\n\n#define PORT 8080       \n#define LO \"127.0.0.1\"  \n\nint main(int argc, char const *argv[]) \n{ \n    int socket_client = 0, n; \n    struct sockaddr_in serv_addr; \n    char buffer[1024] = {0}; \n\n    \n    if ((socket_client = socket(AF_INET, SOCK_STREAM, 0)) < 0) \n    { \n        printf(\"\\n Socket creation error \\n\"); \n        return -1; \n    }\n\n    \n    serv_addr.sin_family = AF_INET; \n    serv_addr.sin_port = htons(PORT); \n    \n    \n    if(inet_pton(AF_INET, LO , &serv_addr.sin_addr)<=0) \n    { \n        printf(\"\\nInvalid address\/ Address not supported \\n\"); \n        return -1; \n    } \n\n    \n    if (connect(socket_client, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) \n    { \n        printf(\"\\nConnection Failed \\n\"); \n        return -1; \n    }\n    \n    \n    while(1) {\n        bzero(buffer, 1024);\n        printf(\"Enter Client's Message: \");\n        fgets(buffer, 1024, stdin);\n        char bye[5] = \"close\";\n        if(strncmp(buffer, \"close\", 5)==0) {\n            n = send(socket_client , bye, 1024, 0); \n            \n            close(socket_client);\n            break;\n        }\n        n = send(socket_client , buffer, 1024, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        bzero(buffer, 1024);\n        n = recv(socket_client , buffer, 1024, 0); \n\n        printf(\"Server: %s\\n\", buffer);\n        bzero(buffer, 1024);\n\n    }\n    printf(\"Client Closed Connection.\\n\"); \n    return 0; \n} \n\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>   \n#include<string.h> \n#include<stdlib.h> \n#include <unistd.h> \n\n\n#include<arpa\/inet.h>\n#include<sys\/socket.h>\n\n#define SERVER \"127.0.0.1\"\n#define BUFLEN 512  \n#define PORT 8888   \n\nvoid error(char *s)\n{\n    perror(s);\n    exit(1);\n}\n\n\n\nint main(void)\n{\n    struct sockaddr_in si_client;\n    int socket_udp, i, slen=sizeof(si_client);\n    char buf[BUFLEN];\n    char message[BUFLEN];\n\n    if ((socket_udp=socket(AF_INET, SOCK_DGRAM, 0)) == -1)\n    {\n        error(\"socket\");\n    }\n\n    memset((char *) &si_client, 0, sizeof(si_client));\n\n    si_client.sin_family = AF_INET;\n    si_client.sin_port = htons(PORT);\n    if (inet_aton(SERVER , &si_client.sin_addr) == 0) \n    {\n        fprintf(stderr, \"inet_aton() failed\\n\");\n        exit(1);\n    }\n\n    while(1)\n    {\n        printf(\"Enter message : \");\n        fgets(message, 512, stdin);\n        \n        if(strncmp(message, \"close\", 5)==0) {\n            close(socket_udp);\n            exit(0);\n        }\n        \n        if (sendto(socket_udp, message, strlen(message) , 0 , (struct sockaddr *) &si_client, slen)==-1)\n        {\n            error(\"sendto()\");\n        }\n        \n        \n        memset(buf,'\\0', BUFLEN);\n\n        \n        \n        if (recvfrom(socket_udp, buf, BUFLEN, 0, (struct sockaddr *) &si_client, &slen) == -1)\n        {\n            error(\"recvfrom()\");\n        }\n        \n        puts(buf);\n    }\n\n    close(socket_udp);\n    return 0;\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <pthread.h>\n\n#define LENGTH 2048\n\n\nvolatile sig_atomic_t flag = 0;\nint sockfd = 0;\nchar name[32];\nchar new_entry_message[42];\n\nvoid str_overwrite_stdout()\n{\n    printf(\"%s\", \"> \");\n    fflush(stdout);\n}\n\nvoid str_trim_lf(char *arr, int length)\n{\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        \n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}\n\nvoid catch_ctrl_c_and_exit(int sig)\n{\n    flag = 1;\n}\n\nvoid send_msg_handler()\n{\n    char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n\n    while (1)\n    {\n        str_overwrite_stdout();\n        fgets(message, LENGTH, stdin);\n        str_trim_lf(message, LENGTH);\n\n        if (strcmp(message, \"exit\") == 0)\n        {\n            break;\n        }\n        else\n        {\n            sprintf(buffer, \"%s: %s\\n\", name, message);\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n\n        bzero(message, LENGTH);\n        bzero(buffer, LENGTH + 32);\n    }\n    catch_ctrl_c_and_exit(2);\n}\n\nvoid recv_msg_handler()\n{\n    char message[LENGTH] = {};\n    while (1)\n    {\n        int receive = recv(sockfd, message, LENGTH, 0);\n        if (receive > 0)\n        {\n            printf(\"%s\", message);\n            str_overwrite_stdout();\n        }\n        else if (receive == 0)\n        {\n            break;\n        }\n        else\n        {\n            \n        }\n        memset(message, 0, sizeof(message));\n    }\n}\n\nint main(int argc, char **argv)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n\n    signal(SIGINT, catch_ctrl_c_and_exit);\n\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    struct sockaddr_in server_addr;\n\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(ip);\n    server_addr.sin_port = htons(port);\n\n    \n    int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n    if (err == -1)\n    {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n\n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    \n    send(sockfd, new_entry_message, 32, 0);\n\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n\n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, NULL) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n\n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, NULL) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n\n    while (1)\n    {\n        if (flag)\n        {\n            printf(\"\\nBye.\\n\");\n            break;\n        }\n    }\n\n    close(sockfd);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>     \n\n#include <sys\/socket.h>\n#include <arpa\/inet.h>  \n\n#include <pthread.h>\n#include <signal.h>\n\n#define PORT 8080       \n#define LO \"127.0.0.1\"  \n\n#define LENGTH 2048\n\nchar name[32];\nchar new_entry_message[42];\n\n\nvolatile sig_atomic_t flag = 0;\n\nvoid str_overwrite_stdout();\nvoid str_trim_lf(char *arr, int length);\nvoid catch_ctrl_c_and_exit(int sig);\n\n\nvoid* send_msg_handler(void*);\nvoid* recv_msg_handler(void*);\n\n\nvoid communication(int);\nvoid block();\n\nint main(int argc, char const *argv[])\n{\n    int socket_client = 0, n;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    \n\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    if ((socket_client = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        printf(\"\\n Socket creation error \\n\");\n        return -1;\n    }\n\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    \n    if(inet_pton(AF_INET, LO , &serv_addr.sin_addr)<=0)\n    {\n        printf(\"\\nInvalid address\/ Address not supported \\n\");\n        return -1;\n    }\n\n    \n    if (connect(socket_client, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n    {\n        printf(\"\\nConnection Failed \\n\");\n        return -1;\n    }\n\n    \n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined! \\n\");\n\n    send(socket_client, new_entry_message, 32, 0);\n\n    \n    printf(\"\\n--------------------- WELCOME TO THE CHATROOM ---------------------\\n\");\n\n    \n    communication(socket_client);\n\n    close(socket_client);\n\n    return EXIT_SUCCESS;\n}\n\nvoid communication(int socket_client) {\n\n    int* pclient = malloc(sizeof(int));\n    *pclient = socket_client;\n    \n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    block();\n}\n\nvoid* send_msg_handler(void* pclient)\n{\n    int sockfd = *((int* ) pclient);\n    char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n    while (1)\n    {\n        str_overwrite_stdout();\n        fgets(message, LENGTH, stdin);\n        str_trim_lf(message, LENGTH);\n\n        if (strcmp(message, \"exit\") == 0)\n        {\n            break;\n        }\n        else\n        {\n            sprintf(buffer, \"%s: %s\\n\", name, message);\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n\n        bzero(message, LENGTH);\n        bzero(buffer, LENGTH + 32);\n    }\n    catch_ctrl_c_and_exit(2);\n    return NULL;\n}\n\nvoid* recv_msg_handler(void* pclient)\n{\n    int sockfd = *((int* ) pclient);\n    char message[LENGTH] = {};\n    while (1)\n    {\n        int receive = recv(sockfd, message, LENGTH, 0);\n        if (receive > 0)\n        {\n            printf(\"%s\", message);\n            str_overwrite_stdout();\n        }\n        else if (receive == 0)\n        {\n            break;\n        }\n        memset(message, 0, sizeof(message));\n    }\n    return NULL;\n}\n\nvoid str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        \n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}\n\nvoid str_overwrite_stdout()\n{\n    printf(\"%s\", \"> \");\n    fflush(stdout);\n}\n\nvoid block()\n{\n    while (1)\n    {\n        if (flag)\n        {\n            printf(\"\\nBye.\\n\");\n            return;\n        }\n    }\n}\n\nvoid catch_ctrl_c_and_exit(int sig)\n{\n    flag = 1;\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <pthread.h>\n\n#define LENGTH 2048\n\n\nvolatile sig_atomic_t flag = 0;\nint sockfd = 0;\nchar name[32];\n\nvoid str_overwrite_stdout() {\n  printf(\"%s\", \"> \");\n  fflush(stdout);\n}\n\nvoid str_trim_lf (char* arr, int length) {\n  int i;\n  for (i = 0; i < length; i++) { \n    if (arr[i] == '\\n') {\n      arr[i] = '\\0';\n      break;\n    }\n  }\n}\n\nvoid catch_ctrl_c_and_exit(int sig) {\n    flag = 1;\n}\n\nvoid send_msg_handler() {\n  char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n\n  while(1) {\n    str_overwrite_stdout();\n    fgets(message, LENGTH, stdin);\n    str_trim_lf(message, LENGTH);\n\n    if (strcmp(message, \"exit\") == 0) {\n            break;\n    } else {\n      sprintf(buffer, \"%s: %s\\n\", name, message);\n      send(sockfd, buffer, strlen(buffer), 0);\n    }\n\n        bzero(message, LENGTH);\n    bzero(buffer, LENGTH + 32);\n  }\n  catch_ctrl_c_and_exit(2);\n}\n\nvoid recv_msg_handler() {\n    char message[LENGTH] = {};\n  while (1) {\n        int receive = recv(sockfd, message, LENGTH, 0);\n    if (receive > 0) {\n      printf(\"%s\", message);\n      str_overwrite_stdout();\n    } else if (receive == 0) {\n            break;\n    } else {\n            \n        }\n        memset(message, 0, sizeof(message));\n  }\n}\n\nint main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n\n    signal(SIGINT, catch_ctrl_c_and_exit);\n\n    printf(\"Please enter your name: \");\n  fgets(name, 32, stdin);\n  str_trim_lf(name, strlen(name));\n\n\n    if (strlen(name) > 32 || strlen(name) < 2){\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    struct sockaddr_in server_addr;\n\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = inet_addr(ip);\n  server_addr.sin_port = htons(port);\n\n\n  \n  int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (err == -1) {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    send(sockfd, name, 32, 0);\n\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n\n    pthread_t send_msg_thread;\n  if(pthread_create(&send_msg_thread, NULL, (void *) send_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n    return EXIT_FAILURE;\n    }\n\n    pthread_t recv_msg_thread;\n  if(pthread_create(&recv_msg_thread, NULL, (void *) recv_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n\n    while (1){\n        if(flag){\n            printf(\"\\nBye\\n\");\n            break;\n    }\n    }\n\n    close(sockfd);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"gokulsreekumar","func":"#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <pthread.h>\n#include <sys\/types.h>\n#include <signal.h>\n\n#define MAX_CLIENTS 100\n#define BUFFER_SZ 2048\n\nstatic _Atomic unsigned int cli_count = 0;\nstatic int uid = 10;\n\n\ntypedef struct{\n    struct sockaddr_in address;\n    int sockfd;\n    int uid;\n    char name[32];\n} client_t;\n\nclient_t *clients[MAX_CLIENTS];\n\npthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid str_overwrite_stdout() {\n    printf(\"\\r%s\", \"> \");\n    fflush(stdout);\n}\n\nvoid str_trim_lf (char* arr, int length) {\n  int i;\n  for (i = 0; i < length; i++) { \n    if (arr[i] == '\\n') {\n      arr[i] = '\\0';\n      break;\n    }\n  }\n}\n\nvoid print_client_addr(struct sockaddr_in addr){\n    printf(\"%d.%d.%d.%d\",\n        addr.sin_addr.s_addr & 0xff,\n        (addr.sin_addr.s_addr & 0xff00) >> 8,\n        (addr.sin_addr.s_addr & 0xff0000) >> 16,\n        (addr.sin_addr.s_addr & 0xff000000) >> 24);\n}\n\n\nvoid queue_add(client_t *cl){\n    pthread_mutex_lock(&clients_mutex);\n\n    for(int i=0; i < MAX_CLIENTS; ++i){\n        if(!clients[i]){\n            clients[i] = cl;\n            break;\n        }\n    }\n\n    pthread_mutex_unlock(&clients_mutex);\n}\n\n\nvoid queue_remove(int uid){\n    pthread_mutex_lock(&clients_mutex);\n\n    for(int i=0; i < MAX_CLIENTS; ++i){\n        if(clients[i]){\n            if(clients[i]->uid == uid){\n                clients[i] = NULL;\n                break;\n            }\n        }\n    }\n\n    pthread_mutex_unlock(&clients_mutex);\n}\n\n\nvoid send_message(char *s, int uid){\n    pthread_mutex_lock(&clients_mutex);\n\n    for(int i=0; i<MAX_CLIENTS; ++i){\n        if(clients[i]){\n            if(clients[i]->uid != uid){\n                if(write(clients[i]->sockfd, s, strlen(s)) < 0){\n                    perror(\"ERROR: write to descriptor failed\");\n                    break;\n                }\n            }\n        }\n    }\n\n    pthread_mutex_unlock(&clients_mutex);\n}\n\n\nvoid *handle_client(void *arg){\n    char buff_out[BUFFER_SZ];\n    char name[32];\n    int leave_flag = 0;\n\n    cli_count++;\n    client_t *cli = (client_t *)arg;\n\n    \n    if(recv(cli->sockfd, name, 32, 0) <= 0 || strlen(name) <  2 || strlen(name) >= 32-1){\n        printf(\"Didn't enter the name.\\n\");\n        leave_flag = 1;\n    } else{\n        strcpy(cli->name, name);\n        sprintf(buff_out, \"%s has joined\\n\", cli->name);\n        printf(\"%s\", buff_out);\n        send_message(buff_out, cli->uid);\n    }\n\n    bzero(buff_out, BUFFER_SZ);\n\n    while(1){\n        if (leave_flag) {\n            break;\n        }\n\n        int receive = recv(cli->sockfd, buff_out, BUFFER_SZ, 0);\n        if (receive > 0){\n            if(strlen(buff_out) > 0){\n                send_message(buff_out, cli->uid);\n\n                str_trim_lf(buff_out, strlen(buff_out));\n                printf(\"%s -> %s\\n\", buff_out, cli->name);\n            }\n        } else if (receive == 0 || strcmp(buff_out, \"exit\") == 0){\n            sprintf(buff_out, \"%s has left\\n\", cli->name);\n            printf(\"%s\", buff_out);\n            send_message(buff_out, cli->uid);\n            leave_flag = 1;\n        } else {\n            printf(\"ERROR: -1\\n\");\n            leave_flag = 1;\n        }\n\n        bzero(buff_out, BUFFER_SZ);\n    }\n\n  \n    close(cli->sockfd);\n  queue_remove(cli->uid);\n  free(cli);\n  cli_count--;\n  pthread_detach(pthread_self());\n\n    return NULL;\n}\n\nint main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    int option = 1;\n    int listenfd = 0, connfd = 0;\n  struct sockaddr_in serv_addr;\n  struct sockaddr_in cli_addr;\n  pthread_t tid;\n\n  \n  listenfd = socket(AF_INET, SOCK_STREAM, 0);\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_addr.s_addr = inet_addr(ip);\n  serv_addr.sin_port = htons(port);\n\n  \n    signal(SIGPIPE, SIG_IGN);\n\n    if(setsockopt(listenfd, SOL_SOCKET,(SO_REUSEPORT | SO_REUSEADDR),(char*)&option,sizeof(option)) < 0){\n        perror(\"ERROR: setsockopt failed\");\n    return EXIT_FAILURE;\n    }\n\n    \n  if(bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n    perror(\"ERROR: Socket binding failed\");\n    return EXIT_FAILURE;\n  }\n\n  \n  if (listen(listenfd, 10) < 0) {\n    perror(\"ERROR: Socket listening failed\");\n    return EXIT_FAILURE;\n    }\n\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n\n    while(1){\n        socklen_t clilen = sizeof(cli_addr);\n        connfd = accept(listenfd, (struct sockaddr*)&cli_addr, &clilen);\n\n        \n        if((cli_count + 1) == MAX_CLIENTS){\n            printf(\"Max clients reached. Rejected: \");\n            print_client_addr(cli_addr);\n            printf(\":%d\\n\", cli_addr.sin_port);\n            close(connfd);\n            continue;\n        }\n\n        \n        client_t *cli = (client_t *)malloc(sizeof(client_t));\n        cli->address = cli_addr;\n        cli->sockfd = connfd;\n        cli->uid = uid++;\n\n        \n        queue_add(cli);\n        pthread_create(&tid, NULL, &handle_client, (void*)cli);\n\n        \n        sleep(1);\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"gokulsreekumar","func":"\n\n\n\n\n\n\n\n\n\n\n\n     \n\n\n\n     \n\n\n\n\n\n\n\n         \n\n         \n\n\n         \n\n\n     \n\n\n\n\n\n         \n\n\n\n\n\n\n     \n\n\n\n\n\n\n\n\n     \n\n\n\n\n         \n\n\n\n\n\n\n\n         \n\n\n\n\n\n\n         \n\n\n\n         \n\n\n\n\n     \n\n\n\n             \n\n\n\n\n\n                 \n\n\n\n                 \n\n\n\n\n     \n\n\n\n       \n\n\n\n\n             \n\n\n\n\n\n\n\n\n\n\n             \n\n\n\n           \n\n\n\n\n\n                 \n\n                 \n\n\n\n\n\n\n\n\n                         \n\n\n\n\n             \n\n\n\n\n                 \n\n\n\n\n\n\n\n\n\n\n\n                         \n\n\n\n\n                     \n\n\n\n\n\n\n\n\n\n\n\n         \n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <netdb.h>\n\n#define PORT \"8888\"   \n\n\nvoid *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}\n\nint main(void)\n{\n    fd_set master;    \n    fd_set read_fds;  \n    int fdmax;        \n\n    int listener;     \n    int newfd;        \n    struct sockaddr_storage remoteaddr; \n    socklen_t addrlen;\n\n    char buf[256];    \n    int nbytes;\n\n    char remoteIP[INET6_ADDRSTRLEN];\n\n    int yes=1;        \n    int i, j, rv;\n\n    struct addrinfo hints, *ai, *p;\n\n    FD_ZERO(&master);    \n    FD_ZERO(&read_fds);\n\n    \n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n    if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {\n        fprintf(stderr, \"selectserver: %s\\n\", gai_strerror(rv));\n        exit(1);\n    }\n    \n    for(p = ai; p != NULL; p = p->ai_next) {\n        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n        if (listener < 0) { \n            continue;\n        }\n        \n        \n        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n\n        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {\n            close(listener);\n            continue;\n        }\n\n        break;\n    }\n\n    \n    if (p == NULL) {\n        fprintf(stderr, \"selectserver: failed to bind\\n\");\n        exit(2);\n    }\n\n    freeaddrinfo(ai); \n\n    \n    if (listen(listener, 10) == -1) {\n        perror(\"listen\");\n        exit(3);\n    }\n\n    \n    FD_SET(listener, &master);\n\n    \n    fdmax = listener; \n\n    \n    for(;;) {\n        read_fds = master; \n        if (select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {\n            perror(\"select\");\n            exit(4);\n        }\n\n        \n        for(i = 0; i <= fdmax; i++) {\n            if (FD_ISSET(i, &read_fds)) { \n                if (i == listener) {\n                    \n                    addrlen = sizeof remoteaddr;\n                    newfd = accept(listener,\n                        (struct sockaddr *)&remoteaddr,\n                        &addrlen);\n\n                    if (newfd == -1) {\n                        perror(\"accept\");\n                    } else {\n                        FD_SET(newfd, &master); \n                        if (newfd > fdmax) {    \n                            fdmax = newfd;\n                        }\n                        printf(\"selectserver: new connection from %s on \"\n                            \"socket %d\\n\",\n                            inet_ntop(remoteaddr.ss_family,\n                                get_in_addr((struct sockaddr*)&remoteaddr),\n                                remoteIP, INET6_ADDRSTRLEN),\n                            newfd);\n                    }\n                } else {\n                    \n                    if ((nbytes = recv(i, buf, sizeof buf, 0)) <= 0) {\n                        \n                        if (nbytes == 0) {\n                            \n                            printf(\"selectserver: socket %d hung up\\n\", i);\n                        } else {\n                            perror(\"recv\");\n                        }\n                        close(i); \n                        FD_CLR(i, &master); \n                    } else {\n                        \n                        for(j = 0; j <= fdmax; j++) {\n                            \n                            if (FD_ISSET(j, &master)) {\n                                \n                                if (j != listener && j != i) {\n                                    if (send(j, buf, nbytes, 0) == -1) {\n                                        perror(\"send\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } \n            } \n        } \n    } \n    \n    return 0;\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <netdb.h>\n\n#define PORT 8080\n#define BUFSIZE 1024\n\nstruct message {\n    int type;\n    char data[BUFSIZE];\n};\n\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr);\n\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);\n\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax);\n\nint main()\n{\n    fd_set master, read_fds;\n\n    int fdmax, i;\n    int sockfd = 0;\n\n    struct sockaddr_in server_addr, client_addr;\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    server_set_up(&sockfd, &server_addr);\n\n    \n    FD_SET(sockfd, &master);\n\n    \n    fdmax = sockfd;\n\n    while (1)\n    {\n        \n        read_fds = master;\n\n        \n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n\n        \n        for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    \n                    \n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    \n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    \n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = INADDR_ANY;\n\n    \n\n    \n    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"Unable to bind\");\n        exit(1);\n    }\n    printf(\"TCP Server Bound to Port: %d\\n\", PORT);\n    \n    if (listen(*sockfd, 10) == -1)\n    {\n        perror(\"listen\");\n        exit(1);\n    }\n    printf(\"TCP Server Waiting for Client Requests...\\n\");\n    fflush(stdout);\n}\n\n\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)\n{\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n    int newsockfd;\n\n    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)\n    {\n        perror(\"accept\");\n        exit(1);\n    } \n    else \n    {\n        \n        FD_SET(newsockfd, master);\n        \n        if (newsockfd > *fdmax)\n            *fdmax = newsockfd;\n        printf(\"New connection at %s : %d \\n\", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));\n    }\n}\n\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax) \n{\n    int recv_size, j;\n    char recv_buf[BUFSIZE], buf[BUFSIZE];\n    if ((recv_size = recv(i, recv_buf, BUFSIZE, 0)) <= 0)\n    {\n        if (recv_size == 0)\n            printf(\"Socket with FD: %d Hung Up\\n\", i);\n        else\n            perror(\"recv\");\n\n        \n        \n        close(i);\n        FD_CLR(i, master);\n    }\n    else\n    {\n        for (j = 0; j <= fdmax; j++)\n        {\n            \n            if (FD_ISSET(j, master))\n            {\n                if (j != sockfd && j != i)\n                {\n                    if (send(j, recv_buf, recv_size, 0) == -1)\n                    {\n                        perror(\"send\");\n                    }\n                }\n            }\n        }\n        printf(\"%s\\n\", recv_buf);\n        bzero(recv_buf, BUFSIZE);\n    }\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <string.h>\n#include <unistd.h>     \n\n\n\n#include <sys\/types.h>  \n#include <sys\/socket.h> \n\n#include <netinet\/in.h> \n#include<arpa\/inet.h>   \n\n#define PORT 8080 \n\nint main(int argc, char const *argv[]) \n{ \n    int server_fd, new_socket, n; \n    struct sockaddr_in server_address, client_address; \n    char buffer[1024] = {0}; \n    \n    \n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) \n    { \n        perror(\"socket failed\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"TCP Socket Created!\\n\");\n\n    \n    \n    server_address.sin_family = AF_INET; \n    server_address.sin_addr.s_addr = INADDR_ANY; \n    server_address.sin_port = htons( PORT ); \n    \n    \n    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) \n    { \n        perror(\"bind failed\"); \n        exit(EXIT_FAILURE); \n    }\n    printf(\"Socket bound to 0.0.0.0: 8080\\n\");\n\n    \n    if(listen(server_fd, 3) < 0) \n    { \n        perror(\"listen\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"Listening on Port: 8080\\n\");\n\n    \n    \n    int addrlen = sizeof(client_address); \n    if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) \n    { \n        perror(\"accept\"); \n        exit(EXIT_FAILURE); \n    } \n    \n    \n    \n    \n    printf(\"Connected to %s:%d\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n\n    \n    while(1) {\n        bzero(buffer, 1024);\n        n = recv( new_socket , buffer, 1024, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        printf(\"Client: %s\\n\", buffer);\n        bzero(buffer, 1024);\n        printf(\"Enter Server's Message:\");\n        fgets(buffer, 1024, stdin);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            close(new_socket);\n            break;\n        }\n        send(new_socket , buffer , strlen(buffer) , 0 ); \n    }\n\n    \n    close(server_fd);\n    printf(\"Server Closed.\\n\");\n    return 0; \n} \n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <netdb.h> \n#include <netinet\/in.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys\/socket.h> \n#include <sys\/types.h> \n#define MAX 80 \n#define PORT 8080 \n#define SA struct sockaddr \n\n\nvoid comm(int sockfd) \n{ \n    char buff[MAX]; \n    int n; \n    \n    while(1) { \n        bzero(buff, MAX); \n\n        \n        read(sockfd, buff, sizeof(buff)); \n        \n        printf(\"From client: %s\\t To client : \", buff); \n        bzero(buff, MAX); \n        n = 0; \n        \n        while ((buff[n++] = getchar()) != '\\n'); \n\n        \n        write(sockfd, buff, sizeof(buff)); \n\n        \n        if (strncmp(\"close\", buff, 5) == 0) { \n            printf(\"Server Exit!\\n\"); \n            break; \n        } \n    } \n} \n\n\nint main() \n{ \n    int sockfd, connfd, len; \n    struct sockaddr_in servaddr, cli; \n\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0); \n    if (sockfd == -1) { \n        printf(\"socket creation failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully created..\\n\"); \n    bzero(&servaddr, sizeof(servaddr)); \n\n    \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); \n    servaddr.sin_port = htons(PORT); \n\n    \n    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) { \n        printf(\"socket bind failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully binded..\\n\"); \n\n    \n    if ((listen(sockfd, 5)) != 0) { \n        printf(\"Listen failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Server listening..\\n\"); \n    len = sizeof(cli); \n\n    \n    connfd = accept(sockfd, (SA*)&cli, &len); \n    if (connfd < 0) { \n        printf(\"server acccept failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"server acccept the client...\\n\"); \n\n    \n    comm(connfd); \n\n    \n    close(sockfd); \n} \n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <netdb.h>\n\n#define PORT 8080\n#define BUFSIZE 1024\n\n#define MAX_NUMBER_CLIENTS 1024\nchar name_directory[MAX_NUMBER_CLIENTS][32];\n\n#define PASSWORD \"password\"\n\n\n\n\n\n\n\n\nstruct message\n{\n    int type;\n    char name[32];\n    char data[BUFSIZE];\n};\n\n\n\n\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr);\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax);\n\nint main()\n{\n    fd_set master, read_fds;\n\n    int fdmax, i;\n    int sockfd = 0;\n\n    struct sockaddr_in server_addr, client_addr;\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    server_set_up(&sockfd, &server_addr);\n\n    \n    \n    FD_SET(sockfd, &master);\n    fdmax = sockfd;\n\n    \n    memset(name_directory, '\\0', sizeof(name_directory));\n\n    while (1)\n    {\n        \n        read_fds = master;\n        \n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n       for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    \n                    \n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    \n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    \n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = INADDR_ANY;\n\n    \n    int flag = 1;\n    if (setsockopt(*sockfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int)) == -1) {\n        perror(\"error in setsockopt\");\n        exit(1);\n    }\n\n    \n    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"Unable to bind\");\n        exit(1);\n    }\n    printf(\"TCP Server Bound to Port: %d\\n\", PORT);\n\n    \n    if (listen(*sockfd, 10) == -1)\n    {\n        perror(\"listen\");\n        exit(1);\n    }\n    printf(\"TCP Server Waiting for Client Requests...\\n\");\n    fflush(stdout);\n}\n\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)\n{\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n    int newsockfd;\n\n    char list_message[32] = \"The List of People Online are:\";\n    char name_message[32];\n\n    struct message send_message;\n\n    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)\n    {\n        perror(\"accept\");\n        exit(1);\n    }\n    else\n    {\n        \n        FD_SET(newsockfd, master);\n        \n        if (newsockfd > *fdmax)\n            *fdmax = newsockfd;\n        printf(\"New connection at %s : %d \\n\", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));\n        strcpy(send_message.data, \"\\0\");\n        for (int i = 0; i < *(fdmax); i++)\n        {\n            if (FD_ISSET(i, master) && i != newsockfd)\n            {\n                if (name_directory[i][0] != '\\0')\n                {\n                    send_message.type = 3;\n                    strcpy(send_message.name, name_directory[i]);\n                    send(newsockfd, &send_message, sizeof(struct message), 0);\n                }\n            }\n        }\n    }\n}\n\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax)\n{\n    int recv_size, j;\n    struct message recv_message, send_message;\n    char recv_buf[BUFSIZE];\n\n    if ((recv_size = recv(i, &recv_message, sizeof(struct message), 0)) <= 0)\n    {\n        if (recv_size == 0)\n            printf(\"Socket with FD: %d Hung Up\\n\", i);\n        else\n            perror(\"recv\");\n\n        \n        strcpy(name_directory[i], \"\\0\");\n\n        \n        \n        close(i);\n        FD_CLR(i, master);\n    }\n    else\n    {\n        \n        send_message.type = recv_message.type;\n        strcpy(send_message.name, recv_message.name);\n        strcpy(send_message.data, recv_message.data);\n\n        if (recv_message.type == 1)\n        {\n            \n            \n            if(strcmp(recv_message.data, PASSWORD)==0) {\n                \n                strcpy(name_directory[i], recv_message.name);\n            } else {\n                send_message.type = 4;\n                send(i, &send_message, sizeof(struct message), 0);\n                close(i);\n                FD_CLR(i, master);\n                return;\n            }\n            \n        }\n        for (j = 0; j <= fdmax; j++)\n        {\n            \n            if (FD_ISSET(j, master))\n            {\n                if (j != sockfd && j != i)\n                {\n                    if (send(j, &send_message, sizeof(struct message), 0) == -1)\n                    {\n                        perror(\"send\");\n                    }\n                }\n            }\n        }\n\n        if (recv_message.type == 2)\n        {\n            printf(\"%s left the discussion\\n\", recv_message.name);\n        }\n        bzero(recv_buf, BUFSIZE);\n    }\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <netdb.h>\n\n#define PORT 8080\n#define BUFSIZE 1024\n\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr);\n\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr);\n\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax);\n\nint main()\n{\n    fd_set master, read_fds;\n\n    int fdmax, i;\n    int sockfd = 0;\n\n    struct sockaddr_in server_addr, client_addr;\n\n    \n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n\n    server_set_up(&sockfd, &server_addr);\n\n    \n    FD_SET(sockfd, &master);\n\n    \n    fdmax = sockfd;\n\n    while (1)\n    {\n        \n        read_fds = master;\n\n        \n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n\n        \n        for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    \n                    \n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    \n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}\n\nvoid server_set_up(int *sockfd, struct sockaddr_in *server_addr)\n{\n    if ((*sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        perror(\"Socket\");\n        exit(1);\n    }\n\n    \n    server_addr->sin_family = AF_INET;\n    server_addr->sin_port = htons(PORT);\n    server_addr->sin_addr.s_addr = INADDR_ANY;\n\n    \n\n    \n    if (bind(*sockfd, (struct sockaddr *)server_addr, sizeof(struct sockaddr)) == -1)\n    {\n        perror(\"Unable to bind\");\n        exit(1);\n    }\n    printf(\"TCP Server Bound to Port: %d\\n\", PORT);\n    \n    if (listen(*sockfd, 10) == -1)\n    {\n        perror(\"listen\");\n        exit(1);\n    }\n    printf(\"TCP Server Waiting for Client Requests...\\n\");\n    fflush(stdout);\n}\n\n\nvoid connection_accept(fd_set *master, int *fdmax, int sockfd, struct sockaddr_in *client_addr)\n{\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n    int newsockfd;\n\n    if ((newsockfd = accept(sockfd, (struct sockaddr *)client_addr, &addrlen)) == -1)\n    {\n        perror(\"accept\");\n        exit(1);\n    } \n    else \n    {\n        \n        FD_SET(newsockfd, master);\n        \n        if (newsockfd > *fdmax)\n            *fdmax = newsockfd;\n        printf(\"New connection at %s : %d \\n\", inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port));\n    }\n}\n\nvoid send_recv(int i, fd_set *master, int sockfd, int fdmax) \n{\n    int recv_size, j;\n    char recv_buf[BUFSIZE], buf[BUFSIZE];\n    if ((recv_size = recv(i, recv_buf, BUFSIZE, 0)) <= 0)\n    {\n        if (recv_size == 0)\n            printf(\"Socket with FD: %d Hung Up\\n\", i);\n        else\n            perror(\"recv\");\n\n        \n        \n        close(i);\n        FD_CLR(i, master);\n    }\n    else\n    {\n        for (j = 0; j <= fdmax; j++)\n        {\n            \n            if (FD_ISSET(j, master))\n            {\n                if (j != sockfd && j != i)\n                {\n                    if (send(j, recv_buf, recv_size, 0) == -1)\n                    {\n                        perror(\"send\");\n                    }\n                }\n            }\n        }\n        printf(\"%s\\n\", recv_buf);\n        bzero(recv_buf, BUFSIZE);\n    }\n}"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <string.h>\n#include <unistd.h>     \n\n\n\n#include <sys\/types.h>  \n#include <sys\/socket.h> \n\n#include <netinet\/in.h> \n#include <arpa\/inet.h>   \n\n#include <pthread.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n#define SERVE_BACKLOG 3\n\n#define MAX_THREADS 100\n\n\nint sockets[MAX_THREADS]={0};\n\nvoid* communication(void* new_socket);\n\n\nint main(int argc, char const *argv[]) \n{ \n    int server_fd, new_socket, n; \n    struct sockaddr_in server_address, client_address; \n    char buffer[BUFFER_SIZE] = {0}; \n    \n    \n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) \n    { \n        perror(\"socket failed\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"TCP Socket Created!\\n\");\n\n    \n    \n    server_address.sin_family = AF_INET; \n    server_address.sin_addr.s_addr = INADDR_ANY; \n    server_address.sin_port = htons( PORT ); \n    \n    \n    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) \n    { \n        perror(\"bind failed\"); \n        exit(EXIT_FAILURE); \n    }\n    printf(\"Socket bound to 0.0.0.0: 8080\\n\");\n\n    \n    if(listen(server_fd, SERVE_BACKLOG) < 0) \n    { \n        perror(\"listen\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"Listening on Port: 8080\\n\");\n    int i = 0;\n    while(1) {\n        \n        \n        int addrlen = sizeof(client_address); \n        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) \n        { \n            perror(\"accept\"); \n            exit(EXIT_FAILURE); \n        } \n        \n        \n        \n        \n        printf(\"Connected to %s:%d\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n\n        pthread_t t;\n        int* pclient = malloc(sizeof(int));\n        *pclient = new_socket;\n        sockets[i++] = new_socket;\n        \n        \n\n        pthread_create(&t, NULL, communication, pclient);\n\n    }\n    \n    close(server_fd);\n    printf(\"Server Closed.\\n\");\n    return 0; \n} \n\nvoid* broadcast(char* buffer, int socketfd) {\n    for(int i = 0; i<50; i++) {\n        if(sockets[i]!=0) {\n            char name[5] = \"Name:\";\n            strcat(name, buffer);\n            send(sockets[i], name, strlen(name) , 0);\n        } else {\n            break;\n        }\n    }\n}\n\nvoid* communication(void* pclient) {\n    int new_socket = *((int*)pclient);\n    free(pclient);\n    int n;\n    char buffer[BUFFER_SIZE] = {0}; \n    while(1) {\n        bzero(buffer, BUFFER_SIZE);\n        n = recv( new_socket , buffer, BUFFER_SIZE, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        printf(\"Client: %s\\n\", buffer);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            printf(\"Client with Socketfd: %d disconnected!\\n\", new_socket);\n            bzero(buffer, BUFFER_SIZE);\n            return NULL;\n        }\n        \n        \n        \n        \n        \n        \n        \n        send(new_socket , buffer , strlen(buffer) , 0); \n    }\n    return NULL;\n}\n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <stdlib.h> \n#include <string.h>\n#include <unistd.h>     \n\n\n\n#include <sys\/types.h>  \n#include <sys\/socket.h> \n\n#include <netinet\/in.h> \n#include<arpa\/inet.h>   \n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n#define SERVE_BACKLOG 3\n\nvoid communication(int new_socket);\n\n\nint main(int argc, char const *argv[]) \n{ \n    int server_fd, new_socket, n; \n    struct sockaddr_in server_address, client_address; \n    char buffer[BUFFER_SIZE] = {0}; \n    \n    \n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) \n    { \n        perror(\"socket failed\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"TCP Socket Created!\\n\");\n\n    \n    \n    server_address.sin_family = AF_INET; \n    server_address.sin_addr.s_addr = INADDR_ANY; \n    server_address.sin_port = htons( PORT ); \n    \n    \n    if (bind(server_fd, (struct sockaddr *)&server_address, sizeof(server_address))<0) \n    { \n        perror(\"bind failed\"); \n        exit(EXIT_FAILURE); \n    }\n    printf(\"Socket bound to 0.0.0.0: 8080\\n\");\n\n    \n    if(listen(server_fd, SERVE_BACKLOG) < 0) \n    { \n        perror(\"listen\"); \n        exit(EXIT_FAILURE); \n    } \n    printf(\"Listening on Port: 8080\\n\");\n\n    while(1) {\n        \n        \n        int addrlen = sizeof(client_address); \n        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t*)&addrlen))<0) \n        { \n            perror(\"accept\"); \n            exit(EXIT_FAILURE); \n        } \n        \n        \n        \n        \n        printf(\"Connected to %s:%d\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n\n        \n        communication(new_socket);\n\n    }\n    \n    close(server_fd);\n    printf(\"Server Closed.\\n\");\n    return 0; \n} \n\nvoid communication(int new_socket) {\n    int n;\n    char buffer[BUFFER_SIZE] = {0}; \n    while(1) {\n        bzero(buffer, BUFFER_SIZE);\n        n = recv( new_socket , buffer, BUFFER_SIZE, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        printf(\"Client: %s\\n\", buffer);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            printf(\"Client with Socketfd: %d disconnected!\\n\", new_socket);\n            bzero(buffer, BUFFER_SIZE);\n            return;\n        }\n        bzero(buffer, BUFFER_SIZE);\n        printf(\"Enter Server's Message:\");\n        fgets(buffer, BUFFER_SIZE, stdin);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            close(new_socket);\n            break;\n        }\n        send(new_socket , buffer , strlen(buffer) , 0 ); \n    }\n}\n\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>   \n#include<string.h>  \n#include<stdlib.h>  \n#include<arpa\/inet.h>\n#include<sys\/socket.h>\n\n#include <unistd.h> \n\n#define BUFLEN 512  \n#define PORT 8888   \n\nvoid error(char *s)\n{\n    perror(s);\n    exit(1);\n}\n\n\n\n\nint main(void)\n{\n    struct sockaddr_in si_server, si_client;\n    \n    int socket_udp, i, slen = sizeof(si_client) , recv_len;\n    char buf[BUFLEN];\n    \n    \n    if ((socket_udp=socket(AF_INET, SOCK_DGRAM, 0)) == -1)\n    {\n        error(\"socket\");\n    }\n    printf(\"UDP Socket created!\\n\");\n\n    \n    memset((char *) &si_server, 0, sizeof(si_server));\n    \n    \n    si_server.sin_family = AF_INET;\n    si_server.sin_port = htons(PORT);\n    si_server.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    \n    if( bind(socket_udp , (struct sockaddr*)&si_server, sizeof(si_server) ) == -1)\n    {\n        close(socket_udp);\n        error(\"bind\");\n    }\n    printf(\"Socket bound to 0.0.0.0: 8888\\n\");\n    \n    while(1)\n    {\n        printf(\"Waiting for data...\\n\");\n        fflush(stdout);\n        bzero(buf, BUFLEN);\n\n        \n        \n        if ((recv_len = recvfrom(socket_udp, buf, BUFLEN, MSG_WAITALL, (struct sockaddr *) &si_client, &slen)) == -1)\n        {\n            error(\"recvfrom()\");\n        }\n        \n        \n        printf(\"\\n--------- DATA PACKET ------------------\\n\");\n        printf(\"Received Data Packet from %s:%d\\n\", inet_ntoa(si_client.sin_addr), ntohs(si_client.sin_port));\n        printf(\"Data: %s\\n\" , buf);\n        printf(\"----------------------------------------\\n\\n\");\n        \n        \n        if (sendto(socket_udp, buf, recv_len, 0, (struct sockaddr*) &si_client, slen) == -1)\n        {\n            error(\"sendto()\");\n        }\n        \n        bzero(buf, BUFLEN);\n    }\n\n    close(socket_udp);\n    return 0;\n}"}
{"target":"gokulsreekumar","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <netdb.h>\n\n#define PORT \"8888\"   \n\n\nvoid *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}\n\nint main(void)\n{\n    fd_set master;    \n    fd_set read_fds;  \n    int fdmax;        \n\n    int listener;     \n    int newfd;        \n    struct sockaddr_storage remoteaddr; \n    socklen_t addrlen;\n\n    char buf[256];    \n    int nbytes;\n\n    char remoteIP[INET6_ADDRSTRLEN];\n\n    int yes=1;        \n    int i, j, rv;\n\n    struct addrinfo hints, *ai, *p;\n\n    FD_ZERO(&master);    \n    FD_ZERO(&read_fds);\n\n    \n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n    if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {\n        fprintf(stderr, \"selectserver: %s\\n\", gai_strerror(rv));\n        exit(1);\n    }\n\n    for(p = ai; p != NULL; p = p->ai_next) {\n        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n        if (listener < 0) {\n            continue;\n        }\n\n        \n        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n\n        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {\n            close(listener);\n            continue;\n        }\n\n        break;\n    }\n\n    \n    if (p == NULL) {\n        fprintf(stderr, \"selectserver: failed to bind\\n\");\n        exit(2);\n    }\n\n    freeaddrinfo(ai); \n\n    \n    if (listen(listener, 10) == -1) {\n        perror(\"listen\");\n        exit(3);\n    }\n\n    \n    FD_SET(listener, &master);\n\n    \n    fdmax = listener; \n\n    \n    for(;;) {\n        read_fds = master; \n        if (select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {\n            perror(\"select\");\n            exit(4);\n        }\n\n        \n        for(i = 0; i <= fdmax; i++) {\n            if (FD_ISSET(i, &read_fds)) { \n                if (i == listener) {\n                    \n                    addrlen = sizeof remoteaddr;\n                    newfd = accept(listener,\n                        (struct sockaddr *)&remoteaddr,\n                        &addrlen);\n\n                    if (newfd == -1) {\n                        perror(\"accept\");\n                    } else {\n                        FD_SET(newfd, &master); \n                        if (newfd > fdmax) {    \n                            fdmax = newfd;\n                        }\n                        printf(\"selectserver: new connection from %s on \"\n                            \"socket %d\\n\",\n                            inet_ntop(remoteaddr.ss_family,\n                                get_in_addr((struct sockaddr*)&remoteaddr),\n                                remoteIP, INET6_ADDRSTRLEN),\n                            newfd);\n                    }\n                } else {\n                    \n                    if ((nbytes = recv(i, buf, sizeof buf, 0)) <= 0) {\n                        \n                        if (nbytes == 0) {\n                            \n                            printf(\"selectserver: socket %d hung up\\n\", i);\n                        } else {\n                            perror(\"recv\");\n                        }\n                        close(i); \n                        FD_CLR(i, &master); \n                    } else {\n                        \n                        for(j = 0; j <= fdmax; j++) {\n                            \n                            if (FD_ISSET(j, &master)) {\n                                \n                                if (j != listener && j != i) {\n                                    if (send(j, buf, nbytes, 0) == -1) {\n                                        perror(\"send\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } \n            } \n        } \n    } \n\n    return 0;\n}\n"}
{"target":"gokulsreekumar","func":"\n#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <string.h> \n#include <sys\/types.h> \n#include <sys\/socket.h> \n#include <arpa\/inet.h> \n#include <netinet\/in.h> \n\n#define PORT     8089 \n#define MAXLINE 1024 \n\n\nint main() { \n    int sockfd; \n    char buffer[MAXLINE]; \n    char *hello = \"Hello from server\"; \n    struct sockaddr_in servaddr, cliaddr; \n    \n    \n    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { \n        perror(\"socket creation failed\"); \n        exit(EXIT_FAILURE); \n    } \n    \n    memset(&servaddr, 0, sizeof(servaddr)); \n    memset(&cliaddr, 0, sizeof(cliaddr)); \n    \n    \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = INADDR_ANY; \n    servaddr.sin_port = htons(PORT); \n    \n    \n    if ( bind(sockfd, (const struct sockaddr *)&servaddr, \n            sizeof(servaddr)) < 0 ) \n    { \n        perror(\"bind failed\"); \n        exit(EXIT_FAILURE); \n    } \n    \n    int len, n; \n\n    len = sizeof(cliaddr); \n\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, \n                MSG_WAITALL, ( struct sockaddr *) &cliaddr, \n                &len); \n    buffer[n] = '\\0'; \n    printf(\"Client : %s\\n\", buffer); \n    sendto(sockfd, (const char *)hello, strlen(hello), \n        MSG_CONFIRM, (const struct sockaddr *) &cliaddr, \n            len); \n    printf(\"Hello message sent.\\n\"); \n    \n    return 0; \n} \n"}
{"target":"gokulsreekumar","func":"\n#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <string.h> \n#include <sys\/types.h> \n#include <sys\/socket.h> \n#include <arpa\/inet.h> \n#include <netinet\/in.h> \n\n#define PORT     8089 \n#define MAXLINE 1024 \n\n\nint main() { \n    int sockfd; \n    char buffer[MAXLINE]; \n    char *hello = \"Hello from server\"; \n    struct sockaddr_in servaddr, cliaddr; \n    \n    \n    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { \n        perror(\"socket creation failed\"); \n        exit(EXIT_FAILURE); \n    } \n    \n    memset(&servaddr, 0, sizeof(servaddr)); \n    memset(&cliaddr, 0, sizeof(cliaddr)); \n    \n    \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = INADDR_ANY; \n    servaddr.sin_port = htons(PORT); \n    \n    \n    if ( bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0 ) \n    { \n        perror(\"bind failed\"); \n        exit(EXIT_FAILURE); \n    } \n    \n    int len, n; \n\n    len = sizeof(cliaddr); \n\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, ( struct sockaddr *) &cliaddr, &len); \n    buffer[n] = '\\0'; \n    printf(\"Client : %s\\n\", buffer); \n    sendto(sockfd, (const char *)hello, strlen(hello),MSG_CONFIRM, (const struct sockaddr *) &cliaddr, \n            len); \n    printf(\"Hello message sent.\\n\"); \n    \n    return 0; \n} \n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\nFILE *F1;\nFILE *F2;\nint* read(int n)\n{\n      int *arr;\n      arr = (int*) malloc(n* sizeof(int));\n      int i;\n      for(i=0;i<n;i++)\n       fscanf(F1,\"%d\",&arr[i]);\n      return arr;\n}\nvoid display(int a[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {fprintf(F2,\"%d \",a[i]);\n   if(i==(n-1))\n    fprintf(F2,\"\\n\");}\n}\nint search(int A[],int n,int k)\n{\n int i;\n\n for(i=0;i<n;i++)\n   if(A[i]==k)\n     return i;\n   return -1;\n}\nint main(int argc,char *argv[])\n  {     char sel;\n        int n,x,k;\n        int *arr;\n        F1=fopen(argv[1],\"r\");\n        F2=fopen(argv[2],\"w\");\n        if(F1==NULL)\n         printf(\"Cant open file\");\n        else\n          {\n           while(1)\n           {\n             fscanf(F1,\"%ch\",&sel);\n             if(sel=='r')\n             {\n               fscanf(F1,\" %d\",&n);\n               arr= read(n);\n             }\n            else if(sel=='d')\n             {\n               display(arr,n);\n             }\n             else if(sel=='s')\n             {\n              fscanf(F1,\"%d\",&k);\n              x=search(arr,n,k);\n              fprintf(F2,\"%d\\n\",x);\n             }\n             else if(sel=='t')\n               break;\n           }\n\n         }\n   fclose(F1);\n   fclose(F2);\n\n  }\n   \n\n\n\n\n\n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\nFILE* F1;\nFILE* F2;\n\nint search_shift(int a[],int n)\n{\n    int str = 0;\n    int end = n-1;\n    int mid = (end + str)\/2;\n    if(a[n-1] > a[str])\n    {\n        return 0;\n    }\n    while(end>str)\n    {\n        mid = (end+str)\/2;\n        if(a[mid-1]> a[mid]){\n            return mid;\n        }\n        else if(a[mid-1]<=a[mid] && a[mid]<=a[end])\n        {\n            end = mid;\n        }\n        else if(a[mid - 1]<= a[mid] && a[mid]>=a[end])\n        {\n            str = mid;\n        }\n    }\n    return 0;\n        \n}\nint* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}\n\nvoid display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\nint main(int argc, char* argv[])\n{\n    int search_shift(int a[], int);\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c\",&s);\n        if(s == 'r')\n        {\n        fscanf(F1, \"%d\", &num);\n                size = num;\n                arr = read(num);\n\n        }\n        else if(s == 's')\n        {\n                int p = search_shift(arr, size);\n                fprintf(F2,\"%d\\n\", p);\n        }\n\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n    else if(s == 't')\n        return 0;\n    }\n    fclose(F1);\n    fclose(F2);\n}\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\nFILE* F1;\nFILE* F2;\nint* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}\nvoid display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\n\nint binary_search(int a[], int str, int end, int k)\n{\n    int mid = (end+str)\/2;\n    while(str<=end)\n    {\n        mid = (end+str)\/2;\n        if(a[mid] == k)\n            return mid;\n        else if(a[mid]>k)\n        {\n            end = mid-1;\n        }\n        else if(a[mid]<k)\n        {\n            str = mid+1;\n        }\n    }\n    return -1;\n\n}\n\nint binary_search_rev(int a[], int str, int end, int k)\n{\n        int mid = (end+str)\/2;\n        while(str<=end)\n        {\n                mid = (end+str)\/2;\n                if(a[mid] == k)\n                        return mid;\n                else if(a[mid]>k)\n                {\n                        str = mid+1;\n                }\n                else if(a[mid]<k)\n                {\n                        end = mid-1;\n                }\n        }\n        return -1;\n\n}\nint binary_bitonic(int arr[],int str, int end ) \n{ \n    int mid; \n      \n    mid = (str + end) \/ 2; \n    if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid + 1]) \n    { \n        return mid; \n    } \n      \n    else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) \n    { \n        binary_bitonic(arr, mid , end); \n    } \n  \n    else if(arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) \n    { \n        binary_bitonic(arr, str, mid); \n    } \n} \n\nint search(int a[], int k, int size)\n{\n    \n    int str = 0; \n    int end = size - 1;\n    int b = binary_bitonic(a, str, end);\n    \n    int bs = binary_search(a, 0, b, k);\n    if(bs!=-1)\n    {\n        printf(\"search succesful : normal\\n\");  \n        return bs;\n    }\n    else if (bs == -1)\n    {\n        int rbs = binary_search_rev(a, b, end, k);\n            return rbs;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n\n        }\n        else if(s == 's')\n        {\n                int p = search(arr, num, size);\n                fprintf(F2,\"%d\\n\", p);\n        }\n\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n    fclose(F1);\n    fclose(F2);\n}\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\n\n\n\nFILE* F1;\nFILE* F2;\n\n\nint* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}\n\n\n\nvoid display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\n\nvoid sort(int a[], int n)\n{\n    int i = 1;\n    int shift, cmp;\n    for(i = 1; i<n; i++)\n    {\n        int key = a[i];\n        int j = i-1;\n        cmp = 0;shift = 0;\n        while(j>=0 && a[j]<key)\n        {\n            a[j+1]= a[j];\n            j = j-1;\n            cmp++;\n            shift++;\n        }\n            a[j+1] = key;\n            if(j != -1)\n            {\n                cmp++;\n            }\n            if( j != i-1)\n            {\n                shift++;\n            }\n            fprintf(F2, \"%d %d\\n\", cmp, shift);\n            display(a, n);\n            fprintf(F2, \"\\n\");\n\n    }\n\n}\n\nint main(int argc, char* argv[])\n{\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n\n        }\n        else if(s == 's')\n        {\n                sort(arr, size);\n        }\n\n        else if(s == 'd')\n        {\n                display(arr, num);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n        fclose(F1);\n        fclose(F2);\n    \n}\n\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\n\nFILE* F1;\nFILE* F2;\n\nint flag =0;\n\nint a[200];\nint* read(int n)\n{\n        flag++;\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n\n}\n\n\n\nvoid display(int arr2[], int n)\n{   \n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\nfloat findMedian(int X[],int Y[],int m,int n)\n{\n    float median;\n    int s = sizeof(int);\n    \n    int j=0; int k =0;\n    int i=0;\n\n    while(i<m+n)\n    {\n        if(j<m && k<n)\n        {\n            if(X[j]<=Y[k])\n            {\n                a[i] = X[j];\n                j++;\n            }\n            else\n            {\n                a[i] = Y[k];\n                k++;\n            }\n            i++;\n        }\n    \n        else if(j == m)\n        {\n            a[i]=Y[k];\n            k++;\n            i++;\n        }\n        else if(k == n)\n        {\n            a[i]=X[j];\n            j++;\n            i++;\n        }\n\n    }\n\n    if((m+n)%2 != 0)\n    {\n        median = a[(m+n)\/2];\n        return median;\n    }\n    else\n    {\n        median = (a[(m+n-1)\/2]+a[(m+n-1)\/2+1])\/2.0;\n        return median;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    \n        int num; char s;int size1, size2;\n        int* arr1;\n        int* arr2;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n            if(flag%2==0)\n            {\n                size1 = num;\n                arr1 = read(num);\n            }\n            else if(flag%2==1)\n            {\n                size2 = num;\n                arr2 = read(num);\n            }\n        }\n        else if(s == 'f')\n        {\n                float p = findMedian(arr1,arr2,size1,size2);\n        if((size1+size2)%2 == 0)\n        {\n                fprintf(F2,\"%0.2f\\n\", p);\n        }\n        else\n            fprintf(F2, \"%d\\n\", (int)p);\n        }\n\n        else if(s == 'd')\n        {\n        float med = findMedian(arr1, arr2, size1, size2);\n                display(a, size1+size2);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n        fclose(F1);\n        fclose(F2);\n\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include<stdlib.h>\n\nFILE* F1;\nFILE* F2;\nint* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}\n\n\n\nvoid display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\n\nvoid swap(int *a, int *b) \n{ \n    int temp = *a; \n    *a = *b; \n    *b = temp; \n} \n  \nvoid bubbleSort(int arr[], int n) \n{ \n   int i, j; \n   for (i = 0; i < n-1; i++)       \n       for (j = 0; j < n-i-1; j++)\n    { \n       if(arr[j]>=0 && arr[j+1]>=0)\n       {\n           if (arr[j] > arr[j+1]) \n              swap(&arr[j], &arr[j+1]);\n       } \n       else if(arr[j]>0 && arr[j+1]<0)\n       {\n          for(int m = 0; m<n-j; m++)\n          {\n            if(arr[j+m]<arr[j] && arr[j+m]>=0)\n            {\n              swap(&arr[j+m], &arr[j]);\n              break;\n            }\n          }\n       }\n       else if(arr[j]<0)\n          continue;\n   }\n} \n\n\nint main(int argc, char* argv[]) \n{ \n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n\n        }\n        else if(s == 's')\n        {\n                bubbleSort(arr, size);\n        display(arr, size);\n        }\n\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n} \n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h> \nFILE* F1;\nFILE* F2;\nint* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}\n\n\n\nvoid display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n\n}\n\n\nint check_digit(int n)\n{\n    int count=0;\n    if(n==0)\n        return 1;\n    while(n>0)\n    {\n        n=n\/10;\n        count++;\n    }\n    return count;\n}\nint check_digit_array(int A[], int n)\n{\n    int s;\n    int num = check_digit(A[0]);\n    for(int i = 1; i<n; i++)\n    {\n        s = check_digit(A[i]);\n        if(s != num)\n            return 0;\n    }\n    return 1;\n}\n\n\nint getMax(int arr[], int n) {\n    int mx = arr[0];\n    int i;\n    for (i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n \nvoid countSort(int arr[], int n, int exp) {\n    int output[n]; \n    int i, count[10] = { 0 };\n    for (i = 0; i < n; i++)\n        count[(arr[i] \/ exp) % 10]++;\n \n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n \n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] \/ exp) % 10] - 1] = arr[i];\n        count[(arr[i] \/ exp) % 10]--;\n    }\n \n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n \nvoid radix_sort(int arr[], int n) {\n    int m = getMax(arr, n);\n \n    int exp;\n    for (exp = 1; m \/ exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}\n \nint main(int argc, char* argv[]) {\n    \n        int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n\n        }\n        else if(s == 's')\n        {\n            int nm1 = check_digit_array(arr, 6);\n            if(nm1 != 0)\n            {\n                radix_sort(arr, size);\n        display(arr, size);\n            }\n        }\n\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n    \n        return 0;\n\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\nFILE* F1;\nFILE* F2;\nvoid read(int A[], int n)\n{\n        int i;\n        for(i=0;i<n;i++)\n        {\n                fscanf(F1,\"%d\", &A[i]);\n        }\n}\nvoid display(int A[],int n)\n{\n        int i;\n        for(i=0;i<n;i++)\n        {\n                fprintf(F2,\"%d \",A[i]);\n        }\n        fprintf(F2,\"\\n\");\n}\nint merge_sort(int A[],int p,int r)\n{\n        static int flips=0;\n    int q = p + (r-p)\/2;\n    if((r-p+1)%2 == 0)\n        q = q + 1;\n    if(p<r)\n    {\n\n        for(int i=p;i<q;i++)\n            for(int j=q;j<=r;j++)\n            {\n                if(A[j]<A[i])\n                {\n                    flips++;\n                }\n            }\n        merge_sort(A,p,q-1);\n        merge_sort(A,q,r);\n    }\n    return flips;\n}\nint inversion(int A[],int n)\n{\n        int r = n-1;\n        int p=merge_sort(A,0,r);\n        return p;\n}\n\nint main(int argc, char* argv[])\n{\n        F1 = fopen(argv[1],\"r\");\n        F2 = fopen(argv[2],\"w\");\n        char s;\n        int num;\n        int size;\n        int* A;\n        while(1)\n        {\n                fscanf(F1,\"%c\",&s);\n                if(s=='r')\n                {\n                        fscanf(F1,\"%d\", &num);\n                        size=num;\n                        A=(int*)malloc(sizeof(int)*num);\n                        read(A,num);\n                }\n                else if(s=='i')\n                {\n                        int p=inversion(A,size);\n                        fprintf(F2,\"%d\\n\",p);\n                }\n                else if(s=='d')\n                {\n                        fscanf(F1,\"%d\", &num);\n                        display(A,num);\n                }\n                else if(s=='t')\n                        break;\n        }\n    return 0;\n}\n                                                                                                                                   \n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\nFILE *F1;\nFILE *F2;\n\nvoid read(int A[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n    fscanf(F1,\"%d\",&A[i]);\n}\n\nvoid checkSubset(int X[],int m,int Y[],int n)\n{\n    int i,j,flag=0;\n    for(i=0;i<n;i++)\n     {\n         for(j=0;j<m;j++)\n         {\n             if(Y[i]==X[j])\n              {\n                  flag++;\n                  break;\n              }\n         }  \n     }\n     if(flag==n)\n       fprintf(F2,\"true\");\n     else\n       fprintf(F2,\"false\");\n}\nint main(int argc,char *argv[])\n{\n    char s;\n    int m,n,x,p,k;\n    int *X,*Y;\n    int count=0;\n    F1=fopen(argv[1],\"r\");\n    F2=fopen(argv[2],\"w\");\n    if(F1==NULL)\n        printf(\"cant open file\");\n    else\n        {\n        while(1)\n         {\n            fscanf(F1,\"%c\",&s);\n            if(s=='r')\n                {\n                    count++;\n                    if(count%2!=0)\n                     { \n                         fscanf(F1,\" %d\",&m);\n                         X = (int*) malloc(m* sizeof(int));\n                         read(X,m);\n                     }\n                    else\n                     {\n                         fscanf(F1,\" %d\",&n);\n                         Y = (int*) malloc(n* sizeof(int));\n                         read(Y,n);\n                     }\n                 }    \n            else if(s=='c')\n                 {        \n                      checkSubset(X,m,Y,n);\n                 }\n            else if(s=='t')\n                break;\n            }\n\n         }\n    fclose(F1);\n    fclose(F2);\n\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\nFILE *F1;\nFILE *F2;\n\nstruct bucket\n{\n    int count;\n    int* value;\n};\n\n\nvoid read(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n   fscanf(F1,\"%d\",&A[i]);\n}\nvoid display(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {\n        fprintf(F2,\"%d \",A[i]);\n        if(i==(n-1))\n        fprintf(F2,\"\\n\");}\n}\nint findMax_digits(int a[],int n)\n{\n  int i,digits=0,num;\n  int max=0;\n  int level=1;\n  for(i=1;i<n;i++)\n   {\n     if(a[i]>a[max])\n       max=i;\n   }\n  num=a[max];\n  if(num==0)\n   return 0;\n  while(num>=level)\n   {\n     digits++;\n     level*=2;\n   }\n  return digits;\n}\nvoid form_binary(int a[],int n,int q,int bin[n][q])\n{\n\n  int i,j,num;\n  for(i=0;i<n;i++)\n   {\n    num=a[i];\n    j=q-1;\n    while(num>0)\n      {\n           bin[i][j]=num%2;\n           num\/=2;\n           j--;\n      }\n   }\n}\nvoid count_ones(int n,int q,int a[n][q],int one[])\n{\nint i,j;\n  for(i=0;i<n;i++)\n    for(j=0;j<q;j++)\n        {if(a[i][j]==1)\n         one[i]++;\n        }\n}\n\nvoid insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n }\nvoid bucketSort(int A[],int n)\n {  int i,j,k,flag=0;\n    int dig=0;\n    dig=findMax_digits(A,n);\n    int binarr[n][dig];\n    for (i = 0; i < n; i++)\n     for (j = 0; j < dig; j++)\n      binarr[i][j]=0;\n    form_binary(A,n,dig,binarr);\n    int one[n];\n    for (i = 0; i < n; i++)\n     {one[i]=0;\n      }\n    count_ones(n,dig,binarr,one);\n    int max=0;\n    for(i=1;i<n;i++)\n     {\n       if(one[i]>one[max])\n       max=i;\n     }\n    int bucket_nos;\n     bucket_nos=one[max]+1;\n\n    struct bucket buckets[bucket_nos];\n    for (i = 0; i <= bucket_nos; i++)\n    {\n        buckets[i].count = 0;\n        buckets[i].value = (int*)malloc(sizeof(int) * n);\n    }\n\n    for (i = 0; i < n; i++)\n      buckets[one[i]].value[buckets[one[i]].count++] = A[i];\n    for (k = 0, i = 0; i <= bucket_nos; i++)\n    {\n        if(buckets[i].count!=0)\n          insertionSort(buckets[i].value,buckets[i].count);\n        for (j = 0; j < buckets[i].count; j++)\n                    A[k + j] = buckets[i].value[j];\n        k+=buckets[i].count;\n    }\n\n        for(i=0;i<= bucket_nos;i++)\n        {\n                if(buckets[i].count!=0)\n                display(buckets[i].value,buckets[i].count);\n\n        }\n}\n\nint main(int argc,char *argv[])\n  {     char ch;\n        int n,x,p;\n        int *arr;\n        F1=fopen(argv[1],\"r\");\n        F2=fopen(argv[2],\"w\");\n        if(F1==NULL)\n         printf(\"cant open file\");\n        else\n          {\n          while(1)\n           {\n             fscanf(F1,\"%c\",&ch);\n             if(ch=='r')\n             {\n               fscanf(F1,\" %d\",&n);\n               arr= (int*) malloc(n* sizeof(int));\n               read(arr,n);\n             }\n            else if(ch=='d')\n             {\n               fscanf(F1,\"%d\",&p);\n               display(arr,n);\n             }\n             else if(ch=='s')\n             {\n              bucketSort(arr,n);\n             }\n             else if(ch=='t')\n               break;\n           }\n\n         }\n   fclose(F1);\n   fclose(F2);\n\n}\n                       \n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct stack{\n    int top;\n    int cap;\n    char* A;\n};\n\nint StackOverflow(struct stack* stk)\n{\n    if(stk->top==stk->cap-1)\n        return 1;\n    else \n        return 0;\n}\nint StackEmpty(struct stack* stk)\n{\n    if(stk->top==-1)\n        return 1;\n    else\n        return 0;\n}\nvoid push(struct stack* stk, char elem){\n    if(StackOverflow(stk))\n    {\n        printf(\"%d\\n\", 999);\n        return;\n    }\n    stk->top++;\n    stk->A[stk->top]=elem;\n        \n};\nchar pop(struct stack* stk){\n    if(StackEmpty(stk))\n    {\n        printf(\"%d\\n\", -1);\n        return('b');\n    }\n    stk->top--;\n    return(stk->A[stk->top+1]);\n};\n\n\nint isMatchingPair(char character1, char character2) \n{ \n   if (character1 == '(' && character2 == ')') \n     return 1; \n   else if (character1 == '{' && character2 == '}') \n     return 1; \n   else if (character1 == '[' && character2 == ']') \n     return 1; \n   else\n     return 0; \n} \n\n\nint checkParantheses(char* exp,struct stack* stk)\n{\n    int i;char popped;\n    for(i=0;i<stk->cap;i++)\n    {\n        if(exp[i]=='('||exp[i]=='{'||exp[i]=='[')\n        {\n            push(stk,exp[i]);\n        }\n        else if(exp[i]==')'||exp[i]=='}'||exp[i]==']')\n        {\n            popped=pop(stk);\n            if(!(isMatchingPair(popped,exp[i])))\n            {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main()\n{\n\n    char sel;\n    int p;\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\"); \n    fp2=fopen(\"output.txt\",\"w\");    \n    char exp[10000];        \n    while(1)    \n    {\n        int i=0;\n        fscanf(fp1,\"%c\",&sel);\n        if(sel=='e')\n        {\n            fgetc(fp1);\n            fscanf(fp1,\"%[^\\n]\",exp);\n            i=strlen(exp);\n            fgetc(fp1);\n            struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n            stk->A=(char*)malloc(i);\n            stk->top=-1;\n            stk->cap=i;\n            \n            p=checkParantheses(exp,stk);\n            if(p==0)\n            {\n                fprintf(fp2, \"NO\\n\");\n            }\n            else\n                fprintf(fp2,\"YES\\n\");\n        }\n        else if(sel=='s')\n            break;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n \nstruct Stack \n{ \n    int top; \n    unsigned capacity; \n    int* array; \n}; \n  \nstruct Stack* createStack( unsigned capacity ) \n{ \n    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack)); \n  \n    if (!stack)  \n        return NULL; \n  \n    stack->top = -1; \n    stack->capacity = capacity; \n  \n    stack->array = (int*) malloc(stack->capacity * sizeof(int)); \n  \n    if (!stack->array) \n        return NULL; \n    return stack; \n} \nint isEmpty(struct Stack* stack) \n{ \n    return stack->top == -1 ; \n} \nchar peek(struct Stack* stack) \n{ \n    return stack->array[stack->top]; \n} \nchar pop(struct Stack* stack) \n{ \n    if (!isEmpty(stack)) \n        return stack->array[stack->top--] ; \n    return '$'; \n} \nvoid push(struct Stack* stack, char op) \n{ \n    stack->array[++stack->top] = op; \n} \n  \nint isOperand(char ch) \n{ \n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); \n} \n  \nint Prec(char ch) \n{ \n    switch (ch) \n    { \n    case '+': \n    case '-': \n        return 1; \n  \n    case '*': \n    case '\/': \n        return 2; \n  \n    case '^': \n        return 3; \n    } \n    return -1; \n} \n  \nvoid infixToPostfix(char* exp) \n{ \n    int i, k; \n  \n    struct Stack* stack = createStack(strlen(exp));  \n\n    for (i = 0, k = -1; exp[i]; ++i) \n    { \n \n        if (isOperand(exp[i])) \n            exp[++k] = exp[i]; \n          \n        else if (exp[i] == '(') \n            push(stack, exp[i]); \n          \n\n        else if (exp[i] == ')') \n        { \n            while (!isEmpty(stack) && peek(stack) != '(') \n                exp[++k] = pop(stack); \n            if (!isEmpty(stack) && peek(stack) != '(') \n                return;             \n            else\n                pop(stack); \n        } \n        else\n        { \n            while (!isEmpty(stack) && Prec(exp[i]) <= Prec(peek(stack))) \n                exp[++k] = pop(stack); \n            push(stack, exp[i]); \n        } \n  \n    } \n\n    while (!isEmpty(stack)) \n        exp[++k] = pop(stack); \n  \n    exp[++k] = '\\0'; \n} \n\nint main(int argc,char *argv[])\n{\n    char ch,temp;\n    char exp[10000];\n    FILE *fp1;\n    FILE *fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    while(1)\n         {\n            fscanf(fp1,\"%c\",&ch);\n            if(ch=='e')\n            {\n                fgetc(fp1);\n                fscanf(fp1,\"%[^\\n]\",exp);\n                infixToPostfix(exp);\n                fprintf(fp2,\"%s\\n\",exp);\n            }\n            else if(ch=='s')\n                break;\n\n        }\n\n    fclose(fp1);\n    fclose(fp2);\n    return 0;\n}\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\nstruct stack{\n        int stk[50];\n        int top;\n        };\n\nint evaluatepostfix(int a,int b, char c,FILE* F2)\n{\nint res=1;\nif(c=='+')\n    return a+b;\nif(c=='-')\n        return b-a;\nif(c=='*')\n        return a*b;\nif(c=='\/')\n        return b\/a;\nif(c=='^')\n{\nfor(int i=1;i<=a;i++)\n{\nres*=b;\n}\nreturn res;\n}\nprintf(\"invalid operator\");\nfprintf(F2,\"-999\");\nexit(0);\n}\nint pop(struct stack* A)\n{\nint q;\nq=A->stk[A->top];\nreturn q;\n}\n\nstruct stack* push(struct stack* A,int elt)\n{\n\n                A->top=A->top+1;\n                A->stk[A->top]=elt;\n        return A;\n}\n\nint main()\n{       FILE* F1;\n        FILE *F2;\n        F1 = fopen(\"input.txt\",\"r\");\n        F2 = fopen(\"output.txt\",\"w\");\n        if(F1 == NULL)\n        {\n                printf(\"input file not found\");\n                exit(0);\n        }\n\n\n          int flag=-1;;\n      char a,check;\n      char c;\n          int p,size,elt,q,t1,t2,res;\n          struct stack AA;\n          struct stack *A=&AA;\n          A->top=-1;\n      \n        while(1)\n        {\n                fscanf(F1,\"%c\",&a);\n               if(a=='e' || a=='s');\n                else\n               {\n                        printf(\"invalid char input \");\n                        fprintf(F2,\"-999\");\n                        exit(0);\n                }\n                if(a=='e')\n                {  \n                fscanf(F1,\" \");\n        while(1)\n        {\n        fscanf(F1,\"%c\",&check);\n        if(check=='e' || check =='s' || check=='\\n')\n        {    fseek(F1,-1,1);\n            break;}\n        else\n            fseek(F1,-1,1);\n        \n\n        t2=ftell(F1);\n        if(fscanf(F1,\"%d\",&elt));\n        else\n        {\n        flag=1;  \n        \n        t1=ftell(F1);\n        if(t1!=t2)\n        {\n        fseek(F1,-1,1);\n        }\n        fscanf(F1,\"%c\",&c);\n        }\n    \n    \n        if(flag==-1)\n        {\n        A=push(A,elt);\n        }\n\n        if(flag==1)\n        {   int e1=pop(A);\n            A->top=A->top-1;\n            int e2=pop(A);\n             A->top=A->top-1;\n            res=evaluatepostfix(e1,e2,c,F2);\n            A=push(A,res);\n        }\n        flag=-1;\n        fscanf(F1,\" \");\n        }\n        fprintf(F2,\"%d\\n\",A->stk[A->top]);\n        A->top=-1;\n        } \n                if(a=='s')\n                        exit(0);\n                fscanf(F1,\"\\n\");\n        }\n        return 0;\n}\n\n\n\n\n\n"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nstruct Node{\n    int data;\n    struct Node* next;\n};\n\ntypedef struct Node* node;\n\nnode createNode()\n{\n    node t=(node)malloc(sizeof(struct Node));\n    if(t==NULL)\n        {\n            printf(\"Memory not allocated for node\");\n            exit(0);\n        }\n    t->next=NULL;\n    return t;\n}\n\n\nvoid enqueue(struct Node** head_ref, int new_data) \n{ \n    struct Node* new_node = createNode();\n    struct Node *last = *head_ref;\n    new_node->data  = new_data; \n\n    if (*head_ref == NULL) \n    { \n       *head_ref = new_node; \n       return; \n    }   \n    while (last->next != NULL) \n        last = last->next; \n    last->next = new_node; \n    return;     \n}\n\nint find_size(node head)\n{\n    node p;\n    int n=0;\n    p=head;\n    while(p!=NULL)\n    {\n        n++;\n        p=p->next;\n    }\n    return n;\n}\n\nvoid print(node head,int n,FILE *fp2)\n{\n\n  node temp=head;\n  int count=0;\n  node p=head;\n  if(head==NULL)\n    {\n      fprintf(fp2,\"-1\\n\");\n      return;\n    }\n  int size=find_size(head);\n\n  if(n==0 || n>size)\n  {\n    while(temp!=NULL)\n   {\n    fprintf(fp2,\"%d\",temp->data);\n    temp=temp->next;\n    if(temp==NULL)\n    {\n      if(n>size)\n        fprintf(fp2,\" END\");\n      fprintf(fp2,\"\\n\");\n    }\n    else\n      fprintf(fp2,\" \");\n   }\n   return;\n  }\n  if(n>0 && n<=size)\n   {\n    while(count<n)\n    {\n      fprintf(fp2,\"%d\",p->data);\n      p=p->next;\n      count++;\n      if(count==n)\n        fprintf(fp2,\"\\n\");\n      else \n        fprintf(fp2,\" \");\n    }   \n   }\n}\n\n\nint dequeue(node* head)\n{\n  node p;\n  int dequeued;\n  if(*head==NULL)\n      return -1;\n  dequeued=(*head)->data;\n  p=(*head)->next;\n  free(*head);\n  *head=p;\n  return dequeued;\n}\n\nint main()\n{\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    node Q=NULL;\n    char sel;\n    int elem,num,temp=0;\n    while(1)\n    {\n        fscanf(fp1,\"%c\",&sel);\n        if(sel=='e')\n        {\n            fscanf(fp1,\"%d\",&elem);\n            enqueue(&Q, elem);\n        }\n        else if(sel=='p')\n        {\n            fscanf(fp1,\"%d\",&num);\n            print(Q,num,fp2);\n        }\n        else if(sel=='d')\n        {\n            temp=dequeue(&Q);\n            fprintf(fp2,\"%d\\n\",temp);\n        }\n        else if(sel=='s')\n        {\n            break;\n        }\n    }\n    fclose(fp1);\n    fclose(fp2);\n}"}
{"target":"gokulsreekumar","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct stack{\n    int top;\n    int cap;\n    int* A;\n};\n\nint StackOverflow(struct stack* stk)\n{\n    if(stk->top==stk->cap-1)\n        return 1;\n    else \n        return 0;\n}\nint StackEmpty(struct stack* stk)\n{\n    if(stk->top==-1)\n        return 1;\n    else\n        return 0;\n}\nvoid push(struct stack* stk, int elem,FILE* fp2){\n    if(StackOverflow(stk))\n    {\n        fprintf(fp2, \"%d\\n\", 999);\n        return;\n    }\n    stk->top++;\n    stk->A[stk->top]=elem;\n        \n};\nvoid pop(struct stack* stk,FILE* fp2){\n    if(StackEmpty(stk))\n    {\n        fprintf(fp2, \"%d\\n\", -1);\n        return;\n    }\n    stk->top--;\n    fprintf(fp2,\"%d\\n\",stk->A[stk->top+1]);\n};\nvoid print(struct stack* stk,int n,FILE* fp2)\n{\n    int i;\n    int top1=stk->top;\n    if(StackEmpty(stk))\n    {\n        fprintf(fp2, \"%d\\n\",-1);\n        return;\n    }\n    if(n==0)\n    {\n        for(i=top1;i>=0;i--)\n        {\n            fprintf(fp2, \"%d \",stk->A[i]);\n        }\n        fprintf(fp2, \"\\n\");\n    }\n    else if(n>0)\n    {\n        if(n<=top1+1)\n        {\n            for(i=0;i<n;i++)\n                {\n                    fprintf(fp2, \"%d \", stk->A[top1-i]);\n                }\n                        fprintf(fp2, \"\\n\");\n        }\n        else if(n>top1+1)\n        {\n            for(i=top1;i>=0;i--)\n            {\n                fprintf(fp2, \"%d \",stk->A[i]);\n            }\n            fprintf(fp2, \"END\\n\");\n        }   \n    }\n}\nint main()\n{\n    int num;\n    char sel;\n    int n1; int capacity;\n\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n\n    fscanf(fp1,\"%d\",&capacity);\n    \n    struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n    stk->cap=capacity;\n    stk->top=-1;\n    stk->A=(int*)malloc(sizeof(int)*capacity);\n\n\n    while(1){\n    fscanf(fp1,\"%c\",&sel);\n    if(sel=='p')\n    {\n        fscanf(fp1,\"%d\",&n1);\n        push(stk,n1,fp2);\n    }\n    else if(sel=='t')\n    {\n        pop(stk,fp2);\n    }\n    else if(sel=='d')\n    {\n        fscanf(fp1,\"%d\",&num);\n        print(stk,num,fp2);\n    }\n    else if(sel=='s')\n    {\n        break;\n    }\n}\n}\n"}
{"target":"gokulsreekumar","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nstruct Queue\n{\n    int rear,front;\n    int size;\n    int *arr;\n};\n\ntypedef struct Queue queue;\n\nint isFull(queue Q)\n{\n    if( (Q.front == Q.rear + 1) || (Q.front == 0 && Q.rear == Q.size-1))\n        return 1;\n    return 0;\n}\nint isEmpty(queue Q)\n{\n    if(Q.front == -1)\n        return 1;\n    return 0;\n}\nint enqueue(queue *Qref,int element)\n{\n    if(isFull(*Qref))\n        return -999;\n    else\n    {\n        if((*Qref).front == -1)\n            (*Qref).front = 0;\n        (*Qref).rear = ((*Qref).rear + 1) % (*Qref).size;\n        (*Qref).arr[(*Qref).rear] = element;\n    }\n    return 0;\n}\nint dequeue(queue *Qref)\n{\n    int element;\n    if(isEmpty(*Qref))\n        return(-1);\n    else\n      {\n        element = (*Qref).arr[(*Qref).front];\n        if ((*Qref).front == (*Qref).rear)\n        {\n            (*Qref).front = -1;\n            (*Qref).rear = -1;\n        } \n        else\n            (*Qref).front = ((*Qref).front + 1) % (*Qref).size;\n        return(element);\n      }\n}\n\nint length(queue Q)\n{\n    int l;\n    if (Q.front == -1)\n       return 0;\n    if (Q.rear >= Q.front)\n        l=Q.rear-Q.front+1;\n    else\n        l=Q.size-Q.front+2+Q.rear;\n    return l;\n}\n\nvoid print(queue Q,int n,FILE *fp2)\n{\n    int i,l,c=0;\n    l=length(Q);\n    if (Q.front == -1)\n    {\n        fprintf(fp2,\"-1\\n\");\n        return;\n    }\n    if(n>0 || n==0)\n     {\n        if(n==0)\n          n=l;\n        if (Q.rear >= Q.front)\n         {\n          for (i = Q.front; i <= Q.rear; i++)\n            {\n                if(c<n)\n                 fprintf(fp2,\"%d\",Q.arr[i]);\n                if(i!=Q.rear)\n                 fprintf(fp2,\" \");\n                 c++;  \n              }\n             if(c<n)\n              fprintf(fp2,\" END\\n\");\n             else\n              fprintf(fp2,\"\\n\");\n          }\n     \n       \n        else\n        {\n          for (i = Q.front; i < Q.size; i++)\n            {\n                if(c<n)\n                 fprintf(fp2,\"%d \", Q.arr[i]);\n                c++;\n            }      \n          for (i = 0; i <= Q.rear; i++)\n            {  \n                if(c<=n)\n                 fprintf(fp2,\"%d\", Q.arr[i]);\n                c++;\n                if(i!=Q.rear)\n                 fprintf(fp2,\" \");\n            }\n            if(c<n)\n              fprintf(fp2,\" END\\n\");\n            else\n              fprintf(fp2,\"\\n\");\n         }\n \n    }\n}\n\nint main()\n{\n    char sel;\n    int p,q,n,element;\n    FILE *fp1;\n    FILE *fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    queue Q;\n    Q.rear=-1;\n    Q.front=-1;\n\n    fscanf(fp1,\"%d\",&(Q.size));\n    Q.arr=(int*)malloc(sizeof(int)*(Q.size));\n    while(1)\n         {\n            fscanf(fp1,\"%c\",&sel);\n              if(sel=='e')\n                {\n                    fscanf(fp1,\"%d\",&element);\n                    p=enqueue(&Q,element);\n\n                    if(p==-999)\n                      fprintf(fp2,\"%d\\n\",p);\n                }  \n            else if(sel=='p')\n                 {\n                    fscanf(fp1,\"%d\",&n);\n                    print(Q,n,fp2);\n                 }\n            else if(sel=='d')\n                {\n                    q=dequeue(&Q);\n                    fprintf(fp2,\"%d\\n\",q);\n                }\n            else if(sel=='s')\n                break;\n         }\n\n  fclose(fp1);\n  fclose(fp2);\n  return 0;\n}\n"}
{"target":"HakNinja","func":"#include<stdio.h>\nstruct student\n{\n    int rno;\n    float per;\n    char name[30];\n};\nint main()\n{\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x.name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s\\n\",x.name);\n    printf(\"Percentage:%f\\n\",x.per);\n    return(0);\n}\n\n\n\n\n\n\n\n\n\n"}
{"target":"HakNinja","func":"#include<stdio.h>\nstruct student\n{\n    int rno;\n    float per;\n    char name[30];\n};\nint main()\n{int i,n;\n    struct student x[100];\n    printf(\"Enter number of students:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter Details:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x[i].rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x[i].name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x[i].per);\n    }\n    printf(\"\\n------------------------------------------\");\n    printf(\"Enter Details are:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"\\nRoll number:%d\\n\",x[i].rno);\n    printf(\"\\nName:%s\\n\",x[i].name);\n    printf(\"Percentage:%f\\n\",x[i].per);\n    }  \n    return(0);\n}\n"}
{"target":"HakNinja","func":"#include<stdio.h>\nstruct student\n{\n    int rno;\n    float per;\n    char name[30];\n};\nint main()\n{int i,n,s;\n    struct student x[100];\n    printf(\"Enter number of students:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter Details:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x[i].rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x[i].name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x[i].per);\n    }\n    printf(\"\\n---------------------------------\\n\");\n    printf(\"Roll_no top be search:\");\n    scanf(\"%d\",&s);\n    for(i=0;i<n;i++)\n    {if(s==x[i].rno)\n    {\n    printf(\"\\nRoll number:%d\\n\",x[i].rno);\n    printf(\"\\nName:%s\\n\",x[i].name);\n    printf(\"Percentage:%f\\n\",x[i].per);\n    } \n    }  \n    return(0);\n}\n"}
{"target":"HakNinja","func":"#include<stdio.h>\nstruct NAME\n{\n    char fn[30],mn[30],ln[30];\n};\nstruct date\n{\n    int d,m,y;\n};\nstruct student\n{\n    int rno;\n    float per;\n    struct  NAME name;\n    struct date dob;\n};\nint main()\n{\n    int u;\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student\");\n    printf(\"\\nFirst name:\");\n    scanf(\"%s\",&x.name.fn);\n    printf(\"Middle name:\");\n    scanf(\"%s\",&x.name.mn);\n    printf(\"Last name:\");\n    scanf(\"%s\",&x.name.ln);\n    printf(\"Enter Date Of Birth\");\n    printf(\"\\nDate:\");\n    scanf(\"%d\",&x.dob.d);\n    printf(\"Month:\");\n    scanf(\"%d\",&x.dob.m);\n    printf(\"Year:\");\n    scanf(\"%d\",&x.dob.y);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s %s %s\\n\",x.name.fn,x.name.mn,x.name.ln);\n    printf(\"DoB:%d\/%d\/%d\\n\",x.dob.d,x.dob.m,x.dob.y);\n    printf(\"Percentage:%f\\n\",x.per);\n    \n    return(0);\n}\n"}
{"target":"HakNinja","func":"#include<stdio.h>\n#include<process.h>\nstruct time\n{int h,m,s;\n}x,y,z;\nint main()\n{\nprintf(\"____________________________________________________________________\\n\");\nprintf(\"\\nEnter Duration 1\");\nprintf(\"\\nin sec:\");\nscanf(\"%d\",&x.s);\nprintf(\"\\nin min:\");\nscanf(\"%d\",&x.m);\nprintf(\"\\nin hours:\");\nscanf(\"%d\",&x.h);\n\nprintf(\"\\nEnter Duration 2\");\nprintf(\"\\nin sec:\");\nscanf(\"%d\",&y.s);\nprintf(\"\\nin min:\");\nscanf(\"%d\",&y.m);\nprintf(\"\\nin hours:\");\nscanf(\"%d\",&y.h);\nz.h=x.h+y.h;\nz.m=x.m+y.m;\nz.s=x.s+y.s;\n\nif(z.s>=60)\n{z.s=z.s-60;\nz.m=z.m+1;\n}\nif(z.m>=60)\n{z.m=z.m-60;\nz.h=z.h+1;\n}\nprintf(\"Final Value of time:\");\nprintf(\"in hours:%d\",z.h);\nprintf(\"in min:%d\",z.m);\nprintf(\"in sec:%d\",z.s);\n\nreturn 0;\n}\n\n"}
{"target":"HakNinja","func":"\n \n#include<stdio.h>\nvoid main()\n {\n  float m1,m2,m3,m4,m5,per;\n  printf(\"Enter marks of five subject=\");\n  scanf(\"%f%f%f%f%f\",&m1,&m2,&m3,&m4,&m5);\n  per=(m1+m2+m3+m4+m5)\/5;\n  printf(\"percentage=%f\\n\",per);\n  if(per<=100&&per>=85)\n   {\n    printf(\"Grade=A\");\n    }\n  else if(per<85&&per>=75)\n   {\n    printf(\"Grade=B\");\n    }\n  else if(per<75&&per>=55)\n   {\n    printf(\"Grade=C\");\n    }\n  else if(per<55&&per>=40)\n   {\n    printf(\"Grade=D\");\n    }\n  else\n   {\n    printf(\"FAIL\");\n    }\n  }\n\n\n                                       \n"}
{"target":"HakNinja","func":"\n \n#include<stdio.h>\n#include<math.h>\nvoid main()\n {\n  float r1,r2;\n  int a,b,c,d;\n  printf(\"Enter value of a,b and c:\");\n  scanf(\"%d%d%d\",&a,&b,&c);\n  d=b*b-4*a*c;\n  if(d>0)\n   {\n    printf(\"root are real\");\n    r1=(-b+sqrt(d))\/2*a;\n    r2=(-b-sqrt(d))\/2*a;\n    printf(\"root are %f and %f\\n\",r1,r2);\n    }\n  else if(d==0)\n   {\n    printf(\"root are equal\");\n    r1=-b\/2*a;\n    r2=-b\/2*a;\n    printf(\"root are %f and %f\\n\",r1,r2);\n    }\n  else\n   {\n    printf(\"root are imaginary!\");\n    printf(\"root are not real !!\");\n    }\n  }\n\n"}
{"target":"HakNinja","func":"\n \n#include<stdio.h>\nvoid main()\n {int a[10],n,s,first,middle,last;\n  printf(\"Enter no of element:\");\n  scanf(\"%d\",&n);\n  printf(\"Enter element in ascending order:\");\n  for(int i=0;i<n;i++)\n   {scanf(\"%d\",&a[i]);\n    }\n  printf(\"Enter element to be search:\");\n  scanf(\"%d\",&s);\n  first=0;\n  last=n-1;\n  middle=(first+last)\/2;\n  while(first<=last)\n   {if(a[middle]<s)\n     { first=middle+1;\n      }\n    else if(a[middle]==s)\n     {printf(\"Number is present\\n\");\n      break;         \n      }\n    else\n     {last=middle-1;\n      }\n    middle=(first+last)\/2;\n    }\n  if (first>last)\n   { printf(\"not found!!!\");\n    }\n  }\n\n"}
{"target":"HakNinja","func":"\n                                                         \n#include<stdio.h>\nvoid main()\n {int a[10][10],t[10][10],n,m,i,j;\n  printf (\"Enter numbers of rows:\");\n  scanf (\"%d\",&n);\n  printf (\"Enter numbers of columns:\");\n  scanf (\"%d\",&m);\n  printf(\"Enter elements:\");\n  for(i=0;i<n;i++)            \n   {for(j=0;j<m;j++)\n     {  scanf(\"%d\",&a[i][j]);\n      }\n    }\n  printf(\"\\n Array is:\\n\");\n  for(i=0;i<n;i++)          \n   {for(j=0;j<m;j++)\n     {  printf(\"\\t %d\",a[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");  \n  for(i=0;i<n;i++)         \n   {for(j=0;j<m;j++)\n     {   t[j][i]=a[i][j];\n      }\n    }\n  printf(\"\\n Its transpose:\\n\");\n  for(i=0;i<n;i++)           \n   {for(j=0;j<m;j++)\n     {  printf(\"\\t %d\",t[i][j]);\n      }\n    printf(\"\\n\");\n    }\n  }\n  \n                                                                      \n \n  \n  \n\n                                       \n"}
{"target":"HakNinja","func":"\n\n#include<stdio.h>\n#include<string.h>\nvoid main()\n {\n  char st[100],ch;\n  printf(\"Enter string:\");\n  gets(st);\n  for(int i=0;st[i]!='\\o';i++)\n   {\n    if (st[i]>='A' && st[i]<='Z')\n     {\n      st[i]=st[i]+32;\n      }\n    if (st[i]>='a' && st[i]<='z')\n     {\n      st[i]=st[i]-32;\n      }\n    }\n  printf(\"Opposite case of the string:\");\n  puts(st);\n  }\n\n\n\n\n\n\n\n"}
{"target":"HakNinja","func":"\n                                                         \n#include<stdio.h>\n#include<string.h>\nvoid main()\n {\n  char st[100],ch;\n  printf(\"Enter string:\");\n  gets(st);\n  int i,n,j;\n  n=strlen(st);\n  i=0;\n  j=n-1;\n  while(i<j) \n   { \n    ch=st[i];\n    st[i]=st[j];\n    st[j]=ch;\n    j--;\n    i++;\n    }\n  printf(\"Reverse of the string:\");\n  puts(st);\n  } \n  \n                                                                      \n \n  \n  \n\n                                       \n"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <ctype.h>\n#include <strings.h>\n#include <sys\/epoll.h>\n\n#define MAXLINE 80\n#define OPEN_MAX 1024\n\nint main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    int epfd = epoll_create(OPEN_MAX);                          \n    if(epfd == -1)\n        sys_err(\"epoll_create() error\");\n\n    struct epoll_event temp;                                    \n    struct epoll_event ep[OPEN_MAX];                            \n\n    temp.events = EPOLLIN;                                      \n    temp.data.fd = serv_sock;\n\n    int res = epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &temp); \n    if(res == -1)\n        sys_err(\"epoll_ctl() error\");\n\n    \n    char buf[MAXLINE], str[INET_ADDRSTRLEN];\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    int ret, conn_sock, clnt_sock, i, n, num = 0;\n    while(1)\n    {\n        ret = epoll_wait(epfd, ep, OPEN_MAX, -1);               \n        if(ret == -1)\n            sys_err(\"epoll_wait() error\");\n        \n        for(i = 0; i < ret; i++)\n        {\n            if(!ep[i].events & EPOLLIN)                         \n                continue;\n            \n            if(ep[i].data.fd == serv_sock)\n            {\n                clnt_adr_len = sizeof(clnt_adr);\n                conn_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n\n                printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n                printf(\"cfd %d --- client %d\\n\", conn_sock, ++num);\n\n                temp.events = EPOLLIN;\n                temp.data.fd = conn_sock;\n                res = epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &temp);     \n                if(res == -1)\n                    sys_err(\"epoll_ctl() error\");\n            }\n            else\n            {\n                clnt_sock = ep[i].data.fd;\n                n = Read(clnt_sock, buf, MAXLINE);\n                if(n == 0)\n                {\n                    res = epoll_ctl(epfd, EPOLL_CTL_DEL, clnt_sock, NULL);  \n                    if(res == -1)\n                        sys_err(\"epoll_ctl() error\");\n                    Close(clnt_sock);\n                    printf(\"client[%d] closed connection\\n\", clnt_sock);\n                }\n                else\n                {\n                    for(i = 0; i < n; i++)\n                        buf[i] = toupper(buf[i]);\n                    \n                    Write(STDOUT_FILENO, buf, n);\n                    Write(clnt_sock, buf, n);\n                }\n            }\n        }\n    }\n    Close(serv_sock);\n    Close(epfd);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <ctype.h>\n#include <strings.h>\n#include <poll.h>\n\n#define MAXLINE 80\n#define OPEN_MAX 1024\n\nint main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    struct pollfd client[OPEN_MAX];\n    client[0].fd = serv_sock;       \n    client[0].events = POLLIN;      \n\n    for(int i = 1; i < OPEN_MAX; i++)\n    {\n        client[i].fd = -1;\n    }\n\n    int maxi = 0;           \n    char buf[MAXLINE], str[INET_ADDRSTRLEN];\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    int ret, conn_sock, clnt_sock, i, n;\n    while(1)\n    {\n        ret = poll(client, maxi+1, -1);\n        if(ret < 0)\n        {\n            sys_err(\"poll() err\");\n        }\n\n        if(client[0].revents & POLLIN)\n        {\n            clnt_adr_len = sizeof(clnt_adr);\n            conn_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n            printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n\n            for(i = 1; i < OPEN_MAX; i++)\n            {\n                if(client[i].fd < 0)\n                {\n                    client[i].fd = conn_sock;           \n                    break;\n                }\n            }\n            if(i == OPEN_MAX)\n            {\n                fputs(\"too many clients\\n\", stderr);            \n                exit(1);\n            }\n            \n            client[i].events = POLLIN;                  \n            if(i > maxi)\n                maxi = i;                               \n            if(--ret <= 0)\n                continue;                               \n        }\n\n        for(i = 1; i <= maxi; i++)\n        {\n            if((clnt_sock = client[i].fd) < 0)\n                continue;\n\n            if(client[i].revents & POLLIN)\n            {\n                if((n = Read(clnt_sock, buf, MAXLINE)) < 0)\n                {\n                    if(errno == ECONNRESET)             \n                    {\n                        printf(\"client[%d] aborted connection\\n\", i);\n                        Close(clnt_sock);\n                        client[i].fd = -1;              \n                    }\n                    else\n                    {\n                        sys_err(\"read() error\");\n                    }\n                }\n                else if(n == 0)                         \n                {\n                    printf(\"client[%d] closed connection\\n\", i);\n                    Close(clnt_sock);\n                    client[i].fd = -1;\n                }\n                else\n                {\n                    for(int j = 0; j < n; j++)\n                        buf[j] = toupper(buf[j]);\n                    Write(clnt_sock, buf, n);\n                }\n\n                if(--ret <= 0)\n                    break;\n            }\n        }\n    }\n    Close(serv_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <strings.h>\n#include <ctype.h>\n#include <sys\/select.h>\n\nint main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    int maxfd = serv_sock;          \n\n    fd_set rset, allset;            \n    FD_ZERO(&allset);               \n    FD_SET(serv_sock, &allset);     \n     \n    int clnt_sock;\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    char buf[BUFSIZ];\n    int ret, n;\n    while(1)\n    {\n        rset = allset;              \n        ret = select(maxfd+1, &rset, NULL, NULL, NULL);     \n        if (ret < 0)\n        {\n            sys_err(\"select() error\");\n        }\n\n        if(FD_ISSET(serv_sock, &rset))                      \n        {\n            clnt_adr_len = sizeof(clnt_adr);\n            clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);      \n            FD_SET(clnt_sock, &allset);                     \n            \n            if(maxfd < clnt_sock)       \n                maxfd = clnt_sock;\n            \n            if(ret == 1)                \n                continue;\n        }\n\n        for(int i = serv_sock+1; i <= maxfd; i++)   \n        {\n            if(FD_ISSET(i, &rset))\n            {\n                n = Read(i, buf, sizeof(buf));\n                if(n == 0)\n                {\n                    Close(i);\n                    FD_CLR(i, &allset);             \n                }\n                else\n                {\n                    for(int j = 0; j < n; j++)\n                    {\n                        buf[j] = toupper(buf[j]);\n                    }\n                    Write(i, buf, n);\n                    Write(STDOUT_FILENO, buf, n);\n                }\n            }\n        } \n    }\n\n    Close(serv_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa\/inet.h>\n#include <sys\/socket.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    int serv_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(serv_sock == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n\n    int ret = 0;\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    ret = bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        sys_err(\"bind() error\");\n    }\n    \n    ret = listen(serv_sock, 128);\n    if(ret == -1)\n    {\n        sys_err(\"listen() error\");\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sock == -1)\n    {\n        sys_err(\"accept error\");\n    }\n\n    char clnt_IP[1024];\n    printf(\"client ip:%s, port:%d\\n\", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));\n\n    char buf[BUFSIZ];\n    while(1)\n    {\n        int ret = read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        write(STDOUT_FILENO, buf, ret);\n\n        for(int i = 0; i < ret; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n        write(clnt_sock, buf, ret);\n    }\n\n    close(serv_sock);\n    close(clnt_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <arpa\/inet.h>\n#include <sys\/socket.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    int clnt_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(clnt_sock == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    int ret = connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret != 0)\n    {\n        sys_err(\"connect() error\");\n    }\n\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        write(clnt_sock, \"hello\\n\", 6);\n        ret = read(clnt_sock, buf, sizeof(buf));\n        write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n\n    close(clnt_sock);\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys\/epoll.h>\n#include <errno.h>\n#include <unistd.h>\n\n#define MAXLINE 10\n\nint main(int argc, char *argv[])\n{\n    char buf[MAXLINE];\n    char ch = 'a';\n\n    int pfd[2];\n    pipe(pfd);\n\n    pid_t pid = fork();\n    if(pid == 0)            \n    {\n        close(pfd[0]);\n        int i;\n        while(1)\n        {\n            \n            for(i = 0; i < MAXLINE\/2; i++)\n            {\n                buf[i] = ch;\n            }\n            buf[i-1] = '\\n';\n            ch++;\n\n            \n            for(; i < MAXLINE; i++)\n            {\n                buf[i] = ch;\n            }\n            buf[i-1] = '\\n';\n            ch++;\n            \n            write(pfd[1], buf, sizeof(buf));\n            sleep(5);\n        }\n        close(pfd[1]);\n    }\n    else if(pid > 0)        \n    {\n        close(pfd[1]);\n\n        struct epoll_event event;               \n        struct epoll_event resevent[10];        \n \n        int efd = epoll_create(10);\n        event.events = EPOLLIN|EPOLLET;         \n        \n        event.data.fd = pfd[0];\n        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event);\n\n        int res, len;\n        while(1)\n        {\n            res = epoll_wait(efd, resevent, 10, -1);\n            \n            if(resevent[0].data.fd == pfd[0])\n            {\n                len = read(pfd[0], buf, MAXLINE\/2);\n                write(STDOUT_FILENO, buf, len);\n            }\n        }\n\n        close(pfd[0]);\n        close(efd);\n    }\n    else\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n\n#include \"..\/base.h\"\n#include <strings.h>    \n#include <ctype.h>\n#include <pthread.h>\n\nstruct clnt_info                \n{\n    struct sockaddr_in clnt_addr;\n    int clnt_sock; \n};\n\nvoid *do_work(void *arg)\n{\n    struct clnt_info *p_cInfo = (struct clnt_info *)arg;\n    char buf[BUFSIZ];\n    char str[16];       \n    int n;\n\n    while(1)\n    {\n        n = Read(p_cInfo->clnt_sock, buf, sizeof(buf));\n        if(n == 0)\n        {\n            printf(\"the client %d closed...\\n\", p_cInfo->clnt_sock);\n            break;\n        }\n\n        printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &(p_cInfo->clnt_addr.sin_addr), str, sizeof(str)), ntohs(p_cInfo->clnt_addr.sin_port));  \n\n        for(int i = 0; i < n; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n\n        Write(STDOUT_FILENO, buf, n);\n        Write(p_cInfo->clnt_sock, buf, n);\n    }\n    Close(p_cInfo->clnt_sock);\n    return (void*)0;        \n}\n\nint main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    \n    \n    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    Listen(serv_sock, 128);\n\n    printf(\"Accepting client connect...\\n\");\n    struct clnt_info c_info[256];\n    int i = 0;\n    int clnt_sock;\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len;\n    pthread_t tid;\n    while(1)\n    {\n        clnt_addr_len = sizeof(clnt_addr);\n        clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n        c_info[i].clnt_addr = clnt_addr;\n        c_info[i].clnt_sock = clnt_sock;\n\n        pthread_create(&tid, NULL, do_work, (void*)&c_info[i]);     \n        pthread_detach(tid);            \n        i++;\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <strings.h>\n#include <ctype.h>\n#include <sys\/select.h>\n\nint main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    int maxfd = serv_sock;          \n\n    int maxi = -1;                  \n    int clnt[FD_SETSIZE];           \n    for(int i = 0; i < FD_SETSIZE; i++)\n    {\n        clnt[i] = -1;\n    }\n\n    fd_set rset, allset;            \n    FD_ZERO(&allset);              \n    FD_SET(serv_sock, &allset);  \n     \n    int clnt_sock;\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    char buf[BUFSIZ], str[INET_ADDRSTRLEN];     \n    int ret, n, i, sockfd;\n    while(1)\n    {\n        rset = allset;                          \n        ret = select(maxfd+1, &rset, NULL, NULL, NULL);     \n        if (ret < 0)\n        {\n            sys_err(\"select() error\");\n        }\n\n        if(FD_ISSET(serv_sock, &rset))                      \n        {\n            clnt_adr_len = sizeof(clnt_adr);\n            clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n            printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n\n            for(i = 0; i < FD_SETSIZE; i++)             \n            {\n                if(clnt[i] < 0)\n                {\n                    clnt[i] = clnt_sock;            \n                    break;\n                }\n            }\n            if(i == FD_SETSIZE)                         \n            {\n                fputs(\"too many clients\\n\", stderr);\n                exit(1);\n            }\n\n            FD_SET(clnt_sock, &allset);                     \n            \n            if(maxfd < clnt_sock)       \n                maxfd = clnt_sock;\n            \n            if(i > maxi)                    \n                maxi = i;\n\n            if(--ret == 0)                       \n                continue;\n        }\n\n        for(i = 0; i <= maxi; i++)          \n        {\n            if((sockfd = clnt[i]) < 0)\n            {\n                continue;\n            }\n            if(FD_ISSET(sockfd, &rset))\n            {\n                n = Read(sockfd, buf, sizeof(buf));\n                if(n == 0)     \n                {\n                    Close(sockfd);\n                    FD_CLR(sockfd, &allset);\n                    clnt[i] = -1;           \n                }\n                else\n                {\n                    for(int j = 0; j < n; j++)\n                    {\n                        buf[j] = toupper(buf[j]);\n                    }\n                    Write(sockfd, buf, n);\n                    Write(STDOUT_FILENO, buf, n);\n                }\n\n                if(--ret == 0)\n                    break;          \n            }\n        } \n    }\n\n    Close(serv_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <strings.h>\n#include <sys\/epoll.h>\n\n#define MAXLINE 10\n\nint main(int argc, char *argv[])\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    struct epoll_event event;               \n    struct epoll_event resevent[10];        \n\n    int efd = epoll_create(10);\n    event.events = EPOLLIN|EPOLLET;       \n    \n\n    printf(\"Accepting connection ...\\n\");\n\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len = sizeof(clnt_adr);\n    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n\n    char str[INET_ADDRSTRLEN];\n    printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n\n    event.data.fd = clnt_sock;\n    epoll_ctl(efd, EPOLL_CTL_ADD, clnt_sock, &event);\n\n    int res, len;\n    char buf[MAXLINE];\n    while(1)\n    {\n        res = epoll_wait(efd, resevent, 10, -1);\n        \n        if(resevent[0].data.fd == clnt_sock)\n        {\n            len = read(clnt_sock, buf, MAXLINE\/2);\n            write(STDOUT_FILENO, buf, len);\n        }\n    }\n\n    Close(serv_sock);\n    Close(efd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n\n#include \"..\/base.h\"\n#include <ctype.h>          \n\nint main(int argc, char *argv[])\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    Listen(serv_sock, 128);\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n\n    char clnt_IP[1024];\n    printf(\"client ip:%s, port:%d\\n\", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));\n\n    char buf[BUFSIZ];\n    while(1)\n    {\n        int ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n\n        for(int i = 0; i < ret; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n        Write(clnt_sock, buf, ret);\n    }\n\n    Close(serv_sock);\n    Close(clnt_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/base.h\"\n\nint main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n\n    Close(clnt_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <strings.h>\n\n#define MAXLINE 10\n\nint main(int argc, char *argv[])\n{\n    int sockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_adr.sin_addr.s_addr);\n    \n    Connect(sockfd, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n\n    char ch = 'a';\n    char buf[MAXLINE];\n    int i;\n    while(1)\n    {\n        \n        for(i = 0; i < MAXLINE\/2; i++)\n        {\n            buf[i] = ch;\n        }\n        buf[i-1] = '\\n';\n        ch++;\n\n        \n        for(; i < MAXLINE; i++)\n        {\n            buf[i] = ch;\n        }\n        buf[i-1] = '\\n';\n        ch++;\n        \n        write(sockfd, buf, sizeof(buf));\n        sleep(5);\n    }\n\n    Close(sockfd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n\n#include \"..\/..\/base.h\"\n#include <strings.h>\n#include <sys\/epoll.h>\n#include <fcntl.h>          \n\n#define MAXLINE 10\n\nint main(int argc, char *argv[])\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n\n    Listen(serv_sock, 128);\n\n    struct epoll_event event;               \n    struct epoll_event resevent[10];        \n\n    int efd = epoll_create(10);\n    event.events = EPOLLIN|EPOLLET;       \n\n    printf(\"Accepting connection ...\\n\");\n\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len = sizeof(clnt_adr);\n    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n\n    char str[INET_ADDRSTRLEN];\n    printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n\n    int flag = fcntl(clnt_sock, F_GETFL);       \n    flag |= O_NONBLOCK;\n    fcntl(clnt_sock, F_SETFL, flag);\n\n    event.data.fd = clnt_sock;\n    epoll_ctl(efd, EPOLL_CTL_ADD, clnt_sock, &event);\n\n    int res, len;\n    char buf[MAXLINE];\n    while(1)\n    {\n        printf(\"epoll_wait begin\\n\");\n        res = epoll_wait(efd, resevent, 10, -1);\n        printf(\"epoll_wait end res %d\\n\", res);\n\n        if(resevent[0].data.fd == clnt_sock)\n        {\n            while((len = read(clnt_sock, buf, MAXLINE\/2)) > 0)      \n                write(STDOUT_FILENO, buf, len);\n        }\n    }\n\n    Close(serv_sock);\n    Close(efd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n\n#include \"base.h\"\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint Socket(int domain, int type, int protocol)\n{\n    int sockfd = socket(domain, type, protocol);\n    if(sockfd == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n    return sockfd;\n}\n\nint Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    int ret = bind(sockfd, addr, addrlen);\n    if(ret == -1)\n    {\n        sys_err(\"bind() error\");\n    }\n    return ret;\n}\n\nint Listen(int sockfd, int backlog)\n{\n    int ret = listen(sockfd, backlog);\n    if(ret == -1)\n    {\n        sys_err(\"listen() error\");\n    }\n    return ret;\n}\n\nint Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    int clnt_sock;\n    while((clnt_sock = accept(sockfd, addr, addrlen)) == -1)\n    {\n        if(errno == EINTR)      \n            continue;\n        else\n            sys_err(\"accept() error\");\n    }\n    return clnt_sock;\n}\n\nint Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    int ret = connect(sockfd, addr, addrlen);\n    if(ret == -1)\n    {\n        sys_err(\"connect() error\");\n    }\n    return ret;\n}\n\nssize_t Read(int fd, void *buf, size_t count)\n{\n    int ret;\n    while((ret = read(fd, buf, count)) == -1)\n    {                                           \n        if(errno == EINTR)                      \n            continue;                           \n        else\n            sys_err(\"read() error\");\n    }\n    return ret;\n}\n\nssize_t Write(int fd, const void *buf, size_t count)\n{\n    int ret;\n    while((ret = write(fd, buf, count)) == -1)\n    {\n        if(errno == EINTR)\n            continue;\n        else\n            sys_err(\"write() error\");\n    }\n    return ret;\n}\n\nint Close(int fd)\n{\n    int ret = close(fd);\n    if(ret == -1)\n    {\n        sys_err(\"close() error\");\n    }\n    return ret;\n}"}
{"target":"haon1026","func":"\n\n#define _POSIX_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys\/wait.h>\n#include <sys\/types.h>\n\n\nvoid sys_err(const char* str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid catch_child(int signo)\n{\n    pid_t wpid;\n    int status;\n\n    \n    while((wpid = waitpid(-1, &status, 0)) != -1)      \n    {\n        if(WIFEXITED(status))\n            printf(\"catch child, pid = %d, ret = %d\\n\", wpid, WEXITSTATUS(status));\n    }\n\n    \n    \n    \n    return;\n}\n\nint main()\n{\n    \n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGCHLD);\n    sigprocmask(SIG_BLOCK, &set, NULL);\n\n    pid_t pid;\n    int i;\n    for(i = 0; i < 10; i++)\n    {\n        if((pid =fork()) == 0)          \n            break;\n    }\n\n    if(i == 10)\n    {\n        struct sigaction act;               \n        act.sa_handler = catch_child;       \n        sigemptyset(&act.sa_mask);          \n        act.sa_flags = 0;                   \n        sigaction(SIGCHLD, &act, NULL);     \n\n        \n        sigprocmask(SIG_UNBLOCK, &set, NULL);   \n\n        printf(\"I'm parent, pid = %d\\n\", getpid());\n        \n        int num = 0;\n        while(1)\n        {\n            printf(\"num = %d\\n\", num++);\n            sleep(1);\n        }\n    }\n    else\n    {\n        printf(\"I'm child, pid = %d\\n\", getpid());\n        return i;\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include \"..\/base.h\"\n\nint main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n\n    Close(clnt_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include \"..\/..\/base.h\"\n\nint main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n\n    Close(clnt_sock);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid err_thread(int ret, char *str)\n{\n    if(ret != 0)\n    {\n        fprintf(stderr, \"%s:%s\\n\", str, strerror(ret));\n        pthread_exit(NULL);\n    }\n}\n\nstruct msg\n{\n    int num;\n    struct msg *next; \n};\nstruct msg *head;\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;      \npthread_cond_t has_data = PTHREAD_COND_INITIALIZER;     \n\nvoid *producer(void *arg)\n{\n    while(1)\n    {\n        struct msg *mp = malloc(sizeof(struct msg));\n        mp->num = rand() % 1000 + 1;                    \n        printf(\"-----produce %d\\n\", mp->num);\n\n        pthread_mutex_lock(&mutex);                     \n        mp->next = head;                                \n        head = mp;\n        pthread_mutex_unlock(&mutex);                   \n\n        pthread_cond_signal(&has_data);              \n\n        sleep(rand()%3);\n    }\n\n    return NULL;\n}\n\nvoid *comsumer(void *arg)\n{\n    while(1)\n    {\n        pthread_mutex_lock(&mutex);                     \n\n        while(head == NULL)                             \n        {\n            pthread_cond_wait(&has_data, &mutex);       \n        }                                               \n\n        struct msg *mp = head;\n        head = head->next;\n         \n        pthread_mutex_unlock(&mutex);                   \n        printf(\"----------comsumer id: %lu : %d\\n\", pthread_self(), mp->num);\n\n        free(mp);\n        sleep(rand()%3);\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    srand(time(NULL));\n\n    pthread_t pid, cid1, cid2, cid3;\n    int ret = pthread_create(&pid, NULL, producer, NULL);   \n    if(ret != 0)\n        err_thread(ret, \"pthread_create producer error\");\n\n    ret = pthread_create(&cid1, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n\n    ret = pthread_create(&cid2, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n    \n    ret = pthread_create(&cid3, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n\n    pthread_join(pid, NULL);\n    pthread_join(cid1, NULL);\n    pthread_join(cid2, NULL);\n    pthread_join(cid3, NULL);\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDONLY);\n    if(fd1 == -1)\n    {\n        perror(\"open argv1 error\");\n        exit(1);\n    }\n\n    int fd2 = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0644);\n    if(fd2 == -1)\n    {\n        perror(\"open argv2 error\");\n        exit(1);\n    }\n\n    char buf[1024];\n    int n = 0;\n    while((n = read(fd1, buf, 1024)) != 0)\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            break;\n        }\n        write(fd2, buf, n);\n    }\n\n    close(fd1);\n    close(fd2);\n}   \n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint val1;\nint val2;\npthread_mutex_t mutex1;\npthread_mutex_t mutex2;\n\nvoid* fun1(void *arg)\n{\n    pthread_mutex_lock(&mutex1);\n    printf(\"val1 = %d\\n\", val1);\n    sleep(1);\n    pthread_mutex_lock(&mutex2);\n    val2 = 100;\n    printf(\"val2 = %d\\n\", val2);\n    pthread_mutex_unlock(&mutex2);\n    pthread_mutex_unlock(&mutex1);\n\n    return NULL;\n}\n\nvoid* fun2(void *arg)\n{\n    pthread_mutex_lock(&mutex2);\n    printf(\"val2 = %d\\n\", val2);\n    sleep(1);\n    pthread_mutex_lock(&mutex1);\n    val1 = 200;\n    printf(\"val1 = %d\\n\", val1);\n    pthread_mutex_unlock(&mutex1);\n    pthread_mutex_unlock(&mutex2);\n    return NULL;\n}\n\nint main()\n{\n    pthread_mutex_init(&mutex1, NULL);\n    pthread_mutex_init(&mutex2, NULL);\n    pthread_t tid1, tid2;\n\n    pthread_create(&tid1, NULL, fun1, NULL);\n    pthread_create(&tid2, NULL, fun2, NULL);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    pthread_mutex_destroy(&mutex1);\n    pthread_mutex_destroy(&mutex2);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDWR|O_CREAT, 0644);   \n    if(fd1 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n\n    int fd2 = open(argv[2], O_RDWR|O_CREAT, 0644);   \n    if(fd2 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n\n    int newfd = dup2(fd1, fd2);                 \n    printf(\"newfd = %d\\n\", newfd);\n\n    int ret = write(fd2, \"1234567\", 7);         \n    printf(\"ret = %d\\n\", ret);\n\n    dup2(fd1, STDOUT_FILENO);                   \n    printf(\"-------------------\\n\");\n\n    close(fd1);\n    close(newfd);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define MSG_TRY \"try again\\n\"\n\nint main()\n{\n    int flags = fcntl(STDIN_FILENO, F_GETFL);   \n    if(flags == -1)\n    {\n        perror(\"fcntl error\");\n        exit(1);\n    }\n    \n    flags |= O_NONBLOCK;\n    int ret = fcntl(STDIN_FILENO, F_SETFL, flags);\n    if(ret == -1)\n    {\n        perror(\"fcntl error\");\n        exit(1);\n    }\n\n    char buf[10];\n    int n;\n    while(1)\n    {\n        n = read(STDIN_FILENO, buf, 10);\n        if(n < 0)\n        {\n            if(errno != EAGAIN)\n            {\n                perror(\"read \/dev\/tty\");\n                exit(1);\n            }\n            else\n            {\n                write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));\n                sleep(2);\n                continue;\n            }\n        }\n        break;\n    }\n\n    write(STDOUT_FILENO, buf, n);\n\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <fcntl.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    if(argc < 2)\n    {\n        printf(\"enter a fifo name\\n\");\n        return -1;\n    }\n\n    int fd = open(argv[1], O_RDONLY);\n    if(fd < 0)\n        sys_error(\"open error\");\n    \n    int n;\n    char buf[1024];\n    while(1)\n    {\n        n = read(fd, buf, sizeof(buf));\n        write(STDOUT_FILENO, buf, n);\n        sleep(1);\n    }\n\n    close(fd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <fcntl.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main(int argc, char *argv[])\n{\n    if(argc < 2)\n    {\n        printf(\"enter a fifo name\\n\");\n        return -1;\n    }\n\n    int fd = open(argv[1], O_WRONLY);\n    if(fd < 0)\n        sys_error(\"open error\");\n    \n    int i = 0;\n    char buf[1024];\n    while(1)\n    {\n        sprintf(buf, \"hello world %d\\n\", i++);\n        write(fd, buf, strlen(buf));\n        sleep(1);\n    }\n\n    close(fd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include <sys\/types.h>\n\nint val = 100;\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd = open(\"temp\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n\n    ftruncate(fd, 4); \n\n    \n    int *p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n\n    close(fd);              \n    pid_t pid = fork();\n    if(pid < 0)\n        sys_err(\"fork error\");\n    else if(pid == 0)\n    {\n        *p = 2000;          \n        val = 1000;\n        printf(\"child, *p = %d, var = %d\\n\", *p, val);\n    }\n    else\n    {\n        sleep(1);\n        printf(\"parent, *p = %d, var = %d\\n\", *p, val);     \n        wait(NULL);\n        \n        int ret = munmap(p, 4);\n        if(ret == -1)\n            perror(\"munmap error\");\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"before fork-1-\\n\");\n    printf(\"before fork-2-\\n\");\n    printf(\"before fork-3-\\n\");\n    printf(\"before fork-4-\\n\");\n\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"child is created\\n\");\n    }\n    else if(pid > 0)\n    {\n        printf(\"parent process:child is %d\\n\", pid);\n    }\n\n    printf(\"end of file\\n\");\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n    FILE *fp1 = fopen(argv[1], \"r\");\n    if(fp1 == NULL)\n    {\n        perror(\"file1 fopen error\");\n        exit(1);\n    }\n\n    FILE *fp2 = fopen(argv[2], \"w\");\n    if(fp2 == NULL)\n    {\n        perror(\"file2 fopen error\");\n        exit(1);\n    }\n\n    int n;\n    while((n = fgetc(fp1)) != EOF)\n    {\n        fputc(n, fp2);\n    }\n    \n    fclose(fp1);\n    fclose(fp2);\n    return 0;\n}\n\n\n\n\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"before fork-1-\\n\");\n    printf(\"before fork-2-\\n\");\n    printf(\"before fork-3-\\n\");\n    printf(\"before fork-4-\\n\");\n\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"child is created, pid:%d, parent-pid:%d\\n\", getpid(), getppid());\n    }\n    else if(pid > 0)\n    {\n        printf(\"parent process:child pid:%d, my-pid:%d, parent-pid:%d\\n\", pid, getpid(), getppid());\n    }\n\n    printf(\"end of file\\n\");\n    sleep(2);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys\/types.h>\n\nint val = 100;\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    pid_t pid = fork();\n    if(pid > 0)\n    {\n        while(1)\n        {\n            printf(\"parent, pid = %d\\n\", getpid());\n            sleep(1);\n        }\n    }\n    else if(pid == 0)\n    {\n        \n\n        \n\n        sleep(5);\n        printf(\"child pid = %d, ppid = %d\\n\", getpid(), getppid());         \n        kill(0, SIGKILL);\n    }\n    \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid* thread_fun(void *arg)\n{\n    int i = (int)arg;\n    sleep(i);\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)i);     \n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n\n    sleep(i);\n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid* thread_fun(void *arg)\n{\n    int i = *((int*)arg);           \n    sleep(i);\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)&i);    \n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n\n    sleep(6);\n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/stat.h>\n#include <dirent.h>\n\nvoid isFile(char *filename);\n\nvoid readDir(char *dir)\n{\n    \n    DIR *dp = opendir(dir);\n    if(dp == NULL)\n    {\n        perror(\"opendir error\");\n        return;\n    }\n\n    \n    char path[256] = {0};\n    struct dirent *sdp;\n    while((sdp = readdir(dp)) != NULL)\n    {\n        if(strcmp(sdp->d_name, \".\") == 0 || strcmp(sdp->d_name, \"..\") == 0)\n            continue;\n        \n        \n        sprintf(path, \"%s\/%s\", dir, sdp->d_name);\n        \n        isFile(path);\n    }\n\n    closedir(dp);\n    return;\n}\n\nvoid isFile(char *filename)\n{\n    \n    struct stat buf;\n    int ret = stat(filename, &buf);\n    if(ret == -1)\n    {\n        perror(\"stat error\");\n        return;\n    }\n\n    \n    if(S_ISDIR(buf.st_mode))\n    {\n        readDir(filename);\n    }\n\n    \n    printf(\"%s\\t%ld\\n\", filename, buf.st_size);\n\n    return;\n}\n\nint main(int argc, char *argv[])\n{\n    \n    if(argc == 1)\n    {\n        isFile(\".\");\n    }\n    else\n    {\n        isFile(argv[1]);\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    \n    pid_t pid = fork();\n    if(pid == -1)\n    {   \n        sys_error(\"fork error\");\n    }\n    else if (pid > 0)\n    {\n        close(fd[1]);\n        dup2(fd[0], STDIN_FILENO);\n        execlp(\"wc\", \"wc\", \"-l\", NULL);\n        sys_error(\"execlp wc error\");\n    }\n    else if (pid == 0)\n    {\n        close(fd[0]);\n        dup2(fd[1], STDOUT_FILENO);\n        execlp(\"ls\", \"ls\", NULL);\n        sys_error(\"execlp ls error\");\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(int argc, char *argv[])\n{\n    int fd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n\n    char msg[] = \"It's a test for lseek\\n\";\n    write(fd, msg, strlen(msg));    \n\n    \n\n    int n;\n    char ch;\n    while(n = read(fd, &ch, 1))\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            exit(1);\n        }\n        write(STDOUT_FILENO, &ch, n);\n    }\n\n    close(fd);\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include <sys\/types.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd = open(\"testmap\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n\n    \n    \n    ftruncate(fd, 20);              \n\n    int len = lseek(fd, 0, SEEK_END);\n    char *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n\n    \n    strcpy(p, \"hello map\");\n    printf(\"%s\\n\", p);\n\n    int ret = munmap(p, len);\n    if(ret == -1)\n        sys_err(\"munmap error\");\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint main()\n{\n    int fd = open(\"\/dev\/tty\", O_RDONLY|O_NONBLOCK);\n    if(fd < 0)\n    {\n        perror(\"open \/dev\/tty\");\n        exit(1);\n    }\n    printf(\"open \/dev\/tty ok, fd = %d\\n\", fd);\n\n    char buf[10];\n    int n;\n    while(1)\n    {\n        n = read(fd, buf, 10);\n        if(n < 0)\n        {\n            if(errno != EAGAIN)\n            {\n                perror(\"read \/dev\/tty\");\n                exit(1);\n            }\n            else\n            {\n                write(STDOUT_FILENO, \"try again\\n\", strlen(\"try again\\n\"));\n                sleep(2);\n                continue;\n            }\n        }\n        break;\n    }\n\n    write(STDOUT_FILENO, buf, n);\n    close(fd);\n\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define MSG_TRY \"try again\\n\"\n#define MSG_TIMEOUT \"time out\\n\"\n\nint main()\n{\n    int fd = open(\"\/dev\/tty\", O_RDONLY|O_NONBLOCK);\n    if(fd < 0)\n    {\n        perror(\"open \/dev\/tty\");\n        exit(1);\n    }\n    printf(\"open \/dev\/tty ok, fd = %d\\n\", fd);\n\n    char buf[10];\n    int i, n;\n    for(i = 0; i < 5; i++)\n    {\n        n = read(fd, buf, 10);\n        if(n > 0)\n            break;\n\n        if(errno != EAGAIN)\n        {\n            perror(\"read \/dev\/tty\");\n            exit(1);\n        }\n        else\n        {\n            write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));\n            sleep(2);\n        }\n    }\n\n    if(i == 5)\n        write(STDOUT_FILENO, MSG_TIMEOUT, strlen(MSG_TIMEOUT));\n    else\n        write(STDOUT_FILENO, buf, n);\n\n    close(fd);\n    return 0;\n}\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include <sys\/types.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nstruct student\n{\n    int id;\n    char name[256];\n    int age;\n};\n\nint main()\n{\n    struct student stu;\n    int fd = open(\"temp\", O_RDONLY);\n    if(fd == -1)\n        sys_err(\"open error\");\n\n    struct student *p = mmap(NULL, sizeof(stu), PROT_READ, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n\n    close(fd);\n    \n    while(1)\n    {\n        printf(\"id = %d, name = %s, age = %d\\n\", p->id, p->name, p->age);\n        sleep(1);\n    }\n\n    munmap(p, sizeof(stu));\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include <sys\/types.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nstruct student\n{\n    int id;\n    char name[256];\n    int age;\n};\n\nint main()\n{\n    struct student stu = {1, \"zhangsan\", 18};\n    int fd = open(\"temp\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n\n    ftruncate(fd, sizeof(stu)); \n\n    struct student *p = mmap(NULL, sizeof(stu), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n\n    close(fd);\n    \n    while(1)\n    {\n        memcpy(p, &stu, sizeof(stu));\n        stu.id++;\n        sleep(1);\n    }\n\n    munmap(p, sizeof(stu));\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nint main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        while(1)\n        {\n            printf(\"I'm child, my parent pid = %d\\n\", getppid());\n            sleep(1);\n        }\n    }\n    else if(pid > 0)\n    {\n        printf(\"I'm parent, my pid = %d\\n\", getpid());\n        sleep(9);\n        printf(\"--------parent process going to die---------\\n\");\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid sys_error(char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    \n    char str[] = \"hello world\\n\";\n    char buf[100];\n    int pid = fork();\n    if(pid == 0)\n    {\n        close(fd[1]);\n        \n        int n = read(fd[0], buf, sizeof(buf));\n        if(n > 0)\n        {\n            printf(\"%s\", buf);\n        }\n        else\n        {\n            sys_error(\"read error\");\n        }\n        close(fd[0]);\n    }\n    else if (pid > 0)\n    {\n        close(fd[0]);\n        int n = write(fd[1], str, strlen(str));\n        if(n > 0)\n        {\n            printf(\"write ok, n = %d\\n\", n);\n        }\n        sleep(1);\n        close(fd[1]);\n    }\n    \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    \n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n\n    if(i == 2)\n    {\n        \n        \n        wait(NULL);\n        wait(NULL);\n    }\n    else if (i == 0)\n    {\n        close(fd[0]);\n        dup2(fd[1], STDOUT_FILENO);\n        execlp(\"ls\", \"ls\", NULL);\n        sys_error(\"execlp ls error\");\n    }\n    else if (i == 1)\n    {\n        close(fd[1]);\n        dup2(fd[0], STDIN_FILENO);\n        execlp(\"wc\", \"wc\", \"-l\", NULL);\n        sys_error(\"execlp wc error\");\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    \n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n\n    char buf[1024];\n    int n;\n    if (i == 0)\n    {\n        close(fd[1]);\n        n = read(fd[0], buf, 6);\n        write(STDOUT_FILENO, buf, n);\n    }\n    else if (i == 1)\n    {\n        close(fd[1]);\n        n = read(fd[0], buf, 6);\n        write(STDOUT_FILENO, buf, n);\n    }\n    else if(i == 2)\n    {\n        close(fd[0]);\n        write(fd[1], \"hello world\\n\", strlen(\"hello world\\n\"));\n\n        wait(NULL);\n        wait(NULL);\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nvoid sys_error(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nint main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    \n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n\n    char buf[1024];\n    if (i == 0)\n    {\n        close(fd[0]);\n        write(fd[1], \"1.hello\\n\", strlen(\"1.hello\\n\"));\n    }\n    else if (i == 1)\n    {\n        close(fd[0]);\n        write(fd[1], \"2.world\\n\", strlen(\"2.world\\n\"));\n    }\n    else if(i == 2)\n    {\n        close(fd[1]);\n        \n        int n = read(fd[0], buf, 1024);\n        write(STDOUT_FILENO, buf, n);\n\n        wait(NULL);\n        wait(NULL);\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid* thread_fun(void *arg)\n{\n    printf(\"thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    pthread_attr_t attr;\n    int ret = pthread_attr_init(&attr);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);      \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    pthread_t tid;\n    ret = pthread_create(&tid, &attr, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    ret = pthread_attr_destroy(&attr);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_destroy error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    ret = pthread_join(tid, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_join error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <errno.h>\n\nvoid* thread_fun(void *arg)\n{   \n    while(1)\n    {\n        printf(\"thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n        sleep(1);\n    }\n    \n    return NULL;\n}\n\nint main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error:%s\\n\", strerror(errno));\n        exit(1);\n    }\n\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    sleep(5);\n    ret = pthread_cancel(tid);          \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_cancel error:%s\\n\", strerror(errno));\n        exit(1);\n    }\n    \n    while(1);\n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <errno.h>\n\nvoid* thread_fun1(void *arg)\n{   \n    printf(\"thread 1 return\\n\");\n    return (void*)111;\n}\n\nvoid* thread_fun2(void *arg)\n{   \n    printf(\"thread 2 return\\n\");\n    pthread_exit((void*)222);\n}\n\nvoid* thread_fun3(void *arg)\n{   \n    \n\n    \n\n    \n   \n    return (void*)666;\n}\n\nint main()\n{\n    pthread_t tid;\n    void *retval = NULL;\n\n    pthread_create(&tid, NULL, thread_fun1, NULL);\n    pthread_join(tid, &retval);\n    printf(\"thread 1 exit code = %d\\n\\n\", (int)retval);\n\n    pthread_create(&tid, NULL, thread_fun2, NULL);\n    pthread_join(tid, &retval);\n    printf(\"thread 2 exit code = %d\\n\\n\", (int)retval);\n\n    pthread_create(&tid, NULL, thread_fun3, NULL);\n    sleep(3);\n    pthread_cancel(tid);\n    pthread_join(tid, &retval);\n    printf(\"thread 3 exit code = %d\\n\\n\", (int)retval);     \n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid* thread_fun(void *arg)\n{\n    printf(\"thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    \n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n        sys_err(\"pthread_create error\");\n\n    sleep(1);\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid* thread_fun(void *arg)\n{\n    printf(\"thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error: %s\\n\", strerror(ret));   \n        exit(1);\n    }\n    \n    ret = pthread_detach(tid);              \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_detach error: %s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    sleep(1);\n\n    ret = pthread_join(tid, NULL);\n    \n    if(ret != 0)                                    \n    {\n        fprintf(stderr, \"pthread_join error: %s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n\n    return 0;    \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid* thread_fun(void *arg)\n{\n    int i = (int)arg;\n    sleep(i);\n    if(i == 2)\n    {\n        \n        \n        pthread_exit(NULL);\n    }\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}\n\nint main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)i);\n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n\n    \n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n\n    \n    pthread_exit(NULL);     \n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n\nstruct thrd\n{\n    int var;\n    char str[256];\n};\n\nvoid sys_err(const char *str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid* thread_fun(void *arg)\n{\n    struct thrd *tval;\n    tval = malloc(sizeof(struct thrd));\n    tval->var = 100;\n    strcpy(tval->str, \"hello thread\");\n\n    return (void *)tval;\n}\n\nint main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n        sys_err(\"pthread_create error\");\n    \n    struct thrd *retval;\n    ret = pthread_join(tid, (void**)&retval);\n    if(ret != 0)\n        sys_err(\"pthread join error\");\n\n    printf(\"child thread exit with var = %d, str = %s\\n\", retval->var, retval->str);\n\n    pthread_exit(NULL);\n}"}
{"target":"haon1026","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <pthread.h>\n\nvoid *fun(void *arg)\n{\n    srand(time(NULL));\n\n    while (1)\n    {\n        printf(\"hello \");\n        sleep(rand()%3);    \n        printf(\"world\\n\");\n        sleep(rand()%3);\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    srand(time(NULL));\n    pthread_t tid;\n\n    pthread_create(&tid, NULL, fun, NULL);\n    while (1)\n    {\n        printf(\"HELLO \");\n        sleep(rand()%3);\n        printf(\"WORLD\\n\");\n        sleep(rand()%3);\n    }\n    pthread_join(tid, NULL);\n    return 0;\n}"}
{"target":"haon1026","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <pthread.h>\n\npthread_mutex_t mutex;  \n\nvoid *fun(void *arg)\n{\n    srand(time(NULL));\n\n    while (1)\n    {\n        pthread_mutex_lock(&mutex);     \n        printf(\"hello \");\n        sleep(rand()%3);    \n        printf(\"world\\n\");\n        pthread_mutex_unlock(&mutex);   \n        sleep(rand()%3);\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    srand(time(NULL));\n    pthread_t tid;\n\n    int ret = pthread_mutex_init(&mutex, NULL);     \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_mutex_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n\n    pthread_create(&tid, NULL, fun, NULL);\n    while (1)\n    {\n        pthread_mutex_lock(&mutex);     \n        printf(\"HELLO \");\n        sleep(rand()%3);\n        printf(\"WORLD\\n\");\n        pthread_mutex_unlock(&mutex);   \n        sleep(rand()%3);\n    }\n    pthread_join(tid, NULL);\n    pthread_mutex_destroy(&mutex);      \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n\n#define N 1\n\nint main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDONLY);\n    if(fd1 < 0)\n    {\n        perror(\"file1 open error\");\n        exit(1);\n    }\n\n    int fd2 = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0644);\n    if(fd2 < 0)\n    {\n        perror(\"file2 open error\");\n        exit(1);\n    }\n\n    char buf[N];\n    int n;\n    while((n = read(fd1, buf, N)) != 0)\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            break;\n        }\n        write(fd2, buf, N);\n    }\n\n    close(fd1);\n    close(fd2);\n    return 0;\n}\n\n\n\n\n"}
{"target":"haon1026","func":"\n\n#define _XOPEN_SOURCE 500     \n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint counter;\npthread_rwlock_t rwlock;\n\n\nvoid *thread_write(void *arg)\n{\n    int t;\n    int i = (int)arg;\n    while(1)\n    {\n        pthread_rwlock_wrlock(&rwlock);     \n        t = counter;\n        usleep(1000);       \n        printf(\"write %d:%lu: counter=%d ++counter=%d\\n\", i, pthread_self(), t, ++counter);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(10000);\n    }\n    return NULL;\n}\n\nvoid *thread_read(void *arg)\n{\n    int i = (int)arg;\n    while(1)\n    {\n        pthread_rwlock_wrlock(&rwlock);     \n        printf(\"read %d:%lu: counter=%d\\n\", i, pthread_self(), counter);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(2000);\n    }\n    return NULL;\n}\n\nint main()\n{\n    pthread_t tid[8];\n    pthread_rwlock_init(&rwlock, NULL);\n\n    int i;\n    for(i = 0; i < 3; i++)\n        pthread_create(&tid[i], NULL, thread_write, (void*)i);\n    \n    for(i = 0; i < 5; i++)\n        pthread_create(&tid[i+3], NULL, thread_read, (void*)i);\n    \n    for(i = 0; i < 8; i++)\n        pthread_join(tid[i], NULL);\n\n    pthread_rwlock_destroy(&rwlock);\n\n    return 0;\n}\n\n"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#define NUM 5\nint queue[NUM];                        \nsem_t blank_number;                     \nsem_t product_number;                   \nint i = 0;\n\nvoid *product(void *arg)\n{\n    int i = 0;\n    while(1)\n    {\n        sem_wait(&blank_number);                    \n        queue[i] = rand() % 1000 + 1;              \n        printf(\"-----Produce %d\\n\", queue[i]);                     \n\n        sem_post(&product_number);     \n        i = (i+1) % NUM;                    \n\n        sleep(rand()%1);\n    }\n}\n\nvoid *comsumer(void *arg)\n{\n    while(1)\n    {\n        sem_wait(&product_number);                 \n        printf(\"Comsume:%lu queue[%d]=%d\\n\", pthread_self(), i, queue[i]);           \n        queue[i] = 0;                                                 \n        sem_post(&blank_number);     \n        i = (i+1) % NUM;                                       \n        \n        sleep(rand()%2);\n    }\n}\n\nint main()\n{\n    srand(time(NULL));\n    pthread_t cid[5], pid;\n\n    sem_init(&blank_number, 0, NUM);            \n    sem_init(&product_number, 0, 0);            \n\n    pthread_create(&pid, NULL, product, NULL);\n    for(int i = 0; i < 5; i++)\n    {\n        pthread_create(&cid[i], NULL, comsumer, NULL);\n    }\n\n    pthread_join(pid, NULL);\n    for(int i = 0; i < 5; i++)\n    {\n        pthread_join(cid[i], NULL);\n    }\n\n    sem_destroy(&blank_number);\n    sem_destroy(&product_number);\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nint main()\n{\n    pid_t pid;\n    if((pid = fork()) < 0)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        sleep(5);\n        printf(\"Child process PID is %d\\n\", getpid());\n        printf(\"Group ID of child is %d\\n\", getpgid(0));\n        printf(\"Session ID of child is %d\\n\", getsid(0));\n\n        sleep(10);\n        setsid();           \n\n        printf(\"Changed:\\n\");\n\n        printf(\"Child process PID is %d\\n\", getpid());\n        printf(\"Group ID of child is %d\\n\", getpgid(0));\n        printf(\"Session ID of child is %d\\n\", getsid(0));\n\n        sleep(10);\n    }\n\n    sleep(5);       \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <sys\/time.h>\n#include <signal.h>\n\nvoid myfunc(int signo)\n{\n    printf(\"hello world\\n\");\n}\n\nint main()\n{\n    struct itimerval newit, oldit;\n\n    signal(SIGALRM, myfunc);\n\n    newit.it_value.tv_sec = 2;\n    newit.it_value.tv_usec = 0;\n\n    newit.it_interval.tv_sec = 5;\n    newit.it_interval.tv_usec = 0;\n\n    if(setitimer(ITIMER_REAL, &newit, &oldit) == -1)\n    {\n        perror(\"setitimer error\");\n        return -1;\n    }\n    while(1);\n    \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#define _POSIX_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n\nvoid sys_err(const char* str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid sig_catch(int signo)           \n{\n    if(signo == SIGINT)\n    {\n        printf(\"catch SIGINT!!! %d\\n\", signo);\n        sleep(10);\n    }\n    else if(signo == SIGBUS)\n        printf(\"catch SIGBUS!!! %d\\n\", signo);\n    return;\n}\n\nint main()\n{\n    struct sigaction act, oldact;\n\n    act.sa_handler = sig_catch;         \n    sigemptyset(&act.sa_mask);          \n    act.sa_flags = 0;                   \n\n    int ret = sigaction(SIGINT, &act, &oldact);     \n    if(ret == -1)\n        sys_err(\"sigaction error\");\n    \n    ret = sigaction(SIGBUS, &act, &oldact);\n    if(ret == -1)\n        sys_err(\"sigaction error\");\n\n    while(1);\n    \n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#define _POSIX_SOURCE\n\n#include <sys\/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n\nvoid sys_err(const char* str)\n{\n    perror(str);\n    exit(1);\n}\n\nvoid print_set(sigset_t *pset)\n{\n    for(int i = 1; i < 32; i++)\n    {\n        if(sigismember(pset, i))\n            putchar('1');\n        else\n            putchar('0');\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGINT);\n    sigaddset(&set, SIGQUIT);\n    sigaddset(&set, SIGKILL);   \n    sigaddset(&set, SIGBUS);\n\n    sigset_t oldset;\n    int ret = sigprocmask(SIG_BLOCK, &set, &oldset);\n    if(ret == -1)\n        sys_err(\"sigprocmask error\");\n    \n    sigset_t pendset;\n    while(1)\n    {\n        ret = sigpending(&pendset);\n        if(ret == -1)\n            sys_err(\"sigpending error\");\n\n        print_set(&pendset);\n        sleep(1);\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/stat.h>\n\nint main(int argc, char *argv[])\n{\n    struct stat buf;\n    \n    int ret = lstat(argv[1], &buf);\n    if(ret == -1)\n    {\n        perror(\"stat error\");\n        exit(1);\n    }\n\n    printf(\"file size:%d\\n\", buf.st_size);\n    printf(\"inode number:%d\\n\", buf.st_ino);\n\n    if(S_ISREG(buf.st_mode))\n        printf(\"%s is a regular file\\n\", argv[1]);\n    else if(S_ISDIR(buf.st_mode))\n        printf(\"%s is a directory\\n\", argv[1]);\n    else if(S_ISLNK(buf.st_mode))\n        printf(\"%s is a symbolic link\\n\", argv[1]);      \n    \n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"temp.txt\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open temp error\");\n        exit(1);\n    }\n\n    int ret;\n    ret = unlink(\"temp.txt\");       \n    if(ret < 0)\n    {\n        perror(\"unlink error\");\n        exit(1);\n    }\n\n    char *p1 = \"test of unlink\\n\";\n    char *p2 = \"after write something\\n\";\n    ret = write(fd, p1, strlen(p1));\n    if(ret == -1)\n        perror(\"write error\");\n\n    printf(\"write ok\\n\");\n    ret = write(fd, p2, strlen(p2));\n    if(ret == -1)\n        perror(\"write error\");\n\n    printf(\"Enter any key continue\\n\");\n    getchar();\n\n    \n\n    close(fd);\n\n    \n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nint main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"I'm child, pid = %d, going to sleep 10s\\n\", getpid());\n        sleep(10);\n        printf(\"--------child die---------\\n\");\n    }\n    else if(pid > 0)\n    {\n        int wpid;\n        int status;\n        \n        wpid = wait(&status);       \n        if(wpid == -1)\n        {\n            perror(\"wait error\");\n            exit(1);\n        }\n        if(WIFEXITED(status))       \n        {\n            printf(\"child exit with %d\\n\", WEXITSTATUS(status));\n        }\n        if(WIFSIGNALED(status))     \n        {  \n            printf(\"child bekill with signal %d\\n\", WTERMSIG(status));\n        }\n        printf(\"-----parent wait child %d finish-----\\n\", wpid);\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nint main()\n{\n    int i;\n    pid_t wpid, temp;\n    for(i = 0; i < 5; i++)\n    {\n        temp = fork();\n        if(temp == 0)\n            break;\n    }\n\n    if(i == 5)\n    {\n        \n\n        while((wpid = waitpid(-1, NULL, WNOHANG)) != -1)        \n        {\n            if(wpid > 0)\n            {\n                printf(\"wait child pid = %d\\n\", wpid);\n            }\n            else if(wpid == 0)\n            {\n                \n            }\n            \n        }\n    }\n    else\n    {\n        sleep(i);\n        printf(\"I'm %dth child, pid = %d\\n\", i+1, getpid());\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n\nint main()\n{\n    int i;\n    pid_t pid, wpid, temp;\n    for(i = 0; i < 5; i++)\n    {\n        temp = fork();\n        if(temp == 0)\n            break;\n        \n        if(i == 2)\n        {\n            pid = temp;\n            printf(\"2th child pid = %d\\n\", pid);\n        }\n    }\n\n    if(i == 5)\n    {\n        sleep(5);\n        \n        wpid = waitpid(pid, NULL, WNOHANG);         \n        if(wpid == -1)\n        {\n            perror(\"waitpid error\");\n            exit(1);\n        }\n        printf(\"I'm parent, wait a child finish : %d\\n\", wpid);\n    }\n    else\n    {\n        sleep(i);\n        printf(\"I'm %dth child, pid = %d\\n\", i+1, getpid());\n    }\n\n    return 0;\n}"}
{"target":"haon1026","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys\/types.h>\n\nint main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"I'm child, my parent pid = %d, going to sleep 10s\\n\", getppid());\n        sleep(10);\n        printf(\"--------child die---------\\n\");\n    }\n    else if(pid > 0)\n    {\n        while(1)\n        {\n            printf(\"I'm parent, pid = %d, myson = %d\\n\", getpid(), pid);\n            sleep(1);\n        }\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n, qtd = 2, idade, maior, menor;\n\n    printf(\"\\nInforme a quantidade de idades: \");\n    scanf(\"%i\", &n);\n\n    printf(\"\\nInforme a 1\u00aa idade: \");\n    scanf(\"%i\", &idade);\n\n    maior = idade;\n    menor = idade;\n\n    for (int i = 0; i < (n - 1); i++)\n    {\n        printf(\"\\nInforme a %i\u00aa idade: \", qtd);\n        scanf(\"%i\", &idade);\n        qtd++;\n\n        if (idade > maior)\n        {\n            maior = idade;\n        }\n\n        else if (idade < menor)\n        {\n            menor = idade;\n        }\n    }\n\n    printf(\"\\nMaior idade: %i\", maior);\n    printf(\"\\nMenor idade: %i\\n\\n\", menor);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nint main()\n{\n    float v0, alfa, g = 10, x, y, t_queda, x_max;\n    int t;\n\n    printf(\"\\nInforme a velocidade inicial em m\/s: \");\n    scanf(\"%f\", &v0);\n    printf(\"\\nInforme o \u00e2ngulo do lan\u00e7amentos em graus: \");\n    scanf(\"%f\", &alfa);\n\n    alfa = alfa * 3.14 \/ 180;\n\n    t_queda = (2 * v0 * sin(alfa)) \/ g;\n    x_max = (pow(v0, 2) * sin(alfa * 2)) \/ g;\n\n    printf(\"\\n\");\n\n    for (t = 0; t <= fabs(t_queda); t++)\n    {\n        x = v0 * cos(alfa) * t;\n        y = v0 * sin(alfa) * t - 0.5 * g * pow(t, 2);\n\n        printf(\"t = %is: Altura = %.2fm, Alcance = %.2fm\\n\", t, y, x);\n\n        sleep(1);\n    }\n\n    printf(\"t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n\", t++, x_max);\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define tamanho 10\n\nint main(void)\n{\n    int vetor[tamanho], aux, i = 0, k = 0, maior, menor, indice_maior[tamanho], indice_menor[tamanho];\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (int a = 0; a < tamanho; a++)\n    {\n        scanf(\"%i\", &vetor[a]);\n        if (a == 0)\n        {\n            maior = vetor[a];\n            indice_maior[i] = a;\n            menor = vetor[a];\n            indice_menor[k] = a;\n        }\n        else\n        {\n            if (vetor[a] > maior)\n            {\n                maior = vetor[a];\n                for (int j = 0; j < tamanho; j++)\n                {\n                    indice_maior[j] = 0;\n                }\n                i = 0;\n                indice_maior[i] = a;\n            }\n            else if (vetor[a] == maior)\n            {\n                i++;\n                indice_maior[i] = a;\n            }\n            else if (vetor[a] < menor)\n            {\n                menor = vetor[a];\n                for (int l = 0; l < tamanho; l++)\n                {\n                    indice_menor[l] = 0;\n                }\n                k = 0;\n                indice_menor[k] = a;\n            }\n            else if (vetor[a] == menor)\n            {\n                k++;\n                indice_menor[k] = a;\n            }\n        }\n    }\n\n    if (k != 0)\n    {\n        printf(\"\\nMenor = indices \");\n        for (int c = 0; c <= k; c++)\n        {\n            if (c == k)\n            {\n                printf(\"%i. \", indice_menor[c]);\n            }\n            else\n            {\n                printf(\"%i, \", indice_menor[c]);\n            }\n        }\n        printf(\"com valor %i\", menor);\n    }\n    else if (k == 0)\n    {\n        printf(\"\\nMenor = indice %i com valor %i\", indice_menor[k], menor);\n    }\n\n    if (i != 0)\n    {\n        printf(\"\\nMaior = indices \");\n        for (int b = 0; b <= i; b++)\n        {\n            if (b == i)\n            {\n                printf(\"%i. \", indice_maior[b]);\n            }\n            else\n            {\n                printf(\"%i, \", indice_maior[b]);\n            }\n        }\n        printf(\"com valor %i\", maior);\n    }\n    else if (i == 0)\n    {\n        printf(\"\\nMaior = indice %i com valor %i\", indice_maior[i], maior);\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int matriz[4][4];\n    int soma = 0;\n    system(\"clear\");\n    printf(\"Informe os elementos(int) de uma matriz 4x4:\\n\");\n\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n            if (i == j)\n            {\n                soma += matriz[i][j];\n            }\n        }\n    }\n\n    system(\"clear\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%3i\", matriz[i][j]);\n            if (j == 3)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\nA soma dos elementos da diagonal principal \u00e9: %d\\n\\n\", soma);\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int hora_inicio, minuto_inicio, hora_fim, minuto_fim, minuto_total_inicio, minuto_total_fim, res_minuto, duracao_hora, duracao_minuto;\n\n    scanf(\"%i\", &hora_inicio);\n    scanf(\"%i\", &minuto_inicio);\n    scanf(\"%i\", &hora_fim);\n    scanf(\"%i\", &minuto_fim);\n\n    minuto_total_inicio = (hora_inicio * 60) + minuto_inicio;\n    minuto_total_fim = (hora_fim * 60) + minuto_fim;\n\n    res_minuto = minuto_total_fim - minuto_total_inicio;\n\n    duracao_hora = res_minuto \/ 60;\n    duracao_minuto = res_minuto % 60;\n\n    printf(\"\\n\\n\");\n    if (duracao_hora < 10)\n    {\n        printf(\"0%d\", duracao_hora);\n    }\n    else\n    {\n        printf(\"%d\", duracao_hora);\n    }\n    if (duracao_minuto < 10)\n    {\n        printf(\":0%d\", duracao_minuto);\n    }\n    else\n    {\n        printf(\":%d\", duracao_minuto);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char str[10];\n    int tam, valor, num = false;\n    while (num == false)\n    {\n        puts(\"\\nInforme um n\u00famero:\");\n        scanf(\"%s\", str);\n        getchar();\n\n        tam = strlen(str);\n        valor = atoi(str);\n        \n\n        if ((pow(10, (tam - 1))) <= valor)\n        {\n            num = true;\n        }\n\n        else if (num == false)\n        {\n            system(\"clear\");\n            puts(\"\\nN\u00famero inv\u00e1lido, digite novamente!\");\n        }\n    }\n\n    puts(\"\\nO n\u00famero \u00e9 de fato um n\u00famero\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    char matriz[3][5];\n\n    system(\"clear\");\n\n    printf(\"informe os elementos(char) de uma matriz 3x5:\\n\");\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            scanf(\"%c\", &matriz[i][j]);\n            getchar();\n        }\n    }\n\n    system(\"clear\");\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%2c\", matriz[i][j]);\n            if (j == 4)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%2c\", matriz[j][i]);\n            if (j == 2)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n, i, j, multiplo = 0;\n\n    printf(\"\\nInforme os n\u00fameros inteiros positivos 'n','i' e 'j'.\\nOnde 'n' ser\u00e1 a quantidade de n\u00fameros em ordem crescentes,\\nque sejam m\u00faltiplos de 'i' ou de 'j' ou de ambos.\\n\");\n    printf(\"\\nInforme 'n': \");\n    scanf(\"%i\", &n);\n    printf(\"\\nInforme 'i': \");\n    scanf(\"%i\", &i);\n    printf(\"\\nInforme 'j': \");\n    scanf(\"%i\", &j);\n    printf(\"\\n\");\n\n    for (int qtd = 0; qtd < n;)\n    {\n        if (((multiplo % i) == 0) || ((multiplo % j) == 0))\n        {\n            if (qtd == (n - 1))\n            {\n                printf(\"%i.\", multiplo);\n            }\n\n            else\n            {\n                printf(\"%i,\", multiplo);\n            }\n\n            qtd++;\n        }\n\n        multiplo++;\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define tamanho 5\n\nint main(void)\n{\n    int a[tamanho], b[tamanho], aux;\n\n    printf(\"\\nInforme os n\u00fameros do vetor A:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &a[i]);\n    }\n\n    printf(\"\\nInforme os n\u00fameros do vetor B:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &b[i]);\n    }\n\n    for (int j = 0; j < tamanho; j++)\n    {\n        aux = a[j];\n        a[j] = b[j];\n        b[j] = aux;\n    }\n\n    printf(\"\\nVetor A: \");\n    for (int k = 0; k < tamanho; k++)\n    {\n        printf(\"%i \", a[k]);\n    }\n\n    printf(\"\\nVetor B: \");\n    for (int k = 0; k < tamanho; k++)\n    {\n        printf(\"%i \", b[k]);\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}\n"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char frase[200], termo[200];\n    int i = 0, tam_frase, tam_termo, busca = false, indice;\n    puts(\"\\nInforme uma frase:\");\n    scanf(\"%[^\\n]s\", frase);\n    getchar();\n    puts(\"\\nInforme um termo:\");\n    scanf(\"%[^\\n]s\", termo);\n\n    tam_frase = strlen(frase);\n    tam_termo = strlen(termo);\n\n    if (tam_frase >= tam_termo)\n    {\n        for (int i = 0; i < tam_frase; i++)\n        {\n            if ((frase[i] == termo[0]) && (busca == false))\n            {\n                busca = true;\n                indice = i;\n                for (int j = 0; j < tam_termo; j++)\n                {\n                    if ((frase[i + j] != termo[j]) && (busca == true))\n                    {\n                        busca = false;\n                    }\n                }\n            }\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"\\nTermo encontrado, iniciando-se na posi\u00e7\u00e3o %i\\n\\n\", indice + 1);\n    }\n    else if (busca == false)\n    {\n        puts(\"\\nTermo n\u00e3o encontrado na frase\\n\");\n    }\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    char nomes1[4][10], nomes2[4][10], quadrilha[4][2][10];\n\n    system(\"clear\");\n    printf(\"Informe os primeiros 4 nomes (sem acentua\u00e7\u00e3o):\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        scanf(\"%10[^\\n]s\", nomes1[i]);\n        getchar();\n    }\n    printf(\"\\nInforme os \u00faltimos 4 nomes (sem acentua\u00e7\u00e3o):\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        scanf(\"%10[^\\n]s\", nomes2[i]);\n        getchar();\n    }\n\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            if (j == 0)\n            {\n                strcpy(quadrilha[i][j], nomes1[i]);\n            }\n            else if (j == 1)\n            {\n                strcpy(quadrilha[i][j], nomes2[i]);\n            }\n        }\n    }\n\n    system(\"clear\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\" %-10s \", quadrilha[i][j]);\n            if (j == 1)\n            {\n                printf(\"|\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define tamanho 32\n\nint main()\n{\n    int vetor[tamanho];\n    int qtd1 = 0, qtd0, i, j;\n\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &vetor[i]);\n    }\n\n    for (i = 0; i < tamanho; i++)\n    {\n        if (vetor[i] != 0)\n        {\n            vetor[i] = 1;\n            qtd1++;\n        }\n    }\n\n    qtd0 = tamanho - qtd1;\n\n    printf(\"\\nVetor: \");\n    for (j = 0; j < tamanho; j++)\n    {\n        printf(\"%i \", vetor[j]);\n    }\n\n    printf(\"\\nQuantidade de zeros: %i\\nQuantidade de uns: %i\\n\\n\", qtd0, qtd1);\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char frase[200], termo[200];\n    int i, j, tam_frase, tam_termo, busca = false, indice;\n    puts(\"\\nInforme uma frase:\");\n    scanf(\"%[^\\n]s\", frase);\n    getchar();\n    puts(\"\\nInforme um termo:\");\n    scanf(\"%[^\\n]s\", termo);\n\n    tam_frase = strlen(frase);\n    tam_termo = strlen(termo);\n\n    if (tam_frase >= tam_termo)\n    {\n        for (int i = 0; i < tam_frase; i++)\n        {\n            if ((frase[i] == termo[0]) && (busca == false))\n            {\n                busca = true;\n                indice = i;\n                for (int j = 0; j < tam_termo; j++)\n                {\n                    if ((frase[i + j] != termo[j]) && (busca == true))\n                    {\n                        busca = false;\n                    }\n                }\n            }\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"\\n\");\n        for (int k = 0; k < indice; k++)\n        {\n            printf(\"%c\", frase[k]);\n        }\n        for (int l = (indice + (tam_termo)); l < tam_frase; l++)\n        {\n            printf(\"%c\", frase[l]);\n        }\n        printf(\"\\n\");\n    }\n    else if (busca == false)\n    {\n        puts(\"\\nTermo n\u00e3o encontrado na frase\\n\");\n    }\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int restaurante[8][4];\n    int cadeira = 1;\n\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            switch (j)\n            {\n            case 0:\n                restaurante[i][j] = cadeira;\n                break;\n            case 1:\n                restaurante[i][j] = cadeira + 1;\n                break;\n            case 2:\n                restaurante[i][j] = cadeira + 4;\n                break;\n            case 3:\n                restaurante[i][j] = cadeira + 5;\n                break;\n            }\n        }\n        if ((i % 2) == 0)\n        {\n            cadeira += 2;\n        }\n        else\n        {\n            cadeira += 6;\n        }\n    }\n\n    system(\"clear\");\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            printf(\"%3i\", restaurante[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int matriz[4][4];\n\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n\n    printf(\"\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j > i)\n            {\n                printf(\" 0 \");\n            }\n            else\n            {\n                printf(\"%2i \", matriz[i][j]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    float a, b, c, x1, x2, x, delta, real, im1, im2;\n\n    printf(\"\\nDe acordo com o modelo de equa\u00e7\u00e3o: ax\u00b2+bx+c\\n\\n\");\n    printf(\"Informe 'a': \");\n    scanf(\"%f\", &a);\n    printf(\"Informe 'b': \");\n    scanf(\"%f\", &b);\n    printf(\"Informe 'c': \");\n    scanf(\"%f\", &c);\n\n    delta = pow(b, 2) - 4 * a * c;\n\n    if (delta == 0)\n    {\n        x = (-b) \/ (2 * a);\n\n        printf(\"\\nA equa\u00e7\u00e3o tem raiz dupla\\nx = %.2f\\n\\n\", x);\n    }\n\n    else if (delta < 0)\n    {\n        delta = -delta;\n        real = (-b) \/ (2 * a);\n        im1 = sqrt(delta) \/ (2 * a);\n        im2 = (-sqrt(delta)) \/ (2 * a);\n\n        printf(\"\\nA equa\u00e7\u00e3o tem raiz imagin\u00e1ria\\nParte real = %.2f\\nParte imagin\u00e1ria = %.2fi e %.2fi\\n\\n\", real, im1, im2);\n    }\n\n    else\n    {\n        x1 = (-b + sqrt(delta)) \/ (2 * a);\n        x2 = (-b - sqrt(delta)) \/ (2 * a);\n\n        printf(\"\\nA equa\u00e7\u00e3o tem raizes reais\\nx1 = %.2f\\nx2 = %.2f\\n\\n\", x1, x2);\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define tamanho 10\n\nint main(void)\n{\n    float vetor[tamanho], aux;\n    int j = tamanho - 1;\n\n    printf(\"Informe os n\u00fameros do vetor:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%f\", &vetor[i]);\n    }\n\n    for (int i = 0; i < (tamanho \/ 2); i++)\n    {\n        aux = vetor[i];\n        vetor[i] = vetor[j];\n        vetor[j] = aux;\n        j--;\n    }\n\n    printf(\"\\nVetor: \");\n    for (int i = 0; i < tamanho; i++)\n    {\n        printf(\"%.2f \", vetor[i]);\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n    char nome1[100], sobrenome1[100], nome2[100], sobrenome2[100], sobrenome2_2[100];\n    int i1, j1, i2, j2, i1_2, tam_sobrenome1, tam_sobrenome2;\n\n    printf(\"\\nInforme o 1\u00ba nome: \");\n    scanf(\"%[^\\n]s\", nome1);\n    getchar();\n    printf(\"\\nInforme o 1\u00ba sorenomenome: \");\n    scanf(\"%[^\\n]s\", sobrenome1);\n    getchar();\n    printf(\"\\nInforme o 2\u00ba nome: \");\n    scanf(\"%[^\\n]s\", nome2);\n    getchar();\n    printf(\"\\nInforme o 2\u00ba sobrenome: \");\n    scanf(\"%[^\\n]s\", sobrenome2);\n    getchar();\n\n    strcpy(sobrenome2_2, sobrenome2);\n\n    tam_sobrenome1 = strlen(sobrenome1);\n    i1 = tam_sobrenome1;\n    while (sobrenome1[i1] != ' ')\n    {\n        i1--;\n    }\n    i1_2 = i1 + 1;\n\n    tam_sobrenome2 = strlen(sobrenome2);\n    j1 = 0;\n    while (sobrenome2[j1] != ' ')\n    {\n        j1++;\n    }\n\n    for (int k = (j1 + 1); k <= (j1 + i1); k++)\n    {\n        sobrenome2[k] = sobrenome1[i1_2];\n        i1_2++;\n    }\n\n    printf(\"\\n%s %s e %s %s.\\nAp\u00f3s casados se chamar\u00e3o:\\n%s %s e %s %s\\n\\n\",\n           nome1, sobrenome1, nome2, sobrenome2_2, nome1, sobrenome2, nome2, sobrenome2);\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define tamanho 20\n#define true 1\n#define false 0\n\nint main(void)\n{\n    int vetor[tamanho], aux, pivo, n, busca = false;\n\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &vetor[i]);\n        for (int j = i; j > 0; j--)\n        {\n            if (vetor[j] < vetor[j - 1])\n            {\n                aux = vetor[j];\n                vetor[j] = vetor[j - 1];\n                vetor[j - 1] = aux;\n            }\n        }\n    }\n\n    printf(\"\\nVetor: \");\n    for (int i = 0; i < tamanho; i++)\n    {\n        printf(\"%i \", vetor[i]);\n    }\n\n    pivo = tamanho \/ 2;\n\n    printf(\"\\nInforme qual n\u00famero deseja buscar no vetor: \");\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < (tamanho \/ 2); i++)\n    {\n        if (n == vetor[pivo])\n        {\n            busca = true;\n        }\n        else if (n < vetor[pivo - 1])\n        {\n            if ((pivo % 2) == 0)\n            {\n                pivo = pivo \/ 2;\n            }\n            else\n            {\n                pivo = (pivo + 1) \/ 2;\n            }\n        }\n        else if (n > vetor[pivo - 1])\n        {\n            if ((pivo % 2) == 0)\n            {\n                pivo = pivo + (pivo \/ 2);\n            }\n            else\n            {\n                pivo = pivo + ((pivo + 1) \/ 2);\n            }\n        }\n        else if (n == vetor[pivo - 1])\n        {\n            busca = true;\n        }\n    }\n\n    if (busca == true)\n    {\n        printf(\"\\nO n\u00famero est\u00e1 no vetor\\n\");\n    }\n    else\n    {\n        printf(\"\\nO n\u00famero n\u00e3o est\u00e1 no vetor\\n\");\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main()\n{\n    char frase[50], esarf[50];\n    int tam_frase, i = 0, i1, j = 0, k = 0;\n\n    printf(\"\\nInforme uma frase quanlquer:\\n\");\n    scanf(\"%[^\\n]s\", frase);\n\n    tam_frase = strlen(frase);\n    i1 = tam_frase - 1;\n\n    strcpy(esarf, frase);\n    for (int i = 0; i < tam_frase; i++)\n    {\n        esarf[i] = frase[(tam_frase - 1) - i];\n    }\n\n    while (j != (tam_frase + 1))\n    {\n        while ((j <= tam_frase) && (frase[j] != ' '))\n        {\n            j++;\n        }\n\n        for (int j1 = j; j1 < tam_frase; j1++)\n        {\n            frase[j1] = frase[j1 + 1];\n        }\n    }\n\n    while (k != (tam_frase + 1))\n    {\n        while ((k <= tam_frase) && (esarf[k] != ' '))\n        {\n            k++;\n        }\n\n        for (int k1 = k; k1 < tam_frase; k1++)\n        {\n            esarf[k1] = esarf[k1 + 1];\n        }\n    }\n\n    for (int m = 0; frase[m]; m++)\n    {\n        frase[m] = tolower(frase[m]);\n    }\n    for (int n = 0; esarf[n]; n++)\n    {\n        esarf[n] = tolower(esarf[n]);\n    }\n\n    if (strcmp(frase, esarf) == 0)\n    {\n        printf(\"\\nA Frase \u00e9 um pal\u00edndromo.\\n\\n\");\n    }\n    else\n    {\n        printf(\"\\nA Frase n\u00e3o \u00e9 um pal\u00edndromo.\\n\\n\");\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n;\n    float nota, notafinal = 0, denominador = 0, fator, notamedia;\n\n    printf(\"\\nInforme a quantidade de notas do aluno: \");\n    scanf(\"%i\", &n);\n\n    for (int qtd = 1; qtd <= n; qtd++)\n    {\n        printf(\"\\nInforme a %i\u00aa nota: \", qtd);\n        scanf(\"%f\", &nota);\n\n        if ((qtd % 2) == 0)\n        {\n            fator = 3;\n            nota = fator * nota;\n        }\n\n        else\n        {\n            fator = 2;\n            nota = fator * nota;\n        }\n\n        notafinal = notafinal + nota;\n        denominador = denominador + fator;\n    }\n\n    notamedia = notafinal \/ denominador;\n    printf(\"\\nNota m\u00e9dia = %.2f\\n\\n\", notamedia);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n;\n    float nota, notafinal = 0, denominador = 0, fator, notamedia;\n\n    printf(\"\\nInforme a quantidade de notas do aluno: \");\n    scanf(\"%i\", &n);\n\n    for (int qtd = 1; qtd <= n; qtd++)\n    {\n        printf(\"\\nInforme a %i\u00aa nota: \", qtd);\n        scanf(\"%f\", &nota);\n\n        if ((qtd % 2) == 0)\n        {\n            fator = 3;\n            nota = fator * nota;\n        }\n\n        else\n        {\n            fator = 2;\n            nota = fator * nota;\n        }\n\n        notafinal = notafinal + nota;\n        denominador = denominador + fator;\n    }\n\n    notamedia = notafinal \/ denominador;\n    printf(\"\\nNota m\u00e9dia = %.2f\\n\", notamedia);\n\n    if (notamedia < 5)\n    {\n        printf(\"\\nAluno reprovado!\\n\\n\");\n    }\n\n    else if ((notamedia >= 5) && (notamedia < 6))\n    {\n        printf(\"\\nAluno em recupera\u00e7\u00e3o!\\n\\n\");\n    }\n\n    else\n    {\n        printf(\"\\nAluno aprovado!\\n\\n\");\n\n        if ((notamedia >= 8) && (notamedia < 10))\n        {\n            printf(\"Parab\u00e9ns!\\n\\n\");\n        }\n\n        else if (notamedia == 10)\n        {\n            printf(\"Sensacional!\\n\\n\");\n        }\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    system(\"clear\");\n\n    int n;\n    float saldo = 1000, x, y;\n\n    printf(\"########################\\n\");\n    printf(\"# 1 - Saque            #\\n\");\n    printf(\"# 2 - Dep\u00f3sito         #\\n\");\n    printf(\"# 3 - Sair do programa #\\n\");\n    printf(\"########################\\n\");\n    printf(\"Saldo: R$%.2f\\n\", saldo);\n    printf(\"Fa\u00e7a sua escolha: \");\n\n    scanf(\"%i\", &n);\n\n    system(\"clear\");\n\n    while (n != 3)\n    {\n        system(\"clear\");\n\n        switch (n)\n        {\n        case 1:\n            printf(\"SAQUE:\\n\");\n            printf(\"\\nDigite quantos reais deseja sacar: \");\n            scanf(\"%f\", &x);\n\n            saldo = saldo - x;\n\n            break;\n\n        case 2:\n            system(\"clear\");\n\n            printf(\"DEP\u00d3SITO:\\n\");\n            printf(\"\\nDigite quantos reais deseja depositar: \");\n            scanf(\"%f\", &y);\n\n            saldo = saldo + y;\n\n            break;\n        }\n\n        system(\"clear\");\n\n        printf(\"########################\\n\");\n        printf(\"# 1 - Saque            #\\n\");\n        printf(\"# 2 - Dep\u00f3sito         #\\n\");\n        printf(\"# 3 - Sair do programa #\\n\");\n        printf(\"########################\\n\");\n        printf(\"Saldo: R$%.2f\\n\", saldo);\n        printf(\"Fa\u00e7a sua escolha: \");\n\n        scanf(\"%i\", &n);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#define n 5\n#define m 5\n#define true 1\n#define false 0\n\nint main()\n{\n    char entrada[100];\n    int string;\n    int matriz_final[n][m];\n    char matriz_entrada[n][m];\n    int linha, coluna, random_bomb, menu, menu2, menu3, menu12, menu13;\n    int mapa = false, instrucoes = false, creditos = false, sair = false;\n    int qtd_bombas, random;\n    random = (n + m) \/ 3;\n\n    while (sair == false)\n    {\n        system(\"clear\");\n        printf(\"\\tBem vindo ao gerador de mapa de campo minado.\\n\\n\\t(1) Iniciar\\n\\t(2) Instru\u00e7\u00f5es\\n\\t(3) Cr\u00e9ditos\\n\\t(4) Sair\\n\\t \");\n        scanf(\"%d\", &menu);\n        getchar();\n        system(\"clear\");\n\n        switch (menu)\n        {\n        case 1:\n            mapa = true;\n            while (mapa == true)\n            {\n                printf(\"\\t(1) Gerador de mapa manual\\n\\t(2) Gerador de mapa rand\u00f4mico\\n\\t \");\n                scanf(\"%d\", &menu12);\n                getchar();\n                switch (menu12)\n                {\n                case 1:\n                    system(\"clear\");\n                    for (int i = 0; i < n; i++)\n                    {\n                        do\n                        {\n                            printf(\"Informe as %d linhas da matriz com %d elementos v\u00e1lidos,\\nou seja 'X' para bomba e 'L' para n\u00e3o bomba,\\nos elementos dever\u00e3o ser inseridos sem espa\u00e7os entre eles.\\nAo fim de uma linha, pressione 'enter' para escrever a pr\u00f3xima linha.\\n\\n\", n, m);\n                            for (int j = 0; j < i; j++)\n                            {\n                                for (int k = 0; k < m; k++)\n                                {\n                                    printf(\"%c\", matriz_entrada[j][k]);\n                                }\n                                printf(\"\\n\");\n                            }\n                            setbuf(stdin, NULL);\n                            scanf(\"%s\", entrada);\n                            getchar();\n\n                            string = true;\n                            if (strlen(entrada) != m)\n                            {\n                                string = false;\n                            }\n                            for (int j = 0; j < m; j++)\n                            {\n                                if ((toupper(entrada[j]) != 'X') && (toupper(entrada[j]) != 'L'))\n                                {\n                                    string = false;\n                                }\n                            }\n                            if (string == false)\n                            {\n                                printf(\"\\nstring inv\u00e1lida\\n\");\n                                sleep(1);\n                                system(\"clear\");\n                            }\n                        } while (string == false);\n\n                        for (int j = 0; j < m; j++)\n                        {\n                            matriz_entrada[i][j] = entrada[j];\n                        }\n\n                        for (int j = 0; j < m; j++)\n                        {\n                            if (toupper(entrada[j]) == 'X')\n                            {\n                                matriz_final[i][j] = 88;\n                            }\n                            else\n                            {\n                                matriz_final[i][j] = 0;\n                            }\n                        }\n                        system(\"clear\");\n                    }\n\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            qtd_bombas = 0;\n                            if (matriz_final[i][j] != 88)\n                            {\n                                if (j != 0)\n                                {\n                                    if (matriz_final[i][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (j != (m - 1))\n                                {\n                                    if (matriz_final[i][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != 0)\n                                {\n                                    if (matriz_final[i - 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != (n - 1))\n                                {\n                                    if (matriz_final[i + 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                matriz_final[i][j] = qtd_bombas;\n                            }\n                        }\n                    }\n\n                    while (mapa == true)\n                    {\n                        linha = 0;\n                        coluna = 0;\n                        printf(\"colunas:      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"%-2i\", coluna);\n                            coluna++;\n                            printf(\"  \");\n                        }\n                        printf(\"\\n\\t      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"|   \");\n                        }\n                        printf(\"\\n\\n\");\n                        for (int i = 0; i < n; i++)\n                        {\n                            for (int j = 0; j < m; j++)\n                            {\n                                if (j == 0)\n                                {\n                                    printf(\"linha: %2i --  \", linha);\n                                    linha++;\n                                }\n                                if (matriz_final[i][j] == 88)\n                                {\n                                    printf(\"%c   \", matriz_final[i][j]);\n                                }\n                                else\n                                {\n                                    printf(\"%d   \", matriz_final[i][j]);\n                                }\n                            }\n                            printf(\"\\n\\n\");\n                        }\n\n                        printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                        scanf(\"%d\", &menu13);\n                        getchar();\n                        if (menu13 == 0)\n                        {\n                            mapa = false;\n                        }\n                        else\n                        {\n                            system(\"clear\");\n                        }\n                    }\n                    break;\n\n                case 2:\n                    system(\"clear\");\n                    srand(time(NULL));\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            random_bomb = rand() % random;\n                            if (random_bomb == 0)\n                            {\n                                matriz_final[i][j] = 88;\n                            }\n                            else\n                            {\n                                matriz_final[i][j] = 0;\n                            }\n                        }\n                    }\n\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            qtd_bombas = 0;\n                            if (matriz_final[i][j] != 88)\n                            {\n                                if (j != 0)\n                                {\n                                    if (matriz_final[i][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (j != (m - 1))\n                                {\n                                    if (matriz_final[i][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != 0)\n                                {\n                                    if (matriz_final[i - 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != (n - 1))\n                                {\n                                    if (matriz_final[i + 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                matriz_final[i][j] = qtd_bombas;\n                            }\n                        }\n                    }\n\n                    while (mapa == true)\n                    {\n                        linha = 0;\n                        coluna = 0;\n                        printf(\"colunas:      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"%-2i\", coluna);\n                            coluna++;\n                            printf(\"  \");\n                        }\n                        printf(\"\\n\\t      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"|   \");\n                        }\n                        printf(\"\\n\\n\");\n                        for (int i = 0; i < n; i++)\n                        {\n                            for (int j = 0; j < m; j++)\n                            {\n                                if (j == 0)\n                                {\n                                    printf(\"linha: %2i --  \", linha);\n                                    linha++;\n                                }\n                                if (matriz_final[i][j] == 88)\n                                {\n                                    printf(\"%c   \", matriz_final[i][j]);\n                                }\n                                else\n                                {\n                                    printf(\"%d   \", matriz_final[i][j]);\n                                }\n                            }\n                            printf(\"\\n\\n\");\n                        }\n\n                        printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                        scanf(\"%d\", &menu13);\n                        getchar();\n                        if (menu13 == 0)\n                        {\n                            mapa = false;\n                        }\n                        else\n                        {\n                            system(\"clear\");\n                        }\n                    }\n                    break;\n\n                default:\n                    system(\"clear\");\n                    break;\n                }\n            }\n            break;\n\n        case 2:\n            instrucoes = true;\n            while (instrucoes == true)\n            {\n                printf(\"\\tA matriz por padr\u00e3o tem tamanho 5x5, por\u00e9m \u00e9 poss\u00edvel mudar o tamanho da matriz,\\n\");\n                printf(\"\\talterando no inicio c\u00f3digo os valores de n (linhas) e m (colunas) no #define. Ex: '#define n 7'\\n\\n\");\n                printf(\"\\tGera\u00e7\u00e3o manual:\\n\\n\");\n                printf(\"\\tPara cada linha da matriz dever\u00e1 ser digitado uma string (sem espa\u00e7os) do tamanho do n\u00famero de colunas,\\n\");\n                printf(\"\\tEssa string dever\u00e1 conter apenas 'X' para indicar uma bomba e 'L' para indicar n\u00e3o-bomba.\\n\");\n                printf(\"\\tAp\u00f3s digitada a linha, dever\u00e1 pressionar 'enter', para poder escrever a pr\u00f3xima linha.\\n\\n\");\n                printf(\"\\tGera\u00e7\u00e3o rand\u00f4mica:\\n\\n\");\n                printf(\"\\tCaso deseja alterar a chance de que ocorra uma bomba, basta alterar a vari\u00e1vel: 'random',\\n\");\n                printf(\"\\tComo a ocorr\u00eancia de bomba \u00e9 determinada pela escolha aleat\u00f3ria de um n\u00famero de 0 at\u00e9 o random,\\n\");\n                printf(\"\\tQuanto maior for o random menor a chance de aparecer uma bomba.\\n\\n\");\n                printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                scanf(\"%d\", &menu2);\n                getchar();\n                if (menu2 == 0)\n                {\n                    instrucoes = false;\n                }\n                else\n                {\n                    system(\"clear\");\n                }\n            }\n            break;\n\n        case 3:\n            creditos = true;\n            while (creditos == true)\n            {\n                printf(\"\\tEste trabalho, o gerador de mapa de campo minado, foi feito por:\\n\\n\");\n                printf(\"\\tDarla Ellen Santos Garcez\\n\\tGustavo Cunha Lacerda\\n\\tHenrique Tavares Aguiar\\n\\n\");\n                printf(\"\\tQuando estiver pronto, digite '0' para voltar: \");\n                scanf(\"%d\", &menu3);\n                getchar();\n                if (menu3 == 0)\n                {\n                    creditos = false;\n                }\n                else\n                {\n                    system(\"clear\");\n                }\n            }\n            break;\n\n        case 4:\n            sair = true;\n            break;\n        }\n    }\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main(void)\n{\n    long int n;\n    int vf = false, qtd = 0, primo = 2;\n\n    do\n    {\n        printf(\"\\nDigite um numero natural para calcular seus fatores primos: \");\n        scanf(\"%li\", &n);\n        if (n < 0)\n        {\n            printf(\"ERRO! Favor digitar um numero natural\\n\");\n        }\n    } while (n < 0);\n\n    if (n == 0)\n    {\n        printf(\"\\nNao ha fatores primos de 0\\n\");\n    }\n    else if (n == 1)\n    {\n        printf(\"\\n1 = 1\\n\");\n    }\n    else\n    {\n        printf(\"\\n%.0li = \", n);\n        while (n > 1)\n        {\n            while (vf = false)\n            {\n                for (int i = 2; i < primo; i++)\n                {\n                    if ((primo % i) == 0)\n                    {\n                        vf = true;\n                    }\n                }\n                if (vf = false)\n                {\n                    primo++;\n                }\n            }\n            while ((n % primo) == 0)\n            {\n                n = n \/ primo;\n                qtd++;\n            }\n            if (qtd != 0)\n            {\n                printf(\"%i(%i) \", primo, qtd);\n            }\n\n            primo++;\n            vf = false;\n            qtd = 0;\n        }\n        printf(\"\\n\\n\");\n    }\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char palavra[50], tema[50], palavra_rev[50], tentativa_acerto_palavra[50], letra, voltar;\n    int menu, jogo, tam_palavra, partida, letra_certa, letra_usada;\n\n    jogo = 2;\n    while ((jogo != true) && (jogo != false))\n    {\n        system(\"clear\");\n        printf(\"\\tBem vindo ao jogo da forca!\\n\\n\");\n        printf(\"\\t(1) JOGAR\\n\");\n        printf(\"\\t(2) SAIR DO JOGO\\n\\t \");\n        scanf(\"%d\", &menu);\n\n        switch (menu)\n        {\n        case 1:\n            jogo = true;\n            break;\n        case 2:\n            jogo = false;\n        default:\n            break;\n        }\n    }\n\n    while (jogo == true)\n    {\n        char letras_erradas[12 + 1] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '\\0'}; \n\n        \n        int erros = 0, i_lerradas = 0, vitoria = 0, palavra_certa = true;\n\n        system(\"clear\");\n\n        setbuf(stdin, NULL); \n        printf(\"\\tInforme a palavra ou frase desejada:\\n\\t\");\n        scanf(\"%50[^\\n]s\", palavra);\n\n        setbuf(stdin, NULL); \n        printf(\"\\n\\tInforme o tema da palavra ou frase:\\n\\t\");\n        scanf(\"%50[^\\n]s\", tema);\n        tam_palavra = strlen(palavra);\n        palavra[tam_palavra] = '\\0';\n        for (int i = 0; palavra[i] != '\\0'; i++)\n        {\n            if (palavra[i] != ' ')\n            {\n                palavra_rev[i] = '-';\n            }\n            else\n            {\n                palavra_rev[i] = ' ';\n                vitoria++;\n            }\n        }\n        palavra_rev[tam_palavra] = '\\0';\n\n        partida = true;\n\n        while (partida == true)\n        {\n            system(\"clear\");\n            printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n            printf(\"\\tTema: %s\\n\\n\", tema);\n\n            \n            switch (erros)\n            {\n            case 0:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |                                   %s  \\n\", palavra_rev);\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            case 1:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |                                   %s  \\n\", palavra_rev);\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            case 2:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                |                  %s  \\n\", palavra_rev);\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            case 3:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/|                  %s  \\n\", palavra_rev);\n                printf(\"\\t |              \/ |\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            case 4:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/|\\\\                 %s  \\n\", palavra_rev);\n                printf(\"\\t |              \/ | \\\\ \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            case 5:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/|\\\\                 %s  \\n\", palavra_rev);\n                printf(\"\\t |              \/ | \\\\ \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/\\n\");\n                printf(\"\\t |              \/ \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                break;\n            default:\n                break;\n            }\n\n            \n            setbuf(stdin, NULL); \n            printf(\"\\t(1) Acertar a palavra\/frase (se errar \u00e9 fim de jogo)\\n\");\n            printf(\"\\t(2) Escolher uma letra\\n\\t\");\n            scanf(\"%d\", &menu);\n\n            switch (menu)\n            {\n            \n            case 1:\n\n                setbuf(stdin, NULL); \n                printf(\"\\n\\tInforme a palavra\/frase:\\n\\t\");\n                scanf(\"%50[^\\n]s\", tentativa_acerto_palavra);\n                palavra_certa = true;\n                for (int i = 0; tentativa_acerto_palavra[i] != '\\0'; i++)\n                {\n                    if (tolower(tentativa_acerto_palavra[i]) != tolower(palavra[i]))\n                    {\n                        palavra_certa = false;\n                        erros = 6;\n                    }\n                }\n                if (palavra_certa == true)\n                {\n                    vitoria = tam_palavra;\n                }\n                break;\n\n            \n            case 2:\n                \n                setbuf(stdin, NULL); \n                printf(\"\\n\\tEscolha uma letra: \\n\\t\");\n                letra = getchar();\n\n                \n                letra_usada = false;\n                for (int i = 0; i < tam_palavra; i++)\n                {\n                    if (tolower(letra) == tolower(palavra_rev[i]))\n                    {\n                        letra_usada = true;\n                    }\n                }\n                for (int i = 0; i < 12; i++)\n                {\n                    if (tolower(letra) == tolower(letras_erradas[i]))\n                    {\n                        letra_usada = true;\n                    }\n                }\n                \n                if (letra_usada == true)\n                {\n                    printf(\"Letra ja usada...\");\n                }\n                \n                else\n                {\n                    letra_certa = false;\n                    for (int i = 0; palavra[i] != '\\0'; i++)\n                    {\n                        if (tolower(letra) == tolower(palavra[i]))\n                        {\n                            palavra_rev[i] = palavra[i];\n                            letra_certa = true;\n                            vitoria++;\n                        }\n                    }\n                    if (letra_certa == false)\n                    {\n                        letras_erradas[i_lerradas] = letra;\n                        letras_erradas[i_lerradas + 1] = ' ';\n                        i_lerradas += 2;\n                        erros++;\n                    }\n                }\n            default:\n                break;\n            }\n\n            \n            if (vitoria == tam_palavra)\n            {\n                system(\"clear\");\n                printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n                printf(\"\\tTema: %s\\n\\n\", tema);\n                printf(\"\\t ------------------          PARAB\u00c9NS VOC\u00ca ADVINHOU A PALAVRA OU FRASE\\n\");\n                printf(\"\\t\/|\\\\                \\n\");\n                printf(\"\\t |                  \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O**O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              \\\\ | \/\\n\");\n                printf(\"\\t |               \\\\|\/                 %s\\n\", palavra);\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/ \\\\\\n\");\n                printf(\"\\t |              \/   \\\\\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                printf(\"Aperte qualque tecla para voltar: \");\n                scanf(\"%c\", &voltar);\n                getchar();\n                partida = false;\n            }\n            \n            else if (erros == 6)\n            {\n                system(\"clear\");\n                printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n                printf(\"\\tTema: %s\\n\\n\", tema);\n                printf(\"\\t ------------------        QUE PENA, VOC\u00ca N\u00c3O ADVINHOU A PALAVRA OU FRASE\\n\");\n                printf(\"\\t\/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              OxxO\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |  \\n\");\n                printf(\"\\t |               \/|\\\\                %s\\n\", palavra);\n                printf(\"\\t |              \/ | \\\\\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               \/ \\\\\\n\");\n                printf(\"\\t |              \/   \\\\\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t\/ \\\\ \\n\\n\\n\");\n                printf(\"Aperte qualque tecla para voltar: \");\n                scanf(\"%c\", &voltar);\n                getchar();\n                partida = false;\n            }\n        }\n        jogo = 2;\n        while ((jogo != true) && (jogo != false))\n        {\n            system(\"clear\");\n            printf(\"\\tBem vindo ao jogo da forca!\\n\\n\");\n            printf(\"\\t(1) JOGAR\\n\");\n            printf(\"\\t(2) SAIR DO JOGO\\n\\t \");\n            scanf(\"%d\", &menu);\n\n            switch (menu)\n            {\n            case 1:\n                jogo = true;\n                break;\n            case 2:\n                jogo = false;\n            default:\n                break;\n            }\n        }\n    }\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main(void)\n{\n    float temp, frio, normal, quente;\n\n    printf(\"\\nInforme a temperatura ambiente em graus celsius: \");\n    scanf(\"%f\", &temp);\n\n    \n    \n    \n    if (temp < 20)\n    {\n        frio = 1;\n        normal = 0;\n        quente = 0;\n    }\n\n    \n    \n    \n    else if ((temp >= 20) && (temp <= 26))\n    {\n        frio = 0;\n        normal = 1;\n        quente = 0;\n    }\n\n    \n    \n    \n    else\n    {\n        frio = 0;\n        normal = 0;\n        quente = 1;\n    }\n\n    if (frio == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 aquecendo\\n\\n\");\n    }\n    else if (normal == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 desligado\\n\\n\");\n    }\n    else if (quente == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 resfriando\\n\\n\");\n    }\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main(void)\n{\n    float temp;\n    float frio, quente, normal;\n\n    printf(\"\\nInforme a temperatura do ambiente em graus celsius: \");\n    scanf(\"%f\", &temp);\n\n    if (temp <= 10)\n    {\n        frio = 1;\n        normal = 0;\n        quente = 0;\n        \n    }\n    else if ((10 < temp) && (temp <= 11))\n    {\n        frio = 0.9;\n        normal = 0.1;\n        quente = 0;\n        \n    }\n    else if ((11 < temp) && (temp <= 12))\n    {\n        frio = 0.8;\n        normal = 0.2;\n        quente = 0;\n        \n    }\n    else if ((12 < temp) && (temp <= 13))\n    {\n        frio = 0.7;\n        normal = 0.3;\n        quente = 0;\n        \n    }\n    else if ((13 < temp) && (temp <= 14))\n    {\n        frio = 0.6;\n        normal = 0.4;\n        quente = 0;\n        \n    }\n    else if ((14 < temp) && (temp <= 15))\n    {\n        frio = 0.5;\n        normal = 0.5;\n        quente = 0;\n        \n    }\n    else if ((15 < temp) && (temp <= 16))\n    {\n        frio = 0.5;\n        normal = 0.5;\n        quente = 0;\n        \n    }\n    else if ((16 < temp) && (temp <= 17))\n    {\n        frio = 0.4;\n        normal = 0.6;\n        quente = 0;\n        \n    }\n    else if ((17 < temp) && (temp <= 18))\n    {\n        frio = 0.3;\n        normal = 0.7;\n        quente = 0;\n        \n    }\n    else if ((18 < temp) && (temp <= 19))\n    {\n        frio = 0.2;\n        normal = 0.8;\n        quente = 0;\n        \n    }\n    else if ((19 < temp) && (temp <= 20))\n    {\n        frio = 0.1;\n        normal = 0.9;\n        quente = 0;\n        \n    }\n    else if ((20 < temp) && (temp <= 25))\n    {\n        frio = 0;\n        normal = 1;\n        quente = 0;\n        \n    }\n    else if ((25 < temp) && (temp <= 26))\n    {\n        frio = 0;\n        normal = 0.9;\n        quente = 0.1;\n        \n    }\n    else if ((26 < temp) && (temp <= 27))\n    {\n        frio = 0;\n        normal = 0.8;\n        quente = 0.2;\n        \n    }\n    else if ((27 < temp) && (temp <= 28))\n    {\n        frio = 0;\n        normal = 0.7;\n        quente = 0.3;\n        \n    }\n    else if ((28 < temp) && (temp <= 29))\n    {\n        frio = 0;\n        normal = 0.6;\n        quente = 0.4;\n        \n    }\n    else if ((29 < temp) && (temp <= 30))\n    {\n        frio = 0;\n        normal = 0.5;\n        quente = 0.5;\n        \n    }\n    else if ((30 < temp) && (temp <= 31))\n    {\n        frio = 0;\n        normal = 0.5;\n        quente = 0.5;\n        \n    }\n    else if ((31 < temp) && (temp <= 32))\n    {\n        frio = 0;\n        normal = 0.4;\n        quente = 0.6;\n        \n    }\n    else if ((32 < temp) && (temp <= 33))\n    {\n        frio = 0;\n        normal = 0.3;\n        quente = 0.7;\n        \n    }\n    else if ((33 < temp) && (temp <= 34))\n    {\n        frio = 0;\n        normal = 0.2;\n        quente = 0.8;\n        \n    }\n    else if ((34 < temp) && (temp <= 35))\n    {\n        frio = 0;\n        normal = 0.1;\n        quente = 0.9;\n        \n    }\n    else if (temp > 35)\n    {\n        frio = 0;\n        normal = 0;\n        quente = 1;\n        \n    }\n\n    if ((frio > quente) && (normal != 1))\n    {\n        printf(\"\\nO aparelho est\u00e1 aquecendo com %.0f%% de pot\u00eancia\\n\\n\", frio * 100);\n    }\n    else if ((quente > frio) && (normal != 1))\n    {\n        printf(\"\\nO aparelho est\u00e1 resfriando com %.0f%% de pot\u00eancia\\n\\n\", quente * 100);\n    }\n    else if (normal == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 desligado\\n\\n\");\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define mlinhas 9\n#define ncolunas 9\n\nint main()\n{\n    int linha = 1, coluna = 1;\n    char a = 'a';\n    printf(\"\\n\");\n\n    for (int m = 0; m < mlinhas; m++)\n    {\n        for (int n = 0; n < ncolunas; n++)\n        {\n            if (coluna == 1)\n            {\n                printf(\"| \");\n            }\n            printf(\"%c%i%i  \", a, linha, coluna);\n            if (coluna == ncolunas)\n            {\n                printf(\"|\");\n            }\n            coluna++;\n        }\n        printf(\"\\n\");\n        linha++, coluna = 1;\n    }\n    printf(\"\\n\");\n}\n"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum Ordem\n{\n    normal,\n    inversa\n\n} ordem_t;\n\nvoid imprime_elemento(long int *vet, long int i, long int n, ordem_t ordem)\n{\n    printf(\"%li \", *(vet + i));\n\n    if (ordem == normal)\n    {\n        return (i < n-1) ? imprime_elemento(vet, i+1, n, ordem) : 0;\n    }\n    \n    else if (ordem == inversa)\n    {\n        return (i > 0) ? imprime_elemento(vet, i-1, NULL, ordem) : 0;\n    }\n}\n\n\nint main()\n{\n    long int n, *vet;\n\n    do\n    {\n        printf(\"\\nDigite o tamanho do vetor: \");\n        scanf(\"%ld\", &n);\n        getchar();\n        system(\"clear\");\n\n    } while (n <= 0);\n\n    vet = malloc(n * sizeof(long int));\n\n    printf(\"\\nDigite os elementos do vetor:\\n\");\n\n    for (long int i = 0; i < n; i++)\n    {\n        printf(\"\\t-> \");\n        scanf(\"%ld\", vet + i);\n        getchar();\n    }\n\n    printf(\"\\nOrdem normal:\\n\");\n    printf(\"\\t[ \");\n    imprime_elemento(vet, 0, n, normal);\n    printf(\"]\\n\");\n    \n    printf(\"\\nOrdem inversa:\\n\");\n    printf(\"\\t[ \");\n    imprime_elemento(vet, n-1, NULL, inversa);\n    printf(\"]\\n\\n\");\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef enum Bool\n{\n    false, true\n    \n} bool;\n\ntypedef struct Aluno\n{\n    char nome[82];\n    int idade;\n    int semestre;\n    float renda_mensal;\n\n} aluno_t;\n\nvoid le_turma(aluno_t *turma, int n);\nvoid imprime_aluno(aluno_t aluno);\nbool imprime_renda(aluno_t *turma, int semestre, int n);\nbool imprime_semestre(aluno_t *turma, int semestre, int n);\nbool imprime_idade(aluno_t *turma, int idade, int n);\n\nint main()\n{\n    int n, escolha;\n    float renda_media;\n\n    printf(\"\\nDigite o n\u00famero de alunos: \");\n    scanf(\"%i\", &n);\n    getchar();\n\n    aluno_t *turma = malloc(n * sizeof(aluno_t));\n\n    le_turma(turma, n);\n\n    do\n    {\n        do\n        {\n            printf(\"Deseja imprimir:\\n\");\n            printf(\"\\t(1) Alunos que possuam renda mensal superior \u00e0 media de seu semestre.\\n\");\n            printf(\"\\t(2) Alunos que est\u00e3o no mesmo semestre.\\n\");\n            printf(\"\\t(3) Alunos que a idade escolhida.\\n\");\n            printf(\"\\t(4) Sair.\");\n            printf(\"\\n\\tDigite sua escolha: \");\n\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n\n        } while (escolha != 1 && escolha != 2 && escolha != 3 && escolha != 4);\n\n        switch (escolha)\n        {\n            int escolha_sem_1;\n            int escolha_sem_2;\n            int escolha_id;\n\n            case 1:\n                printf(\"Digite o semestre: \");\n                scanf(\"%i\", &escolha_sem_1);\n                getchar();\n                imprime_renda(turma, escolha_sem_1, n);\n                break;\n\n            case 2:\n                printf(\"Digite o semestre: \");\n                scanf(\"%i\", &escolha_sem_2);\n                getchar();\n                imprime_semestre(turma, escolha_sem_2, n);\n                break;\n\n            case 3:\n                printf(\"Digite a Idade: \");\n                scanf(\"%i\", &escolha_id);\n                getchar();\n                imprime_idade(turma, escolha_id, n);\n                break;\n\n            case 4:\n                return 0;   \n        }\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n\n    } while (escolha != 4);\n\n    free(turma);\n    \n    return 0;\n}\n\n\nvoid le_turma(aluno_t *turma, int n)\n{\n    for(int i = 0; i < n; i++)\n    {\n        printf(\"\\nDigite os dados do %i\u00ba aluno:\\n\", i+1);\n\n        printf(\"\\t-> Nome: \");\n        fgets(turma[i].nome, 82, stdin);\n\n        int tam = strlen(turma[i].nome);\n        if (turma[i].nome[tam - 1] == '\\n')\n        {\n            turma[i].nome[tam - 1] = '\\0';\n        }\n\n        printf(\"\\t-> Idade: \");\n        scanf(\"%i\", &turma[i].idade);\n        getchar();\n\n        printf(\"\\t-> Semestre: \");\n        scanf(\"%i\", &turma[i].semestre);\n        getchar();\n\n        printf(\"\\t-> Renda mensal: \");\n        scanf(\"%f\", &turma[i].renda_mensal);\n        getchar();\n    }\n    system(\"clear\");\n}\n\nbool imprime_renda(aluno_t *turma, int semestre, int n)\n{\n    bool sem = false;\n    int k = 0;\n    float media = 0.0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].semestre == semestre)\n        {\n            if (sem == false) sem = true;\n\n            media += turma[i].renda_mensal;\n            k++;\n        }\n    }\n\n    if (sem == false)\n    {\n        printf(\"\\nNenhum aluno foi encontrado no semestre escolhido.\\n\");\n        return false;\n    }\n\n    media \/= k;\n    printf(\"\\nMedia = %f\\n\", media);\n\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].renda_mensal >= media && turma[i].semestre == semestre)\n        {\n            imprime_aluno(turma[i]);\n        }\n    }\n\n    return true;\n}\n\nbool imprime_semestre(aluno_t *turma, int semestre, int n)\n{\n    bool sem = false;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].semestre == semestre)\n        {\n            if (sem == false) sem = true;\n\n            imprime_aluno(turma[i]);\n        }\n    }\n\n    if (sem == false)\n    {\n        printf(\"\\nNenhum aluno foi encontrado no semestre escolhido.\\n\");\n        return false;\n    }\n\n    return true;\n}\n\nbool imprime_idade(aluno_t *turma, int idade, int n)\n{\n    bool id = false;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].idade == idade)\n        {\n            if (id == false) id = true;\n\n            imprime_aluno(turma[i]);\n        }\n    }\n\n    if (id == false)\n    {\n        printf(\"\\nNenhum aluno com a idade escolhida foi encontrado.\\n\");\n        return false;\n    }\n\n    return true;\n}\n\nvoid imprime_aluno(aluno_t aluno)\n{\n    printf(\"\\nNome: %s\\n\", aluno.nome);\n    printf(\"Idade: %i\\n\", aluno.idade);\n    printf(\"Semestre: %i\\n\", aluno.semestre);\n    printf(\"Renda mensal: %f\\n\", aluno.renda_mensal);\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid palavra_fibonacci(int n)\n{\n    if (n == 0) putchar('b');\n\n    else if (n == 1) putchar('a');\n\n    else\n    {\n        palavra_fibonacci(n-1);\n        palavra_fibonacci(n-2);\n    }\n}\n\nint main()\n{\n    int n;\n\n    do\n    {\n        printf(\"\\nDigite um inteiro n\u00e3o-negativo: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n\n    } while (n < 0);\n\n    printf(\"\\nA %i\u00aa palavra de Fibonacci:\\n\\n\", n);\n    palavra_fibonacci(n);\n    printf(\"\\n\\n\");\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ndouble exponencial(double a, int n)\n{\n    if (n == 0) return 1;\n\n    else if (n == 1) return a;\n\n    else if (n < 0) return exponencial(1\/a, (-1)*n);\n\n    else if (n % 2 == 0) return exponencial(a, n\/2) * exponencial(a, n\/2);\n\n    else return exponencial(a, n-1) * exponencial(a, 1);\n}\n\nint main()\n{\n    double a;\n    int n;\n\n    printf(\"\\nFun\u00e7\u00e3o exponencial (a^n):\\n\");\n    printf(\"\\t -> (real) a: \");\n    scanf(\"%lf\", &a);\n    getchar();\n    printf(\"\\t -> (int) n: \");\n    scanf(\"%i\", &n);\n\n    printf(\"\\n%lf^%i = %lf\\n\\n\", a, n, exponencial(a,n));\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n    FILE *arq_1, *arq_2, *arq_3;\n    char aux;\n\n    if (argc < 4)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"r\");\n    arq_3 = fopen(argv[3], \"w\");\n\n    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo\\n\\n\");\n        return 0;\n    }\n\n    while ((fscanf(arq_1, \"%c\", &aux) != EOF))\n    {        \n        fprintf(arq_3, \"%c\", aux);   \n    }\n    \n    while ((fscanf(arq_2, \"%c\", &aux) != EOF))\n    {        \n        fprintf(arq_3, \"%c\", aux);   \n    }\n\n    fclose(arq_1);\n    fclose(arq_2);\n    fclose(arq_3);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid le_mdc(int *a, int *b)\n{\n    do\n    {\n        printf(\"\\nDigite dois inteiros 'a' e 'b', onde 'b' > 0:\\n\");\n        printf(\"\\t-> a: \");\n        scanf(\"%i\", a);\n        getchar();\n        printf(\"\\t-> b: \");\n        scanf(\"%i\", b);\n        getchar();\n        system(\"clear\");\n\n    } while (b <= 0);\n}\n\nvoid le_mmc(int *a, int *b)\n{\n    do\n    {\n        printf(\"\\nDigite dois inteiros n\u00e3o-negativos 'a' e 'b':\\n\");\n        printf(\"\\t-> a: \");\n        scanf(\"%i\", a);\n        getchar();\n        printf(\"\\t-> b: \");\n        scanf(\"%i\", b);\n        getchar();\n        system(\"clear\");\n    \n    } while (a < 0 || b < 0);\n}\n\nint mdc(int a, int b)\n{\n    return (a % b > 0) ? mdc(b, a % b) : b;\n}\n\nint mmc(int a, int b)\n{\n    return (a == 0 || b == 0) ? 0 : (a*b) \/ mdc(a,b);\n}\n\nint main()\n{\n    int a, b, escolha;\n\n    do\n    {\n        do\n        {\n            printf(\"\\n\\t(1) MDC\\n\");\n            printf(\"\\t(2) MMC\\n\");\n            printf(\"\\t(3) Sair\\n\");\n            printf(\"\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n        \n        } while (escolha != 1 && escolha != 2 && escolha != 3);\n\n        if (escolha == 3) return 0;\n\n        if (escolha == 1)\n        {\n            le_mdc(&a, &b);\n            printf(\"\\nMDC(%i,%i) = %i\\n\\n\", a, b, mdc(a,b));\n        }\n\n        else if (escolha == 2)\n        {\n            le_mmc(&a, &b);\n            printf(\"\\nMMC(%i,%i) = %i\\n\\n\", a, b, mmc(a,b));\n        }\n\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    \n    } while (escolha != 3);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Complex\n{\n    float real;\n    float imaginario;\n\n} complex_t;\n\nvoid le_complexs(complex_t *a, complex_t *b);\nvoid imprime_complex(complex_t *c);\n\ncomplex_t conjugado(complex_t a);\ncomplex_t adicao(complex_t a, complex_t b);\ncomplex_t subtracao(complex_t a, complex_t b);\ncomplex_t multiplicacao(complex_t a, complex_t b);\ncomplex_t divisao(complex_t a, complex_t b);\n\nint main()\n{\n    complex_t a, b, c;\n    int escolha;\n\n    do\n    {\n        do\n        {\n            printf(\"\\nCalculadora de n\u00fameros complexs:\\n\");\n            printf(\"\\n\\t(1) Adi\u00e7\u00e3o\\n\");\n            printf(\"\\t(2) Subtra\u00e7\u00e3o\\n\");\n            printf(\"\\t(3) Multiplica\u00e7\u00e3o\\n\");\n            printf(\"\\t(4) Divis\u00e3o\\n\");\n            printf(\"\\t(5) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n\n        } while (escolha != 1 && escolha != 2 && escolha != 3 && escolha != 4 && escolha != 5);\n\n\n        switch (escolha)\n        {\n            case 1:\n                le_complexs(&a, &b);\n                c = adicao(a,b);\n                imprime_complex(&c);\n                break;\n            \n            case 2:\n                le_complexs(&a, &b);\n                c = subtracao(a,b);\n                imprime_complex(&c);\n                break;\n            \n            case 3:\n                le_complexs(&a, &b);\n                c = multiplicacao(a,b);\n                imprime_complex(&c);\n                break;\n            \n            case 4:\n                le_complexs(&a, &b);\n                c = divisao(a,b);\n                imprime_complex(&c);\n                break;\n            \n            case 5:\n                return 0;\n        }\n\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n\n    } while (escolha != 5);\n\n    return 0;\n}\n\n\nvoid le_complexs(complex_t *a, complex_t *b)\n{\n    printf(\"\\nDigite o 1\u00ba n\u00famero:\\n\");\n    \n    printf(\"\\t-> Real: \");\n    scanf(\"%f\", &a->real);\n    getchar();\n\n    printf(\"\\t-> Imagin\u00e1rio: \");\n    scanf(\"%f\", &a->imaginario);\n    getchar();\n\n    printf(\"\\nDigite o 2\u00ba n\u00famero:\\n\");\n    \n    printf(\"\\t-> Real: \");\n    scanf(\"%f\", &b->real);\n    getchar();\n\n    printf(\"\\t-> Imagin\u00e1rio: \");\n    scanf(\"%f\", &b->imaginario);\n    getchar();\n}\n\nvoid imprime_complex(complex_t *c)\n{\n\n    if (c->imaginario < 0)\n    {\n        printf(\"\\nRes = %.2f %.2fi\\n\", c->real, c->imaginario);\n    }\n\n    else\n    {\n        printf(\"\\nRes = %.2f +%.2fi\\n\", c->real, c->imaginario);\n    }\n}\n\ncomplex_t conjugado(complex_t a)\n{\n    a.imaginario *= -1;\n\n    return a;\n}\n\ncomplex_t adicao(complex_t a, complex_t b)\n{\n    complex_t c;\n    \n    c.real = a.real + b.real;\n    c.imaginario = a.imaginario + b.imaginario;\n\n    return c;\n}\n\ncomplex_t subtracao(complex_t a, complex_t b)\n{\n    complex_t c;\n\n    c.real = a.real - b.real;\n    c.imaginario = a.imaginario - b.imaginario;\n\n    return c;\n}\n\ncomplex_t multiplicacao(complex_t a, complex_t b)\n{\n    complex_t c;\n\n    c.real = (a.real * b.real) - (a.imaginario * b.imaginario);\n    c.imaginario = (a.real * b.imaginario) + (a.imaginario * b.real);\n\n    return c;\n}\n\ncomplex_t divisao(complex_t a, complex_t b)\n{\n    complex_t c, d;\n\n    complex_t b2 = conjugado(b);\n\n    d = multiplicacao(b, b2);\n    c = multiplicacao(a, b2);\n\n    c.real \/= d.real;\n    c.imaginario \/= d.real;\n\n    return c;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n    FILE *arq;\n    char aux, *texto;\n\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n\n    arq = fopen(argv[1], \"r+\");\n\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    int i = 0;\n\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n\n    texto = malloc((i+1) * sizeof(char));\n\n    rewind(arq);\n\n    i = 0;\n\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        texto[i] = aux;\n        i++;\n    }\n    texto[i] = '\\0';\n\n\n    for (int j = 0; j < i; j++)\n    {\n        switch (texto[j])\n        {\n            case 'a':\n                texto[j] = 'A';\n                break;\n                \n            case 'e':\n                texto[j] = 'E';\n                break;\n\n            case 'i':\n                texto[j] = 'I';\n                break;\n\n            case 'o':\n                texto[j] = 'O';\n                break;\n\n            case 'u':\n                texto[j] = 'U';\n                break;\n            \n            default:\n                break;\n        }\n    }\n\n    rewind(arq);\n    fprintf(arq, \"%s\", texto);\n    fclose(arq);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct Pontos\n{\n    double x;\n    double y;\n\n} pontos_t;\n\ndouble fatorial(int n);\nvoid le_poligono(pontos_t *poligono, int n);\ndouble perimetro(pontos_t *poligono, int n);\ndouble area(pontos_t *poligono, int n);\ndouble triangulos(pontos_t *poligono, int n, int m);\n\nint main()\n{\n    int n;\n\n    do\n    {\n        printf(\"\\nDigite o n\u00famero de lados do pol\u00edgono (>= 3): \");\n        scanf(\"%li\", &n);\n\n        if (n < 3) system(\"clear\");\n\n    } while (n < 3);\n\n    pontos_t *poligono = malloc(n * sizeof(pontos_t));\n\n    le_poligono(poligono, n);\n\n    system(\"clear\");\n\n    printf(\"\\n\\tPer\u00edmetro = %lf\\n\", perimetro(poligono, n));\n    printf(\"\\n\\t\u00c1rea = %lf\\n\", area(poligono, n));\n    printf(\"\\n\\tQuantidade de tri\u00e2ngulos poss\u00edveis = %.0lf\\n\\n\", triangulos(poligono, n, 3));\n\n    free(poligono);\n\n    return 0;\n}\n\ndouble fatorial(int n)\n{\n    return (n > 0) ? n * fatorial(n-1) : 1;\n}\n\nvoid le_poligono(pontos_t *poligono, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"\\nDigite as coordenadas do %li\u00ba ponto:\\n\", i+1);\n\n        printf(\"\\t-> Coordenada x: \");\n        scanf(\"%lf\", &poligono[i].x);\n        getchar();\n\n        printf(\"\\t-> Coordenada y: \");\n        scanf(\"%lf\", &poligono[i].y);\n        getchar();\n    }\n}\n\ndouble perimetro(pontos_t *poligono, int n)\n{\n    double perimetro = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (i == n-1)\n        {\n            perimetro += sqrtf(powf(poligono[i].x - poligono[0].x,2) + powf(poligono[i].y - poligono[0].y,2));\n        }\n\n        else\n        {\n            perimetro += sqrtf(powf(poligono[i].x - poligono[i+1].x,2) + powf(poligono[i].y - poligono[i+1].y,2));\n        }\n    }\n\n    return perimetro;\n}\n\ndouble area(pontos_t *poligono, int n)\n{\n    double area = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (i == n-1)\n        {\n            area += (poligono[i].x * poligono[0].y) - (poligono[0].x * poligono[i].y);\n        }\n\n        else\n        {\n            area += (poligono[i].x * poligono[i+1].y) - (poligono[i+1].x * poligono[i].y);\n        }\n    }\n\n    area \/= 2;\n\n    return (area < 0) ? area*(-1) : area;\n}\n\ndouble triangulos(pontos_t *poligono, int n, int m)\n{\n    double triangulos;\n\n    triangulos = fatorial(n) \/ (fatorial(n-m) * fatorial(m));\n\n    return triangulos;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2, *arq_3;\n    int *vet_1, *vet_2, aux;\n    int aux_1 = {1, 3, 5, 7, 10, 11}, aux_2 = {0, 2, 4, 6, 8, 10};\n\n    if (argc < 4)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n\n    arq_1 = fopen(argv[1], \"w+b\");\n    arq_2 = fopen(argv[2], \"w+b\");\n    arq_3 = fopen(argv[3], \"wb\");\n\n    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo\\n\\n\");\n        return 0;\n    }\n\n    fwrite(&aux_1, sizeof(int), 6, arq_1);\n    fwrite(&aux_2, sizeof(int), 6, arq_2);\n\n    fseek(arq_1, 0, SEEK_SET);\n    fseek(arq_2, 0, SEEK_SET);\n\n    int i = 0, j = 0;\n    \n    while (fread(&aux, sizeof(int), 1, arq_1) != 0)\n    {\n        i++;\n    }\n\n    while (fread(&aux, sizeof(int), 1, arq_2) != 0)\n    {\n        j++;\n    }\n\n    vet_1 = malloc(i * sizeof(int));\n    vet_2 = malloc(j * sizeof(int));\n\n    fseek(arq_1, 0, SEEK_SET);\n    fseek(arq_2, 0, SEEK_SET);\n\n    fread(vet_1, sizeof(int), i, arq_1);\n    fread(vet_2, sizeof(int), j, arq_2);\n\n    for (int i2 = 0, j2 = 0; i2 < i, j2 < j;)\n    {\n        if (vet_1[i2] < vet_2[j2])\n        {\n            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);\n            i2++;\n        }\n\n        else if (vet_2[j2] < vet_1[i2])\n        {\n            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);\n            j2++;\n        }\n\n        else if (vet_1[i2] == vet_2[j2])\n        {\n            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);\n            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);\n            i2++;\n            j2++;\n        }\n    }\n\n    fclose(arq_1);\n    fclose(arq_2);\n    fclose(arq_3);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum\n{\n    fib = 1, pad, cat, quit\n\n} func_t;\n\nvoid le_numero(int *n)\n{\n    do\n    {\n        printf(\"\\nDigite um inteiro positivo: \");\n        scanf(\"%i\", n);\n        getchar();\n        system(\"clear\");\n\n    } while (n < 0);\n}\n\nlong int fibonacci(int n)\n{\n    return (n > 1) ? fibonacci(n-1) + fibonacci(n-2) : 1;\n}\n\nlong int padovan(int n)\n{\n    return (n > 2) ? padovan(n-2) + padovan(n-3) : 1;\n}\n\nlong int catalan(float n)\n{\n    return (n > 0) ? ((4*n - 2) \/ (n+1)) * catalan(n-1) : 1;\n}\n\nint main()\n{\n    int n;\n    func_t escolha;\n    \n    do\n    {\n        do\n        {\n            printf(\"\\t(1) Fibonacci\\n\");\n            printf(\"\\t(2) Padovan\\n\");\n            printf(\"\\t(3) Catalan\\n\");\n            printf(\"\\t(4) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n\n        } while (escolha != fib && escolha != pad && escolha != cat && escolha != quit);\n\n        if (escolha == quit) return 0;\n\n        le_numero(&n);\n\n        switch (escolha)\n        {\n            case fib:\n                printf(\"\\nFibonacci de %i = %li\\n\\n\", n, fibonacci(n));\n                break;\n            \n            case pad:\n                printf(\"\\nPadovan de %i = %li\\n\\n\", n, padovan(n));\n                break;\n            \n            case cat:\n                printf(\"\\nCatalan de %i = %li\\n\\n\", n, catalan(n));\n                break;\n        }\n\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n\n    } while (escolha != quit);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum Bool\n{\n    false, true\n\n} bool;\n\ntypedef struct Ponto\n{\n    double x;\n    double y;\n\n} ponto_t;\n\ntypedef struct Retangulo\n{\n    ponto_t sup_esq;\n    ponto_t inf_dir;\n\n} rect_t;\n\nvoid le_retangulo(rect_t *retangulo)\n{\n    printf(\"\\nDigite as coordenadas do ret\u00e2ngulo:\\n\");\n    \n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo->sup_esq.y);\n    getchar();\n\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo->inf_dir.y);\n    getchar();\n}\n\nvoid le_retangulos(rect_t *retangulo_1, rect_t *retangulo_2)\n{\n    printf(\"\\nDigite as coordenadas do 1\u00ba ret\u00e2ngulo:\\n\");\n    \n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_1->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_1->sup_esq.y);\n    getchar();\n\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_1->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_1->inf_dir.y);\n    getchar();\n\n    printf(\"\\nDigite as coordenadas do 2\u00ba ret\u00e2ngulo:\\n\");\n    \n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_2->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_2->sup_esq.y);\n    getchar();\n\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_2->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_2->inf_dir.y);\n    getchar();\n}\n\ndouble area(rect_t retangulo)\n{\n    double area = (retangulo.sup_esq.x - retangulo.inf_dir.x) * (retangulo.sup_esq.y - retangulo.inf_dir.y);\n\n    return (area < 0) ? area*(-1) : area;\n}\n\nbool intersecao(rect_t retangulo_1, rect_t retangulo_2)\n{\n    bool sup_esq = false, inf_dir = false;\n\n    if ((((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x) && (retangulo_2.sup_esq.x < retangulo_1.inf_dir.x)) || ((retangulo_2.sup_esq.y < retangulo_1.sup_esq.y) && (retangulo_2.sup_esq.y > retangulo_1.inf_dir.y))) == true)\n    {\n        sup_esq = true;\n    }\n\n    if ((((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x) && (retangulo_2.inf_dir.x > retangulo_1.sup_esq.x)) || ((retangulo_2.inf_dir.y > retangulo_1.inf_dir.y) && (retangulo_2.inf_dir.y < retangulo_1.sup_esq.y))) == true)\n    {\n        inf_dir = true;\n    }\n\n    if ((sup_esq || inf_dir) == true)\n    {\n        return true;\n    }\n\n    else return false;\n}\n\nint contido(rect_t retangulo_1, rect_t retangulo_2)\n{\n    if (((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x && retangulo_2.sup_esq.x < retangulo_1.inf_dir.x) && (retangulo_2.sup_esq.y < retangulo_1.sup_esq.y && retangulo_2.sup_esq.y > retangulo_1.inf_dir.y)) &&\\\n        ((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x && retangulo_2.inf_dir.x > retangulo_1.sup_esq.x) && (retangulo_2.inf_dir.y > retangulo_1.inf_dir.y && retangulo_2.inf_dir.y < retangulo_1.sup_esq.y)) == true)\n    {\n        return 2;\n    }\n\n    else if (((retangulo_1.sup_esq.x > retangulo_2.sup_esq.x && retangulo_1.sup_esq.x < retangulo_2.inf_dir.x) && (retangulo_1.sup_esq.y < retangulo_2.sup_esq.y && retangulo_1.sup_esq.y > retangulo_2.inf_dir.y)) &&\\\n             ((retangulo_1.inf_dir.x < retangulo_2.inf_dir.x && retangulo_1.inf_dir.x > retangulo_2.sup_esq.x) && (retangulo_1.inf_dir.y > retangulo_2.inf_dir.y && retangulo_1.inf_dir.y < retangulo_2.sup_esq.y)) == true)\n    {\n        return 1;\n    }\n\n    else if (((retangulo_1.sup_esq.x == retangulo_2.sup_esq.x && retangulo_1.sup_esq.y == retangulo_2.sup_esq.y) && (retangulo_1.inf_dir.x == retangulo_2.inf_dir.x && retangulo_1.inf_dir.y == retangulo_2.inf_dir.y)) == true)\n    {\n        return 3;\n    }\n\n    else return 0;\n}\n\ndouble intersecao_area(rect_t retangulo_1, rect_t retangulo_2)\n{\n    rect_t retangulo;\n\n    if (retangulo_2.sup_esq.x >= retangulo_1.sup_esq.x && retangulo_2.sup_esq.x <= retangulo_1.inf_dir.x)\n    {\n        retangulo.sup_esq.x = retangulo_2.sup_esq.x;\n    }\n\n    else retangulo.sup_esq.x = retangulo_1.sup_esq.x;\n\n    if (retangulo_2.sup_esq.y <= retangulo_1.sup_esq.y && retangulo_2.sup_esq.y >= retangulo_1.inf_dir.y)\n    {\n        retangulo.sup_esq.y = retangulo_2.sup_esq.y;\n    }\n\n    else retangulo.sup_esq.y = retangulo_1.sup_esq.y;\n\n    if (retangulo_2.inf_dir.x <= retangulo_1.inf_dir.x && retangulo_2.inf_dir.x >= retangulo_1.sup_esq.x)\n    {\n        retangulo.inf_dir.x = retangulo_2.inf_dir.x;\n    }\n\n    else retangulo.inf_dir.x = retangulo_1.inf_dir.x;\n\n    if (retangulo_2.inf_dir.y >= retangulo_1.inf_dir.y && retangulo_2.inf_dir.y <= retangulo_1.sup_esq.y)\n    {\n        retangulo.inf_dir.y = retangulo_2.inf_dir.y;\n    }\n\n    else retangulo.inf_dir.y = retangulo_1.inf_dir.y;\n\n    printf(\"\\nsup_esq (%lf,%lf)\\ninf_dir(%lf,%lf)\\n\", retangulo.sup_esq.x, retangulo.sup_esq.y, retangulo.inf_dir.x, retangulo.inf_dir.y);\n    \n    return area(retangulo);\n}\n\n\nint main()\n{\n    rect_t retangulo_1, retangulo_2;\n    int escolha;\n\n    do\n    {\n        do\n        {\n            printf(\"\\n\\t(1) Calcular a \u00e1rea de um ret\u00e2ngulo\\n\");\n            printf(\"\\t(2) Verificar interse\u00e7\u00e3o de retangulos\\n\");\n            printf(\"\\t(3) Verificar se um ret\u00e2ngulo est\u00e1 contido em um outro\\n\");\n            printf(\"\\t(4) Calcular a \u00e1rea da interse\u00e7\u00e3o entre dois retangulos\\n\");\n            printf(\"\\t(5) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n\n            if (escolha < 1 || escolha > 5) system(\"clear\");\n\n        } while (escolha < 1 || escolha > 5);\n\n        switch (escolha)\n        {\n            case 1:\n                le_retangulo(&retangulo_1);\n                printf(\"\\n\u00c1rea = %lf\\n\", area(retangulo_1));\n                break;\n            \n            case 2:\n                le_retangulos(&retangulo_1, &retangulo_2);\n\n                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == true)\n                {\n                    printf(\"\\nOs ret\u00e2ngulos dados se intersectam!\\n\");\n                }\n\n                else printf(\"\\nOs ret\u00e2ngulos dados n\u00e3o se intersectam!\\n\");\n\n                break;\n\n            case 3:\n                le_retangulos(&retangulo_1, &retangulo_2);\n\n                switch (contido(retangulo_1, retangulo_2))\n                {\n                    case 1:\n                        printf(\"\\nO ret\u00e2ngulo 1 est\u00e1 contido no ret\u00e2ngulo 2\\n\");\n                        break;\n\n                    case 2:\n                        printf(\"\\nO ret\u00e2ngulo 2 est\u00e1 contido no ret\u00e2ngulo 1\\n\");\n                        break;\n                    \n                    case 3:\n                        printf(\"\\nOs ret\u00e2ngulos s\u00e3o identicos\\n\");\n                        break;\n                    \n                    case 0:\n                        printf(\"\\nNenhum ret\u00e2ngulo est\u00e1 contido no outro\\n\");\n                        break;\n                }\n\n                break;\n\n            case 4:\n                le_retangulos(&retangulo_1, &retangulo_2);\n\n                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == false)\n                {\n                    printf(\"\\nOs ret\u00e2ngulos dados n\u00e3o se intersectam!\\n\");\n                }\n\n                else\n                {\n                    printf(\"\\n\u00c1rea da interse\u00e7\u00e3o = %lf\\n\", intersecao_area(retangulo_1, retangulo_2));\n                }\n\n                break;\n            \n            case 5:\n                return 0;\n        }\n\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    \n    } while (escolha != 5);\n\n    return 0;\n\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum Bool\n{\n    false, true\n\n} bool;\n\ntypedef struct Quantidade\n{\n    int chars;\n    int linhas;\n    int palavras;\n\n} qtd_t;\n\nint main(int argc, char **argv)\n{\n    FILE *arq;\n    char aux;\n    qtd_t qtd;\n    bool espaco = false, pontuacao = false, enter = false;\n    \n    qtd.chars = 0;\n    qtd.linhas = 1;\n    qtd.palavras = 0;\n\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n\n    arq = fopen(argv[1], \"r\");\n\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    for (int i = 0; fscanf(arq, \"%c\", &aux) != EOF; i++)\n    {\n        if (aux == '\\n')\n        {\n            qtd.linhas++;\n        }\n\n        if (i == 0)\n        {\n            if (aux != ' ' && aux != '\\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!')\n            {\n                qtd.chars++;\n                qtd.palavras++;\n            }\n        }\n\n        else\n        {\n            if (aux == ' ')\n            {\n                espaco = true;\n            }\n\n            else if (aux == ',' || aux == '.' || aux == ';' || aux == ':' || aux == '?' || aux == '!')\n            {\n                pontuacao = true;\n            }\n\n            else if (aux == '\\n')\n            {\n                enter = true;\n            }\n\n            else\n            {\n                qtd.chars++;\n            }\n\n            if ((espaco == true || pontuacao == true || enter == true) &&\\\n                (aux != ' ' && aux != '\\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!'))\n                {\n                    qtd.palavras++;\n\n                    espaco = false;\n                    pontuacao = false;\n                    enter = false;\n                }\n        }\n    }\n\n    printf(\"\\n%s:\\n\", argv[1]);\n    printf(\"\\t-> chars: %i\\n\", qtd.chars);\n    printf(\"\\t-> palavras: %i\\n\", qtd.palavras);\n    printf(\"\\t-> linhas: %i\\n\", qtd.linhas);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *str_1, *str_2;\n    int n, m;\n    float **matriz, aux_2, *texto;\n\n    if (argc < 3)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    int i = 0;\n    \n    while (fscanf(arq_1, \"%f\", &aux_2) != EOF)\n    {\n        i++;\n    }\n\n    printf(\"\\ni = %i\\n\", i);\n\n    texto = malloc(i * sizeof(float));\n\n    rewind(arq_1);\n\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%f\", texto+j);\n        \n    }\n\n    n = texto[0];\n    m = texto[1];\n\n    \n\n    matriz = malloc(n * sizeof(float*));\n    for (int i = 0; i < n; i++)\n    {\n        matriz[i] = malloc(m * sizeof(float));\n    }\n\n\n    for (int i = 0, k = 0; i < n; i++)\n    {\n        for (int  j = 0; j < m; j++)\n        {\n            matriz[i][j] = texto[k+2];\n            k++;\n            \n        }\n        \n    }\n    \n\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            fprintf(arq_2, \"%f \", matriz[j][i]);\n            \n        }\n        fprintf(arq_2, \"%c\", '\\n');\n        \n    }\n\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n    FILE *arq;\n    char aux, *texto;\n    float res = 0;\n\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n\n    arq = fopen(argv[1], \"r\");\n\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    int i = 0;\n\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n\n    rewind(arq);\n\n    \n\n    texto = malloc(i * sizeof(char));\n\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq, \"%c\", texto+j);\n    }\n\n    for (int j = 0; j < i; j++)\n    {\n        if (texto[j] == 'R' && texto[j+1] == '$')\n        {\n            res += atof(texto + j+2);\n        }\n    }\n    printf(\"\\nLista de compras: R$%.2f\\n\\n\", res);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nlong int ackermann(int m, int n)\n{\n    if (m == 0) return n+1;\n\n    else if (n == 0) return ackermann(m-1, 1);\n\n    else return ackermann(m-1, ackermann(m, n-1));\n}\n\nint main()\n{\n    int m, n;\n\n    do\n    {\n        printf(\"\\nFun\u00e7\u00e3o de Ackermann:\\n\");\n        printf(\"\\t-> m: \");\n        scanf(\"%i\", &m);\n        getchar();\n        printf(\"\\t-> n: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n\n    } while (n < 0 || m < 0);\n\n    printf(\"\\nA(%i,%i) = %li\\n\\n\", m, n, ackermann(m,n));\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Aluno\n{\n    char nome[32];\n    int semestre;\n    float ra;\n\n} aluno_t;\n\nvoid imprime_sem(aluno_t *alunos, int x, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (alunos[i].semestre == x)\n        {\n            printf(\"\\nNome: %s\\n\", alunos[i].nome);\n            printf(\"Semestre: %i\\n\", alunos[i].semestre);\n            printf(\"Rendimento acad\u00eamico: %f\\n\", alunos[i].ra);\n        }\n    }\n}\n\nint main(int argc, char **argv)\n{\n    FILE *arq;\n    aluno_t *alunos;\n    char aux;\n    int x;\n\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n\n    arq  = fopen(argv[1], \"r\");\n\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    int i = 1;\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        if (aux == '\\n')\n        {\n            i++;\n        }\n    }\n\n    rewind(arq);\n\n    if (i % 3 == 0)\n    {\n        i \/= 3;\n    }\n    \n    else\n    {\n        printf(\"\\nInforma\u00e7\u00f5es insuficientes.\\n\\n\");\n        return 0;\n    }\n\n    alunos = malloc(i * sizeof(aluno_t));\n\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq, \"%s\", alunos[j].nome);\n        fscanf(arq, \"%i\", &alunos[j].semestre);\n        fscanf(arq, \"%f\", &alunos[j].ra);\n    }\n\n    printf(\"\\nDigite um semestre: \");\n    scanf(\"%i\", &x);\n    getchar();\n\n    imprime_sem(alunos, x, i);\n\n    fclose(arq);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *texto;\n\n    if (argc < 3)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados aquivos o suficiente.\\n\\n\");\n        return 0;\n    }\n\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo.\\n\\n\");\n        return 0;\n    }\n\n    int i = 0;\n    while (fscanf(arq_1, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n\n    rewind(arq_1);\n\n    texto = malloc(i+1 * sizeof(char));\n\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%c\", texto + j);\n    }\n    texto[i] = '\\0';\n\n    for (int j = 0; j < i; j++)\n    {\n        if (texto[j] == '\/' && texto[j+1] == '\/')\n        {\n            int k = j;\n            while (texto[k] != '\\n' && texto[k] != '\\0')\n            {\n                texto[k] = ' ';\n                k++;\n            }\n        }\n\n    }\n\n    fprintf(arq_2, \"%s\", texto);\n\n    fclose(arq_1);\n    fclose(arq_2);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n\ndouble exponencial(int a, long long int n)\n{\n    if (n == 0) return 1;\n\n    else if (n == 1) return a;\n\n    else if (n % 2 == 0) return exponencial(a, n\/2) * exponencial(a, n\/2);\n\n    else return exponencial(a, n-1) * exponencial(a, 1);\n}\n\nlong long int fatorial(int n)\n{\n    return (n > 1) ? n * fatorial(n-1) : 1;\n}\n\ndouble super_fatorial(int n)\n{\n    return (n > 1) ? exponencial(n, fatorial(n-1)) : 1;\n}\n\nint main()\n{\n    int n;\n\n    do\n    {\n        printf(\"\\nDigite um inteiro positivo: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n\n    } while(n <= 0);\n\n    if (n >= 5) printf(\"\\nFatorial exponencial de %i = %e\\n\\n\", n, super_fatorial(n));\n\n    else printf(\"\\nFatorial exponencial de %i = %.0lf\\n\\n\", n, super_fatorial(n));\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Aluno\n{\n    char nome[102];\n    int prova[3];\n    int trab[2];\n\n} aluno_t;\n\nvoid insere_aluno(FILE *arq)\n{\n    aluno_t aluno;\n    int tam;\n\n    printf(\"\\nDigite o nome do aluno: \");\n    fgets(aluno.nome, 102, stdin);\n\n    tam = strlen(aluno.nome);\n\n    if (aluno.nome[tam - 1] == '\\n')\n    {\n        aluno.nome[tam - 1] = '\\0';\n    }\n\n    printf(\"Digite a nota da primeira prova: \");\n    scanf(\"%i\", aluno.prova[0]);\n    getchar();\n\n    printf(\"Digite a nota da segunda prova: \");\n    scanf(\"%i\", aluno.prova[1]);\n    getchar();\n\n    printf(\"Digite a nota da terceira prova: \");\n    scanf(\"%i\", aluno.prova[2]);\n    getchar();\n\n    printf(\"Digite a nota do primeiro trabalho: \");\n    scanf(\"%i\", aluno.trab[0]);\n    getchar();\n\n    printf(\"Digite a nota do segundo trabalho: \");\n    scanf(\"%i\", aluno.trab[1]);\n    getchar();\n\n    fseek(arq, 0, SEEK_END);\n    \n    fwrite(&aluno, sizeof(aluno), 1, arq);\n}\n\nvoid exibe_alunos(FILE *arq)\n{\n    aluno_t aluno;\n\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        printf(\"\\nNome: %s\\n\", aluno.nome);\n        printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n        printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n        printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n        printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n        printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n    }\n}\n\nvoid exibe_aprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) \/ 10;\n\n        if (media >= 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}\n\nvoid exibe_reprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) \/ 10;\n\n        if (media < 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}\n\nint main(int argc, char **argv)\n{\n    FILE *arq;\n    int escolha;\n    aluno_t aluno;\n\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o arquivo.\\n\\n\");\n        return 0;\n    }\n\n    arq = fopen(argv[1], \"r+b\");\n\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo,\\n\\n\");\n        return 0;\n    }\n\n    do\n    {\n        printf(\"\\n\\t(1) Inserir alunos e suas respectivas notas\\n\");\n        printf(\"\\t (2) Exibir alunos e suas respectivas notas\\n\");\n        printf(\"\\t (3) Exibir alunos aprovados\\n\");\n        printf(\"\\t (4) Exibir alunos reprovados\\n\");\n        printf(\"\\t (5) Sair\\n\");\n        printf('\\n\\t Digite sua escolha: ');\n        scanf(\"%i\", &escolha);\n        getchar();\n        system(\"clear\");\n\n        switch (escolha)\n        {\n            case 1:\n                insere_aluno(arq);\n                break;\n\n            case 2:\n                exibe_alunos(arq);\n                break;\n\n            case 3:\n                exibe_aprovados(arq);\n                break;\n            \n            case 4:\n                exibe_reprovados(arq);\n                break;\n            \n            case 5:\n                return 0;\n            \n            default:\n                break;\n        }\n\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n\n    } while (escolha != 5);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    int n,num,aux,condicao = true, maior, smaior, smenor, menor, maior0, smaior0, menor0, smenor0;\n\n    scanf (\"%i\", &n);\n\n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%i\", &num);\n        if (i==0)\n        {\n            maior = num;\n            menor = num;\n            smaior = num;\n            smenor = num;\n        }\n        else\n        {\n            if (num > maior)\n            {\n                aux = maior;\n                maior = num;\n                smaior = aux;\n            }\n            else if (num < menor)\n            {\n                aux = menor;\n                menor = num;\n                smenor = aux;\n            }\n            if ((maior == smaior)&&(num < smaior)&&(num > smenor)&&(num > menor))\n            {\n                smaior = num;\n            }\n            else if ((menor == smenor)&&(num > smenor)&&(num < smaior)&&(num < maior))\n            {\n                smenor = num;\n            }\n            else if ((maior == smaior)&&(num < smaior))\n            {\n                smaior = num;\n            }\n            else if ((menor == smenor)&&(num > smenor))\n            {\n                smenor = num;\n            }\n            if ((maior == smaior)&&(maior == smenor)&&(num < smenor)&&(num > menor))\n            {\n                smaior = num;\n                smenor = num;\n            }\n            else if ((menor == smenor)&&(menor == smaior)&&(num > smaior)&&(num < maior))\n            {\n                smenor = num;\n                smaior = num;\n            }\n            if ((num < maior)&&(num > smaior))\n            {\n                smaior = num;\n            }\n            else if ((num > menor)&&(num < smenor))\n            {\n                smenor = num;\n            }\n        }\n        \n    }\n    \n        if ((maior == smaior)&&(smaior == smenor)&&(smenor == menor))\n            printf (\"%i\\n%i\\nnao definido\\nnao deifnido\\n\", maior, menor);\n\n        else\n            printf (\"%i\\n%i\\n%i\\n%i\\n\", maior, menor, smaior, smenor);\n    \n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nlong int primos[500];\n\nint primov(long int n)\n{\n    primos[0] = 2;\n    int k = 0, primo;\n\n    for (long int i = 3; (primos[k] * primos[k]) <= n; i += 2)\n    {\n        primo = true;\n        for (int j = 0; (j <= k) && (primo == true); j++)\n        {\n            if ((i % primos[j]) == 0)\n            {\n                primo = false;\n            }\n        }\n\n        if (primo == true)\n        {\n            primos[k + 1] = i;\n            k++;\n        }\n        \n    }\n\n    return k;\n}\n\nint busca(long int n, int k)\n{\n    for (int j = 0; (j <= k) && ((primos[j] * primos[j]) <= n); j++)\n    {\n        if ((n % primos[j]) == 0)\n        {\n            printf(\"composto\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"primo\\n\");\n    return 0;\n}\n\nint main()\n{\n    long int num[100000], maior;\n    int n, k;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%li\", &num[i]);\n\n        if (i == 0)\n        {\n            maior = num[i];\n        }\n\n        else if (num[i] > maior)\n        {\n            maior = num[i];\n        }\n    }\n\n    k = primov(maior);\n\n    for (int i = 0; i < n; i++)\n    {\n\n        if (num[i] == 1)\n        {\n            printf(\"composto\\n\");\n        }\n\n        else if (num[i] == 2)\n        {\n            printf(\"primo\\n\");\n        }\n\n        else\n        {\n            busca(num[i], k);\n        }\n    }\n\n    \n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    double x[1000], y[1000], d, menor;\n    int n, p1, p2;\n\n    scanf (\"%i\", &n);\n\n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%lf\", &x[i]);\n    }\n    \n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%lf\", &y[i]);\n    }\n\n    for (int i=0; i<n; i++)\n    {\n        for (int j=(i+1); j<n; j++)\n        {\n            d = pow((x[i]-x[j]),2) + pow((y[i]-y[j]),2);\n            d = sqrt(d);\n            \n            if ((i==0)&&(j==1))\n            {\n                menor = d;\n                p1 = i;\n                p2 = j;\n            }\n            else\n            {\n                if (d < menor)\n                {\n                    menor = d;\n                    p1 = i;\n                    p2 = j;\n                }\n            }\n            \n        }\n    }\n\n    printf (\"Pontos: %i e %i\\nDistancia: %lf\\n\", p1, p2, menor);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nlong int fib[47];\n\nvoid fibonacci(int maior)\n{\n    fib[0] = 1;\n    fib[1] = 1;\n    \n    for (int a = 2; a <= maior; a++)\n    {\n        fib[a] = fib[a - 1] + fib[a - 2];\n    }\n}\n\nlong int supersigma(int i, int j)\n{\n    long int soma = 0;\n\n    for (int a = i; a <= j; a++)\n    {\n        soma += fib[a];\n    }\n\n    return soma;\n}\n\nint main()\n{\n    int n, iv[100000], jv[100000], maior = 0;\n\n    scanf(\"%i\", &n);\n\n    for (int a = 0; a < n; a++)\n    {\n        scanf(\"%i\", &iv[a]);\n        scanf(\"%i\", &jv[a]);\n\n        if (jv[a] > maior)\n            maior = jv[a];\n    }\n\n    fibonacci(maior);\n\n    for (int a=0; a<n; a++)\n    {\n        printf(\"%li\\n\", supersigma(iv[a], jv[a]));\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n, imaior, imenor, tempm;\n    float temp[100000], maior, menor, media = 0;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%f\", &temp[i]);\n\n        if (i == 0)\n        {\n            maior = temp[i];\n            imaior = i;\n            menor = temp[i];\n            imenor = i;\n        }\n\n        else if (temp[i] > maior)\n        {\n            maior = temp[i];\n            imaior = i;\n        }\n\n        else if (temp[i] < menor)\n        {\n            menor = temp[i];\n            imenor = i;\n        }\n\n        media += temp[i];\n    }\n\n    media \/= n;\n\n    printf(\"%i %.1f\\n%i %.1f\\n%.1f\\n\", imenor, menor, imaior, maior, media);\n\n    for (int i=0; i<n; i++)\n    {\n        if (temp[i] >= media)\n        {\n            printf(\"%i \", i);\n        }\n    }\n    putchar('\\n');\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n, qtd = 0;\n    long int vet[1000], aux, aux2;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%li\", &vet[i]);\n        for (int j = i; j > 0; j--)\n        {\n            if (vet[j] < vet[j - 1])\n            {\n                aux = vet[j];\n                vet[j] = vet[j - 1];\n                vet[j - 1] = aux;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (i == 0)\n        {\n            aux2 = vet[i];\n            qtd++;\n        }\n\n        else if (vet[i] == aux2)\n        {\n            qtd++;\n        }\n\n        else if (vet[i] != aux2)\n        {\n            printf(\"%li %i\\n\", vet[i - 1], qtd);\n            qtd = 0;\n            aux2 = vet[i];\n            qtd++;\n        }\n\n        if (i == (n - 1))\n        {\n            printf(\"%li %i\\n\", vet[i], qtd);\n        }\n    }\n    \n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n\nvoid potencia(float x, int n, float xp[])\n{\n    float x0 = 1;\n    xp[0] = 1;\n\n    for (int i = 1; i <= n; i++)\n    {\n        x0 *= x;\n        xp[i] = x0;\n        \n    }\n}\n\nint main()\n{\n    int n;\n    long int q;\n    float x[100000], av[6], soma = 0, xp[5];\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%f\", &av[i]);\n    }\n\n    scanf(\"%li\", &q);\n\n    for (int i = 0; i < q; i++)\n    {\n        scanf(\"%f\", &x[i]);\n    }\n\n    for (int i = 0; i < q; i++)\n    {\n        potencia(x[i], n, xp);\n\n        for (int j = 0; j <= n; j++)\n        {\n            soma += av[j] * xp[j];\n            \n        }\n\n        printf(\"%f\\n\", soma);\n        soma = 0;\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <limits.h>\n#define true 1\n#define false 0\n\nint primos(long int maior, long int vet[])\n{\n    long int primo = 3;\n    int busca, i0;\n    vet[0] = 2;\n    for (int i = i; (vet[i] * vet[i]) <= maior;)\n    {\n        busca = true;\n        for (int j = i; (j >= 0) && (busca == true); j--)\n        {\n            if (primo % vet[j] == 0)\n                busca = false;\n        }\n\n        if (busca == true)\n        {\n            vet[i + 1] = primo;\n            i++;\n            i0 = i;\n        }\n\n        else if (busca == false)\n            primo++;\n    }\n\n    return i0;\n}\n\nint primo(long int num, long int vet[], int tam)\n{    \n    if (num == 1) return false;\n\n    else if (num == 2) return true;\n        \n    else\n    {\n        for (int j = 0; j <= tam; j++)\n        {\n            if ((num % vet[j] == 0) && (num != vet[j]))\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint main(int argc, char **argv)\n{\n    int t, tam, primovf;\n    long int n[200000], maior = 0, n0, vet[10000];\n\n    scanf(\"%i\", &t);\n\n    for (int i = 0; i < t; i++)\n    {\n        scanf(\"%li\", &n[i]);\n\n        if (n[i] > maior)\n            maior = n[i];\n    }\n\n    tam = primos(maior, vet);\n\n    for  (int i = 0; i < t; i++)\n    {\n        primovf = primo(n[i], vet, tam);\n\n        n0 = n[i];\n\n        while (primovf == true && n[i] >= 10)\n        {\n            n[i] \/= 10;\n            \n            primovf = primo(n[i], vet, tam);\n        }\n\n        if (primovf == true)\n            printf(\"S\\n\");\n        \n        else if (primovf == false)\n            printf(\"N\\n\");\n    }    \n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n#define true 1\n#define false 0\n#define iteracoes 30\n\ndouble x,seno;\nint i,j;\n\ndouble fatorial (int i)\n{\n    double res = 1;\n    for (int j=1; j<i; j++)\n    {\n        res = res*(j+1);\n    }\n    return res;\n}\n\ndouble potencia (double x, int i)\n{\n    double x0 = 1;\n    for (int j=0; j<i; j++)\n    {\n        x0 *= x;\n    }\n\n    return x0;\n}\n\nint main()\n{\n    scanf (\"%lf\",&x);\n    seno = x;\n\n    for (int i=3,j=1; j<=iteracoes; i=i+2,j++)\n    {\n        if ((j%2) == 0)\n        {\n            seno += potencia(x,i)\/fatorial(i);\n        }\n        else\n        {\n            seno -= potencia(x,i)\/fatorial(i);\n        }    \n        \n    }\n\n    printf (\"%.10lf\\n\", seno);\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char string[81], stringinv[81], aux;\n    int tam, tam1, busca;\n\n    fgets(string, 81, stdin);\n\n    for (int i=0; string[i] != '\\0'; i++)\n    {\n        if (string[i] == '\\n')\n        {\n            string[i] = '\\0';\n        }\n    }\n\n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        if (string[i] == ' ')\n        {\n            for (int j = i; string[j] != '\\0'; j++)\n            {\n                string[j] = string[j + 1];\n            }\n        }\n    }\n\n    tam = strlen(string);\n\n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        stringinv[i] = string[(tam - 1) - i];\n    }\n\n    busca = true;\n    \n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        if (string[i] != stringinv[i])\n        {\n            busca = false;\n            break;\n        }\n    }\n\n    if (busca == true)\n    {\n        printf(\"S\\n\");\n    }\n    else if (busca == false)\n    {\n        printf(\"N\\n\");\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main()\n{\n    char str[31];\n    long int tam, soma = 0, pot;\n\n    fgets(str, 31, stdin);\n\n    for (int i=0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n\n    tam = strlen(str);\n    pot = tam-1;\n\n    for (int i=0; i<tam; i++)\n    {\n        if (str[i] == '1')\n        {\n            soma += pow(2,(pot-i));\n        }\n    }\n\n    printf(\"%li\\n\", soma);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main()\n{\n    char hex[9];\n    long int soma = 0;\n    int tam, pot;\n\n    fgets(hex, 9, stdin);\n\n    for (int i = 0; hex[i] != '\\0'; i++)\n    {\n        if (hex[i] == '\\n')\n        {\n            hex[i] = '\\0';\n        }\n    }\n\n    tam = strlen(hex);\n    pot = tam - 1;\n\n    for (int i = 0; hex[i] != '\\0'; i++)\n    {\n        switch (hex[i])\n        {\n        case '1':\n            soma += 1 * pow(16, (pot - i));\n            break;\n\n        case '2':\n            soma += 2 * pow(16, (pot - i));\n            break;\n\n        case '3':\n            soma += 3 * pow(16, (pot - i));\n            break;\n\n        case '4':\n            soma += 4 * pow(16, (pot - i));\n            break;\n\n        case '5':\n            soma += 5 * pow(16, (pot - i));\n            break;\n\n        case '6':\n            soma += 6 * pow(16, (pot - i));\n            break;\n\n        case '7':\n            soma += 7 * pow(16, (pot - i));\n            break;\n\n        case '8':\n            soma += 8 * pow(16, (pot - i));\n            break;\n\n        case '9':\n            soma += 9 * pow(16, (pot - i));\n            break;\n\n        case 'a':\n            soma += 10 * pow(16, (pot - i));\n            break;\n\n        case 'b':\n            soma += 11 * pow(16, (pot - i));\n            break;\n\n        case 'c':\n            soma += 12 * pow(16, (pot - i));\n            break;\n\n        case 'd':\n            soma += 13 * pow(16, (pot - i));\n            break;\n\n        case 'e':\n            soma += 14 * pow(16, (pot - i));\n            break;\n\n        case 'f':\n            soma += 15 * pow(16, (pot - i));\n            break;\n\n        }\n    }\n\n    printf(\"%li\\n\", soma);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char t[1002], p[102];\n    int tamt, tamp, busca;\n\n    fgets(t, 1002, stdin);\n    fgets(p, 102, stdin);\n\n    for (int i = 0; t[i] != '\\0'; i++)\n    {\n        if (t[i] == '\\n')\n        {\n            t[i] = '\\0';\n        }\n    }\n\n    for (int i = 0; p[i] != '\\0'; i++)\n    {\n        if (p[i] == '\\n')\n        {\n            p[i] = '\\0';\n        }\n    }\n\n    tamt = strlen(t);\n    tamp = strlen(p);\n\n    \n\n    for (int i = 0; i <= (tamt - tamp); i++)\n    {\n        if (t[i] == p[0])\n        {\n            busca = true;\n            for (int k = 0; k < tamp; k++)\n            {\n                if (t[i+k] != p[k])\n                {\n                    busca = false;\n                    break;\n                }\n            }\n\n            if (busca == true)\n            {\n                printf (\"%i \", i);\n            }\n        }\n    }\n\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    char str[90];\n    int num[100000], k, n, tam, tam_total = 0;\n\n    scanf(\"%i\", &n);\n    scanf(\"%i\", &k);\n    getchar();\n\n    for (int j = 0; j < n; j++)\n    {\n        fgets(str, 90, stdin);\n\n        for (int i = 0; str[i] != '\\0'; i++)\n        {\n            if (str[i] == '\\n')\n            {\n                num[i + tam_total] = ((int)str[i]);\n            }\n            else\n            {\n                num[i + tam_total] = ((int)str[i]) + k;\n            }\n\n            if (num[i + tam_total] > 126)\n            {\n                num[i + tam_total] -= 95;\n            }\n\n            \n        }\n\n        tam = strlen(str);\n        tam_total += tam;\n    }\n\n    for (int i = 0; i < tam_total; i++)\n    {\n        printf(\"%c\", num[i]);\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    char str[82];\n    int num[100000], k, n, tam;\n    long int tam_total = 0;\n\n    scanf(\"%i\", &n);\n    scanf(\"%i\", &k);\n    getchar();\n\n    for (int j = 0; j < n; j++)\n    {\n        fgets(str, 82, stdin);\n\n        for (int i = 0; str[i] != '\\0'; i++)\n        {\n            if (str[i] == '\\n')\n            {\n                num[i + tam_total] = ((int)str[i]);\n            }\n\n            else\n            {\n                num[i + tam_total] = ((int)str[i]) - k;\n\n                if (num[i + tam_total] < 32)\n                {\n                    num[i + tam_total] += 95;\n                }\n            }\n        }\n\n        tam = strlen(str);\n        tam_total += tam;\n    }\n\n    for (long int i = 0; i < tam_total; i++)\n    {\n        printf(\"%c\", num[i]);\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char str[1001], aux;\n    int qtd = 1;\n\n    fgets(str, 1001, stdin);\n\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n\n    for (int i = 0; str[i] != '\\0';)\n    {\n        aux = str[i];\n\n        for (int k = 1; str[k] != '\\0'; k++)\n        {\n            if (aux != str[i + k])\n            {\n                break;\n            }\n            else\n            {\n                qtd++;\n            }\n            \n        }\n\n        i += qtd;\n\n        if (qtd == 1)\n        {\n            printf(\"%c\", aux);\n        }\n        \n        else\n        {\n            printf(\"%i%c\", qtd, aux);\n        }\n        \n        qtd = 1;\n    }\n\n    putchar('\\n');\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char str[1001];\n    int num[1001], aux, aux0, qtd = 1;\n\n    fgets(str, 1001, stdin);\n\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n\n    for (int i = 0; str[i] != '\\0';)\n    {\n        aux = atoi(&str[i]);\n        aux0 = aux;\n        \n\n        while (aux0 >= 10)\n        {\n            aux0 \/= 10;\n            qtd++;\n        }\n\n        if ((aux != 0) && (str[i + qtd] != '\\0'))\n        {\n            for (int j = 0; j < (aux - 1); j++)\n            {\n                printf(\"%c\", str[i + qtd]);\n            }\n        }\n\n        else\n        {\n            printf(\"%c\", str[i]);\n        }\n\n        i += qtd;\n        qtd = 1;\n    }\n\n    putchar('\\n');\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char str[1001], aux[1002], aux2[1002];\n    int tam, tam2, tam3, busca;\n\n    scanf(\"%1001[^\\n]s\", str);\n    tam = strlen(str);\n\n    for (int i = 1; i < tam; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            aux[j] = str[j];\n        }\n\n        tam2 = strlen(aux);\n        for (int j = 0; j < tam2; j++)\n        {\n            if ((int) aux[j] != (int) str[j])\n                aux[j] = '\\0';\n            \n            \n        }\n        tam2 = strlen(aux);\n        printf(\"%s %i\\n\", aux, tam2);\n\n        for (int j = tam2 - 2; j > 0; j--)\n        {\n            for (int k = 0; aux[j + k] != '\\0'; k++)\n            {\n                \n                for (int l = k; (l <= j + k)&&(str[l + tam2] != '\\0'); l++)\n                {\n                    printf(\"%c %c\\n\", aux[l], str[l + j]);\n                }\n                putchar('\\n');\n            }\n        }\n        \n        for (int j = tam2 - 1; j <= 0; j--)\n        {\n            aux[j] = '\\0';\n        } \n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    char str0[1002], str[1002], aux[1002];\n    int qtd = 0, tam, busca, busca1, tam0, tam1, tam2, p2, p1, k1, h1;\n\n    scanf(\"%1002[^\\n]s\", str);\n\n    tam = strlen(str);\n\n    for (int i = (tam \/ 2); i > 1; i--)\n    {\n        for (int h = 0; str[(2 * i) + h - 1] != '\\0'; h++)\n        {\n            h1 = h;\n        }\n        \n        for (int h = h1; h >= 0; h--)\n        {\n            for (int j = 0; j < i; j++)\n            {\n                aux[j] = str[j + h];\n            }\n\n            tam0 = strlen(aux);\n            for (int j = 0; j < tam0; j++)\n            {\n                if (((int)aux[j] < 97) || ((int)aux[j] > 122))\n                    aux[j] = '\\0';\n            }\n\n            tam0 = strlen(aux);\n            \n\n            printf(\"\\n%s %i\\n\", aux, tam0);\n\n            for (int k = 0; str[2 * i - 1 + k + h] != '\\0'; k++)\n            {\n                k1 = k;\n            }\n\n            for (int k = k1; k >= 0; k--)\n            {\n                busca = true;\n                for (int l = 0; ((l < tam0)&&(busca == true)); l++)\n                {\n                    \n\n                    if (aux[l] != str[i + k + l + h])\n                    {\n                        busca = false;\n                    }\n                    p2 = i + k + l + h;\n                    p1 = i + k + h;\n                }\n\n                if (busca == true)\n                {\n                    if (str[p2 + 1] == '\\0')\n                    {\n                        for (int j = p2; j >= p1; j--)\n                        {\n                            str[j] = '\\0';\n                        }\n                    }\n\n                    else\n                    {\n                        for (int j = p1; (j <= p2)||(str[j+tam0] != '\\0'); j++)\n                        {                           \n                            str[j] = str[j + tam0];\n                            str[j + tam0] = '\\0';\n\n                            \n                        }\n                    }\n                    qtd ++;\n                    printf(\"\\ntrue %i %i\\n%s\\n\", p1, p2, aux);\n                }\n\n                \n            }\n\n            for (int j = tam0 - 1; j >= 0; j--)\n            {\n                aux[j] = '\\0';\n            }\n        }\n    }\n\n    printf(\"\\n%s %li %i\\n\", str, strlen(str), qtd);\n    printf(\"%li\\n\", strlen(str) + qtd);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h> \n#include \"funcoes.h\" \n#define iteracoes 10000\n\nint main()\n{\n    int n;\n    double a[7], l, r, m;\n\n    scanf(\"%i\", &n); \n    getchar();\n\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%lf\", &a[i]); \n        getchar();\n    }\n\n    scanf(\"%lf\", &l); \n    getchar();\n    scanf(\"%lf\", &r); \n    getchar();\n\n    for (long int i = 0; i <= iteracoes; i++)\n    {\n\n        m = l + ((r-l)\/2);\n\n        if (fabs(f_de_x(n, a, m)) <= 0.0001) \n        {\n            printf(\"\\n%lf\\n\\n\", m); \n            return 0;\n        }\n\n        if ((f_de_x(n, a, m) * f_de_x(n, a, l)) < 0) \n        {\n            r = m; \n        }\n        \n        else \n        {\n            l = m; \n        }\n\n        if (i == iteracoes)\n        {\n            printf(\"raiz nao encontrada\\n\"); \n        }\n\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nvoid fill_letters(char str[], char letters[])\n{\n    int busca, tam;\n\n    letters[0] = str[0];\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        busca = false;\n        for (int j = 0; (letters[j] != '\\0') && (busca == false); j++)\n        {\n            if (letters[j] == str[i])\n            {\n                busca = true;\n            }\n        }\n        if (busca == false)\n        {\n            tam = strlen(letters);\n            letters[tam] = str[i];\n            letters[tam + 1] = '\\0';\n        }\n    }\n}\n\nint main()\n{\n    char str[100002], letters[100002];\n    int qtd, tam_s, impar = false, pali = true;\n\n    fgets(str, 100002, stdin);\n\n    if (str[strlen(str) - 1] == '\\n')\n    {\n        str[strlen(str) - 1] = '\\0';\n    }\n\n    fill_letters(str, letters);\n    tam_s = strlen(str);\n\n    for (int i = 0; (letters[i] != '\\0') && (pali == true); i++)\n    {\n        qtd = 0;\n        for (int j = 0; str[j] != '\\0'; j++)\n        {\n            if (letters[i] == str[j])\n            {\n                qtd++;\n            }\n        }\n\n        if (tam_s % 2 == 0)\n        {\n            if (qtd % 2 != 0)\n            {\n                pali = false;\n            }\n        }\n        else\n        {\n            if (qtd % 2 != 0)\n            {\n                if (impar == false)\n                {\n                    impar = true;\n                }\n                else if (impar == true)\n                {\n                    pali = false;\n                }\n            }\n        }    \n    }\n\n    if (pali == true)\n    {\n        printf(\"Sim\\n\");\n    }\n\n    else\n    {\n        printf(\"Nao\\n\");\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#define true 1\n#define false 0\n\nvoid sequencia(int seq[], int print)\n{\n    int tam[10000], seq_aux[10000], qtd, k = 0, tam_s;\n    for (int i = 0; seq[i] != 0; i++)\n    {\n        qtd = 0;\n        for (int j = i; seq[j] == seq[i]; j++)\n        {\n            qtd++;\n        }\n\n        i += qtd - 1;\n        tam[k] = qtd;\n        seq_aux[k] = seq[i];\n        k++;\n    }\n\n    for (int i = 0, j = 0, a = 0; j < k; a++)\n    {\n        if (a % 2 == 0)\n        {\n            seq[a] = tam[i];\n            i++;\n        }\n\n        else if (a % 2 != 0)\n        {\n            seq[a] = seq_aux[j];\n            j++;\n        }\n\n        if (print == true)\n        {\n            printf(\"%i\", seq[a]);\n        }\n    }\n}\n\nint main()\n{\n    int seq[10000], n, tam_s; \n\n    seq[0] = 1;\n\n    scanf(\"%i\", &n);\n\n    if (n == 1)\n    {\n        printf(\"%i\\n\", seq[0]);\n    }\n\n    else\n    {\n        for (int i = 1; i < n; i++)\n        {\n            if (i == (n - 1))\n            {\n                sequencia(seq, true);\n                putchar('\\n');\n            }\n            else\n            {\n                sequencia(seq, false);\n            }\n        }\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    double A[100][100], B[100][100], soma = 0;\n    int n, m, k, l;\n\n    scanf(\"%i %i %i %i\", &n, &m, &k, &l);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            scanf(\"%lf\", &A[i][j]);\n        }\n    }\n\n    for (int i = 0; i < k; i++)\n    {\n        for (int j = 0; j < l; j++)\n        {\n            scanf(\"%lf\", &B[i][j]);\n        }\n    }\n\n    if (m != k)\n    {\n        printf(\"impossivel\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < l; j++)\n        {\n            for (int a = 0; a < m; a++)\n            {\n                soma += A[i][a] * B[a][j];\n            }\n            printf(\"%.2lf \", soma);\n            soma = 0;\n        }\n        putchar('\\n');\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    float A[100][100];\n    int n, m;\n\n    scanf(\"%i %i\", &n, &m);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            scanf(\"%f\", &A[i][j]);\n        }\n    }\n\n    for (int j = 0; j < m; j++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            if (i == (n-1)) printf(\"%.2f\", A[i][j]);\n            \n            else printf(\"%.2f \", A[i][j]);\n        }\n        putchar('\\n');\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint popstar(int N[][1000], int j, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (N[i][j] != 1) return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    int N[1000][1000], n, maybe[1000], busca, busca_p, k = 0;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        busca = true;\n\n        for (int j = 0; j < n; j++)\n        {\n            scanf(\"%i\", &N[i][j]);\n            \n            if ((j != i) && (N[i][j] != 0)) busca = false;\n            else if ((j == i) && (N[i][j] != 1)) busca = false;\n            \n        }\n\n        if (busca == true)\n        {\n            maybe[k] = i;\n            k++;\n        }\n    }\n\n    if (k == 0)\n    {\n        printf(\"Nao ha popstar.\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < k; i++)\n    {\n        busca_p = popstar(N, maybe[i], n);\n\n        if (busca_p == true) printf(\"Popstar: aluno #%i\\n\", maybe[i] + 1);\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <limits.h>\n\nint main()\n{\n    int matriz[1000][1000], n, soma, maior = INT_MIN, k0;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n\n    for (int k = (-n + 1); k < n; k++)\n    {\n        soma = 0;\n        for (int i = 0, j; i < n; i++)\n        {\n            j = i + k;\n            if (j >= 0 && j < n)\n            {\n                soma += matriz[i][j];\n            }\n        }\n\n        if (soma > maior)\n        {\n            maior = soma;\n            k0 = k;\n        }\n    }\n\n    printf(\"%i %i\\n\", k0, maior);\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    int vet[10], num, busca = false, busca2;\n\n    for (int i=0; i<10; i++)\n    {\n        scanf (\"%i\", &vet[i]);\n    }\n\n    putchar ('\\n');\n    scanf (\"%i\", &num);\n\n    for (int i=0; i<10; i++)\n    {\n        for (int j=0; j<10; j++)\n        {\n            if (j != i)\n            {\n                if ((vet[i] * vet[j]) == num)\n                {\n                    printf (\"\\n%i * %i = %i\", vet[i], vet[j], num);\n                    busca = true;\n                }\n            }\n        }\n    }\n\n    if (busca == false)\n    {\n        printf (\"\\nN\u00e3o existe n\u00fameros\\n\\n\");\n    }\n\n    if (busca == true)\n    {\n        printf (\"\\n\\n\");\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int n;\n    scanf (\"%i\", &n);\n\n    n = (n\/2)+1;\n\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=(n-1); j>=i; j--)\n        {\n            putchar (' ');\n        }\n        for (int k=1; k<=i; k++)\n        {\n            putchar ('*');\n        }\n        for (int l=1; l<i; l++)\n        {\n            putchar ('*');\n        }\n        putchar ('\\n');\n    }\n    for (int i=(n-1); i>0; i--)\n    {\n        for (int j=i; j<n; j++)\n        {\n            putchar (' ');\n        }\n        for (int k=1; k<=i; k++)\n        {\n            putchar ('*');\n        }\n        for (int l=1; l<i; l++)\n        {\n            putchar ('*');\n        }\n        putchar ('\\n');\n    }\n    putchar ('\\n');\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <math.h>\n#include \"funcoes.h\"\n\ndouble fatorial(int n)\n{\n    double x = 1;\n\n    for (int i = 2; i <= n; i++)\n    {\n        x *= i; \n    }\n\n    return x; \n}\n\ndouble f_de_x(int n, double a[], double x) \n{\n    double soma = 0;\n\n    for (int i = 0; i <= n; i++)\n    {\n        soma += a[i] * pow(x, i); \n    }\n\n    return soma; \n}\n\nint f_de_x_taylor(int n, double at[], double x, double xf)\n{\n    double soma = 0;\n\n    for (int i = 0; i <= n; i++)\n    {\n        soma += (at[i] * pow(x, i)) \/ fatorial(i); \n\n        printf(\"%i %lf %lf\\n\", i + 1, soma, xf); \n\n        if (fabs(soma - xf) <= 0.001) \n            return 0;\n    }\n\n    return 0;\n}\n\nvoid vetor_taylor(int n, double a[], double x, double xf)\n{\n    double at[7];\n\n    for (int i = 0; i <= n; i++)\n    {\n        at[i] = a[i]; \n    }\n\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i; j > 0; j--)\n        {\n            at[i] *= j; \n        }\n    }\n\n    f_de_x_taylor(n, at, x, xf); \n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main ()\n{\n    long int num, primo = true, i = 3;\n    scanf (\"%li\", &num);\n\n    if (num == 1)\n    {\n        printf (\"Composto!\\n\");\n    }\n\n    else if (num == 2)\n    {\n        printf (\"Primo!\\n\");\n    }\n\n    else if ((num % 2) == 0)\n    {\n        printf (\"Composto!\\n\");\n    }\n\n    else\n    { \n        while (((i*i) <= num)&&(primo == true))\n        {\n            if ((num % i) == 0)\n            {\n                primo = false;\n            }\n            i += 2;\n        }\n\n        if (primo == true)\n        {\n            printf (\"Primo!\\n\");\n        }\n        else\n        {\n            printf (\"Composto!\\n\");\n        }\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main ()\n{\n    int n, qtd;\n    scanf (\"%i\", &qtd);\n\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n\n        while (n>=1000)\n        {\n            putchar ('M');\n            n -= 1000;\n        }\n\n        if ((900<=n)&&(n<=999))\n        {\n            printf (\"CM\");\n            n -= 900;\n        }\n        else if ((800<=n)&&(n<=899))\n        {\n            printf (\"DCCC\");\n            n -= 800;\n        }\n        else if ((700<=n)&&(n<=799))\n        {\n            printf (\"DCC\");\n            n -= 700;\n        }\n        else if ((600<=n)&&(n<=699))\n        {\n            printf (\"DC\");\n            n -= 600;\n        }\n        else if ((500<=n)&&(n<=599))\n        {\n            printf (\"D\");\n            n -= 500;\n        }\n        else if ((400<=n)&&(n<=499))\n        {\n            printf (\"CD\");\n            n -= 400;\n        }\n        else if ((300<=n)&&(n<=399))\n        {\n            printf (\"CCC\");\n            n -= 300;\n        }\n        else if ((200<=n)&&(n<=299))\n        {\n            printf (\"CC\");\n            n -= 200;\n        }\n        else if ((100<=n)&&(n<=199))\n        {\n            printf (\"C\");\n            n -= 100;\n        }\n\n        if ((90<=n)&&(n<=99))\n        {\n            printf (\"XC\");\n            n -= 90;\n        }\n        else if ((80<=n)&&(n<=89))\n        {\n            printf (\"LXXX\");\n            n -= 80;\n        }\n        else if ((70<=n)&&(n<=79))\n        {\n            printf (\"LXX\");\n            n -= 70;\n        }\n        else if ((60<=n)&&(n<=69))\n        {\n            printf (\"LX\");\n            n -= 60;\n        }\n        else if ((50<=n)&&(n<=59))\n        {\n            printf (\"L\");\n            n -= 50;\n        }\n        else if ((40<=n)&&(n<=49))\n        {\n            printf (\"XL\");\n            n -= 40;\n        }\n        else if ((30<=n)&&(n<=39))\n        {\n            printf (\"XXX\");\n            n -= 30;\n        }\n        else if ((20<=n)&&(n<=29))\n        {\n            printf (\"XX\");\n            n -= 20;\n        }\n        else if ((10<=n)&&(n<=19))\n        {\n            printf (\"X\");\n            n -= 10;\n        }\n\n        switch (n)\n        {\n            case 9:\n                printf (\"IX\");\n                n -= 9;\n                break;\n            case 8:\n                printf (\"VIII\");\n                n -= 8;\n                break;\n            case 7:\n                printf (\"VII\");\n                n -= 7;\n                break;\n            case 6:\n                printf (\"VI\");\n                n -= 6;\n                break;\n            case 5:\n                printf (\"V\");\n                n -= 5;\n                break;\n            case 4:\n                printf (\"IV\");\n                n -= 4;\n                break;\n            case 3:\n                printf (\"III\");\n                n -= 3;\n                break;\n            case 2:\n                printf (\"II\");\n                n -= 2;\n                break;\n            case 1:\n                printf (\"I\");\n                n -= 1;\n                break;\n\n        }\n        printf (\"\\n\");\n    }\n\n    return 0;\n\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int qtd, n, qtd_total = 0;\n    scanf (\"%i\", &qtd);\n\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n\n        while (n>=100)\n        {\n            n -= 100;\n            qtd_total++;\n        }\n        \n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd_total++;\n        } \n\n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd_total++;\n        }\n\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd_total++;\n        }\n\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd_total++;\n        }\n\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd_total++;\n        }\n\n        if (n==1)\n        {\n            n--;\n            qtd_total++;\n        }\n    \n        printf (\"%i notas\\n\", qtd_total);\n        qtd_total = 0;\n\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n\nint main()\n{\n    int qtd, n, qtd_total, qtd100 = 0, qtd50 = 0, qtd25 = 0, qtd10 = 0, qtd5 = 0, qtd2 = 0, qtd1 = 0;\n    scanf (\"%i\", &qtd);\n\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=100)\n        {\n            n -= 100;\n            qtd100++;\n        }\n        \n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd50++;\n        } \n\n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd25++;\n        }\n\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd10++;\n        }\n\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd5++;\n        }\n\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd2++;\n        }\n\n        if (n==1)\n        {\n            n--;\n            qtd1++;\n        }\n        \n        qtd_total = qtd100+qtd50+qtd25+qtd10+qtd5+qtd2+qtd1;\n        printf (\"%i notas\\n%i notas de 100\\n%i notas de 50\\n%i notas de 25\\n%i notas de 10\\n%i notas de 5\\n%i notas de 2\\n%i notas de 1\\n\", qtd_total, qtd100, qtd50, qtd25, qtd10, qtd5, qtd2, qtd1);\n        qtd_total = 0;\n        qtd100 = 0;\n        qtd50 = 0;\n        qtd25 = 0;\n        qtd10 = 0;\n        qtd5 = 0;\n        qtd2 = 0;\n        qtd1 = 0;\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"lz77encode.h\" \n#include \"lz77decode.h\" \n#define true 1\n#define false 0\n\nint main()\n{\n    char *str = NULL;\n    int tam, k = 6, i0;\n\n    str = malloc(10002 * sizeof(char)); \n\n    fgets(str, 10002, stdin);\n    tam = strlen(str);\n\n    if (*(str + tam - 1) == '\\n') \n    {\n        *(str + tam - 1) = '\\0';\n    }\n\n    \n    if (*str == '(')\n    {\n        decompress(str); \n    }\n    \n\n\n    \n    else\n    {\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n\n        compress(str, k); \n    }\n    \n\n    free(str); \n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"lz77decode.h\"\n\nvoid decompress(char *compressed_str)\n{\n    \n\n    int pos,             \n        tam,             \n        tam_d,           \n        tam_total = 1;   \n\n    char letra,          \n        *decom = NULL;   \n\n    decom = malloc(1 * sizeof(char)); \n\n    while (*compressed_str)           \n    {\n        if (*compressed_str == '(')   \n        {\n            compressed_str++;\n            \n            \n\n            \n            if (*compressed_str == '-')\n            {\n                pos = -1;\n            }\n\n            \n            else\n            {\n                pos = atoi(compressed_str);\n            }\n\n\n            \n            while (*compressed_str != ',')\n            {\n                compressed_str++;\n            }\n            compressed_str++;\n\n\n            tam = atoi(compressed_str);                       \n            tam_total += tam + 1;                             \n            decom = realloc(decom, tam_total * sizeof(char)); \n            \n\n            \n            while (*compressed_str != ',')\n            {\n                compressed_str++;\n            }\n            compressed_str++;\n\n\n            \n            if (*compressed_str == '\\\\' && *(compressed_str + 1) == '0')\n            {\n                letra = '\\0';\n            }\n\n            \n            else\n            {\n                letra = *compressed_str; \n            }\n            compressed_str++;\n            \n\n\n            \n\n            tam_d = strlen(decom);\n\n            \n            if (pos == -1)\n            {\n                *decom = letra;\n                *(decom + 1) = '\\0';\n            }\n            \n            else if (pos == 0) \n            {\n                *(decom + tam_d) = letra;\n                *(decom + tam_d + 1) = '\\0';\n            }\n            \n            else\n            {\n                int i, \n                    j; \n\n                for (i = tam_d - pos, j = 0; j < tam; i++, j++)\n                {\n                    \n                    if (i == tam_d)\n                    {\n                        i = tam_d - pos;\n                    }\n                    *(decom + j + tam_d) = *(decom + i);\n                }\n\n                \n                *(decom + tam_d + tam) = letra;\n\n                \n                *(decom + tam_d + tam + 1) = '\\0';\n            }\n            \n        }\n        compressed_str++;\n    }\n\n    \n    tam_d = strlen(decom);\n    \n    for (int i = 0; i < tam_d; i++)\n    {\n        printf(\"%c\", *(decom + i));\n    }\n    putchar('\\n');\n    \n    \n\n    free(decom); \n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include \"lz77encode.h\"\n#define true 1\n#define false 0\n\nvoid compress(char *str, int k)\n{\n    int pos,         \n        tam_maior,   \n        tam,         \n        pos_aux,     \n        indice = 0,  \n        i_aux,       \n        end = false; \n\n    \n    printf(\"(-1,0,%c)\", *str); \n\n    str++;\n    indice++;\n    \n\n    \n    while (*str) \n    {\n\n        \n        tam_maior = 0;\n\n        \n        pos = 0;\n\n        \n        for (int i = indice - 1; i >= (indice - k) && i >= 0; i--)\n        {\n            \n            if (*(str - indice + i) == *(str))\n            {\n                tam = 0;\n                i_aux = i;\n\n                \n                for (int j = 0; *(str - indice + i_aux + j) == *(str + j); j++)\n                {\n                    \n                    if (j == 0) \n                    {\n                        pos_aux = -(-indice + i_aux + j);\n                    }\n\n                    \n                    if ((-indice + i_aux + j) >= 0)\n                    {\n                        i_aux = i - j;\n                    }\n\n                    tam++;\n                }\n\n                \n                if (tam > tam_maior)\n                {\n                    tam_maior = tam;\n                    pos = pos_aux;\n                }\n            }\n        }\n        \n        str += tam_maior;\n        \n        indice += tam_maior;\n        \n\n        \n        \n        \n        if (*str == '\\0')\n        {\n            printf(\"(%i,%i,\\\\0)\", pos, tam_maior);\n            end = true;\n        }\n        else\n        {\n            printf(\"(%i,%i,%c)\", pos, tam_maior, *str);\n        }\n        \n\n        \n        str++;\n        indice++;\n    }\n\n    if (end == false) \n    {\n        printf(\"(0,0,\\\\0)\");\n    }\n    putchar('\\n');\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    int n, av[10000], bv[10000], cv[10000], xyz[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%i\", &av[i]);\n        scanf(\"%i\", &bv[i]);\n        scanf(\"%i\", &cv[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        a = av[i];\n        b = bv[i];\n        c = cv[i];\n\n        solucao2 = false;\n\n        for (y = (-c); y <= c; y++)\n        {\n            for (z = y; z <= c; z++)\n            {\n                x = a - y - z;\n                if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c))\n                {\n                    solucao = true;\n                    if (k != 0)\n                    {\n                        for (int j=0; j<=(k-3); j++)\n                        {\n                            if ((x == xyz[j])||(y == xyz[j])||(z == xyz[j]))\n                            {\n                                solucao = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (solucao == true)\n                    {\n                        printf(\"%i %i %i\\n\", y, z, x);\n                        solucao2 = true;\n                        xyz[k] = x;\n                        xyz[k+1] = y;\n                        xyz[k+2] = z;\n                        k += 3;\n                    }\n                }\n            }\n        }\n        if (solucao2 == false)\n            printf(\"Sem solucao\\n\");\n    }\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint sistema(int a, int b, int c)\n{\n    int x, y, z;\n    for (y = (-c); y <= c; y++)\n    {\n        for (z = (y+1); z <= c; z++)\n        {\n            x = a - y - z;\n            if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c) && (z != x) && (y != x))\n            {\n                printf(\"%i %i %i\\n\", y, z, x);\n                return 0;\n            }\n        }\n    }\n    printf(\"Sem solucao\\n\");\n    \n    return 0;\n}\n\nint main()\n{\n    int n, av[10000], bv[10000], cv[10000], xv[100000], yv[100000], zv[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;\n\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%i\", &av[i]);\n        scanf(\"%i\", &bv[i]);\n        scanf(\"%i\", &cv[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        sistema (av[i], bv[i], cv[i]);\n    }\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h> \n#include \"funcoes.h\" \n\nint main()\n{\n    int n, q;\n    double a[7], x[100], xf;\n\n    scanf(\"%i\", &n); \n    getchar();\n\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%lf\", &a[i]); \n        getchar();\n    }\n\n    scanf(\"%i\", &q); \n\n    for (int i = 0; i < q; i++)\n    {\n        scanf(\"%lf\", &x[i]); \n        getchar();\n    }\n\n    putchar('\\n');\n    for (int i = 0; i < q; i++)\n    {\n        xf = f_de_x(n, a, x[i]); \n\n        vetor_taylor(n, a, x[i], xf); \n        \n        putchar('\\n');\n    }\n\n    return 0;\n}"}
{"target":"henrique-tavares","func":"#include <stdio.h>\n#define true 1\n#define false 0\n\nint main()\n{\n    int n, primos[10000], aux = 3, k = 0, primo;\n    primos[0] = 2;\n\n    scanf(\"%i\", &n);\n\n    for (int i=0; i< n; i++)\n    {\n        primo = true;\n        for (int j=k; j>=0; j--)\n        {\n            if ((aux % primos[j]) == 0)\n            {\n                primo = false;\n            }\n        }\n\n        if (primo == false)\n        {\n            aux+=2;\n        }\n\n        if (primo == true)\n        {\n            primos[k+1] = aux;\n            k++;\n        }\n    }\n\n    for (int i=0; i<=k; i++)\n    {\n        printf(\"%i \", primos[i]);\n    }\n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <errno.h>\n#include <string.h>\n\nint main(){\n\n    int n=5, status;\n\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n\n    for (int i=0; i<n; i++){\n        \n        switch (fork()){ \n        \n        case -1:\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        \n        case 0:\n            printf(\"Hijo %d con ID %d, padre: %d \\n\", i+1, getpid(), getppid());\n            exit(EXIT_SUCCESS); \n\n        default:\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status); \n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status)); \n            printf(\"\\n\");\n\n        }\n\n        \n    } \n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <errno.h>\n#include <string.h>\n\nint main(){\n\n    int nHijos=5, hijo, status;\n\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n\n    for (int i=0; i<nHijos; i++){\n        \n        hijo=fork(); \n            \n        switch (hijo){\n        \n        case -1:\n\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        \n        case 0:\n\n            printf(\"Hijo %d con ID %d del proceso %d \\n\", i+1, getpid(), getppid());\n            printf(\"\\n\");\n            break;\n\n        default:\n\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status);\n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status));\n            printf(\"\\n\");\n            exit(EXIT_SUCCESS);\n\n        }\n\n        \n    } \n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <errno.h>\n#include <string.h>\n\nint main(){\n\n    int status;\n    pid_t hijo;\n\n    printf(\"Soy el padre \\n\");\n    printf(\"\\n\");\n\n    hijo = fork();\n\n    if (hijo == -1){\n\n        printf(\"Error \\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (hijo == 0){\n\n        printf(\"HIJO ID: %d \\n\", getpid());\n        exit(EXIT_SUCCESS);\n    }\n\n    else{\n\n        printf(\"sleep 20s \\n\");\n        sleep(20);\n\n        wait(&status);\n\n        printf(\"Proceso hijo termindo con el codigo %d \\n\", WEXITSTATUS(status));\n\n        sleep(20);\n        exit(EXIT_SUCCESS);\n    }\n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char * argv[]){\n\n    switch (fork()){\n\n        case -1:\n\n                printf(\"ERROR\");\n                exit(EXIT_FAILURE);\n                break;\n\n        case 0: \n\n                printf(\"soy el hijo numero %d; mi padre es %d\\n\", getpid(), getppid); \n                execlp(argv[1], argv[1], NULL);\n                exit(EXIT_SUCCESS);\n                \n                break;\n    }\n\n    \n    switch (fork()){\n\n        case -1:\n\n                printf(\"ERROR\");\n                exit(EXIT_FAILURE);\n                break;\n\n        case 0: \n\n                printf(\"soy el hijo numero %d; mi padre es %d\\n\", getpid(), getppid); \n                execvp(argv[2], argv+2);\n                exit(EXIT_SUCCESS);\n                break;\n    }\n\n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char * argv[]){\n\n    int status;\n\n    printf(\"Soy el proceso %d\\n\", getpid());\n\n    for (int i = 0; i < argc - 1; i++){\n\n\n        switch (fork()){\n\n            case -1:\n\n                    printf(\"ERROR\");\n                    exit(EXIT_FAILURE);\n                    break;\n\n            case 0: \n\n                    printf(\"soy el hijo numero %d; mi padre es el proceso: %d\\n\", getpid(), getppid); \n\n                        printf(\" %i \\n\", factorial( atoi(argv[i+1]) ) );\n                    exit(EXIT_SUCCESS);\n                \n                    break;\n\n            default:\n\n                    wait(&status); \n        }\n\n    }\n\n    return 0;\n}\n\n\nint factorial(int n){ \n\n  int resultado = 1;\n\n  for (int i = n; i > 0; i--) {\n\n    resultado *=i;\n  }\n  \n  return resultado;\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys\/wait.h>\n#include <errno.h>\n#include <string.h>\n\nint variableGlobal = 0;\n\nint main(){\n\n    int n=5, status;\n\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n\n    for (int i=0; i<n; i++){\n        \n        switch (fork()){ \n        \n        case -1:\n\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        \n        case 0:\n\n            printf(\"Hijo %d con ID %d, padre: %d \\n\", i+1, getpid(), getppid());\n\n            variableGlobal++;\n            printf(\"%i\\n\", variableGlobal);\n\n            exit(EXIT_SUCCESS); \n\n        default:\n\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status); \n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status)); \n            printf(\"\\n\");\n\n        }\n\n        \n    } \n\n    printf(\"%i\\n\", variableGlobal);\n\n    return 0;\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint i=0;\n\nvoid RING(){    \n\n    printf(\"RING\\n\");\n\n    i++;    \n\n    if (i==4){  \n  \n        kill(getpid(), SIGKILL);    \n    }\n  \n}\n\nint main(int argc, char const *argv[]){\n\n    signal(SIGALRM, RING);  \n\n    alarm(5);     \n    pause();      \n\n    alarm(3);     \n    pause();      \n\n    while (1){    \n\n        alarm(1);   \n        pause();    \n    } \n\n    exit(EXIT_SUCCESS);     \n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <sys\/types.h>\n#include <sys\/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\nvoid tratarSignal() { printf(\"Se\u00f1al recibida\\n\"); }\n\nint main(){\n\n    pid_t pid;\n\n    printf(\"Soy %d el padre de todos\\n\", getpid()); \n\n    pid = fork();\n\n    switch(pid){\n\n\n        case -1: \n\n            printf(\"Error al crear el proceso hijo\\n\"); \n            exit(EXIT_FAILURE);\n\n        case 0:\n\n            signal(SIGUSR1, tratarSignal);      \n\n            printf(\"Soy %d el hijo del proceso: %d\\n\", getpid(), getppid()); \n\n            for (int i = 0; i < 5; i++){      \n        \n                pause();\n            }\n\n            sleep(10);\n\n\n        default: \n\n            printf(\"Esperando a que acabe mi hijo\\n\");\n\n            for (int i = 0; i < 5; i++){ \n      \n                sleep(3);\n                kill(pid, SIGUSR1);\n            }\n\n            sleep(3);\n            kill(pid, SIGKILL);\n    }\n   \n  exit(EXIT_SUCCESS); \n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n\n\n\n\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid * generarNumeros(){\n\n    int * z = malloc(sizeof(int)); \n\n    int x = rand() % 10;\n    printf(\"x = %i \\n\", x);\n\n    int y = rand() % 10;\n    printf(\"y = %i \\n\", y);\n\n    *z = x + y;\n\n    printf(\"x + y = %i \\n\", *z);\n\n    pthread_exit(z);\n}\n\n\nint main(int argc, char const *argv[]){\n\n    srand (time(NULL));\n\n    int nHebras = atoi(argv[1]);\n\n    pthread_t thread[nHebras]; \n\n    int *numero, suma=0; \n\n    for (int i = 0; i < nHebras; i++){\n   \n        if( pthread_create( &(thread[i]), NULL, (void*) generarNumeros, NULL ) != 0 ){ \n\n            fprintf(stderr, \"Error al crear la hebra\");         \n            exit(EXIT_FAILURE);                                 \n        }\n    }\n\n\n    for (int i = 0; i < nHebras; i++){\n   \n        if( pthread_join( thread[i], (void **) &numero ) != 0 ){ \n\n            fprintf(stderr, \"Error al usar join\");         \n            exit(EXIT_FAILURE);                  \n        }\n\n        suma = suma + *numero;\n    }\n    \n    printf(\"%i\", suma);\n\n    return 0;\n}\n\n"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid * cuentaLineas( void * argv ){\n\n    int * numeroLineas = malloc(sizeof(int));\n\n    * numeroLineas = 0;\n    \n    char const * fichero;\n\n    char aux[256];\n\n    fichero = (char*) argv;\n\n    FILE* f = fopen(fichero, \"r\"); \n\n    if (f==NULL){\n\n        printf(\"Error al abrir el archivo\\n\"); \n        EXIT_FAILURE;\n    }\n\n    while(fgets(aux, 256, f)!=NULL){ ++*numeroLineas; } \n    \n    fclose(f);\n \n    pthread_exit( (void**) numeroLineas);\n}\n\n\nint main(int argc, char const * argv[] ){\n\n    int totalLineas = 0;\n\n    int * retorno;\n\n    pthread_t hilos[argc-1];\n\n    for (int i = 0; i < argc-1; i++){\n    \n        if ( pthread_create( &(hilos[i]), NULL, (void *) cuentaLineas, (void *) argv[i+1] ) != 0){\n        \n            fprintf(stderr, \"Error en la creacion de la hebra \\n\");\n\n            exit(EXIT_FAILURE);\n        }\n        \n    }\n\n    for (int i = 0; i < argc-1; i++){\n    \n        if ( pthread_join( hilos[i], (void **) &retorno ) != 0){\n        \n            fprintf(stderr, \"Error al hacer join \\n\");\n\n            exit(EXIT_FAILURE);\n        }\n\n        printf(\"El numero de lineas del fichero %i es %d \\n\", i + 1, *retorno);\n\n\n        totalLineas = totalLineas + *retorno;\n    }\n    \n    printf(\"El numero de lineas totales son %i \\n\", totalLineas);\n\n    return 0;\n}"}
{"target":"jdes01","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <pthread.h>\n\ntypedef struct{\n\n  int * vector;\n  int numeroElementos;\n\n} vInfo;\n\nint comprobacionArgumento(int argumento){\n\n  if (argumento==2 || argumento==5){ return 1; }\n\n  return 0;\n}\n\nint * reservarMemoria(int numeroElementos){\n\n    int *vector;\n\n    vector = (int *) malloc( numeroElementos * sizeof(int) );\n\n    return vector;\n}\n\nvoid rellenaVector(int *vector, int numeroElementos){\n\n    srand( time(NULL) );\n\n    for (int i = 0; i < numeroElementos; ++i){ vector[i] = (rand() % 9) + 1; }\n}\n\nvoid imprimeVector (int *vector, int numeroElementos){\n\n    printf(\"[\");\n    printf(\" %d \", vector[0]);\n\n    for (int i = 1; i < numeroElementos; ++i){ printf(\", %d \", vector[i]); }\n\n    printf(\"]\\n\");\n    printf(\"\\n\");\n}\n\nvInfo * creaHijos(int * vPadre, int numeroHilos){\n\n    int numeroElementos = 10 \/ numeroHilos;\n\n    vInfo * vHijos = (vInfo *) malloc (numeroHilos * sizeof(vInfo));\n\n    for (int i=0;i<numeroHilos;i++){\n\n        vHijos[i].vector = reservarMemoria(numeroElementos);\n\n        vHijos[i].numeroElementos = numeroElementos;\n\n        int k = 0;\n\n        for (int j = (i * numeroElementos); j < ( (i * numeroElementos) + numeroElementos ); j++){\n\n            vHijos[i].vector[k] =vPadre[j];\n\n            k++;\n        }\n\n        printf(\"El vector hijo es: \\n\");\n    \n        imprimeVector(vHijos[i].vector, vHijos->numeroElementos);\n    }\n\n    return vHijos;\n}\n\nvoid * sumaHilos (void* d){\n\n    int * suma = malloc( sizeof(int) );\n\n    *suma = 0;\n\n    vInfo *v;\n\n    v = (vInfo*) d;\n\n    for (int i = 0; i < v->numeroElementos; i++){\n\n        *suma = *suma + v->vector[i];\n    }\n         \n    printf(\"La suma de los elementos de este vector es: %d \\n\", *suma);\n\n    pthread_exit((void**) suma);\n}\n\nint main(int argc, char const *argv[]){\n\n    if( argc < 2 || comprobacionArgumento( atoi(argv[1]) ) == 0 ){\n\n        printf(\"Error llame al programa de la siguiente forma:\\n\");\n        printf(\".\/E3 2. o \/E3 5\\n\");\n\n        exit(EXIT_FAILURE);\n    }\n\n    int numeroHilos = atoi(argv[1]);\n\n    vInfo *vPadre = malloc( sizeof(vInfo) ); \n\n    vPadre->numeroElementos = 10;\n  \n    vPadre->vector = reservarMemoria( vPadre->numeroElementos );\n\n    rellenaVector( vPadre->vector, vPadre->numeroElementos );\n\n    printf(\"El vector padre es: \\n\");\n\n    imprimeVector( vPadre->vector, vPadre->numeroElementos );\n\n    vInfo * vHijos = creaHijos(vPadre->vector, numeroHilos); \n\n    pthread_t hilos[numeroHilos];\n\n    int * retorno, suma = 0;\n\n    for (int i = 0; i < numeroHilos; i++){\n\n        if( pthread_create( &hilos[i], NULL, (void *) sumaHilos, (void *) vHijos+( sizeof(vInfo)*i ) ) != 0 ){\n\n            fprintf(stderr, \"Error creating thread\\n\");\n            exit(EXIT_FAILURE); \n        }\n    }\n\n    for (int i = 0; i < numeroHilos; i++){\n    \n        if(pthread_join( hilos[i], (void**) &retorno) ){\n        \n            fprintf(stderr, \"Error joining thread\\n\");\n            exit(EXIT_FAILURE);\n        }\n\n        suma += *retorno;\n    }    \n\n    printf(\"\\nLa suma de los numeros de todos los vectores es: %d\\n\", suma);\n    exit(EXIT_SUCCESS);\n}"}
{"target":"jdes01","func":"\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nint main(){\n\n    int n, status;\n    pid_t pid; \n\n    printf(\"introduce el numero de procesos:\\n\");\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++){\n\n        switch ( fork() ){\n\n        \n        \n        \n\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n\n        case 0: \n            printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n            exit(EXIT_SUCCESS); \n        }\n    }\n\n    for (int i = 0; i < n; i++){\n\n        pid = wait(&status); \n        \n        \n\n        if (pid > 0){ \n        \n            if      (WIFEXITED(status))   printf(\"1 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WEXITSTATUS(status));\n            else if (WIFSIGNALED(status)) printf(\"2 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WTERMSIG(status));\n            else if (WIFSTOPPED(status))  printf(\"3 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WSTOPSIG(status));\n        \n        }\n        else{ \n            printf(\"fallo en la invocacion\\n\");\n            exit(EXIT_FAILURE);\n        }\n         \n    }\n    \n    exit(EXIT_SUCCESS);\n\n}"}
{"target":"jdes01","func":"\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nint main(){\n\n    int n, status;\n    pid_t pid; \n\n    printf(\"introduce el numero de procesos:\\n\");\n    scanf(\"%i\", &n);\n\n    for (int i = 0; i < n; i++){\n\n        switch ( fork() ){\n\n        \n        \n        \n\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n\n        case 0: \n            printf(\"soy un proceso hijo con PID: [%i]; el PID de mi proceso padre es: [%i]\\n\", getpid(), getppid());\n            break;\n\n        default:\n\n            pid = wait(&status); \n            \n            \n\n            if (pid > 0){ \n        \n                if      (WIFEXITED(status))   printf(\"1 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WEXITSTATUS(status));\n                else if (WIFSIGNALED(status)) printf(\"2 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WTERMSIG(status));\n                else if (WIFSTOPPED(status))  printf(\"3 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WSTOPSIG(status));\n                exit(EXIT_SUCCESS);\n            }\n            else{ \n                printf(\"fallo en la invocacion\\n\");\n                exit(EXIT_FAILURE);\n            }\n            \n\n        }\n\n    }\n    \n    exit(EXIT_SUCCESS);\n\n}"}
{"target":"jdes01","func":"\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nint main(){\n\n        switch ( fork() ){\n\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n\n        case 0: \n            printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n            break;\n\n        default:\n            sleep(10);\n            exit(EXIT_FAILURE);\n        }\n\n}"}
{"target":"jdes01","func":"\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\n\nint main(int argc, char * argv[]){\n\n    int status;\n    pid_t pid[2]; \n\n    switch ( fork() ){\n\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n                break;\n\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                \n                \n                \n                exit(EXIT_SUCCESS); \n            }\n\n    switch ( fork() ){\n\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n                break;\n\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                execlp(\"open\", \"open\", \"-t\", argv[1], argv[2], NULL); \n                exit(EXIT_SUCCESS); \n            }\n\n    pid[0]=wait(&status);\n    pid[1]=wait(&status);\n\n\n        \n}\n\n\n"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nint factorial(int n);\n\nint main(int argc, char * argv[]){\n\n    int status;\n    pid_t pid; \n\n    int n=0;\n\n    for (int i = 0; i < argc-1; i++){\n\n        switch ( fork() ){\n\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                sleep(1);\n                n = atoi(argv[i+1]);\n                printf(\"el factorial de %i es %i\\n\", n, factorial(n));\n                sleep(1);\n                exit(EXIT_SUCCESS); \n        }\n\n        pid=wait(&status);\n    }\n\n    \n}\n\nint factorial(int n){\n\n   int fact=1;\n\n   if( n<0 ) return 0;\n\n   if(n==0) return 1;\n\n   for (int i = 1; i <= n; ++i) {fact = fact*i;} \n      \n   return fact;\n   \n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nint main(int argc, char * argv[]){\n\n    int n;\n\n    int status;\n    pid_t pid; \n\n    for (int i = 1; i < argc; i++){\n \n        switch ( fork() ){\n \n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                execlp(\".\/a.out\", \".\/a.out\", argv[i], NULL);                \n                exit(EXIT_SUCCESS); \n        }\n \n        pid=wait(&status);\n    }\n\n   pid=wait(&status);\n}\n\n"}
{"target":"jdes01","func":"\n\n\n\n\n\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nvoid ring (int signo) { printf(\"RING\\n\"); }\n\nvoid funcion(int segundos){ \n\n    alarm(segundos); \n    pause(); \n    }\n\nint main(){\n\n    signal(SIGALRM, ring); \n\n    printf(\"Alarma en 5 segundo\\n\");\n    funcion(5); \n\n    printf(\"Alarma en 3 segundo\\n\");\n    funcion(3);\n\n    for (int i = 0; i < 90; i++){\n\n        printf(\"Alarma en 1 segundo\\n\");\n        funcion(1);\n\n        printf(\"TIMBRAZOS: %d\\n\", i+1);\n        \n        if (i==3) kill(getpid(),9);\n        \n    }\n\n    return 0;\n    \n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <sys\/types.h> \n#include <errno.h> \n#include <sys\/wait.h> \n\nvoid tratarSennal (int signo) { printf(\"recibida se\u00f1al tratada por hijo\"); }\n\nint main(void){\n\n    pid_t pid, pidHijo;\n    int status, o=0;\n\n    switch (pid) {\n\n    case -1:\n\n        exit(EXIT_FAILURE);\n        break;\n\n    case 0:\n\n        signal(SIGUSR1, tratarSennal);\n\n        for (int i = 0; i < 5; i++) pause();\n        \n        exit(EXIT_SUCCESS);\n        break;    \n    \n    default:\n\n        for (int i = 0; i < 5; i++){\n\n            sleep(1);\n            kill(pid,SIGUSR1);\n        }\n\n        pidHijo=wait(&status);\n        break;\n    }\n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n\nvoid * aleatorio();\n\nint main(){\n\n    int n = 2;\n    float total = 0, * subtotal;\n    pthread_t hilos[n];\n\n    for (int i = 0; i < n; i++){ pthread_create(&hilos[i], NULL, (void *) aleatorio, NULL); } \n    \n\n    for (int i = 0; i < n; i++){\n        \n       pthread_join(hilos[i], (void **) &subtotal); \n       \n       printf(\"Valor recibido: %f\\n\", *subtotal); \n       total = total + *subtotal; \n    }\n    printf(\"la suma del total es: %f\\n\", total);\n\n    exit(EXIT_SUCCESS);\n     \n}    \n\nvoid * aleatorio(){\n\n    float f1 = drand48()*10, f2 = drand48()*10;\n    float * f3 = calloc(1, sizeof(float));\n    *f3 = f1+f2;\n    printf(\"%f + %f = %f\\n\", f1, f2, *f3);\n\n    pthread_exit((void *) f3); \n    \n    \n}"}
{"target":"jdes01","func":"\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n\nvoid * cuentaLineas(void * fichero);\n\nint main(int argc, char * argv[]){\n\n    int nHilos = argc-1; \n    int total = 0; \n    int * nLineas=0;\n    pthread_t hilos[nHilos];\n\n    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, cuentaLineas, (void*) argv[i+1]); } \n    \n\n    for (int i = 0; i < nHilos; i++) {\n\n        pthread_join(hilos[i], (void**) &nLineas); \n\n        printf(\"El fichero %s tiene %i lineas\\n\", argv[i+1], *nLineas);\n\n        total += *nLineas; \n    }\n\n    printf(\"Entre todos los ficheros suman %i lineas\\n\", total);\n    \n}\n\nvoid * cuentaLineas(void * fichero){\n\n    printf(\"contando el fichero: %s\\n\", fichero);\n\n    int * nLineas = malloc(sizeof(int)); \n\n    FILE * f = fopen(fichero, \"r\"); \n\n    *nLineas = 0; \n\n    char s[200]; \n\n    while(fgets(s, 200, f)){ *nLineas = *nLineas + 1; } \n        \n    pthread_exit((void *) nLineas); \n\n}"}
{"target":"jdes01","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <pthread.h>\n#include <errno.h>\n\ntypedef struct {        \n         \n  int *vector;          \n  int hebras;           \n  int i;                \n  \n} Vector;\n\n\nvoid rellenaVector(int *vector){        \n\n    srand(time(NULL));   \n\n    for (int i = 0; i < 10; ++i){ vector[i] = ((rand()%9)+1); }\n}\n\nvoid imprimeVector (int *vector){       \n\n    printf(\"El vector es:\\n\");\n    printf(\"| \");\n\n    for (int i = 0; i < 10; ++i){ printf(\"%d | \",vector[i]); }\n\n    printf(\"\\n\");\n}\n\n\nvoid * sumaVector (void* v){            \n\n    int *suma = malloc(sizeof(int));    \n    *suma = 0;                          \n    \n    Vector *estructura;                 \n    estructura = (Vector*) v;           \n    \n\n    if(estructura->hebras == 2){                                    \n\n        for(int j=estructura->i; j<(estructura->i)+5; j++){         \n\n            *suma = *suma + estructura->vector[j];\n        }\n\n        estructura->i = estructura->i + 5;\n        pthread_exit((void**)suma);                                 \n    }\n\n\n    else{                                                           \n        \n        for(int j=estructura->i; j<(estructura->i)+2; j++){         \n            \n            *suma = *suma + estructura->vector[j];\n        }\n\n        estructura->i = estructura->i + 2;\n        pthread_exit((void**)suma);                                 \n    }\n\n}\n\n\nint main(int argc, char const *argv[]){\n  \n    Vector *v = malloc(sizeof(Vector));                 \n    \n    if (argc != 2){                                     \n        \n        printf(\"Error, llame al programa asi:\\n\");\n        printf(\".\/ej3 2 o \/ej3 5\\n\");\n\n        exit(EXIT_FAILURE);\n    }\n\n    v->hebras = atoi(argv[1]);                          \n    v->i = 0;                                           \n\n    if (v->hebras != 2 && v->hebras != 5){              \n        \n        printf(\"Error, llame al programa asi:\\n\");\n        printf(\".\/ej3 2 o \/ej3 5\\n\");\n\n        exit(EXIT_FAILURE);\n    }\n    \n    v->vector = (int *)malloc (10*sizeof(int));         \n    rellenaVector(v->vector);                           \n    imprimeVector(v->vector);                           \n\n    pthread_t thread[v->hebras];                        \n    int *sumaLinea, suma = 0;                           \n    \n    printf(\"Se pasaran a crear %d hebras para sumar los valores del vector\\n\", v->hebras);\n\n    for (int i = 0; i < v->hebras; i++){                \n        \n        if(pthread_create(&(thread[i]), NULL, (void*) sumaVector, (void*) v)){\n\n            printf(\"Error en la creacion de la hebra. Codigo de error %d\\n\", errno);\n\n            exit(EXIT_FAILURE);\n        }\n\n        if(pthread_join(thread[i], (void**) &sumaLinea)){\n\n            printf(\"Error al esperar la hebra. Codigo de error %d\\n\", errno);\n\n            exit(EXIT_FAILURE);\n        } \n\n        suma = suma + *sumaLinea;                       \n    }\n\n    printf(\"La suma de los numeros de todos los valores es: %d\\n\", suma);\n\n    exit(EXIT_SUCCESS);\n}"}
{"target":"jdes01","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n\nvoid * aumentaVariableGlobal();\n\nint variableGlobal = 0;\n\nint main(int argc, char * argv[]){\n\n\n    int nHilos = 2; \n\n    pthread_t hilos[nHilos];\n\n    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, aumentaVariableGlobal, NULL );\n                                      pthread_join(hilos[i], NULL); }\n\n    \n\n    printf(\"la variable global suma %i \\n\", variableGlobal);\n    \n}\n\nvoid * aumentaVariableGlobal(){\n\n    for (int i = 0; i < 1000; i++)\n    {\n        variableGlobal++;\n        printf(\"%i\\n\", variableGlobal);\n    }\n\n    printf(\"la hebra ha aumentado %i veces\\n\", variableGlobal);\n    \n    pthread_exit(NULL); \n\n}\n"}
{"target":"jdes01","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n\nvoid * compra();\nvoid * suministro();\n\nint camisetas[5] = {1,2,3,4,5};\n\npthread_mutex_t mutex_acceso = PTHREAD_MUTEX_INITIALIZER;\n\nint main(int argc, char * argv[]){\n\n    srand(time(NULL)); \n\n    int n; \n\n    printf(\"introduce el numero de clientes:\\n\");\n    scanf(\"%i\", &n);\n\n    pthread_t clientes[n];\n\n    int m; \n    m = 5;\n\n    pthread_t proveedores[m];\n\n    for (int i = 0; i < n; i++){ pthread_create(&clientes[i], NULL, compra, NULL); } \n                                                                                     \n                                                                                     \n    for (int i = 0; i < m; i++){ pthread_create(&proveedores[i], NULL, suministro, NULL); } \n                                                                                            \n\n    for (int i = 0; i < n; i++){ pthread_join(clientes[i], NULL); } \n                                                                                    \n\n    for (int i = 0; i < m; i++) { pthread_join(proveedores[i], NULL); } \n                                                                                    \n\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n}\n\nvoid * compra(){\n\n    int modelo=(rand()%4)+1; \n\n    int cantidad=(rand()%10)+1; \n\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n\n    printf(\"se va a comprar el modelo %i %i veces \\n\",modelo,cantidad);\n\n    pthread_mutex_lock(&mutex_acceso);\n\n        camisetas[modelo-1] = camisetas[modelo-1] - cantidad;\n\n    pthread_mutex_unlock(&mutex_acceso);\n\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n\n    pthread_exit(NULL); \n\n}\n\nvoid * suministro(){\n\n    int modelo=(rand()%4)+1; \n\n    int cantidad=(rand()%10)+1; \n\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n\n    printf(\"se va a suministrar el modelo %i %i veces \\n\",modelo,cantidad);\n\n    pthread_mutex_lock(&mutex_acceso);\n\n        camisetas[modelo-1] = camisetas[modelo-1] + cantidad;\n\n    pthread_mutex_unlock(&mutex_acceso);\n\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n\n    pthread_exit(NULL); \n\n}"}
{"target":"jdes01","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <errno.h>\n\nint indiceGlobal = 0;                                   \nint par = 0;                                      \nint impar = 0;                                  \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;    \n\n\nint main( int argc, const char * argv[]){\n    \n    if (argc != 2){      \n        \n        printf(\"Error\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    srand(time(NULL));      \n    \n    int n = atoi(argv[1]);     \n    \n    int *resultado;          \n    \n    pthread_t thread[n];        \n\n    for(int i=0; i<n; i++){\n\n        if (pthread_create(&thread[i], NULL, suma, (void *) &indiceGlobal)){  \n           \n            printf(\"Error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    for(int i=0; i<n; i++){\n        \n        if (pthread_join(thread[i], (void **) &resultado )){\n\n            printf(\"Error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    printf(\"Valor del par %d\\n\", par);      \n    printf(\"Valor del impar %d\\n\", impar);\n\n    exit(EXIT_SUCCESS);     \n}\n\nvoid * suma(void * n){               \n        \n    int *indiceLocal= (int *)n;            \n    int *suma = malloc(sizeof(int *));    \n\n    for (int i = 0; i < 5 ; i++){                               \n                        \n        int x = rand()%11;      \n        *suma = *suma + x; \n    }\n\n    if (pthread_mutex_lock(&mutex)){                  \n\n        printf(\"Error %d\", errno);\n        exit(EXIT_FAILURE);\n    }\n\n    indiceGlobal++; \n       \n    printf(\"Hebra %ld con indice %d\\n\", pthread_self(), *indiceLocal);\n    printf(\"La suma en %d es %d\\n\", *indiceLocal, *suma); \n\n    if(*indiceLocal%2==0){ par = par + *suma; }                                              \n   \n\n    else{ impar = impar + *suma; }                                                               \n\n    if (pthread_mutex_unlock(&mutex)){      \n\n        printf(\"Error %d\", errno);\n        exit(EXIT_FAILURE);\n    }\n\n    pthread_exit((void *)suma);                                           \n}\n"}
{"target":"jdes01","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <errno.h>\n#include <semaphore.h>\n\n#define n 5 \n\nint v[n];      \n\nint indiceConsumicion = 0;                    \nint indiceProduccion = 0;\n\nsem_t mutex;                                   \nsem_t full;                                    \nsem_t empty;                                    \n\n\nint main(){\n\n    srand(time(NULL));                  \n\n    sem_init(&mutex, 0, 1);             \n    sem_init(&full, 0, 0);              \n    sem_init(&empty, 0, n);           \n\n    pthread_t threadProductor;        \n    pthread_t threadConsumidor;        \n\n    if(pthread_create(&threadProductor, NULL, productor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n\n    if(pthread_create(&threadConsumidor, NULL, consumidor, NULL )){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    \n    if (pthread_join(threadProductor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    \n    if (pthread_join(threadConsumidor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n   \n    for(int i=0; i<n; i++){ printf(\"Valor %d del buffer: %d\\n\", i+1, v[i]); }\n    \n    exit(EXIT_SUCCESS);                                        \n}\n\n\nvoid * productor(){ \n\n    for (int i=0; i<10; i++){   \n        \n        sem_wait(&empty);                                                          \n        sem_wait(&mutex);  \n        \n        int numero = rand()%101;    \n        \n        producirDato(numero);\n        \n        printf(\"Productor:\\n\");\n        printf(\"Dato %d: %d\\n\", i+1, numero);\n        \n        sem_post(&mutex);                                  \n        sem_post(&full);                                   \n    }\n    \n    pthread_exit(NULL);                                   \n}\n\nvoid * consumidor(){  \n    \n    for (int i=0; i<10; i++){ \n        \n        sem_wait(&full);                                    \n        sem_wait(&mutex);    \n        \n        int numero = consumirDato();\n        \n        printf(\"Consumidor:\\n\");\n        printf(\"---->Consumidor, Dato %d: %d\\n\", i+1, numero);\n        \n        sem_post(&mutex);                             \n        sem_post(&empty);                                                \n    }\n    \n    pthread_exit(NULL);                 \n}\n\n\nvoid producirDato(int numero){    \n\n    v[indiceProduccion] = numero;    \n    \n    indiceProduccion = (indiceProduccion +1)%n; \n    \n    for(int i=0; i<n; i++){ printf(\"%d \", v[i]); }\n}\n\nint consumirDato(){                      \n\n    int numConsumido= v[indiceConsumicion];   \n    \n    v[indiceConsumicion] = '\\0';  \n    \n    indiceConsumicion = (indiceConsumicion +1)%n;   \n    \n    for(int i=0; i<n; i++){ printf(\"%d \", v[i]); }\n\n    return numConsumido;   \n}\n\n\n\n"}
{"target":"jdes01","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <errno.h>\n#include <semaphore.h>\n\n#define n 3                                     \n\nint v[n];                                       \nint indiceConsumicion = 0;                      \nint indiceProduccion = 0;                       \nint hebraProductor = 0;                         \nint hebraConsumidor = 0;                        \n\nsem_t mutex;                                    \nsem_t full;                                     \nsem_t empty;                                    \n\nvoid producirDato(int numero){                  \n    v[indiceProduccion] = numero;               \n    indiceProduccion = (indiceProduccion +1)%n; \n    for(int i=0; i<n; i++){                     \n            printf(\"|%d\", v[i]);\n    }\n    printf(\"|\");\n}\n\nint consumirDato(){                                 \n    int numConsumido= v[indiceConsumicion];         \n    v[indiceConsumicion] = '\\0';                    \n    indiceConsumicion = (indiceConsumicion +1)%n;   \n        for(int i=0; i<n; i++){                     \n            printf(\"|%d\", v[i]);\n        }\n    printf(\"|\");\n    return numConsumido;                            \n}\n\nvoid * productor(){                                         \n    sem_wait(&empty);                                       \n    sem_wait(&mutex);                                       \n    hebraProductor++;                                       \n    int numero = rand()%101;                                \n    producirDato(numero);                                   \n    printf(\"---->Productor %d, Dato %d\\n\",hebraProductor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&full);                                        \n    \n    pthread_exit(NULL);                                     \n}\n\nvoid * consumidor(){                                        \n    sem_wait(&full);                                        \n    sem_wait(&mutex);                                       \n    hebraConsumidor++;                                      \n    int numero = consumirDato();                            \n    printf(\"---->Consumidor %d, Dato: %d\\n\", hebraConsumidor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&empty);                                       \n    \n    pthread_exit(NULL);                                     \n}\n\nint main(){\n    srand(time(NULL));                  \n\n    sem_init(&mutex, 0, 1);             \n    sem_init(&full, 0, 0);              \n    sem_init(&empty, 0, n);             \n\n\n    pthread_t threadProductor[3];       \n    pthread_t threadConsumidor[3];      \n\n    for (int i=0; i<3; i++){\n        if(pthread_create(&threadProductor[i], NULL, productor, NULL)){                         \n            printf(\"Error, no se ha podido crear la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    for (int i=0; i<3; i++){                                                                    \n        if(pthread_create(&threadConsumidor[i], NULL, consumidor, NULL)){\n            printf(\"Error, no se ha podido crear la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    for (int i=0; i<3; i++){\n        if (pthread_join(threadProductor[i], NULL)){                                            \n            printf(\"Error, no se ha podido recoger la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    for (int i=0; i<3; i++){\n        if (pthread_join(threadConsumidor[i], NULL)){                                           \n            printf(\"Error, no se ha podido recoger la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    for(int i=0; i<n; i++){                                     \n        printf(\"Valor %d del buffer: %d\\n\", i+1, v[i]);\n    }\n    exit(EXIT_SUCCESS);                                         \n}"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid timer0_config(void);\nvoid timer1_config(void);\nvoid interrupt_config(void);\nvoid timer0_isr1(void) __irq;               \nvoid timer1_isr2(void) __irq;               \nvoid eint1_isr(void) __irq;\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}\n\nvoid interrupt_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);                                                    \n    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           \n    VICVectCntl1    = (1<<5)| 15;                                       \n    VICVectAddr1    =   (long)eint1_isr;\n    VICVectCntl4    = (1<<5)|4;                                             \n    VICVectAddr4    = (long)timer0_isr1;                                \n    VICVectCntl5    = (1<<5)|5;                                                 \n    VICVectAddr5    = (long)timer1_isr2;\n    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               \n    EXTMODE = (1<<1);                                                       \n    EXTPOLAR    = (1<<1);                                                       \n}\n\nvoid timer0_isr1(void) __irq\n{\n    blink_LED(17);\n    T0IR = (1<<0);          \n    VICVectAddr =   0x00000000;     \n}\n\nvoid timer1_isr2(void) __irq\n{\n    blink_LED(20);\n    T1IR = (1<<0);          \n    VICVectAddr =   0x00000000;     \n}\n\nvoid eint1_isr(void) __irq\n{\n    IOSET0 = 1<<11;\n    delay(300);             \n    IOCLR0 = 1<<11;\n    delay(300);             \n    EXTINT  = (1<<1);\n    VICVectAddr = 0x00000000;\n}\n\nvoid timer0_config(void)\n{\n    T0PR = 14;\n    T0MR0 = 2000000;                            \n    T0MCR = (1<<0)|(1<<1);\n    T0TCR = (1<<0);\n}\n\nvoid timer1_config(void)\n{\n    T1PR = 14;\n    T1MR0 = 2000000;                            \n    T1MCR = (1<<0)|(1<<1);\n    T1TCR = (1<<0);\n    \n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n\nvoid delay(int);\n\nint main()\n{\n    int flag = 0;\n    IODIR0 = IODIR0 | (1<<11);      \n    IODIR1 = IODIR1 & ~(1<<25);     \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))  \n        {\n            IOSET0 = 1<<11;\n            delay(100);\n            IOCLR0 = 1<<11;\n            delay(100);         \n        }\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;++i)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid intr_config(void);\nvoid eint1_isr(void) __irq;\nint main()\n{\n    IODIR1 |= (0xFF<<17);\n    intr_config();\n    while(1)\n    {\n        blink_LED(24);\n    }\n}\n\nvoid intr_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);    \n    \n    VICIntSelect &= ~(1<<15);       \n    VICVectCntl1    = (1<<5)| 15;   \n    VICVectAddr1    =   (long)eint1_isr;\n    VICIntEnable = 1<<15;\n    EXTMODE = (1<<1);       \n    EXTPOLAR    = (1<<1);       \n\n}\n\nvoid eint1_isr(void) __irq\n{\n    blink_LED(17);\n    EXTINT  = (1<<1);\n    VICVectAddr = 0;\n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid intr_config(void);\nvoid eint1_isr(void) __irq;\nint main()\n{\n    IODIR1 |= (0xFF<<17);\n    intr_config();\n    while(1)\n    {\n        blink_LED(24);\n    }\n}\n\nvoid intr_config(void)\n{\n    PINSEL1 |= (1<<29);\n    PINSEL1 &= ~(1<<28);    \n    \n    VICIntSelect &= ~(1<<17);       \n    VICVectCntl1    = (1<<5)| 17;   \n    VICVectAddr1    =   (long)eint1_isr;\n    VICIntEnable = 1<<17;\n    EXTMODE = (1<<3);       \n    EXTPOLAR    = (1<<3);       \n\n}\n\nvoid eint1_isr(void) __irq\n{\n    blink_LED(17);\n    EXTINT  = (1<<3);\n    VICVectAddr = 0;\n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n#include \"..\/lcd_header.h\"\nvoid i2c_init(void);\nvoid i2c_Start(void);\nvoid i2c_tx_data(char );\nchar i2c_rx_data(void);\nvoid i2c_stop(void);\n\nint main()\n{   \n    char i2c_rdata;\n    lcd_config();\n    i2c_init();\n    \n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x01);          \n    \n    I2CONSET = (1<<2);          \n    \n    i2c_Start();                        \n    i2c_tx_data(0xA1);          \n    \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    \n    i2c_stop();\n\n    lcd_cmd(0xC0);\n    lcd_str(\"Data from EEPROM\");\n}\n\nvoid i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}\n\nvoid i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}\n\nvoid i2c_tx_data(char idata)\n{\n    I2DAT = idata;\n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<3);          \n}\n\nchar i2c_rx_data(void)\n{\n    char recv_data;\n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<3);\n    recv_data = I2DAT;\n    return recv_data;\n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = (1<<4);\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n#include \"..\/lcd_header.h\"\nvoid i2c_init(void);\nvoid i2c_Start(void);\nvoid i2c_tx_data(char );\nvoid i2c_stop(void);\n\nint main()\n{   \n    lcd_config();\n    i2c_init();\n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x01);          \n    i2c_tx_data('C');   \n    i2c_tx_data('R');   \n    i2c_tx_data('A');   \n    i2c_tx_data('N');\n    i2c_tx_data('E');   \n    i2c_tx_data('S');       \n    i2c_stop();\n\n    lcd_str(\"Data sent\");\n}\n\nvoid i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}\n\nvoid i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}\n\nvoid i2c_tx_data(char idata)\n{\n    I2DAT = idata;\n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<3);          \n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = (1<<4);\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n#include \"..\/lcd_header.h\"\nvoid i2c_init(void);\nvoid i2c_Start(void);\nvoid i2c_tx_data(char );\nchar i2c_rx_data(void);\nvoid i2c_stop(void);\n\nint main()\n{   \n    char i2c_rdata;\n    lcd_config();\n    i2c_init();\n    \n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x41);          \n    i2c_tx_data('J');   \n    i2c_tx_data('R');   \n    i2c_tx_data('A');   \n    i2c_tx_data('M');\n        \n    i2c_stop();\n\n    lcd_str(\"Data sent\");\n    delay(1000);\n    lcd_cmd(0x01);\n    \n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x41);          \n    \n    I2CONSET = (1<<2);          \n    \n    i2c_Start();                        \n    i2c_tx_data(0xA1);          \n    \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n\n    \n    i2c_stop();\n\n    lcd_cmd(0xC0);\n    lcd_str(\"Data from EEPROM\");\n}\n\nvoid i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}\n\nvoid i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}\n\nvoid i2c_tx_data(char idata)\n{\n    I2DAT = idata;\n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<3);          \n}\n\nchar i2c_rx_data(void)\n{\n    char recv_data;\n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<3);\n    recv_data = I2DAT;\n    return recv_data;\n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = (1<<4);\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n        \n#include \"..\/lcd_header.h\"\n#define ROWS (0x0F<<21)\n#define COLS (0x0F<<17)\n\nvoid rows(void);\nvoid col_1(void);\nvoid col_2(void);\nvoid col_3(void);\nvoid col_4(void);\n\nint main()\n{\n\n    lcd_config();\n    while(1)\n    {\n        rows();\n\n\n        \n    }\n}\n\nvoid rows(void)\n{\n    int val;\n\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    val = IOPIN1 & ROWS;        \n    val = val >> 21;\n    switch(val)\n    {\n        case 0x0E:   col_1();   delay(200); break;\n        case 0x0D:   col_2();   delay(200); break;\n        case 0x0B:   col_3();   delay(200); break;\n        case 0x07:   col_4();   delay(200); break;\n    }\n}\n\nvoid col_1(void)                    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('7');  delay(200); break;\n        case 0x0D:  lcd_data('8');  delay(200); break;\n        case 0x0B:  lcd_data('9');  delay(200); break;\n        case 0x07:  lcd_data('\/');  delay(200); break;\n    }\n}\n\nvoid col_2(void)                    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('4');  delay(200); break;\n        case 0x0D:  lcd_data('5');  delay(200); break;\n        case 0x0B:  lcd_data('6');  delay(200); break;\n        case 0x07:  lcd_data('x');  delay(200); break;\n    }\n}\n\nvoid col_3(void)            \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('1');  delay(200); break;\n        case 0x0D:  lcd_data('2');  delay(200); break;\n        case 0x0B:  lcd_data('3');  delay(200); break;\n        case 0x07:  lcd_data('-');  delay(200); break;\n    }\n}\n\nvoid col_4(void)    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('.');  delay(200); break;\n        case 0x0D:  lcd_data('0');  delay(200); break;\n        case 0x0B:  lcd_data('=');  delay(200); break;\n        case 0x07:  lcd_data('+');  delay(200); break;\n    }\n}\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n#define RS (1<<10)\n#define RW (1<<12)\n#define EN (1<<13)\n#define DATA_PINS (0xFF<<15)\n\nvoid lcd_config(void);\nvoid lcd_cmd(char);\nvoid lcd_data(char);\nvoid lcd_str(char []);\nvoid lcd_str1(char []);\nvoid delay(int);\n\nint main()\n{\n\n\n\n        int num = 8,res,quotient,remainder;     \n        res = 66 + 33;\n        lcd_config();   \n        quotient = res\/10;\n        remainder = res%10;\n        lcd_data(quotient + 0x30);\n        lcd_data(remainder + 0x30);\n    \n\n\n\n\n\n\n\n}\n\nvoid lcd_config(void)\n{\n    IODIR0 |= DATA_PINS|RS|RW|EN;       \n                        \n                        \n    lcd_cmd(0x38);  \n    lcd_cmd(0x0E);  \n    lcd_cmd(0x01);  \n    lcd_cmd(0x80);  \n}\n\nvoid lcd_cmd(char cmd)\n{\n    IOCLR0 = DATA_PINS;     \n    IOSET0 = cmd<<15;  \n    IOCLR0 = RW;                \n    IOCLR0 = RS;        \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid lcd_data(char data)\n{\n    IOCLR0 = DATA_PINS;     \n    IOSET0 = data<<15;  \n    IOCLR0 = RW;                \n    IOSET0 = RS;            \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n\n\nvoid lcd_str(char str[])\n{\n    int i;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n        }\n}\n\nvoid lcd_str1(char str[])\n{\n    int i,count=0;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n            if(count == 16)\n            {\n                lcd_cmd(0xC0);\n            }\n            count++;\n        }\n}\n\n\n\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n#include \"lcd_header.h\"\n\nvoid lcd_config(void)\n{\n    IODIR0 |= DATA_PINS|RS|RW|EN;       \n                        \n                        \n    lcd_cmd(0x38);  \n    lcd_cmd(0x0E);  \n    lcd_cmd(0x01);  \n    lcd_cmd(0x80);  \n}\n\nvoid lcd_cmd(char cmd)\n{\n    IOCLR0 = DATA_PINS;     \n    IOSET0 = cmd<<15;  \n    IOCLR0 = RW;                \n    IOCLR0 = RS;        \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid lcd_data(char data)\n{\n    IOCLR0 = DATA_PINS;     \n    IOSET0 = data<<15;  \n    IOCLR0 = RW;                \n    IOSET0 = RS;            \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n\n\nvoid lcd_str(char str[])\n{\n    int i;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n        }\n}\n\nvoid lcd_str1(char str[])\n{\n    int i,count=0;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n            if(count == 16)\n            {\n                lcd_cmd(0xC0);\n            }\n            count++;\n        }\n}\n\nvoid lcd_num(int num)\n{\n    if(num)\n    {\n        lcd_num(num\/10);\n        lcd_data(num%10 + 0x30);\n    }\n}\n\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"#include<LPC21xx.h>       \n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nvoid delay(int);\n\nint main()\n{\n    int val;\n    IODIR1 = IODIR1 | (0xFF<<17);\n                                    \n    while(1)\n    {\n        for(val =0x01;val <= 0xFF; val++)\n        {\n            IOSET1 = val<<17;\n            delay(100);\n            IOCLR1 = val<<17;\n            delay(100);\n        }\n    }\n}\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<LPC21xx.h>       \n\n\n\n\n\n\n\n\n\n\n    \nvoid delay(int);\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);\n                                    \n    while(1)\n    {\n        for(int led =17;led <= 24; led++)\n        {\n            IOSET1 = 1<<led;\n            delay(100);\n            IOCLR1 = 1<<led;\n            delay(100);\n        }\n    }\n}\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid timer0_config(void);\nvoid timer1_config(void);\nvoid interrupt_config(void);\n\nvoid nonvic_isr(void) __irq;\n\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}\n\nvoid interrupt_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);                                                    \n    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           \n    \n    VICDefVectAddr  = (long)nonvic_isr;\n    \n    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               \n    EXTMODE = (1<<1);                                                       \n    EXTPOLAR    = (1<<1);                                                       \n}\nvoid nonvic_isr(void) __irq\n{\n    blink_LED(17);\n    T0IR = (1<<0);          \n    T1IR = (1<<0);\n    EXTINT  =(1<<1);\n    VICVectAddr =   0x00000000;     \n\n}\n\n\nvoid timer0_config(void)\n{\n    T0PR = 14;\n    T0MR0 = 4000000;                            \n    T0MCR = (1<<0)|(1<<1);\n    T0TCR = (1<<0);\n}\n\nvoid timer1_config(void)\n{\n    T1PR = 14;\n    T1MR0 = 5000000;                            \n    T1MCR = (1<<0)|(1<<1);\n    T1TCR = (1<<0);\n    \n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n#include<LPC21xx.h>\nvoid pll_48MHz(void);\nvoid pll_36MHz(void);\nvoid pll_12MHz(void);\nvoid blink_led(int );\nvoid delay_ms(int );\nint count = 0;\n\nint main()\n{\n    IODIR1 |= (0xFF<<17);\n    while(1)\n    {\n        IOSET1 = 0xFF<<17;          \n        delay_ms(500);\n        IOCLR1 = 0xFF<<17;\n        delay_ms(500);\n        count++;\n        if(count >= 10 && count<20)\n        {\n            pll_36MHz();                    \n        }\n        if (count >= 20 && count<25)\n        { \n            pll_12MHz();                \n        } else if(count >= 25)\n        {\n            pll_48MHz();\n        }\n    \n    }\n}\n\nvoid pll_36MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<6)| 2; \n    PLLCFG &= ~(1<<5);\n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}\n\nvoid pll_48MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<5)| 3; \n    PLLCFG &= ~(1<<5);\n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}\n\nvoid pll_12MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<6)| (1<<5) | 0;    \n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}\n\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n                                            \n#include<LPC21xx.h>\nvoid delay_ms(int);\nint main()\n{\n\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);                \n    PWMPR = 14;\n    PWMMR0 = 10000;                         \n    PWMLER = (1<<0);\n    PWMMCR = (1<<1);                        \n    PWMPCR |= (1<<12)|(1<<4);                   \n    PWMTCR = (1<<0) | (1<<3);       \n    while(1)\n    {\n            PWMMR3 = 3000;          \n            PWMMR4 = 5500;          \n            PWMLER = (1<<3)|(1<<4);\n            delay_ms(1000);\n            PWMMR3 = 3000;          \n            PWMMR4 = 7000;          \n            PWMLER = (1<<3)|(1<<4);\n            delay_ms(1000);\n    }   \n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<LPC21xx.h>\nvoid delay_ms(int);\nint main()\n{\n\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);                \n    PWMPR = 14;\n    PWMMR0 = 10000;                         \n    PWMLER = (1<<0);\n    PWMMCR = (1<<1);                        \n    PWMPCR |= (1<<12);                  \n    PWMPCR &= ~(1<<4);                  \n    PWMTCR = (1<<0) | (1<<3);       \n    while(1)\n    {\n        PWMMR4 = 2500;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        \n        PWMMR4 = 5000;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        \n        PWMMR4 = 7500;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        \n        PWMMR4 = 10000;             \n        PWMLER = (1<<4);\n        delay_ms(1000);\n    }   \n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n        \n#include \"..\/lcd_header.h\"\n#define ROWS (0x0F<<21)\n#define COLS (0x0F<<17)\n\nvoid rows(void);\nvoid cols(void);\n\n\nint main()\n{\n\n    lcd_config();\n    while(1)\n    {\n        rows();\n        delay(1000);\n        lcd_cmd(0x01);\n        \n    }\n}\n\nvoid rows(void)\n{\n    int val;\n\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    val = IOPIN1 & ROWS;        \n    val = val >> 21;\n    switch(val)\n    {\n        case 0x0E:  lcd_str(\"r1\"); cols();  delay(200); break;\n        case 0x0D:  lcd_str(\"r2\"); cols();  delay(200); break;\n        case 0x0B:  lcd_str(\"r3\"); cols();  delay(200); break;\n        case 0x07:  lcd_str(\"r4\"); cols();  delay(200); break;\n    }\n}\n\nvoid cols(void)\n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_str(\"C1\");  delay(200); break;\n        case 0x0D:  lcd_str(\"C2\");  delay(200); break;\n        case 0x0B:  lcd_str(\"C3\");  delay(200); break;\n        case 0x07:  lcd_str(\"C4\");  delay(200); break;\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n        \n#include \"..\/lcd_header.h\"\n#define ROWS (0x0F<<21)\n#define COLS (0x0F<<17)\n\nint main()\n{\n    int val;\n\n\n\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    lcd_config();\n    while(1)\n    {\n        val = IOPIN1 & ROWS;        \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E:  lcd_str(\"r1\");  delay(300); break;\n            case 0x0D:  lcd_str(\"r2\");  delay(300); break;\n            case 0x0B:  lcd_str(\"r3\");  delay(300); break;\n            case 0x07:  lcd_str(\"r4\");  delay(300); break;\n        }\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include \"..\/lcd_header.h\"\n\n\nint main()\n{\n    lcd_config();\n    CCR =1<<0;\n    PREINT = 456;\n    PREFRAC = 25024;\n    \n    HOUR = 7;\n    MIN = 0;\n    SEC = 0;\n    \n    while(1)\n    {\n        lcd_cmd(0x80);\n        lcd_num(HOUR);\n        lcd_data(':');\n        lcd_cmd(0x83);\n        lcd_num(MIN);\n        lcd_data(':');\n        if(SEC < 9)\n        {\n            lcd_cmd(0x86);\n            lcd_data('0');\n            lcd_num(SEC);\n        }else{\n            lcd_cmd(0x86);\n            lcd_num(SEC);\n        }\n    }\n}\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n\nvoid delay(int);\n\nint main()\n{\n    int flag = 0;\n    IODIR1 |= (0xFF<<17);       \n    IODIR1 = IODIR1 & ~(1<<25);     \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))  \n        {\n            if(flag == 0)               \n            {\n                IOSET1 = 1<<17;\n                delay(500);\n                flag = 1;\n            }\n            else if(flag ==1)       \n            {\n                IOCLR1 = 1<<17;\n                delay(500);\n                flag = 0;\n            }\n        }\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;++i)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21XX.h>\nvoid delay(int);\nvoid blink_led(int);\nvoid interrupt_config(void);\nvoid eint_isr(void) __irq; \nint main()\n{\n    IODIR1 = IODIR1 | (0XFF<<17);\n    \n    interrupt_config();\n    while(1)\n    {\n     blink_led(24); \n    }\n}\n\nvoid interrupt_config(void)\n{\n PINSEL0 |= (1<<29);\n PINSEL0 &=~(1<<28);\n VICIntSelect &= ~(1<<15); \n VICVectCntl1 = (   1<<5)|15;   \n VICVectAddr1 = (long)eint_isr;\n VICIntEnable = (1<<15);\n EXTMODE = (1<<1);\n EXTPOLAR = (1<<1); \n\n}\nvoid eint_isr(void) __irq\n{\nblink_led(17);\nEXTINT = (1<<1); \nVICVectAddr =  0X00000000;\n}\nvoid blink_led(int led)\n{\nIOSET1 = 1<<led;\ndelay(300);\nIOCLR1 = 1<<led;\ndelay(300);\n}\n\nvoid delay(int ct)\n{int i,j;\n{\nfor(i=0;i<=ct;i++)\nfor(j=0;j<=6000;++j)\n{}\n}\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid timer0_config(void);\nvoid timer1_config(void);\nvoid interrupt_config(void);\nvoid timer0_isr1(void) __irq;               \nvoid timer1_isr2(void) __irq;               \n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    timer1_config();\n    timer0_config();\n    T0TCR = (1<<0);\n    T1TCR = (1<<0);\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}\n\nvoid interrupt_config(void)\n{\n    VICIntSelect &= ~((1<<4)|(1<<5));           \n    VICVectCntl4    = (1<<5)|4;         \n    VICVectAddr4    = (long)timer0_isr1;        \n    VICVectCntl5    = (1<<5)|5;         \n    VICVectAddr5    = (long)timer1_isr2;\n    VICIntEnable    = (1<<4)|(1<<5);                \n}\n\nvoid timer0_isr1(void) __irq\n{\n    blink_LED(17);\n    T0IR = (1<<0);          \n    VICVectAddr =   0x00000000;     \n}\n\nvoid timer1_isr2(void) __irq\n{\n    blink_LED(20);\n    T1IR = (1<<0);          \n    VICVectAddr =   0x00000000;     \n}\n\nvoid timer0_config(void)\n{\n    T0PR = 14;\n    T0MR0 = 2000000;                            \n    T0MCR = (1<<0)|(1<<1);\n\n}\n\nvoid timer1_config(void)\n{\n    T1PR = 14;\n    T1MR0 = 2000000;                            \n    T1MCR = (1<<0)|(1<<1);\n    \n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                  \n    T0MR0 = 500000;     \n    T0MCR   = (1<<0)|(1<<1);            \n    T0TCR   = (1<<0);           \n    while(1)\n    {\n        blink_LED(24);\n        if(T0IR & (1<<0))           \n        {\n            blink_LED(17);\n            T0IR = 1<<0;            \n        }\n    }\n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(1000);                \n    IOCLR1 = 1<<led;\n    delay(1000);                \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21xx.h>\n\nint main()\n{\n\n\n    int count=0;\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                                          \n    T0MR0 = 2000000;                                \n    T0MR1 = 4000000;                                \n    T0MCR   = (1<<0)|(1<<3)|(1<<4);     \n    T0TCR   = (1<<0);                                   \n    while(1)\n    {\n        count++;\n        if(T0IR & (1<<0))                           \n        {\n            IOSET1 = (0xFF<<17);\n            T0IR = 1<<0;                                \n        }\n        \n        if(T0IR & (1<<1))                           \n        {\n            IOCLR1 = (0xFF<<17);\n            T0IR = 1<<1;                                \n        }\n\n\n\n\n\n\n\n\n    \n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n#include<lpc21xx.h>\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                                          \n    T0MR0 = 1000000;                                \n    T0MR1 = 2000000;                                \n    T0MR2 = 3000000;                                \n    T0MR3   = 4000000;                              \n    T0MCR   = (1<<0)|(1<<3)|(1<<6)|(1<<9)|(1<<10);      \n    T0TCR   = (1<<0);                                   \n    while(1)\n    {\n        if(T0IR & (1<<0))                           \n        {\n            IOSET1 = (1<<17);\n            T0IR = 1<<0;                                \n        }\n        \n        if(T0IR & (1<<1))                           \n        {\n            IOCLR1 = (1<<17);\n            T0IR = 1<<1;                                \n        }\n        if(T0IR & (1<<2))                           \n        {\n            IOSET1 = (1<<24);\n            T0IR = 1<<2;                                \n        }\n        \n        if(T0IR & (1<<3))                           \n        {\n            IOCLR1 = (1<<24);\n            T0IR = 1<<3;                                \n        }\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\nvoid timer0_config(void);\nvoid interrupt_config(void);\nvoid timer0_isr1(void) __irq;               \n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}\n\nvoid interrupt_config(void)\n{\n    VICIntSelect &= ~(1<<4);            \n    VICVectCntl2    = (1<<5)|4;         \n    VICVectAddr2    = (long)timer0_isr1;        \n    VICIntEnable    = (1<<4);               \n}\n\nvoid timer0_isr1(void) __irq\n{\n    blink_LED(17);\n    T0IR = (1<<0);          \n    VICVectAddr =   0x00000000;     \n}\n\nvoid timer0_config(void)\n{\n    T0PR = 14;\n    T0MR0 = 2000000;\n    T0MCR = (1<<0)|(1<<1);\n    T0TCR = (1<<0);\n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\nvoid delay(int );\nvoid blink_LED(int );\n\nint main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                  \n    T0MR0 = 5000000;        \n    T0MCR   = (1<<0)|(1<<1);            \n    T0TCR   = (1<<0);           \n    while(1)\n    {\n        blink_LED(24);\n\n        while(!(T0IR & (1<<0)))         \n        {}\n        blink_LED(17);\n        T0IR = 1<<0;            \n\n    }\n}\n\nvoid blink_LED(int led)\n{\n    IOSET1 = 1<<led;\n    delay(300);             \n    IOCLR1 = 1<<led;\n    delay(300);             \n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<LPC21xx.h>\nvoid blink_led(int );\nvoid delay_ms(int );\nint main()\n{\n    IODIR1 |= (0xFF<<17);\n    WDMOD = (1<<0)|(1<<1);\n    WDTC = 0xFFFFFF;            \n    WDFEED = 0xAA;              \n    WDFEED = 0x55;\n    blink_led(24);          \n    while(1)\n    {\n        blink_led(17);\n    }\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<LPC21xx.h>\nvoid blink_led(int );\nvoid delay_ms(int );\nint main()\n{\n    IODIR1 |= (0xFF<<17);\n    WDMOD = (1<<0)|(1<<1);\n    WDTC = 0xFFFFFF;            \n    WDFEED = 0xAA;\n    WDFEED = 0x55;\n    blink_led(24);          \n    while(1)\n    {\n        if(WDTV <= 0x800000)\n        {\n                WDFEED = 0xAA;\n                WDFEED = 0x55;\n        }\n        IOSET1 = 1<<17;  \n        delay_ms(100);\n        IOCLR1 = 1<<17;   \n        delay_ms(100);\n    }\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include \"lcd_header.h\"\n\n\nint main()\n{\n    int res,done = 1;\n    \n\n\n    PINSEL1 |= 1<<24;\n    PINSEL1 &= ~(1<<25); \n    lcd_config();\n\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24);  \n    while(1)\n    {\n        \n        \n        while(!(ADDR & (done<<31)));\n        res = ADDR & (0x3FF<<6);   \n        res = res>>6;                               \n        res = res\/3.3;  \n        lcd_num(res);\n        delay(1000);\n\n        \n    }\n}\n\nvoid adc_pot(void)\n{\n    int res,done = 1;\n    ADCR = (1<<0)|(4<<8)|(1<<21)|(1<<24); \n    while(!(ADDR & (done<<31)));\n    res = ADDR & (0x3FF<<6);   \n    res = res>>6;       \n}\n\nvoid adc_temp(void)\n{\n    int res,done = 1;\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24); \n    while(!(ADDR & (done<<31)));\n    res = ADDR & (0x3FF<<6);   \n    res = res>>6;       \n}"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\nvoid delay(int );\nvoid blink_led(int );\nint keyFlag = 1;\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    IODIR1 = IODIR1 & ~(1<<25);  \n\n    while(1)\n    {\n        if(IOPIN1 & (1<<25))\n        {\n            if(keyFlag)\n            {   \n                IOSET1 = 0x0F<<17;\n                keyFlag = 0;\n            }\n            else\n            {\n                IOCLR1 = 0x0F<<17;\n                keyFlag = 1;\n            }\n            delay(500);\n        }       \n    }\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay(100);\n        IOCLR1 = 1<<led;   \n        delay(100);\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"..\/lcd_header.h\"\n\n#define ROW (0x0F<<21)    \n#define COL (0x0F<<17)   \nvoid rows(void);\nvoid row_key(void);\nvoid col_key(void);\nint main()\n{\n    \n\n    lcd_config();\n    while(1)\n    {\n        col_key();\n    }   \n}\n\n\nvoid col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n    \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        \n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n            \n        }\n\n}\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid intr_config(void);\nvoid ext_isr(void)__irq;\nint main()\n{\n    IODIR1 |= LED_ALL;\n    PINSEL0 = PINSEL0 | (1<<29); \n    PINSEL0 = PINSEL0 & ~(1<<28);\n    intr_config();\n    while(1)\n    {\n            blink_led(17);\n    }\n}\n\nvoid intr_config(void)\n{\n    VICIntSelect &= ~(1<<15);   \n    VICVectCntl2 = (1<<5)|15;\n    VICVectAddr2 = (long)ext_isr;\n    VICIntEnable = (1<<15);\n    \n    EXTMODE = 1<<1;  \n    \n    EXTPOLAR = (1<<1); \n    \n}\n\nvoid ext_isr(void)__irq\n{\n    blink_led(24);\n    EXTINT = 1<<1; \n    VICVectAddr = 0x00000000;\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include \"..\/lcd_header.h\"\n\nvoid i2c_config(void);\nvoid i2c_start(void);\nvoid i2c_data(char );\nvoid i2c_stop(void);\n\n\nint main()\n{\n    lcd_config();\n    i2c_config();\n    \n    \n    i2c_start();\n    i2c_data(0xA0);     \n    i2c_data(0x00);     \n    i2c_data('D');\n    i2c_data('E');\n    i2c_data('F');\n    i2c_stop();\n    \n}\n\nvoid i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}\n\nvoid i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}\n\nvoid i2c_data(char data)\n{\n    I2DAT = data;\n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;\n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = 1<<4;    \n}\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include \"..\/lcd_header.h\"\n\nvoid i2c_config(void);\nvoid i2c_start(void);\nvoid i2c_data(char );\nvoid i2c_stop(void);\n\n\nint main()\n{\n    lcd_config();\n    i2c_config();\n    \n    i2c_start();\n    i2c_data(0xA0);     \n    i2c_data(0x00);     \n    i2c_data('A');\n    i2c_data('B');\n    i2c_data('C');\n    i2c_stop();\n    \n}\n\nvoid i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    \n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}\n\nvoid i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}\n\nvoid i2c_data(char data)\n{\n    I2DAT = data;\n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;\n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = 1<<4;    \n}\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include \"..\/lcd_header.h\"\n\nvoid i2c_config(void);\nvoid i2c_start(void);\nvoid i2c_data(char );\nchar i2c_recv(void);\nvoid i2c_stop(void);\n\n\nint main()\n{\n    char data;\n    lcd_config();\n    i2c_config();\n    \n    \n    I2CONSET = 1<<2;        \n    \n    i2c_start();\n    i2c_data(0xA0);\n    i2c_data(0x00);         \n    \n    i2c_start();\n    i2c_data(0xA1);         \n    data = i2c_recv();\n    lcd_data(data);\n    data = i2c_recv();\n    lcd_data(data);\n    data = i2c_recv();\n    lcd_data(data);\n    i2c_stop();\n    \n}\n\nvoid i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    \n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}\n\nvoid i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}\n\nvoid i2c_data(char data)\n{\n    I2DAT = data;           \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;\n}\n\nchar i2c_recv(void)\n{\n    char recv;\n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;\n    recv = I2DAT;\n    return recv;\n}\n\nvoid i2c_stop(void)\n{\n    I2CONSET = 1<<4;    \n}\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\nvoid delay(int );\nvoid blink_led(int );\n\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    IODIR1 = IODIR1 & ~(1<<25);  \n\n\n\n\n    while(1)\n    {\n        if(IOPIN1 & (1<<25))\n        {\n            IOSET1 = 0x0F<<17;\n        }\n        \n    }\n}\n\n\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay(100);\n        IOCLR1 = 1<<led;   \n        delay(100);\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n#include \"..\/lcd_header.h\"\n\n#define ROW (0x0F<<21)    \n#define COL (0x0F<<17)    \nvoid row_key(void);\nvoid col_key(void);\nint main()\n{\n    lcd_config();\n    while(1)\n    {\n        row_key();\n    }   \n}\n\nvoid row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"R1\");\n                col_key();\n                break;\n            case 0x0D:\n                lcd_str(\"R2\");\n                col_key();\n                break;\n            case 0x0B:\n                lcd_str(\"R3\");\n                col_key();\n                break;\n            case 0x07:\n                lcd_str(\"R4\");\n                col_key();\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}\n\nvoid col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n    \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        lcd_cmd(0xC0);\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(200);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(200);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(200);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(200);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);          \n        }\n}\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n#include \"..\/lcd_header.h\"\n\n#define ROW (0x0F<<21)    \n#define COL (0x0F<<17)    \nvoid row_key(void);\nvoid col_key1(void);\nvoid col_key2(void);\nvoid col_key3(void);\nvoid col_key4(void);\nint main()\n{\n    lcd_config();\n    while(1)\n    {\n        row_key();\n    }   \n}\n\nvoid row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                col_key1();  \n                break;\n            case 0x0D:\n                col_key2();  \n                break;\n            case 0x0B:\n                col_key3();  \n                break;\n            case 0x07:\n                col_key4();  \n                break;\n\n\n\n        }\n}\n\nvoid col_key1(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('1');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('2');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('3');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('+');\n                delay(500);\n                break;\n                        \n        }\n}\n\nvoid col_key2(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('4');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('5');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('6');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('-');\n                delay(500);\n                break;\n                    \n        }\n}\nvoid col_key3(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('7');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('8');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('9');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('*');\n                delay(500);\n                break;\n                        \n        }\n}\n\nvoid col_key4(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('#');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('0');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('=');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('\/');\n                delay(500);\n                break;\n                        \n        }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n\n#define RS (1<<10)\n#define RW (1<<12)\n#define EN (1<<13)\n#define DATA (0xFF<<15)\n\nvoid delay(int);\nvoid lcd_config(void);\nvoid lcd_cmd(char );\nvoid lcd_data(char );\nvoid lcd_str(char []);\nvoid lcd_num(int );\n\nint main()\n{\n\n    int num = 12345678;\n\n    lcd_config();\n    \n    lcd_num(num);\n\n\n\n\n\n\n    \n    \n\n\n\n\n\n\n    \n\n\n\n\n\n\n}\n\nvoid lcd_config(void)\n{\n    IODIR0 = IODIR0 | RS | RW | EN | DATA; \n    \n    lcd_cmd(0x38);  \n    lcd_cmd(0x0E);  \n    lcd_cmd(0x01);  \n    lcd_cmd(0x80);  \n}\n\nvoid lcd_cmd(char c)\n{\n    \n    \n    \n    IOCLR0 = DATA;    \n    IOSET0 = c<<15;\n    IOCLR0 = RW;    \n    IOCLR0 = RS;    \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;    \n}\n\nvoid lcd_data(char d)\n{\n    IOCLR0 = DATA;\n    IOSET0 = d <<15;\n    IOCLR0 = RW;\n    IOSET0 = RS;\n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid lcd_str(char str[])\n{\n    for(int i=0;str[i]!='\\0';i++)\n    {\n        lcd_data(str[i]);\n    }\n\n\n\n\n\n}\n\nvoid lcd_num(int num)\n{\n    if(num)\n    {\n        lcd_num(num\/10);\n        lcd_data(num%10 + 0x30);\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"#include \"lcd_header.h\"\n\nvoid lcd_config(void)\n{\n    IODIR0 = IODIR0 | RS | RW | EN | DATA; \n    \n    lcd_cmd(0x38);  \n    lcd_cmd(0x0E);  \n    lcd_cmd(0x01);  \n    lcd_cmd(0x80);  \n}\n\nvoid lcd_cmd(char c)\n{\n    \n    \n    \n    IOCLR0 = DATA;    \n    IOSET0 = c<<15;\n    IOCLR0 = RW;    \n    IOCLR0 = RS;    \n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;    \n}\n\nvoid lcd_data(char d)\n{\n    IOCLR0 = DATA;\n    IOSET0 = d <<15;\n    IOCLR0 = RW;\n    IOSET0 = RS;\n    IOSET0 = EN;\n    delay(100);\n    IOCLR0 = EN;\n}\n\nvoid lcd_str(char str[])\n{\n    for(int i=0;str[i]!='\\0';i++)\n    {\n        lcd_data(str[i]);\n    }\n\n\n\n\n\n}\n\nvoid lcd_num(int num)\n{\n    if(num)\n    {\n        lcd_num(num\/10);\n        lcd_data(num%10 + 0x30);\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\n\nvoid delay(int);\n\nint main()\n{\n\n    IODIR1 = IODIR1 | (0xFF << 17);   \n\n    while(1)\n    {\n        for(int i=17;i<=24;++i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n        \n        for(int i=24;i>=17;--i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n    }\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xff<<17)\n#define LED1    (1<<17)         \n#define LED2    (1<<18)         \nvoid delay(int);\n\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL;\n    \n    while(1)\n    {\n        for(int i=17; i<= 24;i++)\n        {\n        IOSET1 = 1<<i;\n        delay(1000);\n        }\n        IOCLR1 = LED_ALL;\n        delay(1000);\n    }\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid timer0_isr(void)__irq;\nvoid timer1_isr(void)__irq;\nvoid ext_isr(void)__irq;\nvoid timer_config(void);\nvoid intr_config(void);\n\n\nint main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        PINSEL0 = PINSEL0 | (1<<29); \n        PINSEL0 = PINSEL0 & ~(1<<28);\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}\n\nvoid timer_config(void)\n{\n    \n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        \n    \n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n    \n        T0TCR = (1<<0);\n}\n\nvoid intr_config(void)\n{\n    \n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); \n    \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        \n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n        \n        VICVectCntl3 = (1<<5)|15;   \n        VICVectAddr3 = (long)&ext_isr;\n    \n    \n        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   \n        \n        EXTMODE = 1<<1; \n        EXTPOLAR = 1<<1;    \n}\n\nvoid timer0_isr(void)__irq\n{\n    IOSET1 = 1<<20;  \n    delay_ms(100);\n    IOCLR1 = 1<<20;   \n    delay_ms(100);\n    T0IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\n\nvoid timer1_isr(void)__irq\n{\n    IOSET1 = 1<<22;  \n    delay_ms(100);\n    IOCLR1 = 1<<22;   \n    delay_ms(100);\n    T1IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\n\nvoid ext_isr(void)__irq\n{\n    blink_led(24);\n    EXTINT = 1<<1; \n    VICVectAddr = 0x00000000;\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include<lpc21xx.h>\n\nvoid delay(int);\n\n\n\nint main()\n{\n    IODIR1 = IODIR1 | (1<<17)|(1<<18);\n    while(1)\n    {\n        IOSET1 = (1<<17)|(1<<18);\n        delay(1000);\n        IOCLR1 = (1<<17)|(1<<18);\n        delay(1000);\n    }\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid nonvic_isr(void)__irq;\nvoid timer_config(void);\nvoid intr_config(void);\n\n\nint main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        PINSEL0 = PINSEL0 | (1<<29); \n        PINSEL0 = PINSEL0 & ~(1<<28);\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}\n\nvoid timer_config(void)\n{\n    \n        T0PR = 14;\n        T0MR0 = 3000000;\n        T0MCR = (1<<0)|(1<<1);\n        \n    \n        T1PR = 14;\n        T1MR0 = 3500000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n    \n        T0TCR = (1<<0);\n}\n\nvoid intr_config(void)\n{\n    \n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); \n    \n        VICDefVectAddr = (long)nonvic_isr;\n    \n        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   \n        \n        EXTMODE = 1<<1; \n        EXTPOLAR = 1<<1;    \n}\n\nvoid nonvic_isr(void)__irq\n{\n    blink_led(24);\n    T0IR = 1<<0;\n    T1IR = 1<<0;\n    EXTINT = 1<<1;\n    VICVectAddr = 0x00000000;\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n#include \"..\/lcd_header.h\"\n\n#define ROW (0x0F<<21)    \n#define COL (0x0F<<17)    \nvoid rows(void);\nvoid row_key(void);\nvoid col_key(void);\nint main()\n{\n    \n\n\n\n\n    lcd_config();\n    while(1)\n    {\n        row_key();\n    }   \n}\n\nvoid row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n    \n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        \n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"R1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"R2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"R3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"R4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}\n\nvoid col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n    \n        val = (IOPIN1 & COL); \n        val = val >> 21;\n        \n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n            \n        }\n\n}\n\nvoid rows(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n    \n        val = (IOPIN1 & ROW); \n        val = val >> 17;\n        if(val == 0x0E)\n        {\n            lcd_str(\"row1\");\n            delay(500);\n        }\n        if(val == 0x0D)\n        {\n            lcd_str(\"row2\");\n            delay(500);\n        }\n        if(val == 0x0B)\n        {\n            lcd_str(\"row3\");\n            delay(500);\n        }\n        if(val == 0x07)\n        {\n            lcd_str(\"Row4\");\n            delay(500);\n        }\n        delay(1000);\n        lcd_cmd(0x01);\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21xx.h>\n\nvoid delay(int);\nint main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    \n\n    \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR = (1<<4)|(1<<12);  \n    PWMTCR = (1<<0)|(1<<3);  \n    \n        while(1)\n        {\n            PWMMR3 = 1000;   \n            PWMMR4 = 3500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            \n            PWMMR3 = 1000;  \n            PWMMR4 = 6000;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            \n            PWMMR3 = 1000;  \n            PWMMR4 = 8500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n        \n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {\n        }\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include<lpc21xx.h>\n\nvoid delay(int);\nint main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    \n\n    \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR &= ~(1<<4);  \n    PWMPCR = (1<<12);\n    PWMTCR = (1<<0)|(1<<3);  \n    \n        while(1)\n        {\n            PWMMR4 = 2500;   \n            PWMLER = 1<<4;\n            delay(500);\n            \n            PWMMR4 = 5000;   \n            PWMLER = 1<<4;\n            delay(500);\n            \n            PWMMR4 = 7500;   \n            PWMLER = 1<<4;\n            delay(500);\n            \n            PWMMR4 = 10000;   \n            PWMLER = 1<<4;\n            delay(500);\n        \n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {\n        }\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n#include \"..\/lcd_header.h\"\n\n#define ROW (0x0F<<17)   \n#define COL (0x0F<<21)   \n\nint main()\n{\n    int val;\n    IODIR1 = IODIR1 & ~(ROW);\n\n    IODIR1 = IODIR1 | (COL);\n\n\n\n\n    lcd_config();\n    while(1)\n    {\n        val = (IOPIN1 & ROW); \n        val = val >> 17;\n\n\n\n\n\n    \n\n\n\n\n        if(val == 0x0E)\n        {\n            lcd_str(\"row1\");\n            delay(500);\n        }\n\n\n\n        if(val == 0x0D)\n        {\n            lcd_str(\"row2\");\n            delay(500);\n        }\n\n\n\n        if(val == 0x0B)\n        {\n            lcd_str(\"row3\");\n            delay(500);\n        }\n\n\n\n        if(val == 0x07)\n        {\n            lcd_str(\"Row4\");\n            delay(500);\n        }\n       \n\n\n\n\n\n\n\n\n        lcd_cmd(0x01);\n    \n    }   \n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n\nvoid spi_data(int);\n\nint main()\n{\n    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  \n    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));\n    IODIR0 |= (1<<7);       \n    \n    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       \n    S0SPCCR = 8;        \n    spi_data(0x0C01);               \n    spi_data(0x090F);               \n    spi_data(0x0AFF);               \n    spi_data(0x0B03);               \n    \n    spi_data(0x010C);               \n    spi_data(0x020B);       \n    spi_data(0x030D);       \n    spi_data(0x040E);       \n}\n\nvoid spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n#include<lpc21xx.h>\n\nvoid spi_data(int);\n\nint main()\n{\n    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  \n    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));\n    IODIR0 |= (1<<7);       \n    \n    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       \n    S0SPCCR = 8;        \n    spi_data(0x0C01);               \n    spi_data(0x0900);               \n    spi_data(0x0A00);               \n    spi_data(0x0B03);               \n    \n    spi_data(0x0177);       \n    spi_data(0x021F);       \n    spi_data(0x034E);       \n    spi_data(0x043D);       \n}\n\nvoid spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include<LPC21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid blink_led(int);\nvoid delay(int);\n\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 2000000;\n    T0MCR = (1<<0)|(1<<1);  \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        if(T0IR & (1<<0))  \n        {\n            blink_led(17);\n            T0IR = (1<<0); \n        }\n    }\n    \n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay(100);\n        IOCLR1 = 1<<led;   \n        delay(100);\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid timer0_isr(void)__irq;\nvoid timer1_isr(void)__irq;\nvoid timer_config(void);\nvoid intr_config(void);\n\nint main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}\n\nvoid timer_config(void)\n{\n    \n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        \n    \n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n    \n    T0TCR = (1<<0);\n}\n\nvoid intr_config(void)\n{\n    \n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        \n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n    \n        VICIntEnable = (1<<5)|(1<<4);   \n}\n\nvoid timer0_isr(void)__irq\n{\n    IOSET1 = 1<<20;  \n    delay_ms(100);\n    IOCLR1 = 1<<20;   \n    delay_ms(100);\n    T0IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\n\nvoid timer1_isr(void)__irq\n{\n    IOSET1 = 1<<24;  \n    delay_ms(100);\n    IOCLR1 = 1<<24;   \n    delay_ms(100);\n    T1IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid timer1_isr(void)__irq;\nvoid timer_config(void);\nvoid intr_config(void);\n\nint main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}\n\nvoid timer_config(void)\n{\n    \n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n}\n\nvoid intr_config(void)\n{\n    \n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;       \n        VICIntEnable = (1<<4)|(1<<5);   \n}\nvoid timer1_isr(void)__irq\n{\n    IOSET1 = 1<<24;  \n    delay_ms(100);\n    IOCLR1 = 1<<24;   \n    delay_ms(100);\n    T1IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include<LPC21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid blink_led(int);\nvoid delay(int);\n\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 1000000;\n    T0MR1 = 2000000;\n    T0MCR = (1<<0)|(1<<3)|(1<<4);   \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        if(T0IR & (1<<0))  \n        {\n            IOSET1 = 1<<17;\n            T0IR = (1<<0); \n        }\n        else if(T0IR & (1<<1))  \n        {\n            IOCLR1 = 1<<17;\n            T0IR = (1<<1); \n        }\n    }\n    \n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay(100);\n        IOCLR1 = 1<<led;   \n        delay(100);\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n#include<LPC21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid blink_led(int);\nvoid delay(int);\n\nint main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 3000000;\n    T0MCR = (1<<0)|(1<<1);  \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        blink_led(17);\n\n        while(!(T0IR & (1<<0))) \n        {}\n                \n            blink_led(24);\n            T0IR = (1<<0); \n\n        blink_led(18);\n        blink_led(19);\n        blink_led(20);\n        blink_led(21);\n\n        \n        \n    }\n    \n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay(100);\n        IOCLR1 = 1<<led;   \n        delay(100);\n}\n\nvoid delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n"}
{"target":"JeyaramanOfficial","func":"#include \"..\\lcd_header.h\"\n\nint main()\n{\n    char var;\n    PINSEL0 |= (1<<0)|(1<<2);   \n    PINSEL0 &= ~((1<<1)|(1<<3));\n    lcd_config();\n    U0LCR = (1<<7);     \n    U0DLL = 97;             \n    U0DLM = 0;\n    U0LCR &= ~(1<<7);   \n    U0LCR = (1<<0)|(1<<1); \n    \n    while(1)\n    {\n        while(!(U0LSR & (1<<0)));   \n            var = U0RBR;            \n            lcd_data(var);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n#include<lpc21xx.h>\n#define LED_ALL (0xFF<<17)\n\nvoid delay_ms(int );\nvoid blink_led(int );\nvoid timer0_isr(void)__irq;\n\nint main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        \n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T0TCR = (1<<0);\n        \n        VICIntSelect = VICIntSelect & ~(1<<4); \n\n\n        VICVectCntl1 = (1<<5)|4;   \n        VICVectAddr1 = (long)&timer0_isr;       \n        VICIntEnable = (1<<4);   \n        while(1)\n        {\n            blink_led(17);\n        }\n}\n\nvoid timer0_isr(void)__irq\n{\n    IOSET1 = 1<<24;  \n    delay_ms(100);\n    IOCLR1 = 1<<24;   \n    delay_ms(100);\n    T0IR = 1<<0;            \n    VICVectAddr = 0x00000000;  \n    \n}\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;  \n        delay_ms(100);\n        IOCLR1 = 1<<led;   \n        delay_ms(100);\n}\n\nvoid delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}\n\n\n\n\n\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n#include<lpc21xx.h>\n\nvoid delay(int );\nvoid blink_led(int);\n\nint main()\n{\n    IODIR1 |= 0xFF<<17;\n    WDMOD = (1<<1) | (1<<0);   \n    WDTC = 0xFFFFFF;\n    blink_led(24);\n    WDFEED = 0xAA; \n    WDFEED = 0x55;\n    while(1)\n    {\n        blink_led(17);\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}\n\nvoid blink_led(int led)\n{\n    IOSET1 = 1<<led;\n        delay(500);\n        IOCLR1 = 1<<led;\n        delay(500);\n}\n"}
{"target":"JeyaramanOfficial","func":"\n\n\n\n\n\n\n\n#include<lpc21xx.h>\n\nvoid delay(int );\nvoid blink_led(int);\n\nint main()\n{\n    IODIR1 |= 0xFF<<17;\n    WDMOD = (1<<1) | (1<<0);   \n    WDTC = 0xFFFFFF;        \n    blink_led(24);\n    WDFEED = 0xAA; \n    WDFEED = 0x55;\n    while(1)\n    {\n        if(WDTV <= 0xF00000)\n        {\n                WDFEED = 0xAA;          \n                WDFEED = 0x55;\n        }\n        blink_led(17);\n    }\n}\n\nvoid delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}\n\nvoid blink_led(int led)\n{\n        IOSET1 = 1<<led;\n        delay(500);    \n        IOCLR1 = 1<<led;\n        delay(500);\n}\n"}
{"target":"jimmywong2003","func":"\n\n#include \"sdk_common.h\"\n\n#include \"sdk_config.h\"\n#include <stdlib.h>\n\n#if 1\n\n#include <string.h>\n#include \"app_error.h\"\n#include \"nrf_assert.h\"\n#include \"sdk_macros.h\"\n#include \"ble_advdata.h\"\n\n#include \"nrf_ble_whitelist.h\"\n\n\n\nstatic bool m_whitelist_is_running = false;\n\nstatic ble_gap_addr_t const * m_whitelist_addr_ptrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];\nstatic ble_gap_addr_t m_whitelist_addrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];\nstatic uint8_t m_addr_cnt = 0;\n\nret_code_t nrf_ble_whitelist_add(ble_gap_addr_t *addr, uint8_t * whitelist_count)\n{\n\n        if (m_addr_cnt >= BLE_GAP_WHITELIST_ADDR_MAX_COUNT)\n                return NRF_ERROR_DATA_SIZE;\n\n        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)\n        {\n                if (memcmp(&m_whitelist_addrs[i], addr, sizeof(ble_gap_addr_t))==0)\n                {\n                        \n                        return NRF_ERROR_INVALID_PARAM;\n                }\n        }\n\n        memcpy(&m_whitelist_addrs[m_addr_cnt], addr, sizeof(ble_gap_addr_t));\n\n        m_addr_cnt++;\n\n        \n        *whitelist_count = m_addr_cnt;\n\n        return NRF_SUCCESS;\n}\n\nret_code_t nrf_ble_whitelist_enable(void)\n{\n        ret_code_t ret;\n\n        m_whitelist_is_running = true;\n\n        if (m_addr_cnt == 0)\n        {\n                return NRF_ERROR_DATA_SIZE;\n        }\n\n        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)\n        {\n                m_whitelist_addr_ptrs[i] = &m_whitelist_addrs[i];\n        }\n\n        ret = sd_ble_gap_whitelist_set(m_whitelist_addr_ptrs, m_addr_cnt);\n        APP_ERROR_CHECK(ret);\n\n        return NRF_SUCCESS;\n}\n\n\nuint8_t nrf_ble_whitelist_cnt(void)\n{\n        return m_addr_cnt;\n}\n\nret_code_t nrf_ble_whitelist_clear(void)\n{\n        ret_code_t ret;\n        memset(m_whitelist_addrs, 0, sizeof(m_whitelist_addrs));\n        m_addr_cnt = 0;\n\n        ret = sd_ble_gap_whitelist_set(NULL, 0);\n        APP_ERROR_CHECK(ret);\n\n\n        m_whitelist_is_running = false;\n        return ret;\n}\n\n\nbool nrf_ble_whitelist_is_running(void)\n{\n        return m_whitelist_is_running;\n}\n\n\n\n#endif \n"}
{"target":"jimmywong2003","func":"\n\n#include \"nrf_dfu_flash.h\"\n#include \"nrf_dfu_types.h\"\n\n#include \"nrf_fstorage.h\"\n#include \"nrf_fstorage_sd.h\"\n#include \"nrf_fstorage_nvmc.h\"\n\n\n#define NRF_LOG_MODULE_NAME nrf_dfu_flash\n#include \"nrf_log.h\"\n\n#if NRF_DFU_FLASH_CONFIG_LOG_ENABLED\n#define NRF_LOG_LEVEL BLE_SCAN_CONFIG_LOG_LEVEL\n#define NRF_LOG_INFO_COLOR BLE_SCAN_CONFIG_INFO_COLOR\n#define NRF_LOG_DEBUG_COLOR BLE_SCAN_CONFIG_DEBUG_COLOR\n#else \n#define NRF_LOG_LEVEL 4\n#endif \n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n\nvoid dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt);\n\n\nNRF_FSTORAGE_DEF(nrf_fstorage_t m_fs) =\n{\n        .evt_handler = dfu_fstorage_evt_handler,\n        .start_addr  = 0x40000,\n        .end_addr    = 0x50000\n};\n\nstatic uint32_t m_flash_operations_pending;\n\nvoid dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n\n        if (p_evt->p_param)\n        {\n                \n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n                \n        }\n}\n\n\nret_code_t nrf_dfu_flash_init(bool sd_irq_initialized)\n{\n        nrf_fstorage_api_t * p_api_impl;\n\n        \n#if defined(BLE_STACK_SUPPORT_REQD) || defined(ANT_STACK_SUPPORT_REQD)\n        if (sd_irq_initialized)\n        {\n                NRF_LOG_DEBUG(\"Initializing nrf_fstorage_sd backend.\");\n                p_api_impl = &nrf_fstorage_sd;\n        }\n        else\n#endif\n        {\n                NRF_LOG_DEBUG(\"Initializing nrf_fstorage_nvmc backend.\");\n                p_api_impl = &nrf_fstorage_nvmc;\n        }\n\n        return nrf_fstorage_init(&m_fs, p_api_impl, NULL);\n}\n\n\nret_code_t nrf_dfu_flash_store(uint32_t dest,\n                               void const * p_src,\n                               uint32_t len,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n\n        NRF_LOG_DEBUG(\"nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d\",\n                      dest, p_src, len, m_flash_operations_pending);\n\n        \n        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);\n        \n\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_write() failed with error 0x%x.\", rc);\n        }\n\n        return rc;\n}\n\n\nret_code_t nrf_dfu_flash_erase(uint32_t page_addr,\n                               uint32_t num_pages,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n\n        NRF_LOG_DEBUG(\"nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d\",\n                      page_addr, num_pages, m_flash_operations_pending);\n\n        \n        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);\n        \n\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_erase() failed with error 0x%x.\", rc);\n        }\n\n        return rc;\n}\n"}
{"target":"jimmywong2003","func":"\n#include \"sdk_config.h\"\n\n#if NRF_FSTORAGE_ENABLED\n\n#include \"nrf_fstorage.h\"\n#include <stddef.h>\n#include <stdint.h>\n#include \"sdk_errors.h\"\n#include \"sdk_macros.h\"\n#include \"nrf_section.h\"\n\n#define NRF_LOG_MODULE_NAME nrf_fstorage\n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n\n\nNRF_SECTION_DEF(fs_data, nrf_fstorage_t);\n\n\n\n#define NRF_FSTORAGE_PARAM_CHECK(_cond, _err)                                                       \\\n    NRF_PARAM_CHECK(NRF_FSTORAGE, _cond, _err, NRF_LOG_ERROR)\n\n\nstatic bool addr_is_aligned32(uint32_t addr);\nstatic bool addr_is_page_aligned(nrf_fstorage_t const * p_fs, uint32_t addr);\nstatic bool addr_is_within_bounds(nrf_fstorage_t const * p_fs, uint32_t addr, uint32_t len);\n\n\nret_code_t nrf_fstorage_init(nrf_fstorage_t     * p_fs,\n                             nrf_fstorage_api_t * p_api,\n                             void               * p_param)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,  NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_api, NRF_ERROR_NULL);\n\n    p_fs->p_api = p_api;\n\n    return (p_fs->p_api)->init(p_fs, p_param);\n}\n\n\nret_code_t nrf_fstorage_uninit(nrf_fstorage_t * p_fs,\n                               void           * p_param)\n{\n    ret_code_t rc;\n\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n\n    rc = (p_fs->p_api)->uninit(p_fs, p_param);\n\n    \n    p_fs->p_api        = NULL;\n    p_fs->p_flash_info = NULL;\n\n    return rc;\n}\n\n\nret_code_t nrf_fstorage_read(nrf_fstorage_t const * p_fs,\n                             uint32_t               src,\n                             void                 * p_dest,\n                             uint32_t               len)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_dest,      NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n\n    \n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(src),                NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, src, len), NRF_ERROR_INVALID_ADDR);\n\n    return (p_fs->p_api)->read(p_fs, src, p_dest, len);\n}\n\n\nret_code_t nrf_fstorage_write(nrf_fstorage_t const * p_fs,\n                              uint32_t               dest,\n                              void           const * p_src,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_src,       NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n\n    \n    NRF_FSTORAGE_PARAM_CHECK(!(len % p_fs->p_flash_info->program_unit), NRF_ERROR_INVALID_LENGTH);\n\n    \n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(dest),                NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32((uint32_t)p_src),     NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, dest, len), NRF_ERROR_INVALID_ADDR);\n\n    return (p_fs->p_api)->write(p_fs, dest, p_src, len, p_context);\n}\n\n\nret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,\n                              uint32_t               page_addr,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n\n    \n    NRF_FSTORAGE_PARAM_CHECK(addr_is_page_aligned(p_fs, page_addr), NRF_ERROR_INVALID_ADDR);\n\n    NRF_FSTORAGE_PARAM_CHECK(\n        addr_is_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)),\n        NRF_ERROR_INVALID_ADDR\n    );\n\n    return (p_fs->p_api)->erase(p_fs, page_addr, len, p_context);\n}\n\n\nuint8_t const * nrf_fstorage_rmap(nrf_fstorage_t const * p_fs, uint32_t addr)\n{\n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        return NULL;\n    }\n\n    return (p_fs->p_api)->rmap(p_fs, addr);\n}\n\n\nuint8_t * nrf_fstorage_wmap(nrf_fstorage_t const * p_fs, uint32_t addr)\n{\n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        return NULL;\n    }\n\n    return (p_fs->p_api)->wmap(p_fs, addr);\n}\n\n\nbool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)\n{\n    \n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)\n        {\n            p_fs = NRF_FSTORAGE_INSTANCE_GET(i);    \n            if (p_fs->p_api != NULL)\n            {\n                \n                if (p_fs->p_api->is_busy(p_fs))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    return p_fs->p_api->is_busy(p_fs);\n}\n\n\nstatic bool addr_is_within_bounds(nrf_fstorage_t const * p_fs,\n                                  uint32_t               addr,\n                                  uint32_t               len)\n{\n    return (   (addr           >= p_fs->start_addr)\n            && (addr + len - 1 <= p_fs->end_addr));\n}\n\n\nstatic bool addr_is_aligned32(uint32_t addr)\n{\n    return !(addr & 0x03);\n}\n\n\nstatic bool addr_is_page_aligned(nrf_fstorage_t const * p_fs,\n                                 uint32_t               addr)\n{\n    return (addr & (p_fs->p_flash_info->erase_unit - 1)) == 0;\n}\n\n\n#endif \n"}
{"target":"jimmywong2003","func":"#include \"app_display.h\"\n#include \"ugui.h\"\n#include \"nrf_gfx_ext.h\"\n#include \"images.h\"\n\n#define RSSI\n\nUG_WINDOW window_1;\nchar m_summary_string1[64];\nchar m_summary_string2[64];\n\nextern const nrf_lcd_t nrf_lcd_ili9341;\nstatic const nrf_lcd_t * p_lcd = &nrf_lcd_ili9341;\n\nchar *display_string_phy[] = {\"Coded\", \"1 Mbps\", \"2 Mbps\", \"MultiPhy\"};\n\nchar *display_string_rssi_label[] = {\"RSSI (LR):\", \"RSSI (1M):\", \"RSSI (2M):\"};\nchar *display_string_speed_label[] = {\"Speed (LR):\", \"Speed (1M):\", \"Speed (2M):\"};\nchar *display_string_psr_label[] = {\"PSR:\", \"PSR:\", \"PSR:\"};\n\nchar *display_string_trip_phy_rssi_label[] = {\"LB (LR):\", \"LB (1M):\", \"LB (2M):\"};\nchar *display_string_tx_power[] = {\"0 dBm\", \"4 dBm\", \"8 dBm\"};\nchar *display_string_app_state[] = {\"Idle\", \"Advertising\", \"Scanning\", \"Connected\", \"Disconnected\"};\nchar *display_string_led_state[] = {\"Off\", \"On\"};\nchar *display_string_button_state[] = {\"Off\", \"On\"};\nconst UG_COLOR display_app_state_button_color[] = APP_STATE_COLORS;\nconst UG_COLOR display_app_state_button_font_color[] = APP_STATE_FONT_COLORS;\nconst UG_COLOR display_on_off_color[] = ON_OFF_COLORS;\nconst UG_COLOR display_on_off_font_color[] = ON_OFF_FONT_COLORS;\n\nUG_GUI gui;\nUG_TEXTBOX textbox_toggle_phy;\nUG_TEXTBOX textbox_toggle_power;\nUG_TEXTBOX textbox_toggle_adv_type; \nUG_TEXTBOX textbox_rssi_label[3];\nUG_TEXTBOX textbox_psr_label;\nUG_TEXTBOX textbox_rssi_number[3];\nUG_TEXTBOX textbox_psr_number;\nUG_TEXTBOX textbox_dbm_label;\nUG_TEXTBOX textbox_percentage_label;\nUG_TEXTBOX textbox_link_indicator;\nUG_TEXTBOX textbox_led_label;\nUG_TEXTBOX textbox_button_label;\nUG_BUTTON phy_button;\nUG_BUTTON power_button;\nUG_BUTTON adv_button;\nUG_BUTTON led_button;\nUG_BUTTON button_button;\nUG_IMAGE image_1;\n\nstatic char sprintf_buf[64];\nstatic char sprintf_psr[64];\n\n#define MAX_OBJECTS 20\n\nUG_OBJECT obj_buff_wnd_1[MAX_OBJECTS];\n\nstatic app_display_content_t content_previous = {0};\n\nvoid window_1_callback (UG_MESSAGE *msg)\n{\n        UNUSED_PARAMETER(msg);\n}\n\nvoid app_display_init(app_display_content_t *initial_state)\n{\n        content_previous = *initial_state;\n        UG_Init(&gui, 240, 320, p_lcd);\n}\n\nvoid app_display_create_main_screen(app_display_content_t *content)\n{\n        \n        UG_WindowCreate ( &window_1, obj_buff_wnd_1, MAX_OBJECTS, window_1_callback );\n        \n        UG_WindowSetTitleText (&window_1, content->main_title);\n        UG_WindowSetTitleTextFont (&window_1, &FONT_10X16);\n        UG_WindowSetTitleTextAlignment(&window_1, ALIGN_CENTER);\n\n        \n        UG_TextboxCreate(&window_1, &textbox_toggle_phy, TXB_ID_0, TXT_ID_0_X_LOCATION, TXT_ID_0_Y_LOCATION, TXT_ID_0_X_LOCATION+TXT_ID_0_WIDTH, TXT_ID_0_Y_LOCATION+TXT_ID_0_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_0, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_0, \"Btn 1: PHY\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_0, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_0, FILL_COLOR_TEXT );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_0, ALIGN_CENTER );\n\n        \n        UG_ButtonCreate(&window_1, &phy_button, BTN_ID_0, BTN_ID_0_X_LOCATION, BTN_ID_0_Y_LOCATION, BTN_ID_0_X_LOCATION+BTN_ID_0_WIDTH, BTN_ID_0_Y_LOCATION+BTN_ID_0_HEIGHT);\n        UG_ButtonSetStyle(&window_1, BTN_ID_0, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);\n        UG_ButtonSetForeColor(&window_1, BTN_ID_0, FONT_COLOR_BUTTON);\n        UG_ButtonSetBackColor(&window_1, BTN_ID_0, FILL_COLOR_BUTTON);\n        UG_ButtonSetFont(&window_1, BTN_ID_0, &FONT_10X16);\n\n        \n        UG_TextboxCreate(&window_1, &textbox_toggle_power, TXB_ID_1, TXT_ID_1_X_LOCATION, TXT_ID_1_Y_LOCATION, TXT_ID_1_X_LOCATION+TXT_ID_1_WIDTH, TXT_ID_1_Y_LOCATION+TXT_ID_1_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_1, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_1, \"Btn 2: Power\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_1, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_1, FILL_COLOR_TEXT );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_1, ALIGN_CENTER );\n\n        \n        UG_ButtonCreate(&window_1, &power_button, BTN_ID_1, BTN_ID_1_X_LOCATION, BTN_ID_1_Y_LOCATION, BTN_ID_1_X_LOCATION+BTN_ID_1_WIDTH, BTN_ID_1_Y_LOCATION+BTN_ID_1_HEIGHT);\n        UG_ButtonSetStyle(&window_1, BTN_ID_1, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);\n        UG_ButtonSetForeColor(&window_1, BTN_ID_1, FONT_COLOR_BUTTON);\n        UG_ButtonSetBackColor(&window_1, BTN_ID_1, FILL_COLOR_BUTTON);\n        UG_ButtonSetFont(&window_1, BTN_ID_1, &FONT_10X16);\n        \n\n        \n        UG_TextboxCreate(&window_1, &textbox_toggle_adv_type, TXB_ID_2, TXT_ID_2_X_LOCATION, TXT_ID_2_Y_LOCATION, TXT_ID_2_X_LOCATION+TXT_ID_2_WIDTH, TXT_ID_2_Y_LOCATION+TXT_ID_2_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_2, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_2, \"Btn 3: App state\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_2, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_2, FILL_COLOR_TEXT );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_2, ALIGN_CENTER );\n\n        \n        UG_ButtonCreate(&window_1, &adv_button, BTN_ID_2, BTN_ID_2_X_LOCATION, BTN_ID_2_Y_LOCATION, BTN_ID_2_X_LOCATION+BTN_ID_2_WIDTH, BTN_ID_2_Y_LOCATION+BTN_ID_2_HEIGHT);\n        UG_ButtonSetStyle(&window_1, BTN_ID_2, BTN_STYLE_3D|BTN_STYLE_USE_ALTERNATE_COLORS);\n        UG_ButtonSetFont(&window_1, BTN_ID_2, &FONT_10X16);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        UG_TextboxCreate(&window_1, &textbox_rssi_label[0], TXB_ID_3, TXT_ID_3_X_LOCATION, TXT_ID_3_Y_LOCATION, TXT_ID_3_X_LOCATION+TXT_ID_3_WIDTH, TXT_ID_3_Y_LOCATION+TXT_ID_3_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_3, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_3, display_string_trip_phy_rssi_label[0]);\n        UG_TextboxSetForeColor (&window_1, TXB_ID_3, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_3, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_3, ALIGN_CENTER );\n\n        UG_TextboxCreate(&window_1, &textbox_rssi_label[1], TXB_ID_4, TXT_ID_4_X_LOCATION, TXT_ID_4_Y_LOCATION, TXT_ID_4_X_LOCATION+TXT_ID_4_WIDTH, TXT_ID_4_Y_LOCATION+TXT_ID_4_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_4, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_4, display_string_trip_phy_rssi_label[1]);\n        UG_TextboxSetForeColor (&window_1, TXB_ID_4, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_4, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_4, ALIGN_CENTER );\n\n        UG_TextboxCreate(&window_1, &textbox_rssi_label[2], TXB_ID_5, TXT_ID_5_X_LOCATION, TXT_ID_5_Y_LOCATION, TXT_ID_5_X_LOCATION+TXT_ID_5_WIDTH, TXT_ID_5_Y_LOCATION+TXT_ID_5_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_5, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_5, display_string_trip_phy_rssi_label[2]);\n        UG_TextboxSetForeColor (&window_1, TXB_ID_5, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_5, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_5, ALIGN_CENTER );\n\n        \n        UG_TextboxCreate(&window_1, &textbox_rssi_number[0], TXB_ID_6, TXT_ID_6_X_LOCATION, TXT_ID_6_Y_LOCATION, TXT_ID_6_X_LOCATION+TXT_ID_6_WIDTH, TXT_ID_6_Y_LOCATION+TXT_ID_6_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_6, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_6, \"Disconnected\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_6, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_6, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_6, ALIGN_CENTER );\n\n        UG_TextboxCreate(&window_1, &textbox_rssi_number[1], TXB_ID_7, TXT_ID_7_X_LOCATION, TXT_ID_7_Y_LOCATION, TXT_ID_7_X_LOCATION+TXT_ID_7_WIDTH, TXT_ID_7_Y_LOCATION+TXT_ID_7_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_7, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_7, \"Disconnected\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_7, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_7, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_7, ALIGN_CENTER );\n\n        UG_TextboxCreate(&window_1, &textbox_rssi_number[2], TXB_ID_8, TXT_ID_8_X_LOCATION, TXT_ID_8_Y_LOCATION, TXT_ID_8_X_LOCATION+TXT_ID_8_WIDTH, TXT_ID_8_Y_LOCATION+TXT_ID_8_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_8, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_8, \"Disconnected\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_8, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_8, 0x0000 );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_8, ALIGN_CENTER );\n\n#if 1\n        \n        UG_TextboxCreate(&window_1, &textbox_psr_label, TXB_ID_12, TXT_ID_12_X_LOCATION, TXT_ID_12_Y_LOCATION, TXT_ID_12_X_LOCATION+TXT_ID_4_WIDTH, TXT_ID_12_Y_LOCATION+TXT_ID_4_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_12, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_12, \"PSR: \");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_12, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_12, FILL_COLOR_TEXT );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_12, ALIGN_CENTER );\n\n        \n        UG_TextboxCreate(&window_1, &textbox_psr_number, TXB_ID_13, TXT_ID_13_X_LOCATION, TXT_ID_13_Y_LOCATION, TXT_ID_13_X_LOCATION+TXT_ID_6_WIDTH, TXT_ID_13_Y_LOCATION+TXT_ID_6_HEIGHT);\n        UG_TextboxSetFont(&window_1, TXB_ID_13, &FONT_8X12);\n        UG_TextboxSetText(&window_1, TXB_ID_13, \"###\");\n        UG_TextboxSetForeColor (&window_1, TXB_ID_13, FONT_COLOR_TEXT );\n        UG_TextboxSetBackColor (&window_1, TXB_ID_13, FILL_COLOR_TEXT );\n        UG_TextboxSetAlignment (&window_1, TXB_ID_13, ALIGN_CENTER );\n\n#endif\n\n        UG_ImageCreate(&window_1, &image_1, IMG_ID_0, 0, 228, 30, 250);\n        UG_ImageSetBMP(&window_1, IMG_ID_0, &bmp_nordicsemi);\n\n        \n        app_display_update_main_screen(content);\n\n        \n        UG_WindowShow( &window_1 );\n}\n\n\n\nvoid app_display_update_main_screen(app_display_content_t *content)\n{\n        static bool first_update = true;\n        if(first_update || content->phy != content_previous.phy)\n        {\n                UG_ButtonSetText(&window_1, BTN_ID_0, display_string_phy[content->phy]);\n\n\n\n\n\n\n\n\n\n                {\n\n\n                        UG_TextboxSetText(&window_1, TXB_ID_4, display_string_rssi_label[APP_PHY_1M]);\n                        UG_TextboxSetText(&window_1, TXB_ID_12, display_string_psr_label[APP_PHY_1M]);\n                }\n                UG_TextboxSetText(&window_1, TXB_ID_7, \"Disconnected\");\n                UG_TextboxSetText(&window_1, TXB_ID_13, \"Disconnected\");\n        }\n        if(first_update || content->tx_power != content_previous.tx_power)\n        {\n                UG_ButtonSetText(&window_1, BTN_ID_1, display_string_tx_power[content->tx_power]);\n        }\n        if(first_update || content->app_state != content_previous.app_state)\n        {\n                UG_ButtonSetBackColor(&window_1, BTN_ID_2, display_app_state_button_color[content->app_state]);\n                UG_ButtonSetForeColor(&window_1, BTN_ID_2, display_app_state_button_font_color[content->app_state]);\n                UG_ButtonSetText(&window_1, BTN_ID_2, display_string_app_state[content->app_state]);\n\n                if(content->app_state == APP_STATE_CONNECTED)\n                {\n                        UG_TextboxShow(&window_1, TXB_ID_4);\n                        UG_TextboxShow(&window_1, TXB_ID_7);\n                        UG_TextboxShow(&window_1, TXB_ID_12);\n                        UG_TextboxShow(&window_1, TXB_ID_13); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                        {\n                                UG_TextboxSetBackColor(&window_1, TXB_ID_4, RGB_888_TO_565(0x0ADD00));\n                                UG_TextboxSetBackColor(&window_1, TXB_ID_7, RGB_888_TO_565(0x0ADD00));\n\n                                UG_TextboxSetBackColor(&window_1, TXB_ID_12, RGB_888_TO_565(0x0ADD00));\n                                UG_TextboxSetBackColor(&window_1, TXB_ID_13, RGB_888_TO_565(0x0ADD00));\n                        }\n                }\n                else\n                {\n                        UG_TextboxHide(&window_1, TXB_ID_3);\n                        UG_TextboxHide(&window_1, TXB_ID_6);\n                        UG_TextboxHide(&window_1, TXB_ID_4);\n                        UG_TextboxHide(&window_1, TXB_ID_5);\n                        UG_TextboxHide(&window_1, TXB_ID_7);\n                        UG_TextboxHide(&window_1, TXB_ID_8);\n\n                        UG_TextboxHide(&window_1, TXB_ID_12);\n                        UG_TextboxHide(&window_1, TXB_ID_13);\n                }\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n        static int rx_sensitivity[] = {-103, -95, -92};\n        static uint32_t link_budget_colors[] = {0xEF0000, 0xfe6c00, 0xfdc700, 0xe2e500, 0xc6f700, 0x5ee900, 0x0ADD00};\n        static int link_budget, link_color;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        {\n                if(first_update || content->rssi[0] != content_previous.rssi[0])\n                {\n                        link_budget = (int)content->rssi[0] - rx_sensitivity[content->phy];\n                        \n                        link_color = RGB_888_TO_565(link_budget < 35 ? link_budget_colors[link_budget \/ 5] : 0x0ADD00);\n\n#ifdef RSSI\n                        sprintf(sprintf_buf, \"%i dBm\", (int)content->rssi[0]);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_4, link_color);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_7, link_color);\n                        UG_TextboxSetText(&window_1, TXB_ID_7, content->rssi[0] != 0 ? sprintf_buf : \"-\");\n#else\n                        sprintf(sprintf_buf, \"%i kbps\", (int)content->throughput_kbps);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_4, link_color);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_7, link_color);\n                        UG_TextboxSetText(&window_1, TXB_ID_7, sprintf_buf);\n\n#endif\n                        sprintf(sprintf_psr, \"%3d% %\", (int)content->psr);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_12, link_color);\n                        UG_TextboxSetBackColor(&window_1, TXB_ID_13, link_color);\n                        UG_TextboxSetText(&window_1, TXB_ID_13, sprintf_psr);\n\n                }\n        }\n        first_update = false;\n        content_previous = *content;\n}\n\nvoid app_display_update(void)\n{\n        UG_Update();\n}\n"}
{"target":"jimmywong2003","func":"\n#include \"sdk_common.h\"\n#if NRF_MODULE_ENABLED(BLE_LBS_C)\n\n#include \"ble_lbs_c_extended.h\"\n#include \"ble_db_discovery.h\"\n#include \"ble_types.h\"\n#include \"ble_srv_common.h\"\n#include \"ble_gattc.h\"\n#define NRF_LOG_MODULE_NAME ble_lbs_c\n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n#define TX_BUFFER_MASK         0x07                  \n#define TX_BUFFER_SIZE         (TX_BUFFER_MASK + 1)  \n\n#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    \n#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    \n\ntypedef enum\n{\n    READ_REQ,  \n    WRITE_REQ  \n} tx_request_t;\n\n\ntypedef struct\n{\n    uint8_t                  gattc_value[WRITE_MESSAGE_LENGTH];  \n    ble_gattc_write_params_t gattc_params;                       \n} write_params_t;\n\n\ntypedef struct\n{\n    uint16_t     conn_handle;  \n    tx_request_t type;         \n    union\n    {\n        uint16_t       read_handle;  \n        write_params_t write_req;    \n    } req;\n} tx_message_t;\n\n\nstatic tx_message_t m_tx_buffer[TX_BUFFER_SIZE];  \nstatic uint32_t     m_tx_insert_index = 0;        \nstatic uint32_t     m_tx_index = 0;               \n\n\n\nstatic void tx_buffer_process(void)\n{\n    if (m_tx_index != m_tx_insert_index)\n    {\n        uint32_t err_code;\n\n        if (m_tx_buffer[m_tx_index].type == READ_REQ)\n        {\n            err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,\n                                         m_tx_buffer[m_tx_index].req.read_handle,\n                                         0);\n        }\n        else\n        {\n            err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,\n                                          &m_tx_buffer[m_tx_index].req.write_req.gattc_params);\n        }\n        if (err_code == NRF_SUCCESS)\n        {\n            NRF_LOG_DEBUG(\"SD Read\/Write API returns Success..\");\n            m_tx_index++;\n            m_tx_index &= TX_BUFFER_MASK;\n        }\n        else\n        {\n            NRF_LOG_DEBUG(\"SD Read\/Write API returns error. This message sending will be \"\n                \"attempted again..\");\n        }\n    }\n}\n\n\n\nstatic void on_write_rsp(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)\n{\n    \n    if (p_ble_lbs_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n    {\n        return;\n    }\n    \n    tx_buffer_process();\n}\n\n\n\nstatic void on_hvx(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)\n{\n    \n    if (p_ble_lbs_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n    {\n        return;\n    }\n    \n    if (p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_lbs_c->peer_lbs_db.button_handle)\n    {\n        if (p_ble_evt->evt.gattc_evt.params.hvx.len == 1)\n        {\n            ble_lbs_c_evt_t ble_lbs_c_evt;\n\n            ble_lbs_c_evt.evt_type                   = BLE_LBS_C_EVT_BUTTON_NOTIFICATION;\n            ble_lbs_c_evt.conn_handle                = p_ble_lbs_c->conn_handle;\n            ble_lbs_c_evt.params.button.button_state = p_ble_evt->evt.gattc_evt.params.hvx.data[0];\n            p_ble_lbs_c->evt_handler(p_ble_lbs_c, &ble_lbs_c_evt);\n        }\n    }\n}\n\n\n\nstatic void on_disconnected(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)\n{\n    if (p_ble_lbs_c->conn_handle == p_ble_evt->evt.gap_evt.conn_handle)\n    {\n        p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;\n    }\n}\n\n\nvoid ble_lbs_on_db_disc_evt(ble_lbs_c_t * p_ble_lbs_c, ble_db_discovery_evt_t const * p_evt)\n{\n    \n    if (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE &&\n        p_evt->params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE &&\n        p_evt->params.discovered_db.srv_uuid.type == p_ble_lbs_c->uuid_type)\n    {\n        ble_lbs_c_evt_t evt;\n\n        evt.evt_type    = BLE_LBS_C_EVT_DISCOVERY_COMPLETE;\n        evt.conn_handle = p_evt->conn_handle;\n\n        for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n        {\n            const ble_gatt_db_char_t * p_char = &(p_evt->params.discovered_db.charateristics[i]);\n            switch (p_char->characteristic.uuid.uuid)\n            {\n                case LBS_UUID_LED_CHAR:\n                    evt.params.peer_db.led_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_LED_COL_CHAR:\n                    evt.params.peer_db.led_color_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_BUTTON_CHAR:\n                    evt.params.peer_db.button_handle      = p_char->characteristic.handle_value;\n                    evt.params.peer_db.button_cccd_handle = p_char->cccd_handle;\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        NRF_LOG_DEBUG(\"Led Button Service discovered at peer.\");\n        \n        if (p_ble_lbs_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n        {\n            if ((p_ble_lbs_c->peer_lbs_db.led_handle         == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.led_color_handle   == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_handle      == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID))\n            {\n                p_ble_lbs_c->peer_lbs_db = evt.params.peer_db;\n            }\n        }\n\n        p_ble_lbs_c->evt_handler(p_ble_lbs_c, &evt);\n\n    }\n}\n\n\nuint32_t ble_lbs_c_init(ble_lbs_c_t * p_ble_lbs_c, ble_lbs_c_init_t * p_ble_lbs_c_init)\n{\n    uint32_t      err_code;\n    ble_uuid_t    lbs_uuid;\n    ble_uuid128_t lbs_base_uuid = {LBS_UUID_BASE};\n\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init);\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init->evt_handler);\n\n    p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;\n    p_ble_lbs_c->evt_handler                    = p_ble_lbs_c_init->evt_handler;\n\n    err_code = sd_ble_uuid_vs_add(&lbs_base_uuid, &p_ble_lbs_c->uuid_type);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    VERIFY_SUCCESS(err_code);\n\n    lbs_uuid.type = p_ble_lbs_c->uuid_type;\n    lbs_uuid.uuid = LBS_UUID_SERVICE;\n\n    return ble_db_discovery_evt_register(&lbs_uuid);\n}\n\nvoid ble_lbs_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    if ((p_context == NULL) || (p_ble_evt == NULL))\n    {\n        return;\n    }\n\n    ble_lbs_c_t * p_ble_lbs_c = (ble_lbs_c_t *)p_context;\n\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GATTC_EVT_HVX:\n            on_hvx(p_ble_lbs_c, p_ble_evt);\n            break;\n\n        case BLE_GATTC_EVT_WRITE_RSP:\n            on_write_rsp(p_ble_lbs_c, p_ble_evt);\n            break;\n\n        case BLE_GAP_EVT_DISCONNECTED:\n            on_disconnected(p_ble_lbs_c, p_ble_evt);\n            break;\n\n        default:\n            break;\n    }\n}\n\n\n\nstatic uint32_t cccd_configure(uint16_t conn_handle, uint16_t handle_cccd, bool enable)\n{\n    NRF_LOG_DEBUG(\"Configuring CCCD. CCCD Handle = %d, Connection Handle = %d\",\n        handle_cccd,conn_handle);\n\n    tx_message_t * p_msg;\n    uint16_t       cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;\n\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n\n    p_msg->req.write_req.gattc_params.handle   = handle_cccd;\n    p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;\n    p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);\n    p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);\n    p_msg->conn_handle                         = conn_handle;\n    p_msg->type                                = WRITE_REQ;\n\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}\n\n\nuint32_t ble_lbs_c_button_notif_enable(ble_lbs_c_t * p_ble_lbs_c)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    return cccd_configure(p_ble_lbs_c->conn_handle,\n                          p_ble_lbs_c->peer_lbs_db.button_cccd_handle,\n                          true);\n}\n\n\nuint32_t ble_lbs_led_status_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t status)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    NRF_LOG_DEBUG(\"writing LED status 0x%x\", status);\n\n    tx_message_t * p_msg;\n\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n\n    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_handle;\n    p_msg->req.write_req.gattc_params.len      = sizeof(status);\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;\n    p_msg->req.write_req.gattc_value[0]        = status;\n    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;\n    p_msg->type                                = WRITE_REQ;\n\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}\n\n\nuint32_t ble_lbs_led_color_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t *colors)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    if (p_ble_lbs_c->peer_lbs_db.led_color_handle == BLE_GATT_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    NRF_LOG_INFO(\"writing LED color %i, %i, %i\", colors[0], colors[1], colors[2]);\n\n    tx_message_t * p_msg;\n\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n\n    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_color_handle;\n    p_msg->req.write_req.gattc_params.len      = 4;\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;\n    memcpy(p_msg->req.write_req.gattc_value, colors, 3);\n    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;\n    p_msg->type                                = WRITE_REQ;\n\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}\n\n\nuint32_t ble_lbs_c_handles_assign(ble_lbs_c_t    * p_ble_lbs_c,\n                                  uint16_t         conn_handle,\n                                  const lbs_db_t * p_peer_handles)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n\n    p_ble_lbs_c->conn_handle = conn_handle;\n    if (p_peer_handles != NULL)\n    {\n        p_ble_lbs_c->peer_lbs_db = *p_peer_handles;\n    }\n    return NRF_SUCCESS;\n}\n\n#endif \n"}
{"target":"jimmywong2003","func":"\n#include \"sdk_common.h\"\n#if NRF_MODULE_ENABLED(BLE_LBS)\n#include \"ble_lbs_extended.h\"\n#include \"ble_srv_common.h\"\n\n\n\nstatic void on_write(ble_lbs_t * p_lbs, ble_evt_t const * p_ble_evt)\n{\n    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;\n\n    if ((p_evt_write->handle == p_lbs->led_char_handles.value_handle)\n        && (p_evt_write->len == 1)\n        && (p_lbs->led_write_handler != NULL))\n    {\n        p_lbs->led_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, p_evt_write->data[0]);\n    }\n    else if ((p_evt_write->handle == p_lbs->led_col_char_handles.value_handle)\n        && (p_evt_write->len == 4)\n        && (p_lbs->led_col_write_handler != NULL))\n    {\n        uint32_t color = p_evt_write->data[0] << 16 | p_evt_write->data[1] << 8 | p_evt_write->data[2] << 0;\n        p_lbs->led_col_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, color);\n    }\n}\n\n\nvoid ble_lbs_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    ble_lbs_t * p_lbs = (ble_lbs_t *)p_context;\n\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GATTS_EVT_WRITE:\n            on_write(p_lbs, p_ble_evt);\n            break;\n\n        default:\n            \n            break;\n    }\n}\n\n\nuint32_t ble_lbs_init(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)\n{\n    uint32_t              err_code;\n    ble_uuid_t            ble_uuid;\n    ble_add_char_params_t add_char_params;\n\n    \n    p_lbs->led_write_handler = p_lbs_init->led_write_handler;\n    p_lbs->led_col_write_handler = p_lbs_init->led_col_write_handler;\n\n    \n    ble_uuid128_t base_uuid = {LBS_UUID_BASE};\n    err_code = sd_ble_uuid_vs_add(&base_uuid, &p_lbs->uuid_type);\n    VERIFY_SUCCESS(err_code);\n\n    ble_uuid.type = p_lbs->uuid_type;\n    ble_uuid.uuid = LBS_UUID_SERVICE;\n\n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lbs->service_handle);\n    VERIFY_SUCCESS(err_code);\n\n    \n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = LBS_UUID_BUTTON_CHAR;\n    add_char_params.uuid_type         = p_lbs->uuid_type;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.max_len           = sizeof(uint8_t);\n    add_char_params.char_props.read   = 1;\n    add_char_params.char_props.notify = 1;\n\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n\n    err_code = characteristic_add(p_lbs->service_handle,\n                                  &add_char_params,\n                                  &p_lbs->button_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n\n    \n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint8_t);\n    add_char_params.max_len          = sizeof(uint8_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n\n    \n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_COL_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint32_t);\n    add_char_params.max_len          = sizeof(uint32_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_col_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n}\n\n\nuint32_t ble_lbs_on_button_change(uint16_t conn_handle, ble_lbs_t * p_lbs, uint8_t button_state)\n{\n    ble_gatts_hvx_params_t params;\n    uint16_t len = sizeof(button_state);\n\n    memset(&params, 0, sizeof(params));\n    params.type   = BLE_GATT_HVX_NOTIFICATION;\n    params.handle = p_lbs->button_char_handles.value_handle;\n    params.p_data = &button_state;\n    params.p_len  = &len;\n\n    return sd_ble_gatts_hvx(conn_handle, &params);\n}\n#endif \n"}
{"target":"jimmywong2003","func":"\n#include \"sdk_common.h\"\n#if NRF_MODULE_ENABLED(BLE_NUS)\n#include \"ble.h\"\n#include \"ble_nus.h\"\n#include \"ble_srv_common.h\"\n\n#define NRF_LOG_MODULE_NAME ble_nus\n#if BLE_NUS_CONFIG_LOG_ENABLED\n#define NRF_LOG_LEVEL       BLE_NUS_CONFIG_LOG_LEVEL\n#define NRF_LOG_INFO_COLOR  BLE_NUS_CONFIG_INFO_COLOR\n#define NRF_LOG_DEBUG_COLOR BLE_NUS_CONFIG_DEBUG_COLOR\n#else \n#define NRF_LOG_LEVEL       0\n#endif \n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n#define BLE_UUID_NUS_TX_CHARACTERISTIC 0x0003               \n#define BLE_UUID_NUS_RX_CHARACTERISTIC 0x0002               \n\n#define BLE_NUS_MAX_RX_CHAR_LEN        BLE_NUS_MAX_DATA_LEN \n#define BLE_NUS_MAX_TX_CHAR_LEN        BLE_NUS_MAX_DATA_LEN \n\n#define NUS_BASE_UUID                  {{0x9E, 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9, 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00, 0x00, 0x40, 0x6E}} \n\n\n\nstatic void on_connect(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                 err_code;\n    ble_nus_evt_t              evt;\n    ble_gatts_value_t          gatts_val;\n    uint8_t                    cccd_value[2];\n    ble_nus_client_context_t * p_client = NULL;\n\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gap_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gap_evt.conn_handle);\n    }\n\n    \n    memset(&gatts_val, 0, sizeof(ble_gatts_value_t));\n    gatts_val.p_value = cccd_value;\n    gatts_val.len     = sizeof(cccd_value);\n    gatts_val.offset  = 0;\n\n    err_code = sd_ble_gatts_value_get(p_ble_evt->evt.gap_evt.conn_handle,\n                                      p_nus->rx_handles.cccd_handle,\n                                      &gatts_val);\n\n    if ((err_code == NRF_SUCCESS)     &&\n        (p_nus->data_handler != NULL) &&\n        ble_srv_is_notification_enabled(gatts_val.p_value))\n    {\n        if (p_client != NULL)\n        {\n            p_client->is_notification_enabled = true;\n        }\n\n        memset(&evt, 0, sizeof(ble_nus_evt_t));\n        evt.type        = BLE_NUS_EVT_COMM_STARTED;\n        evt.p_nus       = p_nus;\n        evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\n        evt.p_link_ctx  = p_client;\n\n        p_nus->data_handler(&evt);\n    }\n}\n\n\n\nstatic void on_write(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                    err_code;\n    ble_nus_evt_t                 evt;\n    ble_nus_client_context_t    * p_client;\n    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;\n\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gatts_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gatts_evt.conn_handle);\n    }\n\n    memset(&evt, 0, sizeof(ble_nus_evt_t));\n    evt.p_nus       = p_nus;\n    evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;\n    evt.p_link_ctx  = p_client;\n\n    if ((p_evt_write->handle == p_nus->tx_handles.cccd_handle) &&\n        (p_evt_write->len == 2))\n    {\n        if (p_client != NULL)\n        {\n            if (ble_srv_is_notification_enabled(p_evt_write->data))\n            {\n                p_client->is_notification_enabled = true;\n                evt.type                          = BLE_NUS_EVT_COMM_STARTED;\n            }\n            else\n            {\n                p_client->is_notification_enabled = false;\n                evt.type                          = BLE_NUS_EVT_COMM_STOPPED;\n            }\n\n            if (p_nus->data_handler != NULL)\n            {\n                p_nus->data_handler(&evt);\n            }\n\n        }\n    }\n    else if ((p_evt_write->handle == p_nus->rx_handles.value_handle) &&\n             (p_nus->data_handler != NULL))\n    {\n        evt.type                  = BLE_NUS_EVT_RX_DATA;\n        evt.params.rx_data.p_data = p_evt_write->data;\n        evt.params.rx_data.length = p_evt_write->len;\n\n        p_nus->data_handler(&evt);\n    }\n    else\n    {\n        \n    }\n}\n\n\n\nstatic void on_hvx_tx_complete(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                 err_code;\n    ble_nus_evt_t              evt;\n    ble_nus_client_context_t * p_client;\n\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gatts_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gatts_evt.conn_handle);\n        return;\n    }\n\n    if (p_client->is_notification_enabled)\n    {\n        memset(&evt, 0, sizeof(ble_nus_evt_t));\n        evt.type        = BLE_NUS_EVT_TX_RDY;\n        evt.p_nus       = p_nus;\n        evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;\n        evt.p_link_ctx  = p_client;\n\n        p_nus->data_handler(&evt);\n    }\n}\n\n\nvoid ble_nus_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    if ((p_context == NULL) || (p_ble_evt == NULL))\n    {\n        return;\n    }\n\n    ble_nus_t * p_nus = (ble_nus_t *)p_context;\n\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GAP_EVT_CONNECTED:\n            on_connect(p_nus, p_ble_evt);\n            break;\n\n        case BLE_GATTS_EVT_WRITE:\n            on_write(p_nus, p_ble_evt);\n            break;\n\n        case BLE_GATTS_EVT_HVN_TX_COMPLETE:\n            on_hvx_tx_complete(p_nus, p_ble_evt);\n            break;\n\n        default:\n            \n            break;\n    }\n}\n\n\nuint32_t ble_nus_init(ble_nus_t * p_nus, ble_nus_init_t const * p_nus_init)\n{\n    ret_code_t            err_code;\n    ble_uuid_t            ble_uuid;\n    ble_uuid128_t         nus_base_uuid = NUS_BASE_UUID;\n    ble_add_char_params_t add_char_params;\n\n    VERIFY_PARAM_NOT_NULL(p_nus);\n    VERIFY_PARAM_NOT_NULL(p_nus_init);\n\n    \n    p_nus->data_handler = p_nus_init->data_handler;\n\n    \n    \n    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);\n    VERIFY_SUCCESS(err_code);\n\n    ble_uuid.type = p_nus->uuid_type;\n    ble_uuid.uuid = BLE_UUID_NUS_SERVICE;\n\n    \n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,\n                                        &ble_uuid,\n                                        &p_nus->service_handle);\n    \n    VERIFY_SUCCESS(err_code);\n\n    \n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid                     = BLE_UUID_NUS_RX_CHARACTERISTIC;\n    add_char_params.uuid_type                = p_nus->uuid_type;\n    add_char_params.max_len                  = BLE_NUS_MAX_RX_CHAR_LEN;\n    add_char_params.init_len                 = sizeof(uint8_t);\n    add_char_params.is_var_len               = true;\n    add_char_params.char_props.write         = 1;\n    add_char_params.char_props.write_wo_resp = 1;\n\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n\n    err_code = characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->rx_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n\n    \n    \n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = BLE_UUID_NUS_TX_CHARACTERISTIC;\n    add_char_params.uuid_type         = p_nus->uuid_type;\n    add_char_params.max_len           = BLE_NUS_MAX_TX_CHAR_LEN;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.is_var_len        = true;\n    add_char_params.char_props.notify = 1;\n\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.write_access      = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n\n    return characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->tx_handles);\n    \n}\n\n\nuint32_t ble_nus_data_send(ble_nus_t * p_nus,\n                           uint8_t   * p_data,\n                           uint16_t  * p_length,\n                           uint16_t    conn_handle)\n{\n    ret_code_t                 err_code;\n    ble_gatts_hvx_params_t     hvx_params;\n    ble_nus_client_context_t * p_client;\n\n    VERIFY_PARAM_NOT_NULL(p_nus);\n\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage, conn_handle, (void *) &p_client);\n    VERIFY_SUCCESS(err_code);\n\n    if ((conn_handle == BLE_CONN_HANDLE_INVALID) || (p_client == NULL))\n    {\n        return NRF_ERROR_NOT_FOUND;\n    }\n\n    if (!p_client->is_notification_enabled)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n\n    if (*p_length > BLE_NUS_MAX_DATA_LEN)\n    {\n        return NRF_ERROR_INVALID_PARAM;\n    }\n\n    memset(&hvx_params, 0, sizeof(hvx_params));\n\n    hvx_params.handle = p_nus->tx_handles.value_handle;\n    hvx_params.p_data = p_data;\n    hvx_params.p_len  = p_length;\n    hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\n\n    return sd_ble_gatts_hvx(conn_handle, &hvx_params);\n}\n\n\n#endif \n"}
{"target":"jimmywong2003","func":"\n\n#include \"sdk_common.h\"\n#if NRF_MODULE_ENABLED(BLE_NUS_C)\n#include <stdlib.h>\n\n#include \"ble.h\"\n#include \"ble_nus_c.h\"\n#include \"ble_gattc.h\"\n#include \"ble_srv_common.h\"\n#include \"app_error.h\"\n\n#define NRF_LOG_MODULE_NAME ble_nus_c\n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n#define TX_BUFFER_MASK         0x07                  \n#define TX_BUFFER_SIZE         (TX_BUFFER_MASK + 1)  \n\n#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    \n#define WRITE_MESSAGE_LENGTH   BLE_CCCD_VALUE_LEN    \n\ntypedef enum\n{\n        READ_REQ, \n        WRITE_REQ \n} tx_request_t;\n\n\ntypedef struct\n{\n        uint8_t gattc_value[WRITE_MESSAGE_LENGTH];               \n        ble_gattc_write_params_t gattc_params;                   \n} write_params_t;\n\n\ntypedef struct\n{\n        uint16_t conn_handle;  \n        tx_request_t type;     \n        union\n        {\n                uint16_t read_handle; \n                write_params_t write_req; \n        } req;\n} tx_message_t;\n\nstatic tx_message_t m_tx_buffer[TX_BUFFER_SIZE];  \nstatic uint32_t m_tx_insert_index = 0;            \nstatic uint32_t m_tx_index = 0;                   \n\n\nstatic void tx_buffer_process(void)\n{\n        if (m_tx_index != m_tx_insert_index)\n        {\n                uint32_t err_code;\n\n                if (m_tx_buffer[m_tx_index].type == READ_REQ)\n                {\n                        err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,\n                                                     m_tx_buffer[m_tx_index].req.read_handle,\n                                                     0);\n                }\n                else\n                {\n                        err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,\n                                                      &m_tx_buffer[m_tx_index].req.write_req.gattc_params);\n                }\n                if (err_code == NRF_SUCCESS)\n                {\n                        NRF_LOG_DEBUG(\"SD Read\/Write API returns Success..\");\n                        m_tx_index++;\n                        m_tx_index &= TX_BUFFER_MASK;\n                }\n                else\n                {\n                        NRF_LOG_DEBUG(\"SD Read\/Write API returns error. This message sending will be \"\n                                      \"attempted again..\");\n                }\n        }\n}\n\n\nvoid ble_nus_c_on_db_disc_evt(ble_nus_c_t * p_ble_nus_c, ble_db_discovery_evt_t * p_evt)\n{\n        ble_nus_c_evt_t nus_c_evt;\n        memset(&nus_c_evt,0,sizeof(ble_nus_c_evt_t));\n\n        ble_gatt_db_char_t * p_chars = p_evt->params.discovered_db.charateristics;\n\n        \n        if (    (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE)\n                &&  (p_evt->params.discovered_db.srv_uuid.uuid == BLE_UUID_NUS_SERVICE)\n                &&  (p_evt->params.discovered_db.srv_uuid.type == p_ble_nus_c->uuid_type))\n        {\n                for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n                {\n                        switch (p_chars[i].characteristic.uuid.uuid)\n                        {\n                        case BLE_UUID_NUS_RX_CHARACTERISTIC:\n                                nus_c_evt.handles.nus_rx_handle = p_chars[i].characteristic.handle_value;\n                                break;\n\n                        case BLE_UUID_NUS_TX_CHARACTERISTIC:\n                                nus_c_evt.handles.nus_tx_handle = p_chars[i].characteristic.handle_value;\n                                nus_c_evt.handles.nus_tx_cccd_handle = p_chars[i].cccd_handle;\n                                break;\n\n                        default:\n                                break;\n                        }\n                }\n                NRF_LOG_DEBUG(\"NUS Service discovered at peer.\");\n                if (p_ble_nus_c->evt_handler != NULL)\n                {\n                        if (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n                        {\n                                nus_c_evt.conn_handle = p_evt->conn_handle;\n                                nus_c_evt.evt_type    = BLE_NUS_C_EVT_DISCOVERY_COMPLETE;\n                                p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);\n                        }\n                }\n        }\n}\n\n\nstatic void on_write_rsp(ble_nus_c_t * p_ble_nus_c, ble_evt_t const * p_ble_evt)\n{\n        \n        if (p_ble_nus_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n        {\n                return;\n        }\n        \n        tx_buffer_process();\n}\n\n\n\n\nstatic void on_hvx(ble_nus_c_t * p_ble_nus_c, ble_evt_t const * p_ble_evt)\n{\n        \n        if (p_ble_nus_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n        {\n                return;\n        }\n        \n        if ((p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_nus_c->handles.nus_tx_handle) \\\n            && (p_ble_nus_c->evt_handler != NULL))\n        {\n                \n                {\n                        ble_nus_c_evt_t ble_nus_c_evt;\n\n                        ble_nus_c_evt.evt_type                   = BLE_NUS_C_EVT_NUS_TX_EVT;\n                        ble_nus_c_evt.conn_handle                = p_ble_nus_c->conn_handle;\n                        ble_nus_c_evt.p_data   = (uint8_t *)p_ble_evt->evt.gattc_evt.params.hvx.data;\n                        ble_nus_c_evt.data_len = p_ble_evt->evt.gattc_evt.params.hvx.len;\n\n                        p_ble_nus_c->evt_handler(p_ble_nus_c, &ble_nus_c_evt);\n                        NRF_LOG_DEBUG(\"Client sending data.\");\n                }\n        }\n}\n\nuint32_t ble_nus_c_init(ble_nus_c_t * p_ble_nus_c, ble_nus_c_init_t * p_ble_nus_c_init)\n{\n        uint32_t err_code;\n        ble_uuid_t uart_uuid;\n        ble_uuid128_t nus_base_uuid = NUS_BASE_UUID;\n\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c_init);\n\n        p_ble_nus_c->conn_handle           = BLE_CONN_HANDLE_INVALID;\n        p_ble_nus_c->handles.nus_tx_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_nus_c->handles.nus_rx_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_nus_c->evt_handler           = p_ble_nus_c_init->evt_handler;\n\n        err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_ble_nus_c->uuid_type);\n        VERIFY_SUCCESS(err_code);\n\n        uart_uuid.type = p_ble_nus_c->uuid_type;\n        uart_uuid.uuid = BLE_UUID_NUS_SERVICE;\n\n        return ble_db_discovery_evt_register(&uart_uuid);\n}\n\nvoid ble_nus_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n        ble_nus_c_t * p_ble_nus_c = (ble_nus_c_t *)p_context;\n\n        if ((p_ble_nus_c == NULL) || (p_ble_evt == NULL))\n        {\n                return;\n        }\n\n        if ( (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n             &&(p_ble_nus_c->conn_handle != p_ble_evt->evt.gap_evt.conn_handle)\n             )\n        {\n                return;\n        }\n\n        switch (p_ble_evt->header.evt_id)\n        {\n        case BLE_GATTC_EVT_HVX:\n                on_hvx(p_ble_nus_c, p_ble_evt);\n                break;\n\n        case BLE_GATTC_EVT_WRITE_RSP:\n                on_write_rsp(p_ble_nus_c, p_ble_evt);\n                break;\n\n        case BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE:\n\n                break;\n\n        case BLE_GAP_EVT_DISCONNECTED:\n                if (p_ble_evt->evt.gap_evt.conn_handle == p_ble_nus_c->conn_handle\n                    && p_ble_nus_c->evt_handler != NULL)\n                {\n                        ble_nus_c_evt_t nus_c_evt;\n\n                        nus_c_evt.evt_type = BLE_NUS_C_EVT_DISCONNECTED;\n                        nus_c_evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\n\n                        p_ble_nus_c->conn_handle = BLE_CONN_HANDLE_INVALID;\n                        p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);\n                }\n                break;\n\n        default:\n                \n                break;\n        }\n}\n\n\nstatic uint32_t cccd_configure(uint16_t conn_handle, uint16_t cccd_handle, bool enable)\n{\n        NRF_LOG_DEBUG(\"Configuring CCCD. CCCD Handle = %d, Connection Handle = %d\",\n                      cccd_handle,conn_handle);\n\n        tx_message_t * p_msg;\n        uint16_t cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;\n\n        p_msg              = &m_tx_buffer[m_tx_insert_index++];\n        m_tx_insert_index &= TX_BUFFER_MASK;\n\n        p_msg->req.write_req.gattc_params.handle   = cccd_handle;\n        p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;\n        p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n        p_msg->req.write_req.gattc_params.offset   = 0;\n        p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;\n        p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);\n        p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);\n        p_msg->conn_handle                         = conn_handle;\n        p_msg->type                                = WRITE_REQ;\n\n        tx_buffer_process();\n        return NRF_SUCCESS;\n}\n\n\nuint32_t ble_nus_c_tx_notif_enable(ble_nus_c_t * p_ble_nus_c)\n{\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);\n\n        if ( (p_ble_nus_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n             ||(p_ble_nus_c->handles.nus_tx_cccd_handle == BLE_GATT_HANDLE_INVALID)\n             )\n        {\n                return NRF_ERROR_INVALID_STATE;\n        }\n        return cccd_configure(p_ble_nus_c->conn_handle,p_ble_nus_c->handles.nus_tx_cccd_handle, true);\n}\n\n\nuint32_t ble_nus_c_string_send(ble_nus_c_t * p_ble_nus_c, uint8_t * p_string, uint16_t length)\n{\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);\n\n        if (length > BLE_NUS_MAX_DATA_LEN)\n        {\n                NRF_LOG_WARNING(\"Content too long.\");\n                return NRF_ERROR_INVALID_PARAM;\n        }\n        if (p_ble_nus_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n        {\n                NRF_LOG_WARNING(\"Connection handle invalid.\");\n                return NRF_ERROR_INVALID_STATE;\n        }\n\n        ble_gattc_write_params_t const write_params =\n        {\n                .write_op = BLE_GATT_OP_WRITE_CMD,\n                .flags    = BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE,\n                .handle   = p_ble_nus_c->handles.nus_rx_handle,\n                .offset   = 0,\n                .len      = length,\n                .p_value  = p_string\n        };\n\n        return sd_ble_gattc_write(p_ble_nus_c->conn_handle, &write_params);\n}\n\n\nuint32_t ble_nus_c_handles_assign(ble_nus_c_t               * p_ble_nus,\n                                  uint16_t conn_handle,\n                                  ble_nus_c_handles_t const * p_peer_handles)\n{\n        VERIFY_PARAM_NOT_NULL(p_ble_nus);\n\n        p_ble_nus->conn_handle = conn_handle;\n        if (p_peer_handles != NULL)\n        {\n                p_ble_nus->handles.nus_tx_cccd_handle = p_peer_handles->nus_tx_cccd_handle;\n                p_ble_nus->handles.nus_tx_handle      = p_peer_handles->nus_tx_handle;\n                p_ble_nus->handles.nus_rx_handle      = p_peer_handles->nus_rx_handle;\n        }\n        return NRF_SUCCESS;\n}\n#endif \n"}
{"target":"jimmywong2003","func":"#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include \"nordic_common.h\"\n#include \"app_error.h\"\n#include \"app_util.h\"\n#include \"bsp_btn_ble.h\"\n#include \"ble.h\"\n#include \"ble_gap.h\"\n#include \"ble_hci.h\"\n#include \"nrf_sdh.h\"\n#include \"nrf_sdh_ble.h\"\n#include \"nrf_sdh_soc.h\"\n\n#include \"nrf_ble_gatt.h\"\n#include \"app_scheduler.h\"\n\n#include \"nrf_log_ctrl.h\"\n#include \"nrf_log.h\"\n#include \"nrf_log_default_backends.h\"\n\n#define BLE_GAP_QOS_CHANNEL_SURVERY_INTERVAL      0\n#define NUM_REPORTS_BEFORE_AVERAGE_PRINTOUT       100\n\n#define ADVERTISING_CHANNEL_37      37\n#define ADVERTISING_CHANNEL_38      38\n#define ADVERTISING_CHANNEL_39      39\n\ntypedef struct\n{\n        uint8_t index;\n        bool channel_enable;\n        float ch_energy;\n} channel_energy_t;\n\nstatic uint32_t m_num_channel_survey_reports_received;\nstatic channel_energy_t ch_config_energy[BLE_GAP_CHANNEL_COUNT];\nstatic channel_energy_t m_average_ch_energy[BLE_GAP_CHANNEL_COUNT];\nstatic bool update_channel_survey_status = false;\n\nbool get_channel_map_status(void)\n{\n        return update_channel_survey_status;\n}\n\nuint32_t connection_channel_survey_start(void)\n{\n        ret_code_t err_code = sd_ble_gap_qos_channel_survey_start(BLE_GAP_QOS_CHANNEL_SURVERY_INTERVAL);\n        APP_ERROR_CHECK(err_code);\n        return err_code;\n}\n\nuint32_t connection_channel_survey_stop(void)\n{\n        ret_code_t err_code = sd_ble_gap_qos_channel_survey_stop();\n        APP_ERROR_CHECK(err_code);\n        return err_code;\n}\n\nstatic void sort_channel_survey(void)\n{\n        int n, c, d;\n        float t;\n        uint8_t index = 0;\n        n = BLE_GAP_CHANNEL_COUNT;\n        for (c = 1; c <= n - 1; c++)\n        {\n                d = c;\n                while ( d > 0 && m_average_ch_energy[d-1].ch_energy > m_average_ch_energy[d].ch_energy)\n                {\n                        t          = m_average_ch_energy[d].ch_energy;\n                        index      = m_average_ch_energy[d].index;\n                        m_average_ch_energy[d].ch_energy   = m_average_ch_energy[d-1].ch_energy;\n                        m_average_ch_energy[d].index       = m_average_ch_energy[d-1].index;\n                        m_average_ch_energy[d-1].ch_energy = t;\n                        m_average_ch_energy[d-1].index     = index;\n                        d--;\n                }\n        }\n        return;\n}\n\nvoid update_and_sort_channel_survey_handler(void * p_event_data, uint16_t size)\n{\n        NRF_LOG_INFO(\"Channel energy report:\\n--------------\\n\");\n        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                int8_t channel_energy = m_average_ch_energy[i].ch_energy;\n                m_average_ch_energy[i].index = i;\n        }\n        NRF_LOG_DEBUG(\"00-04: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[0].ch_energy, \\\n                      (int8_t)m_average_ch_energy[1].ch_energy, \\\n                      (int8_t)m_average_ch_energy[2].ch_energy, \\\n                      (int8_t)m_average_ch_energy[3].ch_energy, \\\n                      (int8_t)m_average_ch_energy[4].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"05-09: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[5].ch_energy, \\\n                      (int8_t)m_average_ch_energy[6].ch_energy, \\\n                      (int8_t)m_average_ch_energy[7].ch_energy, \\\n                      (int8_t)m_average_ch_energy[8].ch_energy, \\\n                      (int8_t)m_average_ch_energy[9].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"10-14: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[10].ch_energy, \\\n                      (int8_t)m_average_ch_energy[11].ch_energy, \\\n                      (int8_t)m_average_ch_energy[12].ch_energy, \\\n                      (int8_t)m_average_ch_energy[13].ch_energy, \\\n                      (int8_t)m_average_ch_energy[14].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"15-19: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[15].ch_energy, \\\n                      (int8_t)m_average_ch_energy[16].ch_energy, \\\n                      (int8_t)m_average_ch_energy[17].ch_energy, \\\n                      (int8_t)m_average_ch_energy[18].ch_energy, \\\n                      (int8_t)m_average_ch_energy[19].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"20-24: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[20].ch_energy, \\\n                      (int8_t)m_average_ch_energy[21].ch_energy, \\\n                      (int8_t)m_average_ch_energy[22].ch_energy, \\\n                      (int8_t)m_average_ch_energy[23].ch_energy, \\\n                      (int8_t)m_average_ch_energy[24].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"25-29: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[25].ch_energy, \\\n                      (int8_t)m_average_ch_energy[26].ch_energy, \\\n                      (int8_t)m_average_ch_energy[27].ch_energy, \\\n                      (int8_t)m_average_ch_energy[28].ch_energy, \\\n                      (int8_t)m_average_ch_energy[29].ch_energy  \\\n                      );\n\n        NRF_LOG_DEBUG(\"30-34: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[30].ch_energy, \\\n                      (int8_t)m_average_ch_energy[31].ch_energy, \\\n                      (int8_t)m_average_ch_energy[32].ch_energy, \\\n                      (int8_t)m_average_ch_energy[33].ch_energy, \\\n                      (int8_t)m_average_ch_energy[34].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"35-39: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[35].ch_energy, \\\n                      (int8_t)m_average_ch_energy[36].ch_energy, \\\n                      (int8_t)m_average_ch_energy[37].ch_energy, \\\n                      (int8_t)m_average_ch_energy[38].ch_energy, \\\n                      (int8_t)m_average_ch_energy[39].ch_energy  \\\n                      );\n\n        sort_channel_survey();\n\n        NRF_LOG_DEBUG(\"Top Best Clean Channel Index:\");\n\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[0].index,  \\\n                      m_average_ch_energy[1].index,  \\\n                      m_average_ch_energy[2].index,  \\\n                      m_average_ch_energy[3].index,  \\\n                      m_average_ch_energy[4].index   \\\n                      );\n\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[5].index,  \\\n                      m_average_ch_energy[6].index,  \\\n                      m_average_ch_energy[7].index,  \\\n                      m_average_ch_energy[8].index,  \\\n                      m_average_ch_energy[9].index   \\\n                      );\n\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[10].index,  \\\n                      m_average_ch_energy[11].index,  \\\n                      m_average_ch_energy[12].index,  \\\n                      m_average_ch_energy[13].index,  \\\n                      m_average_ch_energy[14].index   \\\n                      );\n\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[15].index,  \\\n                      m_average_ch_energy[16].index,  \\\n                      m_average_ch_energy[17].index,  \\\n                      m_average_ch_energy[18].index,  \\\n                      m_average_ch_energy[19].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[20].index,  \\\n                      m_average_ch_energy[21].index,  \\\n                      m_average_ch_energy[22].index,  \\\n                      m_average_ch_energy[23].index,  \\\n                      m_average_ch_energy[24].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[25].index,  \\\n                      m_average_ch_energy[26].index,  \\\n                      m_average_ch_energy[27].index,  \\\n                      m_average_ch_energy[28].index,  \\\n                      m_average_ch_energy[29].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[30].index,  \\\n                      m_average_ch_energy[31].index,  \\\n                      m_average_ch_energy[32].index,  \\\n                      m_average_ch_energy[33].index,  \\\n                      m_average_ch_energy[34].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d\",  \\\n                      m_average_ch_energy[35].index,  \\\n                      m_average_ch_energy[36].index\n                      );\n\n        update_channel_survey_status = true;\n\n}\n\n\n\nuint32_t channel_map_request_update(uint16_t conn_handle, uint8_t first_best_channel_number)\n{\n        ret_code_t err_code;\n        uint8_t number_channel_request = 0;\n        ble_gap_opt_ch_map_t channel_map = {0};\n\n        if (conn_handle == BLE_CONN_HANDLE_INVALID)\n        {\n                NRF_LOG_ERROR(\"Failure: because of disconnection!\");\n                return -1;\n        }\n\n        NRF_LOG_DEBUG(\"channel_map_request_update!!\");\n\n        channel_map.conn_handle = conn_handle;  \n\n        for (uint8_t i=0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                uint8_t freq_index = m_average_ch_energy[i].index;\n\n                if (freq_index != ADVERTISING_CHANNEL_37 && freq_index != ADVERTISING_CHANNEL_38 && freq_index != ADVERTISING_CHANNEL_39)\n                {\n                        if (freq_index < 8)\n                        {\n                                channel_map.ch_map[0] |= 1 << (freq_index);\n                                \n                        }\n                        else if (freq_index < 16)\n                        {\n                                channel_map.ch_map[1] |= 1 << (freq_index-8);\n                                \n                        }\n                        else if (freq_index < 24)\n                        {\n                                channel_map.ch_map[2] |= 1 << (freq_index-16);\n                                \n                        }\n                        else if (freq_index < 32)\n                        {\n                                channel_map.ch_map[3] |= 1 << (freq_index-24);\n                                \n                        }\n                        else\n                        {\n                                channel_map.ch_map[4] |= 1 << (freq_index-32);\n                                \n                        }\n                        number_channel_request++;\n                }\n                if (number_channel_request > first_best_channel_number)\n                {\n                        break;\n                }\n        }\n        NRF_LOG_HEXDUMP_DEBUG(channel_map.ch_map, 5);\n\n        err_code = sd_ble_opt_set(BLE_GAP_OPT_CH_MAP, (ble_opt_t *)&channel_map);\n        APP_ERROR_CHECK(err_code);\n\n        update_channel_survey_status = false;\n}\n\nstatic void process_channel_survey_report(ble_gap_evt_qos_channel_survey_report_t * p_report)\n{\n        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                float energy_sample = p_report->channel_energy[i];\n\n                if (energy_sample == BLE_GAP_POWER_LEVEL_INVALID)\n                {\n                        continue;\n                }\n\n                if (m_num_channel_survey_reports_received == 0)\n                {\n                        m_average_ch_energy[i].ch_energy = energy_sample;\n                }\n                else\n                {\n                        m_average_ch_energy[i].ch_energy =  (m_num_channel_survey_reports_received * m_average_ch_energy[i].ch_energy + energy_sample)\n                                                           \/ (m_num_channel_survey_reports_received + 1);\n                }\n        }\n}\n\nuint32_t channel_survey_get_report_event(ble_gap_evt_qos_channel_survey_report_t *channel_survey_report)\n{\n        uint32_t err_code;\n\n        process_channel_survey_report(channel_survey_report);\n        m_num_channel_survey_reports_received++;\n\n        if (m_num_channel_survey_reports_received > NUM_REPORTS_BEFORE_AVERAGE_PRINTOUT)\n        {\n                err_code = sd_ble_gap_qos_channel_survey_stop();\n                APP_ERROR_CHECK(err_code);\n\n                \n\n                err_code = app_sched_event_put(NULL, 0, update_and_sort_channel_survey_handler);\n                APP_ERROR_CHECK(err_code);\n\n                m_num_channel_survey_reports_received = 0;\n        }\n\n}\n"}
{"target":"jimmywong2003","func":"\n#include <nrfx.h>\n#include <string.h>\n#include <nrfx_pwm.h>\n#include <hal\/nrf_gpio.h>\n#include \"drv_ws2812.h\"\n\n#define WS2812_T1H                  14 | 0x8000\n#define WS2812_T0H                  6 | 0x8000\n\n#if defined(NEOPIXEL_RING)\n#define LED_MATRIX_TOTAL_BYTE_WIDTH LED_MATRIX_WIDTH * LED_MATRIX_HEIGHT * 4\n#define LED_MATRIX_TOTAL_BIT_WIDTH  LED_MATRIX_TOTAL_BYTE_WIDTH * 8\n#else\n#define LED_MATRIX_TOTAL_BYTE_WIDTH LED_MATRIX_WIDTH * LED_MATRIX_HEIGHT * 3\n#define LED_MATRIX_TOTAL_BIT_WIDTH  LED_MATRIX_TOTAL_BYTE_WIDTH * 8\n#endif\n\n\nstatic rgb_color_t led_matrix_buffer[LED_MATRIX_WIDTH][LED_MATRIX_HEIGHT];\n\nstatic nrfx_pwm_t m_pwm0 = NRFX_PWM_INSTANCE(0);\nstatic nrf_pwm_values_individual_t pwm_duty_cycle_values[LED_MATRIX_TOTAL_BIT_WIDTH];\nvolatile bool pwm_sequencue_finished = true;\n\nvoid pwm_handler(nrfx_pwm_evt_type_t event_type)\n{\n    switch(event_type)\n    {\n    case NRFX_PWM_EVT_FINISHED:\n        pwm_sequencue_finished = true;\n        break;\n    default:\n        break;\n    }\n}\n\nstatic nrf_pwm_sequence_t pwm_sequence =\n{\n    .values.p_individual = pwm_duty_cycle_values,\n    .length          = (sizeof(pwm_duty_cycle_values) \/ sizeof(uint16_t)),\n    .repeats         = 0,\n    .end_delay       = 0\n};\n\nstatic uint32_t pwm_init(void)\n{\n    nrfx_pwm_config_t pwm_config = NRFX_PWM_DEFAULT_CONFIG;\n    pwm_config.output_pins[0] = NRFX_PWM_PIN_NOT_USED; \n    pwm_config.output_pins[1] = WS2812_PIN; \n    pwm_config.output_pins[2] = NRFX_PWM_PIN_NOT_USED;\n    pwm_config.output_pins[3] = NRFX_PWM_PIN_NOT_USED;\n    pwm_config.load_mode    = NRF_PWM_LOAD_INDIVIDUAL;\n    \n    pwm_config.top_value    = 20; \n    pwm_config.base_clock   = NRF_PWM_CLK_16MHz;\n    \n    return nrfx_pwm_init(&m_pwm0, &pwm_config, pwm_handler);\n}\n\n\n\nstatic void convert_rgb_to_pwm_sequence(void)\n{\n    uint8_t * ptr = (uint8_t *)led_matrix_buffer;\n    uint32_t i = 0;\n    for(int led = 0; led < LED_MATRIX_TOTAL_BYTE_WIDTH; led++)\n    {\n        for(int bit = 7; bit >= 0; bit--)\n        {\n            uint8_t b = (*ptr >> bit) & 0x01;\n            uint16_t pwm = 0;\n            if(b == 1)\n            {\n                pwm = WS2812_T1H;\n            }\n            else\n            {\n                pwm = WS2812_T0H;\n            }\n            pwm_duty_cycle_values[i++].channel_1 = pwm;\n        }\n        ptr++;\n    }\n}\n\nuint32_t drv_ws2812_init(void)\n{   \n    volatile uint32_t size = sizeof(led_matrix_buffer);\n    memset(led_matrix_buffer, 0x00, sizeof(led_matrix_buffer));   \n    return pwm_init();\n}\n\nuint32_t drv_ws2812_display(void)\n{\n    if(!pwm_sequencue_finished) \n    {\n        return NRF_ERROR_BUSY;\n    }\n    convert_rgb_to_pwm_sequence();\n    pwm_sequencue_finished = false;\n    uint32_t err_code = nrfx_pwm_simple_playback(&m_pwm0, &pwm_sequence, 1, NRFX_PWM_FLAG_STOP);\n    return err_code;\n}\n\nuint32_t drv_ws2812_pixel_draw(uint16_t x, uint16_t y, uint32_t color)\n{\n    uint32_t err_code = NRF_SUCCESS;\n    if(x > LED_MATRIX_WIDTH - 1)\n    {\n        err_code = NRF_ERROR_INVALID_PARAM;\n    }\n    if(y > LED_MATRIX_HEIGHT - 1)\n    {\n    err_code = NRF_ERROR_INVALID_PARAM;\n    }\n \n#if defined(NEOPIXEL_RING)\n    led_matrix_buffer[x][y].w = (color & 0xFF000000) >> 24;\n#endif\n    led_matrix_buffer[x][y].r = (color & 0x00FF0000) >> 16;\n    led_matrix_buffer[x][y].g = (color & 0x0000FF00) >> 8;\n    led_matrix_buffer[x][y].b = (color & 0x000000FF);\n    \n    return err_code;\n}\n\nuint32_t drv_ws2812_rectangle_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    uint32_t err_code;\n    for(int h = y; h < (y + height); h++)\n    {\n        for(int w = x; w < (x + width); w++)\n        {\n            err_code = drv_ws2812_pixel_draw(w, h, color);\n            if(err_code) return err_code;\n        }\n    }\n    return NRF_SUCCESS;\n}\n\n"}
{"target":"jimmywong2003","func":"\n#include <stdbool.h>\n#include <stdint.h>\n#include \"nrf_assert.h\"\n#include \"nrf_gpio.h\"\n#include \"sdk_config.h\"\n#include \"sdk_errors.h\"\n#include \"drv_ws2812.h\"\n#include \"drv_ws2812_gfx_glue_layer.h\"\n\n\nret_code_t drv_ws2812_gfx_glue_init(void)\n{\n    return drv_ws2812_init();\n}\n\n\nvoid drv_ws2812_gfx_glue_uninit(void)\n{\n    \n}\n\n\nvoid drv_ws2812_gfx_glue_pixel_draw(uint16_t x, uint16_t y, uint32_t color)\n{\n    drv_ws2812_pixel_draw(x, y, color);\n}\n\n\nvoid drv_ws2812_gfx_glue_rect_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    drv_ws2812_rectangle_draw(x, y, width, height, color);\n}\n\n\nvoid drv_ws2812_gfx_glue_display(void)\n{\n    drv_ws2812_display();\n}\n\n\nvoid drv_ws2812_gfx_glue_rotation_set(nrf_lcd_rotation_t rotation)\n{\n    \n}\n\n\nvoid drv_ws2812_gfx_glue_display_invert(bool invert)\n{\n    \n}\n\n\n"}
{"target":"jimmywong2003","func":"\n\n#include \"sdk_common.h\"\n\n#if NRF_MODULE_ENABLED(ILI9341)\n\n#include \"nrf_lcd_ext.h\"\n#include \"nrf_drv_spi.h\"\n#include \"nrf_delay.h\"\n#include \"nrf_gpio.h\"\n#include \"boards.h\"\n\n\n#define ILI9341_NOP         0x00\n#define ILI9341_SWRESET     0x01\n#define ILI9341_RDDID       0x04\n#define ILI9341_RDDST       0x09\n\n#define ILI9341_SLPIN       0x10\n#define ILI9341_SLPOUT      0x11\n#define ILI9341_PTLON       0x12\n#define ILI9341_NORON       0x13\n\n#define ILI9341_RDMODE      0x0A\n#define ILI9341_RDMADCTL    0x0B\n#define ILI9341_RDPIXFMT    0x0C\n#define ILI9341_RDIMGFMT    0x0D\n#define ILI9341_RDSELFDIAG  0x0F\n\n#define ILI9341_INVOFF      0x20\n#define ILI9341_INVON       0x21\n#define ILI9341_GAMMASET    0x26\n#define ILI9341_DISPOFF     0x28\n#define ILI9341_DISPON      0x29\n\n#define ILI9341_CASET       0x2A\n#define ILI9341_PASET       0x2B\n#define ILI9341_RAMWR       0x2C\n#define ILI9341_RAMRD       0x2E\n\n#define ILI9341_PTLAR       0x30\n#define ILI9341_MADCTL      0x36\n#define ILI9341_PIXFMT      0x3A\n\n#define ILI9341_FRMCTR1     0xB1\n#define ILI9341_FRMCTR2     0xB2\n#define ILI9341_FRMCTR3     0xB3\n#define ILI9341_INVCTR      0xB4\n#define ILI9341_DFUNCTR     0xB6\n\n#define ILI9341_PWCTR1      0xC0\n#define ILI9341_PWCTR2      0xC1\n#define ILI9341_PWCTR3      0xC2\n#define ILI9341_PWCTR4      0xC3\n#define ILI9341_PWCTR5      0xC4\n#define ILI9341_VMCTR1      0xC5\n#define ILI9341_VMCTR2      0xC7\n#define ILI9341_PWCTRSEQ    0xCB\n#define ILI9341_PWCTRA      0xCD\n#define ILI9341_PWCTRB      0xCF\n\n#define ILI9341_RDID1       0xDA\n#define ILI9341_RDID2       0xDB\n#define ILI9341_RDID3       0xDC\n#define ILI9341_RDID4       0xDD\n\n#define ILI9341_GMCTRP1     0xE0\n#define ILI9341_GMCTRN1     0xE1\n#define ILI9341_DGMCTR1     0xE2\n#define ILI9341_DGMCTR2     0xE3\n#define ILI9341_TIMCTRA     0xE8\n#define ILI9341_TIMCTRB     0xEA\n\n#define ILI9341_ENGMCTR     0xF2\n#define ILI9341_INCTR       0xF6\n#define ILI9341_PUMP        0xF7\n\n#define ILI9341_MADCTL_MY  0x80\n#define ILI9341_MADCTL_MX  0x40\n#define ILI9341_MADCTL_MV  0x20\n#define ILI9341_MADCTL_ML  0x10\n#define ILI9341_MADCTL_RGB 0x00\n#define ILI9341_MADCTL_BGR 0x08\n#define ILI9341_MADCTL_MH  0x04\n\nstatic const nrf_drv_spi_t spi = NRF_DRV_SPI_INSTANCE(ILI9341_SPI_INSTANCE);\n\nstatic inline void spi_write(const void * data, size_t size)\n{\n    APP_ERROR_CHECK(nrf_drv_spi_transfer(&spi, data, size, NULL, 0));\n}\n\nstatic inline void write_command(uint8_t c)\n{\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n    spi_write(&c, sizeof(c));\n}\n\nstatic inline void write_data(uint8_t c)\n{\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n    spi_write(&c, sizeof(c));\n}\n\nstatic void set_addr_window(uint16_t x_0, uint16_t y_0, uint16_t x_1, uint16_t y_1)\n{\n    ASSERT(x_0 <= x_1);\n    ASSERT(y_0 <= y_1);\n\n    write_command(ILI9341_CASET);\n    write_data(x_0 >> 8);\n    write_data(x_0);\n    write_data(x_1 >> 8);\n    write_data(x_1);\n    write_command(ILI9341_PASET);\n    write_data(y_0 >> 8);\n    write_data(y_0);\n    write_data(y_1 >> 8);\n    write_data(y_1);\n    write_command(ILI9341_RAMWR);\n}\n\nstatic void command_list(void)\n{\n    write_command(ILI9341_SWRESET);\n    nrf_delay_ms(120);\n    write_command(ILI9341_DISPOFF);\n    nrf_delay_ms(120);\n    write_command(ILI9341_PWCTRB);\n    write_data(0x00);\n    write_data(0XC1);\n    write_data(0X30);\n\n    write_command(ILI9341_TIMCTRA);\n    write_data(0x85);\n    write_data(0x00);\n    write_data(0x78);\n\n    write_command(ILI9341_PWCTRSEQ);\n    write_data(0x39);\n    write_data(0x2C);\n    write_data(0x00);\n    write_data(0x34);\n    write_data(0x02);\n\n    write_command(ILI9341_PUMP);\n    write_data(0x20);\n\n    write_command(ILI9341_TIMCTRB);\n    write_data(0x00);\n    write_data(0x00);\n\n    write_command(ILI9341_PWCTR1);\n    write_data(0x23);\n\n    write_command(ILI9341_PWCTR2);\n    write_data(0x10);\n\n    write_command(ILI9341_VMCTR1);\n    write_data(0x3e);\n    write_data(0x28);\n\n    write_command(ILI9341_VMCTR2);\n    write_data(0x86);\n\n    write_command(ILI9341_MADCTL);\n    write_data(0x48);\n\n    write_command(ILI9341_PIXFMT);\n    write_data(0x55);\n\n    write_command(ILI9341_FRMCTR1);\n    write_data(0x00);\n    write_data(0x18);\n\n    write_command(ILI9341_DFUNCTR);\n    write_data(0x08);\n    write_data(0x82);\n    write_data(0x27);\n\n    write_command(ILI9341_ENGMCTR);\n    write_data(0x00);\n\n    write_command(ILI9341_GAMMASET);\n    write_data(0x01);\n\n    write_command(ILI9341_GMCTRP1);\n    write_data(0x0F);\n    write_data(0x31);\n    write_data(0x2B);\n    write_data(0x0C);\n    write_data(0x0E);\n    write_data(0x08);\n    write_data(0x4E);\n    write_data(0xF1);\n    write_data(0x37);\n    write_data(0x07);\n    write_data(0x10);\n    write_data(0x03);\n    write_data(0x0E);\n    write_data(0x09);\n    write_data(0x00);\n\n    write_command(ILI9341_GMCTRN1);\n    write_data(0x00);\n    write_data(0x0E);\n    write_data(0x14);\n    write_data(0x03);\n    write_data(0x11);\n    write_data(0x07);\n    write_data(0x31);\n    write_data(0xC1);\n    write_data(0x48);\n    write_data(0x08);\n    write_data(0x0F);\n    write_data(0x0C);\n    write_data(0x31);\n    write_data(0x36);\n    write_data(0x0F);\n\n    write_command(ILI9341_SLPOUT);\n    nrf_delay_ms(120);\n    write_command(ILI9341_DISPON);\n}\n\nstatic ret_code_t hardware_init(void)\n{\n    ret_code_t err_code;\n\n    nrf_gpio_cfg_output(ILI9341_DC_PIN);\n\n    nrf_drv_spi_config_t spi_config = NRF_DRV_SPI_DEFAULT_CONFIG;\n\n    spi_config.sck_pin  = ILI9341_SCK_PIN;\n    spi_config.miso_pin = ILI9341_MISO_PIN;\n    spi_config.mosi_pin = ILI9341_MOSI_PIN;\n    spi_config.ss_pin   = ILI9341_SS_PIN;\n    spi_config.frequency = SPI_FREQUENCY_FREQUENCY_M4;\n\n    err_code = nrf_drv_spi_init(&spi, &spi_config, NULL, NULL);\n    return err_code;\n}\n\nstatic ret_code_t ili9341_init(void)\n{\n    ret_code_t err_code;\n\n    err_code = hardware_init();\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n\n    command_list();\n\n    return err_code;\n}\n\nstatic void ili9341_uninit(void)\n{\n    nrf_drv_spi_uninit(&spi);\n}\n\nstatic void ili9341_pixel_draw(uint16_t x, uint16_t y, uint32_t color)\n{\n    set_addr_window(x, y, x, y);\n\n    const uint8_t data[2] = {color >> 8, color};\n\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n\n    spi_write(data, sizeof(data));\n\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n}\n\nstatic void ili9341_rect_draw_old(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    set_addr_window(x, y, x + width - 1, y + height - 1);\n\n    const uint8_t data[2] = {color >> 8, color};\n\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n\n    \n    uint32_t i = (height * width + 7) \/ 8;\n\n\n    switch ((height * width) % 8) {\n        case 0:\n            do {\n                spi_write(data, sizeof(data));\n        case 7:\n                spi_write(data, sizeof(data));\n        case 6:\n                spi_write(data, sizeof(data));\n        case 5:\n                spi_write(data, sizeof(data));\n        case 4:\n                spi_write(data, sizeof(data));\n        case 3:\n                spi_write(data, sizeof(data));\n        case 2:\n                spi_write(data, sizeof(data));\n        case 1:\n                spi_write(data, sizeof(data));\n            } while (--i > 0);\n        default:\n            break;\n    }\n\n\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n}\n\nstatic void ili9341_rect_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    static uint8_t data[32];\n    \n    set_addr_window(x, y, x + width - 1, y + height - 1);\n\n    for(int i = 0; i < 16; i++)\n    {\n       data[i*2] = color >> 8;\n       data[i*2+1] = color;\n    }\n\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n\n    uint32_t bytes_left = height * width * 2;\n\n    do\n    {\n        if(bytes_left > 32)\n        {\n            spi_write(data, sizeof(data));\n            bytes_left -= 16;\n        }\n        else\n        {\n           spi_write(data, bytes_left);\n           bytes_left = 0;\n        }\n    \n    }while(bytes_left > 0); \n\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n}\n\nstatic void ili9341_buffer_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, void * p_data, uint32_t length)\n{\n    uint32_t spi_max_length, spi_length;\n    \n    set_addr_window(x, y, x + width - 1, y + height - 1);\n\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n    spi_max_length = 250; \n    do\n    {\n        spi_length = (length > spi_max_length) ? spi_max_length : length;\n        spi_write(p_data, spi_length);\n        length -= spi_length;\n        p_data += spi_length;        \n    }while(length > 0);\n\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);    \n}\n\nstatic void ili9341_dummy_display(void)\n{\n    \n}\n\nstatic void ili9341_rotation_set(nrf_lcd_rotation_t rotation)\n{\n    write_command(ILI9341_MADCTL);\n    switch (rotation) {\n        case NRF_LCD_ROTATE_0:\n            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_90:\n            write_data(ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_180:\n            write_data(ILI9341_MADCTL_MY | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_270:\n            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_MY | ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);\n            break;\n        default:\n            break;\n    }\n}\n\nstatic void ili9341_display_invert(bool invert)\n{\n    write_command(invert ? ILI9341_INVON : ILI9341_INVOFF);\n}\n\nstatic lcd_cb_t ili9341_cb = {\n    .height = ILI9341_HEIGHT,\n    .width = ILI9341_WIDTH\n};\n\n\nconst nrf_lcd_t nrf_lcd_ili9341 = {\n    .lcd_init = ili9341_init,\n    .lcd_uninit = ili9341_uninit,\n    .lcd_pixel_draw = ili9341_pixel_draw,\n    .lcd_rect_draw = ili9341_rect_draw,\n    .lcd_buffer_draw = ili9341_buffer_draw,\n    .lcd_display = ili9341_dummy_display,\n    .lcd_rotation_set = ili9341_rotation_set,\n    .lcd_display_invert = ili9341_display_invert,\n    .p_lcd_cb = &ili9341_cb\n};\n\n#endif \n"}
{"target":"jimmywong2003","func":"\n\n#include \"nrf_dfu_flash.h\"\n#include \"nrf_dfu_types.h\"\n\n#include \"nrf_fstorage.h\"\n#include \"nrf_fstorage_sd.h\"\n#include \"nrf_fstorage_nvmc.h\"\n\n\n#define NRF_LOG_MODULE_NAME nrf_dfu_flash\n#include \"nrf_log.h\"\n\n#if NRF_DFU_FLASH_CONFIG_LOG_ENABLED\n#define NRF_LOG_LEVEL BLE_SCAN_CONFIG_LOG_LEVEL\n#define NRF_LOG_INFO_COLOR BLE_SCAN_CONFIG_INFO_COLOR\n#define NRF_LOG_DEBUG_COLOR BLE_SCAN_CONFIG_DEBUG_COLOR\n#else \n#define NRF_LOG_LEVEL 4\n#endif \n#include \"nrf_log.h\"\nNRF_LOG_MODULE_REGISTER();\n\n\nvoid dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt);\n\n\nNRF_FSTORAGE_DEF(nrf_fstorage_t m_fs) =\n{\n        .evt_handler = dfu_fstorage_evt_handler,\n        .start_addr  = MBR_SIZE,\n        .end_addr    = BOOTLOADER_SETTINGS_ADDRESS + BOOTLOADER_SETTINGS_PAGE_SIZE\n};\n\nstatic uint32_t m_flash_operations_pending;\n\nvoid dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n\n        if (p_evt->p_param)\n        {\n                \n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n                \n        }\n}\n\n\nret_code_t nrf_dfu_flash_init(bool sd_irq_initialized)\n{\n        nrf_fstorage_api_t * p_api_impl;\n\n        \n#if defined(BLE_STACK_SUPPORT_REQD) || defined(ANT_STACK_SUPPORT_REQD)\n        if (sd_irq_initialized)\n        {\n                NRF_LOG_DEBUG(\"Initializing nrf_fstorage_sd backend.\");\n                p_api_impl = &nrf_fstorage_sd;\n        }\n        else\n#endif\n        {\n                NRF_LOG_DEBUG(\"Initializing nrf_fstorage_nvmc backend.\");\n                p_api_impl = &nrf_fstorage_nvmc;\n        }\n\n\n\n        return nrf_fstorage_init(&m_fs, p_api_impl, NULL);\n}\n\n\nret_code_t nrf_dfu_flash_store(uint32_t dest,\n                               void const * p_src,\n                               uint32_t len,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n\n        NRF_LOG_DEBUG(\"nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d\",\n                      dest, p_src, len, m_flash_operations_pending);\n\n        \n        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);\n        \n\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_write() failed with error 0x%x.\", rc);\n        }\n\n        return rc;\n}\n\n\nret_code_t nrf_dfu_flash_erase(uint32_t page_addr,\n                               uint32_t num_pages,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n\n        NRF_LOG_DEBUG(\"nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d\",\n                      page_addr, num_pages, m_flash_operations_pending);\n\n        \n        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);\n        \n\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_erase() failed with error 0x%x.\", rc);\n        }\n\n        return rc;\n}\n"}
{"target":"jimmywong2003","func":"#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include \"nordic_common.h\"\n#include \"app_error.h\"\n#include \"app_util.h\"\n#include \"bsp_btn_ble.h\"\n#include \"ble.h\"\n#include \"ble_gap.h\"\n#include \"ble_hci.h\"\n#include \"nrf_sdh.h\"\n#include \"nrf_sdh_ble.h\"\n#include \"nrf_sdh_soc.h\"\n#include \"nrf_ble_gatt.h\"\n#include \"nrf_pwr_mgmt.h\"\n\n#include \"packet_error_rate.h\"\n\n#include \"nrf_log_ctrl.h\"\n#include \"nrf_log.h\"\n#include \"nrf_log_default_backends.h\"\n\nstatic uint32_t u32_radio_packet_ready_per_interval = 0;\nstatic uint32_t u32_radio_packet_crcok_per_interval = 0;\n\nstatic packet_error_t m_accumlated_radio_packet;\n\nstatic uint32_t radio_packet_success_rate = 0;\nstatic uint32_t radio_packet_ready = 0;\nstatic uint32_t radio_packet_crcok = 0;\n\nvoid timer_1_init()\n{\n        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;\n        NRF_TIMER_TX_READY->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;\n        NRF_TIMER_TX_READY->PRESCALER = 4;\n        NRF_TIMER_TX_READY->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\n        NRF_TIMER_TX_READY->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;\n        NRF_TIMER_TX_READY->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;\n        NRF_TIMER_TX_READY->TASKS_START = 1;\n}\n\nvoid timer_2_init()\n{\n        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;\n        NRF_TIMER_RX_CRCOK->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;\n        NRF_TIMER_RX_CRCOK->PRESCALER = 4;\n        NRF_TIMER_RX_CRCOK->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\n        NRF_TIMER_RX_CRCOK->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;\n        NRF_TIMER_RX_CRCOK->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;\n        NRF_TIMER_RX_CRCOK->TASKS_START = 1;\n}\n\nvoid packet_error_rate_reset_counter(void)\n{\n        memset(&m_accumlated_radio_packet, 0, sizeof(m_accumlated_radio_packet));\n        radio_packet_success_rate = 0;\n        radio_packet_ready = 0;\n        radio_packet_crcok = 0;\n}\n\nvoid packet_error_rate_detect_enable(void)\n{\n        timer_1_init();\n        timer_2_init();\n\n        \n        NRF_GPIO->DIRSET       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |\n                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );\n\n        \n        NRF_GPIO->OUTCLR       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |\n                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );\n\n        NRF_GPIO->OUTSET       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |\n                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );\n\n        NRF_GPIO->OUTCLR       = ( 1UL << GPIO_PER_PIN_FOR_TX_READY       |\n                                   1UL << GPIO_PER_PIN_FOR_RX_CRCOK );\n\n\n        \n\n        NRF_GPIOTE->CONFIG[GPIOTE_CHANNEL_TX_READY] =\n                (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos) |\n                (GPIO_PER_PIN_FOR_TX_READY << GPIOTE_CONFIG_PSEL_Pos)              |\n                (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos);\n\n        NRF_GPIOTE->CONFIG[GPIOTE_CHANNEL_RX_CRCOK] =\n                (GPIOTE_CONFIG_POLARITY_Toggle << GPIOTE_CONFIG_POLARITY_Pos) |\n                (GPIO_PER_PIN_FOR_RX_CRCOK << GPIOTE_CONFIG_PSEL_Pos)             |\n                (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos);\n\n#if defined (NRF52840_XXAA)\n        \n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_TX_READY]);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_TXREADY);\n\n        \n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_RX_CRCOK]);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);\n\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_TX_READY->TASKS_COUNT);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_TXREADY);\n\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_RX_CRCOK->TASKS_COUNT);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);\n\n#else\n        \n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_TX_READY]);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_READY);\n\n        \n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].TEP = (uint32_t)(&NRF_GPIOTE->TASKS_OUT[GPIOTE_CHANNEL_RX_CRCOK]);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);\n\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_TX_READY->TASKS_COUNT);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_TX_READY_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_READY);\n\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].TEP = (uint32_t)(&NRF_TIMER_RX_CRCOK->TASKS_COUNT);\n        NRF_PPI->CH[PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT].EEP = (uint32_t)(&NRF_RADIO->EVENTS_CRCOK);\n#endif \n        \n        NRF_PPI->CHENSET =  (1 << PPI_CHANNEL_FOR_TX_READY_GPIO_EVT)  |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT) |\n                           (1 << PPI_CHANNEL_FOR_TX_READY_TIMER_EVT) |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT);\n}\n\nvoid packet_error_rate_detect_disable(void)\n{\n        \n        NRF_PPI->CHENCLR =  (1 << PPI_CHANNEL_FOR_TX_READY_GPIO_EVT)  |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT) |\n                           (1 << PPI_CHANNEL_FOR_TX_READY_TIMER_EVT) |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT);\n\n        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;\n        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;\n\n        NRF_TIMER_TX_READY->TASKS_STOP = 1;\n        NRF_TIMER_RX_CRCOK->TASKS_STOP = 1;\n\n        u32_radio_packet_ready_per_interval = 0;\n        u32_radio_packet_crcok_per_interval = 0;\n}\n\nuint32_t packet_error_rate_timeout_handler(void)\n{\n        \n        NRF_TIMER_TX_READY->TASKS_CAPTURE[0] = 1;\n        NRF_TIMER_RX_CRCOK->TASKS_CAPTURE[0] = 1;\n\n#if defined (NRF52840_XXAA)\n        radio_packet_ready = NRF_TIMER_TX_READY->CC[0] - u32_radio_packet_ready_per_interval;\n#else\n        radio_packet_ready = NRF_TIMER_TX_READY->CC[0]\/2 - u32_radio_packet_ready_per_interval;\n#endif\n        radio_packet_crcok = NRF_TIMER_RX_CRCOK->CC[0] - u32_radio_packet_crcok_per_interval;\n\n        radio_packet_success_rate = (radio_packet_crcok * 100)\/(radio_packet_ready);\n\n#if defined (NRF52840_XXAA)\n        u32_radio_packet_ready_per_interval = NRF_TIMER_TX_READY->CC[0];\n#else\n        u32_radio_packet_ready_per_interval = NRF_TIMER_TX_READY->CC[0]\/2;\n#endif\n        u32_radio_packet_crcok_per_interval = NRF_TIMER_RX_CRCOK->CC[0];\n\n        \n        NRF_LOG_DEBUG(\"PER Timeout %d, %d\", radio_packet_ready, radio_packet_crcok);\n        \n        \n\n        \n        \n\n        \n\n        m_accumlated_radio_packet.radio_packet_crcok += radio_packet_crcok;\n        m_accumlated_radio_packet.radio_packet_ready += radio_packet_ready;\n\n        NRF_LOG_DEBUG(\"PER accumulated %d, %d\", m_accumlated_radio_packet.radio_packet_ready, m_accumlated_radio_packet.radio_packet_crcok);\n\n        m_accumlated_radio_packet.radio_packet_success_rate = (m_accumlated_radio_packet.radio_packet_crcok * 100)\/(m_accumlated_radio_packet.radio_packet_ready);\n\n        if (radio_packet_ready > 0xFFFF0000)\n        {\n                u32_radio_packet_ready_per_interval = 0;\n                u32_radio_packet_crcok_per_interval = 0;\n                packet_error_rate_detect_disable();\n                packet_error_rate_detect_enable();\n        }\n        return radio_packet_success_rate;\n}\n\nuint32_t get_packet_success_rate(void)\n{\n        return radio_packet_success_rate;\n}\n\nvoid get_accumlated_packet_success_rate(packet_error_t *per)\n{\n      *per = m_accumlated_radio_packet;\n}\n\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nint scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}\n\n\nvoid print_level(binary_tree_t *tree, int level, void (*func)(int))\n{\n    if (tree != NULL)\n    {\n        if (level == 0)\n        {\n            func((*tree).n);\n        }\n        else\n        {\n            print_level((*tree).left, level - 1, func);\n            print_level((*tree).right, level - 1, func);\n        }\n    }\n}\n\n\nvoid binary_tree_levelorder(const binary_tree_t *tree, void (*func)(int))\n{\n    int level, height;\n\n    if (tree != NULL && func != NULL)\n    {\n        height = scale(tree) + 1;\n\n        for (level = 0; level < height; level++)\n        {\n            print_level((binary_tree_t *)tree, level, func);\n        }\n    }\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nsize_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}\n\n\nint is_complete(binary_tree_t *tree, int pos, int nodes)\n{\n    int left, right;\n\n    if (tree == NULL)\n    {\n        return (1);\n    }\n    if (pos >= nodes)\n    {\n        return (0);\n    }\n    left = is_complete((*tree).left, 2 * pos + 1, nodes);\n    right = is_complete((*tree).right, 2 * pos + 2, nodes);\n    return (left * right);\n}\n\n\nint binary_tree_is_complete(const binary_tree_t *tree)\n{\n    int nodes, pos = 0;\n\n    if (tree != NULL)\n    {\n        nodes = tree_size(tree);\n        return (is_complete((binary_tree_t *)tree, pos, nodes));\n    }\n    return (0);\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nbinary_tree_t *binary_tree_rotate_right(binary_tree_t *tree)\n{\n    binary_tree_t *y, *x;\n\n    if (tree != NULL)\n    {\n        x = tree;\n        if ((*x).left != NULL)\n        {\n            y = (*x).left;\n            \n            (*x).left = (*y).right;\n            if ((*y).right != NULL)\n            {\n                (*(*y).right).parent = x;\n            }\n            \n            (*y).parent = (*x).parent;\n            if ((*x).parent == NULL)\n            {\n                tree = y;\n            }\n            else if (x == (*(*x).parent).right)\n            {\n                (*(*x).parent).right = y;\n            }\n            else\n            {\n                (*(*x).parent).left = y;\n            }\n            \n            (*y).right = x;\n            (*x).parent = y;\n            return (tree);\n        }\n    }\n    return (NULL);\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nsize_t count_leaves(const binary_tree_t *tree)\n{\n    int count = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right == NULL && (*tree).left == NULL)\n    {\n        return (1);\n    }\n    count = count_leaves((*tree).right) + count_leaves((*tree).left);\n    return (count);\n}\n\n\nsize_t internal_nodes(const binary_tree_t *tree)\n{\n    int c = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right != NULL || (*tree).left != NULL)\n    {\n        c = 1 + internal_nodes((*tree).right) + internal_nodes((*tree).left);\n    }\n    return (c);\n}\n\n\nsize_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}\n\n\nint binary_tree_is_full(const binary_tree_t *tree)\n{\n    int _inodes = 0, _nodes = 0, _leaves = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    _nodes = tree_size(tree);\n    _leaves = count_leaves(tree);\n    _inodes = internal_nodes(tree);\n    if (_inodes > 0)\n    {\n        if (_leaves != _inodes + 1)\n        {\n            return (0);\n        }\n        if (_nodes != 2 * _inodes + 1)\n        {\n            return (0);\n        }\n    }\n    if (_inodes != (_nodes - 1) \/ 2)\n    {\n\n        return (0);\n    }\n    if (_leaves != (_nodes + 1) \/ 2)\n    {\n        return (0);\n    }\n    if (_nodes != 2 * _leaves - 1)\n    {\n\n        return (0);\n    }\n    if (_inodes != _leaves - 1)\n    {\n        return (0);\n    }\n    return (1);\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nint _pow(int x, int y)\n{\n    if (y < 0)\n        return (-1);\n    if (y == 0)\n        return (1);\n    if (y > 1)\n    {\n        y = _pow(x, y - 1);\n    }\n    else\n    {\n        return (x * y);\n    }\n    return (x * y);\n}\n\n\nint scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}\n\n\nsize_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}\n\n\nint binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    int height;\n    int _nodes;\n\n    if (tree == NULL)\n        return (0);\n\n    height = scale(tree);\n    _nodes = tree_size(tree);\n    if (_pow(2, height + 1) - 1 == _nodes)\n        return (1);\n    return (0);\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nbinary_tree_t *brother(binary_tree_t *node)\n{\n    binary_tree_t *parent = NULL;\n\n    if (node == NULL)\n    {\n        return (NULL);\n    }\n    if ((*node).parent == NULL)\n    {\n        return (NULL);\n    }\n    parent = (*node).parent;\n    if ((*parent).left != NULL && (*parent).right != NULL)\n    {\n        if (node == (*parent).left)\n            return ((*parent).right);\n        return ((*parent).left);\n    }\n    return (NULL);\n}\n\n\nbinary_tree_t *binary_tree_uncle(binary_tree_t *node)\n{\n\n    if (node == NULL)\n    {\n        return (NULL);\n    }\n    if ((*node).parent == NULL)\n    {\n        return (NULL);\n    }\n    return (brother((*node).parent));\n}\n"}
{"target":"jose120918","func":"#include \"binary_trees.h\"\n\n\nint scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}\n\n\nsize_t binary_tree_height(const binary_tree_t *tree)\n{\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    return (scale(tree));\n}\n"}
{"target":"jose120918","func":"#include \"sort.h\"\n\n\nvoid insertion_sort_list(listint_t **list)\n{\n    listint_t *cur, *t, *t2;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    for (cur = *list; cur != NULL; cur = cur->next)\n    {\n        t = cur;\n        for (t2 = t->prev; t2 != NULL && t2->n > t->n; t2 = t->prev)\n        {\n            if (t2->prev != NULL && t->next != NULL)\n            {\n                t2->prev->next = t;\n                t->next->prev = t2;\n                t2->next = t->next;\n                t->prev = t2->prev;\n                t->next = t2;\n                t2->prev = t;\n                print_list(*list);\n                continue;\n            }\n            if (t2->prev == NULL)\n            {\n                t->prev = NULL;\n                t2->next = t->next;\n                t2->prev = t;\n                if (t->next != NULL)\n                    t->next->prev = t2;\n                t->next = t2;\n                *list = t;\n                print_list(*list);\n                continue;\n            }\n            if (t->next == NULL)\n            {\n                t->prev = t2->prev;\n                t->next = t2;\n                t2->next = NULL;\n                t2->prev->next = t;\n                t2->prev = t;\n                print_list(*list);\n                continue;\n            }\n        }\n    }\n}\n"}
{"target":"jose120918","func":"#include <stdio.h>\n#include <stdlib.h>\n#include \"sort.h\"\n\n\nlistint_t *create_listint(const int *array, size_t size)\n{\n    listint_t *list;\n    listint_t *node;\n    int *tmp;\n\n    list = NULL;\n    while (size--)\n    {\n        node = malloc(sizeof(*node));\n        if (!node)\n            return (NULL);\n        tmp = (int *)&node->n;\n        *tmp = array[size];\n        node->next = list;\n        node->prev = NULL;\n        list = node;\n        if (list->next)\n            list->next->prev = list;\n    }\n    return (list);\n}\n\n\nint main(void)\n{\n    listint_t *list;\n    int array[] = {19, 48, 99, 71, 13, 52, 96, 73, 86, 7};\n    size_t n = sizeof(array) \/ sizeof(array[0]);\n\n    list = create_listint(array, n);\n    if (!list)\n        return (1);\n    print_list(list);\n    printf(\"\\n\");\n    insertion_sort_list(&list);\n    printf(\"\\n\");\n    print_list(list);\n    return (0);\n}\n"}
{"target":"jose120918","func":"\n#include \"sort.h\"\n\n\nvoid shell_sort(int *array, size_t size)\n{\n    size_t h = 1, i, n;\n    int number;\n\n    if (!size || !array)\n        return;\n\n    while (h < size)\n        h = 3 * h + 1;\n\n    h = (h - 1) \/ 3;\n\n    while (h > 0)\n    {\n        for (i = h; i < size; i++)\n        {\n            number = array[i];\n            for (n = i; n > h - 1 && array[n - h] > number; n = n - h)\n            {\n                array[n] = array[n - h];\n            }\n            array[n] = number;\n        }\n        h = h \/ 3;\n        print_array(array, size);\n    }\n}"}
{"target":"jose120918","func":"  \n#include \"sort.h\"\n\n\nint swp_fwd(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n\n    moving = current->next;\n\n    moving->prev = current->prev;\n    if (current->prev)\n        current->prev->next = moving;\n    else\n        *list = current->next;\n\n    current->next = moving->next;\n    current->prev = moving;\n    moving->next = current;\n    if (current->next)\n        current->next->prev = current;\n\n    print_list(*list);\n    return (1);\n}\n\n\nint swp_bck(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n\n    moving = current->prev;\n\n    moving->next = current->next;\n    current->next->prev = moving;\n\n    current->prev = moving->prev;\n    current->next = moving;\n    moving->prev = current;\n    if (current->prev)\n        current->prev->next = current;\n    else\n        *list = current;\n    print_list(*list);\n    return (1);\n}\n\n\nvoid cocktail_sort_list(listint_t **list)\n{\n    listint_t *current = NULL;\n    int swapped = 1;\n\n    if (list)\n    {\n        current = *list;\n        while (swapped)\n        {\n            swapped = 0;\n            while (current->next)\n            {\n                if (current->n > current->next->n)\n                {\n                    swapped = swp_fwd(current, list);\n                    continue;\n                }\n                current = current->next;\n            }\n            if (!swapped)\n                break;\n            swapped = 0;\n            while (current->prev)\n            {\n                if (current->n < current->prev->n)\n                {\n                    swapped = swp_bck(current, list);\n                    continue;\n                }\n                current = current->prev;\n            }\n        }\n    }\n}"}
{"target":"jose120918","func":"#include \"sort.h\"\n\n\nvoid counting_sort(int *array, size_t size)\n{\n    int max, position, *count = NULL, *order = NULL;\n    size_t i;\n\n    if (size < 2 || array == NULL)\n        return;\n    \n    max = array[0];\n    for (i = 0; i < size; i++)\n        if (array[i] > max)\n            max = array[i];\n    \n    count = malloc(sizeof(int) * (max + 1));\n    for (i = 0; i <= (size_t)max; i++)\n        count[i] = 0;\n    \n    for (i = 0; i < size; i++)\n        count[array[i]] = count[array[i]] + 1;\n    \n    for (i = 1; i <= (size_t)max; i++)\n        count[i] = count[i] + count[i - 1];\n    print_array(count, (size_t)max + 1);\n    \n    order = malloc(sizeof(int) * size);\n    for (i = 0; i < size; i++)\n    {\n        count[array[i]] = count[array[i]] - 1;\n        position = count[array[i]];\n        order[position] = array[i];\n    }\n    \n    for (i = 0; i < size; i++)\n        array[i] = order[i];\n    free(count);\n    free(order);\n}"}
{"target":"jose120918","func":"#include \"sort.h\"\n\nvoid selection_sort(int *array, size_t size)\n{\n    size_t boundary = 0, min_pos, i;\n    int min, temp;\n\n    while (boundary < size)\n    {\n        i = boundary;\n        min = array[boundary];\n        min_pos = boundary;\n        while (i < size)\n        {\n            if (array[i] < min)\n            {\n                min = array[i];\n                min_pos = i;\n            }\n            i++;\n        }\n        if (min_pos != boundary)\n        {\n            temp = array[boundary];\n            array[boundary] = array[min_pos];\n            array[min_pos] = temp;\n            print_array(array, size);\n        }\n        boundary++;\n    }\n}\n"}
{"target":"kalpa96","func":"#include<stdio.h>\nint main()\n{\n    int n;\n    printf(\"Enter the print World number: \");\n    scanf(\"%d\",&n);\n    if(n==1)\n    {\n        printf(\"ONE\");\n    }\n    else if(n==2)\n    {\n        printf(\"TWO\");\n    }\n    else if(n==3)\n    {\n        printf(\"THREE\");\n    }\n    else if(n==4)\n    {\n        printf(\"FOUR\");\n    }\n    else if(n==5)\n    {\n        printf(\"FIVE\");\n    }\n    else if(n==6)\n    {\n        printf(\"SIX\");\n    }\n    else if(n==7)\n    {\n        printf(\"SEVEN\");\n    }\n    else if(n==8)\n    {\n        printf(\"EIGHT\");\n    }\n    else if(n==9)\n    {\n        printf(\"NINE\");\n    }\n    else \n    {\n        printf(\"OTHERS\");\n    }\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\nint po(int, int);\nint main(){\n    int n1,n2;\n    printf(\"Enter the number 1 :\\n\");\n    scanf(\"%d\",&n1);\n    printf(\"Enter the number 2 :\\n\");\n    scanf(\"%d\",&n2);\n    po(n1,n2);\n}\n\nint po(int n1, int n2){\n    int i,sum=0;\n    \n    if(n1>n2){  \n        for(i=n2;i<=n1;i++){\n            \n            sum = sum + i*i;\n    }\n        printf(\"sum = %d\",sum);\n        \n    }\n    else{\n        for(i=n1;i<=n2;i++){\n            \n            sum= sum + i*i;         \n        }\n        printf(\"sum = %d\",sum);\n    }\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nint main()\n{\n    int quantity_of_product;\n    float unit_price, revenue,discount;\n    printf(\"Enter quantity of product: \");\n    scanf(\"%d\",&quantity_of_product);\n    printf(\"\\nEnter the unit price: \");\n    scanf(\"%f\",&unit_price);\n    revenue=quantity_of_product*unit_price;\n    if(quantity_of_product>120 &&quantity_of_product<160)\n    {\n        discount=revenue*15\/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n        \n    }\n    else if(quantity_of_product>160)\n    {\n        discount=revenue*20\/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n        \n    }\n    else{\n        discount=revenue*0\/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n    }\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nint main(){\n    int num1,num2,num3;\n    int *p1,*p2,*p3;\n\n    printf(\"Enter Number 1 : \");\n    scanf(\"%d\",&num1);\n    printf(\"Enter Number 2 : \");\n    scanf(\"%d\",&num2);\n    printf(\"Enter Number 3 : \");\n    scanf(\"%d\",&num3);\n    printf(\"\\n\");\n    \n    p1 = &num1;\n    p2 = &num2;\n    p3 = &num3;\n    \n    \n    if(*p1 > *p2){\n        if(*p1 > *p3){\n            printf(\"Maximum is : %d\\n\",*p1);\n        }\n\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    else{\n        if(*p2 > *p3){\n            printf(\"Maximum is : %d\\n\",*p2);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    \n    \n    if(*p1 < *p2){\n        if(*p1 < *p3){\n            printf(\"Minimum is : %d\",*p1);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    else{\n        if(*p2 < *p3){\n            printf(\"Minimum is : %d\",*p2);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n    int *a,n,i,j,temp;\n    printf(\"Enter size of array:\");\n    scanf(\"%d\",&n);\n\n    a=calloc(sizeof(int),n);\n    printf(\"Enter %d Elements:\\n\",n);\n\n    for(i=0;i<n;i++){\n        printf(\"    element - %d : \",i);\n        scanf(\"%d\",a+i);\n    }\n\n    for(i=0;i<n-1;i++)\n    {\n        for(j=0;j<n-1;j++)\n        {\n            if(*(a+j)>*(a+j+1))\n            {\n                temp=*(a+j);\n                *(a+j)=*(a+j+1);\n                *(a+j+1)=temp;\n            }\n        }\n    }\n    printf(\"After sorting array :\\n\");\n    for(i=0;i<n;i++){\n        printf(\"%d \",*(a+i));\n    }\n    return 0;           \n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct student{\n    char name[50],address[60];\n    int no,id,age;\n    float marks;\n} s[10];\n\nint main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n\n    \n    for (i=0;i<11;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"\\nDisplaying Information:\\n\");\n\n    \n    for (i=0;i<11;i++){\n        if(s[i].age==14){\n            printf(\"Name : \");\n            puts(s[i].name);\n        }\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct complex{\n    float real;\n    float imag;\n}complex;\n\nstruct complex add(struct complex n1,struct complex n2);\nstruct complex subtract(struct complex n1,struct complex n2);\nstruct complex multiply(struct complex n1,struct complex n2);\nint main()\n{\n    struct complex n1,n2,result,result1,result2;\n    \n    printf(\"For 1st complex number \\n\");\n    printf(\"Enter the real parts : \");\n    scanf(\"%f\",&n1.real);\n    printf(\"Enter the imaginary parts : \");\n    scanf(\"%f\",&n1.imag);\n    printf(\"\\nFor 2nd complex number \\n\");\n    printf(\"Enter the real parts : \");\n    scanf(\"%f\",&n2.real);\n    printf(\"Enter the imaginary parts : \");\n    scanf(\"%f\",&n2.imag);\n    printf(\"\\n\");\n    \n    result=add(n1,n2);\n    printf(\"Sum value = %.1f + %.1fi\\n\", result.real, result.imag);\n    result1=subtract(n1,n2);\n    printf(\"Subtraction value = %.1f - %.1fi\\n\", result1.real, result1.imag);\n    result2=multiply(n1,n2);\n    printf(\"Multiply value = %.1f - %.1fi\\n\", result2.real, result2.imag);\n}\nstruct complex add(struct complex n1,struct  complex n2) {\n   struct  complex temp;\n    temp.real = n1.real + n2.real;\n    temp.imag = n1.imag + n2.imag;\n    return (temp);\n}\nstruct complex subtract(struct complex n1, struct complex n2) {\n    struct complex temp1;\n    temp1.real = n1.real - n2.real;\n    temp1.imag = n1.imag - n2.imag;\n    return (temp1);\n}\nstruct complex multiply(struct complex n1, struct complex n2) {\n    struct complex temp2;\n    temp2.real = n1.real * n2.real;\n    temp2.imag = n1.imag * n2.imag;\n    return (temp2);\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct Date{\n    int day;\n    int month;\n    int year;\n    int no;\n}d[2];\n\nint main(){\n    int i, j, key=0;\n\n    for(i=0; i<2; i++){\n        d[i].no = i+1;\n        printf(\"\\nEnter 0%d\\n\",d[i].no);\n        printf(\"Year : \");\n        scanf(\"%d\",&d[i].year);\n        printf(\"Month : \");\n        scanf(\"%d\",&d[i].month);\n        printf(\"Day : \");\n        scanf(\"%d\",&d[i].day);\n\n        if(d[i].month >12 || d[i].month<=0 ){\n            printf(\"Invalide Month...\\n\");\n\n            if(d[i].day >30 || d[i].day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            }\n\n            i--;\n        }else{\n            if(d[i].day >30 || d[i].day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            i--;\n            }\n        }\n\n\n    }\n\n\n    for(j=0; j<1; j++){\n        if(d[j].day==d[j+1].day){\n            if(d[j].month==d[j+1].month){\n                if(d[j].year==d[j+1].year){\n                    printf(\"Dates are equal..\\n\");\n                }\n                else{\n                    key = 1;\n                }\n            }\n            else{\n                key = 1;\n            }\n        }\n        else{\n            key = 1;\n        }\n    }\n\n    if(key==1){\n        printf(\"Dates are not equal.\\n\");\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"int main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n\n    \n    for (i=0;i<11;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"\\nDisplaying Information:\\n\");\n\n    \n    for (i=0;i<11;i++){\n        if(s[i].id%2==0){\n            printf(\"Name : \");\n            puts(s[i].name);\n        }\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct Date{\n    int day;\n    int month;\n    int year;\n}d;\n\nint main(){\n    int flag =0;\n\n    while(flag != 1){\n        flag = 1;\n        printf(\"Year : \");\n        scanf(\"%d\",&d.year);\n        printf(\"Month : \");\n        scanf(\"%d\",&d.month);\n        printf(\"Day : \");\n        scanf(\"%d\",&d.day);\n\n        if(d.month >12 || d.month<=0 ){\n            printf(\"Invalide Month...\\n\");\n\n            if(d.day >30 || d.day<=0 ){\n            printf(\"Invalide Date...\\n\");\n\n            flag =0;\n            }\n\n        }else{\n            if(d.day >30 || d.day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            flag =0;\n            }\n        }\n\n    }\n\n    d.day = d.day + 45;\n    if(d.day>30 && d.day<60){\n        d.day = d.day - 30;\n        d.month = d.month + 1;\n        if(d.month>12){\n            d.month = d.month-12;\n            d.year = d.year + 1;\n        }\n    }\n    else if(d.day>60){\n        d.day = d.day - 60;\n        d.month = d.month + 2;\n        if(d.month>12){\n            d.month = d.month-12;\n            d.year = d.year + 1;\n        }\n    }\n    printf(\"\\nAdd 45 days...\\n\");\n    printf(\"\\nUpdated date is : %d %d %d\", d.year, d.month, d.day);\n\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct customer{\n    char name[30];\n    int accNmbr,no;\n    int balance;\n}c[50];\n\nvoid minimumAcc(int bal, char name[]){\n    if(bal<200){\n        printf(\"%s\\n\", name);\n    }\n}\n\nvoid maximumAcc(int bal, char name[]){\n    if(bal>1000){\n        bal = bal + 100;\n        printf(\"Now %s's account balance is %d\", name, bal);\n    }\n}\n\nint main(){\n    int n,i,j;\n    printf(\"Enter the number of customers : \");\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<n;i++){\n        c[i].no = i+1;\n        printf(\"\\nCustomer 0%d\\n\",c[i].no);\n        printf(\"Enter name : \");\n        scanf(\"%s\",c[i].name);\n        printf(\"Enter Account Number : \");\n        scanf(\"%d\",&c[i].accNmbr);\n        printf(\"Enter balance : \");\n        scanf(\"%d\",&c[i].balance);\n    }\n    \n    printf(\"\\nCustomers having balance less than Rs.200\\n\");\n    for(j=0;j<n;j++){\n        minimumAcc(c[j].balance,c[j].name);\n    }\n    \n    printf(\"\\nCustomers having balanace greater than Rs.1000 are increased acc balance..\\n\");\n    for(j=0;j<n;j++){\n        maximumAcc(c[j].balance,c[j].name);\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef struct{\n    int a,e,i,o,u,other;\n}word;\n\nint main()\n{\n    word W;\n    char array[100];\n    FILE * fp;\n    int i=0;\n\n    fp = fopen(\"myword.txt\",\"a\");\n    printf(\"Enter your word: \");\n    gets(array);\n    fprintf(fp,array);\n\n    W.a = 0,W.e = 0,W.i = 0,W.o = 0,W.u = 0,W.other = 0;\n\n    while(strlen(array)>i){\n\n        if(array[i]=='a'||array[i]=='A'){\n            W.a=W.a + 1;\n        }\n\n        if(array[i]=='e'||array[i]=='E'){\n            W.e=W.e+1;\n        }\n\n        if(array[i]=='i'||array[i]=='I'){\n            W.i=W.i+1;\n        }\n\n        if(array[i]=='o'||array[i]=='O'){\n            W.o=W.o+1;\n        }\n\n        if(array[i]=='u'||array[i]=='U'){\n            W.u=W.u+1;\n        }\n\n        if(array[i] !='a' && array[i] != 'e' && array[i] != 'i' && array[i] != 'o'&& array[i] != 'u' && array[i] != 'A' && array[i] != 'E' && array[i] != 'I' && array[i] != 'O' && array[i] != 'U' ){\n            W.other=W.other+1;\n        }\n    i++;\n    }\n    fprintf(fp,\"\\t\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\",W.a,W.e,W.i,W.o,W.u,W.other,strlen(array));\n    fclose(fp);\n\n    fp=fopen(\"myword.txt\",\"a\");\n    fprintf(fp,\"\\n\");\n    fclose(fp);\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n\nstruct Marks {\n    int ID_no;\n    char name[30];\n    float chem_marks, maths_marks, phy_marks;\n};\n\nint main() {\n    \n    struct Marks marks[5];\n    int i;\n\n    for(i=0;i<1;i++){\n        printf(\"Student %d\\n\",i+1);\n        printf(\"Enter ID no. : \");\n        scanf(\"%d\",&marks[i].ID_no);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&marks[i].name);\n        printf(\"Enter Chemistry marks : \");\n        scanf(\"%f\",&marks[i].chem_marks);\n        printf(\"Enter Maths marks : \");\n        scanf(\"%f\",&marks[i].maths_marks);\n        printf(\"Enter Physics marks : \");\n        scanf(\"%f\",&marks[i].phy_marks);\n        \n        printf(\"\\n\");\n    }\n    \n    for(i=0;i<5;i++) {\n        printf(\"Student %d\\n\",i+1);\n        float percentage = (marks[i].chem_marks + marks[i].maths_marks + marks[i].phy_marks)\/3.0;\n        printf(\"Percentage : %f\\n\", percentage);\n    }\n  return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n    int id_number;\n    int anu_income;\n    int numOfMembers;\n    int t;\n}F;\nF fam[5];\nint IncomeSum=0;\nint Members=0;\n\nint sumOfIncome(int income){\n    IncomeSum=IncomeSum+income;\n    }\n\nint totalOfMembers(int mem,int i){\n    Members=Members+mem;\n    fam[i].t=Members;\n\n    }\n\nint main(){\n\n    FILE *fp;\n    fp=fopen(\"readme.txt\",\"r\");\n    int i=0,medianIncome;\n\n    while(i<5){\n        fscanf(fp,\"%d\\t\\t%d\\t\\t\\t%d\",&fam[i].id_number,&fam[i].anu_income,&fam[i].numOfMembers);\n        sumOfIncome(fam[i].anu_income);\n        totalOfMembers(fam[i].numOfMembers,i);\n        i++;\n    }\n\n    printf(\"IDNumber\\tAnnualIncome($)\\tNumberOfMembers\\n\\n\");\n    for(i=0;i<5;i++){\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",fam[i].id_number,fam[i].anu_income,fam[i].numOfMembers);\n    }\n\n    int avrgeIncm=IncomeSum\/5;\n    printf(\"\\nAverage household income($):%d\\n\",avrgeIncm);\n    printf(\"\\nTotal number of members in the town:%d\\n\",Members);\n    \n    int medianPoint=Members\/2;\n\n    for(i=0;i<5;i++){\n        if(medianPoint-fam[i].t<0){\n            medianIncome=fam[i].anu_income;\n            break;\n        }\n    }\n\n    printf(\"\\nMedian Annual Income($):%d\",medianIncome);\n\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\nstruct student{\n    char name[50],address[60];\n    int no,id,age;\n    float marks;\n} s[10];\n\nint main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n\n    \n    for (i=0;i<5;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"Displaying Information:\\n\\n\");\n\n    \n    for (i=0;i<5;++i){\n        printf(\"\\nStudent : %d\\n\",i+1);\n        printf(\"ID number : %d\\n\",s[i].id);\n        printf(\"Name : \");\n        puts(s[i].name);\n        printf(\"Age : %d\\n\",s[i].age);\n        printf(\"Address : \");\n        puts(s[i].address);\n        printf(\"Marks: %.1f\",s[i].marks);\n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"target":"kalpa96","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n    char Name[20];\n    int EmpNo;\n    float salary;\n    float OT;\n}Emp;\n\nint main(){\n    Emp e[4];\n    char array[1000];\n    FILE *fp;\n    int i;\n    float amount[4];\n\n    float total=0;\n    fp=fopen(\"data.txt\",\"r\");\n\n    while(!feof(fp)){\n\n        fgets(array,500,fp);\n        if(array[i]!='\\n'){\n            fscanf(fp,\"%s\\t\\t%d\\t\\t%f\\t\\t%f\",&e[i].Name,&e[i].EmpNo,&e[i].salary,&e[i].OT);\n        }\n        i++;\n    }\n\n    fclose(fp);\n     printf(\"Employee No\\tBasic salary\\tOT Hours\\tNet salary \\n\");\n    for(i=0;(sizeof(e)\/sizeof(e[0]))>i;i++){\n        amount[i]=e[i].salary+e[i].salary*0.35+e[i].OT*15;\n        printf(\"%d\\t\\t%.2f\\t%.2f\\t\\t%.2f\\n\",e[i].EmpNo,e[i].salary,e[i].OT,amount[i]);\n    }\n\n\n    for(i=0;(sizeof(amount)\/sizeof(amount[0]))>i;i++){\n        total=total+amount[i];\n    }\n\n    printf(\"\\nTotal Amount:%.2f\",total);\n\n}"}
{"target":"kbtomic","func":"#include \"ShuffleIslands.h\"\n#include \"RandomGenerator.h\"\n#include \"NumberOfIslands.h\"\nint Shuffle(islandPointer startIsland, int numberOfIslands)\n{\n    islandPointer islandToChange = startIsland->next;\n    islandPointer start = startIsland;\n    islandPointer prevOfIslandToChange = startIsland;\n    while(islandToChange->next)\n    {\n        prevOfIslandToChange = startIsland;\n        islandToChange = startIsland->next;\n        int randomIndex = GenerateRandom(start->next->index, numberOfIslands);\n        islandPointer changeWithMe = start;\n        islandPointer prevOfChangeWithMe = changeWithMe;\n        islandPointer nextOfChangeWithMe = changeWithMe->next;\n        while (changeWithMe->index != randomIndex)\n        {\n            prevOfChangeWithMe = changeWithMe;\n            changeWithMe = changeWithMe->next;\n            nextOfChangeWithMe = changeWithMe->next;\n        }\n        if (islandToChange->index != randomIndex)\n        {\n            if (islandToChange->next == changeWithMe)\n            {\n                prevOfIslandToChange->next = changeWithMe;\n                prevOfChangeWithMe->next = changeWithMe->next;\n                changeWithMe->next = islandToChange;\n                islandToChange->next = nextOfChangeWithMe;\n            }\n            else if (changeWithMe->next == islandToChange)\n            {\n                prevOfChangeWithMe->next = islandToChange;\n                prevOfIslandToChange->next = islandToChange->next;\n                changeWithMe->next = islandToChange->next;\n                islandToChange->next = changeWithMe;\n            }\n            else \n            {\n                prevOfIslandToChange->next = changeWithMe;\n                prevOfChangeWithMe->next = islandToChange;\n                changeWithMe->next = islandToChange->next;\n                islandToChange->next = nextOfChangeWithMe;\n            }\n        }\n        startIsland = startIsland->next;\n        if (!startIsland->next)\n            break;\n    }\n    return 0;\n}"}
{"target":"kbtomic","func":"#include \"Stack.h\"\n#include \"AllocateMemory.h\"\nislandPointer PopStack(stackPointer stackHead)\n{\n    stackPointer tempStackElement = stackHead->next, prev = stackHead->next;\n    if (!tempStackElement->next)\n        return NULL;\n    while (tempStackElement->next)\n    {\n        prev = tempStackElement;\n        tempStackElement = tempStackElement->next;\n    }\n    islandPointer island = tempStackElement->data;\n    prev->next = tempStackElement->next;\n    free(tempStackElement);\n    return island;\n}\nint PushStack(islandPointer current, stackPointer stackHead)\n{\n    stackPointer newStackElement;\n    stackPointer tempStackElement = stackHead;\n    if (newStackElement = AllocateMemoryForStack())\n    {\n        while (tempStackElement->next)\n            tempStackElement = tempStackElement->next;\n        newStackElement->next = tempStackElement->next;\n        tempStackElement->next = newStackElement;\n        newStackElement->data = current;\n        return 0;\n    }\n    else\n        return 1;\n}\nint CleanStack(stackPointer stackHead)\n{\n    stackPointer prev = stackHead->next, top = stackHead->next;\n    stackHead = stackHead->next;\n    while (top->next)\n    {\n        while (stackHead->next)\n        {\n            prev = stackHead;\n            stackHead = stackHead->next;\n        }\n        free(stackHead);\n        prev->next = NULL;\n        stackHead = top->next;\n        prev = top;\n    }\n    return 0;\n}\nstackPointer CreateStackHead()\n{\n    stackPointer stackHead = AllocateMemoryForStack();\n    stackHead->data = NULL;\n    stackHead->next = NULL;\n    return stackHead;\n}"}
{"target":"kbtomic","func":"#include \"Travels.h\"\n#include \"CoinCalculator.h\"\n#include \"Respawn.h\"\n#include \"Stack.h\"\n#include \"IslandType.h\"\nislandPointer TravelToLeftIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->leftNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->leftNext->coins);\n        currentIsland = currentIsland->leftNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}\nislandPointer TravelToRightIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->rightNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->rightNext->coins);\n        currentIsland = currentIsland->rightNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}\nislandPointer TravelToPrevIsland(islandPointer parentIsland, islandPointer currentIsland, stackPointer stackHead)\n{\n    printf(\"Vracamo se na prethodni otok: %s kako bi nastavio svoje putovanje u drugom smjeru\\n\", parentIsland->islandName);\n    PopStack(stackHead);\n    currentIsland = parentIsland;\n    return currentIsland;\n}\nislandPointer TravelToStartIsland(islandPointer start, islandPointer currentIsland, stackPointer stackHead)\n{\n    currentIsland = start;\n    CleanStack(stackHead);\n    return currentIsland;\n}"}
{"target":"kbtomic","func":"#include \"functions.h\"\n\npointerHash InitializeHashTable(int size)\n{\n    pointerHash table;\n    table = (pointerHash)malloc(sizeof(HashTable));\n    if (!table)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return table;\n    }\n    table->size = size;\n    table->hashList = (position*)malloc(sizeof(position) * size);\n    if (!table->hashList)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return table->hashList;\n    }\n    for (int i = 0; i < table->size; i++)\n        table->hashList[i] = NULL;\n    return table;\n}\nint CountKey(char* lastName)\n{\n    int lengthOfLastName = strlen(lastName);\n    int sum = 0, i = 0;\n    if (lengthOfLastName < LAST_NAME_LENGTH)\n    {\n        for (i = 0; i < lengthOfLastName; i++)\n            sum += lastName[i];\n    }\n    else\n    {\n        for (i = 0; i < LAST_NAME_LENGTH; i++)\n            sum += lastName[i];\n    }\n    return (sum % SIZE_OF_TABLE);\n}\nint InputStudentsFromFile(char* fileName, pointerHash hashTable)\n{\n    FILE* fp = NULL;\n    fp = fopen(fileName, \"r\");\n    if (!fp)\n    {\n        printf(\"Can't open file!\\n\");\n        return fp;\n    }\n    char fileFirstName[MAX_STRING_LENGTH];\n    char fileLastName[MAX_STRING_LENGTH];\n    char fileRegistrationNumber[MAX_STRING_LENGTH];\n\n    while (!feof(fp))\n    {\n        fscanf(fp, \"%s %s %s\\n\", fileFirstName, fileLastName, fileRegistrationNumber);\n        AddToHashTable(AllocateMemoryForStudent(fileFirstName, fileLastName, fileRegistrationNumber), hashTable);\n    }\n    fclose(fp);\n    return 0;\n}\nposition AllocateMemoryForStudent(char* firstName, char* lastName, char* registrationNumber)\n{\n    position newStudent = NULL;\n    newStudent = (position)malloc(sizeof(ListElement));\n    if (!newStudent)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return newStudent;\n    }\n    newStudent->next = NULL;\n    strcpy(newStudent->firstName, firstName);\n    strcpy(newStudent->lastName, lastName);\n    strcpy(newStudent->registrationNumber, registrationNumber);\n    return newStudent;\n}\nint AddToHashTable(position newStudent, pointerHash hashTable)\n{\n    int hashKey = CountKey(newStudent->lastName, hashTable->size);\n    if (!hashTable->hashList[hashKey])\n        hashTable->hashList[hashKey] = newStudent;\n    else\n    {\n        position currentStudent = hashTable->hashList[hashKey];\n        if (currentStudent && (strcmp(newStudent->lastName, currentStudent->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->firstName) < 0)))\n        {\n            hashTable->hashList[hashKey] = newStudent;\n            newStudent->next = currentStudent;\n        }\n        else \n        {\n            while (currentStudent->next)\n            {\n                if (strcmp(newStudent->lastName, currentStudent->next->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->next->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->next->firstName) < 0))\n                {\n                    newStudent->next = currentStudent->next;\n                    currentStudent->next = newStudent;\n                    break;\n                }\n                currentStudent = currentStudent->next;\n            }\n            if (!currentStudent->next)\n            {\n                newStudent->next = currentStudent->next;\n                currentStudent->next = newStudent;\n            }\n        }\n    }\n    return 0;\n}\nint PrintHashTable(pointerHash hashTable)\n{\n    printf(\"Hash table of students:\\n\\n\");\n    for (int i = 0; i < hashTable->size; i++)\n    {\n        int printMeOnce = 1;\n        position current = hashTable->hashList[i];\n        while (current)\n        {\n            if (printMeOnce == 1)\n            {\n                printf(\"Key:%d\\n\", i);\n                printMeOnce++;\n            }\n            printf(\"%s %s\\n\\n\", current->firstName, current->lastName);\n            current = current->next;\n        }\n    }\n    return 0;\n}\nint FindStudent(char* lastName, char* firstName, pointerHash hashTable)\n{\n    int hashKey = CountKey(lastName);\n    position currentStudent = hashTable->hashList[hashKey];\n    int isFound = 0;\n    while (currentStudent && !isFound)\n    {\n        if (strcmp(currentStudent->lastName, lastName) == 0 && strcmp(currentStudent->firstName, firstName) == 0)\n        {\n            printf(\"Registration number for %s %s is:%s\\n\", currentStudent->firstName, currentStudent->lastName, currentStudent->registrationNumber);\n            isFound = 1;\n        }\n        currentStudent = currentStudent->next;\n    }\n    if (!isFound)\n    {\n        printf(\"Student does not exist!\\n\");\n    }\n    return 0;\n}\n"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n    char ime[10];\n    char prezime[10];\n    double bodovi;\n}student;\nint upis(FILE* fp, student* s, int n);\nint main()\n{\n    int n = 0;\n    FILE* fp = NULL;\n    fp = fopen(\"studenti.txt\", \"r\");\n    if (fp == NULL)\n    {   \n        printf(\"Datoteka nije pronadena!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        if (fgetc(fp) == '\\n')\n            n++;\n    }\n    \n    student* stud = NULL;\n    stud = (student*)malloc(n * sizeof(student));\n    if (stud == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n    }\n    rewind(fp);\n    upis(fp, stud, n);\n    fclose(fp);\n    return 0;\n}\nint upis(FILE* fp, student* s, int n)\n{\n    int i, max = 100;\n    double r;\n    for (i = 0; i < n; i++)\n    {\n        fscanf(fp, \"%s %s %lf\\n\", (*(s + i)).ime, (*(s + i)).prezime, &(*(s + i)).bodovi);\n        r = s[i].bodovi \/ max * 100;\n        printf(\"Ime i prezime: %s \\t%s\\t Bodovi: %.2lf\\t  Relativni bodovi: %.2lf\\n\", (*(s + i)).ime, (*(s + i)).prezime, (*(s + i)).bodovi, r);\n    }\n    return 0;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX_NAME_OF_FILE 30\n\ntypedef struct treeNode* treePointer;\ntypedef struct stack* stackPointer;\nstruct treeNode\n{\n    char data;\n    treePointer left;\n    treePointer right;\n};\nstruct stack\n{\n    stackPointer next;\n    treePointer nextTree;\n};\ntreePointer ReadFromFile(char*, treePointer, stackPointer);\nint Push(stackPointer, char);\nstackPointer AllocateMemoryForStackElement(stackPointer, char);\ntreePointer AllocateMemoryForTree(char);\ntreePointer Pop(stackPointer);\ntreePointer EditTree(treePointer, treePointer, treePointer);\nint CreateTree(treePointer, stackPointer);\nint WriteInFile(char *, treePointer);\nint InOrderPrintInFile(FILE*, treePointer);\nint main()\n{\n    stackPointer head = (stackPointer)malloc(sizeof(struct stack));\n    head->next = NULL;\n    treePointer root = NULL;\n    char readFile[MAX_NAME_OF_FILE] = \"postfix.txt\";\n    char writeFile[MAX_NAME_OF_FILE] = \"infix.txt\";\n    root = ReadFromFile(readFile, root, head);\n    WriteInFile(writeFile, root);\n    return 0;\n}\ntreePointer ReadFromFile(char* nameOfFile, treePointer root, stackPointer head)\n{\n    char sign;\n    treePointer rightChild = NULL;\n    treePointer leftChild = NULL;\n    FILE* fp = NULL;\n    fp = fopen(nameOfFile, \"r\");\n    if (!fp)\n    {\n        printf(\"Greska kod otvaranja datoteke!\\n\");\n        return fp;\n    }\n    while (!feof(fp))\n    {\n        fscanf(fp, \"%c \", &sign);\n        if (sign == '+' || sign == '-' || sign == '*' || sign == '\/')\n        {\n            root = AllocateMemoryForTree(sign);\n            rightChild = Pop(head);\n            leftChild = Pop(head);\n            root = EditTree(root, rightChild, leftChild);\n            CreateTree(root, head);\n        }\n        else\n            Push(head, sign);\n    }\n    root = head->next->nextTree;\n    fclose(fp);\n    return root;\n}\nint Push(stackPointer head, char sign)\n{\n    stackPointer newStackElement = AllocateMemoryForStackElement(head, sign);\n    newStackElement->next = head->next;\n    head->next = newStackElement;\n    return 0;\n}\nstackPointer AllocateMemoryForStackElement(stackPointer head, char sign)\n{\n    stackPointer newStackElement = (stackPointer)malloc(sizeof(struct stack));\n    if (!newStackElement)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return newStackElement;\n    }\n    newStackElement->next = NULL;\n    newStackElement->nextTree = AllocateMemoryForTree(sign);\n    return newStackElement;\n}\ntreePointer AllocateMemoryForTree(char sign)\n{\n    treePointer newTreeNode = (treePointer)malloc(sizeof(struct treeNode));\n    if (!newTreeNode)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return newTreeNode;\n    }\n    newTreeNode->left = NULL;\n    newTreeNode->right = NULL;\n    newTreeNode->data = sign;\n    return newTreeNode;\n}\ntreePointer Pop(stackPointer head)\n{\n    stackPointer deletedStackElement = head->next;\n    treePointer returnedTree = NULL;\n    head->next = deletedStackElement->next;\n    returnedTree = deletedStackElement->nextTree;\n    free(deletedStackElement);\n    return returnedTree;\n}\ntreePointer EditTree(treePointer root, treePointer rightChild, treePointer leftChild)\n{\n    root->right = rightChild;\n    root->left = leftChild;\n    return root;\n}\nint CreateTree(treePointer root, stackPointer head)\n{\n    stackPointer nodeToAdd = (stackPointer)malloc(sizeof(struct stack));\n    if (!nodeToAdd)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    nodeToAdd->next = head->next;\n    head->next = nodeToAdd;\n    nodeToAdd->nextTree = root;\n    return 0;\n}\nint WriteInFile(char* nameOfFile, treePointer root)\n{\n    FILE* fp = NULL;\n    fp = fopen(nameOfFile, \"w\");\n    if (!fp)\n    {\n        printf(\"Greska kod otvaranja datoteke!\\n\");\n        return 1;\n    }\n    InOrderPrintInFile(fp, root);\n    fclose(fp);\n    return 0;\n}\nint InOrderPrintInFile(FILE* fp, treePointer root)\n{\n    if (root)\n    {\n        InOrderPrintInFile(fp, root->left);\n        fprintf(fp, \"%c \", root->data);\n        InOrderPrintInFile(fp, root->right);\n    }\n    return 0;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct polinom* pozicija;\nstruct polinom {\n    int koeficijent;\n    int eksponent;\n    pozicija next;\n};\nint unosPrvi(pozicija);\nint unosDrugi(pozicija);\nint ispis(pozicija);\nint zbroj(pozicija, pozicija, pozicija);\nint umnozak(pozicija, pozicija, pozicija);\nint main() {\n    struct polinom Head1;\n    struct polinom Head2;\n    struct polinom HeadZ;\n    struct polinom HeadM;\n    Head1.next = NULL;\n    Head2.next = NULL;\n    HeadZ.next = NULL;\n    HeadM.next = NULL;\n    unosPrvi(&Head1);\n    unosDrugi(&Head2);\n    printf(\"Ispis prvog polinoma:\\n\");\n    ispis(Head1.next);\n    printf(\"Ispis drugog polinoma:\\n\");\n    ispis(Head2.next);\n    zbroj(&Head1, &Head2, &HeadZ);\n    printf(\"Ispis zbrojenog polinoma:\\n\");\n    ispis(HeadZ.next);\n    umnozak(&Head1, &Head2, &HeadM);\n    printf(\"Ispis pomnozenih polinoma:\\n\");\n    ispis(HeadM.next);\n    return 0;\n}\nint unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"pol1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct polinom));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d %d\", &q->koeficijent, &q->eksponent);\n        while (temp != NULL && temp->eksponent < q->eksponent)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}\nint unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"pol2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct polinom));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d %d\", &q->koeficijent, &q->eksponent);\n        while (temp != NULL && temp->eksponent < q->eksponent)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n    return 0;\n}\nint ispis(pozicija p)\n{\n    while (p != NULL)\n    {\n        printf(\"Koeficijent je: %d Eksponent je: %d\\n\", p->koeficijent, p->eksponent);\n        p = p->next;\n    }\n    return 0;\n}\nint zbroj(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct polinom));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n\n        if (p->next->eksponent < q->next->eksponent)\n        {\n            s->eksponent = p->next->eksponent;\n            s->koeficijent = p->next->koeficijent;\n            p = p->next;\n        }\n        else if (p->next->eksponent > q->next->eksponent)\n        {\n            s->eksponent = q->next->eksponent;\n            s->koeficijent = q->next->koeficijent;\n            q = q->next;\n        }\n        else\n        {\n            s->eksponent = p->next->eksponent;\n            s->koeficijent =(p->next->koeficijent + q->next->koeficijent);\n            p = p->next;\n            q = q->next;\n        }\n        r->next = s;\n        r = s;\n    }\n    pozicija temp;\n    if (p->next == NULL)\n        temp = q->next;\n    else\n        temp = p->next;\n    while (temp != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct polinom));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n        s->eksponent = temp->eksponent;\n        s->koeficijent = temp->koeficijent;\n        r->next = s;\n        r = s;\n        temp = temp->next;\n    }\n    return 0;\n}\nint umnozak(pozicija p, pozicija q, pozicija r)\n{\n    pozicija prvi = p->next;\n    pozicija drugi = q->next;\n    struct polinom P;\n    pozicija s = NULL;\n    s = (pozicija)malloc(sizeof(struct polinom));\n    if (s == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    s->next = NULL;\n    P.next = s;\n    while (prvi != NULL)\n    {\n        drugi = q->next;\n        while (drugi != NULL)\n        {\n\n            s->koeficijent = prvi->koeficijent * drugi->koeficijent;\n            s->eksponent = prvi->eksponent + drugi->eksponent;\n\n            zbroj(&P, r, r);\n            drugi = drugi->next;\n        }\n        prvi = prvi->next;\n    }\n\n    return 0;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS \n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct lista* pozicija;\nstruct lista {\n    int el;\n    pozicija next;\n};\nint unija(pozicija, pozicija, pozicija);\nint presjek(pozicija, pozicija, pozicija);\nint unosPrvi(pozicija);\nint unosDrugi(pozicija);\nint ispis(pozicija);\nint main()\n{\n    struct lista Head1;\n    struct lista Head2;\n    struct lista HeadU;\n    struct lista HeadP;\n    Head1.next = NULL;\n    Head2.next = NULL;\n    HeadU.next = NULL;\n    HeadP.next = NULL;\n    unosPrvi(&Head1);\n    unosDrugi(&Head2);\n    printf(\"Prva lista:\\n\");\n    ispis(Head1.next);\n    printf(\"Druga lista:\\n\");\n    ispis(Head2.next);\n    unija(&Head1, &Head2, &HeadU);\n    printf(\"Ispis unije listi:\\n\");\n    ispis(HeadU.next);\n    presjek(&Head1, &Head2, &HeadP);\n    printf(\"Ispis presjeka listi:\\n\");\n    ispis(HeadP.next);\n\n    return 0;\n}\nint unija(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct lista));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n        if (p->next->el == q->next->el) \n        {\n            s->el = p->next->el;\n            p = p->next;\n            q = q->next;\n        }\n        else if(p->next->el < q->next->el) \n        {\n            s->el = p->next->el;\n            p = p->next;\n        }\n        else\n        {\n            s->el = q->next->el;\n            q = q->next;\n        }\n        r->next = s;\n        r = s;\n    }\n    if (p->next == NULL) \n    {\n        while (q->next != NULL)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = q->next->el;\n            q = q->next;\n            r->next = s;\n            r = s;\n        }\n        \n    }\n    else \n    {\n        while (p->next != NULL)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = p->next->el;\n            p = p->next;\n            r->next = s;\n            r = s;\n        }\n        \n    }\n    \n    return 0;\n}\nint presjek(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL) \n    {\n        if (p->next->el == q->next->el)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = p->next->el;\n            p = p->next;\n            q = q->next;\n            r->next = s;\n            r = s;\n        }\n        else if (p->next->el < q->next->el) \n            p = p->next;\n        else\n            q = q->next;\n    }\n    return 0;\n}\nint unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        \n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}\nint unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}\nint ispis(pozicija p)\n{\n    while (p != NULL)\n    {\n        printf(\"Element liste je: %d\\n\", p->el);\n        p = p->next;\n    }\n    return 0;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n#include <time.h>\n#define MIN 10\n#define MAX 100\ntypedef struct cvor* pozicija;\nstruct cvor {\n    int el;\n    pozicija next;\n};\nint stog(pozicija);\nint red(pozicija);\nint push(pozicija);\nint pop(pozicija);\nint pushR(pozicija);\nint ispis(pozicija);\nint main()\n{\n    srand(time(NULL));\n    struct cvor HeadS;\n    HeadS.next = NULL;\n    struct cvor HeadR;\n    HeadR.next = NULL;\n    char c;\n    while (1) {\n        printf(\"Unesi 1 za implementaciju stoga, a 2 za implementaciju reda, 0 za izlaz iz programa\\n\");\n        scanf(\" %c\", &c);\n        if (c == '1')\n            stog(&HeadS);\n        else if (c == '2')\n            red(&HeadR);\n        else if (c == '0')\n            break;\n        else\n            printf(\"Nisi unio ispravni broj!\\n\");\n    }\n\n\n    return 0;\n}\nint stog(pozicija p)\n{\n    char c;\n    while (1) {\n        printf(\"Unesi N za unos novog elementa stoga, M za micanje postojeceg elementa stoga, I za ispis elemenata stoga, X za izlaz\\n\");\n        scanf(\" %c\", &c);\n        if (c == 'N')\n            push(p);\n        else if (c == 'M')\n            pop(p);\n        else if (c == 'I')\n            ispis(p->next);\n        else if (c == 'X')\n            break;\n        else\n            printf(\"Nisi unio ispravno slovo!\\n\");\n    }\n    return 0;\n}\nint red(pozicija p)\n{\n    char c;\n    while (1) {\n        printf(\"Unesi N za unos novog elementa reda, M za micanje postojeceg elementa reda, I za ispis elemenata reda, X za izlaz\\n\");\n        scanf(\" %c\", &c);\n        if (c == 'N')\n            pushR(p);\n        else if (c == 'M')\n            pop(p);\n        else if (c == 'I')\n            ispis(p->next);\n        else if (c == 'X')\n            break;\n        else\n            printf(\"Nisi unio ispravno slovo!\\n\");\n    }\n    return 0;\n}\nint ispis(pozicija p)\n{\n    while (p != NULL)\n    {\n        printf(\"Element je: %d\\n\", p->el);\n        p = p->next;\n    }\n    return 0;\n}\nint push(pozicija p)\n{ \n    pozicija q = NULL;\n    q = (pozicija)malloc(sizeof(struct cvor));\n    if (q == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    int broj = (rand() % (MAX - MIN + 1)) + MIN;\n    q->el = broj;\n    q->next = p->next;\n    p->next = q;\n\n    return 0;\n}\nint pop(pozicija p)\n{ \n    pozicija q = NULL;\n    if (p->next == NULL)\n        printf(\"Nisi jos dodao niti jedan element!\\n\");\n    else\n    {\n        printf(\"Skidamo element:%d\\n\", p->next->el);\n        q = p->next;\n        p->next = q->next;\n        free(q);\n    }\n    return 0;\n}\nint pushR(pozicija p)\n{ \n    pozicija q = NULL;\n    q = (pozicija)malloc(sizeof(struct cvor));\n    if (q == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n     pozicija kraj = NULL;\n    if (p->next == NULL)\n        kraj = p;\n    int broj = (rand() % (MAX - MIN + 1)) + MIN;\n    q->el = broj;\n    q->next = NULL;\n    kraj->next = q;\n    kraj = q;\n    return 0;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\ntypedef struct stog* pozicija;\nstruct stog {\n    int el;\n    pozicija next;\n};\nint push(pozicija head, int element);\nint pop(pozicija head);\nint dat(pozicija head);\nint zbroj(pozicija head);\nint razlika(pozicija head);\nint umnozak(pozicija head);\nint kvocijent(pozicija head);\nint main()\n{\n    struct stog Head;\n    Head.next = NULL;\n    dat(&Head);\n    printf(\"Rezultat je %d\\n\", Head.next->el);\n    return 0;\n}\nint dat(pozicija head)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"postfix.txt\", \"r\");\n    char operacija[15];\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        int br = 0;\n        int procitani = sscanf(fp, \"%d\", &br);\n        if (!procitani) {\n            if (!strcmp(procitani, \"+\"))\n                zbroj(head);\n            else if (!strcmp(procitani, \"-\"))\n                razlika(head);\n            else if (!strcmp(procitani, \"*\"))\n                umnozak(head);\n            else if (!strcmp(procitani, \"\/\"))\n                kvocijent(head);\n        }\n        else\n            push(head, procitani);\n    }\n    fclose(fp);\n    return 0;\n\n}\nint push(pozicija head, int element)\n{\n    pozicija novi;\n    novi = (pozicija)malloc(sizeof(struct stog));\n    if (novi == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    novi->el = element;\n    novi->next = head->next;\n    head->next = novi;\n\n    return 0;\n}\nint pop(pozicija head)\n{\n    pozicija temp = NULL;\n    int element;\n    if (head == NULL)\n        printf(\"Stog je prazan!\\n\");\n    else {\n        temp = head->next;\n        element = temp->el;\n        head->next = temp->next;\n        free(temp);\n    }\n    return element;\n}\nint zbroj(pozicija head)\n{\n    int prviBroj = pop(head);\n    int drugiBroj = pop(head);\n    push(head, drugiBroj + prviBroj);\n    return 0;\n}\nint razlika(pozicija head)\n{\n    int prviBroj = pop(head);\n    int drugiBroj = pop(head);\n    push(head, drugiBroj - prviBroj);\n    return 0;\n}\nint umnozak(pozicija head)\n{\n    int prviBroj = pop(head);\n    int drugiBroj = pop(head);\n    push(head, drugiBroj * prviBroj);\n    return 0;\n}\nint kvocijent(pozicija head)\n{\n    int prviBroj = pop(head);\n    int drugiBroj = pop(head);\n    push(head, drugiBroj \/ prviBroj);\n    return 0;\n}\n"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct treeNode* treePointer;\nstruct treeNode\n{\n    int data;\n    treePointer left;\n    treePointer right;\n};\ntreePointer AllocateMemory(int);\ntreePointer InsertElement(int, treePointer);\nint InOrderPrint(treePointer);\nint PostOrderPrint(treePointer);\nint PreOrderPrint(treePointer);\ntreePointer DeleteElement(int, treePointer);\ntreePointer FindMin(treePointer);\ntreePointer FindElement(int, treePointer);\nint main()\n{\n    treePointer root = NULL;\n    root = InsertElement(2, root);\n    root = InsertElement(4, root);\n    root = InsertElement(9, root);\n    root = InsertElement(1, root);\n    root = InsertElement(11, root);\n    root = InsertElement(7, root);\n    root = DeleteElement(2, root);\n    int choice = 0, element;\n    treePointer temp = NULL;\n\n    do\n    {\n        printf(\"Odaberi:\\n\");\n        printf(\"1 - unos novog elementa u stablo\\n\");\n        printf(\"2 - ispis inorder stabla\\n\");\n        printf(\"3 - ispis postorder stabla\\n\");\n        printf(\"4 - ispis preorder stabla\\n\");\n        printf(\"5 - trazenje elementa stabla\\n\");\n        printf(\"6 - brisanje elementa iz stabla\\n\");\n        printf(\"7 - izlaz\\n\");\n\n        scanf(\"%d\", &choice);\n        system(\"cls\");\n        switch (choice)\n        {\n        case 1:\n            printf(\"Unesi element koji zelis unijeti u stablo:\\n\");\n            scanf(\"%d\", &element);\n            root = InsertElement(element, root);\n            break;\n        case 2:\n            InOrderPrint(root);\n            break;\n        case 3:\n            PostOrderPrint(root);\n            break;\n        case 4:\n            PreOrderPrint(root);\n            break;\n        case 5:\n            printf(\"Unesi element koji trazis u stablu:\\n\");\n            scanf(\"%d\", &element);\n            temp = FindElement(element, root);\n            if (temp)\n                printf(\"Element %d se nalazi na adresi %d\\n\", temp->data, temp);\n            break;\n        case 6:\n            printf(\"Unesi element koji brises iz stabla:\\n\");\n            scanf(\"%d\", &element);\n            root = DeleteElement(element, root);\n        case 7:\n            break;\n        default:\n            printf(\"Pogresan unos!\\n\");\n        }\n    } while (choice != '7');\n    return 0;\n}\ntreePointer AllocateMemory(int element)\n{\n    treePointer newNode = (treePointer)malloc(sizeof(struct treeNode));\n    if (!newNode)\n    {\n        printf(\"Problem s alokacijom memorije!\\n\");\n        return newNode;\n    }\n    newNode->data = element;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n\n}\ntreePointer InsertElement(int element, treePointer root)\n{\n    if (!root)\n        return AllocateMemory(element);\n    else if (element < root->data)\n        root->left = InsertElement(element, root->left);\n    else if (element > root->data)\n        root->right = InsertElement(element, root->right);\n    return root;\n}\nint InOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        InOrderPrint(root->left);\n        printf(\"%d\\n\", root->data);\n        InOrderPrint(root->right);\n    }\n    return 0;\n}\nint PostOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        PostOrderPrint(root->left);\n        PostOrderPrint(root->right);\n        printf(\"%d\\n\", root->data);\n    }\n    return 0;\n}\nint PreOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        printf(\"%d\\n\", root->data);\n        PreOrderPrint(root->left);\n        PreOrderPrint(root->right);\n    }\n    return 0;\n}\ntreePointer DeleteElement(int element, treePointer root)\n{\n    treePointer temp;\n    if (!root)\n        return root;\n    else if (element < root->data)\n        root->left = DeleteElement(element, root->left);\n    else if (element > root->data)\n        root->right = DeleteElement(element, root->right);\n    else\n    {\n        if (root->left && root->right)\n        {\n            temp = FindMin(root->right);\n            root->data = temp->data;\n            root->right = DeleteElement(temp->data, root->right);\n        }\n        else\n        {\n            temp = root;\n            if (!root->left)\n                root = root->right;\n            else if (!root->right)\n                root = root->left;\n            free(temp);\n        }\n    }\n    return root;\n}\ntreePointer FindMin(treePointer root)\n{\n    while (root->left)\n        root = root->left;\n    return root;\n}\ntreePointer FindElement(int element, treePointer root)\n{\n    if (!root)\n        return root;\n    else if (element < root->data)\n        return FindElement(element, root->left);\n    else if (element > root->data)\n        return FindElement(element, root->right);\n    else\n        return root;\n}"}
{"target":"kbtomic","func":"#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\n\n#define MAX_DIR_LENGTH 256\n\ntypedef struct dir* Position;\ntypedef struct stack* StackPosition;\ntypedef struct dir {\n    char name[MAX_DIR_LENGTH];\n    Position sibling;\n    Position child;\n}Dir;\n\ntypedef struct stack {\n    Position data;\n    StackPosition next;\n} Stack;\nPosition AllocateMemoryForDirectory();\nStackPosition AllocateMemoryForStack();\nint PushStack(Position, StackPosition);\nPosition PopStack(StackPosition);\nPosition MakeDirectory(Position, char*);\nPosition ChangeDirectory(Position, StackPosition, char*);\nPosition ChangeToPreviousDirectory(StackPosition);\nint PrintDirectory(Position);\nint Path(Position, StackPosition);\nint CommandPrompt(Position current, StackPosition stackHead);\nvoid Remove(Position);\nint main()\n{\n    Dir C;\n    C.sibling = NULL;\n    C.child = NULL;\n    strcpy(C.name, \"C:\");\n\n    Stack stackHead;\n    stackHead.data = NULL;\n    stackHead.next = NULL;\n\n    PushStack(&C, &stackHead);\n    CommandPrompt(&C, &stackHead);\n\n    return 0;\n}\nPosition PopStack(StackPosition stackHead)\n{\n    StackPosition tempStackElement = stackHead->next, prev = stackHead->next;\n    if (!tempStackElement->next)\n        return NULL;\n    while (tempStackElement->next)\n    {\n        prev = tempStackElement;\n        tempStackElement = tempStackElement->next;\n    }\n        Position directory = tempStackElement->data;\n        prev->next = tempStackElement->next;\n        free(tempStackElement);\n        return directory;\n}\nint PushStack(Position current, StackPosition stackHead)\n{\n    StackPosition newStackElement;\n    StackPosition tempStackElement = stackHead;\n    if (newStackElement = AllocateMemoryForStack()) \n    {\n        while (tempStackElement->next)\n            tempStackElement = tempStackElement->next;\n        newStackElement->next = tempStackElement->next;\n        tempStackElement->next = newStackElement;\n        newStackElement->data = current;\n        return 0;\n    }\n    else\n        return 1;\n}\nint PrintDirectory(Position current)\n{\n    if (!current->child)\n        printf(\"Directory is empty!\\n\");\n    else\n    {\n        current = current->child;\n        while (current)\n        {\n            printf(\" %s\\n\", current->name);\n            current = current->sibling;\n        }\n    }\n    return 0;\n}\nPosition ChangeToPreviousDirectory(StackPosition stackHead)\n{\n    return PopStack(stackHead);\n}\nPosition ChangeDirectory(Position current, StackPosition stackHead, char* name)\n{\n    if (!current->child)\n    {\n        \n        return current;\n    }\n    else\n    {\n        Position parent = current;\n        Position finderOfWantedDirectory = current->child;\n        while (finderOfWantedDirectory)\n        {\n            if (!strcmp(finderOfWantedDirectory->name, name))\n            {\n                PushStack(finderOfWantedDirectory, stackHead);\n                return finderOfWantedDirectory;\n            }\n            finderOfWantedDirectory = finderOfWantedDirectory->sibling;\n        }\n        \n        return parent;\n    }\n}\nPosition MakeDirectory(Position current, char* name)\n{\n    Position newDirectory;\n    newDirectory = AllocateMemoryForDirectory();\n\n    strcpy(newDirectory->name, name);\n        if (!current->child)\n        {\n            current->child = newDirectory;\n        }\n        else\n        {\n            Position currentChild = current->child;\n            while (currentChild->sibling)\n                currentChild = currentChild->sibling;\n            currentChild->sibling = newDirectory;\n        }\n        return current;\n}\nStackPosition AllocateMemoryForStack()\n{\n    StackPosition newStackElement = (StackPosition)malloc(sizeof(Dir));\n    if (!newStackElement)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    return newStackElement;\n}\nPosition AllocateMemoryForDirectory()\n{\n    Position newDirectory = (Position)malloc(sizeof(Dir));\n    if (!newDirectory)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    newDirectory->child = NULL;\n    newDirectory->sibling = NULL;\n    return newDirectory;    \n}\nvoid Remove(Position current)\n{\n    if (!current)\n        return;\n    remove(current->sibling);\n    remove(current->child);\n    \n}\nint Path(Position current, StackPosition stackHead)\n{\n    char stringToPrint[MAX_DIR_LENGTH] = \"\";\n    \n    while (stackHead)\n    {\n            strcat(stringToPrint, stackHead->data->name);\n            strcat(stringToPrint, \"\\\\\");\n            stackHead = stackHead->next;\n    }\n    strcat(stringToPrint, \">\");\n    printf(\"%s \", stringToPrint);\n    return 0;\n}\nint CommandPrompt(Position current, StackPosition stackHead)\n{\n    Position C = current;\n    char userInput[MAX_DIR_LENGTH];\n    char command[5];\n    char directoryName[MAX_DIR_LENGTH];\n    Path(current, stackHead->next);\n    do {\n        fgets(userInput, MAX_DIR_LENGTH, stdin);\n        sscanf(userInput, \"%s %s\", command, directoryName);\n        if (!strcmp(command, \"md\"))\n        {\n            current = MakeDirectory(current, directoryName);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"cd\"))\n        {\n            current = ChangeDirectory(current, stackHead, directoryName);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"cd..\"))\n        {\n            if (current = ChangeToPreviousDirectory(stackHead) == NULL)\n                current = C;\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"dir\"))\n        {\n            PrintDirectory(current);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"exit\"))\n            Remove(current);\n        else\n            printf(\"That's not an option!\");\n    } while (strcmp(command, \"exit\"));\n    return 0;\n}"}
{"target":"mandarvu","func":"#include <stdio.h>\n\nint main()\n{\n    int A[3][3],B[3][3],AB[3][3]={{0,0,0},{0,0,0},{0,0,0}};\n    int ii,row,col;\n    printf(\"Enter a 3*3 matrix A row wise.\");\n\n    for (ii = 0; ii < 3; ii++)\n    {\n        printf(\"\\nRow %d >>> \",ii + 1);\n        scanf(\"%d %d %d\",(*(A + ii)+0),(*(A + ii)+1),(*(A +ii)+2));\n    }\n    printf(\"The matrix is A =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(A + ii)+0),*(*(A + ii)+1),*(*(A +ii)+2));\n    printf(\"Enter a 3*3 matrix B row wise.\");\n\n    for (ii = 0; ii < 3; ii++)\n    {\n        printf(\"\\nRow %d >>> \",ii + 1);\n        scanf(\"%d %d %d\",(*(B + ii)+0),(*(B + ii)+1),(*(B +ii)+2));\n    }\n    printf(\"The matrix is B =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(B + ii)+0),*(*(B + ii)+1),*(*(B +ii)+2));\n\n    for (row=0;row<3;row++)\n    {\n        for (col=0;col<3;col++)\n        {\n            for (ii=0;ii<3;ii++)\n            {\n                *(*(AB+row)+col) += *(*(A+row)+ii) * *(*(B+ii)+col);\n            }\n        }\n    }\n    printf(\"The matrix is AB =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(AB + ii)+0),*(*(AB + ii)+1),*(*(AB +ii)+2));\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n\nvoid main() {\n  int mat1[2][2], mat2[2][2], mat[2][2];\n\n  printf(\"Enter values in matrix 1(2*2) row-wise (a11, a12, a21, a22): \");\n  for (int i = 0; i < 2; i++)\n    scanf(\"%d %d\",*(mat1 + i) + 0, *(mat1 + i) + 1 );\n\n  printf(\"Enter values in matrix 2(2*2) row-wise (a11, a12, a21, a22): \");\n  for (int i = 0; i < 2; i++)\n    scanf(\"%d %d\",*(mat2 + i) + 0, *(mat2 + i) + 1 );\n\n  printf(\"\\nMatrix 1(2*2)\\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",*(*(mat1 + i) + 0), *(*(mat1 + i) + 1));\n    printf(\"\\n\");\n  }\n\n  printf(\"\\nMatrix 2(2*2)\\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",*(*(mat2 + i) + 0), *(*(mat2 + i) + 1));\n    printf(\"\\n\");\n  }\n\n  printf(\"\\nMatrix1 + Matrix2 = \\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",mat1[i][0] + mat2[i][0], mat1[i][1] + mat2[i][1]);\n    printf(\"\\n\");\n  }\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 20\n\nvoid string_reverse(char *origin, char *rev) {\n  int f = 0, cnt = 0, j = 0;\n  while ( *(origin + f) != '\\0' ) {\n    cnt++;\n    f++;\n  }\n  for (int i = cnt - 1; i >= 0; i--)\n  {\n    *(rev + j) = *(origin + i);\n    j++;\n  }\n  *(rev + j) = '\\0';\n}\n\nint pal_chk(char *norm, char *rev) {\n  while (*(norm) != '\\0') {\n    if (*norm == *rev) {\n      norm++;\n      rev++;\n    }\n    else\n      return 0;\n  }\n  return 1;\n}\n\nint main() {\n  char origin[MAX], reverse[MAX];\n\n  printf(\"Enter a string (20): \");\n  scanf(\"%[^\\n]%*c\", origin);\n\n  string_reverse(origin, reverse);\n\n  if (pal_chk(origin, reverse))\n    printf(\"The string ' %s ' is a Palindrome\\n\", origin);\n  else\n    printf(\"The string ' %s ' is not a Palindrome\\n\", origin);\n\n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 25 \n\n\nvoid string_reverse(char *, char *);\n\nint main () {\n    char source[MAX], final[MAX]; \n    printf(\"Enter a string (max %d characters): \", MAX);\n    \n    fgets(source, MAX, stdin); \n    printf(\"%s \\n\", source);\n    string_reverse(source, final); \n    printf(\"%s \\n\", final);\n    return 0;\n}\n\nvoid string_reverse(char *origin, char *rev) {\n    int f = 0, cnt = 0, j = 0; \n    \n    \n    \n    while ( *(origin + f) != '\\0' ) { \n        cnt++;\n        f++;\n    }\n    \n    for (int i = cnt - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n    \n    *(rev + j) = '\\0'; \n    \n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 5\n\nvoid insertion(int *,int *, int, int);\n\nint main() {\n  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX + 1], pos, input; \n\n  printf(\"The array is\\n\");\n\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(nums + i));\n\n  printf(\"\\nEnter a number and position:\");\n  scanf(\"%d %d\", &input, &pos );\n\n  insertion(nums, target, input, pos);\n\n  printf(\"The array is\\n\");\n\n  for (int i = 0; i < MAX + 1; i++)\n    printf(\"%d\\t\",  *(target + i));\n\n  return 0;\n}\n\nvoid insertion(int *source, int *target, int number, int position) {\n  int j = 0;\n\n  for (j = 0; j < MAX + 1; j++) { \n    if (j < position - 1){\n      *(target + j) = *(source + j);\n      continue;\n    }\n    else if (j == position - 1) \n      *(target + j) = number;\n    else { \n      *(target + j) = *(source + j - 1);\n    }\n  }\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 5\n\nvoid deletion(int *,int *, int);\n\nint main() {\n  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX - 1], pos, input; \n\n  printf(\"The array is\\n\");\n  \n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(nums + i));\n\n  printf(\"\\nEnter the position:\");\n  scanf(\"%d\", &pos );\n\n  deletion(nums, target, pos);\n\n  \n  \n\n  printf(\"The array is\\n\");\n\n  for (int i = 0; i < MAX - 1; i++)\n    printf(\"%d\\t\",  *(target + i));\n\n  return 0;\n}\n\nvoid deletion(int *source, int *target, int position) {\n  int j = 0;\n\n  for (j = 0; j < MAX + 1; j++) { \n    if (j < position - 1){\n      *(target + j) = *(source + j);\n      continue;\n    }\n    else { \n      *(target + j) = *(source + j + 1);\n    }\n  }\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#include <math.h>\n\n\nstruct point {\n    float re;\n    float im;\n};\n\n\nstruct point complex_add(struct point A, struct point B) {\n    struct point C;\n    C.re = A.re + B.re;\n    C.im = A.im + B.im;\n    return C;\n}\n\nint main(void) {\n    struct point A, B, target;\n    printf(\"Enter first number real and imaginary part of A = (a1 + ib1): \");\n    scanf(\"%f %f\", &A.re, &A.im);\n\n    printf(\"Enter first number real and imaginary part of B = (a2 + ib2): \");\n    scanf(\"%f %f\", &B.re, &B.im);   \n\n    target = complex_add(A, B);\n    \n    printf(\"A + B = %4.3f + i(%4.3f)\\n\", target.re, target.im);\n    return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define SIZE 5\nvoid merge_array(int *, int *, int *);\n\nint main() {\n  int unsorted1[SIZE], unsorted2[SIZE], final[2*SIZE];\n\n  printf(\"Enter %d numbers in 1st array: \", SIZE);\n  for (int i = 0; i < SIZE; i++)\n    scanf(\"%d\",unsorted1 + i);\n\n  printf(\"Enter %d numbers in 2nd array: \", SIZE);\n  for (int i = 0; i < SIZE; i++)\n    scanf(\"%d\",unsorted2 + i);\n\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < SIZE; i++)\n    printf(\"%d\\t\",  *(unsorted1 + i));\n\n  printf(\"\\nArray 2:\\n\");\n  for (int i = 0; i < SIZE; i++)\n    printf(\"%d\\t\",  *(unsorted2 + i));\n\n  merge_array(unsorted1, unsorted2, final);\n\n  printf(\"\\nMerged array\\n\");\n\n  for (int j = 0; j < (2 * SIZE); j++)\n    printf(\"%d  \",*(final + j));\n}\n\nvoid merge_array(int *source1, int *source2, int *target) {\n  int j = 0;\n\n  for (j; j < (2*SIZE); j++) {\n    if (j < SIZE) {\n      *(target + j) = *(source1 + j);\n    }\n    else {\n      *(target + j) = *(source2 + j - SIZE);\n    }\n  }\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 40\n\n \nvoid merge_string(char *source1, char *source2, char *target) {\n  while (*source1 != '\\0') {\n    *target = *source1;\n    source1++;\n    target++;\n  }\n\n  while (*source2 != '\\0') {\n    *target = *source2;\n    source2++;\n    target++;\n  }\n\n  *target = '\\0';\n}\n\nint main() { \n  char source1[MAX], source2[MAX], target[MAX];\n  printf(\"Enter a string (Max %d characters)\\n\", MAX);\n  scanf(\"%[^\\n]%*c\", source1); \n  printf(\"Enter another string (Max %d characters)\\n\", MAX);\n  scanf(\"%[^\\n]%*c\", source2); \n  merge_string(source1, source2, target);\n  printf(\"%s\\n\", target);\n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#include <string.h>\n#define MAX 20\n\nstruct NAME {\n    char fname[MAX];\n    char mname[MAX];\n    char lname[MAX];\n};\n\nstruct DOB {\n    int DD;\n    int MM;\n    int YYYY;\n};\n\nstruct student {\n    struct NAME name;\n    int roll;\n    struct DOB dob;\n};\n\nint main(void) {\n    struct student stud[3];\n   \n    for (int i = 0; i < 3; i++) {\n        printf(\"\\nEnter First name - middle name - last name: \");\n        scanf(\"%s %s %s\", stud[i].name.fname, \n                stud[i].name.mname,\n                stud[i].name.lname);\n\n        printf(\"\\nEnter Roll no.: \");\n        scanf(\"%d\", &stud[i].roll);\n\n        printf(\"\\nEnter DOB in form DD - MM - YY: \");\n        scanf(\"%d %d %d\", &stud[i].dob.DD, &stud[i].dob.MM, &stud[i].dob.YYYY);        \n    }\n\n    for (int i = 0; i < 3; i++) {\n        printf(\"NAME = %s %s %s\\n\", \n                (stud+i)->name.fname, \n                (stud+i)->name.mname, \n                (stud+i)->name.lname);\n        printf(\"ROLL = %d\\n\",(stud+i)->roll);\n        printf(\"DOB  = %2d\/%2d\/%4d\\n\",\n                ((stud+i)->dob).DD, \n                ((stud+i)->dob).MM, \n                ((stud+i)->dob).YYYY);\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 5\n\nint search(int *, int);\n\nint main() {\n  int numbers[MAX], val, pos;\n\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\",numbers + i);\n\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(numbers + i));\n\n  printf(\"Enter the value to be searched\\n\" );\n  scanf(\"%d\",&val);\n\n  pos = search(numbers, val);\n\n  if (pos > 0)\n    printf(\"%d is at position %d\\n\",val, pos);\n  else\n    printf(\"%d not found\\n\",val);\n}\n\nint search(int *array, int num) {\n  for (int j = 0; j < MAX; j++)\n  {\n    if (*(array + j) == num)\n    {\n      \n      return (j + 1);\n    }\n  }\n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n\nint main() {\n    int x = 2, y, z = 4;\n    printf(\"x = %d\\nz = %d\\n\", x,z);\n    printf(\"a) y = x++ + ++x => \");\n    y = x++ + ++x;\n    printf(\"%d\\n\", y);\n    \n    x = 2;\n    printf(\"b) y = ++x + ++x => \");\n    y = ++x + ++x;\n    printf(\"%d\\n\", y);\n\n    x = 2;\n    printf(\"c) y = ++x + ++x + ++x => \");\n    y = ++x + ++x + ++x; \n    printf(\"%d\\n\", y);\n    \n    x = 2;\n    printf(\"d) y = x>z = \");\n    y = x > z;\n    printf(\"%d\\n\", y);\n    \n    printf(\"e) y = x>z?x:z = \");\n    y = x > z ? x : z;\n    printf(\"%d\\n\", y);\n\n    return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 5\n\nvoid reverse_array(int *origin, int *rev) {\n  int j = 0;\n  for (int i = MAX - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n}\n\nint main() {\n  int source[MAX], target[MAX];\n\n  printf(\"Enter %d numbers: \", MAX);\n\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\", source + i);\n\n  printf(\"\\nThe Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(source + i));\n\n  reverse_array(source, target);\n\n  printf(\"\\nThe reversed Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(target + i));\n\n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint prime(int n) {\n  if (n % 2 == 0)\n    return 1;\n  else\n  {\n    for (int ii = 1; ii <= sqrt(n); ii++)\n    {\n      if (n % ii == 0)\n       return 1;\n    }\n  return 0;\n  }\n}\n\nint Armstrong(int num) {\n    int sum = 0, target = 0, tmp;\n    tmp = num;\n    while (num > 0)\n    {\n        sum += pow(num%10, 3);\n        num \/= 10;\n    }\n    \n    return  (tmp == sum ? 1 : 0);\n}\n\nint perf_check(int n) {\n  int summ = 0;\n  for (int ii = 1; ii <= sqrt(n) + 1; ii++)\n  {\n    if (n % ii == 0)\n      summ += ii;\n  }\n  return (summ == n ? 1 : 0);\n}\n\nint main() {\n  int v1, num;\n  printf(\"1...Prime Check\\n\");\n  printf(\"2...Armstrong Check\\n\");\n  printf(\"3...Perfect number Check\\n\");\n  scanf(\"%d\",&v1);\n  switch (v1) {\n    case 1:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, prime(num) ? \"not prime\" : \"prime\");\n      break;\n    case 2:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, Armstrong(num) ? \"Armstrong number.\" : \"not Armstrong number.\");\n      break;\n    case 3:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, perf_check(num) ? \"perfect\" : \"not perfect\");\n      break;\n    default:\n      printf(\"ERROR (invalid input)\\n\");\n      exit(1);\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 5\n\nvoid reverse_array(int *origin, int *rev) {\n  int j = 0;\n  for (int i = MAX - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n}\n\nint main() {\n  int source[MAX], target[MAX];\n\n  printf(\"Enter %d numbers: \", MAX);\n\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\", source + i);\n\n  printf(\"\\nThe Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(source + i));\n\n  reverse_array(source, target);\n\n  printf(\"\\nThe reversed Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(target + i));\n  printf(\"\\n\");\n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n\nint main()\n{\n  int rows, cols;\n  int x, y;\n  printf(\"Enter matrix dimension(row * col): \");\n  scanf(\"%d %d\",&rows, &cols);\n\n  int mm[rows][cols];\n\n  printf(\"Give values in the %d * %d matrix row-wise.\\n\", rows, cols);\n\n  for (int ii = 0; ii < rows; ii++)\n  {\n    for (int jj = 0; jj < cols; jj++)\n    {\n      scanf(\"%d\",&mm[ii][jj]);\n    }\n  }\n\n  printf(\"\\nThe array is\\n\");\n  for (int ii = 0; ii < rows; ii++)\n  {\n    for (int jj = 0; jj < cols; jj++)\n    {\n      printf(\"%d\\t\",mm[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n\n\n  printf(\"Enter (row * col) of element needed: \");\n  scanf(\"%d %d\",&x, &y);\n  if (x > rows || y > cols)\n    printf(\"Array index out of range\\n\");\n  else\n    printf(\"Value at %d * %d in the given array is: %d\\n\",x, y, mm[x - 1][y - 1]);\n    \n  return 0;\n}\n"}
{"target":"mandarvu","func":"#include <stdio.h>\n#define MAX 3\n\nint main()\n{\n  int mat1[MAX][MAX], mat2[MAX][MAX], addition[MAX][MAX];\n\n  printf(\"Give values in the matrix1 row-wise.\\n\");\n\n  for (int i = 0; i < MAX; i++)\n  {\n    for (int j = 0; j < MAX; j++)\n    {\n      scanf(\"%d\",&mat1[i][j]);\n    }\n  }\n\n  printf(\"Give values in the matrix2 row-wise.\\n\");\n\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      scanf(\"%d\", &mat2[ii][jj]);\n    }\n  }\n\n  printf(\"\\nThe matrix1 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat1[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n\n  printf(\"\\nThe matrix2 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat2[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n\n\n  printf(\"\\nThe matrix1 + matrix2 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat1[ii][jj] + mat2[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n}\n"}
{"target":"mandarvu","func":"\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nvoid findRoots(int a, int b, int c)\n{\n    if (a == 0) {\n        printf(\"Invalid input, as a has to be non-zero.\\n\");\n        return;\n    }\n\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n\n    if (d > 0) {\n        printf(\"Roots are real and different \\n\");\n        printf(\"%f\\n%f\", (double)(-b + sqrt_val) \/ (2 * a),\n            (double)(-b - sqrt_val) \/ (2 * a));\n    }\n    else if (d == 0) {\n        printf(\"Roots are real and same \\n\");\n        printf(\"%f\", -(double)b \/ (2 * a));\n    }\n    else \n    {\n        printf(\"Roots are complex \\n\");\n        printf(\"%f + i(%f)\\n%f - i(%f)\", -(double)b \/ (2 * a),\n            sqrt_val, -(double)b \/ (2 * a), sqrt_val);\n    }\n}\n\n\nint main()\n{\n    int a, b, c;\n    printf(\"Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n\");\n    scanf(\"%d %d %d\",&a,&b,&c);\n    \n    findRoots(a, b, c);\n    return 0;\n}\n\n"}
{"target":"MartinMarinovich","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"notebook.h\"\n#include \"marca.h\"\n#include \"tipo.h\"\n#include \"servicio.h\"\n#include \"trabajo.h\"\n#include \"utn.h\"\n#include \"menu.h\"\n\n#define TAM_NOTEBOOKS 10\n#define TAM_MARCAS 4\n#define TAM_TIPOS 4\n#define TAM_SERVICIOS 4\n#define TAM_TRABAJOS 20\n#define TAM_CLIENTES 10\n\n\nint main()\n{\n\n\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_CLIENTES];\n\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    int opcionMenu;\n\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n\n\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);\n\n\n\n\n    do\n    {\n        menu(&opcionMenu);\n\n        switch(opcionMenu)\n        {\n            case 1:\n\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n\n            break;\n\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n\n            break;\n\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n\n            break;\n\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n\n            case 18:\n\n                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);\n\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n\n            break;\n\n            case 19:\n\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n\n            break;\n\n        }\n\n    }while(opcionMenu != 20);\n\n    return 0;\n}\n\n\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"marca.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)\n{\n    int error = -1;\n    int id [4] = { 1000,1001,1002,1003};\n    char marcas [4][20]= {\n        \"Compaq\",\n        \"Asus\",\n        \"Acer\",\n        \"HP\",\n    };\n\n    for(int i = 0; i<tamanioMarcas;i++)\n    {\n        strcpy(listaDeMarcas[i].descripcion,marcas[i]);\n        listaDeMarcas[i].idMarca = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarMarca(eMarca unaMarca)\n{\n    printf(\"%4d  %10s \\n\",unaMarca.idMarca,unaMarca.descripcion);\n}\n\nint listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"marca.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)\n{\n    int error = -1;\n    int id [4] = { 1000,1001,1002,1003};\n    char marcas [4][20]= {\n        \"Compaq\",\n        \"Asus\",\n        \"Acer\",\n        \"HP\",\n    };\n\n    for(int i = 0; i<tamanioMarcas;i++)\n    {\n        strcpy(listaDeMarcas[i].descripcion,marcas[i]);\n        listaDeMarcas[i].idMarca = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarMarca(eMarca unaMarca)\n{\n    printf(\"%4d  %10s \\n\",unaMarca.idMarca,unaMarca.descripcion);\n}\n\nint listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include<string.h>\n#include \"utn.h\"\n\nint menu (int *opcionMenu)\n{\n    int error = -1;\n    int opcion;\n    if(opcionMenu != NULL)\n    {\n        \n\n        printf(\"*** ABM Service de Notebooks ***\\n\\n\");\n        printf(\"1  Alta Notebook\\n\");\n        printf(\"2  Modificar Notebook\\n\");\n        printf(\"3  Baja Notebook\\n\");\n        printf(\"4  Listar Notebook\\n\");\n        printf(\"5  Listar Marcas\\n\");\n        printf(\"6  Listar Tipos\\n\");\n        printf(\"7  Listar Servicios\\n\");\n        printf(\"8  Alta Trabajo\\n\");\n        printf(\"9  Listar Trabajos\\n\");\n        printf(\"10 Listar x Tipo\\n\");\n        printf(\"11 Listar x Marca\\n\");\n        printf(\"12 Contar x Marca y Tipo\\n\");\n        printf(\"13 Listar Notebooks separadas x cada Marca\\n\");\n        printf(\"14 Mostrar Marcas mas elegidas \\n\");\n        printf(\"15 Mostrar Notebooks mas baratas \\n\");\n        printf(\"16 Listar trabajos por ID notebook\\n\");\n        printf(\"17 Listar total a pagar por ID notebook\\n\");\n        printf(\"18 Mostrar Notebooks por Servicio\\n\");\n        printf(\"19 Mostrar servicio por fecha\\n\");\n        printf(\"20 Salir\\n\");\n\n        if(!utn_getNumeroInt(&opcion,\"\\nIngrese la opcion deseada\\n\",\"Error, opcion invalida\\n\",1,20, 4))\n        {\n\n            *opcionMenu = opcion;\n        }\n        error = 0;\n\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"notebook.h\"\n#include \"marca.h\"\n#include \"tipo.h\"\n#include \"servicio.h\"\n#include \"trabajo.h\"\n\n#define TAM_NOTEBOOKS 10\n#define TAM_MARCAS 4\n#define TAM_TIPOS 4\n#define TAM_SERVICIOS 4\n#define TAM_TRABAJOS 20\n#define TAM_CLIENTES 10\n\nchar menu (char *opcionMenu);\n\nint main()\n{\n\n    setbuf(stdout,NULL);\n\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_NOTEBOOKS];\n\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    char opcionMenu;\n\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_TRABAJOS);\n\n\n    do\n    {\n        menu(&opcionMenu);\n\n        switch(opcionMenu)\n        {\n            case 1:\n\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n\n            break;\n\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n\n            break;\n\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n\n            break;\n\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n\n        }\n\n    }while(opcionMenu != 19);\n\n    return 0;\n}\n\n\n"}
{"target":"MartinMarinovich","func":"\n\n#include\"servicio.h\"\n#include\"utn.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}\n\n\nvoid mostrarServicio(eServicio unServicio)\n{\n    printf(\"%4d     %10s         %3d\\n\",unServicio.idServicio,unServicio.descripcion,unServicio.precio);\n}\n\nint listarServicios(eServicio listaDeServicio[], int tamanioServicio)\n{\n    int error = -1;\n\n    if(listaDeServicio !=NULL && tamanioServicio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE SERVICIOS  ****\\n\");\n        printf(\" Id         Servicio        Precio\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanioServicio; i++)\n        {\n            mostrarServicio(listaDeServicio[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n\nint getIdServicio(eServicio servicios[],int tam_s)\n{\n    int auxId;\n    listarServicios(servicios,tam_s);\n\n    utn_getNumeroInt(&auxId,\"Ingrese id\",\"Error, ingrese id valido\",2000,2003,4);\n\n    while(buscarServicios(servicios,tam_s,auxId) == -1)\n    {\n         utn_getNumeroInt(&auxId,\"Ingrese un id valido\",\"Error, ingrese id valido\",2000,2003,4);\n    }\n\n    return auxId;\n}\nint buscarServicios(eServicio servicios[],int tam_s,int idServicio)\n{\n    int indice=-1;\n\n    for(int i=0;i<tam_s;i++)\n    {\n        if(servicios[i].idServicio ==idServicio)\n        {\n            indice=i;\n            break;\n        }\n    }\n        return indice;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"tipo.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)\n{\n    int error = -1;\n    int id [4] = {5000,5001,5002,5003};\n    char colores [4][20]= {\n        \"Gamer\",\n        \"Disenio\",\n        \"Ultrabook\",\n        \"Normalita\",\n    };\n\n    for(int i = 0; i<tamanioTipos;i++)\n    {\n        strcpy(listadoDeTipos[i].descripcion,colores[i]);\n        listadoDeTipos[i].idTipo = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarTipo(eTipo unTipo)\n{\n    printf(\" %d         %s \\n\",unTipo.idTipo,unTipo.descripcion);\n}\n\nint listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"tipo.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)\n{\n    int error = -1;\n    int id [4] = {5000,5001,5002,5003};\n    char colores [4][20]= {\n        \"Gamer\",\n        \"Disenio\",\n        \"Ultrabook\",\n        \"Normalita\",\n    };\n\n    for(int i = 0; i<tamanioTipos;i++)\n    {\n        strcpy(listadoDeTipos[i].descripcion,colores[i]);\n        listadoDeTipos[i].idTipo = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarTipo(eTipo unTipo)\n{\n    printf(\" %d         %s \\n\",unTipo.idTipo,unTipo.descripcion);\n}\n\nint listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n#include\"cliente.h\"\n#include \"notebook.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include<string.h>\n\nint hardCodearClientes(eCliente listadoClientes[], int tamanioClientes)\n{\n    int error = -1;\n    int id[10] ={1,2,3,4,5,6,7,8,9,10};\n    char nombres [10][20] = {\"Juan\",\"Carlos\",\"Martin\",\"Lucas\",\"Daniel\",\"Ana\",\"Julia\",\"Daniela\",\"Maria\",\"Pedro\"};\n    char sexos [10] = {'m','m','m','m','m','f','f','f','f','m'};\n\n    if(listadoClientes != NULL && tamanioClientes>0)\n    {\n        for(int i = 0; i<tamanioClientes; i++)\n        {\n            listadoClientes[i].idCliente = id[i];\n            strcpy(listadoClientes[i].nombre,nombres[i]);\n            listadoClientes[i].sexo = sexos[i];\n\n        }\n        error = 0;\n    }\n    return error;\n}\n\nvoid mostrarCliente(eCliente unCliente)\n{\n    printf(\"%d        %10s         %c\\n\",unCliente.idCliente,unCliente.nombre,unCliente.sexo);\n}\n\nint listarClientes(eCliente listadoDeClientes[], int tamanio)\n{\n    int error = -1;\n\n    if(listadoDeClientes !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE CLIENTES  ****\\n\");\n        printf(\" Id             Nombre           Sexo\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            listadoDeClientes[0].idCliente = 1;\n            mostrarCliente(listadoDeClientes[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n\nint obtenerCliente(eCliente listaDeClientes[], int idCliente, int tamClientes, char nombreCliente [], char* sexoCliente)\n{\n    int error = -1;\n\n    if(listaDeClientes != NULL && idCliente >0 && tamClientes >0 && nombreCliente != NULL)\n    {\n        for(int i = 0; i<tamClientes; i++)\n        {\n            if(idCliente == listaDeClientes[i].idCliente)\n            {\n                listaDeClientes[i].idCliente = idCliente;\n                strcpy(nombreCliente,listaDeClientes[i].nombre);\n                *sexoCliente = listaDeClientes[i].sexo;\n                error = 0;\n            }\n        }\n    }\n\n    return error;\n}\n\n"}
{"target":"MartinMarinovich","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"notebook.h\"\n#include \"marca.h\"\n#include \"tipo.h\"\n#include \"servicio.h\"\n#include \"trabajo.h\"\n#include \"utn.h\"\n#include \"menu.h\"\n\n#define TAM_NOTEBOOKS 10\n#define TAM_MARCAS 4\n#define TAM_TIPOS 4\n#define TAM_SERVICIOS 4\n#define TAM_TRABAJOS 20\n#define TAM_CLIENTES 10\n\n\nint main()\n{\n\n\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_CLIENTES];\n\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    int opcionMenu;\n\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n\n\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);\n\n\n\n\n    do\n    {\n        menu(&opcionMenu);\n\n        switch(opcionMenu)\n        {\n            case 1:\n\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n\n            break;\n\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n\n            break;\n\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n\n            break;\n\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n\n            break;\n\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n\n            case 18:\n\n                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);\n\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n\n            break;\n\n            case 19:\n\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n\n            break;\n\n        }\n\n    }while(opcionMenu != 20);\n\n    return 0;\n}\n\n\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"marca.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardcodearMarcas(eMarca listaDeMarcas[], int tamanioMarcas)\n{\n    int error = -1;\n    int id [4] = { 1000,1001,1002,1003};\n    char marcas [4][20]= {\n        \"Compaq\",\n        \"Asus\",\n        \"Acer\",\n        \"HP\",\n    };\n\n    for(int i = 0; i<tamanioMarcas;i++)\n    {\n        strcpy(listaDeMarcas[i].descripcion,marcas[i]);\n        listaDeMarcas[i].idMarca = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarMarca(eMarca unaMarca)\n{\n    printf(\"%4d  %10s \\n\",unaMarca.idMarca,unaMarca.descripcion);\n}\n\nint listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include<string.h>\n#include \"utn.h\"\n\nint menu (int *opcionMenu)\n{\n    int error = -1;\n    int opcion;\n    if(opcionMenu != NULL)\n    {\n        \n\n        printf(\"*** ABM Service de Notebooks ***\\n\\n\");\n        printf(\"1  Alta Notebook\\n\");\n        printf(\"2  Modificar Notebook\\n\");\n        printf(\"3  Baja Notebook\\n\");\n        printf(\"4  Listar Notebook\\n\");\n        printf(\"5  Listar Marcas\\n\");\n        printf(\"6  Listar Tipos\\n\");\n        printf(\"7  Listar Servicios\\n\");\n        printf(\"8  Alta Trabajo\\n\");\n        printf(\"9  Listar Trabajos\\n\");\n        printf(\"10 Listar x Tipo\\n\");\n        printf(\"11 Listar x Marca\\n\");\n        printf(\"12 Contar x Marca y Tipo\\n\");\n        printf(\"13 Listar Notebooks separadas x cada Marca\\n\");\n        printf(\"14 Mostrar Marcas mas elegidas \\n\");\n        printf(\"15 Mostrar Notebooks mas baratas \\n\");\n        printf(\"16 Listar trabajos por ID notebook\\n\");\n        printf(\"17 Listar total a pagar por ID notebook\\n\");\n        printf(\"18 Mostrar Notebooks por Servicio\\n\");\n        printf(\"19 Mostrar servicio por fecha\\n\");\n        printf(\"20 Salir\\n\");\n\n        if(!utn_getNumeroInt(&opcion,\"\\nIngrese la opcion deseada\\n\",\"Error, opcion invalida\\n\",1,20, 4))\n        {\n\n            *opcionMenu = opcion;\n        }\n        error = 0;\n\n    }\n    return error;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n#include\"servicio.h\"\n#include\"utn.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}\n\n\nvoid mostrarServicio(eServicio unServicio)\n{\n    printf(\"%4d     %10s         %3d\\n\",unServicio.idServicio,unServicio.descripcion,unServicio.precio);\n}\n\nint listarServicios(eServicio listaDeServicio[], int tamanioServicio)\n{\n    int error = -1;\n\n    if(listaDeServicio !=NULL && tamanioServicio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE SERVICIOS  ****\\n\");\n        printf(\" Id         Servicio        Precio\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanioServicio; i++)\n        {\n            mostrarServicio(listaDeServicio[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n\nint getIdServicio(eServicio servicios[],int tam_s)\n{\n    int auxId;\n    listarServicios(servicios,tam_s);\n\n    utn_getNumeroInt(&auxId,\"Ingrese id\",\"Error, ingrese id valido\",2000,2003,4);\n\n    while(buscarServicios(servicios,tam_s,auxId) == -1)\n    {\n         utn_getNumeroInt(&auxId,\"Ingrese un id valido\",\"Error, ingrese id valido\",2000,2003,4);\n    }\n\n    return auxId;\n}\nint buscarServicios(eServicio servicios[],int tam_s,int idServicio)\n{\n    int indice=-1;\n\n    for(int i=0;i<tam_s;i++)\n    {\n        if(servicios[i].idServicio ==idServicio)\n        {\n            indice=i;\n            break;\n        }\n    }\n        return indice;\n}\n"}
{"target":"MartinMarinovich","func":"\n\n\n#include\"tipo.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hardCodearTipos(eTipo listadoDeTipos[], int tamanioTipos)\n{\n    int error = -1;\n    int id [4] = {5000,5001,5002,5003};\n    char colores [4][20]= {\n        \"Gamer\",\n        \"Disenio\",\n        \"Ultrabook\",\n        \"Normalita\",\n    };\n\n    for(int i = 0; i<tamanioTipos;i++)\n    {\n        strcpy(listadoDeTipos[i].descripcion,colores[i]);\n        listadoDeTipos[i].idTipo = id[i];\n    }\n\n\n    return error;\n}\n\nvoid mostrarTipo(eTipo unTipo)\n{\n    printf(\" %d         %s \\n\",unTipo.idTipo,unTipo.descripcion);\n}\n\nint listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int array[10][10];\n\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n\n    scanf(\"%d %d\", &m, &n);\n\n    printf(\"Enter the co-efficients of the matrix\\n\");\n\n    for (i = 0; i < m; ++i)\n\n    {\n\n        for (j = 0; j < n; ++j)\n\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n\n}\n\n\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int i,n;\n    printf(\"Enter the element of array:\");\n    scanf(\"%d\", &n);\n    int a[n];\n    for(i=0; i<=n-1; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\nEven numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==0)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    printf(\"\\n\\nOdd numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==1)\n        {\n            printf(\"%d \", a[i]);\n\n        }\n    }\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int a[5][5];\n    int r, c;\n    for(r=0; r<=1; r++)\n    {\n        for(c=0; c<=1; c++)\n        {\n            scanf(\"%d\", &a[r][c]);\n        }\n        printf(\"\\n\");\n    }\n    for(r=0; r<=1; r++)\n    {\n        for(c=0; c<=1; c++)\n        {\n            printf(\"%d \", a[r][c]);\n        }\n        printf(\"\\n\");\n    }\n    int sum=0;\n    for(r=0; r<=1; r++)\n    {\n        sum=0;\n        for(c=0; c<=1; c++)\n        {\n            sum=sum+a[r][c];\n        }\n        printf(\"\\nsum of element of row%d=%d \",r+1, sum);\n    }\n    for(c=0; c<=1; c++)\n    {\n        sum=0;\n        for(r=0; r<=1; r++)\n        {\n            sum=sum+a[r][c];\n        }\n        printf(\"\\nsum of element of coloumn %d=%d \",c+1, sum);\n    }\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#define MAX_SIZE 100\n\nint main()\n{\n    int arr[MAX_SIZE];\n    int i, size, pos;\n\n    \n    printf(\"Enter size of the array : \");\n    scanf(\"%d\", &size);\n    printf(\"Enter elements in array : \");\n    for(i=0; i<size; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    \n    printf(\"Enter the element position to delete : \");\n    scanf(\"%d\", &pos);\n\n    \n    if(pos==size+1 || pos<0)\n    {\n        printf(\"Invalid position! Please enter position between 1 to %d\", size);\n    }\n    else\n    {\n        \n        for(i=pos-1; i<size-1; i++)\n        {\n            arr[i] = arr[i + 1];\n        }\n\n        \n        size--;\n    }\n\n    \n    printf(\"\\nElements of array after delete are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d\\t\", arr[i]);\n    }\n\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"\n#include<stdio.h>\nint main()\n{\n    int n;\n    printf(\"Enter The Number :\");\n    scanf(\"%d\", &n);\n    if (n>=80 && n<=100)\n    {\n        printf(\"\\nEarned Grade is >> A+\");\n    }\n    else if (n>=70 && n<=79)\n    {\n        printf(\"\\nEarned Grade is >> A\");\n    }\n    else if(n>=60 && n<=69)\n    {\n        printf(\"\\nEarned Grade is >> A-\");\n    }\n    else if (n>=50 && n<=59)\n    {\n        printf(\"\\nEarned Grade is >> B\");\n    }\n    else if (n>=40 && n<=49)\n    {\n        printf(\"\\nEarned Grade is >> C\");\n    }\n    else\n    {\n        printf(\"\\nEarned Grade is >> F\");\n    }\n    return 0;\n\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int a[2][2];\n    int r1,c1;\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            scanf(\"%d\", &a[r1][c1]);\n        }\n    }\n    printf(\"The first matrix is:\\n\");\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            printf(\"%d \", a[r1][c1]);\n        }\n        printf(\"\\n\");\n    }\n    \n    int r2,c2;\n    for(r2=0; r2<=1; r2++)\n    {\n        for(c2=0; c2<=1; c2++)\n        {\n            scanf(\"%d\", &a[r2][c2]);\n        }\n    }\n    printf(\"The Secound matrix is:\\n\");\n    for(r2=0; r2<=1; r2++)\n    {\n        for(c2=0; c2<=1; c2++)\n        {\n            printf(\"%d \", a[r2][c2]);\n        }\n        printf(\"\\n\");\n    }\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            for(r2=0; r2<=1; r2++)\n            {\n                for(c2=0; c2<=1; c2++)\n                {\n                    if(r1==r2&&c1==c2)\n                        {\n                            printf(\"Two matrices are equal\");\n                        }\n                    else\n                        {\n                            printf(\"Not equal\");\n                        }\n\n\n                }\n            }\n        }\n    }\n\n\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n\n   int a[2][2];\n   int r1, c1;\n   for(r1=0; r1<=1; r1++)\n   {\n       for(c1=0; c1<=1; c1++)\n       {\n           scanf(\"%d\", &a[r1][c1]);\n       }\n   }\n   for(r1=0; r1<=1; r1++)\n   {\n       for(c1=0; c1<=1; c1++)\n       {\n           printf(\"%d \", a[r1][c1]);\n       }\n       printf(\"\\n\");\n   }\n   int b[2][2];\n   int r2, c2;\n   for(r2=0; r2<=1; r2++)\n   {\n       for(c2=0; c2<=1; c2++)\n       {\n           scanf(\"%d\", &b[r2][c2]);\n       }\n   }\n   for(r2=0; r2<=1; r2++)\n   {\n       for(c2=0; c2<=1; c2++)\n       {\n           printf(\"%d \", b[r2][c2]);\n       }\n       printf(\"\\n\");\n   }\n   for(r1=0; r2)\n\n\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int array[10][10];\n\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n\n    scanf(\"%d %d\", &m, &n);\n\n    printf(\"Enter the co-efficients of the matrix\\n\");\n\n    for (i = 0; i < m; ++i)\n\n    {\n\n        for (j = 0; j < n; ++j)\n\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n\n}\n\n\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\nint main()\n{\n    int i,n;\n    printf(\"Enter the element of array:\");\n    scanf(\"%d\", &n);\n    int a[n];\n    for(i=0; i<=n-1; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\nEven numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==0)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    printf(\"\\n\\nOdd numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==1)\n        {\n            printf(\"%d \", a[i]);\n\n        }\n    }\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * next;\n}*head;\n\nvoid createList(int n);\nvoid displayList();\n\n\nint main()\n{\n    int n, data, choice=1;\n\n    head = NULL;\n\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayList();\n\n    return 0;\n}\nvoid createList(int n)\n{\n    int i, data;\n    struct node *temp, *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n\n        head->data = data;\n        head->next = NULL;\n\n        temp = head;\n\n        \n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n\n            newNode->data = data;\n            newNode->next = NULL;\n\n            \n            temp->next = newNode;\n\n            \n            temp = newNode;\n        }\n\n        \n        temp->next = head;\n\n        printf(\"\\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\\n\");\n\n}\n\n\n\nvoid displayList()\n{\n    struct node *current;\n    int n = 1;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\nint data;\nstruct node*next;\n};\nstruct node*head;\nvoid createlist(int n);\nvoid displaylist();\n\nint main()\n    {\n        int n,data;\n        printf(\"Enter the number of list:\");\n        scanf(\"%d\", &n);\n        createlist(n);\n        printf(\"\\nDisplay\\n\");\n        displaylist();\n        return 0;\n    }\n\nvoid createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n\n}\n\n    void displaylist()\n    {\n        struct node*temp;\n        temp=head;\n        while(temp!=NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp=temp->next;\n        }\n    }\n\n\n\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\nint data;\nstruct node*next;\n};\nstruct node*head;\nvoid createlist(int n);\nvoid displaylist();\n\nint main()\n    {\n        int n,data;\n        printf(\"Enter the number of list:\");\n        scanf(\"%d\", &n);\n        createlist(n);\n        printf(\"\\nDisplay\\n\");\n        displaylist();\n        return 0;\n    }\n\nvoid createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=mehedi;\n    }\n\n}\n\n    void displaylist()\n    {\n        struct node*temp;\n        temp=head;\n        while(temp!=NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp=temp->next;\n        }\n    }\n\n\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * prev;\n    struct node * next;\n}*head, *last;\n\nvoid createList(int n);\nvoid displayList();\n\n\nvoid deleteFromN(int position);\n\n\nint main()\n{\n    int n, data, choice=1;\n\n    head = NULL;\n    last = NULL;\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    \n    \n    printf(\"Enter the node position which you want to delete: \");\n    scanf(\"%d\", &n);\n    deleteFromN(n);\n    displayList();\n    return 0;\n}\n\nvoid createList(int n)\n{\n    int i, data;\n        struct node *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n\n        head->data = data;\n        head->prev = NULL;\n        head->next = NULL;\n\n        last = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n\n            newNode->data = data;\n            newNode->prev = last; \n            newNode->next = NULL;\n\n            last->next = newNode; \n            last = newNode; \n        }\n}\n\nvoid displayList()\n{\n    struct node * temp;\n    int n = 1;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        temp = head;\n        printf(\"DATA IN THE LIST:\\n\");\n\n        while(temp != NULL)\n        {\n            printf(\"DATA of %d node = %d\\n\", n, temp->data);\n\n            n++;\n\n            \n            temp = temp->next;\n        }\n    }\n}\n\nvoid deleteFromN(int position)\n{\n    struct node *current;\n    int i;\n    current = head;\n\n    for(i=1; i<position && current!=NULL; i++)\n    {\n        current = current->next;\n    }\n\n    if(position == 1)\n    {\n        \n        struct node * toDelete;\n        toDelete = head;\n\n        head = head->next; \n        head->prev = NULL; \n\n        free(toDelete); \n    }\n    else if(current == last)\n    {\n        \n        struct node * toDelete;\n        toDelete = last;\n\n        last = last->prev; \n        last->next = NULL; \n\n        free(toDelete);       \n    }\n    else if(current != NULL)\n    {\n        current->prev->next = current->next;\n        current->next->prev = current->prev;\n\n        free(current); \n\n        printf(\"SUCCESSFULLY DELETED NODE FROM %d POSITION.\\n\", position);\n    }\n}\n    \n\n\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\n    int data;\n    struct node*next;\n};\nstruct node*head;\n\nvoid print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}\nvoid create(int value){\nstruct node*temp=(struct node*)malloc(sizeof(struct node));\ntemp->data=value;\ntemp->next=NULL;\nif(head==NULL){\n    head=temp;\n}\nelse{\n    struct node*newnode;\n    newnode=head;\n    while(newnode->next!=NULL)\n    {\n        newnode=newnode->next;\n    }\n    newnode->next=temp;\n}\n}\nvoid deletenode(int position)\n{\n    int i;\n    if(position==1)\n    {\n        struct node*temp;\n        temp=head;\n        head=head->next;\n        free(temp);\n    }\n    else\n    {\n        struct node*temp1;\n        temp1=head;\n        for(i=1;i<=position-2;i++)\n        {\n            temp1=temp1->next;\n        }\n        struct node*temp2;\n        temp2=temp1->next;\n        temp1->next=temp2->next;\n        free(temp2);\n    }\n}\n\nint main()\n{\n    head=NULL;\n    create(10);\n    create(20);\n    create(30);\n    create(4);\n    printf(\"display:\\n\");\n    print();\n    deletenode(2);\n    printf(\"display:\\n\");\n    print();\n    return 0;\n\n\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * prev;\n    struct node * next;\n}*head,*last;\n\nvoid createList(int n);\nvoid displayListFromFirst();\n\nvoid insertAtBeginning(int data);\nvoid insertAtN(int data, int position);\n\n\nint main()\n{\n    int n, data;\n\n    head = NULL;\n    last = NULL;\n\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    \n\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    scanf(\"%d\", &data);\n    insertAtN(data, n);\n    displayListFromFirst();\n    \n\n    return 0;\n}\nvoid createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }\n\nvoid displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\n\n\n\nvoid insertAtN(int data, int position)\n{\n    int i;\n    struct node * newNode, *temp;\n        temp = head;\n        i=1;\n\n        while(i<position-1 && temp!=NULL)\n        {\n            temp = temp->next;\n            i++;\n        }\n\n        \n            newNode = (struct node *)malloc(sizeof(struct node));\n\n            newNode->data = data;\n            newNode->next = temp->next;\n            newNode->prev = temp;\n            \n            \n                temp->next->prev = newNode;\n            \n            temp->next = newNode;\n        \n    }\n\n\n\n\n\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * prev;\n    struct node * next;\n}*head,*last;\n\nvoid createList(int n);\nvoid displayListFromFirst();\n\nvoid insertAtBeginning(int data);\nvoid insertAtN(int data, int position);\n\n\nint main()\n{\n    int n, data;\n\n    head = NULL;\n    last = NULL;\n\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    \n\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    scanf(\"%d\", &data);\n    insertAtN(data, n);\n    displayListFromFirst();\n    \n\n    return 0;\n}\nvoid createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }\n\nvoid displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\nvoid insertAtBeginning(int data)\n{\n    struct node * newNode;\n\n    if(head == NULL)\n    {\n        printf(\"Error, List is Empty!\\n\");\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n\n        newNode->data = data;\n        newNode->next = head; \n        newNode->prev = NULL; \n\n        \n        head->prev = newNode;\n\n        \n        head = newNode;\n\n        printf(\"NODE INSERTED SUCCESSFULLY AT THE BEGINNING OF THE LIST\\n\");\n    }\n}\nvoid insertAtEnd(int data)\n{\n    struct node * newNode;\n\n    if(last == NULL)\n    {\n        printf(\"Error, List is empty!\\n\");\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n\n        newNode->data = data;\n        newNode->next = NULL;\n        newNode->prev = last;\n\n        last->next = newNode;\n        last = newNode;\n\n        printf(\"NODE INSERTED SUCCESSFULLY AT THE END OF LIST\\n\");\n    }\n}\n    void insertAtN(int data, int position)\n{\n    int i;\n    struct node * newNode, *temp;\n\n        if(position == 1)\n        {\n            insertAtBeginning(data);\n        \n}\n        else if(temp!=NULL)\n        {\n             insertAtEnd(data);\n            \n        }\n        else\n        {\n            printf(\"Error, Invalid position\\n\");\n        }\n    }\n\n\n\n\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * prev;\n    struct node * next;\n}*head,*last;\n\nvoid createList(int n);\nvoid displayListFromFirst();\nvoid displayListFromEnd();\n\nint main()\n{\n    int n, data;\n\n    head = NULL;\n    last = NULL;\n\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    displayListFromEnd();\n    return 0;\n}\nvoid createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }\n\nvoid displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }\nvoid displayListFromEnd()\n{\n    struct node * temp;\n        temp = last;\n        printf(\"\\n\\nDATA IN THE LIST From End:\\n\");\n\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->prev;\n        }\n}\n\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\n    int data;\n    struct node*next;\n};\nstruct node*head;\n\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\nvoid deletenode(int position)\n{\n        int i;\n\n        struct node*temp1;\n        temp1=head;\n        for(i=1;i<=position-2;i++)\n        {\n            temp1=temp1->next;\n        }\n        struct node*temp2;\n        temp2=temp1->next;\n        temp1->next=temp2->next;\n        free(temp2);\n    }\nvoid print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}\nint main()\n{\n    int n;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    return 0;\n\n\n}\n\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * next;\n}*head;\nvoid createList(int n);\nvoid displayList();\nvoid insertAtBeginning(int data);\nvoid insertAtN(int data, int position);\n\n\nint main()\n{\n    int n, data, choice=1;\n\n    head = NULL;\n                printf(\"Enter the total number of nodes in list: \");\n                scanf(\"%d\", &n);\n                createList(n);\n                displayList();\n                printf(\"Enter node position: \");\n                scanf(\"%d\", &n);\n                printf(\"Enter data you want to insert at %d position: \", n);\n                scanf(\"%d\", &data);\n                insertAtN(data, n);\n                displayList();\n\n\n    return 0;\n}\n \n \nvoid createList(int n)\n{\n    int i, data;\n    struct node *prevNode, *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n\n        head->data = data;\n        head->next = NULL;\n\n        prevNode = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n\n            newNode->data = data;\n            newNode->next = NULL;\n\n            \n            prevNode->next = newNode;\n            \n            prevNode = newNode;\n        }\n\n        \n        prevNode->next = head;\n}\nvoid displayList()\n{\n    struct node *current;\n    int n = 1;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}\nvoid insertAtBeginning(int data)\n{\n    struct node *newNode, *current;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n         \n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = head;\n         \n        \n        current = head;\n        while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n\n        \n        head = newNode;\n\n        printf(\"NODE INSERTED SUCCESSFULLY\\n\");\n    }\n}\nvoid insertAtN(int data, int position)\n{\n    struct node *newNode, *current;\n    int i;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else if(position == 1)\n    {\n    \n    struct node *newNode, *current;\n        \n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = head;\n         \n        current = head;\n        while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n\n        \n        head = newNode;\n}\n    else\n    {\n        \n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        \n        current = head;\n        for(i=2; i<=position-1; i++)\n        {\n            current = current->next;\n        }\n        \n        newNode->next = current->next;\n        current->next = newNode;\n\n    }\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\nint data;\nstruct node*next;\n};\nstruct node*head;\nvoid createList(int n);\nvoid inab(int data);\nvoid displayList();\nint main()\n{\n    int n, data;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data to insert at beginning of the list: \");\n    scanf(\"%d\", &data);\n    inab(data);\n\n    printf(\"\\nData in the list \\n\");\n    displayList();\n\n    return 0;\n}\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\nvoid inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}\nvoid displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\nint data;\nstruct node*next;\n};\nstruct node*head;\nvoid createList(int n);\nvoid inab(int data);\nvoid displayList();\nint main()\n{\n    int n, data;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data to insert at beginning of the list: \");\n    scanf(\"%d\", &data);\n    inab(data);\n\n    printf(\"\\nData in the list \\n\");\n    displayList();\n\n    return 0;\n}\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\nvoid inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}\nvoid displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\nstruct node {\n    int data;\n    struct node * next;\n}*head;\nvoid createList(int n);\nvoid displayList();\n\nvoid insertAtN(int data, int position);\n\n\nint main()\n{\n    int n, data;\n\n    head = NULL;\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayList();\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    insertAtN(data, n);\n    displayList();\n\n    return 0;\n}\nvoid createList(int n)\n{\n    int i, data;\n    struct node *prevNode, *newNode;\n\n    if(n >= 1)\n    {\n        head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n\n        head->data = data;\n        head->next = NULL;\n\n        prevNode = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n\n            newNode->data = data;\n            newNode->next = NULL;\n            prevNode->next = newNode;\n            prevNode = newNode;\n        }\n        prevNode->next = head;\n\n        printf(\"\\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }\n}\nvoid displayList()\n{\n    struct node *current;\n    int n = 1;\n\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}\nvoid insertAtN(int data, int position)\n{\n    struct node *newNode, *current;\n    int i;\n    if(position == 1)\n    {\n    struct node *newNode, *current;\n    newNode = (struct node *)malloc(sizeof(struct node));\n    scanf(\"%d\", &data);\n    newNode->data = data;\n    newNode->next = head;\n    current = head;\n    while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n        head = newNode;\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        scanf(\"%d\", &data);\n        newNode->data = data;\n        current = head;\n        for(i=2; i<=position-1; i++)\n        {\n            current = current->next;\n        }\n        newNode->next = current->next;\n        current->next = newNode;\n\n        printf(\"NODE INSERTED SUCCESSFULLY.\\n\");\n    }\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX 6\n\nint queue[MAX];\nint front = 0;\nint rear = 0;\nint itemCount = 0;\n\nint peek() {\n   return queue[front];\n}\n\nbool isEmpty() {\n   return itemCount == 0;\n}\n\nbool isFull() {\n   return itemCount == MAX;\n}\n\n\n\nint enqueue(int data) {\n\n   if(!isFull()) {\n        rear=rear+1;\n        queue[rear]=data;\n\n   itemCount++;}\n}\n\nint dequeue() {\n   int data;\n   if(!isEmpty()){\n   data = queue[front];\n   front=front+1;\n   itemCount--;}\n   return data;\n}\n\nint main() {\n   int num, n;\n   enqueue(3);\n   enqueue(5);\n   enqueue(9);\n   enqueue(1);\n   enqueue(12);\n   enqueue(15);\n\n   if(isFull()){\n      printf(\"Queue is full!\\n\");\n   }\n\n   num = dequeue();\n   \n\n   printf(\"Element removed: %d\\n\",num);\n   enqueue(16);\n   enqueue(17);\n   enqueue(18);\n   printf(\"Element at front: %d\\n\",peek());\n\n   \n   \n   \n   printf(\"Queue:  \");\n\n   while(!isEmpty()) {\n      n = dequeue();\n      printf(\"%d \",n);\n   }\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* front = NULL;\nstruct Node* rear = NULL;\n\n\nvoid Enqueue(int x) {\n    struct Node* temp =\n        (struct Node*)malloc(sizeof(struct Node));\n    temp->data =x;\n    temp->next = NULL;\n    if(front == NULL && rear == NULL){\n        front = rear = temp;\n        return;\n    }\n    rear->next = temp;\n    rear = temp;\n}\n\nvoid Dequeue() {\n    struct Node* temp = front;\n    if(front == NULL) {\n        printf(\"Queue is Empty\\n\");\n        return;\n    }\n    if(front == rear) {\n        front = rear = NULL;\n    }\n    else {\n        front = front->next;\n    }\n    free(temp);\n}\n\nint Front() {\n    if(front == NULL) {\n        printf(\"Queue is empty\\n\");\n        return;\n    }\n    return front->data;\n}\n\nvoid Print() {\n    struct Node* temp = front;\n    while(temp != NULL) {\n        printf(\"%d  \\n\",temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int i,n,p,m;\n    printf(\"How many number do you want to enqueue ? \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"Enter the value :\");\n        scanf(\"%d\",&p);\n        Enqueue(p);\n        printf(\"List is :\\n\");\n        Print();\n    }\n    printf(\"How many number do you want to dequeue ? \");\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++)\n    {\n        Dequeue();\n        printf(\"List is :\\n\");\n        Print();\n    }\n\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\n    int data;\n    struct node*next;\n};\nstruct node*head;\n\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\nvoid reverse()\n{\n    struct node* current, *prev, *temp;\n    current=head;\n    prev =NULL;\n    while(temp!=NULL)\n    {\n        temp=current->next;\n        current->next=prev;\n        prev=current;\n        current=temp;\n    }\n    head=prev;\n}\nvoid print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}\nint main()\n{\n    int n;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    printf(\"reverse:\\n\");\n    reverse();\n    print();\n    return 0;\n\n\n}\n\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node *next;\n}*head;\nvoid createList(int n)\n{\n    struct node *newNode, *temp;\n    int data, i;\n\n    head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter the data of node 1: \");\n        scanf(\"%d\", &data);\n\n        head->data = data;\n        head->next = NULL;\n\n        temp = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n                printf(\"Enter the data of node %d: \", i);\n                scanf(\"%d\", &data);\n\n                newNode->data = data;\n                newNode->next = NULL;\n\n                temp->next = newNode;\n\n                temp = temp->next;\n            }\n}\n\n\n\nvoid search(int key)\n{\n    while (head != NULL)\n    {    if(head->data==key)\n        {\n            printf(\"key Data found\\n\");\n            return;\n       }\n        head = head->next;\n    }\n    printf(\"Key Data not found\\n\");\n}\nvoid displayList()\n{\n    struct node *temp;\n        temp = head;\n        while(temp != NULL)\n        {\n            printf(\"Data = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n}\nint main()\n{\n    int n, data,key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"\\nData in the list :\\n\");\n    displayList();\n\n     printf(\"\\nEnter key to search: \");\n    scanf(\"%d\", &key);\n    search(key);\n\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\nint data;\n\nstruct node*next;\n};\nstruct node*head;\nvoid createList(int n);\nvoid displayList();\nint main()\n{\n    int n, key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data which u wnt to srch: \");\n    scanf(\"%d\", &key);\n    search(key);\n\n    return 0;\n}\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\nvoid search(int key)\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        if(temp->data==key){\n        printf(\"Key found :)\");\n        temp=temp->next;\n        break;\n    }\n    else{\n        printf(\"Key not found :(\");\n        break;\n    }\n}\n}\nvoid displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}\n"}
{"target":"mehedi9021","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct node{\n    int data;\n    int key;\n    struct node*next;\n};\nstruct node*head;\n\nvoid createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}\n\nvoid print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}\nvoid search(int key)\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        if(temp->data==key)\n        {\n            printf(\"Key found :)\");\n            temp=temp->next;\n            break;\n        }\n        else\n        {\n            printf(\"Key not found :(\");\n            break;\n        }\n    }\n}\nint main()\n{\n    int n, key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    printf(\"srch:\");\n    scanf(\"%d\", &key);\n    search(key);\n    return 0;\n\n\n}\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n\nint MAXSIZE = 8;\nint stack[8];\nint top = -1;\n\nint isempty() {\n\n   if(top == -1)\n      return 1;\n   else\n      return 0;\n}\n\nint isfull() {\n\n   if(top == MAXSIZE)\n      return 1;\n   else\n      return 0;\n}\n\nint peek() {\n   return stack[top];\n}\n\nint pop() {\n   int data;\n\n   if(!isempty()) {\n      data = stack[top];\n      top = top - 1;\n      return data;\n   } else {\n      printf(\"Could not retrieve data, Stack is empty.\\n\");\n   }\n}\n\nint push(int data) {\n\n   if(!isfull()) {\n      top = top + 1;\n      stack[top] = data;\n   } else {\n      printf(\"Could not insert data, Stack is full.\\n\");\n   }\n}\n\nint main() {\n   \n   push(3);\n   push(5);\n   push(9);\n   push(1);\n   push(12);\n   push(15);\n\n   printf(\"Element at top of the stack: %d\\n\" ,peek());\n   printf(\"Elements: \\n\");\n\n   \n   while(!isempty()) {\n      int data = pop();\n      printf(\"%d\\n\",data);\n   }\n\n   printf(\"Stack full: %s\\n\" , isfull()?\"true\":\"false\");\n   printf(\"Stack empty: %s\\n\" , isempty()?\"true\":\"false\");\n\n   return 0;\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <string.h>\n\n#define MAXSIZE 100\nstruct Stack {\n    int top;\n    int array[MAXSIZE];\n} string;\n\nint isFull() {\n    if(string.top >= MAXSIZE)\n        return 1;\n    else\n        return 0;\n}\nint isEmpty() {\n if(string.top == -1)\n     return 1;\n else\n     return 0;\n}\nvoid push(int num) {\n    if (isFull())\n        printf(\"Stack is Full...\\n\");\n    else {\n        string.array[string.top + 1] = num;\n        string.top++;\n    }\n}\nint pop() {\n    if (isEmpty())\n        printf(\"Stack is Empty...\\n\");\n    else {\n     string.top = string.top - 1;\n        return string.array[string.top+1];\n    }\n}\n\nint main() {\n    char inputString[100], c;\n    int i, length;\n    \n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    length = strlen(inputString);\n    for(i = 0; i < length; i++){\n        push(inputString[i]);\n    }\n    for(i = 0; i < length; i++){\n        if(pop() != inputString[i]) {\n            printf(\"Not a Palindrome String\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Palindrome String\\n\");\n    return 0;\n}\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <string.h>\n\n#define MAXSIZE 100\nstruct Stack {\n    int top;\n    int array[MAXSIZE];\n} string;\n\nint isFull() {\n    if(string.top >= MAXSIZE)\n        return 1;\n    else\n        return 0;\n}\nint isEmpty() {\n if(string.top == -1)\n     return 1;\n else\n     return 0;\n}\nvoid push(int num) {\n    if (isFull())\n        printf(\"Stack is Full...\\n\");\n    else {\n        string.array[string.top + 1] = num;\n        string.top++;\n    }\n}\n\n\nint main() {\n    char inputString[100], c;\n    int i, length;\n    \n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    printf(\"\\n\\n\");\n    puts(inputString);\n    length = strlen(inputString);\n    \n            return 0;\n\n\n    printf(\"\");\n    return 0;\n}\n\n"}
{"target":"mehedi9021","func":"#include <stdio.h>\n#include <malloc.h>\n\nstruct node {\n    struct node * left;\n    char data;\n    struct node * right;\n};\n\nstruct node *constructTree( int );\nvoid inorder(struct node *);\n\nchar array[ ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', '\\0', '\\0', 'H' };\nint leftcount[ ] = {  1,   3,   5,   -1,   9,  -1,  -1,   -1,   -1,  -1 };\nint rightcount[ ] = {  2,   4,   6,   -1,  -1,  -1,  -1,   -1,   -1,  -1 };\n\nvoid main() {\n    struct node *root;\n    root = constructTree( 0 );\n    printf(\"In-order Traversal: \\n\");\n    inorder(root);\n}\n\nstruct node * constructTree( int index ) {\n    struct node *temp = NULL;\n    if (index != -1) {\n        temp = (struct node *)malloc( sizeof ( struct node ) );\n        temp->left = constructTree( leftcount[index] );\n        temp->data = array[index];\n        temp->right = constructTree( rightcount[index] );\n    }\n    return temp;\n}\n\nvoid inorder( struct node *root ) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%c\\t\", root->data);\n        inorder(root->right);\n    }\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nvoid ReverseArray(int arr[] ,int size){\n    int i, temp;\n\n    \n    for(i=0 ; i<size\/2 ; i++){\n        temp = arr[i];\n        arr[i] = arr[size-1 - i];\n        arr[size-1 -i] = temp;\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int k , j;\n    int size = 5;\n    int arr[5];\n\n    printf(\"Enter elements of array: \");\n\n    \n    for(k=0 ; k<size ; k++){\n        scanf(\"%d\",&arr[k]);\n    }\n\n    \n    ReverseArray(arr,size);\n\n    printf(\"Array after being reversed: \");\n    \n    for(j=0 ; j<size ; j++){\n        printf(\"%d \",arr[j]);\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nint * Swap(int a_size,int *a,int b_size,int *b)\n{\n    int temp;\n    int i;\n    for(i=0;i<b_size;i++)\n    {\n        temp = a[i];\n        a[i] = b[i];\n        b[i] = temp;\n    }\n    return a;\n}\n\n\nint main(void)\n{\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int i;\n    int a_size = 10;\n    int b_size = 5;\n    int array_A[a_size];\n    int array_B[b_size];\n\n    printf(\"Enter Array A elements: \");\n    \n    for(i=0 ; i < a_size ; i++){\n        scanf(\"%d\",&array_A[i]);\n            }\n\n    printf(\"\\n\");\n\n    printf(\"Enter Array B elements: \");\n    \n    for(i=0 ; i < b_size ; i++){\n        scanf(\"%d\",&array_B[i]);\n        }\n\n    printf(\"Array A before the Swap : \");\n    \n    for(i=0;i<a_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Array B before the Swap : \");\n    \n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n\n    Swap(a_size,array_A,b_size,array_B);\n\n    printf(\"Array A after the Swap : \");\n    \n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Array B after the Swap : \");\n    \n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nint LongestConsecutive(int arr[],int size , int element){\n    int max_consec = 0;\n    int count = 0;\n    int i;\n    int ahead , current;\n    \n    for(i = 0; i < size ; i++){\n\n        ahead = arr[i+1];\n        current = arr[i];\n\n        \n        if(arr[i] == element){\n            count++;\n\n            \n            if(count > max_consec){\n                max_consec = count;\n            }\n        }\n\n        \n        if( ahead != current){\n            count = 0;\n        }\n    }\n\n    return max_consec;\n}\n\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int size = 15;\n    int arr[size];\n    int maximum , element;\n    int i;\n\n    printf(\"Enter array elements: \");\n\n    \n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n\n    printf(\"\\n\");\n    printf(\"Enter required element: \");\n\n    \n    scanf(\"%d\",&element);\n\n    \n    maximum = LongestConsecutive(arr , size , element);\n\n    \n    printf(\"Longest consecutive number of element %d is %d\",element ,maximum);\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define TRUE 1\n#define FALSE 0\n\n\nint CheckIdentical(int array_A[], int array_B[] ,int size){\n    int i;\n\n    \n    for(i=0 ; i<size ; i++){\n        if(array_A[i] != array_B[i]){\n            return 1;\n        }\n    }\n\n    \n    return 0;\n}\n\nint main(void){\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n\n    int size = 5;\n    int arrayA[size];\n    int arrayB[size];\n    int i;\n    int result;\n\n    printf(\"Enter array A elements: \");\n    \n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arrayA[i]);\n    }\n\n\n    printf(\"Enter array B elements: \");\n    \n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arrayB[i]);\n    }\n\n    \n    result = CheckIdentical(arrayA, arrayB ,size);\n\n    if(result == TRUE){\n        printf(\"Two arrays are not identical\");\n    }\n    else if(result == FALSE){\n        printf(\"Two arrays are identical\");\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#include<string.h>\n#define TRUE 1\n#define FALSE 0\n\nint CheckString(char s[]){\n    int i=0 ,j=0;\n    int result = TRUE;\n\n    \n    while(s[i] != '\\0'){\n\n        j = i+1;  \n            while(s[j] != '\\0'){\n                \n                if(s[i] == s[j]){\n                    result = FALSE;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        return result;\n}\n\nint main(void){\n    int result;\n    char str[20];\n    gets(str);                       \n\n    \n    result = CheckString(str);\n\n    if(result == TRUE){\n        printf(\"All Characters are distinct\");\n    }\n    else if(result == FALSE){\n        printf(\"Repeated characters exist\");\n    }\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include <stdio.h>\n\n\nint OutputArray[256];\n\nint * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)\n{\n    int i;\n    *result_size = 0;\n    \n    if((LowerNumber>=UpperNumber) || (UpperNumber-1 == LowerNumber))\n    {\n        OutputArray[0] = 0xFF;\n        OutputArray[1] = 0xFF;\n        *result_size = 2;\n    }\n    else\n    {\n        \n        for(i=UpperNumber-1;i>LowerNumber;i--)\n        {\n            OutputArray[*result_size] = i;\n            (*result_size)++;\n        }\n    }\n    return OutputArray;\n}\n\nint main(void) {\n    int count;\n    int n1 = 5,n2=10;\n    int *ptr;\n    int arr_size_used = 0;\n\n    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);\n\n    printf(\"Output Array = \");\n\n    \n    for(count=0;count<arr_size_used;count++)\n    {\n        \n        printf(\"%d \",ptr[count]);\n    }\n    printf(\"\\nOutput Array Size = %d\",arr_size_used);\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include <stdio.h>\n\n\nint OutputArray[256];\n\nint * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)\n{\n    int i;\n    *result_size = 0;\n    \n    if(LowerNumber > UpperNumber)\n    {\n        OutputArray[0] = 0xFF;\n        OutputArray[1] = 0xFF;\n        *result_size = 2;\n    }\n    else\n    {\n        \n        for(i=UpperNumber;i>=LowerNumber;i--)\n        {\n            OutputArray[*result_size] = i;\n            (*result_size)++;\n        }\n    }\n    return OutputArray;\n}\n\nint main(void) {\n    int count;\n    int n1 = 5,n2=10;\n    int *ptr;\n    int arr_size_used = 0;\n\n    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);\n\n    printf(\"Output Array = \");\n\n    \n    for(count=0;count<arr_size_used;count++)\n    {\n        \n        printf(\"%d \",ptr[count]);\n    }\n    printf(\"\\nOutput Array Size = %d\",arr_size_used);\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include <stdio.h>\n\n#define ERROR 0\n#define SUCCESS 1\n\n\nint removeDuplicates(int arr_old[], int n_old, int arr_new[], int *n_new)\n{\n    int i=0;\n\n    \n    if (n_old==0)\n        return ERROR;\n\n    for (i=0 ; i<n_old-1 ; i++)\n    {\n        \n        if (arr_old[i] != arr_old[i+1])\n        {\n            arr_new[*n_new] = arr_old[i];\n            (*n_new)++;\n        }\n\n    }\n\n    \n    arr_new[*n_new] = arr_old[i];\n    (*n_new)++;\n\n    return SUCCESS;\n}\n\nint main(void)\n{\n    int arr1[10] = {1,2,3,3,3,4,4,5,5,5};\n    int arr2[10];\n    int arr2_usedSize = 0;\n    int ret,i;\n\n    \n    ret = removeDuplicates(arr1,10,arr2,&arr2_usedSize);\n\n    if(ret == SUCCESS)\n    {\n        for(i=0;i<arr2_usedSize;i++)\n        {\n            printf(\"%d \\t\",arr2[i]);\n        }\n    }\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nvoid BubbleSort(int arr[], const int array_size){\n        int i, j;\n        int temp;\n        for(i=1 ; i<= array_size ; i++){\n            for(j=0 ; j<= (array_size - 1) ; j++){\n\n                if(arr[j]>arr[j+1]){\n                    temp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n}\n\nint main(void){\n\n    const int array_size =5;\n    int arr[array_size];\n    int i, j, k;\n\n\n    for(i=0 ; i<array_size ; i++){\n            scanf(\"%d\",&arr[i]);\n        }\n\n    printf(\"Array before sorting: \\n\");\n    for(j=0 ; j<array_size ; j++){\n            printf(\"%d\\t\",arr[j]);\n        }\n\n    BubbleSort(arr, array_size);\n\n    printf(\"\\n\");\n    printf(\"Array after sorting: \\n\");\n    for(k=0 ; k<array_size ; k++){\n        printf(\"%d\\t\",arr[k]);\n    }\n\n    return 0;\n    }\n\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nvoid SelectionSorting(int arr[],const int size ){\n    int i , j , min , temp;\n\n    \n    for(i = 0 ; i < (size-1) ; i++){\n        \n        min = i;\n\n            for(j = i+1 ; j < size ; j++){\n\n                if(arr[j]<arr[min]){\n                    min = j;\n                }\n            }\n\n            \n            temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i ,j ,k;\n    const int size = 5;\n    int arr[size];\n\n    printf(\"Enter array elements:\\n\");\n\n    \n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n\n    printf(\"Array before sorting:\\n\");\n\n    \n    for(j=0 ; j<size ; j++){\n        printf(\"%d\\t\",arr[j]);\n    }\n\n    \n    SelectionSorting(arr,size);\n\n    printf(\"\\n\");\n    printf(\"Array after sorting:\\n\");\n\n    \n    for(k=0 ; k<size ; k++){\n        printf(\"%d\\t\",arr[k]);\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nint LinearSearch(int arr[] , int element , int size ){\n    int i;\n\n    \n    for(i =0; i <size ; i++){\n        if(arr[i] == element)\n            return i;           \n    }\n    return -1;  \n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i ;\n    int size = 5;\n    int arr[size];\n    int result, element;\n    printf(\"Enter array of numbers:\");\n\n    \n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n\n    printf(\"Enter required element:\");\n\n    \n    scanf(\"%d\",&element);\n\n    \n    result = LinearSearch(arr, element ,size);\n\n    if(result == -1){\n        printf(\"Item is not on the list\");\n    }\n    else{\n        printf(\"The index of required item is %d\",result);\n    }\n    return 0;\n}\n\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define SIZE 20\n#define FOR_WHILE 1\n#define RECURSIVE 2\n\n\nint ForFibonacci(int arr[],int index){\n    int i;\n\n    \n    arr[0] = 1;\n    arr[1] = 1;\n\n    \n    for( i=2 ; i<(SIZE-1) ; i++ ){\n        arr[i] = arr[i-1] + arr[i-2];\n    }\n\n    \n    return arr[index];\n}\n\n\nlong RecursiveFibonacci(long index){\n\n    if(index == 0 || index == 1){\n        return 1;\n    }\n    else{\n        return RecursiveFibonacci(index-2) + RecursiveFibonacci(index-1);\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int arr[SIZE];\n    int function_type;                                                                      \n    int index;\n    int result_forwhile;\n    long result_fibo;\n\n    \n    printf(\"Enter required element in Fibonacci series: \");\n    scanf(\"%d\",&index);\n    printf(\"\\n\");\n\n    \n    printf(\"Type 1 for ForWhile function or type 2 for Recursive function: \");\n    scanf(\"%d\",&function_type);\n\n    if(function_type == FOR_WHILE){\n\n        \n        result_forwhile = ForFibonacci(arr,index);\n        printf(\"The %d element in fibonacci series is %d\",index,result_forwhile);\n    }\n    else if(function_type == RECURSIVE){\n\n        \n        result_fibo = RecursiveFibonacci(index);\n        printf(\"The %d element in recursive fibonacci is %ld\",index , result_fibo);\n    }\n\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\n\nint countOnes(unsigned char number){\n    unsigned char mask = 0x80;                          \n    int ones = 0;\n    \n    for(int i = 0; i<8 ; i++){\n\n        if((number<<i) & mask){\n            ++ones;\n        }\n    }\n    return ones;\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    unsigned int number;\n    int ones_count;\n    printf(\"Enter an 8-bit number: \");\n    scanf(\"%d\",&number);                                            \n    ones_count = countOnes(number);                                 \n    printf(\"Number of 1's in given number is %d\",ones_count);\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nint MaximumValue(int l, int r){\n        int max_value = 0;\n        int result = 0;\n\n        \n        for(int i = l ; i<=r ;i++){\n            for(int j = i ; j<=r ;j++){\n                result = i^j;\n                if(result > max_value){\n                    max_value = result;\n                }\n            }\n        }\n        return max_value;\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int number1, number2;\n    int maximum;\n    printf(\"Enter first number: \");\n    scanf(\"%d\",&number1);                                           \n    printf(\"Enter second number: \");\n    scanf(\"%d\",&number2);                                           \n    maximum = MaximumValue(number1,number2);\n    printf(\"The maximum value of %d XOR %d is %d\",number1,number2,maximum);\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n#define NO_ERROR_VALID_OPERATION 0\n#define ERROR_INVALID_OPERATION 1\n\n\nfloat calculate(float a , float b , char operator , int *error_ptr){\n    float result;\n    switch(operator){\n\n            case '+':result = a+b;\n                     *error_ptr = NO_ERROR_VALID_OPERATION;\n                     break;\n\n            case'-':result = a-b;\n                    *error_ptr = NO_ERROR_VALID_OPERATION;\n                    break;\n\n            case'*':result = a*b;\n                    *error_ptr = NO_ERROR_VALID_OPERATION;\n                    break;\n\n            case'\/':result = a\/b;\n                    *error_ptr = NO_ERROR_VALID_OPERATION;\n                    break;\n\n            default:printf(\"ERROR INVALID INPUT OPERATION\\n\");\n                    *error_ptr = ERROR_INVALID_OPERATION;\n                    break;\n    }\n    return result;\n}\n\nint main(void){\n        setvbuf(stdout , NULL , _IONBF , 0);                            \n        setvbuf(stderr , NULL , _IONBF , 0);\n        char op;\n        float number1;\n        float number2;\n        float result;\n        int error = NO_ERROR_VALID_OPERATION;       \n        printf(\"Enter the required operation: \");\n        scanf(\"%c\",&op);                            \n        printf(\"Enter first number: \");\n        scanf(\"%f\",&number1);                       \n        printf(\"Enter second number: \");\n        scanf(\"%f\",&number2);                       \n        result = calculate(number1 , number2 , op , &error);        \n        if( error == NO_ERROR_VALID_OPERATION ){\n            printf(\"Result = %f\",result);\n        }\n        else if( error == ERROR_INVALID_OPERATION ){\n            printf(\"No result , invalid operation\");\n        }\n        return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define CHECK_LOWER_FALSE   0\n#define CHECK_LOWER_TRUE    1\n\nint test_case = CHECK_LOWER_TRUE;                               \n\n\nchar lower_to_upper(char alphabet){\n    if( alphabet >= 'a' && alphabet <= 'z' ){\n        alphabet = alphabet - 32;                                   \n    }\n    else{\n        test_case = CHECK_LOWER_FALSE;\n    }\n    return alphabet;\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    char alphabet;                                                  \n    char uppercase;                                                 \n    printf(\"Please enter a lowercase letter: \");\n    scanf(\"%c\",&alphabet);                                          \n    uppercase = lower_to_upper(alphabet);                           \n    if( test_case == CHECK_LOWER_TRUE ){\n    printf(\"Uppercase letter %c of corresponding Lowercase letter %c \",uppercase,alphabet);\n       }\n    else {\n        printf(\"Invalid input, please enter a lowercase letter \");\n    }\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\n\nvoid display_prime(int num1, int num2){\n    int number = num1;\n    int rem_of_two, rem_of_three;                           \n\n    \n    for (int i = num1; i<=num2 ; ){\n        rem_of_two = number % 2;\n        rem_of_three = number % 3;\n\n        \n        if(number == 2 || number == 3){\n                printf(\"%d \",number);                                               \n            }\n            else{\n                \n                if( rem_of_two == 0 || rem_of_three == 0){\n                    i++;\n                    number++;\n                    continue;\n                }\n                else{\n                    printf(\"%d \",number);\n                }\n            }\n        i++;\n        number++;\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int number1, number2;                                           \n    printf(\"Enter first number: \");\n    scanf(\"%d\",&number1);                                           \n    printf(\"Enter second number: \");\n    scanf(\"%d\",&number2);                                           \n    display_prime(number1,number2);                                 \n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                        \n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int i,j,rows;\n\n        printf(\"Enter number of rows: \");\n        scanf(\"%d\",&rows);\n        printf(\"\\n\");\n\n        for(i=0;i<rows;i++)\n        {\n            if(i == rows\/2){\n                continue;\n            }\n            for(j=0;j<rows;j++)\n            {\n                if(j == rows\/2){\n                    continue;\n                }\n                if( (j==i) || (j==rows-i-1) )\n                {\n                    printf(\"*\");\n                }\n                else\n                {\n                    printf(\" \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        return 0;\n\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int grade;                                      \n    printf(\"Enter student's grade in percentage: \");\n    scanf(\"%d\",&grade);                             \n    if(grade >= 85 && grade <=100){\n        printf(\"Student's grade is Excellent\");\n    }\n    else if(grade < 85 && grade >= 75){\n        printf(\"Student's grade is Very good\");\n    }\n    else if(grade < 75 && grade >= 65){\n        printf(\"Student's grade is Good\");\n    }\n    else if(grade < 65 && grade >= 50){\n        printf(\"Student's grade is Passed\");\n    }\n    else if(grade < 50 && grade >= 0){\n        printf(\"Student's grade is Failed\");\n    }\n    else{\n        printf(\"Invalid input\");\n    }\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nvoid SwapBits(unsigned int *ptr){\n\n    unsigned short temp;\n    unsigned short *ptrS = (unsigned short *)ptr;\n\n    temp = *ptrS;\n    *ptrS = *(ptrS + 1);\n    *(ptrS + 1) = temp;\n}\n\nint main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n\n    unsigned int number;\n    unsigned short *ptr = (unsigned short *)&number;\n\n    printf(\"Enter number: \");\n    scanf(\"%d\",&number);\n\n\n    printf(\"Two 16-bits of 32-bits integer number before swapping are %hi  and  %hi\\n\",*ptr,*(ptr+1));\n\n    \n    SwapBits(&number);\n\n    printf(\"Two 16-bits of 32-bits integer number after swapping are %hi  and  %hi\",*ptr,*(ptr+1));\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include <stdio.h>\n\n#define ARRAY_SIZE 15\n\nint OddRepetitionNumberInArray(int *arr,int arr_size)\n{\n    int i,j;\n    int count = 0;\n    int index = 0;\n    for(i=0;i<arr_size;i++)\n    {\n        for(j = 0; j < arr_size;j++)\n        {\n            \n            if(arr[i] == arr[j])\n            {\n                index = i;\n                count++;\n            }\n        }\n        \n        if(count%2 != 0)\n        {\n            break;\n        }\n        \n        count = 0;\n    }\n    return arr[index];\n}\n\nint main(void)\n{\n    int arr[ARRAY_SIZE] = {1,2,3,1,2,3,1,1,1,1,3,3,3};\n\n    int num = OddRepetitionNumberInArray(arr,ARRAY_SIZE);\n\n    printf(\"number is : %d\",num); \n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define SIZE 10\n\nvoid ReverseArray(int *ptr){ \n    int i;\n    int temp;\n\n    \n    for(i=0 ; i<SIZE\/2 ;i++){\n        temp = *ptr;\n        *ptr = *(ptr + (SIZE-1) - i*2);\n        *(ptr + (SIZE-1) - i*2) = temp;\n        ptr++;\n    }\n}\n\nint main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n    int arr[SIZE];\n    int i;\n    int *ptr = arr;\n\n    \n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ;i++){\n        scanf(\"%d\",ptr);\n        ptr++;\n    }\n\n    \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element before re-arranging: arr[%d] = %d\\n\",i,arr[i]);\n    }\n\n    \n    ReverseArray(arr);\n\n    ptr = arr;           \n    \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element after re-arranging: arr[%d] = %d\\n\",i,*ptr);\n        ptr++;\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define SIZE 10\n\n\nvoid CopyArray(int *ptrA , int *ptrB){\n    int i;\n\n    for(i=0 ; i<SIZE ; i++){\n        *ptrB = *ptrA;\n        ptrA++;\n        ptrB++;\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stdout , NULL , _IONBF , 0);\n\n    int i;\n    int array_A[SIZE];\n    int array_B[SIZE];\n    int *ptrA = array_A;\n    int *ptrB = array_B;\n    \n    printf(\"Enter elements of array A: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrA);\n        ptrA++;\n    }\n\n    \n    CopyArray(array_A,array_B);\n\n    \n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d \\n\",i,*ptrB);\n        ptrB++;\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define SIZE 10\n\nint maximum;\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int i;\n    int array[SIZE];\n    int *ptr[SIZE];\n\n    \n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",&array[i]);\n\n        \n        ptr[i] = &array[i];\n    }\n\n    \n    maximum = *ptr[0];\n\n    for(i=1 ; i<SIZE ; i++){\n\n        if(maximum < *ptr[i]){\n            maximum = *ptr[i];\n        }\n    }\n\n    \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array[%d] = %d\\n\",i,*ptr[i]);\n    }\n\n    printf(\"Maximum number is %d\",maximum);\n\n    return 0;\n}\n\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n\n\nvoid Swap(int *X, int *Y){\n    *X = *X ^ *Y;\n    *Y = *X ^ *Y;\n    *X = *X ^ *Y;\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int num1 , num2 ;\n    void (*ptr)(int *,int *) = Swap;\n\n    \n    printf(\"Enter first number: \");\n    scanf(\"%d\",&num1);\n\n    printf(\"Enter second number: \");\n    scanf(\"%d\",&num2);\n\n    \n    printf(\"Displaying two number before swapping\\n\");\n    printf(\"First number is %d , Second number is %d\\n\",num1,num2);\n\n    \n    (*ptr)(&num1 , &num2);\n\n    \n    printf(\"Displaying two numbers after swapping\\n\");\n    printf(\"First number is %d , Second number is %d\",num1,num2);\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n\n#include<stdio.h>\n#define SIZE 10\n\n\nvoid Swap(int *ptrA , int *ptrB){\n    int temp;\n    int i;\n\n    for(i=0 ; i<SIZE ; i++){\n        temp = *ptrA;\n        *ptrA = *ptrB;\n        *ptrB = temp;\n        ptrA++;\n        ptrB++;\n    }\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    int arrayA[SIZE];\n    int arrayB[SIZE];\n\n    int *ptrA = arrayA;\n    int *ptrB = arrayB;\n\n    int i;\n\n    \n    printf(\"Enter elements of first array: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrA);\n        ptrA++;\n    }\n\n    printf(\"Enter elements of second array: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrB);\n        ptrB++;\n    }\n\n    \n    ptrA = arrayA;\n    ptrB = arrayB;\n\n\n    printf(\"\\n\");\n    \n    printf(\"Array elements before swapping\\n\");\n    printf(\"Elements of first array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayA[%d] = %d\\n\",i,*ptrA);\n        ptrA++;\n    }\n\n    printf(\"\\n\");\n    printf(\"Elements of second array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d\\n\",i,*ptrB);\n        ptrB++;\n    }\n\n    \n    Swap(arrayA,arrayB);\n\n    \n    ptrA = arrayA;\n    ptrB = arrayB;\n\n    printf(\"\\n\");\n    \n    printf(\"Array elements after swapping\\n\");\n    printf(\"Elements of first array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayA[%d] = %d\\n\",i,*ptrA);\n        ptrA++;\n    }\n\n    printf(\"\\n\");\n    printf(\"Elements of second array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d\\n\",i,*ptrB);\n        ptrB++;\n    }\n\n    return 0;\n}\n"}
{"target":"MFarid94","func":"\n#include<stdio.h>\n\nchar arr[256];\n\n\nchar* LastLetters(char *str){\n\n    while(*str != '\\0'){\n        str++;\n    }\n\n    arr[0] = *(--str);\n\n    arr[1] = ' ';\n\n    arr[2] = *(--str);\n\n    arr[3] = '\\0';\n\n    return arr;\n}\n\nint main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n\n    char str[256];\n\n    printf(\"Enter a string: \");\n    gets(str);\n\n    printf(\"Reversed string: %s\",LastLetters(str));\n\n    return 0;\n}\n"}
{"target":"Mr-JoE1","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint BinaryToDecimal( int binary );\n\nint main()\n{\n    int binary;\n\n    printf(\"Enter Number In Binary Form : \");\n    scanf(\"%d\" , &binary);\n\n    printf(\"\\nNumber = %d\\n\" , BinaryToDecimal( binary ) );\n\n    return 0;\n}\n\n\nint BinaryToDecimal( int binary )\n{\n    int PowerOfTwo = 1;\n    int decimal = 0;\n\n    while(binary != 0)\n    {\n        decimal += (binary % 10) * PowerOfTwo;                  \n        binary \/= 10;\n        PowerOfTwo = PowerOfTwo << 1;                           \n    }\n    return decimal;\n}\n"}
{"target":"Mr-JoE1","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\nint IsPalindrome( int num );\nint ReverseNum( int num );\n\nint main()\n{\n    int num;\n\n    printf(\"Enter A Number : \");\n    scanf(\"%d\" , &num);\n\n    if(IsPalindrome( num ))\n        printf(\"\\n%d Is Palindrome!!\\n\" , num );\n    else\n        printf(\"\\n%d Is Not Palindrome!!\\n\" , num );\n\n    return 0;\n}\n\nint IsPalindrome( int num )\n{\n    int reversed_num = ReverseNum( num );\n    return reversed_num == num;\n}\n\nint ReverseNum( int num )\n{\n    int reversed_num = 0;\n\n    while(num != 0)\n    {\n        reversed_num = reversed_num * 10 + num % 10;\n        num \/= 10;\n    }\n    return reversed_num;\n}\n"}
{"target":"Mr-JoE1","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\nunsigned int My_strlen( char string[] , int size );\n\n\nint main()\n{\n    char my_string[ 100 ];\n\n    printf(\"Enter Your String : \");\n    scanf(\"%99[^\\n]s\" , my_string);\n\n    printf(\"\\nLength Of Your String Is : %u\\n\" , My_strlen( my_string , sizeof(my_string)\/sizeof(char) ));\n\n    return 0;\n}\n\nunsigned int My_strlen( char string[] , int size )\n{\n    for(int i = 0;i < size;i++)\n        if(string[ i ] == '\\0')                                 \n            return i;\n}\n"}
{"target":"Mr-JoE1","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main()\n{\n    int num;\n    int count_sevens = 0;\n    int units;\n\n    printf(\"Enter A Number : \");\n    scanf(\"%d\" , &num);\n\n    while(num != 0)\n    {\n        units = abs(num % 10);                                          \n        if(units == 7)                                                  \n            count_sevens++;                                             \n\n        num \/= 10;                                                      \n    }\n\n    printf(\"\\nNumber Of Sevens = %d\\n\" , count_sevens);\n\n    return 0;\n}\n"}
{"target":"Mr-JoE1","func":" \n#include <stdio.h>\nint main() {\n\n\nwhile(1){\n   int num, originalNum, remainder, n = 0;\n   float result = 0.0;\n\n   printf(\"Enter an integer: \");\n   scanf(\"%d\", &num);\n\n   originalNum = num;\n\n   \n   for (originalNum = num; originalNum != 0; ++n) {\n       originalNum \/= 10;\n   }\n   \n   for (originalNum = num; originalNum != 0; originalNum \/= 10) {\n       remainder = originalNum % 10;\n\n      \n      result += pow(remainder, n);\n   }\n\n   \n   if ((int)result == num)\n    printf(\"%d is an Armstrong number.\", num);\n   else\n    printf(\"%d is not an Armstrong number.\\n\", num);\n\n    }\n}"}
{"target":"Mr-JoE1","func":" \n#include <stdio.h>\n\n#include <stdio.h>\nint main() {\n    \nwhile(1){\n    int n, i, flag = 0;\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\", &n);\n\n    for (i = 2; i <= n \/ 2; ++i) {\n\n        \n        if (n % i == 0) {\n            flag = 1;\n            break;\n        }\n    }\n\n    if (n == 1) {\n        printf(\"1 is neither prime nor composite.\");\n    }\n    else {\n        if (flag == 0)\n            printf(\"%d is a prime number.\\n\", n);\n        else\n            printf(\"%d is not a prime number.\\n\", n);\n    }\n\n    }\n}"}
{"target":"Mr-JoE1","func":" \n\n \n#include <stdio.h>\n \nint main()\n{\n    int number,cnt,i;\n    char    hex[32];    \n \n    printf(\"Enter decimal number: \");\n    scanf(\"%d\",&number);\n \n     \n    cnt=0;              \n    while(number>0)\n    {\n        switch(number%16)\n        {\n            case 10:\n                hex[cnt]='A'; break;\n            case 11:\n                hex[cnt]='B'; break;\n            case 12:\n                hex[cnt]='C'; break;\n            case 13:\n                hex[cnt]='D'; break;\n            case 14:\n                hex[cnt]='E'; break;\n            case 15:\n                hex[cnt]='F'; break;\n            default:\n                hex[cnt]=(number%16)+0x30;  \n        }\n        number=number\/16;\n        cnt++;\n    }\n \n    \n    printf(\"Hexadecimal value is: \");\n    for(i=(cnt-1); i>=0;i--)\n        printf(\"%c\",hex[i]);\n \n    return 0;\n}"}
{"target":"Mr-JoE1","func":" \n\n\n \n#include <stdio.h>\n \nint main()\n{\n    int     number,cnt,i;\n    int     oct[32];\n \n    printf(\"Enter decimal number: \");\n    scanf(\"%d\",&number);\n \n     \n    cnt=0;              \n    while(number>0)\n    {\n        oct[cnt]=number%8;\n        number=number\/8;\n        cnt++;\n    }\n \n    \n    printf(\"Octal value is: \");\n    for(i=(cnt-1); i>=0;i--)\n        printf(\"%d\",oct[i]);\n \n    return 0;\n}"}
{"target":"Mr-JoE1","func":" \n#include <stdio.h>\n\n\nint main()\n{\n\nwhile(1){\n    int i, originalNum, num, lastDigit, sum;\n    long fact;\n\n    \n    printf(\"Enter any number to check Strong number: \");\n    scanf(\"%d\", &num);\n\n    \n    originalNum = num;\n\n    sum = 0;\n\n    \n    while(num > 0)\n    {\n\n        \n        lastDigit = num % 10;\n\n        \n        fact = 1;\n        for(i=1; i<=lastDigit; i++)\n        {\n            fact = fact * i;\n        }\n\n        \n        sum = sum + fact;\n\n        num = num \/ 10;\n    }\n\n    \n    if(sum == originalNum)\n    {\n        printf(\"%d is STRONG NUMBER\\n\", originalNum);\n    }\n    else\n    {\n        printf(\"%d is NOT STRONG NUMBER\\n\", originalNum);\n    }\n\n}\n}"}
{"target":"Mr-JoE1","func":" \n\n \n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n \nint main()\n{\n    char hex[32]={0};\n    int  dec,i;\n    int  cnt;   \n    int  dig;   \n \n    printf(\"Enter hex value: \");\n    gets(hex);\n \n    cnt=0;\n    dec=0;\n    for(i=(strlen(hex)-1);i>=0;i--)\n    {\n        switch(hex[i])\n        {\n            case 'A':\n                dig=10; break;\n            case 'B':\n                dig=11; break;\n            case 'C':\n                dig=12; break;\n            case 'D':\n                dig=13; break;\n            case 'E':\n                dig=14; break;\n            case 'F':\n                dig=15; break;\n            default:\n                dig=hex[i]-0x30;\n        }\n        dec= dec+ (dig)*pow((double)16,(double)cnt);\n        cnt++;\n    }\n \n    printf(\"DECIMAL value is: %d\",dec);\n    return 0;\n}"}
{"target":"Oryx-Embedded","func":"\n\n\n#include \"cpu_endian.h\"\n\n\n\n\nuint16_t swapInt16(uint16_t value)\n{\n   return SWAPINT16(value);\n}\n\n\n\n\nuint32_t swapInt32(uint32_t value)\n{\n   return SWAPINT32(value);\n}\n\n\n\n\nuint64_t swapInt64(uint64_t value)\n{\n   return SWAPINT64(value);\n}\n\n\n\n\nuint8_t reverseInt4(uint8_t value)\n{\n   value = ((value & 0x0C) >> 2) | ((value & 0x03) << 2);\n   value = ((value & 0x0A) >> 1) | ((value & 0x05) << 1);\n\n   return value;\n}\n\n\n\n\nuint8_t reverseInt8(uint8_t value)\n{\n   value = ((value & 0xF0) >> 4) | ((value & 0x0F) << 4);\n   value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n   value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n\n   return value;\n}\n\n\n\n\nuint16_t reverseInt16(uint16_t value)\n{\n   value = ((value & 0xFF00) >> 8) | ((value & 0x00FF) << 8);\n   value = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);\n   value = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);\n   value = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);\n\n   return value;\n}\n\n\n\n\nuint32_t reverseInt32(uint32_t value)\n{\n   value = ((value & 0xFFFF0000UL) >> 16) | ((value & 0x0000FFFFUL) << 16);\n   value = ((value & 0xFF00FF00UL) >> 8) | ((value & 0x00FF00FFUL) << 8);\n   value = ((value & 0xF0F0F0F0UL) >> 4) | ((value & 0x0F0F0F0FUL) << 4);\n   value = ((value & 0xCCCCCCCCUL) >> 2) | ((value & 0x33333333UL) << 2);\n   value = ((value & 0xAAAAAAAAUL) >> 1) | ((value & 0x55555555UL) << 1);\n\n   return value;\n}\n\n\n\n\nuint64_t reverseInt64(uint64_t value)\n{\n   value = ((value & 0xFFFFFFFF00000000ULL) >> 32) | ((value & 0x00000000FFFFFFFFULL) << 32);\n   value = ((value & 0xFFFF0000FFFF0000ULL) >> 16) | ((value & 0x0000FFFF0000FFFFULL) << 16);\n   value = ((value & 0xFF00FF00FF00FF00ULL) >> 8) | ((value & 0x00FF00FF00FF00FFULL) << 8);\n   value = ((value & 0xF0F0F0F0F0F0F0F0ULL) >> 4) | ((value & 0x0F0F0F0F0F0F0F0FULL) << 4);\n   value = ((value & 0xCCCCCCCCCCCCCCCCULL) >> 2) | ((value & 0x3333333333333333ULL) << 2);\n   value = ((value & 0xAAAAAAAAAAAAAAAAULL) >> 1) | ((value & 0x5555555555555555ULL) << 1);\n\n   return value;\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#include <stdio.h>\n#include <string.h>\n#include \"date_time.h\"\n\n#if defined(_WIN32)\n   #include <time.h>\n#endif\n\n\nstatic const char days[8][10] =\n{\n   \"\",\n   \"Monday\",\n   \"Tuesday\",\n   \"Wednesday\",\n   \"Thursday\",\n   \"Friday\",\n   \"Saturday\",\n   \"Sunday\"\n};\n\n\nstatic const char months[13][10] =\n{\n   \"\",\n   \"January\",\n   \"February\",\n   \"March\",\n   \"April\",\n   \"May\",\n   \"June\",\n   \"July\",\n   \"August\",\n   \"September\",\n   \"October\",\n   \"November\",\n   \"December\"\n};\n\n\n\n\nconst char_t *formatSystemTime(systime_t time, char_t *str)\n{\n   uint16_t hours;\n   uint8_t minutes;\n   uint8_t seconds;\n   uint16_t milliseconds;\n   static char_t buffer[24];\n\n   \n   milliseconds = time % 1000;\n   time \/= 1000;\n   \n   seconds = time % 60;\n   time \/= 60;\n   \n   minutes = time % 60;\n   time \/= 60;\n   \n   hours = time;\n\n   \n   if(!str)\n      str = buffer;\n\n   \n   if(hours > 0)\n   {\n      osSprintf(str, \"%\" PRIu16 \"h %02\" PRIu8 \"min %02\" PRIu8 \"s %03\" PRIu16 \"ms\",\n         hours, minutes, seconds, milliseconds);\n   }\n   else if(minutes > 0)\n   {\n      osSprintf(str, \"%\" PRIu8 \"min %02\" PRIu8 \"s %03\" PRIu16 \"ms\",\n         minutes, seconds, milliseconds);\n   }\n   else if(seconds > 0)\n   {\n      osSprintf(str, \"%\" PRIu8 \"s %03\" PRIu16 \"ms\", seconds, milliseconds);\n   }\n   else\n   {\n      osSprintf(str, \"%\" PRIu16 \"ms\", milliseconds);\n   }\n\n   \n   return str;\n}\n\n\n\n\nconst char_t *formatDate(const DateTime *date, char_t *str)\n{\n   static char_t buffer[40];\n\n   \n   if(!str)\n      str = buffer;\n\n   \n   if(date->dayOfWeek)\n   {\n      osSprintf(str, \"%s, %s %\" PRIu8 \", %\" PRIu16 \" %02\" PRIu8 \":%02\" PRIu8 \":%02\" PRIu8,\n         days[MIN(date->dayOfWeek, 7)], months[MIN(date->month, 12)], date->day,\n         date->year, date->hours, date->minutes, date->seconds);\n   }\n   else\n   {\n      osSprintf(str, \"%s %\" PRIu8 \", %\" PRIu16 \" %02\" PRIu8 \":%02\" PRIu8 \":%02\" PRIu8,\n         months[MIN(date->month, 12)], date->day, date->year,\n         date->hours, date->minutes, date->seconds);\n   }\n\n   \n   return str;\n}\n\n\n\n\nvoid getCurrentDate(DateTime *date)\n{\n   \n   time_t time = getCurrentUnixTime();\n\n   \n   convertUnixTimeToDate(time, date);\n}\n\n\n\n\n__weak time_t getCurrentUnixTime(void)\n{\n#if defined(_WIN32)\n   \n   return time(NULL);\n#else\n   \n   return 0;\n#endif\n}\n\n\n\n\nvoid convertUnixTimeToDate(time_t t, DateTime *date)\n{\n   uint32_t a;\n   uint32_t b;\n   uint32_t c;\n   uint32_t d;\n   uint32_t e;\n   uint32_t f;\n\n   \n   if(t < 1)\n      t = 0;\n\n   \n   date->milliseconds = 0;\n\n   \n   date->seconds = t % 60;\n   t \/= 60;\n   date->minutes = t % 60;\n   t \/= 60;\n   date->hours = t % 24;\n   t \/= 24;\n\n   \n   a = (uint32_t) ((4 * t + 102032) \/ 146097 + 15);\n   b = (uint32_t) (t + 2442113 + a - (a \/ 4));\n   c = (20 * b - 2442) \/ 7305;\n   d = b - 365 * c - (c \/ 4);\n   e = d * 1000 \/ 30601;\n   f = d - e * 30 - e * 601 \/ 1000;\n\n   \n   if(e <= 13)\n   {\n      c -= 4716;\n      e -= 1;\n   }\n   else\n   {\n      c -= 4715;\n      e -= 13;\n   }\n\n   \n   date->year = c;\n   date->month = e;\n   date->day = f;\n\n   \n   date->dayOfWeek = computeDayOfWeek(c, e, f);\n}\n\n\n\n\ntime_t convertDateToUnixTime(const DateTime *date)\n{\n   uint_t y;\n   uint_t m;\n   uint_t d;\n   uint32_t t;\n\n   \n   y = date->year;\n   \n   m = date->month;\n   \n   d = date->day;\n\n   \n   if(m <= 2)\n   {\n      m += 12;\n      y -= 1;\n   }\n\n   \n   t = (365 * y) + (y \/ 4) - (y \/ 100) + (y \/ 400);\n   \n   t += (30 * m) + (3 * (m + 1) \/ 5) + d;\n   \n   t -= 719561;\n   \n   t *= 86400;\n   \n   t += (3600 * date->hours) + (60 * date->minutes) + date->seconds;\n\n   \n   return t;\n}\n\n\n\n\nint_t compareDateTime(const DateTime *date1, const DateTime *date2)\n{\n   int_t res;\n\n   \n   if(date1->year < date2->year)\n      res = -1;\n   else if(date1->year > date2->year)\n      res = 1;\n   else if(date1->month < date2->month)\n      res = -1;\n   else if(date1->month > date2->month)\n      res = 1;\n   else if(date1->day < date2->day)\n      res = -1;\n   else if(date1->day > date2->day)\n      res = 1;\n   else if(date1->hours < date2->hours)\n      res = -1;\n   else if(date1->hours > date2->hours)\n      res = 1;\n   else if(date1->minutes < date2->minutes)\n      res = -1;\n   else if(date1->minutes > date2->minutes)\n      res = 1;\n   else if(date1->seconds < date2->seconds)\n      res = -1;\n   else if(date1->seconds > date2->seconds)\n      res = 1;\n   else if(date1->milliseconds < date2->milliseconds)\n      res = -1;\n   else if(date1->milliseconds > date2->milliseconds)\n      res = 1;\n   else\n      res = 0;\n\n   \n   return res;\n}\n\n\n\n\nuint8_t computeDayOfWeek(uint16_t y, uint8_t m, uint8_t d)\n{\n   uint_t h;\n   uint_t j;\n   uint_t k;\n\n   \n   if(m <= 2)\n   {\n      m += 12;\n      y -= 1;\n   }\n\n   \n   j = y \/ 100;\n   \n   k = y % 100;\n\n   \n   h = d + (26 * (m + 1) \/ 10) + k + (k \/ 4) + (5 * j) + (j \/ 4);\n\n   \n   return ((h + 5) % 7) + 1;\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#include \"debug.h\"\n\n\n\n\nvoid debugDisplayArray(FILE *stream,\n   const char_t *prepend, const void *data, size_t length)\n{\n   uint_t i;\n\n   \n   for(i = 0; i < length; i++)\n   {\n      \n      if((i % 16) == 0)\n      {\n         TRACE_PRINTF(\"%s\", prepend);\n      }\n\n      \n      TRACE_PRINTF(\"%02\" PRIX8 \" \", *((const uint8_t *) data + i));\n\n      \n      if((i % 16) == 15 || i == (length - 1))\n      {\n         TRACE_PRINTF(\"\\r\\n\");\n      }\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"os_port.h\"\n#include \"os_port_chibios.h\"\n#include \"debug.h\"\n\n\nstatic OsTask taskTable[OS_PORT_MAX_TASKS];\nstatic uint_t *waTable[OS_PORT_MAX_TASKS];\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   osMemset(taskTable, 0, sizeof(taskTable));\n   osMemset(waTable, 0, sizeof(waTable));\n\n   \n   chSysInit();\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n   chThdExit(MSG_OK);\n}\n\n\n\n\nbool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   \n   stackSize *= sizeof(uint_t);\n\n   \n   task->tp = chThdCreateStatic(stack, stackSize,\n      priority, (tfunc_t) taskCode, param);\n\n   \n   if(task->tp != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   void *wa;\n   OsTask *task = NULL;\n\n   \n   stackSize *= sizeof(uint_t);\n\n   \n   wa = osAllocMem(THD_WORKING_AREA_SIZE(stackSize));\n\n   \n   if(wa != NULL)\n   {\n      \n      chSysLock();\n\n      \n      for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n      {\n         \n         if(taskTable[i].tp == NULL)\n            break;\n      }\n\n      \n      if(i < OS_PORT_MAX_TASKS)\n      {\n         \n         taskTable[i].tp = chThdCreateI(wa, THD_WORKING_AREA_SIZE(stackSize),\n            priority, (tfunc_t) taskCode, param);\n\n         \n         if(taskTable[i].tp != NULL)\n         {\n            \n            chSchWakeupS(taskTable[i].tp, MSG_OK);\n\n            \n            task = &taskTable[i];\n            \n            waTable[i] = wa;\n\n            \n            chSysUnlock();\n         }\n         else\n         {\n            \n            chSysUnlock();\n            \n            osFreeMem(wa);\n         }\n      }\n      else\n      {\n         \n         chSysUnlock();\n         \n         osFreeMem(wa);\n      }\n   }\n\n   \n   return task;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   if(task == NULL)\n      chThdExit(MSG_OK);\n   else\n      chThdTerminate(task->tp);\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   chThdSleep(OS_MS_TO_SYSTICKS(delay));\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n   chThdYield();\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   chSysLock();\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   chSysUnlock();\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   chBSemObjectInit(event, TRUE);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   chBSemSignal(event);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   chBSemReset(event, TRUE);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   msg_t msg;\n\n   \n   \n   if(timeout == 0)\n   {\n      \n      msg = chBSemWaitTimeout(event, TIME_IMMEDIATE);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      msg = chBSemWaitTimeout(event, TIME_INFINITE);\n   }\n   else\n   {\n      \n      msg = chBSemWaitTimeout(event, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   if(msg == MSG_OK)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   chBSemSignalI(event);\n\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   \n   chSemObjectInit(semaphore, count);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   msg_t msg;\n\n   \n   if(timeout == 0)\n   {\n      \n      msg = chSemWaitTimeout(semaphore, TIME_IMMEDIATE);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      msg = chSemWaitTimeout(semaphore, TIME_INFINITE);\n   }\n   else\n   {\n      \n      msg = chSemWaitTimeout(semaphore, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   if(msg == MSG_OK)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   chSemSignal(semaphore);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   \n   chMtxObjectInit(mutex);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   chMtxLock(mutex);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n#if (CH_KERNEL_MAJOR < 3)\n   chMtxUnlock();\n#else\n   chMtxUnlock(mutex);\n#endif\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = chVTGetSystemTime();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   p = chHeapAlloc(NULL, size);\n\n   \n   TRACE_DEBUG(\"Allocating %\" PRIuSIZE \" bytes at 0x%08\" PRIXPTR \"\\r\\n\", size, (uintptr_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08\" PRIXPTR \"\\r\\n\", (uintptr_t) p);\n\n      \n      chHeapFree(p);\n   }\n}\n\n\n\n\nvoid osIdleLoopHook(void)\n{\n   uint_t i;\n\n   \n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      \n      if(taskTable[i].tp != NULL)\n      {\n         \n         if(chThdTerminatedX(taskTable[i].tp))\n         {\n            \n            osFreeMem(waTable[i]);\n\n            \n            waTable[i] = NULL;\n            taskTable[i].tp = NULL;\n         }\n      }\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"os_port.h\"\n#include \"os_port_cmsis_rtos2.h\"\n#include \"debug.h\"\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   osKernelInitialize();\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n   osKernelStart();\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   osThreadId_t threadId;\n   osThreadAttr_t threadAttr;\n\n   \n   threadAttr.name = name;\n   threadAttr.attr_bits = 0;\n   threadAttr.cb_mem = NULL;\n   threadAttr.cb_size = 0;\n   threadAttr.stack_mem = NULL;\n   threadAttr.stack_size = stackSize * sizeof(uint_t);\n   threadAttr.priority = (osPriority_t) priority;\n   threadAttr.tz_module = 0;\n   threadAttr.reserved = 0;\n\n   \n   threadId = osThreadNew(taskCode, param, &threadAttr);\n   \n   return (OsTask *) threadId;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   if(task == NULL)\n      osThreadExit();\n   else\n      osThreadTerminate((osThreadId_t) task);\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   osDelay(OS_MS_TO_SYSTICKS(delay));\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n   osThreadYield();\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   if(osKernelGetState() != osKernelInactive)\n   {\n      \n      osKernelLock();\n   }\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   if(osKernelGetState() != osKernelInactive)\n   {\n      \n      osKernelUnlock();\n   }\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   osEventFlagsAttr_t eventFlagsAttr;\n\n   \n   eventFlagsAttr.name = NULL;\n   eventFlagsAttr.attr_bits = 0;\n\n#if defined(os_CMSIS_RTX)\n   eventFlagsAttr.cb_mem = &event->cb;\n   eventFlagsAttr.cb_size = sizeof(os_event_flags_t);\n#elif defined(osRtxVersionKernel)\n   eventFlagsAttr.cb_mem = &event->cb;\n   eventFlagsAttr.cb_size = sizeof(osRtxEventFlags_t);\n#else\n   eventFlagsAttr.cb_mem = NULL;\n   eventFlagsAttr.cb_size = 0;\n#endif\n\n   \n   event->id = osEventFlagsNew(&eventFlagsAttr);\n\n   \n   if(event->id != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   if(event->id != NULL)\n   {\n      \n      osEventFlagsDelete(event->id);\n   }\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   osEventFlagsSet(event->id, 1);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   osEventFlagsClear(event->id, 1);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   uint32_t flags;\n\n   \n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny, osWaitForever);\n   }\n   else\n   {\n      \n      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny,\n         OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   if(flags == 1)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   osEventFlagsSet(event->id, 1);\n\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   osSemaphoreAttr_t semaphoreAttr;\n\n   \n   semaphoreAttr.name = NULL;\n   semaphoreAttr.attr_bits = 0;\n\n#if defined(os_CMSIS_RTX)\n   semaphoreAttr.cb_mem = &semaphore->cb;\n   semaphoreAttr.cb_size = sizeof(os_semaphore_t);\n#elif defined(osRtxVersionKernel)\n   semaphoreAttr.cb_mem = &semaphore->cb;\n   semaphoreAttr.cb_size = sizeof(osRtxSemaphore_t);\n#else\n   semaphoreAttr.cb_mem = NULL;\n   semaphoreAttr.cb_size = 0;\n#endif\n\n   \n   semaphore->id = osSemaphoreNew(count, count, &semaphoreAttr);\n\n   \n   if(semaphore->id != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   if(semaphore->id != NULL)\n   {\n      \n      osSemaphoreDelete(semaphore->id);\n   }\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   osStatus_t status;\n\n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      status = osSemaphoreAcquire(semaphore->id, osWaitForever);\n   }\n   else\n   {\n      \n      status = osSemaphoreAcquire(semaphore->id, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   if(status == osOK)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   osSemaphoreRelease(semaphore->id);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   osMutexAttr_t mutexAttr;\n\n   \n   mutexAttr.name = NULL;\n   mutexAttr.attr_bits = 0;\n\n#if defined(os_CMSIS_RTX)\n   mutexAttr.cb_mem = &mutex->cb;\n   mutexAttr.cb_size = sizeof(os_mutex_t);\n#elif defined(osRtxVersionKernel)\n   mutexAttr.cb_mem = &mutex->cb;\n   mutexAttr.cb_size = sizeof(osRtxMutex_t);\n#else\n   mutexAttr.cb_mem = NULL;\n   mutexAttr.cb_size = 0;\n#endif\n\n   \n   mutex->id = osMutexNew(&mutexAttr);\n\n   \n   if(mutex->id != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   if(mutex->id != NULL)\n   {\n      \n      osMutexDelete(mutex->id);\n   }\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   osMutexAcquire(mutex->id, osWaitForever);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   osMutexRelease(mutex->id);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = osKernelGetTickCount();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   osSuspendAllTasks();\n   \n   p = malloc(size);\n   \n   osResumeAllTasks();\n\n   \n   TRACE_DEBUG(\"Allocating %u bytes at 0x%08X\\r\\n\", size, (uint_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08X\\r\\n\", (uint_t) p);\n\n      \n      osSuspendAllTasks();\n      \n      free(p);\n      \n      osResumeAllTasks();\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"os_port.h\"\n#include \"os_port_embos.h\"\n#include \"debug.h\"\n\n\nvoid osIdleTaskHook(void);\n\n\nstatic OS_TASK *tcbTable[OS_PORT_MAX_TASKS];\nstatic void *stkTable[OS_PORT_MAX_TASKS];\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   osMemset(tcbTable, 0, sizeof(tcbTable));\n   osMemset(stkTable, 0, sizeof(stkTable));\n\n   \n   OS_IncDI();\n   \n   OS_InitKern();\n   \n   OS_InitHW();\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n   OS_Start();\n}\n\n\n\n\nbool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   \n   OS_CreateTaskEx(task, name, priority, taskCode,\n      stack, stackSize * sizeof(uint_t), 1, param);\n\n   \n   return TRUE;\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   OS_TASK *task;\n   void *stack;\n\n   \n   osSuspendAllTasks();\n\n   \n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      \n      if(tcbTable[i] == NULL)\n         break;\n   }\n\n   \n   if(i < OS_PORT_MAX_TASKS)\n   {\n      \n      task = osAllocMem(sizeof(OS_TASK));\n\n      \n      if(task != NULL)\n      {\n         \n         stack = osAllocMem(stackSize * sizeof(uint_t));\n\n         \n         if(stack != NULL)\n         {\n            \n            OS_CreateTaskEx(task, name, priority, taskCode,\n               stack, stackSize * sizeof(uint_t), 1, param);\n\n            \n            tcbTable[i] = task;\n            \n            stkTable[i] = stack;\n         }\n         else\n         {\n            osFreeMem(task);\n            \n            task = NULL;\n         }\n      }\n   }\n   else\n   {\n      \n      task = NULL;\n   }\n\n   \n   osResumeAllTasks();\n\n   \n   return task;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   OS_TerminateTask(task);\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   OS_Delay(OS_MS_TO_SYSTICKS(delay));\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   if(OS_IsRunning())\n   {\n      \n      OS_SuspendAllTasks();\n   }\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   if(OS_IsRunning())\n   {\n      \n      OS_ResumeAllSuspendedTasks();\n   }\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   OS_EVENT_Create(event);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   if(OS_IsRunning())\n   {\n      \n      OS_EVENT_Delete(event);\n   }\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   OS_EVENT_Set(event);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   OS_EVENT_Reset(event);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   bool_t ret;\n\n   \n   \n   if(timeout == 0)\n   {\n      \n      ret = OS_EVENT_Get(event);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      OS_EVENT_Wait(event);\n      ret = TRUE;\n   }\n   else\n   {\n      \n      ret = !OS_EVENT_WaitTimed(event, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   OS_EVENT_Set(event);\n\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   \n   OS_CreateCSema(semaphore, count);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   if(OS_IsRunning())\n   {\n      \n      OS_DeleteCSema(semaphore);\n   }\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   bool_t ret;\n\n   \n   if(timeout == 0)\n   {\n      \n      ret = OS_CSemaRequest(semaphore);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      OS_WaitCSema(semaphore);\n      ret = TRUE;\n   }\n   else\n   {\n      \n      ret = OS_WaitCSemaTimed(semaphore, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   OS_SignalCSema(semaphore);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   \n   OS_CreateRSema(mutex);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   if(OS_IsRunning())\n   {\n      \n      OS_DeleteRSema(mutex);\n   }\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   OS_Use(mutex);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   OS_Unuse(mutex);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = OS_GetTime32();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   p = OS_malloc(size);\n\n   \n   TRACE_DEBUG(\"Allocating %\" PRIuSIZE \" bytes at 0x%08\" PRIXPTR \"\\r\\n\", size, (uintptr_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08\" PRIXPTR \"\\r\\n\", (uintptr_t) p);\n\n      \n      OS_free(p);\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"os_port.h\"\n#include \"os_port_freertos.h\"\n#include \"debug.h\"\n\n\n\n\nvoid osInitKernel(void)\n{\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n   vTaskStartScheduler();\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   portBASE_TYPE status;\n   TaskHandle_t task = NULL;\n\n   \n   status = xTaskCreate((TaskFunction_t) taskCode, name, stackSize, param,\n      priority, &task);\n\n   \n   if(status == pdPASS)\n      return task;\n   else\n      return NULL;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   vTaskDelete((TaskHandle_t) task);\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   vTaskDelay(OS_MS_TO_SYSTICKS(delay));\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n   taskYIELD();\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)\n   {\n      \n      vTaskSuspendAll();\n   }\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)\n   {\n      \n      xTaskResumeAll();\n   }\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n#if (configSUPPORT_STATIC_ALLOCATION == 1)\n   \n   event->handle = xSemaphoreCreateBinaryStatic(&event->buffer);\n#else\n   \n   event->handle = xSemaphoreCreateBinary();\n#endif\n\n   \n   if(event->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   if(event->handle != NULL)\n   {\n      \n      vSemaphoreDelete(event->handle);\n   }\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   xSemaphoreGive(event->handle);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   xSemaphoreTake(event->handle, 0);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   portBASE_TYPE ret;\n\n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = xSemaphoreTake(event->handle, portMAX_DELAY);\n   }\n   else\n   {\n      \n      ret = xSemaphoreTake(event->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   portBASE_TYPE flag = FALSE;\n\n   \n   xSemaphoreGiveFromISR(event->handle, &flag);\n\n   \n   return flag;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n#if (configSUPPORT_STATIC_ALLOCATION == 1)\n   \n   semaphore->handle = xSemaphoreCreateCountingStatic(count, count,\n      &semaphore->buffer);\n#else\n   \n   semaphore->handle = xSemaphoreCreateCounting(count, count);\n#endif\n\n   \n   if(semaphore->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   if(semaphore->handle != NULL)\n   {\n      \n      vSemaphoreDelete(semaphore->handle);\n   }\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   portBASE_TYPE ret;\n\n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = xSemaphoreTake(semaphore->handle, portMAX_DELAY);\n   }\n   else\n   {\n      \n      ret = xSemaphoreTake(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   xSemaphoreGive(semaphore->handle);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n#if (configSUPPORT_STATIC_ALLOCATION == 1)\n   \n   mutex->handle = xSemaphoreCreateMutexStatic(&mutex->buffer);\n#else\n   \n   mutex->handle = xSemaphoreCreateMutex();\n#endif\n\n   \n   if(mutex->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   if(mutex->handle != NULL)\n   {\n      \n      vSemaphoreDelete(mutex->handle);\n   }\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   xSemaphoreTake(mutex->handle, portMAX_DELAY);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   xSemaphoreGive(mutex->handle);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = xTaskGetTickCount();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   p = pvPortMalloc(size);\n\n   \n   TRACE_DEBUG(\"Allocating %\" PRIuSIZE \" bytes at 0x%08\" PRIXPTR \"\\r\\n\", size, (uintptr_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08\" PRIXPTR \"\\r\\n\", (uintptr_t) p);\n\n      \n      vPortFree(p);\n   }\n}\n\n\n#if 0\n\n\n\nvoid vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)\n{\n   (void) pcTaskName;\n   (void) pxTask;\n\n   taskDISABLE_INTERRUPTS();\n   while(1);\n}\n\n\n\n\nvoid vAssertCalled(const char *pcFile, unsigned long ulLine)\n{\n   volatile unsigned long ul = 0;\n\n   (void) pcFile;\n   (void) ulLine;\n\n   taskENTER_CRITICAL();\n\n   \n   while(ul == 0)\n   {\n      portNOP();\n   }\n\n   taskEXIT_CRITICAL();\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"os_port.h\"\n#include \"os_port_none.h\"\n#include \"debug.h\"\n\n\n#if defined(__linux__) || defined(__FreeBSD__)\n   #include <sys\/time.h>\n#elif defined(_WIN32)\n   #include <windows.h>\n#endif\n\n\nsystime_t systemTicks = 0;\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   systemTicks = 0;\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   \n   return (OsTask *) (-1);\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   *event = FALSE;\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   *event = TRUE;\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   *event = FALSE;\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   \n   if(*event)\n   {\n      \n      *event = FALSE;\n      \n      return TRUE;\n   }\n   else\n   {\n      \n      return FALSE;\n   }\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   *event = TRUE;\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   \n   *semaphore = count;\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   \n   if(*semaphore > 0)\n   {\n      \n      *semaphore -= 1;\n      \n      return TRUE;\n   }\n   else\n   {\n      \n      return FALSE;\n   }\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   *semaphore += 1;\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n#if defined(__linux__) || defined(__FreeBSD__)\n   struct timeval tv;\n   \n   gettimeofday(&tv, NULL);\n   \n   time = (tv.tv_sec * 1000) + (tv.tv_usec \/ 1000);\n#elif defined(_WIN32)\n   \n   time = GetTickCount();\n#else\n   \n   time = systemTicks;\n#endif\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   p = malloc(size);\n\n   \n   TRACE_DEBUG(\"Allocating %\" PRIuSIZE \" bytes at 0x%08\" PRIXPTR \"\\r\\n\", size, (uintptr_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08\" PRIXPTR \"\\r\\n\", (uintptr_t) p);\n\n      \n      free(p);\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys\/time.h>\n#include \"os_port.h\"\n#include \"os_port_posix.h\"\n#include \"debug.h\"\n\n\ntypedef void *(*PthreadTaskCode) (void *param);\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   int_t ret;\n   pthread_t thread;\n\n   \n   ret = pthread_create(&thread, NULL, (PthreadTaskCode) taskCode, param);\n\n   \n   if(ret == 0)\n      return (OsTask *) thread;\n   else\n      return NULL;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   if(task == NULL)\n   {\n      \n      pthread_exit(NULL);\n   }\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   usleep(delay * 1000);\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   int_t ret;\n\n   \n   ret = sem_init(event, 0, 0);\n\n   \n   if(ret == 0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   sem_destroy(event);\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   int_t ret;\n   int_t value;\n\n   \n   ret = sem_getvalue(event, &value);\n\n   \n   if(ret == 0 && value == 0)\n   {\n      \n      sem_post(event);\n   }\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   int_t ret;\n\n   \n   do\n   {\n      \n      ret = sem_trywait(event);\n\n      \n   } while(ret == 0);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   int_t ret;\n   struct timespec ts;\n\n   \n   \n   if(timeout == 0)\n   {\n      \n      ret = sem_trywait(event);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = sem_wait(event);\n   }\n   else\n   {\n      \n      clock_gettime(CLOCK_REALTIME, &ts);\n\n      \n      ts.tv_sec += timeout \/ 1000;\n      ts.tv_nsec += (timeout % 1000) * 1000000;\n\n      \n      if(ts.tv_nsec >= 1000000000)\n      {\n         ts.tv_sec += 1;\n         ts.tv_nsec -= 1000000000;\n      }\n\n      \n      ret = sem_timedwait(event, &ts);\n   }\n\n   \n   if(ret == 0)\n   {\n      \n      do\n      {\n         \n         ret = sem_trywait(event);\n\n         \n      } while(ret == 0);\n\n      \n      return TRUE;\n   }\n   else\n   {\n      \n      return FALSE;\n   }\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   int_t ret;\n\n   \n   ret = sem_init(semaphore, 0, count);\n\n   \n   if(ret == 0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   sem_destroy(semaphore);\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   int_t ret;\n   struct timespec ts;\n\n   \n   if(timeout == 0)\n   {\n      \n      ret = sem_trywait(semaphore);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = sem_wait(semaphore);\n   }\n   else\n   {\n      \n      clock_gettime(CLOCK_REALTIME, &ts);\n\n      \n      ts.tv_sec += timeout \/ 1000;\n      ts.tv_nsec += (timeout % 1000) * 1000000;\n\n      \n      if(ts.tv_nsec >= 1000000000)\n      {\n         ts.tv_sec += 1;\n         ts.tv_nsec -= 1000000000;\n      }\n\n      \n      ret = sem_timedwait(semaphore, &ts);\n   }\n\n   \n   if(ret == 0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   sem_post(semaphore);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   int_t ret;\n\n   \n   ret = pthread_mutex_init(mutex, NULL);\n\n   \n   if(ret == 0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   pthread_mutex_destroy(mutex);\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   pthread_mutex_lock(mutex);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   pthread_mutex_unlock(mutex);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   struct timeval tv;\n\n   \n   gettimeofday(&tv, NULL);\n\n   \n   return (tv.tv_sec * 1000) + (tv.tv_usec \/ 1000);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   \n   return malloc(size);\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   free(p);\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"os_port.h\"\n#include \"os_port_rtx.h\"\n#include \"debug.h\"\n\n\nstatic bool_t running = FALSE;\nstatic OsTask taskTable[OS_PORT_MAX_TASKS];\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   running = FALSE;\n   \n   osMemset(taskTable, 0, sizeof(taskTable));\n}\n\n\n\n\nvoid osStartKernel(OsInitTaskCode task)\n{\n   \n   running = TRUE;\n   \n   os_sys_init(task);\n}\n\n\n\n\nbool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   \n   task->tid = os_tsk_create_user_ex(taskCode, priority, stack,\n      stackSize * sizeof(uint_t), param);\n\n   \n   if(task->tid != 0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   OsTask *task = NULL;\n\n   \n   osSuspendAllTasks();\n\n   \n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      \n      if(!taskTable[i].tid)\n         break;\n   }\n\n   \n   if(i < OS_PORT_MAX_TASKS)\n   {\n      \n      taskTable[i].tid = os_tsk_create_ex(taskCode, priority, param);\n\n      \n      if(taskTable[i].tid != 0)\n         task = &taskTable[i];\n   }\n\n   \n   osResumeAllTasks();\n\n   \n   return task;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   uint_t i;\n   OS_TID tid;\n\n   \n   if(task == NULL)\n      tid = os_tsk_self();\n   else\n      tid = task->tid;\n\n   \n   osSuspendAllTasks();\n\n   \n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      \n      if(taskTable[i].tid == tid)\n      {\n         \n         taskTable[i].tid = 0;\n      }\n   }\n\n   \n   osResumeAllTasks();\n\n   \n   if(task == NULL)\n   {\n      \n      os_tsk_delete_self();\n   }\n   else\n   {\n      \n      os_tsk_delete(tid);\n   }\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   uint16_t n;\n\n   \n   delay = OS_MS_TO_SYSTICKS(delay);\n\n   \n   while(delay > 0)\n   {\n      \n      n = MIN(delay, 0xFFFE);\n      \n      os_dly_wait(n);\n      \n      delay -= n;\n   }\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n   os_tsk_pass();\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   if(running)\n   {\n      \n      tsk_lock();\n   }\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   if(running)\n   {\n      \n      tsk_unlock();\n   }\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   os_sem_init(event, 0);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   os_sem_send(event);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   OS_RESULT res;\n\n   \n   do\n   {\n      \n      res = os_sem_wait(event, 0);\n\n      \n   } while(res == OS_R_OK);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   uint16_t n;\n   OS_RESULT res;\n\n   \n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      res = os_sem_wait(event, 0xFFFF);\n   }\n   else\n   {\n      \n      timeout = OS_MS_TO_SYSTICKS(timeout);\n\n      \n      do\n      {\n         \n         n = MIN(timeout, 0xFFFE);\n         \n         res = os_sem_wait(event, n);\n         \n         timeout -= n;\n\n         \n      } while(res == OS_R_TMO && timeout > 0);\n   }\n\n   \n   if(res == OS_R_OK || res == OS_R_SEM)\n   {\n      \n      do\n      {\n         \n         res = os_sem_wait(event, 0);\n\n         \n      } while(res == OS_R_OK);\n\n      \n      return TRUE;\n   }\n   else\n   {\n      \n      return FALSE;\n   }\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   isr_sem_send(event);\n\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   \n   os_sem_init(semaphore, count);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   uint16_t n;\n   OS_RESULT res;\n\n   \n   if(timeout == INFINITE_DELAY)\n   {\n      \n      res = os_sem_wait(semaphore, 0xFFFF);\n   }\n   else\n   {\n      \n      timeout = OS_MS_TO_SYSTICKS(timeout);\n\n      \n      do\n      {\n         \n         n = MIN(timeout, 0xFFFE);\n         \n         res = os_sem_wait(semaphore, n);\n         \n         timeout -= n;\n\n         \n      } while(res == OS_R_TMO && timeout > 0);\n   }\n\n   \n   if(res == OS_R_OK || res == OS_R_SEM)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   os_sem_send(semaphore);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   \n   os_mut_init(mutex);\n\n   \n   return TRUE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   os_mut_wait(mutex, 0xFFFF);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   os_mut_release(mutex);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = os_time_get();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   osSuspendAllTasks();\n   \n   p = malloc(size);\n   \n   osResumeAllTasks();\n\n   \n   TRACE_DEBUG(\"Allocating %u bytes at 0x%08X\\r\\n\", size, (uint_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08X\\r\\n\", (uint_t) p);\n\n      \n      osSuspendAllTasks();\n      \n      free(p);\n      \n      osResumeAllTasks();\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"os_port.h\"\n#include \"os_port_sys_bios.h\"\n#include \"debug.h\"\n\n\nstatic bool_t running = FALSE;\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n   running = FALSE;\n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n   running = TRUE;\n   \n   BIOS_start();\n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   Error_Block eb;\n   Task_Params taskParams;\n   Task_Handle task;\n\n   \n   Error_init(&eb);\n\n   \n   Task_Params_init(&taskParams);\n   taskParams.arg0 = (UArg) param;\n   taskParams.stackSize = stackSize * sizeof(uint_t);\n   taskParams.priority = priority;\n\n   \n   task = Task_create((Task_FuncPtr) taskCode, &taskParams, &eb);\n\n   \n   return task;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   Task_delete(&task);\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   Task_sleep(OS_MS_TO_SYSTICKS(delay));\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n   Task_yield();\n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n   if(running)\n   {\n      \n      Task_disable();\n   }\n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n   if(running)\n   {\n      \n      Task_enable();\n   }\n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   event->handle = Event_create(NULL, NULL);\n\n   \n   if(event->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   if(event->handle != NULL)\n   {\n      \n      Event_delete(&event->handle);\n   }\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   Event_post(event->handle, Event_Id_00);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   Event_pend(event->handle, Event_Id_00, Event_Id_NONE, BIOS_NO_WAIT);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   Bool ret;\n\n   \n   if(timeout == 0)\n   {\n      \n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      \n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   Event_post(event->handle, Event_Id_00);\n\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   Semaphore_Params semaphoreParams;\n\n   \n   Semaphore_Params_init(&semaphoreParams);\n   semaphoreParams.mode = Semaphore_Mode_COUNTING;\n\n   \n   semaphore->handle = Semaphore_create(count, &semaphoreParams, NULL);\n\n   \n   if(semaphore->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   if(semaphore->handle != NULL)\n   {\n      \n      Semaphore_delete(&semaphore->handle);\n   }\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   Bool ret;\n\n   \n   if(timeout == 0)\n   {\n      \n      ret = Semaphore_pend(semaphore->handle, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      \n      ret = Semaphore_pend(semaphore->handle, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      \n      ret = Semaphore_pend(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n\n   \n   return ret;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   Semaphore_post(semaphore->handle);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   Semaphore_Params semaphoreParams;\n\n   \n   Semaphore_Params_init(&semaphoreParams);\n   semaphoreParams.mode = Semaphore_Mode_BINARY_PRIORITY;\n\n   \n   mutex->handle = Semaphore_create(1, &semaphoreParams, NULL);\n\n   \n   if(mutex->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   if(mutex->handle != NULL)\n   {\n      \n      Semaphore_delete(&mutex->handle);\n   }\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   Semaphore_pend(mutex->handle, BIOS_WAIT_FOREVER);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   Semaphore_post(mutex->handle);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   systime_t time;\n\n   \n   time = Clock_getTicks();\n\n   \n   return OS_SYSTICKS_TO_MS(time);\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   void *p;\n\n   \n   osSuspendAllTasks();\n   \n   p = malloc(size);\n   \n   osResumeAllTasks();\n\n   \n   TRACE_DEBUG(\"Allocating %\" PRIuSIZE \" bytes at 0x%08\" PRIXPTR \"\\r\\n\", size, (uintptr_t) p);\n\n   \n   return p;\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   if(p != NULL)\n   {\n      \n      TRACE_DEBUG(\"Freeing memory at 0x%08\" PRIXPTR \"\\r\\n\", (uintptr_t) p);\n\n      \n      osSuspendAllTasks();\n      \n      free(p);\n      \n      osResumeAllTasks();\n   }\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TRACE_LEVEL_OFF\n\n\n#if (defined(_WIN32) && defined(_DEBUG))\n   #define _CRTDBG_MAP_ALLOC\n   #include <stdlib.h>\n   #include <crtdbg.h>\n#endif\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <windows.h>\n#include \"os_port.h\"\n#include \"os_port_windows.h\"\n#include \"debug.h\"\n\n\n\n\nvoid osInitKernel(void)\n{\n   \n}\n\n\n\n\nvoid osStartKernel(void)\n{\n   \n}\n\n\n\n\nOsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   void *handle;\n\n   \n   handle = CreateThread(NULL, 0,\n      (LPTHREAD_START_ROUTINE) taskCode, param, 0, NULL);\n\n   \n   return handle;\n}\n\n\n\n\nvoid osDeleteTask(OsTask *task)\n{\n   \n   if(task == NULL)\n   {\n      \n      ExitThread(0);\n   }\n   else\n   {\n      \n      TerminateThread(task, 0);\n   }\n}\n\n\n\n\nvoid osDelayTask(systime_t delay)\n{\n   \n   Sleep(delay);\n}\n\n\n\n\nvoid osSwitchTask(void)\n{\n   \n}\n\n\n\n\nvoid osSuspendAllTasks(void)\n{\n   \n}\n\n\n\n\nvoid osResumeAllTasks(void)\n{\n   \n}\n\n\n\n\nbool_t osCreateEvent(OsEvent *event)\n{\n   \n   event->handle = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n   \n   if(event->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteEvent(OsEvent *event)\n{\n   \n   if(event->handle != NULL)\n   {\n      \n      CloseHandle(event->handle);\n   }\n}\n\n\n\n\nvoid osSetEvent(OsEvent *event)\n{\n   \n   SetEvent(event->handle);\n}\n\n\n\n\nvoid osResetEvent(OsEvent *event)\n{\n   \n   ResetEvent(event->handle);\n}\n\n\n\n\nbool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   \n   if(WaitForSingleObject(event->handle, timeout) == WAIT_OBJECT_0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nbool_t osSetEventFromIsr(OsEvent *event)\n{\n   \n   return FALSE;\n}\n\n\n\n\nbool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   \n   semaphore->handle = CreateSemaphore(NULL, count, count, NULL);\n\n   \n   if(semaphore->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteSemaphore(OsSemaphore *semaphore)\n{\n   \n   if(semaphore->handle != NULL)\n   {\n      \n      CloseHandle(semaphore->handle);\n   }\n}\n\n\n\n\nbool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   \n   if(WaitForSingleObject(semaphore->handle, timeout) == WAIT_OBJECT_0)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osReleaseSemaphore(OsSemaphore *semaphore)\n{\n   \n   ReleaseSemaphore(semaphore->handle, 1, NULL);\n}\n\n\n\n\nbool_t osCreateMutex(OsMutex *mutex)\n{\n   \n   mutex->handle = CreateMutex(NULL, FALSE, NULL);\n\n   \n   if(mutex->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nvoid osDeleteMutex(OsMutex *mutex)\n{\n   \n   if(mutex->handle != NULL)\n   {\n      \n      CloseHandle(mutex->handle);\n   }\n}\n\n\n\n\nvoid osAcquireMutex(OsMutex *mutex)\n{\n   \n   WaitForSingleObject(mutex->handle, INFINITE);\n}\n\n\n\n\nvoid osReleaseMutex(OsMutex *mutex)\n{\n   \n   ReleaseMutex(mutex->handle);\n}\n\n\n\n\nsystime_t osGetSystemTime(void)\n{\n   \n   return GetTickCount();\n}\n\n\n\n\nvoid *osAllocMem(size_t size)\n{\n   \n   return malloc(size);\n}\n\n\n\n\nvoid osFreeMem(void *p)\n{\n   \n   free(p);\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#include <string.h>\n#include <ctype.h>\n#include \"path.h\"\n\n\n\n\nbool_t pathIsAbsolute(const char_t *path)\n{\n   \n   if(path[0] == '\/' || path[0] == '\\\\')\n      return TRUE;\n   else\n      return FALSE;\n}\n\n\n\n\nbool_t pathIsRelative(const char_t *path)\n{\n   \n   if(path[0] == '\/' || path[0] == '\\\\')\n      return FALSE;\n   else\n      return TRUE;\n}\n\n\n\n\nconst char_t *pathGetFilename(const char_t *path)\n{\n   size_t n;\n\n   \n   n = osStrlen(path);\n\n   \n   while(n > 0)\n   {\n      \n      if(path[n - 1] != '\/' && path[n - 1] != '\\\\')\n         break;\n\n      \n      n--;\n   }\n\n   \n   while(n > 0)\n   {\n      \n      if(path[n - 1] == '\/' || path[n - 1] == '\\\\')\n         break;\n\n      \n      n--;\n   }\n\n   \n   return path + n;\n}\n\n\n\n\nvoid pathRemoveFilename(char_t *path)\n{\n   char_t *p;\n\n   \n   p = (char_t *) pathGetFilename(path);\n   *p = '\\0';\n}\n\n\n\n\nvoid pathCopy(char_t *dest, const char_t *src, size_t maxLen)\n{\n   size_t n;\n\n   \n   n = osStrlen(src);\n   \n   n = MIN(n, maxLen);\n\n   \n   osStrncpy(dest, src, n);\n   \n   dest[n] = '\\0';\n}\n\n\n\n\nvoid pathCanonicalize(char_t *path)\n{\n   size_t i;\n   size_t j;\n   size_t k;\n\n   \n   i = 0;\n   k = 0;\n\n   \n   while(path[i] != '\\0')\n   {\n      \n      if(path[i] == '\/' || path[i] == '\\\\')\n      {\n         path[k++] = '\/';\n         while(path[i] == '\/' || path[i] == '\\\\') i++;\n      }\n      else\n      {\n         path[k++] = path[i++];\n      }\n   }\n\n   \n   path[k] = '\\0';\n\n   \n   i = 0;\n   j = 0;\n   k = 0;\n\n   \n   do\n   {\n      \n      if(path[i] == '\/' || path[i] == '\\0')\n      {\n         \n         if((i - j) == 1 && !osStrncmp(path + j, \".\", 1))\n         {\n            \n            if(k == 0)\n            {\n               if(path[i] == '\\0')\n               {\n                  path[k++] = '.';\n               }\n               else if(path[i] == '\/' && path[i + 1] == '\\0')\n               {\n                  path[k++] = '.';\n                  path[k++] = '\/';\n               }\n            }\n            else if(k > 1)\n            {\n               \n               if(path[i] == '\\0')\n                  k--;\n            }\n         }\n         \n         else if((i - j) == 2 && !osStrncmp(path + j, \"..\", 2))\n         {\n            \n            if(k == 0)\n            {\n               path[k++] = '.';\n               path[k++] = '.';\n\n               \n               if(path[i] == '\/')\n                  path[k++] = '\/';\n            }\n            else if(k > 1)\n            {\n               \n               for(j = 1; j < k; j++)\n               {\n                  if(path[k - j - 1] == '\/')\n                     break;\n               }\n\n               \n               if(j < k)\n               {\n                  if(!osStrncmp(path + k - j, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                  }\n                  else\n                  {\n                     k = k - j - 1;\n                  }\n\n                  \n                  if(k == 0 && path[0] == '\/')\n                     path[k++] = '\/';\n                  else if(path[i] == '\/')\n                     path[k++] = '\/';\n               }\n               \n               else\n               {\n                  if(k == 3 && !osStrncmp(path, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n\n                     \n                     if(path[i] == '\/')\n                        path[k++] = '\/';\n                  }\n                  else if(path[i] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                  }\n                  else if(path[i] == '\/' && path[i + 1] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                     path[k++] = '\/';\n                  }\n                  else\n                  {\n                     k = 0;\n                  }\n               }\n            }\n         }\n         else\n         {\n            \n            osMemmove(path + k, path + j, i - j);\n            \n            k += i - j;\n\n            \n            if(path[i] == '\/')\n               path[k++] = '\/';\n         }\n\n         \n         while(path[i] == '\/') i++;\n         j = i;\n      }\n   } while(path[i++] != '\\0');\n\n   \n   path[k] = '\\0';\n}\n\n\n\n\nvoid pathAddSlash(char_t *path, size_t maxLen)\n{\n   size_t n;\n\n   \n   n = osStrlen(path);\n\n   \n   if(!n)\n   {\n      \n      if(maxLen >= 1)\n         osStrcpy(path, \"\/\");\n   }\n   else if(path[n - 1] != '\/' && path[n - 1] != '\\\\')\n   {\n      \n      if(maxLen >= (n + 1))\n         osStrcat(path, \"\/\");\n   }\n}\n\n\n\n\nvoid pathRemoveSlash(char_t *path)\n{\n   char_t *end;\n\n   \n   if(pathIsAbsolute(path))\n      path++;\n\n   \n   for(end = NULL; *path != '\\0'; path++)\n   {\n      if(*path != '\/' && *path != '\\\\')\n         end = NULL;\n      else if(!end)\n         end = path;\n   }\n\n   \n   if(end)\n      *end = '\\0';\n}\n\n\n\n\nvoid pathCombine(char_t *path, const char_t *more, size_t maxLen)\n{\n   size_t n1;\n   size_t n2;\n\n   \n   if(*path != '\\0')\n      pathAddSlash(path, maxLen);\n\n   \n   while(*more == '\/' || *more == '\\\\') more++;\n\n   \n   n1 = osStrlen(path);\n   \n   n2 = osStrlen(more);\n\n   \n   if(n1 < maxLen)\n   {\n      \n      n2 = MIN(n2, maxLen - n1);\n      \n      osStrncpy(path + n1, more, n2);\n      \n      path[n1 + n2] = '\\0';\n   }\n}\n\n\n\n\nbool_t pathMatch(const char_t *path, const char_t *pattern)\n{\n   size_t i = 0;\n   size_t j = 0;\n\n   \n   while(pattern[j] != '\\0')\n   {\n      \n      if(pattern[j] == '?')\n      {\n         \n         if(path[i] == '\\0')\n         {\n            return FALSE;\n         }\n         else\n         {\n            \n            i++;\n            \n            j++;\n         }\n      }\n      else if(pattern[j] == '*')\n      {\n         \n         if(path[i] == '\\0')\n         {\n            \n            j++;\n         }\n         else if(pathMatch(path + i, pattern + j + 1))\n         {\n            return TRUE;\n         }\n         else\n         {\n            \n            i++;\n         }\n      }\n      else\n      {\n         \n         if(osTolower(path[i]) != osTolower(pattern[j]))\n         {\n            return FALSE;\n         }\n         else\n         {\n            \n            i++;\n            \n            j++;\n         }\n      }\n   }\n\n   \n   if(path[i] == '\\0' && pattern[j] == '\\0')\n      return TRUE;\n   else\n      return FALSE;\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#include <string.h>\n#include \"os_port.h\"\n#include \"resource_manager.h\"\n#include \"debug.h\"\n\n\nextern const uint8_t res[];\n\n\nerror_t resGetData(const char_t *path, const uint8_t **data, size_t *length)\n{\n   bool_t found;\n   bool_t match;\n   uint_t n;\n   uint_t dirLength;\n   ResEntry *resEntry;\n\n   \n   ResHeader *resHeader = (ResHeader *) res;\n\n   \n   if(resHeader->totalSize < sizeof(ResHeader))\n      return ERROR_INVALID_RESOURCE;\n\n   \n   dirLength = resHeader->rootEntry.dataLength;\n   \n   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);\n\n   \n   for(found = FALSE; !found && path[0] != '\\0'; path += n + 1)\n   {\n      \n      for(n = 0; path[n] != '\\\\' && path[n] != '\/' && path[n] != '\\0'; n++);\n\n      if(n == 0 && path[n] != '\\0')\n      {\n         path++;\n         for(n = 0; path[n] != '\\\\' && path[n] != '\/' && path[n] != '\\0'; n++);\n      }\n\n      \n      for(match = FALSE; !match && dirLength > 0; )\n      {\n         \n         if(dirLength < sizeof(ResEntry))\n            return ERROR_INVALID_RESOURCE;\n         \n         if(dirLength < (sizeof(ResEntry) + resEntry->nameLength))\n            return ERROR_INVALID_RESOURCE;\n\n         \n         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))\n         {\n            \n            if(resEntry->type == RES_TYPE_DIR)\n            {\n               \n               dirLength = resEntry->dataLength;\n               \n               resEntry = (ResEntry *) (res + resEntry->dataStart);\n            }\n            else\n            {\n               \n               if(path[n] != '\\0')\n                  return ERROR_NOT_FOUND;\n\n               \n               found = TRUE;\n            }\n            \n            match = TRUE;\n         }\n         else\n         {\n            \n            dirLength -= sizeof(ResEntry) + resEntry->nameLength;\n            \n            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);\n         }\n      }\n\n      \n      if(!match)\n         return ERROR_NOT_FOUND;\n   }\n\n   \n   if(!found)\n      return ERROR_NOT_FOUND;\n   \n   if(resEntry->type != RES_TYPE_FILE)\n      return ERROR_NOT_FOUND;\n\n   \n   *data = res + resEntry->dataStart;\n   \n   *length = resEntry->dataLength;\n\n   \n   return NO_ERROR;\n}\n\n\nerror_t resSearchFile(const char_t *path, DirEntry *dirEntry)\n{\n   bool_t found;\n   bool_t match;\n   uint_t n;\n   uint_t length;\n   ResEntry *resEntry;\n\n   \n   ResHeader *resHeader = (ResHeader *) res;\n\n   \n   if(resHeader->totalSize < sizeof(ResHeader))\n      return ERROR_INVALID_RESOURCE;\n\n   \n   length = resHeader->rootEntry.dataLength;\n   \n   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);\n\n   \n   for(found = FALSE; !found && path[0] != '\\0'; path += n + 1)\n   {\n      \n      for(n = 0; path[n] != '\\\\' && path[n] != '\/' && path[n] != '\\0'; n++);\n\n      if(n == 0 && path[n] != '\\0')\n      {\n         path++;\n         for(n = 0; path[n] != '\\\\' && path[n] != '\/' && path[n] != '\\0'; n++);\n      }\n\n      \n      for(match = FALSE; !match && length > 0; )\n      {\n         \n         if(length < sizeof(ResEntry))\n            return ERROR_INVALID_RESOURCE;\n         \n         if(length < (sizeof(ResEntry) + resEntry->nameLength))\n            return ERROR_INVALID_RESOURCE;\n\n         \n         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))\n         {\n            \n            if(resEntry->type == RES_TYPE_DIR)\n            {\n               \n               length = resEntry->dataLength;\n               \n               resEntry = (ResEntry *) (res + resEntry->dataStart);\n            }\n            else\n            {\n               \n               if(path[n] != '\\0')\n                  return ERROR_INVALID_PATH;\n\n               \n               found = TRUE;\n            }\n            \n            match = TRUE;\n         }\n         else\n         {\n            \n            length -= sizeof(ResEntry) + resEntry->nameLength;\n            \n            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);\n         }\n      }\n\n      \n      if(!match)\n         return ERROR_NOT_FOUND;\n   }\n\n   \n   if(!found)\n      return ERROR_NOT_FOUND;\n\n   \n   dirEntry->type = resEntry->type;\n   dirEntry->volume = 0;\n   dirEntry->dataStart = resEntry->dataStart;\n   dirEntry->dataLength = resEntry->dataLength;\n   dirEntry->nameLength = 0; \n   \n   \n   \n   \n\n   \n   return NO_ERROR;\n}\n\n#if 0\n\nerror_t resOpenFile(FsFile *file, const DirEntry *dirEntry, uint_t mode)\n{\n   file->mode = mode;\n   file->offset = 0;\n   file->start = dirEntry->dataStart;\n   file->size = dirEntry->dataLength;\n\n   return NO_ERROR;\n}\n\n\nerror_t resSeekFile(FsFile *file, uint32_t *position)\n{\n   return ERROR_NOT_IMPLEMENTED;\n}\n\n\nuint_t resReadFile(FsFile *file, void *data, size_t length)\n{\n   length = MIN(length, file->size - file->offset);\n   osMemcpy(data, res + file->start + file->offset, length);\n   file->offset += length;\n   return length;\n}\n\nFILE *fopen(const char_t *filename, const char_t *mode)\n{\n   error_t error;\n   DirEntry dirEntry;\n   FsFile *file;\n\n   error = resSearchFile(filename, &dirEntry);\n   if(error)\n      return NULL;\n\n   file = osAllocMem(sizeof(FsFile));\n   if(!file)\n      return NULL;\n\n   error = resOpenFile(file, &dirEntry, MODE_BINARY);\n   if(error)\n   {\n      osFreeMem(file);\n      return NULL;\n   }\n\n   return (FILE *) file;\n}\n\n\nsize_t fread(void *ptr, size_t size, size_t count, FILE *stream)\n{\n   uint_t n;\n\n   n = resReadFile((FsFile *) stream, ptr, size * count);\n\n   return n \/ size;\n}\n\n\nint_t fclose(FILE * stream)\n{\n   osFreeMem(stream);\n   \n   return 0;\n}\n\n\nuint_t fileGetSize(FILE *stream)\n{\n   uint_t n;\n   n = ((FsFile *) stream)->size;\n   return n;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include \"str.h\"\n\n\n\n\nchar_t *strDuplicate(const char_t *s)\n{\n   uint_t n;\n   char_t *p;\n\n   \n   p = NULL;\n\n   \n   if(s != NULL)\n   {\n      \n      n = osStrlen(s) + 1;\n\n      \n      p = osAllocMem(n);\n\n      \n      if(p != NULL)\n      {\n         \n         osMemcpy(p, s, n);\n      }\n   }\n\n   \n   return p;\n}\n\n\n\n\nchar_t *strTrimWhitespace(char_t *s)\n{\n   char_t *end;\n   char_t *result;\n\n   \n   while(isspace((uint8_t) *s))\n   {\n      s++;\n   }\n\n   \n   result = s;\n\n   \n   \n   for(end = NULL; *s != '\\0'; s++)\n   {\n      if(!isspace((uint8_t) *s))\n         end = NULL;\n      else if(!end)\n         end = s;\n   }\n\n   \n   if(end)\n      *end = '\\0';\n\n   \n   \n   return result;\n}\n\n\n\n\nvoid strRemoveTrailingSpace(char_t *s)\n{\n   char_t *end;\n\n   \n   \n   for(end = NULL; *s != '\\0'; s++)\n   {\n      if(!isspace((uint8_t) *s))\n         end = NULL;\n      else if(!end)\n         end = s;\n   }\n\n   \n   if(end)\n      *end = '\\0';\n}\n\n\n\n\nvoid strReplaceChar(char_t *s, char_t oldChar, char_t newChar)\n{\n   \n   while(*s != '\\0')\n   {\n      \n      if(*s == oldChar)\n         *s = newChar;\n\n      \n      s++;\n   }\n}\n\n\n\n\nerror_t strSafeCopy(char_t *dest, const char_t *src, size_t destSize)\n{\n   size_t n;\n\n   \n   if(dest == NULL || src == NULL || destSize < 1)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   n = osStrlen(src);\n   \n   n = MIN(n, destSize - 1);\n\n   \n   osStrncpy(dest, src, n);\n   \n   dest[n] = '\\0';\n\n   \n   return NO_ERROR;\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL ACME_TRACE_LEVEL\n\n\n#include \"acme\/acme_client.h\"\n#include \"acme\/acme_client_auth.h\"\n#include \"acme\/acme_client_challenge.h\"\n#include \"acme\/acme_client_jose.h\"\n#include \"acme\/acme_client_misc.h\"\n#include \"jansson.h\"\n#include \"debug.h\"\n\n\n#if (ACME_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t acmeClientSendAuthorizationRequest(AcmeClientContext *context,\n   AcmeAuthorization *authorization)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         \n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET AUTHORIZATION ##########################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n\n         \n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         \n         error = acmeFormatAuthorizationRequest(context, authorization);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         \n         \n         \n         \n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            authorization->url);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         \n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         \n         error = acmeClientParseAuthorizationResponse(context, authorization);\n\n         \n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         \n         error = ERROR_WRONG_STATE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeFormatAuthorizationRequest(AcmeClientContext *context,\n   const AcmeAuthorization *authorization)\n{\n   error_t error;\n   size_t n;\n   char_t *protected;\n   const char_t *payload;\n\n   \n   payload = \"\";\n\n   \n   protected = context->buffer;\n\n   \n   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n      context->account.url, context->nonce, authorization->url, protected, &n);\n\n   \n   if(!error)\n   {\n      \n      error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n         payload, context->accountKey.alg, context->accountKey.crv,\n         context->accountKey.privateKey, context->buffer, &context->bufferLen);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientParseAuthorizationResponse(AcmeClientContext *context,\n   AcmeAuthorization *authorization)\n{\n   error_t error;\n   uint_t i;\n   uint_t n;\n   const char_t *status;\n   const char_t *value;\n   const char_t *type;\n   const char_t *url;\n   const char_t *token;\n   json_t *rootObj;\n   json_t *statusObj;\n   json_t *identifierObj;\n   json_t *valueObj;\n   json_t *wildcardObj;\n   json_t *arrayObj;\n   json_t *challengeObj;\n   json_t *typeObj;\n   json_t *urlObj;\n   json_t *tokenObj;\n   AcmeChallenge *challenge;\n   AcmeChallengeType challengeType;\n\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   \n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(osStrcasecmp(context->contentType, \"application\/json\"))\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n\n   \n   error = ERROR_INVALID_RESPONSE;\n\n   \n   rootObj = json_loads(context->buffer, 0, NULL);\n\n   \n   do\n   {\n      \n      if(!json_is_object(rootObj))\n         break;\n\n      \n      statusObj = json_object_get(rootObj, \"status\");\n\n      \n      if(!json_is_string(statusObj))\n         break;\n\n      \n      status = json_string_value(statusObj);\n      \n      authorization->status = acmeClientParseAuthorizationStatus(status);\n\n      \n      identifierObj = json_object_get(rootObj, \"identifier\");\n\n      \n      if(!json_is_object(identifierObj))\n         break;\n\n      \n      valueObj = json_object_get(identifierObj, \"value\");\n\n      \n      if(!json_is_string(valueObj))\n         break;\n\n      \n      value = json_string_value(valueObj);\n\n      \n      if(osStrlen(value) > ACME_CLIENT_MAX_URL_LEN)\n         break;\n\n      \n      wildcardObj = json_object_get(rootObj, \"wildcard\");\n\n      \n      if(json_is_boolean(wildcardObj))\n      {\n         \n         authorization->wildcard = json_boolean_value(wildcardObj);\n      }\n\n      \n      challengeType = acmeClientGetChallengeType(context, value,\n         authorization->wildcard);\n\n      \n      if(authorization->status == ACME_AUTH_STATUS_PENDING)\n      {\n         \n         arrayObj = json_object_get(rootObj, \"challenges\");\n\n         \n         if(!json_is_array(arrayObj))\n            break;\n\n         \n         n = json_array_size(arrayObj);\n\n         \n         for(i = 0; i < n; i++)\n         {\n            \n            challengeObj = json_array_get(arrayObj, i);\n\n            \n            if(!json_is_object(challengeObj))\n               break;\n\n            \n            typeObj = json_object_get(challengeObj, \"type\");\n            urlObj = json_object_get(challengeObj, \"url\");\n            statusObj = json_object_get(challengeObj, \"status\");\n\n            \n            if(!json_is_string(typeObj) ||\n               !json_is_string(urlObj) ||\n               !json_is_string(statusObj))\n            {\n               break;\n            }\n\n            \n            type = json_string_value(typeObj);\n            url = json_string_value(urlObj);\n            status = json_string_value(statusObj);\n\n            \n            if(acmeClientParseChallengeType(type) == challengeType)\n            {\n               \n               tokenObj = json_object_get(challengeObj, \"token\");\n\n               \n               if(!json_is_string(tokenObj))\n                  break;\n\n               \n               token = json_string_value(tokenObj);\n\n               \n               if(osStrlen(url) <= ACME_CLIENT_MAX_URL_LEN &&\n                  osStrlen(token) <= ACME_CLIENT_MAX_URL_LEN &&\n                  osStrlen(value) <= ACME_CLIENT_MAX_NAME_LEN)\n               {\n                  \n                  challenge = &context->challenges[context->numChallenges];\n\n                  \n                  challenge->status = acmeClientParseChallengeStatus(status);\n                  \n                  osStrcpy(challenge->url, url);\n                  \n                  osStrcpy(challenge->token, token);\n\n                  \n                  osStrcpy(challenge->identifier, value);\n                  challenge->wildcard = authorization->wildcard;\n\n                  \n                  challenge->type = challengeType;\n\n                  \n                  \n                  error = acmeClientGenerateKeyAuthorization(context, challenge);\n\n                  \n                  if(!error)\n                  {\n                     \n                     if(challenge->type == ACME_CHALLENGE_TYPE_DNS_01)\n                     {\n                        \n                        \n                        error = acmeClientDigestKeyAuthorization(context,\n                           challenge);\n                     }\n                     else if(challenge->type == ACME_CHALLENGE_TYPE_TLS_ALPN_01)\n                     {\n                        \n                        \n                        error = acmeClientGenerateTlsAlpnCert(context, challenge);\n                     }\n                     else\n                     {\n                        \n                     }\n                  }\n\n                  \n                  if(!error)\n                  {\n                     \n                     context->numChallenges++;\n                  }\n\n                  \n                  break;\n               }\n            }\n         }\n      }\n      else\n      {\n         \n         \n         error = NO_ERROR;\n      }\n\n      \n   } while(0);\n\n   \n   json_decref(rootObj);\n\n   \n   return error;\n}\n\n\n\n\nAcmeAuthStatus acmeClientParseAuthorizationStatus(const char_t *label)\n{\n   AcmeAuthStatus status;\n\n   \n   if(!osStrcmp(label, \"pending\"))\n   {\n      \n      status = ACME_AUTH_STATUS_PENDING;\n   }\n   else if(!osStrcmp(label, \"valid\"))\n   {\n      \n      \n      status = ACME_AUTH_STATUS_VALID;\n   }\n   else if(!osStrcmp(label, \"invalid\"))\n   {\n      \n      \n      \n      status = ACME_AUTH_STATUS_INVALID;\n   }\n   else if(!osStrcmp(label, \"expired\"))\n   {\n      \n      status = ACME_AUTH_STATUS_EXPIRED;\n   }\n   else if(!osStrcmp(label, \"deactivated\"))\n   {\n      \n      status = ACME_AUTH_STATUS_DEACTIVATED;\n   }\n   else if(!osStrcmp(label, \"revoked\"))\n   {\n      \n      status = ACME_AUTH_STATUS_REVOKED;\n   }\n   else\n   {\n      \n      status = ACME_AUTH_STATUS_INVALID;\n   }\n\n   \n   return status;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL ACME_TRACE_LEVEL\n\n\n#include \"acme\/acme_client.h\"\n#include \"acme\/acme_client_certificate.h\"\n#include \"acme\/acme_client_jose.h\"\n#include \"acme\/acme_client_misc.h\"\n#include \"pkix\/pem_import.h\"\n#include \"encoding\/base64url.h\"\n#include \"jansson.h\"\n#include \"jansson_private.h\"\n#include \"debug.h\"\n\n\n#if (ACME_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t acmeClientSendDownloadCertRequest(AcmeClientContext *context,\n   char_t *buffer, size_t size, size_t *length)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         \n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## DOWNLOAD CERTIFICATE #######################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n\n         \n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         \n         error = acmeClientFormatDownloadCertRequest(context);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         \n         \n         \n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            context->order.certificate);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         \n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         \n         error = acmeClientParseDownloadCertResponse(context, buffer, size,\n            length);\n\n         \n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         \n         error = ERROR_WRONG_STATE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientFormatDownloadCertRequest(AcmeClientContext *context)\n{\n   error_t error;\n   size_t n;\n   char_t *protected;\n   const char_t *payload;\n\n   \n   payload = \"\";\n\n   \n   protected = context->buffer;\n\n   \n   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n      context->account.url, context->nonce, context->order.certificate,\n      protected, &n);\n\n   \n   if(!error)\n   {\n      \n      error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n         payload, context->accountKey.alg, context->accountKey.crv,\n         context->accountKey.privateKey, context->buffer, &context->bufferLen);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientParseDownloadCertResponse(AcmeClientContext *context,\n   char_t *buffer, size_t size, size_t *length)\n{\n   error_t error;\n   size_t n;\n\n   \n   error = NO_ERROR;\n\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   \n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(osStrcasecmp(context->contentType, \"application\/pem-certificate-chain\"))\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n\n   \n   error = pemImportCertificate(context->buffer, context->bufferLen, NULL,\n      &n, NULL);\n   \n   if(error)\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(context->bufferLen > size)\n      return ERROR_BUFFER_OVERFLOW;\n\n   \n   osMemcpy(buffer, context->buffer, context->bufferLen);\n\n   \n   *length = context->bufferLen;\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientSendRevokeCertRequest(AcmeClientContext *context,\n   const char_t *cert, size_t certLen, AcmeReasonCode reason)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         \n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## REVOKE CERTIFICATE #########################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n\n         \n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         \n         error = acmeClientFormatRevokeCertRequest(context, cert, certLen, reason);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         \n         \n         \n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            context->directory.revokeCert);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         \n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         \n         error = acmeClientParseRevokeCertResponse(context);\n\n         \n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         \n         error = ERROR_WRONG_STATE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientFormatRevokeCertRequest(AcmeClientContext *context,\n   const char_t *cert, size_t certLen, AcmeReasonCode reason)\n{\n   error_t error;\n   int_t ret;\n   size_t n;\n   char_t *protected;\n   char_t *payload;\n   json_t *payloadObj;\n\n   \n   error = pemImportCertificate(cert, certLen, (uint8_t *) context->buffer,\n      &n, NULL);\n   \n   if(error)\n      return error;\n\n   \n   base64urlEncode(context->buffer, n, context->buffer, &n);\n\n   \n   payloadObj = json_object();\n\n   \n   ret = json_object_set_new(payloadObj, \"certificate\",\n      json_string(context->buffer));\n\n   \n   ret |= json_object_set_new(payloadObj, \"reason\",\n      json_integer((json_int_t) reason));\n\n   \n   if(ret == 0)\n   {\n      \n      payload = json_dumps(payloadObj, JSON_COMPACT);\n   }\n   else\n   {\n      \n      payload = NULL;\n   }\n\n   \n   if(payload != NULL)\n   {\n      \n      protected = context->buffer;\n\n      \n      error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n         context->account.url, context->nonce, context->directory.revokeCert,\n         protected, &n);\n\n      \n      if(!error)\n      {\n         \n         error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n            payload, context->accountKey.alg, context->accountKey.crv,\n            context->accountKey.privateKey, context->buffer, &context->bufferLen);\n      }\n\n      \n      jsonp_free(payload);\n   }\n   else\n   {\n      \n      error = ERROR_FAILURE;\n   }\n\n   \n   json_decref(payloadObj);\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientParseRevokeCertResponse(AcmeClientContext *context)\n{\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   \n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL ACME_TRACE_LEVEL\n\n\n#include \"acme\/acme_client.h\"\n#include \"acme\/acme_client_directory.h\"\n#include \"acme\/acme_client_misc.h\"\n#include \"jansson.h\"\n#include \"debug.h\"\n\n\n#if (ACME_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t acmeClientSendDirectoryRequest(AcmeClientContext *context)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         \n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET DIRECTORY ##############################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n\n         \n         if(context->directory.newNonce[0] != '\\0' &&\n            context->directory.newAccount[0] != '\\0' &&\n            context->directory.newOrder[0] != '\\0' &&\n            context->directory.revokeCert[0] != '\\0' &&\n            context->directory.keyChange[0] != '\\0')\n         {\n            \n            break;\n         }\n         else\n         {\n            \n            \n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         \n         \n         error = acmeClientFormatRequestHeader(context, \"GET\",\n            context->directoryUri);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         \n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         \n         error = acmeClientParseDirectoryResponse(context);\n\n         \n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         \n         error = ERROR_WRONG_STATE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientParseDirectoryResponse(AcmeClientContext *context)\n{\n   error_t error;\n   const char_t *newNonce;\n   const char_t *newAccount;\n   const char_t *newOrder;\n   const char_t *revokeCert;\n   const char_t *keyChange;\n   json_t *rootObj;\n   json_t *newNonceObj;\n   json_t *newAccountObj;\n   json_t *newOrderObj;\n   json_t *revokeCertObj;\n   json_t *keyChangeObj;\n\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   if(osStrcasecmp(context->contentType, \"application\/json\"))\n      return ERROR_INVALID_RESPONSE;\n\n   \n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n\n   \n   error = ERROR_INVALID_RESPONSE;\n\n   \n   osMemset(&context->directory, 0, sizeof(AcmeDirectory));\n\n   \n   rootObj = json_loads(context->buffer, 0, NULL);\n\n   \n   if(json_is_object(rootObj))\n   {\n      \n      \n      newNonceObj = json_object_get(rootObj, \"newNonce\");\n      newAccountObj = json_object_get(rootObj, \"newAccount\");\n      newOrderObj = json_object_get(rootObj, \"newOrder\");\n      revokeCertObj = json_object_get(rootObj, \"revokeCert\");\n      keyChangeObj = json_object_get(rootObj, \"keyChange\");\n\n      \n      if(json_is_string(newNonceObj) &&\n         json_is_string(newAccountObj) &&\n         json_is_string(newOrderObj) &&\n         json_is_string(revokeCertObj) &&\n         json_is_string(keyChangeObj))\n      {\n         \n         newNonce = json_string_value(newNonceObj);\n         newAccount = json_string_value(newAccountObj);\n         newOrder = json_string_value(newOrderObj);\n         revokeCert = json_string_value(revokeCertObj);\n         keyChange = json_string_value(keyChangeObj);\n\n         \n         if(osStrlen(newNonce) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(newAccount) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(newOrder) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(revokeCert) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(keyChange) <= ACME_CLIENT_MAX_URL_LEN)\n         {\n            \n            osStrcpy(context->directory.newNonce, newNonce);\n            osStrcpy(context->directory.newAccount, newAccount);\n            osStrcpy(context->directory.newOrder, newOrder);\n            osStrcpy(context->directory.revokeCert, revokeCert);\n            osStrcpy(context->directory.keyChange, keyChange);\n\n            \n            error = NO_ERROR;\n         }\n      }\n   }\n\n   \n   json_decref(rootObj);\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL ACME_TRACE_LEVEL\n\n\n#include \"acme\/acme_client.h\"\n#include \"acme\/acme_client_nonce.h\"\n#include \"acme\/acme_client_misc.h\"\n#include \"debug.h\"\n\n\n#if (ACME_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t acmeClientSendNewNonceRequest(AcmeClientContext *context)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         \n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET NEW NONCE ###############################################################\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n\n         \n         if(context->nonce[0] != '\\0')\n         {\n            \n            break;\n         }\n         else\n         {\n            \n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         \n         \n         error = acmeClientFormatRequestHeader(context, \"HEAD\",\n            context->directory.newNonce);\n\n         \n         if(!error)\n         {\n            \n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         \n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         \n         error = acmeClientParseNewNonceResponse(context);\n\n         \n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         \n         error = ERROR_WRONG_STATE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeClientParseNewNonceResponse(AcmeClientContext *context)\n{\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   \n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL ACME_DNS_TRACE_LEVEL\n\n\n#include \"dns_api\/acme_dns_client.h\"\n#include \"dns_api\/acme_dns_client_misc.h\"\n#include \"jansson.h\"\n#include \"debug.h\"\n\n\n#if (ACME_DNS_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t acmeDnsClientFormatRegisterRequest(AcmeDnsClientContext *context)\n{\n   bool_t defaultPort;\n\n   \n   httpClientCreateRequest(&context->httpClientContext);\n   httpClientSetMethod(&context->httpClientContext, \"POST\");\n   httpClientSetUri(&context->httpClientContext, \"\/register\");\n\n#if (ACME_DNS_CLIENT_TLS_SUPPORT == ENABLED)\n   \n   if(context->tlsInitCallback != NULL)\n   {\n      \n      defaultPort = (context->serverPort == HTTPS_PORT) ? TRUE : FALSE;\n   }\n   else\n#endif\n   \n   {\n      \n      defaultPort = (context->serverPort == HTTP_PORT) ? TRUE : FALSE;\n   }\n\n   \n   \n   if(defaultPort)\n   {\n      \n      \n      httpClientAddHeaderField(&context->httpClientContext, \"Host\",\n         context->serverName);\n   }\n   else\n   {\n      \n      httpClientFormatHeaderField(&context->httpClientContext,\n         \"Host\", \"%s:%\" PRIu16, context->serverName, context->serverPort);\n   }\n\n   \n   httpClientAddHeaderField(&context->httpClientContext, \"User-Agent\",\n      \"Mozilla\/5.0\");\n\n   httpClientAddHeaderField(&context->httpClientContext, \"Content-Type\",\n      \"application\/json\");\n\n   \n   httpClientSetContentLength(&context->httpClientContext, 0);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t acmeDnsClientParseRegisterResponse(AcmeDnsClientContext *context)\n{\n   error_t error;\n   const char_t *username;\n   const char_t *password;\n   const char_t *subDomain;\n   const char_t *fullDomain;\n   json_t *rootObj;\n   json_t *usernameObj;\n   json_t *passwordObj;\n   json_t *subDomainObj;\n   json_t *fullDomainObj;\n\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   if(context->bufferLen >= ACME_DNS_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n\n   \n   error = ERROR_INVALID_RESPONSE;\n\n   \n   context->username[0] = '\\0';\n   context->password[0] = '\\0';\n   context->subDomain[0] = '\\0';\n   context->fullDomain[0] = '\\0';\n\n   \n   rootObj = json_loads(context->buffer, 0, NULL);\n\n   \n   if(json_is_object(rootObj))\n   {\n      \n      \n      usernameObj = json_object_get(rootObj, \"username\");\n      passwordObj = json_object_get(rootObj, \"password\");\n      subDomainObj = json_object_get(rootObj, \"subdomain\");\n      fullDomainObj = json_object_get(rootObj, \"fulldomain\");\n\n      \n      if(json_is_string(usernameObj) &&\n         json_is_string(passwordObj) &&\n         json_is_string(subDomainObj) &&\n         json_is_string(fullDomainObj))\n      {\n         \n         username = json_string_value(usernameObj);\n         password = json_string_value(passwordObj);\n         subDomain = json_string_value(subDomainObj);\n         fullDomain = json_string_value(fullDomainObj);\n\n         \n         if(osStrlen(username) <= ACME_DNS_CLIENT_MAX_USERNAME_LEN &&\n            osStrlen(password) <= ACME_DNS_CLIENT_MAX_PASSWORD_LEN &&\n            osStrlen(subDomain) <= ACME_DNS_CLIENT_MAX_SUB_DOMAIN_LEN &&\n            osStrlen(fullDomain) <= ACME_DNS_CLIENT_MAX_FULL_DOMAIN_LEN)\n         {\n            \n            osStrcpy(context->username, username);\n            osStrcpy(context->password, password);\n            osStrcpy(context->subDomain, subDomain);\n            osStrcpy(context->fullDomain, fullDomain);\n\n            \n            error = NO_ERROR;\n         }\n      }\n   }\n\n   \n   json_decref(rootObj);\n\n   \n   return error;\n}\n\n\n\n\nerror_t acmeDnsClientFormatUpdateRequest(AcmeDnsClientContext *context,\n   const char_t *txt)\n{\n   bool_t defaultPort;\n\n   \n   if(osStrlen(txt) != ACME_DNS_TXT_RECORD_LEN)\n      return ERROR_INVALID_LENGTH;\n\n   \n   httpClientCreateRequest(&context->httpClientContext);\n   httpClientSetMethod(&context->httpClientContext, \"POST\");\n   httpClientSetUri(&context->httpClientContext, \"\/update\");\n\n#if (ACME_DNS_CLIENT_TLS_SUPPORT == ENABLED)\n   \n   if(context->tlsInitCallback != NULL)\n   {\n      \n      defaultPort = (context->serverPort == HTTPS_PORT) ? TRUE : FALSE;\n   }\n   else\n#endif\n   \n   {\n      \n      defaultPort = (context->serverPort == HTTP_PORT) ? TRUE : FALSE;\n   }\n\n   \n   \n   if(defaultPort)\n   {\n      \n      \n      httpClientAddHeaderField(&context->httpClientContext, \"Host\",\n         context->serverName);\n   }\n   else\n   {\n      \n      httpClientFormatHeaderField(&context->httpClientContext,\n         \"Host\", \"%s:%\" PRIu16, context->serverName, context->serverPort);\n   }\n\n   \n   httpClientAddHeaderField(&context->httpClientContext, \"User-Agent\",\n      \"Mozilla\/5.0\");\n\n   httpClientAddHeaderField(&context->httpClientContext, \"X-Api-User\",\n      context->username);\n\n   httpClientAddHeaderField(&context->httpClientContext, \"X-Api-Key\",\n      context->password);\n\n   httpClientAddHeaderField(&context->httpClientContext, \"Content-Type\",\n      \"application\/json\");\n\n   \n   context->bufferLen = osSprintf(context->buffer,\n      \"{\\\"subdomain\\\":\\\"%s\\\",\\\"txt\\\":\\\"%s\\\"}\", context->subDomain, txt);\n\n   \n   httpClientSetContentLength(&context->httpClientContext, context->bufferLen);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t acmeDnsClientParseUpdateResponse(AcmeDnsClientContext *context)\n{\n   \n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n\n   \n   if(context->bufferLen >= ACME_DNS_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SCP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_connection.h\"\n#include \"ssh\/ssh_request.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"scp\/scp_client.h\"\n#include \"scp\/scp_client_misc.h\"\n#include \"debug.h\"\n\n\n#if (SCP_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nvoid scpClientChangeState(ScpClientContext *context,\n   ScpClientState newState)\n{\n   \n   context->state = newState;\n\n   \n   context->timestamp = osGetSystemTime();\n}\n\n\n\n\nerror_t scpClientOpenConnection(ScpClientContext *context)\n{\n   error_t error;\n   Socket *socket;\n   SshConnection *connection;\n\n   \n   error = sshInit(&context->sshContext, &context->sshConnection, 1,\n      &context->sshChannel, 1);\n   \n   if(error)\n      return error;\n\n   \n   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);\n   \n   if(error)\n      return error;\n\n   \n   if(context->sshInitCallback != NULL)\n   {\n      \n      error = context->sshInitCallback(context, &context->sshContext);\n      \n      if(error)\n         return error;\n   }\n\n   \n   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n\n   \n   if(socket != NULL)\n   {\n      \n      socketBindToInterface(socket, context->interface);\n      \n      socketSetTimeout(socket, context->timeout);\n\n      \n      connection = sshOpenConnection(&context->sshContext, socket);\n\n      \n      if(connection == NULL)\n      {\n         \n         socketClose(socket);\n         \n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_OPEN_FAILED;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpClientEstablishConnection(ScpClientContext *context)\n{\n   error_t error;\n\n   \n   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)\n   {\n      \n      error = scpClientProcessEvents(context);\n   }\n   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)\n   {\n      \n      scpClientChangeState(context, SCP_CLIENT_STATE_CONNECTED);\n      \n      error = NO_ERROR;\n   }\n   else\n   {\n      \n      error = ERROR_WRONG_STATE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nvoid scpClientCloseConnection(ScpClientContext *context)\n{\n   \n   if(context->sshConnection.state != SSH_CONN_STATE_CLOSED)\n   {\n      \n      sshCloseConnection(&context->sshConnection);\n   }\n\n   \n   sshDeinit(&context->sshContext);\n}\n\n\n\n\nerror_t scpClientSendDirective(ScpClientContext *context,\n   const ScpDirective *directive)\n{\n   error_t error;\n   size_t n;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->bufferLen == 0)\n      {\n         \n         n = scpFormatDirective(directive, context->buffer);\n\n         \n         context->bufferLen = n;\n         context->bufferPos = 0;\n      }\n      else if(context->bufferPos < context->bufferLen)\n      {\n         \n         error = sshWriteChannel(&context->sshChannel,\n            context->buffer + context->bufferPos,\n            context->bufferLen - context->bufferPos, &n, 0);\n\n         \n         if(error == NO_ERROR || error == ERROR_TIMEOUT)\n         {\n            \n            context->bufferPos += n;\n         }\n      }\n      else\n      {\n         \n         context->bufferLen = 0;\n         context->bufferPos = 0;\n\n         \n         break;\n      }\n\n      \n      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n      {\n         \n         error = scpClientProcessEvents(context);\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpClientReceiveDirective(ScpClientContext *context,\n   ScpDirective *directive)\n{\n   error_t error;\n   size_t n;\n   uint8_t opcode;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->bufferLen == 0)\n      {\n         \n         error = sshReadChannel(&context->sshChannel, context->buffer, 1,\n            &n, 0);\n\n         \n         if(!error)\n         {\n            \n            context->bufferLen += n;\n         }\n      }\n      else if(context->bufferLen < SCP_CLIENT_BUFFER_SIZE)\n      {\n         \n         opcode = context->buffer[0];\n\n         \n         if(opcode == SCP_OPCODE_OK ||\n            opcode == SCP_OPCODE_END)\n         {\n            \n            error = scpParseDirective(context->buffer, directive);\n\n            \n            context->bufferLen = 0;\n            context->bufferPos = 0;\n\n            \n            break;\n         }\n         else if(opcode == SCP_OPCODE_WARNING ||\n            opcode == SCP_OPCODE_ERROR ||\n            opcode == SCP_OPCODE_FILE ||\n            opcode == SCP_OPCODE_DIR ||\n            opcode == SCP_OPCODE_TIME)\n         {\n            \n            n = SCP_CLIENT_BUFFER_SIZE - context->bufferLen;\n\n            \n            error = sshReadChannel(&context->sshChannel, context->buffer +\n               context->bufferLen, n, &n, SSH_FLAG_BREAK_CRLF);\n\n            \n            if(!error)\n            {\n               \n               context->bufferLen += n;\n\n               \n               if(context->bufferLen > 0 &&\n                  context->buffer[context->bufferLen - 1] == '\\n')\n               {\n                  \n                  context->buffer[context->bufferLen - 1] = '\\0';\n\n                  \n                  error = scpParseDirective(context->buffer, directive);\n\n                  \n                  context->bufferLen = 0;\n                  context->bufferPos = 0;\n\n                  \n                  break;\n               }\n               else\n               {\n                  \n                  error = ERROR_WOULD_BLOCK;\n               }\n            }\n         }\n         else\n         {\n            \n            error = ERROR_INVALID_COMMAND;\n         }\n      }\n      else\n      {\n         \n         error = ERROR_BUFFER_OVERFLOW;\n      }\n\n      \n      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n      {\n         \n         error = scpClientProcessEvents(context);\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpClientProcessEvents(ScpClientContext *context)\n{\n   error_t error;\n   uint_t i;\n   SshContext *sshContext;\n   SshConnection *connection;\n\n   \n   sshContext = &context->sshContext;\n\n   \n   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));\n\n   \n   for(i = 0; i < sshContext->numConnections; i++)\n   {\n      \n      connection = &sshContext->connections[i];\n\n      \n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         \n         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);\n      }\n   }\n\n   \n   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,\n      &sshContext->event, context->timeout);\n\n   \n   if(!error)\n   {\n      \n      for(i = 0; i < sshContext->numConnections && !error; i++)\n      {\n         \n         connection = &sshContext->connections[i];\n\n         \n         if(connection->state != SSH_CONN_STATE_CLOSED)\n         {\n            \n            if(sshContext->eventDesc[i].eventFlags != 0)\n            {\n               \n               error = sshProcessConnectionEvents(sshContext, connection);\n            }\n         }\n      }\n   }\n\n   \n   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n   {\n      \n      error = scpClientCheckTimeout(context);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpClientCheckTimeout(ScpClientContext *context)\n{\n   error_t error;\n   systime_t time;\n\n   \n   time = osGetSystemTime();\n\n   \n   if(timeCompare(time, context->timestamp + context->timeout) >= 0)\n   {\n      \n      error = ERROR_TIMEOUT;\n   }\n   else\n   {\n#if (NET_RTOS_SUPPORT == ENABLED)\n      \n      error = NO_ERROR;\n#else\n      \n      error = ERROR_WOULD_BLOCK;\n#endif\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SCP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"scp\/scp_common.h\"\n#include \"debug.h\"\n\n\n\n\nsize_t scpFormatDirective(const ScpDirective *directive, char_t *buffer)\n{\n   size_t n;\n\n   \n   n = 0;\n\n   \n   buffer[n++] = directive->opcode;\n\n   \n   if(directive->opcode == SCP_OPCODE_OK)\n   {\n      \n      TRACE_DEBUG(\"Sending SCP success directive...\\r\\n\");\n   }\n   else if(directive->opcode == SCP_OPCODE_WARNING ||\n      directive->opcode == SCP_OPCODE_ERROR)\n   {\n      \n      n += osSprintf(buffer + n, \"%s\\n\", directive->message);\n\n      \n      TRACE_DEBUG(\"Sending SCP error directive...\\r\\n\");\n   }\n   else if(directive->opcode == SCP_OPCODE_FILE ||\n      directive->opcode == SCP_OPCODE_DIR)\n   {\n      \n      \n      n += osSprintf(buffer + n, \"%04\" PRIo32 \" %\" PRIu64 \" %s\\n\",\n         directive->mode, directive->size, directive->filename);\n\n      \n      TRACE_DEBUG(\"Sending SCP '%c' directive...\\r\\n\", directive->opcode);\n   }\n   else if(directive->opcode == SCP_OPCODE_END)\n   {\n      \n      buffer[n++] = '\\n';\n\n      \n      TRACE_DEBUG(\"Sending SCP '%c' directive...\\r\\n\", directive->opcode);\n   }\n   else if(directive->opcode == SCP_OPCODE_TIME)\n   {\n      \n      \n      n += osSprintf(buffer + n, \"%\" PRIu32 \" 0 %\" PRIu32 \" 0\\n\",\n         directive->mtime, directive->atime);\n\n      \n      TRACE_DEBUG(\"Sending SCP '%c' directive...\\r\\n\", directive->opcode);\n   }\n   else\n   {\n      \n   }\n\n   \n   return n;\n}\n\n\n\n\nerror_t scpParseDirective(const char_t *buffer, ScpDirective *directive)\n{\n   error_t error;\n   char_t *p;\n\n   \n   error = NO_ERROR;\n\n   \n   osMemset(directive, 0, sizeof(ScpDirective));\n\n   \n   directive->opcode = (ScpOpcode) buffer[0];\n\n   \n   if(directive->opcode == SCP_OPCODE_OK)\n   {\n      \n      TRACE_DEBUG(\"SCP success directive received...\\r\\n\");\n   }\n   else if(directive->opcode == SCP_OPCODE_WARNING ||\n      directive->opcode == SCP_OPCODE_ERROR)\n   {\n      \n      TRACE_DEBUG(\"SCP error directive received...\\r\\n\");\n\n      \n      directive->message = (char_t *) buffer + 1;\n   }\n   else if(directive->opcode == SCP_OPCODE_FILE ||\n      directive->opcode == SCP_OPCODE_DIR)\n   {\n      \n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n\n      \n      do\n      {\n         \n         directive->mode = osStrtoul(buffer + 1, &p, 8);\n\n         \n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n         while(osIsblank(*p))\n         {\n            p++;\n         }\n\n         \n         directive->size = osStrtoull(p, &p, 10);\n\n         \n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n         while(osIsblank(*p))\n         {\n            p++;\n         }\n\n         \n         directive->filename = p;\n\n         \n      } while(0);\n   }\n   else if(directive->opcode == SCP_OPCODE_END)\n   {\n      \n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n   }\n   else if(directive->opcode == SCP_OPCODE_TIME)\n   {\n      \n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n\n      \n      do\n      {\n         \n         directive->mtime = osStrtoul(buffer + 1, &p, 10);\n\n         \n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n         osStrtoul(p, &p, 10);\n\n         \n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n         directive->atime = osStrtoul(p, &p, 10);\n\n         \n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n         osStrtoul(p, &p, 10);\n\n         \n         if(*p != '\\0')\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n\n         \n      } while(0);\n   }\n   else\n   {\n      \n      TRACE_WARNING(\"SCP unknown directive received...\\r\\n\");\n\n      \n      error = ERROR_INVALID_COMMAND;\n   }\n\n   \n   return error;\n}\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SCP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"scp\/scp_server.h\"\n#include \"scp\/scp_server_misc.h\"\n#include \"path.h\"\n#include \"debug.h\"\n\n\n#if (SCP_SERVER_SUPPORT == ENABLED)\n\n\n\n\nvoid scpServerGetDefaultSettings(ScpServerSettings *settings)\n{\n   \n   settings->sshServerContext = NULL;\n\n   \n   settings->numSessions = 0;\n   settings->sessions = NULL;\n\n   \n   settings->rootDir = NULL;\n\n   \n   settings->checkUserCallback = NULL;\n   \n   settings->getFilePermCallback = NULL;\n}\n\n\n\n\nerror_t scpServerInit(ScpServerContext *context,\n   const ScpServerSettings *settings)\n{\n   uint_t i;\n\n   \n   TRACE_INFO(\"Initializing SCP server...\\r\\n\");\n\n   \n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SCP_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   if(settings->rootDir == NULL ||\n      osStrlen(settings->rootDir) > SCP_SERVER_MAX_ROOT_DIR_LEN)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   osMemset(context, 0, sizeof(ScpServerContext));\n\n   \n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->getFilePermCallback = settings->getFilePermCallback;\n\n   \n   osStrcpy(context->rootDir, settings->rootDir);\n\n   \n   pathCanonicalize(context->rootDir);\n   pathRemoveSlash(context->rootDir);\n\n   \n   for(i = 0; i < context->numSessions; i++)\n   {\n      \n      osMemset(&context->sessions[i], 0, sizeof(ScpServerSession));\n   }\n\n   \n   if(!osCreateEvent(&context->event))\n   {\n      \n      scpServerDeinit(context);\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t scpServerStart(ScpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Starting SCP server...\\r\\n\");\n\n   \n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n\n   \n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      scpServerChannelRequestCallback, context);\n\n   \n   if(!error)\n   {\n      \n      context->stop = FALSE;\n      context->running = TRUE;\n\n      \n      task = osCreateTask(\"SCP Server\", scpServerTask, context,\n         SCP_SERVER_STACK_SIZE, SCP_SERVER_PRIORITY);\n      \n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n\n   \n   if(error)\n   {\n      \n      context->running = FALSE;\n\n      \n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpServerStop(ScpServerContext *context)\n{\n   uint_t i;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Stopping SCP server...\\r\\n\");\n\n   \n   if(context->running)\n   {\n      \n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n\n      \n      context->stop = TRUE;\n      \n      osSetEvent(&context->event);\n\n      \n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n\n      \n      for(i = 0; i < context->numSessions; i++)\n      {\n         \n         if(context->sessions[i].state != SCP_SERVER_SESSION_STATE_CLOSED)\n         {\n            \n            scpServerCloseSession(&context->sessions[i]);\n         }\n      }\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t scpServerSetRootDir(ScpServerSession *session, const char_t *rootDir)\n{\n   ScpServerContext *context;\n\n   \n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   context = session->context;\n\n   \n   pathCopy(session->rootDir, context->rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);\n\n   \n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n\n   \n   pathCopy(session->homeDir, session->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t scpServerSetHomeDir(ScpServerSession *session, const char_t *homeDir)\n{\n   ScpServerContext *context;\n\n   \n   if(session == NULL || homeDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   context = session->context;\n\n   \n   pathCopy(session->homeDir, context->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n   pathCombine(session->homeDir, homeDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n\n   \n   pathCanonicalize(session->homeDir);\n   pathRemoveSlash(session->homeDir);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid scpServerTask(void *param)\n{\n   error_t error;\n   uint_t i;\n   systime_t timeout;\n   ScpServerContext *context;\n   ScpServerSession *session;\n\n   \n   context = (ScpServerContext *) param;\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   \n   osEnterTask();\n\n   \n   while(1)\n   {\n#endif\n      \n      timeout = SCP_SERVER_TICK_INTERVAL;\n\n      \n      osMemset(context->eventDesc, 0, sizeof(context->eventDesc));\n\n      \n      for(i = 0; i < context->numSessions; i++)\n      {\n         \n         session = &context->sessions[i];\n\n         \n         if(session->state != SCP_SERVER_SESSION_STATE_CLOSED)\n         {\n            \n            scpServerRegisterSessionEvents(session, &context->eventDesc[i]);\n\n            \n            if(context->eventDesc[i].eventFlags != 0)\n            {\n               \n               timeout = 0;\n            }\n         }\n      }\n\n      \n      error = sshPollChannels(context->eventDesc, context->numSessions,\n         &context->event, timeout);\n\n      \n      if(error == NO_ERROR || error == ERROR_TIMEOUT)\n      {\n         \n         if(context->stop)\n         {\n            \n            context->running = FALSE;\n            \n            osDeleteTask(NULL);\n         }\n\n         \n         for(i = 0; i < context->numSessions; i++)\n         {\n            \n            session = &context->sessions[i];\n\n            \n            if(session->state != SCP_SERVER_SESSION_STATE_CLOSED)\n            {\n               \n               if(context->eventDesc[i].eventFlags != 0)\n               {\n                  \n                  scpServerProcessSessionEvents(session);\n               }\n            }\n         }\n      }\n\n      \n      scpServerTick(context);\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   }\n#endif\n}\n\n\n\n\nvoid scpServerDeinit(ScpServerContext *context)\n{\n   \n   if(context != NULL)\n   {\n      \n      osDeleteEvent(&context->event);\n\n      \n      osMemset(context, 0, sizeof(ScpServerContext));\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SCP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"scp\/scp_server.h\"\n#include \"scp\/scp_server_file.h\"\n#include \"scp\/scp_server_directory.h\"\n#include \"scp\/scp_server_misc.h\"\n#include \"path.h\"\n#include \"debug.h\"\n\n\n#if (SCP_SERVER_SUPPORT == ENABLED)\n\n\n\n\nerror_t scpServerCreateDir(ScpServerSession *session, const char_t *name)\n{\n   error_t error;\n   uint_t perm;\n\n   \n   pathCombine(session->path, name, SCP_SERVER_MAX_PATH_LEN);\n   pathCanonicalize(session->path);\n   pathRemoveSlash(session->path);\n\n   \n   if(!fsDirExists(session->path))\n   {\n      \n      perm = scpServerGetFilePermissions(session, session->path);\n\n      \n      if((perm & SCP_FILE_PERM_WRITE) != 0)\n      {\n         \n         error = fsCreateDir(session->path);\n\n         \n         if(error)\n         {\n            \n            error = ERROR_DIRECTORY_NOT_FOUND;\n         }\n      }\n      else\n      {\n         \n         error = ERROR_ACCESS_DENIED;\n      }\n   }\n   else\n   {\n      \n      error = NO_ERROR;\n   }\n\n   \n   if(!error)\n   {\n      \n      session->dirLevel++;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpServerOpenDir(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n\n   \n   perm = scpServerGetFilePermissions(session, session->path);\n\n   \n   if((perm & SCP_FILE_PERM_READ) != 0)\n   {\n      \n      session->dir[session->dirLevel] = fsOpenDir(session->path);\n\n      \n      if(session->dir[session->dirLevel] != NULL)\n      {\n         \n         \n         session->fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO;\n\n         \n         error = NO_ERROR;\n      }\n      else\n      {\n         \n         error = ERROR_DIRECTORY_NOT_FOUND;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_ACCESS_DENIED;\n   }\n\n   \n   return error;\n}\n\n\n\n\nvoid scpServerGetNextDirEntry(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n\n   \n   while(1)\n   {\n      \n      error = fsReadDir(session->dir[session->dirLevel], &dirEntry);\n\n      \n      if(!error)\n      {\n         \n         if(!osStrcmp(dirEntry.name, \".\") || !osStrcmp(dirEntry.name, \"..\"))\n         {\n            \n         }\n         else\n         {\n            \n            pathCombine(session->path, dirEntry.name, SCP_SERVER_MAX_PATH_LEN);\n            pathCanonicalize(session->path);\n\n            \n            perm = scpServerGetFilePermissions(session, session->path);\n\n            \n            if((perm & SCP_FILE_PERM_LIST) != 0)\n            {\n               \n               if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n               {\n                  \n                  if((session->dirLevel + 1) < SCP_SERVER_MAX_RECURSION_LEVEL)\n                  {\n                     \n                     session->dirLevel++;\n\n                     \n                     error = scpServerOpenDir(session);\n\n                     \n                     if(error)\n                     {\n                        \n                        session->dirLevel--;\n                     }\n                  }\n                  else\n                  {\n                     \n                     error = ERROR_OPEN_FAILED;\n                  }\n               }\n               else\n               {\n                  \n                  error = scpServerOpenFileForReading(session);\n               }\n\n               \n               if(!error)\n               {\n                  break;\n               }\n            }\n\n            \n            pathRemoveFilename(session->path);\n            pathRemoveSlash(session->path);\n         }\n      }\n      else\n      {\n         \n         break;\n      }\n   }\n\n   \n   if(error)\n   {\n      \n      fsCloseDir(session->dir[session->dirLevel]);\n      session->dir[session->dirLevel] = NULL;\n\n      \n      if(session->dirLevel > 0)\n      {\n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n   }\n\n   \n   session->state = SCP_SERVER_SESSION_STATE_READ_COMMAND;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SCP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"scp\/scp_server.h\"\n#include \"scp\/scp_server_file.h\"\n#include \"scp\/scp_server_misc.h\"\n#include \"path.h\"\n#include \"debug.h\"\n\n\n#if (SCP_SERVER_SUPPORT == ENABLED)\n\n\n\n\nerror_t scpServerOpenFileForWriting(ScpServerSession *session,\n   const char_t *filename, uint32_t mode, uint64_t size)\n{\n   error_t error;\n   uint_t perm;\n   ScpServerContext *context;\n\n   \n   context = session->context;\n\n   \n   if(fsDirExists(session->path) || session->recursive)\n   {\n      \n      pathCopy(context->path, session->path, SCP_SERVER_MAX_PATH_LEN);\n      pathCombine(context->path, filename, SCP_SERVER_MAX_PATH_LEN);\n      pathCanonicalize(context->path);\n   }\n   else\n   {\n      \n      pathCopy(context->path, session->path, SCP_SERVER_MAX_PATH_LEN);\n   }\n\n   \n   perm = scpServerGetFilePermissions(session, context->path);\n\n   \n   if((perm & SCP_FILE_PERM_WRITE) != 0)\n   {\n      \n      session->file = fsOpenFile(context->path, FS_FILE_MODE_WRITE |\n         FS_FILE_MODE_CREATE | FS_FILE_MODE_TRUNC);\n\n      \n      if(session->file != NULL)\n      {\n         \n         session->fileSize = size;\n         session->fileOffset = 0;\n\n         \n         error = NO_ERROR;\n      }\n      else\n      {\n         \n         error = ERROR_FILE_NOT_FOUND;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_ACCESS_DENIED;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpServerOpenFileForReading(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsFileStat fileStat;\n\n   \n   error = fsGetFileStat(session->path, &fileStat);\n\n   \n   if(!error)\n   {\n      \n      if((fileStat.attributes & FS_FILE_ATTR_DIRECTORY) == 0)\n      {\n         \n         perm = scpServerGetFilePermissions(session, session->path);\n\n         \n         if((perm & SCP_FILE_PERM_READ) != 0)\n         {\n            \n            session->file = fsOpenFile(session->path, FS_FILE_MODE_READ);\n\n            \n            if(session->file != NULL)\n            {\n               \n               session->fileSize = fileStat.size;\n               session->fileOffset = 0;\n\n               \n               \n               if((fileStat.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n               {\n                  session->fileMode = SCP_MODE_IRUSR | SCP_MODE_IRGRP |\n                     SCP_MODE_IROTH;\n               }\n               else\n               {\n                  session->fileMode = SCP_MODE_IRUSR | SCP_MODE_IWUSR |\n                     SCP_MODE_IRGRP | SCP_MODE_IWGRP | SCP_MODE_IROTH |\n                     SCP_MODE_IWOTH;\n               }\n\n               \n               error = NO_ERROR;\n            }\n            else\n            {\n               \n               error = ERROR_FILE_NOT_FOUND;\n            }\n         }\n         else\n         {\n            \n            error = ERROR_ACCESS_DENIED;\n         }\n      }\n      else\n      {\n         \n         error = ERROR_FILE_NOT_FOUND;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_FILE_NOT_FOUND;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpServerWriteData(ScpServerSession *session)\n{\n   error_t error;\n   size_t n;\n\n   \n   error = NO_ERROR;\n\n   \n   if(session->bufferPos < session->bufferLen)\n   {\n      \n      error = sshReadChannel(session->channel,\n         session->buffer + session->bufferPos,\n         session->bufferLen - session->bufferPos, &n, 0);\n\n      \n      if(!error)\n      {\n         \n         session->bufferPos += n;\n      }\n   }\n   else if(session->fileOffset < session->fileSize)\n   {\n      \n      if(session->bufferLen > 0)\n      {\n         \n         if(session->statusCode == NO_ERROR)\n         {\n            \n            session->statusCode = fsWriteFile(session->file, session->buffer,\n               session->bufferLen);\n         }\n\n         \n         session->fileOffset += session->bufferLen;\n      }\n\n      \n      if((session->fileSize - session->fileOffset) < SCP_SERVER_BUFFER_SIZE)\n      {\n         n = (size_t) (session->fileSize - session->fileOffset);\n      }\n      else\n      {\n         n = SCP_SERVER_BUFFER_SIZE;\n      }\n\n      \n      session->bufferLen = n;\n      session->bufferPos = 0;\n   }\n   else\n   {\n      \n      fsCloseFile(session->file);\n      session->file = NULL;\n\n      \n      session->bufferLen = 0;\n      session->bufferPos = 0;\n\n      \n      if(session->statusCode == NO_ERROR)\n      {\n         session->state = SCP_SERVER_SESSION_STATE_WRITE_STATUS;\n      }\n      else\n      {\n         session->state = SCP_SERVER_SESSION_STATE_ERROR;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t scpServerReadData(ScpServerSession *session)\n{\n   error_t error;\n   size_t n;\n   size_t length;\n\n   \n   error = NO_ERROR;\n\n   \n   if(session->bufferPos < session->bufferLen)\n   {\n      \n      error = sshWriteChannel(session->channel,\n         session->buffer + session->bufferPos,\n         session->bufferLen - session->bufferPos, &n, 0);\n\n      \n      if(error == NO_ERROR || error == ERROR_TIMEOUT)\n      {\n         \n         session->bufferPos += n;\n      }\n   }\n   else if(session->fileOffset < session->fileSize)\n   {\n      \n      if((session->fileSize - session->fileOffset) < SCP_SERVER_BUFFER_SIZE)\n      {\n         length = (size_t) (session->fileSize - session->fileOffset);\n      }\n      else\n      {\n         length = SCP_SERVER_BUFFER_SIZE;\n      }\n\n      \n      error = fsReadFile(session->file, session->buffer, length, &n);\n\n      \n      if(!error)\n      {\n         \n         if(n == length)\n         {\n            \n            session->fileOffset += n;\n\n            \n            session->bufferLen = n;\n            session->bufferPos = 0;\n         }\n         else\n         {\n            \n            error = ERROR_READ_FAILED;\n         }\n      }\n   }\n   else\n   {\n      \n      fsCloseFile(session->file);\n      session->file = NULL;\n\n      \n      if(session->recursive)\n      {\n         \n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n\n      \n      session->bufferLen = 0;\n      session->bufferPos = 0;\n\n      \n      session->state = SCP_SERVER_SESSION_STATE_READ_STATUS;\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SFTP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"sftp\/sftp_server.h\"\n#include \"sftp\/sftp_server_misc.h\"\n#include \"path.h\"\n#include \"debug.h\"\n\n\n#if (SFTP_SERVER_SUPPORT == ENABLED)\n\n\n\n\nvoid sftpServerGetDefaultSettings(SftpServerSettings *settings)\n{\n   \n   settings->sshServerContext = NULL;\n\n   \n   settings->numSessions = 0;\n   settings->sessions = NULL;\n\n   \n   settings->numFileObjects = 0;\n   settings->fileObjects = NULL;\n\n   \n   settings->rootDir = NULL;\n\n   \n   settings->checkUserCallback = NULL;\n   \n   settings->getFilePermCallback = NULL;\n}\n\n\n\n\nerror_t sftpServerInit(SftpServerContext *context,\n   const SftpServerSettings *settings)\n{\n   uint_t i;\n\n   \n   TRACE_INFO(\"Initializing SFTP server...\\r\\n\");\n\n   \n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SFTP_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   if(settings->fileObjects == NULL || settings->numFileObjects < 1)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   if(settings->rootDir == NULL ||\n      osStrlen(settings->rootDir) > SFTP_SERVER_MAX_ROOT_DIR_LEN)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   osMemset(context, 0, sizeof(SftpServerContext));\n\n   \n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->numFileObjects = settings->numFileObjects;\n   context->fileObjects = settings->fileObjects;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->getFilePermCallback = settings->getFilePermCallback;\n\n   \n   osStrcpy(context->rootDir, settings->rootDir);\n\n   \n   pathCanonicalize(context->rootDir);\n   pathRemoveSlash(context->rootDir);\n\n   \n   for(i = 0; i < context->numSessions; i++)\n   {\n      \n      osMemset(&context->sessions[i], 0, sizeof(SftpServerSession));\n   }\n\n   \n   for(i = 0; i < context->numFileObjects; i++)\n   {\n      \n      osMemset(&context->fileObjects[i], 0, sizeof(SftpFileObject));\n   }\n\n   \n   if(!osCreateEvent(&context->event))\n   {\n      \n      sftpServerDeinit(context);\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t sftpServerStart(SftpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Starting SFTP server...\\r\\n\");\n\n   \n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n\n   \n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      sftpServerChannelRequestCallback, context);\n\n   \n   if(!error)\n   {\n      \n      context->stop = FALSE;\n      context->running = TRUE;\n\n      \n      task = osCreateTask(\"SFTP Server\", sftpServerTask, context,\n         SFTP_SERVER_STACK_SIZE, SFTP_SERVER_PRIORITY);\n      \n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n\n   \n   if(error)\n   {\n      \n      context->running = FALSE;\n\n      \n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         sftpServerChannelRequestCallback);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sftpServerStop(SftpServerContext *context)\n{\n   uint_t i;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Stopping SFTP server...\\r\\n\");\n\n   \n   if(context->running)\n   {\n      \n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         sftpServerChannelRequestCallback);\n\n      \n      context->stop = TRUE;\n      \n      osSetEvent(&context->event);\n\n      \n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n\n      \n      for(i = 0; i < context->numSessions; i++)\n      {\n         \n         if(context->sessions[i].state != SFTP_SERVER_SESSION_STATE_CLOSED)\n         {\n            \n            sftpServerCloseSession(&context->sessions[i]);\n         }\n      }\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t sftpServerSetRootDir(SftpServerSession *session, const char_t *rootDir)\n{\n   SftpServerContext *context;\n\n   \n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   context = session->context;\n\n   \n   pathCopy(session->rootDir, context->rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n\n   \n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n\n   \n   pathCopy(session->homeDir, session->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t sftpServerSetHomeDir(SftpServerSession *session, const char_t *homeDir)\n{\n   SftpServerContext *context;\n\n   \n   if(session == NULL || homeDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   context = session->context;\n\n   \n   pathCopy(session->homeDir, context->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   pathCombine(session->homeDir, homeDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n\n   \n   pathCanonicalize(session->homeDir);\n   pathRemoveSlash(session->homeDir);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid sftpServerTask(void *param)\n{\n   error_t error;\n   uint_t i;\n   systime_t timeout;\n   SftpServerContext *context;\n   SftpServerSession *session;\n\n   \n   context = (SftpServerContext *) param;\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   \n   osEnterTask();\n\n   \n   while(1)\n   {\n#endif\n      \n      timeout = SFTP_SERVER_TICK_INTERVAL;\n\n      \n      osMemset(context->eventDesc, 0, sizeof(context->eventDesc));\n\n      \n      for(i = 0; i < context->numSessions; i++)\n      {\n         \n         session = &context->sessions[i];\n\n         \n         if(session->state != SFTP_SERVER_SESSION_STATE_CLOSED)\n         {\n            \n            sftpServerRegisterSessionEvents(session, &context->eventDesc[i]);\n\n            \n            if(context->eventDesc[i].eventFlags != 0)\n            {\n               \n               timeout = 0;\n            }\n         }\n      }\n\n      \n      error = sshPollChannels(context->eventDesc, context->numSessions,\n         &context->event, timeout);\n\n      \n      if(error == NO_ERROR || error == ERROR_TIMEOUT)\n      {\n         \n         if(context->stop)\n         {\n            \n            context->running = FALSE;\n            \n            osDeleteTask(NULL);\n         }\n\n         \n         for(i = 0; i < context->numSessions; i++)\n         {\n            \n            session = &context->sessions[i];\n\n            \n            if(session->state != SFTP_SERVER_SESSION_STATE_CLOSED)\n            {\n               \n               if(context->eventDesc[i].eventFlags != 0)\n               {\n                  \n                  sftpServerProcessSessionEvents(session);\n               }\n            }\n         }\n      }\n\n      \n      sftpServerTick(context);\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   }\n#endif\n}\n\n\n\n\nvoid sftpServerDeinit(SftpServerContext *context)\n{\n   \n   if(context != NULL)\n   {\n      \n      osDeleteEvent(&context->event);\n\n      \n      osMemset(context, 0, sizeof(SftpServerContext));\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SFTP_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"sftp\/sftp_server.h\"\n#include \"sftp\/sftp_server_directory.h\"\n#include \"sftp\/sftp_server_misc.h\"\n#include \"path.h\"\n#include \"debug.h\"\n\n\n#if (SFTP_SERVER_SUPPORT == ENABLED)\n\n\n\n\nerror_t sftpServerCreateDir(SftpServerSession *session,\n   const SshString *path, const SftpFileAttrs *attributes)\n{\n   error_t error;\n   uint_t perm;\n   SftpServerContext *context;\n\n   \n   context = session->context;\n\n   \n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   \n   if(error)\n      return error;\n\n   \n   perm = sftpServerGetFilePermissions(session, context->path);\n   \n   if((perm & SFTP_FILE_PERM_WRITE) == 0)\n      return ERROR_ACCESS_DENIED;\n\n   \n   error = fsCreateDir(context->path);\n\n   \n   return error;\n}\n\n\n\n\nerror_t sftpServerRemoveDir(SftpServerSession *session,\n   const SshString *path)\n{\n   error_t error;\n   uint_t perm;\n   SftpServerContext *context;\n\n   \n   context = session->context;\n\n   \n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   \n   if(error)\n      return error;\n\n   \n   perm = sftpServerGetFilePermissions(session, context->path);\n   \n   if((perm & SFTP_FILE_PERM_WRITE) == 0)\n      return ERROR_ACCESS_DENIED;\n\n   \n   error = fsRemoveDir(context->path);\n\n   \n   return error;\n}\n\n\n\n\nerror_t sftpServerOpenDir(SftpServerSession *session,\n   const SshString *path, uint32_t *handle)\n{\n   error_t error;\n   uint_t i;\n   uint_t perm;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n\n   \n   context = session->context;\n\n   \n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   \n   if(error)\n      return error;\n\n   \n   perm = sftpServerGetFilePermissions(session, context->path);\n   \n   if((perm & SFTP_FILE_PERM_READ) == 0)\n      return ERROR_ACCESS_DENIED;\n\n   \n   for(i = 0; i < context->numFileObjects; i++)\n   {\n      \n      fileObject = &context->fileObjects[i];\n\n      \n      if(fileObject->type == SSH_FILEXFER_TYPE_INVALID)\n      {\n         break;\n      }\n   }\n\n   \n   if(i < context->numFileObjects)\n   {\n      \n      fileObject->dir = fsOpenDir(context->path);\n\n      \n      if(fileObject->dir != NULL)\n      {\n         \n         fileObject->type = SSH_FILEXFER_TYPE_DIRECTORY;\n         fileObject->session = session;\n         fileObject->size = 0;\n         fileObject->offset = 0;\n         fileObject->file = NULL;\n\n         \n         osStrcpy(fileObject->path, context->path);\n\n         \n         fileObject->handle = sftpServerGenerateHandle(session);\n\n         \n         \n         *handle = fileObject->handle;\n\n         \n         error = NO_ERROR;\n      }\n      else\n      {\n         \n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_OUT_OF_RESOURCES;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sftpServerReadDir(SftpServerSession *session,\n   const SshBinaryString *handle, SftpName *name)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n\n   \n   error = NO_ERROR;\n\n   \n   context = session->context;\n\n   \n   osMemset(name, 0, sizeof(SftpName));\n\n   \n   \n   fileObject = sftpServerFindDir(session, handle);\n   \n   if(fileObject == NULL)\n      return ERROR_INVALID_HANDLE;\n\n   \n   while(!error)\n   {\n      \n      error = fsReadDir(fileObject->dir, &dirEntry);\n\n      \n      if(!error)\n      {\n         \n         pathCopy(context->path, fileObject->path, SFTP_SERVER_MAX_PATH_LEN);\n         pathCombine(context->path, dirEntry.name, SFTP_SERVER_MAX_PATH_LEN);\n         pathCanonicalize(context->path);\n\n         \n         perm = sftpServerGetFilePermissions(session, context->path);\n\n         \n         if((perm & SFTP_FILE_PERM_READ) != 0)\n         {\n            \n            osStrcpy(context->path, dirEntry.name);\n\n            \n            name->filename.value = context->path;\n            name->filename.length = osStrlen(context->path);\n\n            \n            if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n            {\n               name->attributes.type = SSH_FILEXFER_TYPE_DIRECTORY;\n            }\n            else\n            {\n               name->attributes.type = SSH_FILEXFER_TYPE_REGULAR;\n            }\n\n            \n            name->attributes.size = dirEntry.size;\n\n            \n            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n            {\n               name->attributes.permissions = SFTP_MODE_IRUSR;\n            }\n            else\n            {\n               name->attributes.permissions = SFTP_MODE_IRUSR | SFTP_MODE_IWUSR;\n            }\n\n            \n            name->attributes.mtime = dirEntry.modified;\n            name->attributes.atime = dirEntry.modified;\n\n            \n            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_READONLY;\n            }\n\n            if((dirEntry.attributes & FS_FILE_ATTR_SYSTEM) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_SYSTEM;\n            }\n\n            if((dirEntry.attributes & FS_FILE_ATTR_HIDDEN) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_HIDDEN;\n            }\n\n            if((dirEntry.attributes & FS_FILE_ATTR_ARCHIVE) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_ARCHIVE;\n            }\n\n            \n            name->attributes.flags = SSH_FILEXFER_ATTR_SIZE |\n               SSH_FILEXFER_ATTR_PERMISSIONS | SSH_FILEXFER_ATTR_ACMODTIME;\n\n            \n            break;\n         }\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sftpServerCloseDir(SftpServerSession *session,\n   const SshBinaryString *handle)\n{\n   error_t error;\n   SftpFileObject *fileObject;\n\n   \n   \n   fileObject = sftpServerFindDir(session, handle);\n\n   \n   if(fileObject != NULL)\n   {\n      \n      fsCloseDir(fileObject->dir);\n      fileObject->dir = NULL;\n\n      \n      fileObject->type = SSH_FILEXFER_TYPE_INVALID;\n\n      \n      error = NO_ERROR;\n   }\n   else\n   {\n      \n      error = ERROR_INVALID_HANDLE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nSftpFileObject *sftpServerFindDir(SftpServerSession *session,\n   const SshBinaryString *handle)\n{\n   uint_t i;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n\n   \n   context = session->context;\n\n   \n   if(handle->length == sizeof(uint32_t))\n   {\n      \n      for(i = 0; i < context->numFileObjects; i++)\n      {\n         \n         fileObject = &context->fileObjects[i];\n\n         \n         if(fileObject->type == SSH_FILEXFER_TYPE_DIRECTORY &&\n            fileObject->session == session &&\n            fileObject->handle == LOAD32BE(handle->value))\n         {\n            \n            return fileObject;\n         }\n      }\n   }\n\n   \n   return NULL;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SHELL_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_connection.h\"\n#include \"ssh\/ssh_request.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"shell\/shell_client.h\"\n#include \"shell\/shell_client_misc.h\"\n#include \"debug.h\"\n\n\n#if (SHELL_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nvoid shellClientChangeState(ShellClientContext *context,\n   ShellClientState newState)\n{\n   \n   context->state = newState;\n\n   \n   context->timestamp = osGetSystemTime();\n}\n\n\n\n\nerror_t shellClientChannelRequestCallback(SshChannel *channel,\n   const SshString *type, const uint8_t *data, size_t length,\n   void *param)\n{\n   error_t error;\n   ShellClientContext *context;\n\n   \n   TRACE_INFO(\"Shell client: SSH channel request callback...\\r\\n\");\n\n   \n   context = (ShellClientContext *) param;\n\n   \n   if(sshCompareString(type, \"exit-status\"))\n   {\n      SshExitStatusReqParams requestParams;\n\n      \n      \n      \n      error = sshParseExitStatusReqParams(data, length, &requestParams);\n\n      \n      if(!error)\n      {\n         \n         if(channel == &context->sshChannel)\n         {\n            \n            context->exitStatus = requestParams.exitStatus;\n         }\n         else\n         {\n            \n            error = ERROR_UNKNOWN_REQUEST;\n         }\n      }\n   }\n   else\n   {\n      \n      error = ERROR_UNKNOWN_REQUEST;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t shellClientOpenConnection(ShellClientContext *context)\n{\n   error_t error;\n   Socket *socket;\n   SshConnection *connection;\n\n   \n   error = sshInit(&context->sshContext, &context->sshConnection, 1,\n      &context->sshChannel, 1);\n   \n   if(error)\n      return error;\n\n   \n   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);\n   \n   if(error)\n      return error;\n\n   \n   error = sshRegisterChannelRequestCallback(&context->sshContext,\n      shellClientChannelRequestCallback, context);\n   \n   if(error)\n      return error;\n\n   \n   if(context->sshInitCallback != NULL)\n   {\n      \n      error = context->sshInitCallback(context, &context->sshContext);\n      \n      if(error)\n         return error;\n   }\n\n   \n   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n\n   \n   if(socket != NULL)\n   {\n      \n      socketBindToInterface(socket, context->interface);\n      \n      socketSetTimeout(socket, context->timeout);\n\n      \n      connection = sshOpenConnection(&context->sshContext, socket);\n\n      \n      if(connection == NULL)\n      {\n         \n         socketClose(socket);\n         \n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_OPEN_FAILED;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t shellClientEstablishConnection(ShellClientContext *context)\n{\n   error_t error;\n\n   \n   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)\n   {\n      \n      error = shellClientProcessEvents(context);\n   }\n   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)\n   {\n      \n      shellClientChangeState(context, SHELL_CLIENT_STATE_CONNECTED);\n      \n      error = NO_ERROR;\n   }\n   else\n   {\n      \n      error = ERROR_WRONG_STATE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nvoid shellClientCloseConnection(ShellClientContext *context)\n{\n   \n   if(context->sshConnection.state != SSH_CONN_STATE_CLOSED)\n   {\n      \n      sshCloseConnection(&context->sshConnection);\n   }\n\n   \n   sshDeinit(&context->sshContext);\n}\n\n\n\n\nerror_t shellClientProcessEvents(ShellClientContext *context)\n{\n   error_t error;\n   uint_t i;\n   SshContext *sshContext;\n   SshConnection *connection;\n\n   \n   sshContext = &context->sshContext;\n\n   \n   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));\n\n   \n   for(i = 0; i < sshContext->numConnections; i++)\n   {\n      \n      connection = &sshContext->connections[i];\n\n      \n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         \n         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);\n      }\n   }\n\n   \n   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,\n      &sshContext->event, context->timeout);\n\n   \n   if(!error)\n   {\n      \n      for(i = 0; i < sshContext->numConnections && !error; i++)\n      {\n         \n         connection = &sshContext->connections[i];\n\n         \n         if(connection->state != SSH_CONN_STATE_CLOSED)\n         {\n            \n            if(sshContext->eventDesc[i].eventFlags != 0)\n            {\n               \n               error = sshProcessConnectionEvents(sshContext, connection);\n            }\n         }\n      }\n   }\n\n   \n   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n   {\n      \n      error = shellClientCheckTimeout(context);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t shellClientCheckTimeout(ShellClientContext *context)\n{\n   error_t error;\n   systime_t time;\n\n   \n   time = osGetSystemTime();\n\n   \n   if(timeCompare(time, context->timestamp + context->timeout) >= 0)\n   {\n      \n      error = ERROR_TIMEOUT;\n   }\n   else\n   {\n#if (NET_RTOS_SUPPORT == ENABLED)\n      \n      error = NO_ERROR;\n#else\n      \n      error = ERROR_WOULD_BLOCK;\n#endif\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SHELL_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"shell\/shell_server.h\"\n#include \"shell\/shell_server_pty.h\"\n#include \"shell\/shell_server_misc.h\"\n#include \"debug.h\"\n\n\n#if (SHELL_SERVER_SUPPORT == ENABLED)\n\n\n\n\nvoid shellServerGetDefaultSettings(ShellServerSettings *settings)\n{\n   \n   settings->sshServerContext = NULL;\n\n   \n   settings->numSessions = 0;\n   settings->sessions = NULL;\n\n   \n   settings->checkUserCallback = NULL;\n   \n   settings->commandLineCallback = NULL;\n}\n\n\n\n\nerror_t shellServerInit(ShellServerContext *context,\n   const ShellServerSettings *settings)\n{\n   uint_t i;\n\n   \n   TRACE_INFO(\"Initializing shell server...\\r\\n\");\n\n   \n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SHELL_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   osMemset(context, 0, sizeof(ShellServerContext));\n\n   \n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->commandLineCallback = settings->commandLineCallback;\n\n   \n   for(i = 0; i < context->numSessions; i++)\n   {\n      \n      osMemset(&context->sessions[i], 0, sizeof(ShellServerSession));\n\n      \n      if(!osCreateEvent(&context->sessions[i].startEvent))\n         return ERROR_OUT_OF_RESOURCES;\n\n      \n      if(!osCreateEvent(&context->sessions[i].event))\n         return ERROR_OUT_OF_RESOURCES;\n   }\n\n   \n   if(!osCreateEvent(&context->event))\n      return ERROR_OUT_OF_RESOURCES;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t shellServerStart(ShellServerContext *context)\n{\n   error_t error;\n   uint_t i;\n   OsTask *task;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Starting shell server...\\r\\n\");\n\n   \n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n\n   \n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      shellServerChannelRequestCallback, context);\n   \n   if(error)\n      return error;\n\n   \n   for(i = 0; i < context->numSessions; i++)\n   {\n      \n      task = osCreateTask(\"Shell Session\", shellServerTask,\n         &context->sessions[i], SHELL_SERVER_STACK_SIZE,\n         SHELL_SERVER_PRIORITY);\n\n      \n      if(task == NULL)\n         return ERROR_OUT_OF_RESOURCES;\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t shellServerSetBanner(ShellServerSession *session,\n   const char_t *banner)\n{\n   size_t n;\n\n   \n   if(session == NULL || banner == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   n = osStrlen(banner);\n\n   \n   if(n > SHELL_SERVER_BUFFER_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   osStrncpy(session->buffer, banner, n);\n\n   \n   session->bufferLen = n;\n   session->bufferPos = 0;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t shellServerSetPrompt(ShellServerSession *session,\n   const char_t *prompt)\n{\n   \n   if(session == NULL || prompt == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(osStrlen(prompt) > SHELL_SERVER_MAX_PROMPT_LEN)\n      return ERROR_INVALID_LENGTH;\n\n   \n   osStrcpy(session->prompt, prompt);\n   \n   session->promptLen = osStrlen(prompt);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t shellServerSetTimeout(ShellServerSession *session, systime_t timeout)\n{\n   error_t error;\n\n   \n   if(session != NULL)\n   {\n      \n      error = sshSetChannelTimeout(session->channel, timeout);\n   }\n   else\n   {\n      \n      error = ERROR_INVALID_PARAMETER;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t shellServerWriteStream(ShellServerSession *session, const void *data,\n   size_t length, size_t *written, uint_t flags)\n{\n   error_t error;\n\n   \n   if(session != NULL)\n   {\n      \n      error = sshWriteChannel(session->channel, data, length, written, flags);\n   }\n   else\n   {\n      \n      error = ERROR_INVALID_PARAMETER;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t shellServerReadStream(ShellServerSession *session, void *data,\n   size_t size, size_t *received, uint_t flags)\n{\n   error_t error;\n\n   \n   if(session != NULL)\n   {\n      \n      error = sshReadChannel(session->channel, data, size, received, flags);\n   }\n   else\n   {\n      \n      error = ERROR_INVALID_PARAMETER;\n   }\n\n   \n   return error;\n}\n\n\n\n\nvoid shellServerTask(void *param)\n{\n   error_t error;\n   SshChannel *channel;\n   ShellServerSession *session;\n\n   \n   session = (ShellServerSession *) param;\n\n   \n   TRACE_INFO(\"Starting shell task...\\r\\n\");\n\n   \n   error = NO_ERROR;\n\n   \n   while(1)\n   {\n      \n      osWaitForEvent(&session->startEvent, INFINITE_DELAY);\n\n      \n      TRACE_INFO(\"Starting shell session...\\r\\n\");\n\n      \n      channel = session->channel;\n\n      \n      if(session->state == SHELL_SERVER_SESSION_STATE_OPEN)\n      {\n         \n         sshSetChannelTimeout(channel, INFINITE_DELAY);\n\n         \n         if(session->bufferLen > 0)\n         {\n            \n            error = sshWriteChannel(channel, session->buffer,\n               session->bufferLen, NULL, 0);\n         }\n\n         \n         if(!error)\n         {\n            \n            error = sshWriteChannel(channel, session->prompt,\n               osStrlen(session->prompt), NULL, 0);\n         }\n\n         \n         session->bufferLen = 0;\n         session->bufferPos = 0;\n         session->escSeqLen = 0;\n\n         \n         while(!error)\n         {\n            SshChannelEventDesc eventDesc[1];\n\n            \n            eventDesc[0].channel = channel;\n            eventDesc[0].eventMask = SSH_CHANNEL_EVENT_RX_READY;\n            eventDesc[0].eventFlags = 0;\n\n            \n            error = sshPollChannels(eventDesc, 1, &session->event,\n               SHELL_SERVER_TICK_INTERVAL);\n\n            \n            if(error == NO_ERROR || error == ERROR_TIMEOUT)\n            {\n               \n               if(session->windowResize)\n               {\n                  \n                  error = shellServerProcessWindowResize(session);\n               }\n\n               \n               if(eventDesc[0].eventFlags != 0)\n               {\n                  \n                  error = shellServerProcessChar(session);\n               }\n               else\n               {\n                  \n                  error = NO_ERROR;\n               }\n            }\n            else\n            {\n               \n               break;\n            }\n         }\n      }\n      else if(session->state == SHELL_SERVER_SESSION_STATE_EXEC)\n      {\n         \n         session->buffer[session->bufferLen] = '\\0';\n         \n         error = shellServerProcessCommandLine(session, session->buffer);\n      }\n      else\n      {\n         \n      }\n\n      \n      sshCloseChannel(channel);\n\n      \n      session->state = SHELL_SERVER_SESSION_STATE_CLOSED;\n\n      \n      TRACE_INFO(\"Shell session terminated...\\r\\n\");\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_transport.h\"\n#include \"ssh\/ssh_auth.h\"\n#include \"ssh\/ssh_auth_password.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED && SSH_PASSWORD_AUTH_SUPPORT == ENABLED)\n\n\n\n\nerror_t sshFormatPasswordAuthParams(SshConnection *connection, uint8_t *p,\n   size_t *written)\n{\n#if (SSH_CLIENT_SUPPORT == ENABLED)\n   error_t error;\n   size_t n;\n\n   \n   *written = 0;\n\n   \n   error = sshFormatString(\"password\", p, &n);\n   \n   if(error)\n      return error;\n\n   \n   p += n;\n   *written += n;\n\n   \n   p[0] = FALSE;\n\n   \n   p += sizeof(uint8_t);\n   *written += sizeof(uint8_t);\n\n   \n   error = sshFormatString(connection->context->password, p, &n);\n   \n   if(error)\n      return error;\n\n   \n   *written += n;\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshParsePasswordAuthParams(SshConnection *connection,\n   const SshString *userName, const uint8_t *p, size_t length)\n{\n#if (SSH_SERVER_SUPPORT == ENABLED)\n   error_t error;\n   SshBoolean flag;\n   SshString oldPassword;\n   SshString newPassword;\n   SshAccessStatus status;\n   SshContext *context;\n\n   \n   context = connection->context;\n\n   \n   if(length < sizeof(uint8_t))\n      return ERROR_INVALID_MESSAGE;\n\n   \n   flag = p[0];\n\n   \n   p += sizeof(uint8_t);\n   length -= sizeof(uint8_t);\n\n   \n   error = sshParseString(p, length, &oldPassword);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + oldPassword.length;\n   length -= sizeof(uint32_t) + oldPassword.length;\n\n   \n   if(flag)\n   {\n      \n      error = sshParseString(p, length, &newPassword);\n      \n      if(error)\n         return error;\n\n      \n      p += sizeof(uint32_t) + newPassword.length;\n      length -= sizeof(uint32_t) + newPassword.length;\n   }\n   else\n   {\n      \n      newPassword.value = NULL;\n      newPassword.length = 0;\n   }\n\n   \n   if(length != 0)\n      return ERROR_INVALID_MESSAGE;\n\n   \n   if(userName->length <= SSH_MAX_USERNAME_LEN)\n   {\n      \n      osMemcpy(connection->user, userName->value, userName->length);\n      \n      connection->user[userName->length] = '\\0';\n\n      \n      if(context->passwordAuthCallback != NULL)\n      {\n         \n         status = context->passwordAuthCallback(connection, connection->user,\n            oldPassword.value, oldPassword.length);\n      }\n      else\n      {\n         \n         status = SSH_ACCESS_DENIED;\n      }\n   }\n   else\n   {\n      \n      status = SSH_ACCESS_DENIED;\n   }\n\n   \n   if(status == SSH_ACCESS_ALLOWED)\n   {\n      \n      \n      error = sshSendUserAuthSuccess(connection);\n   }\n   else\n   {\n      \n      \n      error = sshRejectAuthRequest(connection);\n   }\n\n   \n   return error;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshParseUserAuthPasswdChangeReq(SshConnection *connection,\n   const uint8_t *message, size_t length)\n{\n#if (SSH_CLIENT_SUPPORT == ENABLED)\n   error_t error;\n   const uint8_t *p;\n   SshString prompt;\n   SshString languageTag;\n\n   \n   TRACE_INFO(\"SSH_USERAUTH_PASSWD_CHANGEREQ message received (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n   TRACE_VERBOSE_ARRAY(\"  \", message, length);\n\n   \n   if(connection->context->mode != SSH_OPERATION_MODE_CLIENT)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(connection->state != SSH_CONN_STATE_USER_AUTH_REPLY)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(length < sizeof(uint8_t))\n      return ERROR_INVALID_MESSAGE;\n\n   \n   p = message + sizeof(uint8_t);\n   \n   length -= sizeof(uint8_t);\n\n   \n   error = sshParseString(p, length, &prompt);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + prompt.length;\n   length -= sizeof(uint32_t) + prompt.length;\n\n   \n   error = sshParseString(p, length, &languageTag);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + languageTag.length;\n   length -= sizeof(uint32_t) + languageTag.length;\n\n   \n   if(length != 0)\n      return ERROR_INVALID_MESSAGE;\n\n   \n   \n   return ERROR_AUTHENTICATION_FAILED;\n#else\n   \n   return ERROR_UNEXPECTED_MESSAGE;\n#endif\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_algorithms.h\"\n#include \"ssh\/ssh_transport.h\"\n#include \"ssh\/ssh_auth.h\"\n#include \"ssh\/ssh_auth_public_key.h\"\n#include \"ssh\/ssh_packet.h\"\n#include \"ssh\/ssh_signature.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED && SSH_PUBLIC_KEY_AUTH_SUPPORT == ENABLED)\n\n\n\n\nerror_t sshSendUserAuthPkOk(SshConnection *connection,\n   const SshString *publicKeyAlgo, const SshBinaryString *publicKey)\n{\n#if (SSH_SERVER_SUPPORT == ENABLED)\n   error_t error;\n   size_t length;\n   uint8_t *message;\n\n   \n   message = connection->buffer + SSH_PACKET_HEADER_SIZE;\n\n   \n   error = sshFormatUserAuthPkOk(connection, publicKeyAlgo, publicKey, message,\n      &length);\n\n   \n   if(!error)\n   {\n      \n      TRACE_INFO(\"Sending SSH_MSG_USERAUTH_PK_OK message (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n      TRACE_VERBOSE_ARRAY(\"  \", message, length);\n\n      \n      error = sshSendPacket(connection, message, length);\n   }\n\n   \n   return error;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshFormatPublicKeyAuthParams(SshConnection *connection,\n   const uint8_t *message, size_t messageLen, uint8_t *p, size_t *written)\n{\n#if (SSH_CLIENT_SUPPORT == ENABLED)\n   error_t error;\n   size_t n;\n   SshHostKey *hostKey;\n   const char_t *publicKeyAlgo;\n\n   \n   *written = 0;\n\n   \n   error = sshFormatString(\"publickey\", p, &n);\n   \n   if(error)\n      return error;\n\n   \n   p += n;\n   *written += n;\n\n   \n   p[0] = connection->publicKeyOk ? TRUE : FALSE;\n\n   \n   p += sizeof(uint8_t);\n   *written += sizeof(uint8_t);\n\n   \n   hostKey = sshGetHostKey(connection);\n   \n   if(hostKey == NULL)\n      return ERROR_INVALID_KEY;\n\n   \n   publicKeyAlgo = sshSelectPublicKeyAlgo(hostKey->keyFormatId);\n   \n   if(publicKeyAlgo == NULL)\n      return ERROR_INVALID_KEY;\n\n   \n   error = sshFormatString(publicKeyAlgo, p, &n);\n   \n   if(error)\n      return error;\n\n   \n   p += n;\n   *written += n;\n\n   \n   error = sshFormatHostKey(connection, p + sizeof(uint32_t), &n);\n   \n   if(error)\n      return error;\n\n   \n   STORE32BE(n, p);\n\n   \n   p += sizeof(uint32_t) + n;\n   *written += sizeof(uint32_t) + n;\n\n   \n   \n   if(connection->publicKeyOk)\n   {\n      \n      messageLen += *written;\n\n      \n      error = sshGenerateSignature(connection, publicKeyAlgo, hostKey,\n         message, messageLen, p + sizeof(uint32_t), &n);\n      \n      if(error)\n         return error;\n\n      \n      STORE32BE(n, p);\n\n      \n      *written += sizeof(uint32_t) + n;\n   }\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshFormatUserAuthPkOk(SshConnection *connection,\n   const SshString *publicKeyAlgo, const SshBinaryString *publicKey,\n   uint8_t *p, size_t *length)\n{\n#if (SSH_SERVER_SUPPORT == ENABLED)\n   error_t error;\n   size_t n;\n\n   \n   *length = 0;\n\n   \n   p[0] = SSH_MSG_USERAUTH_PK_OK;\n\n   \n   p += sizeof(uint8_t);\n   *length += sizeof(uint8_t);\n\n   \n   error = sshFormatBinaryString(publicKeyAlgo->value, publicKeyAlgo->length,\n      p, &n);\n   \n   if(error)\n      return error;\n\n   \n   p += n;\n   *length += n;\n\n   \n   error = sshFormatBinaryString(publicKey->value, publicKey->length, p, &n);\n   \n   if(error)\n      return error;\n\n   \n   *length += n;\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshParsePublicKeyAuthParams(SshConnection *connection,\n   const SshString *userName, const uint8_t *message, const uint8_t *p,\n   size_t length)\n{\n#if (SSH_SERVER_SUPPORT == ENABLED)\n   error_t error;\n   size_t messageLen;\n   SshBoolean flag;\n   SshString publicKeyAlgo;\n   SshBinaryString publicKey;\n   SshBinaryString signature;\n   SshContext *context;\n\n   \n   context = connection->context;\n\n   \n   if(length < sizeof(uint8_t))\n      return ERROR_INVALID_MESSAGE;\n\n   \n   flag = p[0];\n\n   \n   p += sizeof(uint8_t);\n   length -= sizeof(uint8_t);\n\n   \n   error = sshParseString(p, length, &publicKeyAlgo);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + publicKeyAlgo.length;\n   length -= sizeof(uint32_t) + publicKeyAlgo.length;\n\n   \n   error = sshParseBinaryString(p, length, &publicKey);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + publicKey.length;\n   length -= sizeof(uint32_t) + publicKey.length;\n\n   \n   messageLen = p - message;\n\n   \n   if(flag)\n   {\n      \n      error = sshParseBinaryString(p, length, &signature);\n      \n      if(error)\n         return error;\n\n      \n      p += sizeof(uint32_t) + signature.length;\n      length -= sizeof(uint32_t) + signature.length;\n   }\n   else\n   {\n      \n      signature.value = NULL;\n      signature.length = 0;\n   }\n\n   \n   if(length != 0)\n      return ERROR_INVALID_MESSAGE;\n\n   \n   \n   error = sshCheckHostKey(&publicKeyAlgo, &publicKey);\n\n   \n   if(!error)\n   {\n      \n      if(userName->length <= SSH_MAX_USERNAME_LEN &&\n         context->publicKeyAuthCallback != NULL)\n      {\n         \n         osMemcpy(connection->user, userName->value, userName->length);\n         \n         connection->user[userName->length] = '\\0';\n\n         \n         error = context->publicKeyAuthCallback(connection, connection->user,\n            publicKey.value, publicKey.length);\n      }\n      else\n      {\n         \n         error = ERROR_INVALID_KEY;\n      }\n   }\n\n   \n   if(!error)\n   {\n      \n      if(flag)\n      {\n         \n         \n         error = sshVerifySignature(connection, &publicKeyAlgo, &publicKey,\n            message, messageLen, &signature);\n      }\n   }\n\n   \n   if(!error)\n   {\n      \n      if(flag)\n      {\n         \n         \n         error = sshSendUserAuthSuccess(connection);\n      }\n      else\n      {\n         \n         if(connection->authAttempts <= SSH_MAX_AUTH_ATTEMPTS)\n         {\n            \n            error = sshSendUserAuthPkOk(connection, &publicKeyAlgo, &publicKey);\n         }\n         else\n         {\n            \n            \n            error = sshSendDisconnect(connection, SSH_DISCONNECT_BY_APPLICATION,\n               \"Too many authentication attempts\");\n         }\n      }\n   }\n   else\n   {\n      \n      \n      error = sshRejectAuthRequest(connection);\n   }\n\n   \n   return error;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t sshParseUserAuthPkOk(SshConnection *connection,\n   const uint8_t *message, size_t length)\n{\n#if (SSH_CLIENT_SUPPORT == ENABLED)\n   error_t error;\n   const uint8_t *p;\n   SshString publicKeyAlgo;\n   SshBinaryString publicKey;\n\n   \n   TRACE_INFO(\"SSH_MSG_USERAUTH_PK_OK message received (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n   TRACE_VERBOSE_ARRAY(\"  \", message, length);\n\n   \n   if(connection->context->mode != SSH_OPERATION_MODE_CLIENT)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(connection->state != SSH_CONN_STATE_USER_AUTH_REPLY)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(length < sizeof(uint8_t))\n      return ERROR_INVALID_MESSAGE;\n\n   \n   p = message + sizeof(uint8_t);\n   \n   length -= sizeof(uint8_t);\n\n   \n   error = sshParseString(p, length, &publicKeyAlgo);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + publicKeyAlgo.length;\n   length -= sizeof(uint32_t) + publicKeyAlgo.length;\n\n   \n   error = sshParseBinaryString(p, length, &publicKey);\n   \n   if(error)\n      return error;\n\n   \n   p += sizeof(uint32_t) + publicKey.length;\n   length -= sizeof(uint32_t) + publicKey.length;\n\n   \n   if(length != 0)\n      return ERROR_INVALID_MESSAGE;\n\n   \n   if(connection->publicKeyOk)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   error = sshCheckHostKey(&publicKeyAlgo, &publicKey);\n   \n   if(error)\n      return error;\n\n   \n   connection->publicKeyOk = TRUE;\n\n   \n   \n   connection->state = SSH_CONN_STATE_USER_AUTH_REQUEST;\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_UNEXPECTED_MESSAGE;\n#endif\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_signature.h\"\n#include \"ssh\/ssh_exchange_hash.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED)\n\n\n\n\nerror_t sshInitExchangeHash(SshConnection *connection)\n{\n   error_t error;\n   const HashAlgo *hashAlgo;\n\n   \n   error = NO_ERROR;\n\n#if (SSH_SHA1_SUPPORT == ENABLED)\n   \n   if(sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group1-sha1\") ||\n      sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group14-sha1\") ||\n      sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group-exchange-sha1\"))\n   {\n      \n      hashAlgo = SHA1_HASH_ALGO;\n   }\n   else\n#endif\n#if (SSH_SHA256_SUPPORT == ENABLED)\n   \n   if(sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group14-sha256\") ||\n      sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group-exchange-sha256\") ||\n      sshCompareAlgo(connection->kexAlgo, \"ecdh-sha2-nistp256\") ||\n      sshCompareAlgo(connection->kexAlgo, \"curve25519-sha256\") ||\n      sshCompareAlgo(connection->kexAlgo, \"curve25519-sha256@libssh.org\"))\n   {\n      \n      hashAlgo = SHA256_HASH_ALGO;\n   }\n   else\n#endif\n#if (SSH_SHA384_SUPPORT == ENABLED)\n   \n   if(sshCompareAlgo(connection->kexAlgo, \"ecdh-sha2-nistp384\"))\n   {\n      \n      hashAlgo = SHA384_HASH_ALGO;\n   }\n   else\n#endif\n#if (SSH_SHA512_SUPPORT == ENABLED)\n   \n   if(sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group15-sha512\") ||\n      sshCompareAlgo(connection->kexAlgo, \"diffie-hellman-group16-sha512\") ||\n      sshCompareAlgo(connection->kexAlgo, \"ecdh-sha2-nistp521\") ||\n      sshCompareAlgo(connection->kexAlgo, \"curve448-sha512\"))\n   {\n      \n      hashAlgo = SHA512_HASH_ALGO;\n   }\n   else\n#endif\n   \n   {\n      \n      hashAlgo = NULL;\n   }\n\n   \n   if(hashAlgo != NULL)\n   {\n      \n      \n      connection->hashAlgo = hashAlgo;\n\n      \n      hashAlgo->init(connection->hashContext);\n   }\n   else\n   {\n      \n      error = ERROR_UNSUPPORTED_KEY_EXCH_METHOD;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshUpdateExchangeHash(SshConnection *connection, const void *data,\n   size_t length)\n{\n   error_t error;\n   uint8_t temp[4];\n\n   \n   error = NO_ERROR;\n\n   \n   if(connection->hashAlgo != NULL)\n   {\n      \n      STORE32BE(length, temp);\n\n      \n      connection->hashAlgo->update(connection->hashContext, temp, sizeof(temp));\n      \n      connection->hashAlgo->update(connection->hashContext, data, length);\n   }\n   else\n   {\n      \n      error = ERROR_FAILURE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshFinalizeExchangeHash(SshConnection *connection, uint8_t *digest,\n   size_t *digestLen)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   if(connection->hashAlgo != NULL)\n   {\n      \n      connection->hashAlgo->final(connection->hashContext, digest);\n      \n      *digestLen = connection->hashAlgo->digestSize;\n   }\n   else\n   {\n      \n      error = ERROR_FAILURE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshGenerateExchangeHashSignature(SshConnection *connection, uint8_t *p,\n   size_t *written)\n{\n   error_t error;\n   SshHostKey *hostKey;\n\n   \n   error = sshFinalizeExchangeHash(connection, connection->h,\n      &connection->hLen);\n\n   \n   if(!error)\n   {\n      \n      if(!connection->newKeysSent)\n      {\n         \n         \n         \n         \n         osMemcpy(connection->sessionId, connection->h, connection->hLen);\n         connection->sessionIdLen = connection->hLen;\n      }\n\n      \n      hostKey = sshGetHostKey(connection);\n\n      \n      if(hostKey != NULL)\n      {\n         \n         error = sshGenerateSignature(connection, connection->serverHostKeyAlgo,\n            hostKey, connection->h, connection->hLen, p, written);\n      }\n      else\n      {\n         \n         error = ERROR_INVALID_KEY;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshVerifyExchangeHashSignature(SshConnection *connection,\n   const SshBinaryString *serverHostKey, const SshBinaryString *signature)\n{\n   error_t error;\n   SshString serverHostKeyAlgo;\n\n   \n   error = sshFinalizeExchangeHash(connection, connection->h,\n      &connection->hLen);\n\n   \n   if(!error)\n   {\n      \n      if(!connection->newKeysSent)\n      {\n         \n         \n         \n         \n         osMemcpy(connection->sessionId, connection->h, connection->hLen);\n         connection->sessionIdLen = connection->hLen;\n      }\n\n      \n      serverHostKeyAlgo.value = connection->serverHostKeyAlgo;\n      serverHostKeyAlgo.length = osStrlen(connection->serverHostKeyAlgo);\n\n      \n      error = sshVerifySignature(connection, &serverHostKeyAlgo, serverHostKey,\n         connection->h, connection->hLen, signature);\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_key_import.h\"\n#include \"ssh\/ssh_key_verify.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED)\n\n\n\n\nerror_t sshVerifyHostKey(const uint8_t *hostKey, size_t hostKeyLen,\n   const char_t *trustedKey, size_t trustedKeyLen)\n{\n   error_t error;\n   size_t n;\n   uint8_t *buffer;\n\n   \n   error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, NULL, &n);\n\n   \n   if(!error)\n   {\n      \n      buffer = sshAllocMem(n);\n\n      \n      if(buffer != NULL)\n      {\n         \n         error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, buffer, &n);\n\n         \n         if(hostKeyLen == n && !osMemcmp(hostKey, buffer, n))\n         {\n            \n            error = NO_ERROR;\n         }\n         else\n         {\n            \n            error = ERROR_INVALID_KEY;\n         }\n\n         \n         sshFreeMem(buffer);\n      }\n      else\n      {\n         \n         error = ERROR_OUT_OF_MEMORY;\n      }\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_modp_groups.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_DH_SUPPORT == ENABLED)\n\n\n\n\nconst SshDhGroup sshDhGroup1 =\n{\n   \n   \"diffie-hellman-group1\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   128,\n   \n   2\n};\n\n\n\n\nconst SshDhGroup sshDhGroup14 =\n{\n   \n   \"diffie-hellman-group14\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   256,\n   \n   2\n};\n\n\n\n\nconst SshDhGroup sshDhGroup15 =\n{\n   \n   \"diffie-hellman-group15\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x3A, 0xD2, 0xCA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   384,\n   \n   2\n};\n\n\n\n\nconst SshDhGroup sshDhGroup16 =\n{\n   \n   \"diffie-hellman-group16\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01, 0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\n    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26, 0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\n    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA, 0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\n    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9, 0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\n    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D, 0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\n    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED, 0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\n    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C, 0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\n    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1, 0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\n    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   512,\n   \n   2\n};\n\n\n\n\nconst SshDhGroup *sshGetDhGroup(const char_t *kexAlgo)\n{\n   const SshDhGroup *dhGroup;\n\n#if (SSH_MAX_DH_MODULUS_SIZE >= 1024 && SSH_MIN_DH_MODULUS_SIZE <= 1024)\n   \n   if(sshCompareAlgo(kexAlgo, \"diffie-hellman-group1-sha1\"))\n   {\n      dhGroup = &sshDhGroup1;\n   }\n   else\n#endif\n#if (SSH_MAX_DH_MODULUS_SIZE >= 2048 && SSH_MIN_DH_MODULUS_SIZE <= 2048)\n   \n   if(sshCompareAlgo(kexAlgo, \"diffie-hellman-group14-sha1\") ||\n      sshCompareAlgo(kexAlgo, \"diffie-hellman-group14-sha256\"))\n   {\n      dhGroup = &sshDhGroup14;\n   }\n   else\n#endif\n#if (SSH_MAX_DH_MODULUS_SIZE >= 3072 && SSH_MIN_DH_MODULUS_SIZE <= 3072)\n   \n   if(sshCompareAlgo(kexAlgo, \"diffie-hellman-group15-sha512\"))\n   {\n      dhGroup = &sshDhGroup15;\n   }\n   else\n#endif\n#if (SSH_MAX_DH_MODULUS_SIZE >= 4096 && SSH_MIN_DH_MODULUS_SIZE <= 4096)\n   \n   if(sshCompareAlgo(kexAlgo, \"diffie-hellman-group16-sha512\"))\n   {\n      dhGroup = &sshDhGroup16;\n   }\n   else\n#endif\n   \n   {\n      dhGroup = NULL;\n   }\n\n   \n   return dhGroup;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"ssh\/ssh_server.h\"\n#include \"ssh\/ssh_server_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED && SSH_SERVER_SUPPORT == ENABLED)\n\n\n\n\nvoid sshServerGetDefaultSettings(SshServerSettings *settings)\n{\n   \n   settings->interface = NULL;\n\n   \n   settings->port = SSH_PORT;\n\n   \n   settings->numConnections = 0;\n   settings->connections = NULL;\n\n   \n   settings->numChannels = 0;\n   settings->channels = NULL;\n\n   \n   settings->prngAlgo = NULL;\n   settings->prngContext = NULL;\n\n   \n   settings->passwordAuthCallback = NULL;\n   \n   settings->publicKeyAuthCallback = NULL;\n}\n\n\n\n\nerror_t sshServerInit(SshServerContext *context,\n   const SshServerSettings *settings)\n{\n   error_t error;\n\n   \n   TRACE_INFO(\"Initializing SSH server...\\r\\n\");\n\n   \n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(settings->numConnections < 1 ||\n      settings->numConnections > SSH_MAX_CONNECTIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   if(settings->numChannels < settings->numConnections)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   error = sshInit(&context->sshContext, settings->connections,\n      settings->numConnections, settings->channels, settings->numChannels);\n   \n   if(error)\n      return error;\n\n   \n   context->interface = settings->interface;\n   context->port = settings->port;\n\n   \n   do\n   {\n      \n      error = sshSetOperationMode(&context->sshContext,\n         SSH_OPERATION_MODE_SERVER);\n      \n      if(error)\n         break;\n\n      \n      error = sshSetPrng(&context->sshContext, settings->prngAlgo,\n         settings->prngContext);\n      \n      if(error)\n         break;\n\n      \n      if(settings->passwordAuthCallback != NULL)\n      {\n         \n         error = sshRegisterPasswordAuthCallback(&context->sshContext,\n            settings->passwordAuthCallback);\n         \n         if(error)\n            break;\n      }\n\n      \n      if(settings->publicKeyAuthCallback != NULL)\n      {\n         \n         error = sshRegisterPublicKeyAuthCallback(&context->sshContext,\n            settings->publicKeyAuthCallback);\n         \n         if(error)\n            break;\n      }\n\n      \n   } while(0);\n\n   \n   if(error)\n   {\n      \n      sshServerDeinit(context);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshServerRegisterGlobalRequestCallback(SshServerContext *context,\n   SshGlobalReqCallback callback, void *param)\n{\n   \n   return sshRegisterGlobalRequestCallback(&context->sshContext, callback,\n      param);\n}\n\n\n\n\nerror_t sshServerUnregisterGlobalRequestCallback(SshServerContext *context,\n   SshGlobalReqCallback callback)\n{\n   \n   return sshUnregisterGlobalRequestCallback(&context->sshContext, callback);\n}\n\n\n\n\nerror_t sshServerRegisterChannelRequestCallback(SshServerContext *context,\n   SshChannelReqCallback callback, void *param)\n{\n   \n   return sshRegisterChannelRequestCallback(&context->sshContext, callback,\n      param);\n}\n\n\n\n\nerror_t sshServerUnregisterChannelRequestCallback(SshServerContext *context,\n   SshChannelReqCallback callback)\n{\n   \n   return sshUnregisterChannelRequestCallback(&context->sshContext, callback);\n}\n\n\n\n\nerror_t sshServerLoadHostKey(SshServerContext *context, const char_t *publicKey,\n   size_t publicKeyLen, const char_t *privateKey, size_t privateKeyLen)\n{\n   error_t error;\n\n   \n   if(!context->running)\n   {\n      \n      error = sshLoadHostKey(&context->sshContext, publicKey, publicKeyLen,\n         privateKey, privateKeyLen);\n   }\n   else\n   {\n      \n      error = ERROR_WRONG_STATE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshServerUnloadAllHostKeys(SshServerContext *context)\n{\n   error_t error;\n\n   \n   if(!context->running)\n   {\n      \n      error = sshUnloadAllHostKeys(&context->sshContext);\n   }\n   else\n   {\n      \n      error = ERROR_WRONG_STATE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshServerStart(SshServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Starting SSH server...\\r\\n\");\n\n   \n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n\n   \n   do\n   {\n      \n      context->socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n\n      \n      if(context->socket == NULL)\n      {\n         \n         error = ERROR_OPEN_FAILED;\n         \n         break;\n      }\n\n      \n      error = socketSetTimeout(context->socket, 0);\n      \n      if(error)\n         break;\n\n      \n      error = socketBindToInterface(context->socket, context->interface);\n      \n      if(error)\n         break;\n\n      \n      error = socketBind(context->socket, &IP_ADDR_ANY, context->port);\n      \n      if(error)\n         break;\n\n      \n      error = socketListen(context->socket, 0);\n      \n      if(error)\n         break;\n\n      \n      context->stop = FALSE;\n      context->running = TRUE;\n\n      \n      task = osCreateTask(\"SSH Server\", (OsTaskCode) sshServerTask, context,\n         SSH_SERVER_STACK_SIZE, SSH_SERVER_PRIORITY);\n      \n      if(task == OS_INVALID_HANDLE)\n      {\n         \n         error = ERROR_OUT_OF_RESOURCES;\n         break;\n      }\n\n      \n   } while(0);\n\n   \n   if(error)\n   {\n      \n      context->running = FALSE;\n      \n      socketClose(context->socket);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t sshServerStop(SshServerContext *context)\n{\n   uint_t i;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   TRACE_INFO(\"Stopping SSH server...\\r\\n\");\n\n   \n   if(context->running)\n   {\n      \n      context->stop = TRUE;\n      \n      sshNotifyEvent(&context->sshContext);\n\n      \n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n\n      \n      for(i = 0; i < context->sshContext.numConnections; i++)\n      {\n         \n         if(context->sshContext.connections[i].state != SSH_CONN_STATE_CLOSED)\n         {\n            \n            sshCloseConnection(&context->sshContext.connections[i]);\n         }\n      }\n\n      \n      socketClose(context->socket);\n      context->socket = NULL;\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid sshServerTask(SshServerContext *context)\n{\n   error_t error;\n   uint_t i;\n   SshContext *sshContext;\n   SshConnection *connection;\n\n   \n   sshContext = &context->sshContext;\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   \n   osEnterTask();\n\n   \n   while(1)\n   {\n#endif\n      \n      osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));\n\n      \n      for(i = 0; i < sshContext->numConnections; i++)\n      {\n         \n         connection = &sshContext->connections[i];\n\n         \n         if(connection->state != SSH_CONN_STATE_CLOSED)\n         {\n            \n            sshRegisterConnectionEvents(sshContext, connection,\n               &sshContext->eventDesc[i]);\n         }\n      }\n\n      \n      sshContext->eventDesc[i].socket = context->socket;\n      sshContext->eventDesc[i].eventMask = SOCKET_EVENT_ACCEPT;\n\n      \n      error = socketPoll(sshContext->eventDesc, sshContext->numConnections + 1,\n         &sshContext->event, SSH_SERVER_TICK_INTERVAL);\n\n      \n      if(error == NO_ERROR || error == ERROR_TIMEOUT)\n      {\n         \n         if(context->stop)\n         {\n            \n            context->running = FALSE;\n            \n            osDeleteTask(NULL);\n         }\n\n         \n         for(i = 0; i < sshContext->numConnections; i++)\n         {\n            \n            connection = &sshContext->connections[i];\n\n            \n            if(connection->state != SSH_CONN_STATE_CLOSED)\n            {\n               \n               if(sshContext->eventDesc[i].eventFlags != 0)\n               {\n                  \n                  error = sshProcessConnectionEvents(sshContext, connection);\n\n                  \n                  if(error != NO_ERROR && error != ERROR_TIMEOUT)\n                  {\n                     \n                     sshCloseConnection(connection);\n                  }\n               }\n            }\n         }\n\n         \n         if(sshContext->eventDesc[i].eventFlags != 0)\n         {\n            \n            sshServerAcceptConnection(context);\n         }\n      }\n\n      \n      sshServerTick(context);\n\n#if (NET_RTOS_SUPPORT == ENABLED)\n   }\n#endif\n}\n\n\n\n\nvoid sshServerDeinit(SshServerContext *context)\n{\n   \n   if(context != NULL)\n   {\n      \n      socketClose(context->socket);\n\n      \n      sshDeinit(&context->sshContext);\n\n      \n      osMemset(context, 0, sizeof(SshServerContext));\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SSH_TRACE_LEVEL\n\n\n#include \"ssh\/ssh.h\"\n#include \"ssh\/ssh_server.h\"\n#include \"ssh\/ssh_server_misc.h\"\n#include \"ssh\/ssh_transport.h\"\n#include \"ssh\/ssh_channel.h\"\n#include \"ssh\/ssh_misc.h\"\n#include \"debug.h\"\n\n\n#if (SSH_SUPPORT == ENABLED && SSH_SERVER_SUPPORT == ENABLED)\n\n\n\n\nvoid sshServerTick(SshServerContext *context)\n{\n   error_t error;\n   uint_t i;\n   systime_t time;\n   SshConnection *connection;\n\n   \n   time = osGetSystemTime();\n\n   \n   for(i = 0; i < context->sshContext.numConnections; i++)\n   {\n      \n      connection = &context->sshContext.connections[i];\n\n      \n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         \n         if(timeCompare(time, connection->timestamp + SSH_SERVER_TIMEOUT) >= 0)\n         {\n            \n            TRACE_INFO(\"SSH server: Closing inactive connection...\\r\\n\");\n\n            \n            error = sshSendDisconnect(connection, SSH_DISCONNECT_BY_APPLICATION,\n               \"Session idle timeout\");\n\n            \n            if(error)\n            {\n               \n               sshCloseConnection(connection);\n            }\n         }\n      }\n   }\n}\n\n\n\n\nvoid sshServerAcceptConnection(SshServerContext *context)\n{\n   Socket *socket;\n   IpAddr clientIpAddr;\n   uint16_t clientPort;\n   SshConnection *connection;\n\n   \n   socket = socketAccept(context->socket, &clientIpAddr, &clientPort);\n\n   \n   if(socket != NULL)\n   {\n      \n      connection = sshOpenConnection(&context->sshContext, socket);\n\n      \n      \n      if(connection != NULL)\n      {\n         \n         TRACE_INFO(\"SSH server: Connection established with client %s port %\"\n            PRIu16 \"...\\r\\n\", ipAddrToString(&clientIpAddr, NULL), clientPort);\n\n         \n         socketSetTimeout(socket, 0);\n      }\n      else\n      {\n         \n         TRACE_INFO(\"SSH Server: Connection refused with client %s port %\"\n            PRIu16 \"...\\r\\n\", ipAddrToString(&clientIpAddr, NULL), clientPort);\n\n         \n         socketClose(socket);\n      }\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"core\/crypto.h\"\n#include \"tls.h\"\n#include \"ssl_misc.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_MIN_VERSION <= SSL_VERSION_3_0)\n\n\nconst uint8_t sslPad1[48] =\n{\n   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,\n   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,\n   0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36\n};\n\n\nconst uint8_t sslPad2[48] =\n{\n   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,\n   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,\n   0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C\n};\n\n\n\n\nerror_t sslExpandKey(const uint8_t *secret, size_t secretLen,\n   const uint8_t *random, size_t randomLen, uint8_t *output, size_t outputLen)\n{\n   uint_t i;\n   size_t n;\n   char_t pad[16];\n   Md5Context *md5Context;\n   Sha1Context *sha1Context;\n\n   \n   if(outputLen > (sizeof(pad) * MD5_DIGEST_SIZE))\n      return ERROR_INVALID_LENGTH;\n\n   \n   md5Context = tlsAllocMem(sizeof(Md5Context));\n   \n   if(md5Context == NULL)\n   {\n      \n      return ERROR_OUT_OF_MEMORY;\n   }\n\n   \n   sha1Context = tlsAllocMem(sizeof(Sha1Context));\n   \n   if(sha1Context == NULL)\n   {\n      \n      tlsFreeMem(md5Context);\n      \n      return ERROR_OUT_OF_MEMORY;\n   }\n\n   \n   for(i = 0; outputLen > 0; i++)\n   {\n      \n      osMemset(pad, 'A' + i, i + 1);\n\n      \n      sha1Init(sha1Context);\n      sha1Update(sha1Context, pad, i + 1);\n      sha1Update(sha1Context, secret, secretLen);\n      sha1Update(sha1Context, random, randomLen);\n      sha1Final(sha1Context, NULL);\n\n      \n      md5Init(md5Context);\n      md5Update(md5Context, secret, secretLen);\n      md5Update(md5Context, sha1Context->digest, SHA1_DIGEST_SIZE);\n      md5Final(md5Context, NULL);\n\n      \n      n = MIN(outputLen, MD5_DIGEST_SIZE);\n      \n      osMemcpy(output, md5Context->digest, n);\n\n      \n      output += n;\n      \n      outputLen -= n;\n   }\n\n   \n   tlsFreeMem(md5Context);\n   tlsFreeMem(sha1Context);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t sslComputeMac(TlsEncryptionEngine *encryptionEngine,\n   const TlsRecord *record, const uint8_t *data, size_t dataLen, uint8_t *mac)\n{\n   size_t padLen;\n   const HashAlgo *hashAlgo;\n   HashContext *hashContext;\n\n   \n   hashAlgo = encryptionEngine->hashAlgo;\n   \n   hashContext = (HashContext *) encryptionEngine->hmacContext->hashContext;\n\n   \n   if(hashAlgo == MD5_HASH_ALGO)\n   {\n      \n      padLen = 48;\n   }\n   else if(hashAlgo == SHA1_HASH_ALGO)\n   {\n      \n      padLen = 40;\n   }\n   else\n   {\n      \n      return ERROR_INVALID_PARAMETER;\n   }\n\n   \n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad1, padLen);\n   hashAlgo->update(hashContext, &encryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   hashAlgo->update(hashContext, &record->type, sizeof(record->type));\n   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));\n   hashAlgo->update(hashContext, data, dataLen);\n   hashAlgo->final(hashContext, mac);\n\n   \n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad2, padLen);\n   hashAlgo->update(hashContext, mac, hashAlgo->digestSize);\n   hashAlgo->final(hashContext, mac);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nuint32_t sslVerifyPadding(TlsEncryptionEngine *decryptionEngine,\n   const uint8_t *data, size_t dataLen, size_t *paddingLen)\n{\n   size_t i;\n   size_t n;\n   uint8_t b;\n   uint8_t mask;\n   uint32_t c;\n   uint32_t bad;\n   uint32_t bad1;\n   uint32_t bad2;\n\n   \n   n = data[dataLen - 1];\n\n   \n   bad = CRYPTO_TEST_GTE_32(n, dataLen);\n\n   \n   \n   bad |= CRYPTO_TEST_GTE_32(n, decryptionEngine->cipherAlgo->blockSize);\n\n   \n   \n   for(bad1 = 0, i = 1; i < dataLen && i < 256; i++)\n   {\n      \n      b = data[dataLen - 1 - i];\n\n      \n      c = CRYPTO_TEST_LTE_32(i, n);\n      mask = CRYPTO_SELECT_8(b, n, c);\n      bad1 |= CRYPTO_TEST_NEQ_8(b, mask);\n   }\n\n   \n   \n   for(bad2 = 0, i = 1; i < dataLen && i < 256; i++)\n   {\n      \n      b = data[dataLen - 1 - i];\n\n      \n      c = CRYPTO_TEST_LTE_32(i, n);\n      mask = CRYPTO_SELECT_8(b, 0, c);\n      bad2 |= CRYPTO_TEST_NEQ_8(b, mask);\n   }\n\n   \n   bad |= bad1 & bad2;\n\n   \n   *paddingLen = CRYPTO_SELECT_32(n, 0, bad);\n\n   \n   return bad;\n}\n\n\n\n\nuint32_t sslVerifyMac(TlsEncryptionEngine *decryptionEngine,\n   const TlsRecord *record, const uint8_t *data, size_t dataLen,\n   size_t maxDataLen, const uint8_t *mac)\n{\n   size_t i;\n   size_t j;\n   size_t n;\n   size_t padLen;\n   size_t headerLen;\n   size_t paddingLen;\n   size_t blockSizeMask;\n   uint8_t b;\n   uint32_t c;\n   uint64_t bitLen;\n   const HashAlgo *hashAlgo;\n   HashContext *hashContext;\n   uint8_t temp1[SHA1_DIGEST_SIZE];\n   uint8_t temp2[SHA1_DIGEST_SIZE];\n\n   \n   hashAlgo = decryptionEngine->hashAlgo;\n   \n   hashContext = (HashContext *) decryptionEngine->hmacContext->hashContext;\n\n   \n   if(hashAlgo == MD5_HASH_ALGO)\n   {\n      \n      padLen = 48;\n   }\n   else if(hashAlgo == SHA1_HASH_ALGO)\n   {\n      \n      padLen = 40;\n   }\n   else\n   {\n      \n      return 1;\n   }\n\n   \n   blockSizeMask = hashAlgo->blockSize - 1;\n\n   \n   \n   headerLen = decryptionEngine->macKeyLen + padLen + 11;\n\n   \n   paddingLen = (headerLen + dataLen + hashAlgo->minPadSize - 1) & blockSizeMask;\n   paddingLen = hashAlgo->blockSize - paddingLen;\n\n   \n   bitLen = (headerLen + dataLen) << 3;\n\n   \n   if(hashAlgo->bigEndian)\n   {\n      \n      bitLen = swapInt64(bitLen);\n   }\n\n   \n   n = headerLen + maxDataLen + hashAlgo->minPadSize;\n   n = (n + hashAlgo->blockSize - 1) & ~blockSizeMask;\n   n -= headerLen;\n\n   \n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad1, padLen);\n   hashAlgo->update(hashContext, &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   hashAlgo->update(hashContext, &record->type, sizeof(record->type));\n   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));\n\n   \n   i = 0;\n\n   \n   \n   if(maxDataLen > 255)\n   {\n      \n      hashAlgo->update(hashContext, data, maxDataLen - 255);\n      i += maxDataLen - 255;\n   }\n\n   \n   while(i < n)\n   {\n      \n      b = 0;\n\n      \n      c = CRYPTO_TEST_LT_32(i, dataLen);\n      b = CRYPTO_SELECT_8(b, data[i], c);\n\n      c = CRYPTO_TEST_EQ_32(i, dataLen);\n      b = CRYPTO_SELECT_8(b, 0x80, c);\n\n      j = dataLen + paddingLen;\n      c = CRYPTO_TEST_GTE_32(i, j);\n      j += 8;\n      c &= CRYPTO_TEST_LT_32(i, j);\n      b = CRYPTO_SELECT_8(b, bitLen & 0xFF, c);\n      bitLen = CRYPTO_SELECT_64(bitLen, bitLen >> 8, c);\n\n      \n      hashAlgo->update(hashContext, &b, sizeof(uint8_t));\n\n      \n      i++;\n\n      \n      if(((i + headerLen) & blockSizeMask) == 0)\n      {\n         \n         hashAlgo->finalRaw(hashContext, temp1);\n\n         \n         c = CRYPTO_TEST_EQ_32(i, dataLen + paddingLen + 8);\n\n         \n         \n         for(j = 0; j < hashAlgo->digestSize; j++)\n         {\n            temp2[j] = CRYPTO_SELECT_8(temp2[j], temp1[j], c);\n         }\n      }\n   }\n\n   \n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad2, padLen);\n   hashAlgo->update(hashContext, temp2, hashAlgo->digestSize);\n   hashAlgo->final(hashContext, temp1);\n\n   \n   TRACE_DEBUG(\"Read sequence number:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   TRACE_DEBUG(\"Computed MAC:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", temp1, hashAlgo->digestSize);\n\n   \n   \n   for(b = 0, i = 0; i < hashAlgo->digestSize; i++)\n   {\n      b |= mac[i] ^ temp1[i];\n   }\n\n   \n   return CRYPTO_TEST_NEQ_8(b, 0);\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_handshake.h\"\n#include \"tls_client.h\"\n#include \"tls_common.h\"\n#include \"tls_transcript_hash.h\"\n#include \"tls_record.h\"\n#include \"tls_misc.h\"\n#include \"tls13_client_misc.h\"\n#include \"tls13_key_material.h\"\n#include \"tls13_ticket.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_CLIENT_SUPPORT == ENABLED && \\\n   TLS_MAX_VERSION >= TLS_VERSION_1_3)\n\n\n\n\nbool_t tls13IsHelloRetryRequest(const TlsServerHello *message, size_t length)\n{\n   bool_t res;\n\n   \n   res = FALSE;\n\n   \n   if(length >= sizeof(TlsServerHello))\n   {\n      \n      \n      if(!osMemcmp(&message->random, tls13HelloRetryRequestRandom,\n         sizeof(tls13HelloRetryRequestRandom)))\n      {\n         \n         res = TRUE;\n      }\n   }\n\n   \n   return res;\n}\n\n\n\n\nerror_t tls13ComputePskBinders(TlsContext *context, const void *clientHello,\n   size_t clientHelloLen, const Tls13PskIdentityList *identityList,\n   Tls13PskBinderList *binderList)\n{\n   error_t error;\n   size_t n;\n   size_t m;\n   size_t truncatedClientHelloLen;\n   uint8_t *q;\n   const uint8_t *p;\n   Tls13PskBinder *binder;\n   const Tls13PskIdentity *identity;\n\n   \n   error = NO_ERROR;\n\n#if (TLS13_PSK_KE_SUPPORT == ENABLED || TLS13_PSK_DHE_KE_SUPPORT == ENABLED || \\\n   TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)\n   \n   if(identityList != NULL && binderList != NULL)\n   {\n      \n      \n      p = identityList->value;\n      n = ntohs(identityList->length);\n\n      \n      \n      q = binderList->value;\n      m = ntohs(binderList->length);\n\n      \n      \n      truncatedClientHelloLen = (uint8_t *) binderList - (uint8_t *) clientHello;\n\n      \n      while(n > 0)\n      {\n         \n         identity = (Tls13PskIdentity *) p;\n\n         \n         if(n < sizeof(TlsPskIdentity))\n            return ERROR_DECODING_FAILED;\n         if(n < (sizeof(TlsPskIdentity) + ntohs(identity->length)))\n            return ERROR_DECODING_FAILED;\n\n         \n         p += sizeof(TlsPskIdentity) + ntohs(identity->length);\n         n -= sizeof(TlsPskIdentity) + ntohs(identity->length);\n\n         \n         if(n < sizeof(uint32_t))\n            return ERROR_DECODING_FAILED;\n\n         \n         p += sizeof(uint32_t);\n         n -= sizeof(uint32_t);\n\n         \n         binder = (Tls13PskBinder *) q;\n\n         \n         if(m < sizeof(Tls13PskBinder))\n            return ERROR_DECODING_FAILED;\n         if(m < (sizeof(Tls13PskBinder) + binder->length))\n            return ERROR_DECODING_FAILED;\n\n         \n         q += sizeof(Tls13PskBinder) + binder->length;\n         m -= sizeof(Tls13PskBinder) + binder->length;\n\n         \n         error = tls13ComputePskBinder(context, clientHello, clientHelloLen,\n            truncatedClientHelloLen, identity, binder->value, binder->length);\n         \n         if(error)\n            break;\n      }\n   }\n#endif\n\n   \n   return error;\n}\n\n\n\n\nerror_t tls13SendEarlyData(TlsContext *context, const void *data,\n   size_t length, size_t *written)\n{\n#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)\n   error_t error;\n   size_t n;\n\n   \n   *written = 0;\n\n   \n   if(tls13IsPskValid(context))\n   {\n      \n      if(context->pskCipherSuite == 0)\n         return ERROR_END_OF_STREAM;\n   }\n   else if(tls13IsTicketValid(context))\n   {\n      \n      if(context->ticketCipherSuite == 0)\n         return ERROR_END_OF_STREAM;\n   }\n   else\n   {\n      \n      return ERROR_END_OF_STREAM;\n   }\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)\n      {\n         \n         if(context->state != TLS_STATE_INIT &&\n            context->state != TLS_STATE_CLOSED)\n         {\n            \n            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);\n            \n            if(error)\n               break;\n         }\n      }\n\n      \n      \n      if(context->state == TLS_STATE_INIT)\n      {\n         \n         error = tlsInitHandshake(context);\n      }\n      else if(context->state == TLS_STATE_CLIENT_HELLO)\n      {\n         \n         \n         \n         context->earlyDataEnabled = TRUE;\n\n         \n         \n         error = tlsSendClientHello(context);\n      }\n      else if(context->state == TLS_STATE_SERVER_HELLO)\n      {\n         \n         error = tlsInitTranscriptHash(context);\n\n#if (TLS13_MIDDLEBOX_COMPAT_SUPPORT == ENABLED)\n         \n         \n         context->state = TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC;\n#else\n         \n         context->state = TLS_STATE_CLIENT_HELLO_2;\n#endif\n      }\n      else if(context->state == TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC)\n      {\n         \n         error = tlsSendChangeCipherSpec(context);\n      }\n      else if(context->state == TLS_STATE_CLIENT_HELLO_2)\n      {\n         \n         error = tls13GenerateEarlyTrafficKeys(context);\n      }\n      else if(context->state == TLS_STATE_EARLY_DATA)\n      {\n         \n         if(*written < length &&\n            context->earlyDataLen < context->maxEarlyDataSize)\n         {\n            \n            n = MIN(context->txBufferMaxLen, length - *written);\n            n = MIN(n, context->maxEarlyDataSize - context->earlyDataLen);\n\n            \n            n = MIN(n, TLS_MAX_RECORD_LENGTH);\n\n            \n            TRACE_INFO(\"Sending early data (%\" PRIuSIZE \" bytes)...\\r\\n\", n);\n\n            \n            error = tlsWriteProtocolData(context, data, n,\n               TLS_TYPE_APPLICATION_DATA);\n\n            \n            if(!error)\n            {\n               \n               data = (uint8_t *) data + n;\n               \n               *written += n;\n\n               \n               context->earlyDataLen += n;\n            }\n         }\n         else\n         {\n            \n            break;\n         }\n      }\n      else\n      {\n         \n         error = ERROR_UNEXPECTED_STATE;\n      }\n   }\n\n   \n   if(error == NO_ERROR && length != 0 && *written == 0)\n   {\n      error = ERROR_END_OF_STREAM;\n   }\n\n   \n   return error;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_handshake.h\"\n#include \"tls_misc.h\"\n#include \"tls13_common.h\"\n#include \"tls13_key_material.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_MAX_VERSION >= TLS_VERSION_1_3)\n\n\n\n\nerror_t tls13SendKeyUpdate(TlsContext *context)\n{\n   error_t error;\n   size_t length;\n   uint8_t *appTrafficSecret;\n   Tls13KeyUpdate *message;\n   const HashAlgo *hash;\n\n   \n   appTrafficSecret = NULL;\n\n   \n   message = (Tls13KeyUpdate *) (context->txBuffer + context->txBufferLen);\n\n   \n   error = tls13FormatKeyUpdate(context, message, &length);\n\n   \n   if(!error)\n   {\n      \n      TRACE_INFO(\"Sending KeyUpdate message (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n      TRACE_DEBUG_ARRAY(\"  \", message, length);\n\n      \n      error = tlsSendHandshakeMessage(context, message, length,\n         TLS_TYPE_KEY_UPDATE);\n   }\n\n   \n   if(error == NO_ERROR || error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n   {\n      \n      hash = context->cipherSuite.prfHashAlgo;\n\n      \n      if(hash != NULL)\n      {\n         \n         if(context->entity == TLS_CONNECTION_END_CLIENT)\n            appTrafficSecret = context->clientAppTrafficSecret;\n         else\n            appTrafficSecret = context->serverAppTrafficSecret;\n\n         \n         error = tls13HkdfExpandLabel(hash, appTrafficSecret, hash->digestSize,\n            \"traffic upd\", NULL, 0, appTrafficSecret, hash->digestSize);\n      }\n      else\n      {\n         \n         error = ERROR_FAILURE;\n      }\n   }\n\n   \n   if(!error)\n   {\n      \n      tlsFreeEncryptionEngine(&context->encryptionEngine);\n\n      \n      \n      error = tlsInitEncryptionEngine(context, &context->encryptionEngine,\n         context->entity, appTrafficSecret);\n   }\n\n   \n   if(!error)\n   {\n      \n      \n      context->state = TLS_STATE_APPLICATION_DATA;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tls13FormatKeyUpdate(TlsContext *context, Tls13KeyUpdate *message,\n   size_t *length)\n{\n   \n   \n   message->requestUpdate = TLS_KEY_UPDATE_NOT_REQUESTED;\n\n   \n   *length = sizeof(Tls13KeyUpdate);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tls13ParseKeyUpdate(TlsContext *context, const Tls13KeyUpdate *message,\n   size_t length)\n{\n   error_t error;\n   uint8_t *appTrafficSecret;\n   TlsConnectionEnd entity;\n   const HashAlgo *hash;\n\n   \n   TRACE_INFO(\"KeyUpdate message received (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", message, length);\n\n   \n   if(context->version != TLS_VERSION_1_3)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(length != sizeof(Tls13KeyUpdate))\n      return ERROR_DECODING_FAILED;\n\n   \n   if(message->requestUpdate != TLS_KEY_UPDATE_NOT_REQUESTED &&\n      message->requestUpdate != TLS_KEY_UPDATE_REQUESTED)\n   {\n      \n      \n      return ERROR_ILLEGAL_PARAMETER;\n   }\n\n   \n   \n   if(context->state != TLS_STATE_APPLICATION_DATA &&\n      context->state != TLS_STATE_CLOSING)\n   {\n      \n      return ERROR_UNEXPECTED_MESSAGE;\n   }\n\n#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)\n   \n   context->keyUpdateCount++;\n\n   \n   if(context->keyUpdateCount > TLS_MAX_KEY_UPDATE_MESSAGES)\n      return ERROR_UNEXPECTED_MESSAGE;\n#endif\n\n   \n   hash = context->cipherSuite.prfHashAlgo;\n   \n   if(hash == NULL)\n      return ERROR_FAILURE;\n\n   \n   if(context->entity == TLS_CONNECTION_END_CLIENT)\n   {\n      entity = TLS_CONNECTION_END_SERVER;\n      appTrafficSecret = context->serverAppTrafficSecret;\n   }\n   else\n   {\n      entity = TLS_CONNECTION_END_CLIENT;\n      appTrafficSecret = context->clientAppTrafficSecret;\n   }\n\n   \n   error = tls13HkdfExpandLabel(hash, appTrafficSecret, hash->digestSize,\n      \"traffic upd\", NULL, 0, appTrafficSecret, hash->digestSize);\n   \n   if(error)\n      return error;\n\n   \n   \n   if(context->rxBufferLen != 0)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   tlsFreeEncryptionEngine(&context->decryptionEngine);\n\n   \n   \n   error = tlsInitEncryptionEngine(context, &context->decryptionEngine,\n      entity, appTrafficSecret);\n   \n   if(error)\n      return error;\n\n   \n   if(message->requestUpdate == TLS_KEY_UPDATE_REQUESTED &&\n      context->state == TLS_STATE_APPLICATION_DATA)\n   {\n#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)\n      if(context->keyUpdateCount == 1)\n#endif\n      {\n         \n         \n         \n         context->state = TLS_STATE_KEY_UPDATE;\n      }\n   }\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_server_misc.h\"\n#include \"tls_transcript_hash.h\"\n#include \"tls_ffdhe.h\"\n#include \"tls_misc.h\"\n#include \"tls13_server_extensions.h\"\n#include \"tls13_server_misc.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_SERVER_SUPPORT == ENABLED && \\\n   TLS_MAX_VERSION >= TLS_VERSION_1_3)\n\n\n\n\nerror_t tls13NegotiateCipherSuite(TlsContext *context, const void *clientHello,\n   size_t clientHelloLen, const TlsCipherSuites *cipherSuites,\n   TlsHelloExtensions *extensions)\n{\n   error_t error;\n\n   \n   \n   context->keyExchMethod = TLS_KEY_EXCH_NONE;\n\n   \n   \n   \n   error = tls13ParseClientPreSharedKeyExtension(context, clientHello,\n      clientHelloLen, extensions->identityList, extensions->binderList);\n   \n   if(error)\n      return error;\n\n   \n   if(context->selectedIdentity >= 0)\n   {\n      \n      error = tlsNegotiateCipherSuite(context, context->cipherSuite.prfHashAlgo,\n         cipherSuites, extensions);\n\n      \n      if(!error)\n      {\n         \n         context->keyExchMethod = TLS13_KEY_EXCH_PSK;\n      }\n      else\n      {\n         \n         context->keyExchMethod = TLS_KEY_EXCH_NONE;\n         context->selectedIdentity = -1;\n      }\n   }\n\n   \n   if(context->keyExchMethod == TLS_KEY_EXCH_NONE)\n   {\n      \n      error = tlsNegotiateCipherSuite(context, NULL, cipherSuites, extensions);\n      \n      if(error)\n         return ERROR_HANDSHAKE_FAILED;\n   }\n\n   \n   \n   \n   if(context->state != TLS_STATE_CLIENT_HELLO_2)\n   {\n      \n      error = tlsInitTranscriptHash(context);\n      \n      if(error)\n         return error;\n   }\n\n   \n   \n   error = tls13ParseClientEarlyDataExtension(context,\n      extensions->earlyDataIndication);\n   \n   if(error)\n      return error;\n\n   \n   error = tls13ParseClientKeyShareExtension(context, extensions->keyShareList);\n   \n   if(error)\n      return error;\n\n   \n   if(extensions->keyShareList != NULL && context->namedGroup == TLS_GROUP_NONE)\n   {\n      \n      error = tls13SelectGroup(context, extensions->supportedGroupList);\n      \n      if(error)\n         return error;\n\n      \n      context->state = TLS_STATE_HELLO_RETRY_REQUEST;\n   }\n   else\n   {\n      \n      if(context->keyExchMethod == TLS13_KEY_EXCH_DHE ||\n         context->keyExchMethod == TLS13_KEY_EXCH_ECDHE)\n      {\n         \n      }\n      else if(context->keyExchMethod == TLS13_KEY_EXCH_PSK ||\n         context->keyExchMethod == TLS13_KEY_EXCH_PSK_DHE ||\n         context->keyExchMethod == TLS13_KEY_EXCH_PSK_ECDHE)\n      {\n         \n         \n         error = tls13ParsePskKeModesExtension(context,\n            extensions->pskKeModeList);\n         \n         if(error)\n            return error;\n\n         \n         \n         error = tls13VerifyPskBinder(context, clientHello, clientHelloLen,\n            extensions->identityList, extensions->binderList,\n            context->selectedIdentity);\n         \n         if(error)\n            return error;\n      }\n      else\n      {\n         \n         \n         return ERROR_HANDSHAKE_FAILED;\n      }\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tls13SelectGroup(TlsContext *context,\n   const TlsSupportedGroupList *groupList)\n{\n   error_t error;\n\n   \n   error = ERROR_HANDSHAKE_FAILED;\n\n   \n   context->namedGroup = TLS_GROUP_NONE;\n\n#if (TLS13_DHE_KE_SUPPORT == ENABLED || TLS13_ECDHE_KE_SUPPORT == ENABLED || \\\n   TLS13_PSK_DHE_KE_SUPPORT == ENABLED || TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)\n   \n   if(groupList != NULL)\n   {\n      uint_t i;\n      uint_t j;\n      uint_t n;\n      uint16_t namedGroup;\n\n      \n      n = ntohs(groupList->length) \/ sizeof(uint16_t);\n\n      \n      if(context->numSupportedGroups > 0)\n      {\n         \n         for(i = 0; i < context->numSupportedGroups && error; i++)\n         {\n            \n            for(j = 0; j < n && error; j++)\n            {\n               \n               namedGroup = ntohs(groupList->value[j]);\n\n               \n               \n               if(context->supportedGroups[i] == namedGroup)\n               {\n                  \n                  if(tls13IsGroupSupported(context, namedGroup))\n                  {\n                     \n                     context->namedGroup = namedGroup;\n                     error = NO_ERROR;\n                  }\n               }\n            }\n         }\n      }\n      else\n      {\n         \n         \n         for(j = 0; j < n && error; j++)\n         {\n            \n            namedGroup = ntohs(groupList->value[j]);\n\n            \n            if(tls13IsGroupSupported(context, namedGroup))\n            {\n               \n               context->namedGroup = namedGroup;\n               error = NO_ERROR;\n            }\n         }\n      }\n   }\n#endif\n\n   \n   return error;\n}\n\n\n\n\nerror_t tls13VerifyPskBinder(TlsContext *context, const void *clientHello,\n   size_t clientHelloLen, const Tls13PskIdentityList *identityList,\n   const Tls13PskBinderList *binderList, int_t selectedIdentity)\n{\n#if (TLS13_PSK_KE_SUPPORT == ENABLED || TLS13_PSK_DHE_KE_SUPPORT == ENABLED || \\\n   TLS13_PSK_ECDHE_KE_SUPPORT == ENABLED)\n   error_t error;\n   int_t i;\n   size_t n;\n   const uint8_t *p;\n   const Tls13PskIdentity *identity;\n   const Tls13PskBinder *binder;\n   uint8_t calculatedBinder[TLS_MAX_HKDF_DIGEST_SIZE];\n\n   \n   identity = NULL;\n   binder = NULL;\n\n   \n   if(identityList == NULL || binderList == NULL)\n      return ERROR_FAILURE;\n\n   \n   if(selectedIdentity < 0)\n      return ERROR_FAILURE;\n\n   \n   \n   p = identityList->value;\n   n = ntohs(identityList->length);\n\n   \n   for(i = 0; i <= selectedIdentity && n > 0; i++)\n   {\n      \n      identity = (Tls13PskIdentity *) p;\n\n      \n      if(n < sizeof(TlsPskIdentity))\n         return ERROR_DECODING_FAILED;\n      if(n < (sizeof(TlsPskIdentity) + ntohs(identity->length)))\n         return ERROR_DECODING_FAILED;\n\n      \n      p += sizeof(TlsPskIdentity) + ntohs(identity->length);\n      n -= sizeof(TlsPskIdentity) + ntohs(identity->length);\n\n      \n      if(n < sizeof(uint32_t))\n         return ERROR_DECODING_FAILED;\n\n      \n      p += sizeof(uint32_t);\n      n -= sizeof(uint32_t);\n   }\n\n   \n   if(selectedIdentity >= i)\n      return ERROR_FAILURE;\n\n   \n   \n   p = binderList->value;\n   n = ntohs(binderList->length);\n\n   \n   for(i = 0; i <= selectedIdentity && n > 0; i++)\n   {\n      \n      binder = (Tls13PskBinder *) p;\n\n      \n      if(n < sizeof(Tls13PskBinder))\n         return ERROR_DECODING_FAILED;\n      if(n < (sizeof(Tls13PskBinder) + binder->length))\n         return ERROR_DECODING_FAILED;\n\n      \n      p += sizeof(Tls13PskBinder) + binder->length;\n      n -= sizeof(Tls13PskBinder) + binder->length;\n   }\n\n   \n   if(selectedIdentity >= i)\n      return ERROR_FAILURE;\n\n   \n   if(binder->length > TLS_MAX_HKDF_DIGEST_SIZE)\n      return ERROR_DECRYPTION_FAILED;\n\n   \n   \n   n = (uint8_t *) binderList - (uint8_t *) clientHello;\n\n   \n   error = tls13ComputePskBinder(context, clientHello, clientHelloLen,\n      n, identity, calculatedBinder, binder->length);\n   \n   if(error)\n      return ERROR_DECRYPTION_FAILED;\n\n   \n   TRACE_DEBUG(\"PSK binder:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", binder->value, binder->length);\n   TRACE_DEBUG(\"Calculated PSK binder:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", calculatedBinder, binder->length);\n\n   \n   \n   if(osMemcmp(calculatedBinder, binder->value, binder->length))\n   {\n      \n      return ERROR_DECRYPTION_FAILED;\n   }\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t tls13ProcessEarlyData(TlsContext *context, const uint8_t *data,\n   size_t length)\n{\n   \n   if(context->version != TLS_VERSION_1_3)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   if(context->state != TLS_STATE_CLIENT_HELLO_2)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   \n   if(!context->earlyDataExtReceived)\n      return ERROR_UNEXPECTED_MESSAGE;\n\n   \n   context->earlyDataLen += length;\n\n   \n   \n   if(context->earlyDataLen > context->maxEarlyDataSize)\n      return ERROR_BAD_RECORD_MAC;\n\n   \n   TRACE_INFO(\"Discarding early data (%\" PRIuSIZE \" bytes)...\\r\\n\", length);\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include \"tls.h\"\n#include \"tls_misc.h\"\n#include \"tls13_key_material.h\"\n#include \"tls13_ticket.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_MAX_VERSION >= TLS_VERSION_1_3)\n\n\n\n\nbool_t tls13IsTicketValid(TlsContext *context)\n{\n   bool_t valid = FALSE;\n\n   \n   if(tlsGetHashAlgo(context->ticketHashAlgo) != NULL)\n   {\n      \n      if(context->ticketPskLen > 0)\n      {\n         \n         if(context->entity == TLS_CONNECTION_END_CLIENT)\n         {\n            \n            if(context->ticket != NULL && context->ticketLen > 0)\n            {\n               valid = TRUE;\n            }\n         }\n         else\n         {\n            valid = TRUE;\n         }\n      }\n   }\n\n   \n   return valid;\n}\n\n\n\n\nerror_t tls13SaveSessionTicket(const TlsContext *context,\n   TlsSessionState *session)\n{\n   const HashAlgo *hashAlgo;\n\n   \n   if(context->version != TLS_VERSION_1_3)\n      return ERROR_INVALID_VERSION;\n\n   \n   if(context->ticket == NULL || context->ticketLen == 0)\n      return ERROR_INVALID_TICKET;\n\n   \n   if(context->cipherSuite.identifier == 0 ||\n      context->cipherSuite.prfHashAlgo == NULL)\n   {\n      return ERROR_INVALID_SESSION;\n   }\n\n   \n   hashAlgo = context->cipherSuite.prfHashAlgo;\n\n   \n   session->ticket = tlsAllocMem(context->ticketLen);\n   \n   if(session->ticket == NULL)\n      return ERROR_OUT_OF_MEMORY;\n\n   \n   session->timestamp = osGetSystemTime();\n\n   \n   session->version = context->version;\n   session->cipherSuite = context->cipherSuite.identifier;\n   session->ticketTimestamp = context->ticketTimestamp;\n   session->ticketLifetime = context->ticketLifetime;\n   session->ticketAgeAdd = context->ticketAgeAdd;\n   session->maxEarlyDataSize = context->maxEarlyDataSize;\n\n   \n   osMemcpy(session->ticket, context->ticket, context->ticketLen);\n   session->ticketLen = context->ticketLen;\n\n   \n   \n   if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA256))\n   {\n      session->ticketHashAlgo = TLS_HASH_ALGO_SHA256;\n   }\n   else if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA384))\n   {\n      session->ticketHashAlgo = TLS_HASH_ALGO_SHA384;\n   }\n   else\n   {\n      session->ticketHashAlgo = TLS_HASH_ALGO_NONE;\n   }\n\n   \n   osMemcpy(session->secret, context->ticketPsk, hashAlgo->digestSize);\n\n#if (TLS_ALPN_SUPPORT == ENABLED)\n   \n   if(context->selectedProtocol != NULL)\n   {\n      size_t n;\n\n      \n      n = osStrlen(context->selectedProtocol);\n\n      \n      session->ticketAlpn = tlsAllocMem(n + 1);\n      \n      if(session->ticketAlpn == NULL)\n         return ERROR_OUT_OF_MEMORY;\n\n      \n      osStrcpy(session->ticketAlpn, context->selectedProtocol);\n   }\n#endif\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tls13RestoreSessionTicket(TlsContext *context,\n   const TlsSessionState *session)\n{\n   systime_t serverTicketAge;\n\n   \n   if(session->version != TLS_VERSION_1_3)\n      return ERROR_INVALID_VERSION;\n\n   \n   if(session->ticket == NULL || session->ticketLen == 0)\n      return ERROR_INVALID_TICKET;\n\n   \n   if(session->cipherSuite == 0 ||\n      session->ticketHashAlgo == TLS_HASH_ALGO_NONE)\n   {\n      return ERROR_INVALID_SESSION;\n   }\n\n   \n   serverTicketAge = osGetSystemTime() - session->ticketTimestamp;\n\n   \n   if(serverTicketAge >= (session->ticketLifetime * 1000))\n      return ERROR_TICKET_EXPIRED;\n\n   \n   context->version = session->version;\n   context->ticketCipherSuite = session->cipherSuite;\n   context->ticketHashAlgo = session->ticketHashAlgo;\n   context->ticketTimestamp = session->ticketTimestamp;\n   context->ticketLifetime = session->ticketLifetime;\n   context->ticketAgeAdd = session->ticketAgeAdd;\n   context->maxEarlyDataSize = session->maxEarlyDataSize;\n   context->sessionIdLen = 0;\n\n   \n   if(context->ticket != NULL)\n   {\n      osMemset(context->ticket, 0, context->ticketLen);\n      tlsFreeMem(context->ticket);\n      context->ticket = NULL;\n      context->ticketLen = 0;\n   }\n\n   \n   context->ticket = tlsAllocMem(session->ticketLen);\n   \n   if(context->ticket == NULL)\n      return ERROR_OUT_OF_MEMORY;\n\n   \n   osMemcpy(context->ticket, session->ticket, session->ticketLen);\n   context->ticketLen = session->ticketLen;\n\n   \n   \n   if(session->ticketHashAlgo == TLS_HASH_ALGO_SHA256)\n   {\n      context->ticketPskLen = SHA256_DIGEST_SIZE;\n   }\n   else if(session->ticketHashAlgo == TLS_HASH_ALGO_SHA384)\n   {\n      context->ticketPskLen = SHA384_DIGEST_SIZE;\n   }\n   else\n   {\n      context->ticketPskLen = 0;\n   }\n\n   \n   osMemcpy(context->ticketPsk, session->secret, context->ticketPskLen);\n\n#if (TLS_ALPN_SUPPORT == ENABLED)\n   \n   if(context->ticketAlpn != NULL)\n   {\n      tlsFreeMem(context->ticketAlpn);\n      context->ticketAlpn = NULL;\n   }\n\n   \n   if(session->ticketAlpn != NULL)\n   {\n      size_t n;\n\n      \n      n = osStrlen(session->ticketAlpn);\n\n      \n      context->ticketAlpn = tlsAllocMem(n + 1);\n      \n      if(context->ticketAlpn == NULL)\n         return ERROR_OUT_OF_MEMORY;\n\n      \n      osStrcpy(context->ticketAlpn, session->ticketAlpn);\n   }\n#endif\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tls13GenerateTicket(TlsContext *context,\n   const Tls13NewSessionTicket *message, uint8_t *ticket, size_t *length)\n{\n#if (TLS_TICKET_SUPPORT == ENABLED)\n   error_t error;\n   size_t n;\n   Tls13PlaintextSessionState *state;\n   const HashAlgo *hashAlgo;\n\n   \n   state = (Tls13PlaintextSessionState *) ticket;\n\n   \n   state->version = context->version;\n   state->cipherSuite = context->cipherSuite.identifier;\n   state->ticketTimestamp = osGetSystemTime();\n   state->ticketLifetime = ntohl(message->ticketLifetime);\n   state->ticketAgeAdd = ntohl(message->ticketAgeAdd);\n   osMemcpy(state->ticketNonce, message->ticketNonce, message->ticketNonceLen);\n   osMemset(state->ticketPsk, 0, TLS_MAX_HKDF_DIGEST_SIZE);\n\n   \n   hashAlgo = context->cipherSuite.prfHashAlgo;\n   \n   if(hashAlgo == NULL)\n      return ERROR_FAILURE;\n\n   \n   error = tls13HkdfExpandLabel(hashAlgo, context->resumptionMasterSecret,\n      hashAlgo->digestSize, \"resumption\", message->ticketNonce,\n      message->ticketNonceLen, state->ticketPsk, hashAlgo->digestSize);\n   \n   if(error)\n      return error;\n\n   \n   state->ticketPskLen = hashAlgo->digestSize;\n\n   \n   n = sizeof(Tls13PlaintextSessionState);\n\n   \n   if(context->ticketEncryptCallback == NULL)\n      return ERROR_FAILURE;\n\n   \n   error = context->ticketEncryptCallback(context, (uint8_t *) state, n,\n      ticket, length, context->ticketParam);\n   \n   if(error)\n      return error;\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t tls13VerifyTicket(TlsContext *context, const uint8_t *ticket,\n   size_t length, uint32_t obfuscatedTicketAge)\n{\n#if (TLS_TICKET_SUPPORT == ENABLED)\n   error_t error;\n   systime_t serverTicketAge;\n   Tls13PlaintextSessionState *state;\n   const HashAlgo *hashAlgo;\n#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)\n   systime_t delta;\n   systime_t clientTicketAge;\n#endif\n\n   \n   if(context->ticketDecryptCallback == NULL)\n      return ERROR_DECRYPTION_FAILED;\n\n   \n   if(length == 0)\n      return ERROR_DECRYPTION_FAILED;\n\n   \n   state = tlsAllocMem(length);\n   \n   if(state == NULL)\n      return ERROR_OUT_OF_MEMORY;\n\n   \n   do\n   {\n      \n      error = context->ticketDecryptCallback(context, ticket, length,\n         (uint8_t *) state, &length, context->ticketParam);\n      \n      if(error)\n         break;\n\n      \n      if(length != sizeof(Tls13PlaintextSessionState))\n      {\n         \n         error = ERROR_INVALID_TICKET;\n         break;\n      }\n\n      \n      if(state->version != TLS_VERSION_1_3)\n      {\n         \n         error = ERROR_INVALID_TICKET;\n         break;\n      }\n\n      \n      serverTicketAge = osGetSystemTime() - state->ticketTimestamp;\n\n      \n      if(serverTicketAge >= (state->ticketLifetime * 1000))\n      {\n         \n         error = ERROR_INVALID_TICKET;\n         break;\n      }\n\n#if (TLS13_EARLY_DATA_SUPPORT == ENABLED)\n      \n      \n      clientTicketAge = obfuscatedTicketAge - state->ticketAgeAdd;\n\n      \n      \n      if(clientTicketAge < serverTicketAge)\n      {\n         delta = serverTicketAge - clientTicketAge;\n      }\n      else\n      {\n         delta = clientTicketAge - serverTicketAge;\n      }\n\n      \n      \n      \n      if(delta >= TLS13_TICKET_AGE_TOLERANCE)\n      {\n         \n         \n         \n         context->earlyDataRejected = TRUE;\n      }\n#endif\n\n      \n      \n      error = tlsSelectCipherSuite(context, state->cipherSuite);\n      \n      if(error)\n         break;\n\n      \n      hashAlgo = context->cipherSuite.prfHashAlgo;\n      \n      if(hashAlgo == NULL)\n      {\n         \n         error = ERROR_INVALID_TICKET;\n         break;\n      }\n\n      \n      if(state->ticketPskLen != hashAlgo->digestSize)\n      {\n         \n         error = ERROR_INVALID_TICKET;\n         break;\n      }\n\n      \n      osMemcpy(context->ticketPsk, state->ticketPsk, state->ticketPskLen);\n      context->ticketPskLen = state->ticketPskLen;\n\n      \n      if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA256))\n      {\n         context->ticketHashAlgo = TLS_HASH_ALGO_SHA256;\n      }\n      else if(hashAlgo == tlsGetHashAlgo(TLS_HASH_ALGO_SHA384))\n      {\n         context->ticketHashAlgo = TLS_HASH_ALGO_SHA384;\n      }\n      else\n      {\n         context->ticketHashAlgo = TLS_HASH_ALGO_NONE;\n      }\n\n      \n   } while(0);\n\n   \n   osMemset(state, 0, length);\n   tlsFreeMem(state);\n\n   \n   return error;\n#else\n   \n   return ERROR_DECRYPTION_FAILED;\n#endif\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_cache.h\"\n#include \"tls_misc.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED)\n\n\n\n\nTlsCache *tlsInitCache(uint_t size)\n{\n   size_t n;\n   TlsCache *cache;\n\n   \n   if(size < 1)\n      return NULL;\n\n   \n   n = sizeof(TlsCache) + size * sizeof(TlsSessionState);\n\n   \n   cache = tlsAllocMem(n);\n   \n   if(cache == NULL)\n      return NULL;\n\n   \n   osMemset(cache, 0, n);\n\n   \n   if(!osCreateMutex(&cache->mutex))\n   {\n      \n      tlsFreeMem(cache);\n      \n      return NULL;\n   }\n\n   \n   cache->size = size;\n\n   \n   return cache;\n}\n\n\n\n\nTlsSessionState *tlsFindCache(TlsCache *cache, const uint8_t *sessionId,\n   size_t sessionIdLen)\n{\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   uint_t i;\n   systime_t time;\n   TlsSessionState *session;\n\n   \n   if(cache == NULL || sessionId == NULL || sessionIdLen == 0)\n      return NULL;\n\n   \n   session = NULL;\n\n   \n   time = osGetSystemTime();\n\n   \n   osAcquireMutex(&cache->mutex);\n\n   \n   for(i = 0; i < cache->size; i++)\n   {\n      \n      if(cache->sessions[i].sessionIdLen != 0)\n      {\n         \n         if((time - cache->sessions[i].timestamp) >= TLS_SESSION_CACHE_LIFETIME)\n         {\n            \n            tlsFreeSessionState(&cache->sessions[i]);\n         }\n      }\n   }\n\n   \n   for(i = 0; i < cache->size; i++)\n   {\n      \n      if(cache->sessions[i].sessionIdLen == sessionIdLen &&\n         !osMemcmp(cache->sessions[i].sessionId, sessionId, sessionIdLen))\n      {\n         \n         session = &cache->sessions[i];\n         break;\n      }\n   }\n\n   \n   osReleaseMutex(&cache->mutex);\n\n   \n   return session;\n#else\n   \n   return NULL;\n#endif\n}\n\n\n\n\nerror_t tlsSaveToCache(TlsContext *context)\n{\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   error_t error;\n   uint_t i;\n   systime_t time;\n   TlsSessionState *session;\n   TlsSessionState *firstFreeEntry;\n   TlsSessionState *oldestEntry;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(context->cache == NULL)\n      return ERROR_FAILURE;\n\n   \n   if(context->sessionIdLen == 0)\n      return NO_ERROR;\n\n   \n   osAcquireMutex(&context->cache->mutex);\n\n   \n   time = osGetSystemTime();\n\n   \n   firstFreeEntry = NULL;\n   \n   oldestEntry = NULL;\n\n   \n   for(i = 0; i < context->cache->size; i++)\n   {\n      \n      session = &context->cache->sessions[i];\n\n      \n      if(session->sessionIdLen == context->sessionIdLen &&\n         !osMemcmp(session->sessionId, context->sessionId, session->sessionIdLen))\n      {\n         \n         firstFreeEntry = NULL;\n         oldestEntry = NULL;\n         \n         break;\n      }\n\n      \n      if(session->sessionIdLen == 0)\n      {\n         \n         if(!firstFreeEntry)\n         {\n            firstFreeEntry = session;\n         }\n      }\n      else\n      {\n         \n         if(oldestEntry == NULL)\n         {\n            oldestEntry = session;\n         }\n         else if((time - session->timestamp) > (time - oldestEntry->timestamp))\n         {\n            oldestEntry = session;\n         }\n      }\n   }\n\n   \n   if(firstFreeEntry != NULL)\n   {\n      error = tlsSaveSessionId(context, firstFreeEntry);\n   }\n   else if(oldestEntry != NULL)\n   {\n      error = tlsSaveSessionId(context, oldestEntry);\n   }\n   else\n   {\n      error = NO_ERROR;\n   }\n\n   \n   osReleaseMutex(&context->cache->mutex);\n\n   \n   return error;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t tlsRemoveFromCache(TlsContext *context)\n{\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   uint_t i;\n   TlsSessionState *session;\n\n   \n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(context->cache == NULL)\n      return ERROR_FAILURE;\n\n   \n   if(context->sessionIdLen == 0)\n      return NO_ERROR;\n\n   \n   osAcquireMutex(&context->cache->mutex);\n\n   \n   for(i = 0; i < context->cache->size; i++)\n   {\n      \n      session = &context->cache->sessions[i];\n\n      \n      if(session->sessionIdLen == context->sessionIdLen &&\n         !osMemcmp(session->sessionId, context->sessionId, session->sessionIdLen))\n      {\n         \n         tlsFreeSessionState(session);\n      }\n   }\n\n   \n   osReleaseMutex(&context->cache->mutex);\n#endif\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid tlsFreeCache(TlsCache *cache)\n{\n   uint_t i;\n\n   \n   if(cache != NULL)\n   {\n      \n      for(i = 0; i < cache->size; i++)\n      {\n         \n         tlsFreeSessionState(&cache->sessions[i]);\n      }\n\n      \n      osDeleteMutex(&cache->mutex);\n\n      \n      tlsFreeMem(cache);\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include \"tls.h\"\n#include \"tls_handshake.h\"\n#include \"tls_client.h\"\n#include \"tls_client_fsm.h\"\n#include \"tls_common.h\"\n#include \"tls_record.h\"\n#include \"tls_misc.h\"\n#include \"tls13_client.h\"\n#include \"tls13_client_misc.h\"\n#include \"tls13_common.h\"\n#include \"tls13_key_material.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_CLIENT_SUPPORT == ENABLED)\n\n\n\n\nerror_t tlsPerformClientHandshake(TlsContext *context)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)\n      {\n         \n         if(context->state != TLS_STATE_INIT &&\n            context->state != TLS_STATE_CLOSED)\n         {\n            \n            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);\n            \n            if(error)\n               break;\n         }\n      }\n\n      \n      if(context->state == TLS_STATE_APPLICATION_DATA)\n      {\n         \n         \n         break;\n      }\n\n      \n      \n      switch(context->state)\n      {\n      \n      case TLS_STATE_INIT:\n         \n         error = tlsInitHandshake(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_HELLO:\n      case TLS_STATE_CLIENT_HELLO_2:\n         \n         \n         error = tlsSendClientHello(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_CERTIFICATE:\n         \n         \n         \n         error = tlsSendCertificate(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_CERTIFICATE_VERIFY:\n         \n         \n         \n         \n         error = tlsSendCertificateVerify(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC:\n      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC_2:\n         \n         \n         \n         error = tlsSendChangeCipherSpec(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_FINISHED:\n         \n         \n         \n         error = tlsSendFinished(context);\n         break;\n\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n      \n      case TLS_STATE_CLIENT_KEY_EXCHANGE:\n         \n         \n         \n         \n         error = tlsSendClientKeyExchange(context);\n         break;\n#endif\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n      \n      case TLS_STATE_END_OF_EARLY_DATA:\n         \n         \n         \n         error = tls13SendEndOfEarlyData(context);\n         break;\n\n      \n      case TLS_STATE_HANDSHAKE_TRAFFIC_KEYS:\n         \n         error = tls13GenerateHandshakeTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_APP_TRAFFIC_KEYS:\n         \n         error = tls13GenerateServerAppTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_APP_TRAFFIC_KEYS:\n         \n         error = tls13GenerateClientAppTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_KEY_UPDATE:\n         \n         \n         error = tls13SendKeyUpdate(context);\n         break;\n#endif\n\n      \n      case TLS_STATE_SERVER_HELLO:\n      case TLS_STATE_SERVER_HELLO_2:\n      case TLS_STATE_SERVER_HELLO_3:\n      case TLS_STATE_ENCRYPTED_EXTENSIONS:\n      case TLS_STATE_SERVER_CERTIFICATE:\n      case TLS_STATE_SERVER_KEY_EXCHANGE:\n      case TLS_STATE_SERVER_CERTIFICATE_VERIFY:\n      case TLS_STATE_CERTIFICATE_REQUEST:\n      case TLS_STATE_SERVER_HELLO_DONE:\n      case TLS_STATE_NEW_SESSION_TICKET:\n      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC:\n      case TLS_STATE_SERVER_FINISHED:\n         \n         error = tlsReceiveHandshakeMessage(context);\n         break;\n\n      \n      case TLS_STATE_CLOSING:\n         \n         context->state = TLS_STATE_CLOSED;\n         break;\n\n      \n      case TLS_STATE_CLOSED:\n         \n         TRACE_WARNING(\"TLS handshake failure!\\r\\n\");\n         \n         error = ERROR_HANDSHAKE_FAILED;\n         break;\n\n      \n      default:\n         \n         error = ERROR_UNEXPECTED_STATE;\n         break;\n      }\n   }\n\n   \n   if(error)\n   {\n      \n      tlsProcessError(context, error);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsParseServerHandshakeMessage(TlsContext *context, uint8_t msgType,\n   const void *message, size_t length)\n{\n   error_t error;\n\n   \n   switch(msgType)\n   {\n   \n   case TLS_TYPE_HELLO_REQUEST:\n      \n      \n      error = tlsParseHelloRequest(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_SERVER_HELLO:\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n      \n      \n      \n      if(tls13IsHelloRetryRequest(message, length))\n      {\n         \n         \n         \n         error = tls13ParseHelloRetryRequest(context, message, length);\n      }\n      else\n#endif\n      {\n         \n         \n         error = tlsParseServerHello(context, message, length);\n      }\n\n      break;\n\n   \n   case TLS_TYPE_CERTIFICATE:\n      \n      \n      \n      error = tlsParseCertificate(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_CERTIFICATE_REQUEST:\n      \n      \n      \n      error = tlsParseCertificateRequest(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_NEW_SESSION_TICKET:\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n      \n      if(context->version == TLS_VERSION_1_3)\n      {\n         \n         \n         error = tls13ParseNewSessionTicket(context, message, length);\n      }\n      else\n#endif\n      {\n         \n         \n         error = tlsParseNewSessionTicket(context, message, length);\n      }\n\n      break;\n\n   \n   case TLS_TYPE_FINISHED:\n      \n      \n      \n      error = tlsParseFinished(context, message, length);\n      break;\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   case TLS_TYPE_HELLO_VERIFY_REQUEST:\n      \n      \n      error = dtlsParseHelloVerifyRequest(context, message, length);\n      break;\n#endif\n\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   \n   case TLS_TYPE_SERVER_KEY_EXCHANGE:\n      \n      \n      \n      error = tlsParseServerKeyExchange(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_SERVER_HELLO_DONE:\n      \n      \n      error = tlsParseServerHelloDone(context, message, length);\n      break;\n#endif\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n   \n   case TLS_TYPE_ENCRYPTED_EXTENSIONS:\n      \n      \n      \n      error = tls13ParseEncryptedExtensions(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_CERTIFICATE_VERIFY:\n      \n      \n      \n      error = tlsParseCertificateVerify(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_KEY_UPDATE:\n      \n      \n      \n      error = tls13ParseKeyUpdate(context, message, length);\n      break;\n#endif\n\n   \n   default:\n      \n      error = ERROR_UNEXPECTED_MESSAGE;\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_ffdhe.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_FFDHE_SUPPORT == ENABLED)\n\n#if (TLS_FFDHE2048_SUPPORT == ENABLED)\n\n\n\nconst TlsFfdheGroup ffdhe2048Group =\n{\n   \n   \"ffdhe2048\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,\n    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,\n    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,\n    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,\n    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,\n    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,\n    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,\n    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,\n    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,\n    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,\n    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,\n    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,\n    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,\n    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,\n    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,\n    0x88, 0x6B, 0x42, 0x38, 0x61, 0x28, 0x5C, 0x97, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   256,\n   \n   2\n};\n\n#endif\n#if (TLS_FFDHE3072_SUPPORT == ENABLED)\n\n\n\nconst TlsFfdheGroup ffdhe3072Group =\n{\n   \n   \"ffdhe3072\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,\n    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,\n    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,\n    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,\n    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,\n    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,\n    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,\n    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,\n    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,\n    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,\n    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,\n    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,\n    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,\n    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,\n    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,\n    0x88, 0x6B, 0x42, 0x38, 0x61, 0x1F, 0xCF, 0xDC, 0xDE, 0x35, 0x5B, 0x3B, 0x65, 0x19, 0x03, 0x5B,\n    0xBC, 0x34, 0xF4, 0xDE, 0xF9, 0x9C, 0x02, 0x38, 0x61, 0xB4, 0x6F, 0xC9, 0xD6, 0xE6, 0xC9, 0x07,\n    0x7A, 0xD9, 0x1D, 0x26, 0x91, 0xF7, 0xF7, 0xEE, 0x59, 0x8C, 0xB0, 0xFA, 0xC1, 0x86, 0xD9, 0x1C,\n    0xAE, 0xFE, 0x13, 0x09, 0x85, 0x13, 0x92, 0x70, 0xB4, 0x13, 0x0C, 0x93, 0xBC, 0x43, 0x79, 0x44,\n    0xF4, 0xFD, 0x44, 0x52, 0xE2, 0xD7, 0x4D, 0xD3, 0x64, 0xF2, 0xE2, 0x1E, 0x71, 0xF5, 0x4B, 0xFF,\n    0x5C, 0xAE, 0x82, 0xAB, 0x9C, 0x9D, 0xF6, 0x9E, 0xE8, 0x6D, 0x2B, 0xC5, 0x22, 0x36, 0x3A, 0x0D,\n    0xAB, 0xC5, 0x21, 0x97, 0x9B, 0x0D, 0xEA, 0xDA, 0x1D, 0xBF, 0x9A, 0x42, 0xD5, 0xC4, 0x48, 0x4E,\n    0x0A, 0xBC, 0xD0, 0x6B, 0xFA, 0x53, 0xDD, 0xEF, 0x3C, 0x1B, 0x20, 0xEE, 0x3F, 0xD5, 0x9D, 0x7C,\n    0x25, 0xE4, 0x1D, 0x2B, 0x66, 0xC6, 0x2E, 0x37, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   384,\n   \n   2\n};\n\n#endif\n#if (TLS_FFDHE4096_SUPPORT == ENABLED)\n\n\n\nconst TlsFfdheGroup ffdhe4096Group =\n{\n   \n   \"ffdhe4096\",\n   \n   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,\n    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95,\n    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,\n    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,\n    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0,\n    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35,\n    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72,\n    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A,\n    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,\n    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4,\n    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70,\n    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61,\n    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83,\n    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,\n    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA,\n    0x88, 0x6B, 0x42, 0x38, 0x61, 0x1F, 0xCF, 0xDC, 0xDE, 0x35, 0x5B, 0x3B, 0x65, 0x19, 0x03, 0x5B,\n    0xBC, 0x34, 0xF4, 0xDE, 0xF9, 0x9C, 0x02, 0x38, 0x61, 0xB4, 0x6F, 0xC9, 0xD6, 0xE6, 0xC9, 0x07,\n    0x7A, 0xD9, 0x1D, 0x26, 0x91, 0xF7, 0xF7, 0xEE, 0x59, 0x8C, 0xB0, 0xFA, 0xC1, 0x86, 0xD9, 0x1C,\n    0xAE, 0xFE, 0x13, 0x09, 0x85, 0x13, 0x92, 0x70, 0xB4, 0x13, 0x0C, 0x93, 0xBC, 0x43, 0x79, 0x44,\n    0xF4, 0xFD, 0x44, 0x52, 0xE2, 0xD7, 0x4D, 0xD3, 0x64, 0xF2, 0xE2, 0x1E, 0x71, 0xF5, 0x4B, 0xFF,\n    0x5C, 0xAE, 0x82, 0xAB, 0x9C, 0x9D, 0xF6, 0x9E, 0xE8, 0x6D, 0x2B, 0xC5, 0x22, 0x36, 0x3A, 0x0D,\n    0xAB, 0xC5, 0x21, 0x97, 0x9B, 0x0D, 0xEA, 0xDA, 0x1D, 0xBF, 0x9A, 0x42, 0xD5, 0xC4, 0x48, 0x4E,\n    0x0A, 0xBC, 0xD0, 0x6B, 0xFA, 0x53, 0xDD, 0xEF, 0x3C, 0x1B, 0x20, 0xEE, 0x3F, 0xD5, 0x9D, 0x7C,\n    0x25, 0xE4, 0x1D, 0x2B, 0x66, 0x9E, 0x1E, 0xF1, 0x6E, 0x6F, 0x52, 0xC3, 0x16, 0x4D, 0xF4, 0xFB,\n    0x79, 0x30, 0xE9, 0xE4, 0xE5, 0x88, 0x57, 0xB6, 0xAC, 0x7D, 0x5F, 0x42, 0xD6, 0x9F, 0x6D, 0x18,\n    0x77, 0x63, 0xCF, 0x1D, 0x55, 0x03, 0x40, 0x04, 0x87, 0xF5, 0x5B, 0xA5, 0x7E, 0x31, 0xCC, 0x7A,\n    0x71, 0x35, 0xC8, 0x86, 0xEF, 0xB4, 0x31, 0x8A, 0xED, 0x6A, 0x1E, 0x01, 0x2D, 0x9E, 0x68, 0x32,\n    0xA9, 0x07, 0x60, 0x0A, 0x91, 0x81, 0x30, 0xC4, 0x6D, 0xC7, 0x78, 0xF9, 0x71, 0xAD, 0x00, 0x38,\n    0x09, 0x29, 0x99, 0xA3, 0x33, 0xCB, 0x8B, 0x7A, 0x1A, 0x1D, 0xB9, 0x3D, 0x71, 0x40, 0x00, 0x3C,\n    0x2A, 0x4E, 0xCE, 0xA9, 0xF9, 0x8D, 0x0A, 0xCC, 0x0A, 0x82, 0x91, 0xCD, 0xCE, 0xC9, 0x7D, 0xCF,\n    0x8E, 0xC9, 0xB5, 0x5A, 0x7F, 0x88, 0xA4, 0x6B, 0x4D, 0xB5, 0xA8, 0x51, 0xF4, 0x41, 0x82, 0xE1,\n    0xC6, 0x8A, 0x00, 0x7E, 0x5E, 0x65, 0x5F, 0x6A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\n   512,\n   \n   2\n};\n\n#endif\n\n\n\n\nerror_t tlsSelectFfdheGroup(TlsContext *context,\n   const TlsSupportedGroupList *groupList)\n{\n   error_t error;\n   uint_t i;\n   uint_t j;\n   uint_t n;\n   uint16_t namedGroup;\n   bool_t ffdheGroupFound;\n\n   \n   error = ERROR_HANDSHAKE_FAILED;\n\n   \n   ffdheGroupFound = FALSE;\n\n   \n   context->namedGroup = TLS_GROUP_NONE;\n\n   \n   if(groupList != NULL)\n   {\n      \n      n = ntohs(groupList->length) \/ sizeof(uint16_t);\n\n      \n      if(context->numSupportedGroups > 0)\n      {\n         \n         for(i = 0; i < context->numSupportedGroups; i++)\n         {\n            \n            for(j = 0; j < n; j++)\n            {\n               \n               namedGroup = ntohs(groupList->value[j]);\n\n               \n               \n               if(namedGroup >= TLS_GROUP_FFDHE2048 &&\n                  namedGroup <= TLS_GROUP_FFDHE_MAX)\n               {\n                  \n                  ffdheGroupFound = TRUE;\n               }\n\n               \n               \n               if(context->supportedGroups[i] == namedGroup)\n               {\n                  \n                  if(tlsGetFfdheGroup(context, namedGroup) != NULL)\n                  {\n                     \n                     if(context->namedGroup == TLS_GROUP_NONE)\n                     {\n                        context->namedGroup = namedGroup;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      else\n      {\n         \n         \n         for(j = 0; j < n; j++)\n         {\n            \n            namedGroup = ntohs(groupList->value[j]);\n\n            \n            \n            if(namedGroup >= TLS_GROUP_FFDHE2048 &&\n               namedGroup <= TLS_GROUP_FFDHE_MAX)\n            {\n               \n               ffdheGroupFound = TRUE;\n            }\n\n            \n            if(tlsGetFfdheGroup(context, namedGroup) != NULL)\n            {\n               \n               if(context->namedGroup == TLS_GROUP_NONE)\n               {\n                  context->namedGroup = namedGroup;\n               }\n            }\n         }\n      }\n   }\n\n   \n   \n   \n   if(!ffdheGroupFound)\n   {\n      \n      if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE2048) != NULL)\n      {\n         \n         context->namedGroup = TLS_GROUP_FFDHE2048;\n      }\n      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE3072) != NULL)\n      {\n         \n         context->namedGroup = TLS_GROUP_FFDHE3072;\n      }\n      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE4096) != NULL)\n      {\n         \n         context->namedGroup = TLS_GROUP_FFDHE4096;\n      }\n      else\n      {\n         \n         context->namedGroup = TLS_GROUP_NONE;\n      }\n   }\n\n   \n   if(context->namedGroup != TLS_GROUP_NONE)\n   {\n      error = NO_ERROR;\n   }\n\n   \n   return error;\n}\n\n\n\n\nconst TlsFfdheGroup *tlsGetFfdheGroup(TlsContext *context, uint16_t namedGroup)\n{\n   uint_t i;\n   const TlsFfdheGroup *ffdheGroup;\n\n   \n   switch(namedGroup)\n   {\n#if (TLS_FFDHE2048_SUPPORT == ENABLED)\n   \n   case TLS_GROUP_FFDHE2048:\n      ffdheGroup = &ffdhe2048Group;\n      break;\n#endif\n#if (TLS_FFDHE3072_SUPPORT == ENABLED)\n   \n   case TLS_GROUP_FFDHE3072:\n      ffdheGroup = &ffdhe3072Group;\n      break;\n#endif\n#if (TLS_FFDHE4096_SUPPORT == ENABLED)\n   \n   case TLS_GROUP_FFDHE4096:\n      ffdheGroup = &ffdhe4096Group;\n      break;\n#endif\n   \n   default:\n      ffdheGroup = NULL;\n      break;\n   }\n\n   \n   if(context->numSupportedGroups > 0)\n   {\n      \n      for(i = 0; i < context->numSupportedGroups; i++)\n      {\n         \n         if(context->supportedGroups[i] == namedGroup)\n            break;\n      }\n\n      \n      if(i >= context->numSupportedGroups)\n         ffdheGroup = NULL;\n   }\n\n   \n   return ffdheGroup;\n}\n\n\n\n\nerror_t tlsLoadFfdheParameters(DhParameters *params,\n   const TlsFfdheGroup *ffdheGroup)\n{\n   error_t error;\n\n   \n   if(ffdheGroup != NULL)\n   {\n      \n      error = mpiImport(&params->p, ffdheGroup->p, ffdheGroup->pLen,\n         MPI_FORMAT_BIG_ENDIAN);\n\n      \n      if(!error)\n      {\n         \n         error = mpiSetValue(&params->g, ffdheGroup->g);\n      }\n   }\n   else\n   {\n      \n      error = ERROR_FAILURE;\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include \"tls.h\"\n#include \"tls_handshake.h\"\n#include \"tls_client_fsm.h\"\n#include \"tls_server_fsm.h\"\n#include \"tls_common.h\"\n#include \"tls_transcript_hash.h\"\n#include \"tls_record.h\"\n#include \"tls13_server_misc.h\"\n#include \"dtls_record.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED)\n\n\n\n\nerror_t tlsInitHandshake(TlsContext *context)\n{\n   \n   if(context->txBuffer == NULL)\n   {\n      \n      context->txBuffer = tlsAllocMem(context->txBufferSize);\n\n      \n      if(context->txBuffer == NULL)\n         return ERROR_OUT_OF_MEMORY;\n\n      \n      osMemset(context->txBuffer, 0, context->txBufferSize);\n   }\n\n   \n   if(context->rxBuffer == NULL)\n   {\n      \n      context->rxBuffer = tlsAllocMem(context->rxBufferSize);\n\n      \n      if(context->rxBuffer == NULL)\n         return ERROR_OUT_OF_MEMORY;\n\n      \n      osMemset(context->rxBuffer, 0, context->rxBufferSize);\n   }\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n   \n   if(context->entity == TLS_CONNECTION_END_SERVER)\n   {\n      \n      context->earlyDataRejected = TRUE;\n   }\n#endif\n\n   \n   \n   context->state = TLS_STATE_CLIENT_HELLO;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tlsPerformHandshake(TlsContext *context)\n{\n   error_t error;\n\n#if (TLS_CLIENT_SUPPORT == ENABLED)\n   \n   if(context->entity == TLS_CONNECTION_END_CLIENT)\n   {\n      \n      error = tlsPerformClientHandshake(context);\n   }\n   else\n#endif\n#if (TLS_SERVER_SUPPORT == ENABLED)\n   \n   if(context->entity == TLS_CONNECTION_END_SERVER)\n   {\n      \n      error = tlsPerformServerHandshake(context);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_INVALID_PARAMETER;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsSendHandshakeMessage(TlsContext *context, const void *data,\n   size_t length, TlsMessageType type)\n{\n   error_t error;\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)\n   {\n      DtlsHandshake *message;\n\n      \n      message = (DtlsHandshake *) data;\n\n      \n      osMemmove(message->data, data, length);\n\n      \n      message->msgType = type;\n      \n      STORE24BE(length, message->length);\n      \n      message->msgSeq = htons(context->txMsgSeq);\n      \n      STORE24BE(0, message->fragOffset);\n      \n      STORE24BE(length, message->fragLength);\n\n      \n      \n      context->txMsgSeq++;\n\n      \n      length += sizeof(DtlsHandshake);\n   }\n   else\n#endif\n   \n   {\n      TlsHandshake *message;\n\n      \n      message = (TlsHandshake *) data;\n\n      \n      osMemmove(message->data, data, length);\n\n      \n      message->msgType = type;\n      \n      STORE24BE(length, message->length);\n\n      \n      length += sizeof(TlsHandshake);\n   }\n\n   \n   \n   \n   if(type != TLS_TYPE_HELLO_REQUEST)\n   {\n      tlsUpdateTranscriptHash(context, data, length);\n   }\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)\n   {\n      \n      error = dtlsWriteProtocolData(context, data, length, TLS_TYPE_HANDSHAKE);\n   }\n   else\n#endif\n   \n   {\n      \n      error = tlsWriteProtocolData(context, data, length, TLS_TYPE_HANDSHAKE);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsReceiveHandshakeMessage(TlsContext *context)\n{\n   error_t error;\n   size_t length;\n   uint8_t *data;\n   TlsContentType contentType;\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)\n   {\n      \n      error = dtlsReadProtocolData(context, &data, &length, &contentType);\n   }\n   else\n#endif\n   \n   {\n      \n      error = tlsReadProtocolData(context, &data, &length, &contentType);\n   }\n\n   \n   if(!error)\n   {\n      \n      context->rxBufferPos += length;\n      \n      context->rxBufferLen -= length;\n\n      \n      if(contentType == TLS_TYPE_HANDSHAKE)\n      {\n         \n         error = tlsParseHandshakeMessage(context, data, length);\n      }\n      \n      else if(contentType == TLS_TYPE_CHANGE_CIPHER_SPEC)\n      {\n         \n         \n         \n         error = tlsParseChangeCipherSpec(context, (TlsChangeCipherSpec *) data,\n            length);\n      }\n      \n      else if(contentType == TLS_TYPE_ALERT)\n      {\n         \n         error = tlsParseAlert(context, (TlsAlert *) data, length);\n      }\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n      \n      else if(contentType == TLS_TYPE_APPLICATION_DATA)\n      {\n#if (TLS_SERVER_SUPPORT == ENABLED)\n         \n         if(context->entity == TLS_CONNECTION_END_SERVER)\n         {\n            \n            error = tls13ProcessEarlyData(context, data, length);\n         }\n         else\n#endif\n         {\n            \n            \n            error = ERROR_UNEXPECTED_MESSAGE;\n         }\n      }\n#endif\n      \n      else\n      {\n         \n         error = ERROR_UNEXPECTED_MESSAGE;\n      }\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsParseHandshakeMessage(TlsContext *context, const uint8_t *message,\n   size_t length)\n{\n   error_t error;\n   uint8_t msgType;\n   size_t n;\n   const void *p;\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)\n   {\n      \n      msgType = ((DtlsHandshake *) message)->msgType;\n      \n      p = message + sizeof(DtlsHandshake);\n      \n      n = length - sizeof(DtlsHandshake);\n   }\n   else\n#endif\n   \n   {\n      \n      msgType = ((TlsHandshake *) message)->msgType;\n      \n      p = message + sizeof(TlsHandshake);\n      \n      n = length - sizeof(TlsHandshake);\n   }\n\n#if (TLS_MAX_KEY_UPDATE_MESSAGES > 0)\n   \n   if(msgType != TLS_TYPE_KEY_UPDATE)\n      context->keyUpdateCount = 0;\n#endif\n\n#if (TLS_CLIENT_SUPPORT == ENABLED)\n   \n   if(context->entity == TLS_CONNECTION_END_CLIENT)\n   {\n      \n      error = tlsParseServerHandshakeMessage(context, msgType, p, n);\n\n      \n      tlsUpdateTranscriptHash(context, message, length);\n   }\n   else\n#endif\n#if (TLS_SERVER_SUPPORT == ENABLED)\n   \n   if(context->entity == TLS_CONNECTION_END_SERVER)\n   {\n      \n      if(msgType == TLS_TYPE_CLIENT_KEY_EXCHANGE)\n      {\n         tlsUpdateTranscriptHash(context, message, length);\n      }\n\n      \n      error = tlsParseClientHandshakeMessage(context, msgType, p, n);\n\n      \n      if(msgType != TLS_TYPE_CLIENT_KEY_EXCHANGE)\n      {\n         tlsUpdateTranscriptHash(context, message, length);\n      }\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_FAILURE;\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_record.h\"\n#include \"tls_record_encryption.h\"\n#include \"tls_misc.h\"\n#include \"ssl_misc.h\"\n#include \"cipher_mode\/cbc.h\"\n#include \"aead\/ccm.h\"\n#include \"aead\/gcm.h\"\n#include \"aead\/chacha20_poly1305.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED)\n\n\n\n\nerror_t tlsEncryptRecord(TlsContext *context,\n   TlsEncryptionEngine *encryptionEngine, void *record)\n{\n   error_t error;\n\n#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED || \\\n   TLS_GCM_CIPHER_SUPPORT == ENABLED || TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_CCM ||\n      encryptionEngine->cipherMode == CIPHER_MODE_GCM ||\n      encryptionEngine->cipherMode == CIPHER_MODE_CHACHA20_POLY1305)\n   {\n      \n      error = tlsEncryptAeadRecord(context, encryptionEngine, record);\n   }\n   else\n#endif\n#if (TLS_CBC_CIPHER_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_CBC)\n   {\n      \n      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);\n\n      \n      if(!error)\n      {\n         \n         error = tlsEncryptCbcRecord(context, encryptionEngine, record);\n      }\n   }\n   else\n#endif\n#if (TLS_STREAM_CIPHER_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_STREAM)\n   {\n      \n      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);\n\n      \n      if(!error)\n      {\n         \n         error = tlsEncryptStreamRecord(context, encryptionEngine, record);\n      }\n   }\n   else\n#endif\n#if (TLS_NULL_CIPHER_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_NULL)\n   {\n      \n      error = tlsAppendMessageAuthCode(context, encryptionEngine, record);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_UNSUPPORTED_CIPHER_MODE;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsEncryptAeadRecord(TlsContext *context,\n   TlsEncryptionEngine *encryptionEngine, void *record)\n{\n#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED || \\\n   TLS_GCM_CIPHER_SUPPORT == ENABLED || TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)\n   error_t error;\n   size_t length;\n   size_t aadLen;\n   size_t nonceLen;\n   uint8_t *tag;\n   uint8_t *data;\n   uint8_t aad[13];\n   uint8_t nonce[12];\n\n   \n   length = tlsGetRecordLength(context, record);\n   \n   data = tlsGetRecordData(context, record);\n\n   \n   TRACE_DEBUG(\"Record to be encrypted (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   if(encryptionEngine->version == TLS_VERSION_1_3)\n   {\n      \n      \n      data[length++] = tlsGetRecordType(context, record);\n\n      \n      \n      tlsSetRecordType(context, record, TLS_TYPE_APPLICATION_DATA);\n\n      \n      tlsSetRecordLength(context, record, length +\n         encryptionEngine->authTagLen);\n   }\n\n   \n   tlsFormatAad(context, encryptionEngine, record, aad, &aadLen);\n\n   \n   if(encryptionEngine->recordIvLen != 0)\n   {\n      \n      osMemmove(data + encryptionEngine->recordIvLen, data, length);\n\n      \n      \n      error = context->prngAlgo->read(context->prngContext, data,\n         encryptionEngine->recordIvLen);\n      \n      if(error)\n         return error;\n   }\n\n   \n   tlsFormatNonce(context, encryptionEngine, record, data, nonce,\n      &nonceLen);\n\n   \n   data += encryptionEngine->recordIvLen;\n   \n   tag = data + length;\n\n#if (TLS_CCM_CIPHER_SUPPORT == ENABLED || TLS_CCM_8_CIPHER_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_CCM)\n   {\n      \n      error = ccmEncrypt(encryptionEngine->cipherAlgo,\n         encryptionEngine->cipherContext, nonce, nonceLen, aad, aadLen,\n         data, data, length, tag, encryptionEngine->authTagLen);\n   }\n   else\n#endif\n#if (TLS_GCM_CIPHER_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_GCM)\n   {\n      \n      error = gcmEncrypt(encryptionEngine->gcmContext, nonce, nonceLen,\n         aad, aadLen, data, data, length, tag, encryptionEngine->authTagLen);\n   }\n   else\n#endif\n#if (TLS_CHACHA20_POLY1305_SUPPORT == ENABLED)\n   \n   if(encryptionEngine->cipherMode == CIPHER_MODE_CHACHA20_POLY1305)\n   {\n      \n      error = chacha20Poly1305Encrypt(encryptionEngine->encKey,\n         encryptionEngine->encKeyLen, nonce, nonceLen, aad, aadLen,\n         data, data, length, tag, encryptionEngine->authTagLen);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_UNSUPPORTED_CIPHER_MODE;\n   }\n\n   \n   if(error)\n      return error;\n\n   \n   length += encryptionEngine->recordIvLen + encryptionEngine->authTagLen;\n   \n   tlsSetRecordLength(context, record, length);\n\n   \n   tlsIncSequenceNumber(&encryptionEngine->seqNum);\n\n   \n   TRACE_DEBUG(\"Encrypted record (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_UNSUPPORTED_CIPHER_MODE;\n#endif\n}\n\n\n\n\nerror_t tlsEncryptCbcRecord(TlsContext *context,\n   TlsEncryptionEngine *encryptionEngine, void *record)\n{\n#if (TLS_CBC_CIPHER_SUPPORT == ENABLED)\n   error_t error;\n   size_t i;\n   size_t length;\n   size_t paddingLen;\n   uint8_t *data;\n   const CipherAlgo *cipherAlgo;\n\n   \n   cipherAlgo = encryptionEngine->cipherAlgo;\n\n   \n   length = tlsGetRecordLength(context, record);\n   \n   data = tlsGetRecordData(context, record);\n\n   \n   TRACE_DEBUG(\"Record to be encrypted (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_1 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   \n   if(encryptionEngine->version >= TLS_VERSION_1_1)\n   {\n      \n      osMemmove(data + encryptionEngine->recordIvLen, data, length);\n\n      \n      error = context->prngAlgo->read(context->prngContext, data,\n         encryptionEngine->recordIvLen);\n      \n      if(error)\n         return error;\n\n      \n      length += encryptionEngine->recordIvLen;\n   }\n#endif\n\n   \n   paddingLen = (length + 1) % cipherAlgo->blockSize;\n\n   \n   \n   if(paddingLen > 0)\n      paddingLen = cipherAlgo->blockSize - paddingLen;\n\n   \n   for(i = 0; i <= paddingLen; i++)\n   {\n      data[length + i] = (uint8_t) paddingLen;\n   }\n\n   \n   length += paddingLen + 1;\n   \n   tlsSetRecordLength(context, record, length);\n\n   \n   TRACE_DEBUG(\"Record with padding (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   error = cbcEncrypt(cipherAlgo, encryptionEngine->cipherContext,\n      encryptionEngine->iv, data, data, length);\n   \n   if(error)\n      return error;\n\n   \n   TRACE_DEBUG(\"Encrypted record (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_UNSUPPORTED_CIPHER_MODE;\n#endif\n}\n\n\n\n\nerror_t tlsEncryptStreamRecord(TlsContext *context,\n   TlsEncryptionEngine *encryptionEngine, void *record)\n{\n#if (TLS_STREAM_CIPHER_SUPPORT == ENABLED)\n   size_t length;\n   uint8_t *data;\n\n   \n   length = tlsGetRecordLength(context, record);\n   \n   data = tlsGetRecordData(context, record);\n\n   \n   TRACE_DEBUG(\"Record to be encrypted (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   encryptionEngine->cipherAlgo->encryptStream(\n      encryptionEngine->cipherContext, data, data, length);\n\n   \n   TRACE_DEBUG(\"Encrypted record (%\" PRIuSIZE \" bytes):\\r\\n\", length);\n   TRACE_DEBUG_ARRAY(\"  \", record, length + sizeof(TlsRecord));\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_UNSUPPORTED_CIPHER_MODE;\n#endif\n}\n\n\n\n\nerror_t tlsAppendMessageAuthCode(TlsContext *context,\n   TlsEncryptionEngine *encryptionEngine, void *record)\n{\n   error_t error;\n   size_t length;\n   uint8_t *data;\n\n   \n   length = tlsGetRecordLength(context, record);\n   \n   data = tlsGetRecordData(context, record);\n\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= SSL_VERSION_3_0)\n   \n   if(encryptionEngine->version == SSL_VERSION_3_0)\n   {\n      \n      error = sslComputeMac(encryptionEngine, record, data, length,\n         data + length);\n   }\n   else\n#endif\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   \n   if(encryptionEngine->version >= TLS_VERSION_1_0 &&\n      encryptionEngine->version <= TLS_VERSION_1_2)\n   {\n      \n      error = tlsComputeMac(context, encryptionEngine, record, data,\n         length, data + length);\n   }\n   else\n#endif\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n   \n   if(encryptionEngine->version == TLS_VERSION_1_3)\n   {\n      \n      \n      data[length++] = tlsGetRecordType(context, record);\n\n      \n      \n      tlsSetRecordType(context, record, TLS_TYPE_APPLICATION_DATA);\n\n      \n      tlsSetRecordLength(context, record, length +\n         encryptionEngine->hashAlgo->digestSize);\n\n      \n      error = tls13ComputeMac(context, encryptionEngine, record, data,\n         length, data + length);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_INVALID_VERSION;\n   }\n\n   \n   if(error)\n      return error;\n\n   \n   TRACE_DEBUG(\"Write sequence number:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", &encryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   TRACE_DEBUG(\"Computed MAC:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", data + length, encryptionEngine->hashAlgo->digestSize);\n\n   \n   length += encryptionEngine->hashAlgo->digestSize;\n   \n   tlsSetRecordLength(context, record, length);\n\n   \n   tlsIncSequenceNumber(&encryptionEngine->seqNum);\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tlsComputeMac(TlsContext *context, TlsEncryptionEngine *encryptionEngine,\n   void *record, const uint8_t *data, size_t dataLen, uint8_t *mac)\n{\n   HmacContext *hmacContext;\n\n   \n   hmacContext = encryptionEngine->hmacContext;\n\n   \n   hmacInit(hmacContext, encryptionEngine->hashAlgo,\n      encryptionEngine->macKey, encryptionEngine->macKeyLen);\n\n#if (DTLS_SUPPORT == ENABLED)\n   \n   if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_DATAGRAM)\n   {\n      const DtlsRecord *dtlsRecord;\n\n      \n      dtlsRecord = (DtlsRecord *) record;\n\n      \n      \n      hmacUpdate(hmacContext, (void *) &dtlsRecord->epoch, 2);\n      hmacUpdate(hmacContext, &dtlsRecord->seqNum, 6);\n\n      \n      hmacUpdate(hmacContext, &dtlsRecord->type, 3);\n      hmacUpdate(hmacContext, (void *) &dtlsRecord->length, 2);\n      hmacUpdate(hmacContext, data, dataLen);\n   }\n   else\n#endif\n   \n   {\n      const TlsRecord *tlsRecord;\n\n      \n      tlsRecord = (TlsRecord *) record;\n\n      \n      hmacUpdate(hmacContext, &encryptionEngine->seqNum,\n         sizeof(TlsSequenceNumber));\n\n      \n      hmacUpdate(hmacContext, tlsRecord, sizeof(TlsRecord));\n      hmacUpdate(hmacContext, data, dataLen);\n   }\n\n   \n   hmacFinal(hmacContext, mac);\n\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include \"tls.h\"\n#include \"tls_handshake.h\"\n#include \"tls_server.h\"\n#include \"tls_server_fsm.h\"\n#include \"tls_common.h\"\n#include \"tls_cache.h\"\n#include \"tls_record.h\"\n#include \"tls_misc.h\"\n#include \"tls13_server.h\"\n#include \"tls13_common.h\"\n#include \"tls13_key_material.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_SERVER_SUPPORT == ENABLED)\n\n\n\n\nerror_t tlsPerformServerHandshake(TlsContext *context)\n{\n   error_t error;\n\n   \n   error = NO_ERROR;\n\n   \n   while(!error)\n   {\n      \n      if(context->transportProtocol == TLS_TRANSPORT_PROTOCOL_STREAM)\n      {\n         \n         if(context->state != TLS_STATE_INIT &&\n            context->state != TLS_STATE_CLOSED)\n         {\n            \n            error = tlsWriteProtocolData(context, NULL, 0, TLS_TYPE_NONE);\n            \n            if(error)\n               break;\n         }\n      }\n\n      \n      if(context->state == TLS_STATE_APPLICATION_DATA)\n      {\n         \n         \n         break;\n      }\n\n      \n      \n      switch(context->state)\n      {\n      \n      case TLS_STATE_INIT:\n         \n         error = tlsInitHandshake(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_HELLO:\n      case TLS_STATE_SERVER_HELLO_2:\n         \n         \n         error = tlsSendServerHello(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_CERTIFICATE:\n         \n         \n         \n         error = tlsSendCertificate(context);\n         break;\n\n      \n      case TLS_STATE_CERTIFICATE_REQUEST:\n         \n         \n         \n         error = tlsSendCertificateRequest(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC:\n      case TLS_STATE_SERVER_CHANGE_CIPHER_SPEC_2:\n         \n         \n         \n         error = tlsSendChangeCipherSpec(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_FINISHED:\n         \n         \n         \n         error = tlsSendFinished(context);\n         break;\n\n#if (DTLS_SUPPORT == ENABLED)\n      \n      case TLS_STATE_HELLO_VERIFY_REQUEST:\n         \n         \n         error = dtlsSendHelloVerifyRequest(context);\n         break;\n#endif\n\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n      \n      case TLS_STATE_SERVER_KEY_EXCHANGE:\n         \n         \n         \n         error = tlsSendServerKeyExchange(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_HELLO_DONE:\n         \n         \n         error = tlsSendServerHelloDone(context);\n         break;\n#endif\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n      \n      case TLS_STATE_HELLO_RETRY_REQUEST:\n         \n         \n         \n         error = tls13SendHelloRetryRequest(context);\n         break;\n\n      \n      case TLS_STATE_HANDSHAKE_TRAFFIC_KEYS:\n         \n         error = tls13GenerateHandshakeTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_ENCRYPTED_EXTENSIONS:\n         \n         \n         \n         error = tls13SendEncryptedExtensions(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_CERTIFICATE_VERIFY:\n         \n         \n         \n         error = tlsSendCertificateVerify(context);\n         break;\n\n      \n      case TLS_STATE_SERVER_APP_TRAFFIC_KEYS:\n         \n         error = tls13GenerateServerAppTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_CLIENT_APP_TRAFFIC_KEYS:\n         \n         error = tls13GenerateClientAppTrafficKeys(context);\n         break;\n\n      \n      case TLS_STATE_NEW_SESSION_TICKET:\n         \n         \n         error = tls13SendNewSessionTicket(context);\n         break;\n\n      \n      case TLS_STATE_KEY_UPDATE:\n         \n         \n         error = tls13SendKeyUpdate(context);\n         break;\n#endif\n\n      \n      case TLS_STATE_CLIENT_HELLO:\n      case TLS_STATE_CLIENT_HELLO_2:\n      case TLS_STATE_CLIENT_CERTIFICATE:\n      case TLS_STATE_CLIENT_KEY_EXCHANGE:\n      case TLS_STATE_CLIENT_CERTIFICATE_VERIFY:\n      case TLS_STATE_CLIENT_CHANGE_CIPHER_SPEC:\n      case TLS_STATE_CLIENT_FINISHED:\n         \n         error = tlsReceiveHandshakeMessage(context);\n         break;\n\n      \n      case TLS_STATE_CLOSING:\n         \n         context->state = TLS_STATE_CLOSED;\n         break;\n\n      \n      case TLS_STATE_CLOSED:\n         \n         TRACE_WARNING(\"TLS handshake failure!\\r\\n\");\n         \n         error = ERROR_HANDSHAKE_FAILED;\n         break;\n\n      \n      default:\n         \n         error = ERROR_UNEXPECTED_STATE;\n         break;\n      }\n   }\n\n   \n   if(!error)\n   {\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n      \n      if(context->version <= TLS_VERSION_1_2)\n      {\n         \n         tlsSaveToCache(context);\n      }\n#endif\n   }\n   else\n   {\n      \n      tlsProcessError(context, error);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsParseClientHandshakeMessage(TlsContext *context, uint8_t msgType,\n   const void *message, size_t length)\n{\n   error_t error;\n\n   \n   switch(msgType)\n   {\n   \n   case TLS_TYPE_CLIENT_HELLO:\n      \n      \n      error = tlsParseClientHello(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_CERTIFICATE:\n      \n      \n      \n      error = tlsParseCertificate(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_CERTIFICATE_VERIFY:\n      \n      \n      \n      \n      error = tlsParseCertificateVerify(context, message, length);\n      break;\n\n   \n   case TLS_TYPE_FINISHED:\n      \n      \n      \n      error = tlsParseFinished(context, message, length);\n      break;\n\n#if (TLS_MAX_VERSION >= SSL_VERSION_3_0 && TLS_MIN_VERSION <= TLS_VERSION_1_2)\n   \n   case TLS_TYPE_CLIENT_KEY_EXCHANGE:\n      \n      \n      \n      error = tlsParseClientKeyExchange(context, message, length);\n      break;\n#endif\n\n#if (TLS_MAX_VERSION >= TLS_VERSION_1_3 && TLS_MIN_VERSION <= TLS_VERSION_1_3)\n   \n   case TLS_TYPE_KEY_UPDATE:\n      \n      \n      \n      error = tls13ParseKeyUpdate(context, message, length);\n      break;\n#endif\n\n   \n   default:\n      \n      error = ERROR_UNEXPECTED_MESSAGE;\n      break;\n   }\n\n   \n   return error;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL TLS_TRACE_LEVEL\n\n\n#include <string.h>\n#include \"tls.h\"\n#include \"tls_ticket.h\"\n#include \"debug.h\"\n\n\n#if (TLS_SUPPORT == ENABLED && TLS_TICKET_SUPPORT == ENABLED)\n\n\n\n\nerror_t tlsInitTicketContext(TlsTicketContext *ticketContext)\n{\n   \n   if(ticketContext == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   osMemset(ticketContext, 0, sizeof(TlsTicketContext));\n\n   \n   if(!osCreateMutex(&ticketContext->mutex))\n   {\n      \n      return ERROR_OUT_OF_RESOURCES;\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t tlsEncryptTicket(TlsContext *context, const uint8_t *plaintext,\n   size_t plaintextLen, uint8_t *ciphertext, size_t *ciphertextLen, void *param)\n{\n   error_t error;\n   uint8_t *iv;\n   uint8_t *data;\n   uint8_t *tag;\n   systime_t time;\n   TlsTicketContext *ticketContext;\n   TlsTicketEncryptionState *state;\n\n   \n   if(context == NULL || param == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(plaintext == NULL || ciphertext == NULL || ciphertextLen == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   error = NO_ERROR;\n\n   \n   iv = NULL;\n   data = NULL;\n   tag = NULL;\n\n   \n   ticketContext = (TlsTicketContext *) param;\n\n   \n   osAcquireMutex(&ticketContext->mutex);\n\n   \n   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);\n   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);\n\n   \n   state = &ticketContext->encryptionState;\n\n   \n   if(state->valid)\n   {\n      \n      time = osGetSystemTime();\n\n      \n      if((time - state->timestamp) >= TLS_TICKET_LIFETIME)\n      {\n         \n         ticketContext->prevEncryptionState = ticketContext->encryptionState;\n         ticketContext->encryptionState.valid = FALSE;\n      }\n   }\n\n   \n   if(!state->valid)\n   {\n      \n      error = tlsGenerateTicketKeys(ticketContext, context->prngAlgo,\n         context->prngContext);\n   }\n\n   \n   if(!error)\n   {\n      \n      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;\n      \n      data = iv + TLS_TICKET_IV_SIZE;\n      \n      tag = data + plaintextLen;\n\n      \n      osMemmove(data, plaintext, plaintextLen);\n      \n      osMemcpy(ciphertext, state->keyName, TLS_TICKET_KEY_NAME_SIZE);\n\n      \n      error = context->prngAlgo->read(context->prngContext, iv,\n         TLS_TICKET_IV_SIZE);\n   }\n\n   \n   if(!error)\n   {\n      \n      error = aesInit(&ticketContext->aesContext, state->key,\n         TLS_TICKET_KEY_SIZE);\n   }\n\n   \n   if(!error)\n   {\n      \n      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,\n         &ticketContext->aesContext);\n   }\n\n   \n   if(!error)\n   {\n      \n      *ciphertextLen = plaintextLen + TLS_TICKET_KEY_NAME_SIZE +\n         TLS_TICKET_IV_SIZE + TLS_TICKET_TAG_SIZE;\n\n      \n      error = gcmEncrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,\n         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, data, plaintextLen,\n         tag, TLS_TICKET_TAG_SIZE);\n   }\n\n   \n   osReleaseMutex(&ticketContext->mutex);\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsDecryptTicket(TlsContext *context, const uint8_t *ciphertext,\n   size_t ciphertextLen, uint8_t *plaintext, size_t *plaintextLen, void *param)\n{\n   error_t error;\n   const uint8_t *iv;\n   const uint8_t *data;\n   const uint8_t *tag;\n   TlsTicketContext *ticketContext;\n   TlsTicketEncryptionState *state;\n\n   \n   if(context == NULL || param == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(ciphertext == NULL || plaintext == NULL || plaintextLen == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   \n   if(ciphertextLen < (TLS_TICKET_KEY_NAME_SIZE + TLS_TICKET_IV_SIZE +\n      TLS_TICKET_TAG_SIZE))\n   {\n      \n      return ERROR_DECRYPTION_FAILED;\n   }\n\n   \n   error = NO_ERROR;\n\n   \n   iv = NULL;\n   data = NULL;\n   tag = NULL;\n   state = NULL;\n\n   \n   ticketContext = (TlsTicketContext *) param;\n\n   \n   osAcquireMutex(&ticketContext->mutex);\n\n   \n   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);\n   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);\n\n   \n   if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,\n      &ticketContext->encryptionState))\n   {\n      \n      state = &ticketContext->encryptionState;\n   }\n   else if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,\n      &ticketContext->prevEncryptionState))\n   {\n      \n      state = &ticketContext->prevEncryptionState;\n   }\n   else\n   {\n      \n      error = ERROR_DECRYPTION_FAILED;\n   }\n\n   \n   if(!error)\n   {\n      \n      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;\n      \n      data = iv + TLS_TICKET_IV_SIZE;\n      \n      tag = ciphertext + ciphertextLen - TLS_TICKET_TAG_SIZE;\n\n      \n      *plaintextLen = ciphertextLen - TLS_TICKET_KEY_NAME_SIZE -\n         TLS_TICKET_IV_SIZE - TLS_TICKET_TAG_SIZE;\n\n      \n      error = aesInit(&ticketContext->aesContext, state->key,\n         TLS_TICKET_KEY_SIZE);\n   }\n\n   \n   if(!error)\n   {\n      \n      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,\n         &ticketContext->aesContext);\n   }\n\n   \n   if(!error)\n   {\n      \n      error = gcmDecrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,\n         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, plaintext,\n         *plaintextLen, tag, TLS_TICKET_TAG_SIZE);\n   }\n\n   \n   osReleaseMutex(&ticketContext->mutex);\n\n   \n   return error;\n}\n\n\n\n\nerror_t tlsGenerateTicketKeys(TlsTicketContext *ticketContext,\n   const PrngAlgo *prngAlgo, void *prngContext)\n{\n   error_t error;\n   TlsTicketEncryptionState *state;\n\n   \n   state = &ticketContext->encryptionState;\n\n   \n   state->valid = FALSE;\n\n   \n   \n   error = prngAlgo->read(prngContext, state->keyName,\n      TLS_TICKET_KEY_NAME_SIZE);\n   \n   if(error)\n      return error;\n\n   \n   error = prngAlgo->read(prngContext, state->key, TLS_TICKET_KEY_SIZE);\n   \n   if(error)\n      return error;\n\n   \n   state->timestamp = osGetSystemTime();\n   \n   state->valid = TRUE;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid tlsCheckTicketKeyLifetime(TlsTicketEncryptionState *state)\n{\n   systime_t time;\n\n   \n   time = osGetSystemTime();\n\n   \n   if(state->valid)\n   {\n      \n      if((time - state->timestamp) >= (2 * TLS_TICKET_LIFETIME))\n      {\n         \n         osMemset(state, 0, sizeof(TlsTicketEncryptionState));\n      }\n   }\n}\n\n\n\n\nbool_t tlsCompareTicketKeyName(const uint8_t *ticket, size_t ticketLen,\n   const TlsTicketEncryptionState *state)\n{\n   bool_t res;\n\n   \n   res = FALSE;\n\n   \n   if(state->valid)\n   {\n      \n      \n      if(ticketLen >= TLS_TICKET_KEY_NAME_SIZE)\n      {\n         \n         if(osMemcmp(ticket, state->keyName, TLS_TICKET_KEY_NAME_SIZE) == 0)\n         {\n            \n            res = TRUE;\n         }\n      }\n   }\n\n   \n   return res;\n}\n\n\n\n\nvoid tlsFreeTicketContext(TlsTicketContext *ticketContext)\n{\n   \n   if(ticketContext != NULL)\n   {\n      \n      osDeleteMutex(&ticketContext->mutex);\n\n      \n      osMemset(ticketContext, 0, sizeof(TlsTicketContext));\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SNMP_TRACE_LEVEL\n\n\n#include \"core\/net.h\"\n#include \"mibs\/mib_common.h\"\n#include \"mibs\/bridge_mib_module.h\"\n#include \"mibs\/bridge_mib_impl.h\"\n#include \"core\/crypto.h\"\n#include \"encoding\/asn1.h\"\n#include \"encoding\/oid.h\"\n#include \"stp\/stp.h\"\n#include \"stp\/stp_mgmt.h\"\n#include \"stp\/stp_misc.h\"\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_mgmt.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (BRIDGE_MIB_SUPPORT == ENABLED)\n\n\n\n\nerror_t bridgeMibInit(void)\n{\n   \n   TRACE_INFO(\"Initializing Bridge MIB base...\\r\\n\");\n\n   \n   memset(&bridgeMibBase, 0, sizeof(bridgeMibBase));\n\n   \n   bridgeMibBase.dot1dBaseType = BRIDGE_MIB_BASE_TYPE_TRANSPARENT_ONLY;\n   \n   bridgeMibBase.dot1dStpProtocolSpecification = BRIDGE_MIB_PROTOCOL_SPEC_IEEE802_1D;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t bridgeMibSetStpBridgeContext(StpBridgeContext *context)\n{\n#if (STP_SUPPORT == ENABLED)\n   \n   if(context != NULL)\n   {\n      bridgeMibBase.stpBridgeContext = context;\n      bridgeMibBase.interface = context->interface;\n   }\n   else\n   {\n      bridgeMibBase.stpBridgeContext = NULL;\n      bridgeMibBase.interface = NULL;\n   }\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nerror_t bridgeMibSetRstpBridgeContext(RstpBridgeContext *context)\n{\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(context != NULL)\n   {\n      bridgeMibBase.rstpBridgeContext = context;\n      bridgeMibBase.interface = context->interface;\n   }\n   else\n   {\n      bridgeMibBase.rstpBridgeContext = NULL;\n      bridgeMibBase.interface = NULL;\n   }\n\n   \n   return NO_ERROR;\n#else\n   \n   return ERROR_NOT_IMPLEMENTED;\n#endif\n}\n\n\n\n\nuint_t bridgeMibGetNumPorts(void)\n{\n   uint_t numPorts;\n\n   \n   numPorts = 0;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      numPorts = bridgeMibBase.stpBridgeContext->numPorts;\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      numPorts = bridgeMibBase.rstpBridgeContext->numPorts;\n   }\n   else\n#endif\n   \n   {\n      \n   }\n\n   \n   return numPorts;\n}\n\n\n\n\nuint_t bridgeMibGetPortIndex(uint16_t portNum)\n{\n   uint_t portIndex;\n\n   \n   portIndex = 0;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      StpBridgePort *port;\n\n      \n      port = stpGetBridgePort(bridgeMibBase.stpBridgeContext, portNum);\n\n      \n      if(port != NULL)\n      {\n         \n         portIndex = port->portIndex;\n      }\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      RstpBridgePort *port;\n\n      \n      port = rstpGetBridgePort(bridgeMibBase.rstpBridgeContext, portNum);\n\n      \n      if(port != NULL)\n      {\n         \n         portIndex = port->portIndex;\n      }\n   }\n   else\n#endif\n   \n   {\n      \n   }\n\n   \n   return portIndex;\n}\n\n\n\n\nuint16_t bridgeMibGetPortNum(uint16_t portIndex)\n{\n   uint_t portNum;\n\n   \n   portNum = 0;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      \n      if(portIndex >= 1 && portIndex <= bridgeMibBase.stpBridgeContext->numPorts)\n      {\n         StpBridgePort *port;\n\n         \n         port = &bridgeMibBase.stpBridgeContext->ports[portIndex - 1];\n         \n         portNum = port->portId & STP_PORT_NUM_MASK;\n      }\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      \n      if(portIndex >= 1 && portIndex <= bridgeMibBase.rstpBridgeContext->numPorts)\n      {\n         RstpBridgePort *port;\n\n         \n         port = &bridgeMibBase.rstpBridgeContext->ports[portIndex - 1];\n         \n         portNum = port->portId & RSTP_PORT_NUM_MASK;\n      }\n   }\n   else\n#endif\n   \n   {\n      \n   }\n\n   \n   return portNum;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SNMP_TRACE_LEVEL\n\n\n#include \"core\/net.h\"\n#include \"mibs\/mib_common.h\"\n#include \"mibs\/bridge_mib_module.h\"\n#include \"mibs\/bridge_mib_impl.h\"\n#include \"mibs\/bridge_mib_impl_base.h\"\n#include \"core\/crypto.h\"\n#include \"encoding\/asn1.h\"\n#include \"encoding\/oid.h\"\n#include \"stp\/stp.h\"\n#include \"stp\/stp_mgmt.h\"\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_mgmt.h\"\n#include \"debug.h\"\n\n\n#if (BRIDGE_MIB_SUPPORT == ENABLED)\n\n\n\n\nerror_t bridgeMibGetDot1dBaseBridgeAddress(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   MacAddr bridgeAddr;\n\n   \n   if(*valueLen < sizeof(MacAddr))\n      return ERROR_BUFFER_OVERFLOW;\n\n   \n   bridgeAddr = MAC_UNSPECIFIED_ADDR;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      \n      error = stpMgmtGetBridgeAddr(bridgeMibBase.stpBridgeContext,\n         &bridgeAddr);\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      \n      error = rstpMgmtGetBridgeAddr(bridgeMibBase.rstpBridgeContext,\n         &bridgeAddr);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_READ_FAILED;\n   }\n\n   \n   if(!error)\n   {\n      \n      macCopyAddr(value->octetString, &bridgeAddr);\n      \n      *valueLen = sizeof(MacAddr);\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetDot1dBaseNumPorts(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   uint_t numPorts;\n\n   \n   numPorts = 0;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      \n      error = stpMgmtGetNumPorts(bridgeMibBase.stpBridgeContext, &numPorts);\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      \n      error = rstpMgmtGetNumPorts(bridgeMibBase.rstpBridgeContext, &numPorts);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_READ_FAILED;\n   }\n\n   \n   if(!error)\n   {\n      \n      value->integer = numPorts;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetDot1dBaseType(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   \n   value->integer = bridgeMibBase.dot1dBaseType;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t bridgeMibGetDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   size_t n;\n   uint_t portIndex;\n   uint16_t dot1dBasePort;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibDecodePort(oid, oidLen, &n, &dot1dBasePort);\n   \n   if(error)\n      return error;\n\n   \n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   portIndex = bridgeMibGetPortIndex(dot1dBasePort);\n   \n   if(portIndex == 0)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   if(!strcmp(object->name, \"dot1dBasePort\"))\n   {\n      \n      \n      value->integer = dot1dBasePort;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dBasePortIfIndex\"))\n   {\n      \n      \n      value->integer = portIndex;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dBasePortCircuit\"))\n   {\n      \n      if(*valueLen >= sizeof(uint8_t))\n      {\n         \n         \n         \n         value->oid[0] = 0;\n\n         \n         *valueLen = sizeof(uint8_t);\n      }\n      else\n      {\n         \n         error = ERROR_BUFFER_OVERFLOW;\n      }\n   }\n   \n   else if(!strcmp(object->name, \"dot1dBasePortDelayExceededDiscards\"))\n   {\n      \n      \n      \n      value->counter32 = 0;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dBasePortMtuExceededDiscards\"))\n   {\n      \n      \n      value->counter32 = 0;\n   }\n   \n   else\n   {\n      \n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetNextDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n\n   \n   portNum = 0;\n\n   \n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n\n   \n   osMemcpy(nextOid, object->oid, object->oidLen);\n\n   \n   numPorts = bridgeMibGetNumPorts();\n\n   \n   for(i = 1; i <= numPorts; i++)\n   {\n      \n      curPortNum = bridgeMibGetPortNum(i);\n\n      \n      n = object->oidLen;\n\n      \n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      \n      if(error)\n         return error;\n\n      \n      \n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         \n         \n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n\n   \n   \n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   \n   if(error)\n      return error;\n\n   \n   *nextOidLen = n;\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SNMP_TRACE_LEVEL\n\n\n#include \"core\/net.h\"\n#include \"mibs\/mib_common.h\"\n#include \"mibs\/bridge_mib_module.h\"\n#include \"mibs\/bridge_mib_impl.h\"\n#include \"mibs\/bridge_mib_impl_tp.h\"\n#include \"core\/crypto.h\"\n#include \"encoding\/asn1.h\"\n#include \"encoding\/oid.h\"\n#include \"stp\/stp.h\"\n#include \"stp\/stp_mgmt.h\"\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_mgmt.h\"\n#include \"debug.h\"\n\n\n#if (BRIDGE_MIB_SUPPORT == ENABLED)\n\n\n\n\nerror_t bridgeMibGetDot1dTpLearnedEntryDiscards(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   \n   \n   \n   value->counter32 = 0;\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t bridgeMibSetDot1dTpAgingTime(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, const MibVariant *value, size_t valueLen, bool_t commit)\n{\n#if (BRIDGE_MIB_SET_SUPPORT == ENABLED)\n   error_t error;\n\n   \n   if(value->integer >= 0)\n   {\n#if (STP_SUPPORT == ENABLED)\n      \n      if(bridgeMibBase.stpBridgeContext != NULL)\n      {\n         \n         \n         error = stpMgmtSetAgeingTime(bridgeMibBase.stpBridgeContext,\n            value->integer, commit);\n      }\n      else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n      \n      if(bridgeMibBase.rstpBridgeContext != NULL)\n      {\n         \n         \n         error = rstpMgmtSetAgeingTime(bridgeMibBase.rstpBridgeContext,\n            value->integer, commit);\n      }\n      else\n#endif\n      \n      {\n         \n         error = ERROR_WRITE_FAILED;\n      }\n   }\n   else\n   {\n      \n      error = ERROR_WRONG_VALUE;\n   }\n\n   \n   return error;\n#else\n   \n   return ERROR_WRITE_FAILED;\n#endif\n}\n\n\n\n\nerror_t bridgeMibGetDot1dTpAgingTime(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   uint_t ageingTime;\n\n   \n   ageingTime = 0;\n\n#if (STP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.stpBridgeContext != NULL)\n   {\n      \n      \n      error = stpMgmtGetAgeingTime(bridgeMibBase.stpBridgeContext,\n         &ageingTime);\n   }\n   else\n#endif\n#if (RSTP_SUPPORT == ENABLED)\n   \n   if(bridgeMibBase.rstpBridgeContext != NULL)\n   {\n      \n      \n      error = rstpMgmtGetAgeingTime(bridgeMibBase.rstpBridgeContext,\n         &ageingTime);\n   }\n   else\n#endif\n   \n   {\n      \n      error = ERROR_READ_FAILED;\n   }\n\n   \n   if(!error)\n   {\n      \n      value->integer = ageingTime;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   SwitchFdbEntry entry;\n   MacAddr dot1dTpFdbAddress;\n   NetInterface *interface;\n\n   \n   if(bridgeMibBase.interface == NULL)\n      return ERROR_READ_FAILED;\n\n   \n   interface = bridgeMibBase.interface;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibDecodeMacAddr(oid, oidLen, &n, &dot1dTpFdbAddress);\n   \n   if(error)\n      return error;\n\n   \n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   for(i = 0; !error; i++)\n   {\n      \n      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);\n\n      \n      if(error == NO_ERROR)\n      {\n         \n         if(macCompAddr(&entry.macAddr, &dot1dTpFdbAddress))\n            break;\n      }\n      else if(error == ERROR_INVALID_ENTRY)\n      {\n         \n         error = NO_ERROR;\n      }\n      else\n      {\n         \n      }\n   }\n\n   \n   if(error)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   if(!strcmp(object->name, \"dot1dTpFdbAddress\"))\n   {\n      \n      if(*valueLen >= sizeof(MacAddr))\n      {\n         \n         \n         macCopyAddr(value->octetString, &entry.macAddr);\n\n         \n         *valueLen = sizeof(MacAddr);\n      }\n      else\n      {\n         \n         error = ERROR_BUFFER_OVERFLOW;\n      }\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpFdbPort\"))\n   {\n      \n      \n      \n      value->integer = entry.srcPort;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpFdbStatus\"))\n   {\n      \n      value->integer = BRIDGE_MIB_FDB_STATUS_LEARNED;\n   }\n   \n   else\n   {\n      \n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetNextDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   MacAddr macAddr;\n   SwitchFdbEntry entry;\n   NetInterface *interface;\n\n   \n   macAddr = MAC_UNSPECIFIED_ADDR;\n\n   \n   if(bridgeMibBase.interface == NULL)\n      return ERROR_OBJECT_NOT_FOUND;\n\n   \n   interface = bridgeMibBase.interface;\n\n   \n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n\n   \n   osMemcpy(nextOid, object->oid, object->oidLen);\n\n   \n   error = NO_ERROR;\n\n   \n   for(i = 0; !error; i++)\n   {\n      \n      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);\n\n      \n      if(error == NO_ERROR)\n      {\n         \n         n = object->oidLen;\n\n         \n         error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &entry.macAddr);\n         \n         if(error)\n            return error;\n\n         \n         \n         if(oidComp(nextOid, n, oid, oidLen) > 0)\n         {\n            \n            \n            if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0 ||\n               mibCompMacAddr(&entry.macAddr, &macAddr) < 0)\n            {\n               macAddr = entry.macAddr;\n            }\n         }\n      }\n      else if(error == ERROR_INVALID_ENTRY)\n      {\n         \n         error = NO_ERROR;\n      }\n      else\n      {\n         \n      }\n   }\n\n   \n   \n   if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &macAddr);\n   \n   if(error)\n      return error;\n\n   \n   *nextOidLen = n;\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t bridgeMibGetDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   size_t n;\n   uint16_t dot1dTpPort;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibDecodePort(oid, oidLen, &n, &dot1dTpPort);\n   \n   if(error)\n      return error;\n\n   \n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   if(bridgeMibGetPortIndex(dot1dTpPort) == 0)\n      return ERROR_INSTANCE_NOT_FOUND;\n\n   \n   if(!strcmp(object->name, \"dot1dTpPort\"))\n   {\n      \n      \n      value->integer = dot1dTpPort;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpPortMaxInfo\"))\n   {\n      \n      \n      value->integer = ETH_MTU;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpPortInFrames\"))\n   {\n      \n      \n      value->counter32 = 0;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpPortOutFrames\"))\n   {\n      \n      \n      value->counter32 = 0;\n   }\n   \n   else if(!strcmp(object->name, \"dot1dTpPortInDiscards\"))\n   {\n      \n      \n      value->counter32 = 0;\n   }\n   \n   else\n   {\n      \n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t bridgeMibGetNextDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n\n   \n   portNum = 0;\n\n   \n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n\n   \n   osMemcpy(nextOid, object->oid, object->oidLen);\n\n   \n   numPorts = bridgeMibGetNumPorts();\n\n   \n   for(i = 1; i <= numPorts; i++)\n   {\n      \n      curPortNum = bridgeMibGetPortNum(i);\n\n      \n      n = object->oidLen;\n\n      \n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      \n      if(error)\n         return error;\n\n      \n      \n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         \n         \n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n\n   \n   \n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n\n   \n   n = object->oidLen;\n\n   \n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   \n   if(error)\n      return error;\n\n   \n   *nextOidLen = n;\n   \n   return NO_ERROR;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_bdm.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpBdmStates[] =\n{\n   {RSTP_BDM_STATE_EDGE,     \"EDGE\"},\n   {RSTP_BDM_STATE_NOT_EDGE, \"NOT_EDGE\"}\n};\n\n\n\n\nvoid rstpBdmInit(RstpBridgePort *port)\n{\n   \n   if(rstpAdminEdge(port))\n   {\n      rstpBdmChangeState(port, RSTP_BDM_STATE_EDGE);\n   }\n   else\n   {\n      rstpBdmChangeState(port, RSTP_BDM_STATE_NOT_EDGE);\n   }\n}\n\n\n\n\nvoid rstpBdmFsm(RstpBridgePort *port)\n{\n   \n   \n   switch(port->bdmState)\n   {\n   \n   case RSTP_BDM_STATE_EDGE:\n      \n      if((!port->portEnabled && !rstpAdminEdge(port)) || !port->operEdge)\n      {\n         \n         rstpBdmChangeState(port, RSTP_BDM_STATE_NOT_EDGE);\n      }\n\n      break;\n\n   \n   case RSTP_BDM_STATE_NOT_EDGE:\n      \n      if((!port->portEnabled && rstpAdminEdge(port)) ||\n         (port->edgeDelayWhile == 0 && rstpAutoEdge(port) &&\n         port->sendRstp && port->proposing))\n      {\n         \n         rstpBdmChangeState(port, RSTP_BDM_STATE_EDGE);\n      }\n\n      break;\n\n   \n   default:\n      \n      rstpFsmError(port->context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpBdmChangeState(RstpBridgePort *port, RstpBdmState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": BDM state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->bdmState, rstpBdmStates, arraysize(rstpBdmStates)),\n      rstpGetParamName(newState, rstpBdmStates, arraysize(rstpBdmStates)));\n\n   \n   port->bdmState = newState;\n\n   \n   \n   switch(port->bdmState)\n   {\n   \n   case RSTP_BDM_STATE_EDGE:\n      \n      port->operEdge = TRUE;\n      break;\n\n   \n   case RSTP_BDM_STATE_NOT_EDGE:\n      \n      port->operEdge = FALSE;\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_bpdu.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst MacAddr RSTP_BRIDGE_GROUP_ADDR = {{{0x01, 0x80, 0xC2, 0x00, 0x00, 0x00}}};\n\n\nconst RstpParamName rstpProtocolVersions[] =\n{\n   {STP_PROTOCOL_VERSION,  \"STP\"},\n   {RSTP_PROTOCOL_VERSION, \"RSTP\"}\n};\n\n\nconst RstpParamName rstpBpduTypes[] =\n{\n   {RSTP_BPDU_TYPE_CONFIG, \"CONFIG\"},\n   {RSTP_BPDU_TYPE_TCN,    \"TCN\"},\n   {RSTP_BPDU_TYPE_RST,    \"RST\"}\n};\n\n\n\n\nvoid rstpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,\n   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)\n{\n   const LlcHeader *llcHeader;\n   const RstpBpdu *bpdu;\n   RstpBridgeContext *context;\n   RstpBridgePort *port;\n\n   \n   context = (RstpBridgeContext *) param;\n\n   \n   \n   \n   if(!macCompAddr(&ethHeader->destAddr, &RSTP_BRIDGE_GROUP_ADDR))\n      return;\n\n   \n   if(length < sizeof(LlcHeader))\n      return;\n\n   \n   llcHeader = (LlcHeader *) data;\n\n   \n   \n   \n   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||\n      llcHeader->control != STP_LLC_CTRL)\n   {\n      return;\n   }\n\n   \n   if(ancillary->port < 1 || ancillary->port > context->numPorts)\n      return;\n\n   \n   port = &context->ports[ancillary->port - 1];\n\n   \n   bpdu = (RstpBpdu *) (data + sizeof(LlcHeader));\n\n   \n   length -= sizeof(LlcHeader);\n\n   \n   rstpProcessBpdu(port, bpdu, length);\n}\n\n\n\n\nerror_t rstpProcessBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   error_t error;\n   uint8_t bpduType;\n   RstpBridgeContext *context;\n\n   \n   TRACE_INFO(\"Port %\" PRIu8 \": BPDU received (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      port->portIndex, length);\n\n   \n   rstpDumpBpdu(bpdu, length);\n\n   \n   context = port->context;\n\n   \n   if(length < STP_MIN_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   if(ntohs(bpdu->protocolId) != STP_PROTOCOL_ID)\n      return ERROR_INVALID_LENGTH;\n\n   \n   bpduType = bpdu->bpduType;\n\n   \n   if(bpduType == RSTP_BPDU_TYPE_CONFIG)\n   {\n      \n      error = rstpValidateConfigBpdu(port, bpdu, length);\n      \n      if(error)\n         return error;\n\n      \n      \n      length = RSTP_CONFIG_BPDU_SIZE;\n   }\n   else if(bpduType == RSTP_BPDU_TYPE_TCN)\n   {\n      \n      \n      length = RSTP_TCN_BPDU_SIZE;\n   }\n   else if(bpduType == RSTP_BPDU_TYPE_RST)\n   {\n      \n      \n      if(stpVersion(context))\n         return ERROR_INVALID_VERSION;\n\n      \n      if(length < RSTP_RST_BPDU_SIZE)\n         return ERROR_INVALID_LENGTH;\n\n      \n      \n      length = RSTP_RST_BPDU_SIZE;\n\n      \n      if((bpdu->flags & RSTP_BPDU_FLAG_PORT_ROLE) ==\n         RSTP_BPDU_FLAG_PORT_ROLE_UNKNOWN)\n      {\n         \n         \n         \n         bpduType = RSTP_BPDU_TYPE_CONFIG;\n\n         \n         error = rstpValidateConfigBpdu(port, bpdu, length);\n         \n         if(error)\n            return error;\n\n         \n         \n         length = RSTP_CONFIG_BPDU_SIZE;\n      }\n   }\n   else\n   {\n      \n      return ERROR_INVALID_TYPE;\n   }\n\n   \n   osMemcpy(&context->bpdu, bpdu, length);\n\n   \n   context->bpdu.bpduType = bpduType;\n\n   \n   \n   if(bpduType == RSTP_BPDU_TYPE_CONFIG)\n   {\n      \n      \n      \n      context->bpdu.flags &= RSTP_BPDU_FLAG_TC_ACK | RSTP_BPDU_FLAG_TC;\n   }\n   else if(bpduType == RSTP_BPDU_TYPE_RST)\n   {\n      \n      context->bpdu.flags &= ~RSTP_BPDU_FLAG_TC_ACK;\n   }\n   else\n   {\n      \n      context->bpdu.flags = 0;\n   }\n\n   \n   \n   port->rcvdBpdu = TRUE;\n\n   \n   rstpFsm(context);\n\n   \n   osMemset(&context->bpdu, 0, sizeof(RstpBpdu));\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t rstpValidateConfigBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   RstpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   if(length < RSTP_CONFIG_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))\n      return ERROR_INVALID_PACKET;\n\n   \n   \n   if(rstpCompareBridgeAddr(&bpdu->bridgeId.addr, &context->bridgeId.addr) == 0 &&\n      rstpComparePortNum(ntohs(bpdu->portId), port->portId) == 0)\n   {\n      return ERROR_WRONG_IDENTIFIER;\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t rstpSendBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   error_t error;\n   size_t offset;\n   LlcHeader *llcHeader;\n   NetBuffer *buffer;\n   NetTxAncillary ancillary;\n   RstpBridgeContext *context;\n\n   \n   TRACE_INFO(\"Port %\" PRIu8 \": Sending BPDU (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      port->portIndex, length);\n\n   \n   rstpDumpBpdu(bpdu, length);\n\n   \n   context = port->context;\n\n   \n   buffer = ethAllocBuffer(sizeof(LlcHeader), &offset);\n\n   \n   if(buffer != NULL)\n   {\n      \n      llcHeader = netBufferAt(buffer, offset);\n\n      \n      \n      \n      llcHeader->dsap = STP_LLC_DSAP;\n      llcHeader->ssap = STP_LLC_SSAP;\n      llcHeader->control = STP_LLC_CTRL;\n\n      \n      error = netBufferAppend(buffer, bpdu, length);\n\n      \n      if(!error)\n      {\n         \n         length += sizeof(LlcHeader);\n\n         \n         ancillary = NET_DEFAULT_TX_ANCILLARY;\n         \n         ancillary.srcMacAddr = port->macAddr;\n         \n         ancillary.port = port->portIndex;\n\n         \n         \n         error = ethSendFrame(context->interface, &RSTP_BRIDGE_GROUP_ADDR,\n            length, buffer, offset, &ancillary);\n      }\n\n      \n      netBufferFree(buffer);\n   }\n   else\n   {\n      \n      error = ERROR_OUT_OF_MEMORY;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t rstpDumpBpdu(const RstpBpdu *bpdu, size_t length)\n{\n#if (RSTP_TRACE_LEVEL >= TRACE_LEVEL_DEBUG)\n   uint32_t t;\n\n   \n   if(length < STP_MIN_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   TRACE_DEBUG(\"  Protocol Identifier = %\" PRIu16 \"\\r\\n\",\n      ntohs(bpdu->protocolId));\n\n   \n   TRACE_DEBUG(\"  Protocol Version Identifier = %\" PRIu8 \" (%s)\\r\\n\",\n      bpdu->protocolVersionId, rstpGetParamName(bpdu->protocolVersionId,\n      rstpProtocolVersions, arraysize(rstpProtocolVersions)));\n\n   \n   TRACE_DEBUG(\"  BPDU Type = 0x%02\" PRIX8 \" (%s)\\r\\n\", bpdu->bpduType,\n      rstpGetParamName(bpdu->bpduType, rstpBpduTypes, arraysize(rstpBpduTypes)));\n\n   \n   if(length >= RSTP_CONFIG_BPDU_SIZE)\n   {\n      \n      rstpDumpFlags(bpdu->flags);\n\n      \n      TRACE_DEBUG(\"  Root Identifier = %\" PRIu16 \" \/ %s\\r\\n\",\n         ntohs(bpdu->rootId.priority), macAddrToString(&bpdu->rootId.addr, NULL));\n\n      \n      TRACE_DEBUG(\"  Root Path Cost = %\" PRIu32 \"\\r\\n\", ntohl(bpdu->rootPathCost));\n\n      \n      TRACE_DEBUG(\"  Bridge Identifier = %\" PRIu16 \" \/ %s\\r\\n\",\n         ntohs(bpdu->bridgeId.priority), macAddrToString(&bpdu->bridgeId.addr, NULL));\n\n      \n      TRACE_DEBUG(\"  Port Identifier = 0x%04\" PRIX16 \"\\r\\n\", ntohs(bpdu->portId));\n\n      \n      t = ntohs(bpdu->messageAge) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Message Age = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->maxAge) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Max Age = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->helloTime) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Hello Time = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->forwardDelay) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Forward Delay = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n   }\n\n   \n   if(length >= RSTP_RST_BPDU_SIZE)\n   {\n      \n      TRACE_DEBUG(\"  Version 1 Length = %\" PRIu8 \"\\r\\n\", bpdu->version1Length);\n   }\n#endif\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid rstpDumpFlags(uint8_t flags)\n{\n   uint8_t role;\n\n   \n   TRACE_DEBUG(\"  Flags = 0x%02\" PRIX8, flags);\n\n   \n   if(flags != 0)\n   {\n      \n      TRACE_DEBUG(\" (\");\n\n      \n      while(flags != 0)\n      {\n         if((flags & RSTP_BPDU_FLAG_TC_ACK) != 0)\n         {\n            \n            TRACE_DEBUG(\"TcAck\");\n            \n            flags &= ~RSTP_BPDU_FLAG_TC_ACK;\n         }\n         else if((flags & RSTP_BPDU_FLAG_AGREEMENT) != 0)\n         {\n            \n            TRACE_DEBUG(\"Agreement\");\n            \n            flags &= ~RSTP_BPDU_FLAG_AGREEMENT;\n         }\n         else if((flags & RSTP_BPDU_FLAG_FORWARDING) != 0)\n         {\n            \n            TRACE_DEBUG(\"Forwarding\");\n            \n            flags &= ~RSTP_BPDU_FLAG_FORWARDING;\n         }\n         else if((flags & RSTP_BPDU_FLAG_LEARNING) != 0)\n         {\n            \n            TRACE_DEBUG(\"Learning\");\n            \n            flags &= ~RSTP_BPDU_FLAG_LEARNING;\n         }\n         else if((flags & RSTP_BPDU_FLAG_PORT_ROLE) != 0)\n         {\n            \n            role = flags & RSTP_BPDU_FLAG_PORT_ROLE;\n\n            \n            if(role == RSTP_BPDU_FLAG_PORT_ROLE_ALT_BACKUP)\n            {\n               TRACE_DEBUG(\"AltBackupRole\");\n            }\n            else if(role == RSTP_BPDU_FLAG_PORT_ROLE_ROOT)\n            {\n               TRACE_DEBUG(\"RootRole\");\n            }\n            else if(role == RSTP_BPDU_FLAG_PORT_ROLE_DESIGNATED)\n            {\n               TRACE_DEBUG(\"DesignatedRole\");\n            }\n\n            \n            flags &= ~RSTP_BPDU_FLAG_PORT_ROLE;\n         }\n         else if((flags & RSTP_BPDU_FLAG_PROPOSAL) != 0)\n         {\n            \n            TRACE_DEBUG(\"Proposal\");\n            \n            flags &= ~RSTP_BPDU_FLAG_PROPOSAL;\n         }\n         else if((flags & RSTP_BPDU_FLAG_TC) != 0)\n         {\n            \n            TRACE_DEBUG(\"Tc\");\n            \n            flags &= ~RSTP_BPDU_FLAG_TC;\n         }\n\n         \n         if(flags != 0)\n         {\n            TRACE_DEBUG(\", \");\n         }\n      }\n\n      \n      TRACE_DEBUG(\")\");\n   }\n\n   \n   TRACE_DEBUG(\"\\r\\n\");\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\n\n\nuint_t rstpAdminEdge(RstpBridgePort *port)\n{\n   \n   return port->params.adminEdgePort;\n}\n\n\n\n\nuint_t rstpAutoEdge(RstpBridgePort *port)\n{\n   \n   return port->params.autoEdgePort;\n}\n\n\n\n\nbool_t rstpAllSynced(RstpBridgeContext *context)\n{\n   uint_t i;\n   bool_t res;\n   RstpBridgePort *port;\n\n   \n   res = TRUE;\n\n   \n   \n   \n   \n   for(i = 0; i < context->numPorts; i++)\n   {\n      \n      port = &context->ports[i];\n\n      \n      if(!port->selected)\n      {\n         res = FALSE;\n      }\n      else if(port->role != port->selectedRole)\n      {\n         res = FALSE;\n      }\n      else if(port->updtInfo)\n      {\n         res = FALSE;\n      }\n      else if(!port->synced && port->role != STP_PORT_ROLE_ROOT)\n      {\n         res = FALSE;\n      }\n      else\n      {\n         \n      }\n   }\n\n   \n   return res;\n}\n\n\n\n\nuint_t rstpEdgeDelay(RstpBridgePort *port)\n{\n   uint_t value;\n\n   \n   \n   if(port->operPointToPointMac)\n   {\n      value = rstpMigrateTime(port->context);\n   }\n   else\n   {\n      value = rstpMaxAge(port);\n   }\n\n   \n   return value;\n}\n\n\n\n\nuint_t rstpForwardDelay(RstpBridgePort *port)\n{\n   uint_t value;\n\n   \n   \n   if(port->sendRstp)\n   {\n      value = rstpHelloTime(port);\n   }\n   else\n   {\n      value = rstpFwdDelay(port);\n   }\n\n   \n   return value;\n}\n\n\n\n\nuint_t rstpFwdDelay(RstpBridgePort *port)\n{\n   \n   return port->designatedTimes.forwardDelay;\n}\n\n\n\n\nuint_t rstpHelloTime(RstpBridgePort *port)\n{\n   \n   return port->designatedTimes.helloTime;\n}\n\n\n\n\nuint_t rstpMaxAge(RstpBridgePort *port)\n{\n   \n   return port->designatedTimes.maxAge;\n}\n\n\n\n\nuint_t rstpMigrateTime(RstpBridgeContext *context)\n{\n   \n   return context->params.migrateTime;\n}\n\n\n\n\nbool_t rstpReRooted(RstpBridgePort *port)\n{\n   uint_t i;\n   bool_t res;\n   RstpBridgeContext *context;\n\n   \n   res = TRUE;\n\n   \n   context = port->context;\n\n   \n   for(i = 0; i < context->numPorts; i++)\n   {\n      \n      if(&context->ports[i] != port && context->ports[i].rrWhile != 0)\n      {\n         res = FALSE;\n      }\n   }\n\n   \n   \n   return res;\n}\n\n\n\n\nbool_t rstpVersion(RstpBridgeContext *context)\n{\n   bool_t res;\n\n   \n   if(context->params.forceProtocolVersion >= RSTP_PROTOCOL_VERSION)\n   {\n      \n      res = TRUE;\n   }\n   else\n   {\n      \n      res = FALSE;\n   }\n\n   \n   return res;\n}\n\n\n\n\nbool_t stpVersion(RstpBridgeContext *context)\n{\n   \n   return !rstpVersion(context);\n}\n\n\n\n\nuint_t rstpTxHoldCount(RstpBridgeContext *context)\n{\n   \n   return context->params.transmitHoldCount;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\n\n\nvoid rstpFsmInit(RstpBridgeContext *context)\n{\n   uint_t i;\n   RstpBridgePort *port;\n\n   \n   \n   \n   context->bridgePriority.rootBridgeId = context->bridgeId;\n   context->bridgePriority.rootPathCost = 0;\n   context->bridgePriority.designatedBridgeId = context->bridgeId;\n   context->bridgePriority.designatedPortId = 0;\n   context->bridgePriority.bridgePortId = 0;\n\n   \n   \n   context->bridgeTimes.forwardDelay = context->params.bridgeForwardDelay;\n   context->bridgeTimes.helloTime = context->params.bridgeHelloTime;\n   context->bridgeTimes.maxAge = context->params.bridgeMaxAge;\n   context->bridgeTimes.messageAge = 0;\n\n   \n   context->rootPriority = context->bridgePriority;\n   \n   context->rootTimes = context->bridgeTimes;\n\n   \n   context->ageingTime = context->params.ageingTime;\n   \n   context->rapidAgeingWhile = 0;\n\n   \n   rstpUpdateAgeingTime(context, context->params.ageingTime);\n\n   \n   osMemset(&context->bpdu, 0, sizeof(RstpBpdu));\n\n   \n   for(i = 0; i < context->numPorts; i++)\n   {\n      \n      port = &context->ports[i];\n\n      \n      \n      \n      port->designatedTimes = context->rootTimes;\n      port->designatedTimes.helloTime = context->bridgeTimes.helloTime;\n\n      \n      memset(&port->msgPriority, 0, sizeof(RstpPriority));\n      memset(&port->msgTimes, 0, sizeof(RstpTimes));\n\n      \n      port->disputed = FALSE;\n      port->rcvdInfo = RSTP_RCVD_INFO_OTHER;\n      port->rcvdTc = FALSE;\n      port->rcvdTcAck = FALSE;\n      port->rcvdTcn = FALSE;\n      port->tcProp = FALSE;\n      port->updtInfo = FALSE;\n   }\n\n   \n   \n   rstpPrsInit(context);\n\n   \n   for(i = 0; i < context->numPorts; i++)\n   {\n      \n      port = &context->ports[i];\n\n      \n      rstpPtiInit(port);\n      \n      rstpPrxInit(port);\n      \n      rstpPpmInit(port);\n      \n      rstpBdmInit(port);\n      \n      rstpPtxInit(port);\n      \n      rstpPimInit(port);\n      \n      rstpPrtInit(port);\n      \n      rstpPstInit(port);\n      \n      rstpTcmInit(port);\n   }\n\n   \n   rstpFsm(context);\n}\n\n\n\n\nvoid rstpFsm(RstpBridgeContext *context)\n{\n   uint_t i;\n   RstpBridgePort *port;\n\n   \n   \n   do\n   {\n      \n      context->busy = FALSE;\n\n      \n      \n      rstpPrsFsm(context);\n\n      \n      \n      for(i = 0; i < context->numPorts; i++)\n      {\n         \n         port = &context->ports[i];\n\n         \n         rstpPtiFsm(port);\n         \n         rstpPrxFsm(port);\n         \n         rstpPpmFsm(port);\n         \n         rstpBdmFsm(port);\n         \n         rstpPimFsm(port);\n         \n         rstpPrtFsm(port);\n         \n         rstpPstFsm(port);\n         \n         rstpTcmFsm(port);\n\n         \n         \n         if(port->fdbFlush)\n         {\n            \n            rstpRemoveFdbEntries(port);\n         }\n      }\n\n      \n      if(!context->busy)\n      {\n         \n         for(i = 0; i < context->numPorts; i++)\n         {\n            \n            port = &context->ports[i];\n\n            \n            rstpPtxFsm(port);\n         }\n      }\n\n      \n      \n   } while(context->busy);\n}\n\n\n\n\nvoid rstpFsmError(RstpBridgeContext *context)\n{\n   \n   TRACE_ERROR(\"RSTP finite state machine error!\\r\\n\");\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL SNMP_TRACE_LEVEL\n\n\n#include \"core\/net.h\"\n#include \"mibs\/mib_common.h\"\n#include \"mibs\/rstp_mib_module.h\"\n#include \"mibs\/rstp_mib_impl.h\"\n#include \"core\/crypto.h\"\n#include \"encoding\/asn1.h\"\n#include \"encoding\/oid.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_MIB_SUPPORT == ENABLED)\n\n\n\n\nRstpMibBase rstpMibBase;\n\n\n\n\nconst MibObject rstpMibObjects[] =\n{\n   \n   {\n      \"dot1dStpVersion\",\n      {43, 6, 1, 2, 1, 17, 2, 16},\n      8,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpVersion,\n      rstpMibGetDot1dStpVersion,\n      NULL\n   },\n   \n   {\n      \"dot1dStpTxHoldCount\",\n      {43, 6, 1, 2, 1, 17, 2, 17},\n      8,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpTxHoldCount,\n      rstpMibGetDot1dStpTxHoldCount,\n      NULL\n   },\n   \n   {\n      \"dot1dStpPortProtocolMigration\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 1},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpExtPortEntry,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   },\n   \n   {\n      \"dot1dStpPortAdminEdgePort\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 2},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpExtPortEntry,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   },\n   \n   {\n      \"dot1dStpPortOperEdgePort\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 3},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_ONLY,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      NULL,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   },\n   \n   {\n      \"dot1dStpPortAdminPointToPoint\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 4},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpExtPortEntry,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   },\n   \n   {\n      \"dot1dStpPortOperPointToPoint\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 5},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_ONLY,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      NULL,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   },\n   \n   {\n      \"dot1dStpPortAdminPathCost\",\n      {43, 6, 1, 2, 1, 17, 2, 19, 1, 6},\n      10,\n      ASN1_CLASS_UNIVERSAL,\n      ASN1_TYPE_INTEGER,\n      MIB_ACCESS_READ_WRITE,\n      NULL,\n      NULL,\n      sizeof(int32_t),\n      rstpMibSetDot1dStpExtPortEntry,\n      rstpMibGetDot1dStpExtPortEntry,\n      rstpMibGetNextDot1dStpExtPortEntry\n   }\n};\n\n\n\n\nconst MibModule rstpMibModule =\n{\n   \"RSTP-MIB\",\n   {43, 6, 1, 2, 1, 129, 6},\n   7,\n   rstpMibObjects,\n   arraysize(rstpMibObjects),\n   rstpMibInit,\n   NULL,\n   NULL,\n   NULL,\n   NULL\n};\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_pim.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPimStates[] =\n{\n   {RSTP_PIM_STATE_DISABLED,            \"DISABLED\"},\n   {RSTP_PIM_STATE_AGED,                \"AGED\"},\n   {RSTP_PIM_STATE_UPDATE,              \"UPDATE\"},\n   {RSTP_PIM_STATE_SUPERIOR_DESIGNATED, \"SUPERIOR_DESIGNATED\"},\n   {RSTP_PIM_STATE_REPEATED_DESIGNATED, \"REPEATED_DESIGNATED\"},\n   {RSTP_PIM_STATE_INFERIOR_DESIGNATED, \"INFERIOR_DESIGNATED\"},\n   {RSTP_PIM_STATE_NOT_DESIGNATED,      \"NOT_DESIGNATED\"},\n   {RSTP_PIM_STATE_OTHER,               \"OTHER\"},\n   {RSTP_PIM_STATE_CURRENT,             \"CURRENT\"},\n   {RSTP_PIM_STATE_RECEIVE,             \"RECEIVE\"}\n};\n\n\n\n\nvoid rstpPimInit(RstpBridgePort *port)\n{\n   \n   rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);\n}\n\n\n\n\nvoid rstpPimFsm(RstpBridgePort *port)\n{\n   \n   if(!port->portEnabled && port->infoIs != RSTP_INFO_IS_DISABLED)\n   {\n      \n      \n      rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);\n   }\n   else\n   {\n      \n      \n      switch(port->pimState)\n      {\n      \n      case RSTP_PIM_STATE_DISABLED:\n         \n         if(port->rcvdMsg)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);\n         }\n         else if(port->portEnabled)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);\n         }\n         else\n         {\n            \n         }\n\n         break;\n\n      \n      case RSTP_PIM_STATE_AGED:\n         \n         if(port->selected && port->updtInfo)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);\n         }\n\n         break;\n\n      \n      \n      case RSTP_PIM_STATE_UPDATE:\n      case RSTP_PIM_STATE_SUPERIOR_DESIGNATED:\n      case RSTP_PIM_STATE_REPEATED_DESIGNATED:\n      case RSTP_PIM_STATE_INFERIOR_DESIGNATED:\n      case RSTP_PIM_STATE_NOT_DESIGNATED:\n      case RSTP_PIM_STATE_OTHER:\n         \n         rstpPimChangeState(port, RSTP_PIM_STATE_CURRENT);\n         break;\n\n      \n      case RSTP_PIM_STATE_CURRENT:\n         \n         if(port->selected && port->updtInfo)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);\n         }\n         else if(port->infoIs == RSTP_INFO_IS_RECEIVED &&\n            port->rcvdInfoWhile == 0 && !port->updtInfo && !port->rcvdMsg)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);\n         }\n         else if(port->rcvdMsg && !port->updtInfo)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_RECEIVE);\n         }\n         else\n         {\n            \n         }\n\n         break;\n\n      \n      case RSTP_PIM_STATE_RECEIVE:\n         \n         if(port->rcvdInfo == RSTP_RCVD_INFO_SUPERIOR_DESIGNATED)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_SUPERIOR_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_REPEATED_DESIGNATED)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_REPEATED_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_DESIGNATED)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_INFERIOR_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_ROOT_ALTERNATE)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_NOT_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_OTHER)\n         {\n            \n            rstpPimChangeState(port, RSTP_PIM_STATE_OTHER);\n         }\n         else\n         {\n            \n         }\n\n         break;\n\n      \n      default:\n         \n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}\n\n\n\n\nvoid rstpPimChangeState(RstpBridgePort *port, RstpPimState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": PIM state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->pimState, rstpPimStates, arraysize(rstpPimStates)),\n      rstpGetParamName(newState, rstpPimStates, arraysize(rstpPimStates)));\n\n   \n   port->pimState = newState;\n\n   \n   \n   switch(port->pimState)\n   {\n   \n   case RSTP_PIM_STATE_DISABLED:\n      \n      port->rcvdMsg = FALSE;\n      port->proposing = FALSE;\n      port->proposed = FALSE;\n      port->agree = FALSE;\n      port->agreed = FALSE;\n      port->rcvdInfoWhile = 0;\n      port->infoIs = RSTP_INFO_IS_DISABLED;\n      port->reselect = TRUE;\n      port->selected = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_AGED:\n      \n      port->infoIs = RSTP_INFO_IS_AGED;\n      port->reselect = TRUE;\n      port->selected = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_UPDATE:\n      port->proposing = FALSE;\n      port->proposed = FALSE;\n\n      \n      port->agreed = port->agreed &&\n         rstpBetterOrSameInfo(port, RSTP_INFO_IS_MINE);\n\n#if defined(RSTP_PIM_WORKAROUND_1)\n      \n      if(port->forward)\n      {\n         port->agreed = port->sendRstp;\n      }\n#endif\n\n      port->synced = port->synced && port->agreed;\n      port->portPriority = port->designatedPriority;\n      port->portTimes = port->designatedTimes;\n      port->updtInfo = FALSE;\n      port->infoIs = RSTP_INFO_IS_MINE;\n      port->newInfo = TRUE;\n      break;\n\n   \n   case RSTP_PIM_STATE_SUPERIOR_DESIGNATED:\n      port->agreed = FALSE;\n      port->proposing = FALSE;\n      rstpRecordProposal(port);\n      rstpSetTcFlags(port);\n\n      \n      port->agree = port->agree &&\n         rstpBetterOrSameInfo(port, RSTP_INFO_IS_RECEIVED);\n\n      rstpRecordPriority(port);\n      rstpRecordTimes(port);\n      rstpUpdtRcvdInfoWhile(port);\n      port->infoIs = RSTP_INFO_IS_RECEIVED;\n      port->reselect = TRUE;\n      port->selected = FALSE;\n      port->rcvdMsg = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_REPEATED_DESIGNATED:\n      rstpRecordProposal(port);\n      rstpSetTcFlags(port);\n      rstpUpdtRcvdInfoWhile(port);\n      port->rcvdMsg = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_INFERIOR_DESIGNATED:\n      rstpRecordDispute(port);\n      port->rcvdMsg = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_NOT_DESIGNATED:\n      rstpRecordAgreement(port);\n      rstpSetTcFlags(port);\n      port->rcvdMsg = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_OTHER:\n      port->rcvdMsg = FALSE;\n      break;\n\n   \n   case RSTP_PIM_STATE_CURRENT:\n      \n      break;\n\n   \n   case RSTP_PIM_STATE_RECEIVE:\n      port->rcvdInfo = rstpRcvInfo(port);\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_ppm.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPpmStates[] =\n{\n   {RSTP_PPM_STATE_CHECKING_RSTP, \"CHECKING_RSTP\"},\n   {RSTP_PPM_STATE_SELECTING_STP, \"SELECTING_STP\"},\n   {RSTP_PPM_STATE_SENSING,       \"SENSING\"}\n};\n\n\n\n\nvoid rstpPpmInit(RstpBridgePort *port)\n{\n   \n   rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);\n}\n\n\n\n\nvoid rstpPpmFsm(RstpBridgePort *port)\n{\n   \n   \n   switch(port->ppmState)\n   {\n   \n   case RSTP_PPM_STATE_CHECKING_RSTP:\n      \n      if(port->mdelayWhile == 0)\n      {\n         \n         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);\n      }\n      else if(port->mdelayWhile != rstpMigrateTime(port->context) &&\n         !port->portEnabled)\n      {\n         \n         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   case RSTP_PPM_STATE_SELECTING_STP:\n      \n      if(port->mdelayWhile == 0 || !port->portEnabled || port->mcheck)\n      {\n         \n         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);\n      }\n\n      break;\n\n   \n   case RSTP_PPM_STATE_SENSING:\n      \n      if(port->sendRstp && port->rcvdStp)\n      {\n         \n         rstpPpmChangeState(port, RSTP_PPM_STATE_SELECTING_STP);\n      }\n      else if(!port->portEnabled || port->mcheck ||\n         (rstpVersion(port->context) && !port->sendRstp && port->rcvdRstp))\n      {\n         \n         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   default:\n      \n      rstpFsmError(port->context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpPpmChangeState(RstpBridgePort *port, RstpPpmState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": PPM state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->ppmState, rstpPpmStates, arraysize(rstpPpmStates)),\n      rstpGetParamName(newState, rstpPpmStates, arraysize(rstpPpmStates)));\n\n   \n   port->ppmState = newState;\n\n   \n   \n   switch(port->ppmState)\n   {\n   \n   case RSTP_PPM_STATE_CHECKING_RSTP:\n      \n      port->mcheck = FALSE;\n\n      \n      \n      \n      port->sendRstp = rstpVersion(port->context);\n\n      \n      port->mdelayWhile = rstpMigrateTime(port->context);\n      break;\n\n   \n   case RSTP_PPM_STATE_SELECTING_STP:\n      \n      port->sendRstp = FALSE;\n\n      \n      port->mdelayWhile = rstpMigrateTime(port->context);\n      break;\n\n   \n   case RSTP_PPM_STATE_SENSING:\n      \n      port->rcvdRstp = FALSE;\n      port->rcvdStp = FALSE;\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_prs.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPrsStates[] =\n{\n   {RSTP_PRS_STATE_INIT_BRIDGE,    \"INIT_BRIDGE\"},\n   {RSTP_PRS_STATE_ROLE_SELECTION, \"ROLE_SELECTION\"}\n};\n\n\n\n\nvoid rstpPrsInit(RstpBridgeContext *context)\n{\n   \n   rstpPrsChangeState(context, RSTP_PRS_STATE_INIT_BRIDGE);\n}\n\n\n\n\nvoid rstpPrsFsm(RstpBridgeContext *context)\n{\n   uint_t i;\n   bool_t reselect;\n\n   \n   \n   switch(context->prsState)\n   {\n   \n   case RSTP_PRS_STATE_INIT_BRIDGE:\n      \n      rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);\n      break;\n\n   \n   case RSTP_PRS_STATE_ROLE_SELECTION:\n      \n      for(reselect = FALSE, i = 0; i < context->numPorts; i++)\n      {\n         reselect |= context->ports[i].reselect;\n      }\n\n      \n      \n      if(reselect)\n      {\n         rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);\n      }\n\n      break;\n\n   \n   default:\n      \n      rstpFsmError(context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpPrsChangeState(RstpBridgeContext *context, RstpPrsState newState)\n{\n   \n   TRACE_VERBOSE(\"PRS state machine %s -> %s\\r\\n\",\n      rstpGetParamName(context->prsState, rstpPrsStates, arraysize(rstpPrsStates)),\n      rstpGetParamName(newState, rstpPrsStates, arraysize(rstpPrsStates)));\n\n   \n   context->prsState = newState;\n\n   \n   \n   switch(context->prsState)\n   {\n   \n   case RSTP_PRS_STATE_INIT_BRIDGE:\n      \n      rstpUpdtRoleDisabledTree(context);\n      break;\n\n   \n   case RSTP_PRS_STATE_ROLE_SELECTION:\n      \n      rstpClearReselectTree(context);\n      rstpUpdtRolesTree(context);\n      rstpSetSelectedTree(context);\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_prx.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPrxStates[] =\n{\n   {RSTP_PRX_STATE_DISCARD, \"DISCARD\"},\n   {RSTP_PRX_STATE_RECEIVE, \"RECEIVE\"}\n};\n\n\n\n\nvoid rstpPrxInit(RstpBridgePort *port)\n{\n   \n   rstpPrxChangeState(port, RSTP_PRX_STATE_DISCARD);\n}\n\n\n\n\nvoid rstpPrxFsm(RstpBridgePort *port)\n{\n   \n   if((port->rcvdBpdu || port->edgeDelayWhile != rstpMigrateTime(port->context)) &&\n      !port->portEnabled)\n   {\n      \n      \n      rstpPrxChangeState(port, RSTP_PRX_STATE_DISCARD);\n   }\n   else\n   {\n      \n      \n      switch(port->prxState)\n      {\n      \n      case RSTP_PRX_STATE_DISCARD:\n         \n         if(port->rcvdBpdu && port->portEnabled)\n         {\n            \n            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);\n         }\n\n         break;\n\n      \n      case RSTP_PRX_STATE_RECEIVE:\n         \n         if(port->rcvdBpdu && port->portEnabled && !port->rcvdMsg)\n         {\n            \n            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);\n         }\n\n         break;\n\n      \n      default:\n         \n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}\n\n\n\n\nvoid rstpPrxChangeState(RstpBridgePort *port, RstpPrxState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": PRX state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->prxState, rstpPrxStates, arraysize(rstpPrxStates)),\n      rstpGetParamName(newState, rstpPrxStates, arraysize(rstpPrxStates)));\n\n   \n   port->prxState = newState;\n\n   \n   \n   switch(port->prxState)\n   {\n   \n   case RSTP_PRX_STATE_DISCARD:\n      \n      port->rcvdBpdu = FALSE;\n      port->rcvdRstp = FALSE;\n      port->rcvdStp = FALSE;\n      port->rcvdMsg = FALSE;\n\n      \n      port->edgeDelayWhile = rstpMigrateTime(port->context);\n      break;\n\n   \n   case RSTP_PRX_STATE_RECEIVE:\n      \n      \n      rstpUpdtBpduVersion(port);\n      port->operEdge = FALSE;\n      port->rcvdBpdu = FALSE;\n\n      \n      \n      port->rcvdMsg = TRUE;\n\n      \n      port->edgeDelayWhile = rstpMigrateTime(port->context);\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_pst.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPstStates[] =\n{\n   {RSTP_PST_STATE_DISCARDING, \"DISCARDING\"},\n   {RSTP_PST_STATE_LEARNING,   \"LEARNING\"},\n   {RSTP_PST_STATE_FORWARDING, \"FORWARDING\"}\n};\n\n\n\n\nvoid rstpPstInit(RstpBridgePort *port)\n{\n   \n   rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);\n}\n\n\n\n\nvoid rstpPstFsm(RstpBridgePort *port)\n{\n   \n   \n   switch(port->pstState)\n   {\n   \n   case RSTP_PST_STATE_DISCARDING:\n      \n      if(port->learn)\n      {\n         \n         rstpPstChangeState(port, RSTP_PST_STATE_LEARNING);\n      }\n\n      break;\n\n   \n   case RSTP_PST_STATE_LEARNING:\n      \n      if(port->forward)\n      {\n         \n         rstpPstChangeState(port, RSTP_PST_STATE_FORWARDING);\n      }\n      else if(!port->learn)\n      {\n         \n         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   case RSTP_PST_STATE_FORWARDING:\n      \n      if(!port->forward)\n      {\n         \n         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);\n      }\n\n      break;\n\n   \n   default:\n      \n      rstpFsmError(port->context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpPstChangeState(RstpBridgePort *port, RstpPstState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": PST state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->pstState, rstpPstStates, arraysize(rstpPstStates)),\n      rstpGetParamName(newState, rstpPstStates, arraysize(rstpPstStates)));\n\n   \n   port->pstState = newState;\n\n   \n   \n   switch(port->pstState)\n   {\n   \n   case RSTP_PST_STATE_DISCARDING:\n      \n      rstpDisableLearning(port);\n      port->learning = FALSE;\n      rstpDisableForwarding(port);\n      port->forwarding = FALSE;\n      break;\n\n   \n   case RSTP_PST_STATE_LEARNING:\n      \n      rstpEnableLearning(port);\n      port->learning = TRUE;\n      break;\n\n   \n   case RSTP_PST_STATE_FORWARDING:\n      \n      rstpEnableForwarding(port);\n      port->forwarding = TRUE;\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_pti.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPtiStates[] =\n{\n   {RSTP_PTI_STATE_ONE_SECOND, \"ONE_SECOND\"},\n   {RSTP_PTI_STATE_TICK,       \"TICK\"}\n};\n\n\n\n\nvoid rstpPtiInit(RstpBridgePort *port)\n{\n   \n   \n   rstpPtiChangeState(port, RSTP_PTI_STATE_ONE_SECOND);\n}\n\n\n\n\nvoid rstpPtiFsm(RstpBridgePort *port)\n{\n   \n   \n   switch(port->ptiState)\n   {\n   \n   case RSTP_PTI_STATE_ONE_SECOND:\n      \n      if(port->tick)\n      {\n         rstpPtiChangeState(port, RSTP_PTI_STATE_TICK);\n      }\n\n      break;\n\n   \n   case RSTP_PTI_STATE_TICK:\n      \n      \n      rstpPtiChangeState(port, RSTP_PTI_STATE_ONE_SECOND);\n      break;\n\n   \n   default:\n      \n      rstpFsmError(port->context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpPtiChangeState(RstpBridgePort *port, RstpPtiState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": PTI state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->ptiState, rstpPtiStates, arraysize(rstpPtiStates)),\n      rstpGetParamName(newState, rstpPtiStates, arraysize(rstpPtiStates)));\n\n   \n   port->ptiState = newState;\n\n   \n   \n   switch(port->ptiState)\n   {\n   \n   case RSTP_PTI_STATE_ONE_SECOND:\n      \n      port->tick = FALSE;\n      break;\n\n   \n   case RSTP_PTI_STATE_TICK:\n      \n      rstpDecrementTimer(&port->helloWhen);\n      rstpDecrementTimer(&port->tcWhile);\n      rstpDecrementTimer(&port->fdWhile);\n      rstpDecrementTimer(&port->rcvdInfoWhile);\n      rstpDecrementTimer(&port->rrWhile);\n      rstpDecrementTimer(&port->rbWhile);\n      rstpDecrementTimer(&port->mdelayWhile);\n      rstpDecrementTimer(&port->edgeDelayWhile);\n      rstpDecrementTimer(&port->txCount);\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_ptx.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_conditions.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpPtxStates[] =\n{\n   {RSTP_PTX_STATE_TRANSMIT_INIT,     \"TRANSMIT_INIT\"},\n   {RSTP_PTX_STATE_TRANSMIT_PERIODIC, \"TRANSMIT_PERIODIC\"},\n   {RSTP_PTX_STATE_TRANSMIT_CONFIG,   \"TRANSMIT_CONFIG\"},\n   {RSTP_PTX_STATE_TRANSMIT_TCN,      \"TRANSMIT_TCN\"},\n   {RSTP_PTX_STATE_TRANSMIT_RSTP,     \"TRANSMIT_RSTP\"},\n   {RSTP_PTX_STATE_IDLE,              \"IDLE\"}\n};\n\n\n\n\nvoid rstpPtxInit(RstpBridgePort *port)\n{\n   \n   rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_INIT);\n}\n\n\n\n\nvoid rstpPtxFsm(RstpBridgePort *port)\n{\n   RstpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   if(!port->portEnabled)\n   {\n      \n      \n      rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_INIT);\n   }\n   else\n   {\n      \n      \n      switch(port->ptxState)\n      {\n      \n      \n      case RSTP_PTX_STATE_TRANSMIT_INIT:\n      case RSTP_PTX_STATE_TRANSMIT_PERIODIC:\n      case RSTP_PTX_STATE_TRANSMIT_CONFIG:\n      case RSTP_PTX_STATE_TRANSMIT_TCN:\n      case RSTP_PTX_STATE_TRANSMIT_RSTP:\n         \n         rstpPtxChangeState(port, RSTP_PTX_STATE_IDLE);\n         break;\n\n      \n      case RSTP_PTX_STATE_IDLE:\n         \n         if(port->selected && !port->updtInfo)\n         {\n            \n            \n            if(port->helloWhen == 0)\n            {\n               \n               rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_PERIODIC);\n            }\n            else\n            {\n               \n               if(port->newInfo)\n               {\n                  \n                  if(port->txCount < rstpTxHoldCount(context))\n                  {\n                     \n                     if(port->sendRstp)\n                     {\n                        \n                        rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_RSTP);\n                     }\n                     else\n                     {\n                        \n                        if(port->role == STP_PORT_ROLE_ROOT)\n                        {\n                           \n                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_TCN);\n                        }\n                        else if(port->role == STP_PORT_ROLE_DESIGNATED)\n                        {\n                           \n                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_CONFIG);\n                        }\n                        else\n                        {\n                           \n                        }\n                     }\n                  }\n               }\n            }\n         }\n\n         break;\n\n      \n      default:\n         \n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}\n\n\n\n\nvoid rstpPtxChangeState(RstpBridgePort *port, RstpPtxState newState)\n{\n   \n   if(port->ptxState != newState)\n   {\n      \n      TRACE_VERBOSE(\"Port %\" PRIu8 \": PTX state machine %s -> %s\\r\\n\",\n         port->portIndex,\n         rstpGetParamName(port->ptxState, rstpPtxStates, arraysize(rstpPtxStates)),\n         rstpGetParamName(newState, rstpPtxStates, arraysize(rstpPtxStates)));\n   }\n\n   \n   port->ptxState = newState;\n\n   \n   \n   switch(port->ptxState)\n   {\n   \n   case RSTP_PTX_STATE_TRANSMIT_INIT:\n      \n      port->newInfo = TRUE;\n      port->txCount = 0;\n      break;\n\n   \n   case RSTP_PTX_STATE_TRANSMIT_PERIODIC:\n      \n      if(port->role == STP_PORT_ROLE_DESIGNATED)\n      {\n         \n         port->newInfo = TRUE;\n      }\n      else if(port->role == STP_PORT_ROLE_ROOT)\n      {\n         \n         if(port->tcWhile != 0)\n         {\n            \n            port->newInfo = TRUE;\n         }\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   case RSTP_PTX_STATE_TRANSMIT_CONFIG:\n      \n      port->newInfo = FALSE;\n      rstpTxConfig(port);\n      port->txCount++;\n      port->tcAck = FALSE;\n      break;\n\n   \n   case RSTP_PTX_STATE_TRANSMIT_TCN:\n      \n      port->newInfo = FALSE;\n      rstpTxTcn(port);\n      port->txCount++;\n      break;\n\n   \n   case RSTP_PTX_STATE_TRANSMIT_RSTP:\n      \n      port->newInfo = FALSE;\n      rstpTxRstp(port);\n      port->txCount++;\n      port->tcAck = FALSE;\n      break;\n\n   \n   case RSTP_PTX_STATE_IDLE:\n      \n      port->helloWhen = rstpHelloTime(port);\n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   if(port->portEnabled)\n   {\n      \n      port->context->busy = TRUE;\n   }\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL RSTP_TRACE_LEVEL\n\n\n#include \"rstp\/rstp.h\"\n#include \"rstp\/rstp_fsm.h\"\n#include \"rstp\/rstp_tcm.h\"\n#include \"rstp\/rstp_procedures.h\"\n#include \"rstp\/rstp_misc.h\"\n#include \"debug.h\"\n\n\n#if (RSTP_SUPPORT == ENABLED)\n\n\nconst RstpParamName rstpTcmStates[] =\n{\n   {RSTP_TCM_STATE_INACTIVE,     \"INACTIVE\"},\n   {RSTP_TCM_STATE_LEARNING,     \"LEARNING\"},\n   {RSTP_TCM_STATE_DETECTED,     \"DETECTED\"},\n   {RSTP_TCM_STATE_NOTIFIED_TCN, \"NOTIFIED_TCN\"},\n   {RSTP_TCM_STATE_NOTIFIED_TC,  \"NOTIFIED_TC\"},\n   {RSTP_TCM_STATE_PROPAGATING,  \"PROPAGATING\"},\n   {RSTP_TCM_STATE_ACKNOWLEDGED, \"ACKNOWLEDGED\"},\n   {RSTP_TCM_STATE_ACTIVE,       \"ACTIVE\"}\n};\n\n\n\n\nvoid rstpTcmInit(RstpBridgePort *port)\n{\n   \n   rstpTcmChangeState(port, RSTP_TCM_STATE_INACTIVE);\n}\n\n\n\n\nvoid rstpTcmFsm(RstpBridgePort *port)\n{\n   \n   \n   switch(port->tcmState)\n   {\n   \n   case RSTP_TCM_STATE_INACTIVE:\n      \n      if(port->learn && !port->fdbFlush)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n\n      break;\n\n   \n   case RSTP_TCM_STATE_LEARNING:\n      \n      if(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n      else if((port->role == STP_PORT_ROLE_ROOT ||\n         port->role == STP_PORT_ROLE_DESIGNATED) &&\n         port->forward && !port->operEdge)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_DETECTED);\n      }\n      else if(port->role != STP_PORT_ROLE_ROOT &&\n         port->role != STP_PORT_ROLE_DESIGNATED &&\n         !(port->learn || port->learning) &&\n         !(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp))\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_INACTIVE);\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   case RSTP_TCM_STATE_NOTIFIED_TCN:\n      \n      rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);\n      break;\n\n   \n   case RSTP_TCM_STATE_DETECTED:\n   case RSTP_TCM_STATE_NOTIFIED_TC:\n   case RSTP_TCM_STATE_PROPAGATING:\n   case RSTP_TCM_STATE_ACKNOWLEDGED:\n      \n      rstpTcmChangeState(port, RSTP_TCM_STATE_ACTIVE);\n      break;\n\n   \n   case RSTP_TCM_STATE_ACTIVE:\n      \n      if((port->role != STP_PORT_ROLE_ROOT &&\n         port->role != STP_PORT_ROLE_DESIGNATED) || port->operEdge)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n      else if(port->rcvdTcn)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TCN);\n      }\n      else if(port->rcvdTc)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);\n      }\n      else if(port->tcProp && !port->operEdge)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_PROPAGATING);\n      }\n      else if(port->rcvdTcAck)\n      {\n         \n         rstpTcmChangeState(port, RSTP_TCM_STATE_ACKNOWLEDGED);\n      }\n      else\n      {\n         \n      }\n\n      break;\n\n   \n   default:\n      \n      rstpFsmError(port->context);\n      break;\n   }\n}\n\n\n\n\nvoid rstpTcmChangeState(RstpBridgePort *port, RstpTcmState newState)\n{\n   \n   TRACE_VERBOSE(\"Port %\" PRIu8 \": TCM state machine %s -> %s\\r\\n\",\n      port->portIndex,\n      rstpGetParamName(port->tcmState, rstpTcmStates, arraysize(rstpTcmStates)),\n      rstpGetParamName(newState, rstpTcmStates, arraysize(rstpTcmStates)));\n\n   \n   port->tcmState = newState;\n\n   \n   \n   switch(port->tcmState)\n   {\n   \n   case RSTP_TCM_STATE_INACTIVE:\n      port->fdbFlush = TRUE;\n      port->tcWhile = 0;\n      port->tcAck = FALSE;\n      break;\n\n   \n   case RSTP_TCM_STATE_LEARNING:\n      port->rcvdTc = FALSE;\n      port->rcvdTcn = FALSE;\n      port->rcvdTcAck = FALSE;\n      port->tcProp = FALSE;\n      break;\n\n   \n   case RSTP_TCM_STATE_DETECTED:\n      rstpNewTcWhile(port);\n      rstpSetTcPropTree(port);\n      port->newInfo = TRUE;\n      break;\n\n   \n   case RSTP_TCM_STATE_NOTIFIED_TCN:\n      rstpNewTcWhile(port);\n      break;\n\n   \n   case RSTP_TCM_STATE_NOTIFIED_TC:\n      port->rcvdTcn = FALSE;\n      port->rcvdTc = FALSE;\n\n      if(port->role == STP_PORT_ROLE_DESIGNATED)\n      {\n         port->tcAck = TRUE;\n      }\n\n      \n      rstpSetTcPropTree(port);\n      break;\n\n   \n   case RSTP_TCM_STATE_PROPAGATING:\n      rstpNewTcWhile(port);\n      port->fdbFlush = TRUE;\n      port->tcProp = FALSE;\n      break;\n\n   \n   case RSTP_TCM_STATE_ACKNOWLEDGED:\n      port->tcWhile = 0;\n      port->rcvdTcAck = FALSE;\n      break;\n\n   \n   case RSTP_TCM_STATE_ACTIVE:\n      \n      break;\n\n   \n   default:\n      \n      break;\n   }\n\n   \n   port->context->busy = TRUE;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL STP_TRACE_LEVEL\n\n\n#include \"stp\/stp.h\"\n#include \"stp\/stp_operation.h\"\n#include \"stp\/stp_bpdu.h\"\n#include \"stp\/stp_misc.h\"\n#include \"debug.h\"\n\n\n#if (STP_SUPPORT == ENABLED)\n\n\nconst MacAddr STP_BRIDGE_GROUP_ADDR = {{{0x01, 0x80, 0xC2, 0x00, 0x00, 0x00}}};\n\n\nconst StpParamName stpProtocolVersions[] =\n{\n   {STP_PROTOCOL_VERSION, \"STP\"}\n};\n\n\nconst StpParamName stpBpduTypes[] =\n{\n   {STP_BPDU_TYPE_CONFIG, \"CONFIG\"},\n   {STP_BPDU_TYPE_TCN,    \"TCN\"}\n};\n\n\n\n\nvoid stpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,\n   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)\n{\n   const LlcHeader *llcHeader;\n   const StpBpdu *bpdu;\n   StpBridgeContext *context;\n   StpBridgePort *port;\n\n   \n   context = (StpBridgeContext *) param;\n\n   \n   \n   if(!macCompAddr(&ethHeader->destAddr, &STP_BRIDGE_GROUP_ADDR))\n      return;\n\n   \n   if(length < sizeof(LlcHeader))\n      return;\n\n   \n   llcHeader = (LlcHeader *) data;\n\n   \n   \n   \n   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||\n      llcHeader->control != STP_LLC_CTRL)\n   {\n      return;\n   }\n\n   \n   if(ancillary->port < 1 || ancillary->port > context->numPorts)\n      return;\n\n   \n   port = &context->ports[ancillary->port - 1];\n\n   \n   bpdu = (StpBpdu *) (data + sizeof(LlcHeader));\n\n   \n   length -= sizeof(LlcHeader);\n\n   \n   stpProcessBpdu(port, bpdu, length);\n}\n\n\n\n\nerror_t stpProcessBpdu(StpBridgePort *port, const StpBpdu *bpdu,\n   size_t length)\n{\n   \n   TRACE_INFO(\"Port %\" PRIu8 \": BPDU received (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      port->portIndex, length);\n\n   \n   stpDumpBpdu(bpdu, length);\n\n   \n   if(length < STP_MIN_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   if(ntohs(bpdu->protocolId) != STP_PROTOCOL_ID)\n      return ERROR_INVALID_LENGTH;\n\n   \n   if(bpdu->bpduType == STP_BPDU_TYPE_CONFIG)\n   {\n      \n      if(length < STP_CONFIG_BPDU_SIZE)\n         return ERROR_INVALID_LENGTH;\n\n      \n      if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))\n         return ERROR_INVALID_PACKET;\n\n      \n      stpReceivedConfigBpdu(port, bpdu);\n   }\n   else if(bpdu->bpduType == STP_BPDU_TYPE_TCN)\n   {\n      \n      stpReceivedTcnBpdu(port, bpdu);\n   }\n   else\n   {\n      \n      return ERROR_INVALID_TYPE;\n   }\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nerror_t stpSendBpdu(StpBridgePort *port, const StpBpdu *bpdu,\n   size_t length)\n{\n   error_t error;\n   size_t offset;\n   LlcHeader *llcHeader;\n   NetBuffer *buffer;\n   NetTxAncillary ancillary;\n   StpBridgeContext *context;\n\n   \n   TRACE_INFO(\"Port %\" PRIu8 \": Sending BPDU (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      port->portIndex, length);\n\n   \n   stpDumpBpdu(bpdu, length);\n\n   \n   context = port->context;\n\n   \n   buffer = ethAllocBuffer(sizeof(LlcHeader), &offset);\n\n   \n   if(buffer != NULL)\n   {\n      \n      llcHeader = netBufferAt(buffer, offset);\n\n      \n      \n      \n      llcHeader->dsap = STP_LLC_DSAP;\n      llcHeader->ssap = STP_LLC_SSAP;\n      llcHeader->control = STP_LLC_CTRL;\n\n      \n      error = netBufferAppend(buffer, bpdu, length);\n\n      \n      if(!error)\n      {\n         \n         length += sizeof(LlcHeader);\n\n         \n         ancillary = NET_DEFAULT_TX_ANCILLARY;\n         \n         ancillary.srcMacAddr = port->macAddr;\n         \n         ancillary.port = port->portIndex;\n\n         \n         \n         error = ethSendFrame(context->interface, &STP_BRIDGE_GROUP_ADDR,\n            length, buffer, offset, &ancillary);\n      }\n\n      \n      netBufferFree(buffer);\n   }\n   else\n   {\n      \n      error = ERROR_OUT_OF_MEMORY;\n   }\n\n   \n   return error;\n}\n\n\n\n\nerror_t stpDumpBpdu(const StpBpdu *bpdu, size_t length)\n{\n#if (STP_TRACE_LEVEL >= TRACE_LEVEL_DEBUG)\n   uint32_t t;\n\n   \n   if(length < STP_MIN_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n\n   \n   TRACE_DEBUG(\"  Protocol Identifier = %\" PRIu16 \"\\r\\n\",\n      ntohs(bpdu->protocolId));\n\n   \n   TRACE_DEBUG(\"  Protocol Version Identifier = %\" PRIu8 \" (%s)\\r\\n\",\n      bpdu->protocolVersionId, stpGetParamName(bpdu->protocolVersionId,\n      stpProtocolVersions, arraysize(stpProtocolVersions)));\n\n   \n   TRACE_DEBUG(\"  BPDU Type = 0x%02\" PRIX8 \" (%s)\\r\\n\", bpdu->bpduType,\n      stpGetParamName(bpdu->bpduType, stpBpduTypes, arraysize(stpBpduTypes)));\n\n   \n   if(length >= STP_CONFIG_BPDU_SIZE)\n   {\n      \n      stpDumpFlags(bpdu->flags);\n\n      \n      TRACE_DEBUG(\"  Root Identifier = %\" PRIu16 \" \/ %s\\r\\n\",\n         ntohs(bpdu->rootId.priority), macAddrToString(&bpdu->rootId.addr, NULL));\n\n      \n      TRACE_DEBUG(\"  Root Path Cost = %\" PRIu32 \"\\r\\n\", ntohl(bpdu->rootPathCost));\n\n      \n      TRACE_DEBUG(\"  Bridge Identifier = %\" PRIu16 \" \/ %s\\r\\n\",\n         ntohs(bpdu->bridgeId.priority), macAddrToString(&bpdu->bridgeId.addr, NULL));\n\n      \n      TRACE_DEBUG(\"  Port Identifier = 0x%04\" PRIX16 \"\\r\\n\", ntohs(bpdu->portId));\n\n      \n      t = ntohs(bpdu->messageAge) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Message Age = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->maxAge) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Max Age = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->helloTime) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Hello Time = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n\n      \n      t = ntohs(bpdu->forwardDelay) * 1000 \/ 256;\n      TRACE_DEBUG(\"  Forward Delay = %\" PRIu32 \".%03\" PRIu32 \"\\r\\n\", t \/ 1000, t % 1000);\n   }\n#endif\n\n   \n   return NO_ERROR;\n}\n\n\n\n\nvoid stpDumpFlags(uint8_t flags)\n{\n   \n   TRACE_DEBUG(\"  Flags = 0x%02\" PRIX8, flags);\n\n   \n   if(flags != 0)\n   {\n      \n      TRACE_DEBUG(\" (\");\n\n      \n      while(flags != 0)\n      {\n         if((flags & STP_BPDU_FLAG_TC_ACK) != 0)\n         {\n            \n            TRACE_DEBUG(\"TcAck\");\n            \n            flags &= ~STP_BPDU_FLAG_TC_ACK;\n         }\n         else if((flags & STP_BPDU_FLAG_TC) != 0)\n         {\n            \n            TRACE_DEBUG(\"Tc\");\n            \n            flags &= ~STP_BPDU_FLAG_TC;\n         }\n\n         \n         if(flags != 0)\n         {\n            TRACE_DEBUG(\", \");\n         }\n      }\n\n      \n      TRACE_DEBUG(\")\");\n   }\n\n   \n   TRACE_DEBUG(\"\\r\\n\");\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL STP_TRACE_LEVEL\n\n\n#include \"stp\/stp.h\"\n#include \"stp\/stp_conditions.h\"\n#include \"stp\/stp_misc.h\"\n#include \"debug.h\"\n\n\n#if (STP_SUPPORT == ENABLED)\n\n\n\n\nbool_t stpRootBridge(StpBridgeContext *context)\n{\n   bool_t res;\n\n   \n   \n   if(stpCompareBridgeId(&context->designatedRoot, &context->bridgeId) == 0)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n\n   \n   return res;\n}\n\n\n\n\nbool_t stpDesignatedBridge(StpBridgeContext *context)\n{\n   uint_t i;\n   bool_t res;\n   StpBridgePort *port;\n\n   \n   res = FALSE;\n\n   \n   for(i = 0; i < context->numPorts; i++)\n   {\n      \n      port = &context->ports[i];\n\n      \n      \n      if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0)\n      {\n         res = TRUE;\n      }\n   }\n\n   \n   \n   return res;\n}\n\n\n\n\nbool_t stpRootPort(StpBridgePort *port)\n{\n   bool_t res;\n\n   \n   if(stpComparePortNum(port->portId, port->context->rootPort) == 0)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n\n   \n   return res;\n}\n\n\n\n\nbool_t stpDesignatedPort(StpBridgePort *port)\n{\n   bool_t res;\n   StpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   \n   \n   if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0 &&\n      port->designatedPort == port->portId)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n\n   \n   \n   return res;\n}\n\n\n\n\nbool_t stpSupersedesPortInfo(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   bool_t res;\n   StpBridgeId rootId;\n   StpBridgeId bridgeId;\n   StpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   \n   rootId.priority = ntohs(bpdu->rootId.priority);\n   rootId.addr = bpdu->rootId.addr;\n   bridgeId.priority = ntohs(bpdu->bridgeId.priority);\n   bridgeId.addr = bpdu->bridgeId.addr;\n\n   \n   res = FALSE;\n\n   \n   \n   if(stpCompareBridgeId(&rootId, &port->designatedRoot) < 0)\n   {\n      \n      \n      res = TRUE;\n   }\n   else if(stpCompareBridgeId(&rootId, &port->designatedRoot) > 0)\n   {\n   }\n   else if(ntohl(bpdu->rootPathCost) < port->designatedCost)\n   {\n      \n      \n      \n      res = TRUE;\n   }\n   else if(ntohl(bpdu->rootPathCost) > port->designatedCost)\n   {\n   }\n   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) < 0)\n   {\n      \n      \n      \n      res = TRUE;\n   }\n   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) > 0)\n   {\n   }\n   else\n   {\n      \n      \n      \n      if(stpCompareBridgeId(&bridgeId, &context->bridgeId) != 0)\n      {\n         \n         \n         res = TRUE;\n      }\n      else if(ntohs(bpdu->portId) <= port->designatedPort)\n      {\n         \n         \n         res = TRUE;\n      }\n      else\n      {\n      }\n   }\n\n   \n   return res;\n}\n\n#endif\n"}
{"target":"Oryx-Embedded","func":"\n\n\n#define TRACE_LEVEL STP_TRACE_LEVEL\n\n\n#include \"stp\/stp.h\"\n#include \"stp\/stp_operation.h\"\n#include \"stp\/stp_procedures.h\"\n#include \"stp\/stp_conditions.h\"\n#include \"stp\/stp_misc.h\"\n#include \"debug.h\"\n\n\n#if (STP_SUPPORT == ENABLED)\n\n\n\n\nvoid stpReceivedConfigBpdu(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   bool_t rootBridge;\n   StpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)\n   {\n      \n      \n      if(stpSupersedesPortInfo(port, bpdu))\n      {\n         \n         rootBridge = stpRootBridge(context);\n\n         \n         stpRecordConfigInfo(port, bpdu);\n         \n         stpConfigUpdate(context);\n         \n         stpPortStateSelection(context);\n\n         \n         \n         if(rootBridge && !stpRootBridge(context))\n         {\n            \n            stpStopTimer(&context->helloTimer);\n\n            \n            if(context->topologyChangeDetected)\n            {\n               \n               \n               \n               stpStopTimer(&context->topologyChangeTimer);\n               stpTransmitTcnBpdu(context);\n               stpStartTimer(&context->tcnTimer, 0);\n            }\n         }\n\n         \n         if(stpRootPort(port))\n         {\n            \n            \n            stpRecordConfigTimeoutValues(context, bpdu);\n            stpConfigBpduGeneration(context);\n\n            \n            if((bpdu->flags & STP_BPDU_FLAG_TC_ACK) != 0)\n            {\n               \n               stpTopologyChangeAcked(context);\n            }\n         }\n      }\n      else\n      {\n         \n         \n         \n         \n         if(stpDesignatedPort(port))\n         {\n            stpReplyToConfigBpdu(port);\n         }\n      }\n   }\n}\n\n\n\n\nvoid stpReceivedTcnBpdu(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   \n   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)\n   {\n      \n      \n      if(stpDesignatedPort(port))\n      {\n         \n         stpTopologyChangeDetection(port->context);\n         \n         stpAckTopologyChange(port);\n      }\n   }\n}\n\n\n\n\nvoid stpHelloTimerExpiry(StpBridgeContext *context)\n{\n   \n   \n   stpConfigBpduGeneration(context);\n   stpStartTimer(&context->helloTimer, 0);\n}\n\n\n\n\nvoid stpMessageAgeTimerExpiry(StpBridgePort *port)\n{\n   bool_t rootBridge;\n   StpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   rootBridge = stpRootBridge(context);\n\n   \n   \n   stpBecomeDesignatedPort(port);\n\n   \n   stpConfigUpdate(context);\n   \n   stpPortStateSelection(context);\n\n   \n   if(!rootBridge && stpRootBridge(context))\n   {\n      \n      \n      \n      context->maxAge = context->bridgeMaxAge;\n      context->helloTime = context->bridgeHelloTime;\n      context->forwardDelay = context->bridgeForwardDelay;\n\n      \n      stpTopologyChangeDetection(context);\n      \n      stpStopTimer(&context->tcnTimer);\n\n      \n      \n      stpConfigBpduGeneration(context);\n      stpStartTimer(&context->helloTimer, 0);\n   }\n}\n\n\n\n\nvoid stpForwardDelayTimerExpiry(StpBridgePort *port)\n{\n   StpBridgeContext *context;\n\n   \n   context = port->context;\n\n   \n   if(port->state == STP_PORT_STATE_LISTENING)\n   {\n      \n      \n      stpUpdatePortState(port, STP_PORT_STATE_LEARNING);\n\n      \n      stpStartTimer(&port->forwardDelayTimer, 0);\n   }\n   else if(port->state == STP_PORT_STATE_LEARNING)\n   {\n      \n      \n      stpUpdatePortState(port, STP_PORT_STATE_FORWARDING);\n\n      \n      \n      \n      if(stpDesignatedBridge(context) && port->changeDetectionEnabled)\n      {\n         \n         stpTopologyChangeDetection(context);\n      }\n   }\n   else\n   {\n      \n   }\n}\n\n\n\n\nvoid stpTcnTimerExpiry(StpBridgeContext *context)\n{\n   \n   stpTransmitTcnBpdu(context);\n   \n   stpStartTimer(&context->tcnTimer, 0);\n}\n\n\n\n\nvoid stpTopologyChangeTimerExpiry(StpBridgeContext *context)\n{\n   \n   context->topologyChangeDetected = FALSE;\n   \n   stpUpdateTopologyChange(context, FALSE);\n}\n\n\n\n\nvoid stpHoldTimerExpiry(StpBridgePort *port)\n{\n   \n   \n   \n   if(port->configPending)\n   {\n      stpTransmitConfigBpdu(port);\n   }\n}\n\n#endif\n"}
{"target":"paawankohli","func":"\n\n\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#define PORT 9734\n\nvoid main() {\n    \n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    \n    if (serverfd == -1) {\n        printf(\"Couldn't create socket. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created \\n\");\n    }\n\n    \n    struct sockaddr_in server_address;\n    int len = sizeof(server_address);\n\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    server_address.sin_port = PORT;\n\n    \n    int status = connect(serverfd, (struct sockaddr *)&server_address, len);\n    \n    \n    if (status == -1) {\n        printf(\"Couldn't connect. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Connection established!\\n\\n\");\n    }\n\n    char time[100];\n\n    read(serverfd, time, 100);\n    printf(\"Server Time: %s\\n\", time);\n\n    char processid[100];\n\n    read(serverfd, processid, 100);\n    printf(\"Server proccess ID: %s\\n\", processid);\n\n    \n    close(serverfd);\n}"}
{"target":"paawankohli","func":"\n\n\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n\n#define PORT 9734\n\nvoid main() {\n    \n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    \n    if (serverfd == -1) {\n        printf(\"Couldn't create socket. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created \\n\");\n    }\n\n    \n    struct sockaddr_in server_address, client_address;\n    int len = sizeof(server_address);\n\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    server_address.sin_port = PORT;\n\n    \n    if (bind(serverfd, (struct sockaddr *)&server_address, len) == -1) {\n        exit(0);\n    } else {\n        printf(\"Binding successful!\\n\");\n    }\n\n    \n    if (listen(serverfd, 5) == -1) {\n        printf(\"Couldn't start listening. Exit.\\n\");\n        exit(0);\n    } else {\n        printf(\"Server listening.\\n\\n\");\n    }\n\n    while (1) {\n        int clientfd = accept(serverfd, (struct sockaddr *)&client_address, &len);\n\n        \n        time_t rawtime;\n        struct tm * timeinfo;\n        time ( &rawtime );\n        timeinfo = localtime ( &rawtime );\n        char* time_to_output = malloc(strlen(asctime (timeinfo)) + 1);\n        strcpy(time_to_output, asctime (timeinfo));\n\n        \n        write(clientfd, time_to_output, 100);\n\n        \n        char process_id_to_output[100];\n        sprintf(process_id_to_output, \"%d\", getpid());\n        write(clientfd, &process_id_to_output, 100);\n\n        \n        close(clientfd);\n    }\n}"}
{"target":"paawankohli","func":"#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <netinet\/in.h>\n#include <arpa\/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#define PORT 1327\n\nvoid main () {\n    struct sockaddr_in serverAddress;\n    struct sockaddr_in clientAddress;\n\n    int sockaddr_len = sizeof(struct sockaddr_in);\n\n    \n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    \n    if (serverfd == -1) {\n        printf(\"Couldn't create socket! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created successfully!\\n\");\n    }\n\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serverAddress.sin_port = PORT;\n\n    \n    int status = bind(serverfd, (struct sockaddr*) &serverAddress, sockaddr_len);\n\n    if (status == -1) {\n        printf(\"Couldn't bind socket! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket binded successfully!\\n\");\n    }\n\n    \n    status = listen(serverfd, 5);\n\n    if (status == -1) {\n        printf(\"Couldn't start listening! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Server listening at port: PORT\\n\\n\");\n    }\n\n\n    while (1) {\n        printf(\"Server waiting for connection....\\n\");\n\n        \n        int clientfd = accept(serverfd, (struct sockaddr*) &clientAddress, &sockaddr_len);\n\n        if (clientfd == -1) {\n            printf(\"Couldn't accept connection request! Exited.\\n\");\n            exit(0);\n        } else {\n            char *clientIP = inet_ntoa(clientAddress.sin_addr);\n            int clientPort = clientAddress.sin_port;\n            printf(\"Connection request accepted from \");\n            printf(\"%s : %d\\n\", clientIP, clientPort);\n        }\n\n        char ch;\n\n        read(clientfd, &ch, 1);\n        ch++;\n        write(clientfd, &ch, 1);\n\n        close(clientfd);\n        printf(\"Connection closed\\n\");\n    }\n}"}
{"target":"paawankohli","func":"#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet\/ip.h>\n#include <unistd.h>\n#include <arpa\/inet.h>\n\nvoid main () {\n\n    struct sockaddr_in seradd;\n    int sockaddr_len = sizeof(seradd);\n\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 1326;\n    seradd.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n\n    connect(fd, (struct sockaddr*)&seradd, sockaddr_len);\n\n    while (1) {\n        printf(\"enter n and elements: \");\n        int n; scanf(\"%d\", &n);\n        \n        int arr[n + 1];\n        arr[0] = n;\n\n        for (int i = 1; i <= n; ++i)\n            scanf(\"%d\", &arr[i]);\n\n        write(fd, arr, (n + 1) * 4);\n\n        if (n == 0) {\n            break;\n        }\n    }\n\n\n}"}
{"target":"paawankohli","func":"#include <sys\/types.h>\n#include <sys\/socket.h> \n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet\/ip.h> \n#include <unistd.h>\n#include <arpa\/inet.h> \n#include <errno.h>\n\nvoid main () {\n\n    struct sockaddr_in seradd;\n    int len = sizeof(seradd);\n\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 5555;\n    seradd.sin_addr.s_addr = inet_addr(\"172.16.57.152\");\n\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    printf(\"Socket fd: %d \\n\", fd);\n\n    if (connect(fd, (struct sockaddr*)&seradd, len) == -1) {\n        printf(\"Connect error! %d\\n\" , errno);\n        exit(0);\n    } else {\n        printf(\"Connected\\n\");\n    }\n\n    char c = 'a';\n\n    write(fd, &c, 1);\n\n    char msg[100];\n\n    read(fd, msg, 100);\n\n    printf(\"Server: %s\\n\", msg);\n\n}"}
{"target":"paawankohli","func":"#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet\/ip.h>\n#include <unistd.h>\n#include <arpa\/inet.h>\n\nvoid main () {\n\n    struct sockaddr_in cliadd, seradd;\n    int sockaddr_len = sizeof(seradd);\n\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 1326;\n    seradd.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (serverfd == -1) {\n        printf(\"Can't create socket\\n\");\n        exit(0);\n    }\n\n    if (bind(serverfd, (struct sockaddr*) &seradd, sockaddr_len) == -1) {\n        printf(\"Can't bind\\n\");\n        exit(0);\n    }\n\n    if (listen(serverfd, 10) == -1) {\n        printf(\"Can't listen\\n\");\n        exit(0);\n    }\n\n    printf(\"Waiting for connection!\\n\");\n\n    int clientfd = accept(serverfd, (struct sockaddr*)&cliadd, &sockaddr_len);\n\n    printf(\"Connection established!\\n\");\n    printf(\"IP: %s\\n\", inet_ntoa(cliadd.sin_addr));\n    printf(\"Port: %d\\n\", cliadd.sin_port);\n\n    int mat[100][100];\n    int i = 0;\n\n    while (1) {\n        int arr[100];\n        read(clientfd, arr, 100 * 4) \/ 4;\n        int size = arr[0];\n\n        if (size == 0) {\n            break;\n        }\n\n        for (int j = 0 ; j <= size ; j++) {\n            mat[i][j] = arr[j];\n        }\n\n        i++;\n\n        printf(\"Got line %d\\n\", 1);\n    }\n\n    for (int ii = 0 ; ii < i ; ii++) {\n        int size = mat[ii][0];\n\n        for (int j = 1 ; j <= size ; j++) {\n            printf(\"%d \", mat[ii][j]);\n        }\n\n        printf(\"\\n\");\n    }\n\n    close(clientfd);\n}"}
{"target":"paawankohli","func":"#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys\/types.h>\n#include <sys\/socket.h>\n#include <netinet\/ip.h>\n#include <string.h>\n\nvoid main () {\n    int serverfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    struct sockaddr_in seradd;\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 4000;\n    seradd.sin_addr.s_addr = INADDR_ANY;\n\n    bind(serverfd, (struct sockaddr *) &seradd, sizeof(seradd));\n\n    while (1) {\n        char buf[100];\n        struct sockaddr_in cliadd;\n        int len = sizeof(cliadd);\n\n        recvfrom(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, &len);\n        printf(\"Client: %s\\n\", buf);\n\n        strcpy(buf, \"Got it bro\");\n\n        sendto(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, len);\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int rowNum;\n    printf(\"Enter no. of rows:\");\n    scanf(\"%d\", &rowNum);\n\n    int **table = calloc(rowNum, sizeof(int*));\n\n    int total = 0;\n\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize;\n        printf(\"Enter no. of columns of %dth row: \", i + 1);\n        scanf(\"%d\", &colSize);\n\n        table[i] = calloc(colSize + 1, sizeof(int));\n\n        table[i][0] = colSize;  \n\n        printf(\"Enter %d elements: \", colSize);\n        for(int j = 1 ; j <= table[i][0] ; j++)\n            scanf(\"%d\", &table[i][j]);\n\n        total += colSize;\n    }\n\n    int temp[total];\n    int k = 0;\n\n    for(int i = 1 ; i <= table[rowNum - 1][0] ; i++) \n        temp[k++] = table[rowNum - 1][i];\n\n    for(int a = 0 ; a < rowNum - 1 ; a++)\n    {\n        int colSize = table[a][0];\n\n        for(int i = 1 ; i <= colSize ; i++)\n            temp[k++] = table[a][i];\n    }\n\n    for(int i = 0 ; i < rowNum - 1; i++)\n        table[i][0] = 0;\n\n    table[rowNum - 1] = malloc((total + 1) * sizeof(int));\n    table[rowNum - 1][0] = total;\n\n    for(int i = 1; i <= total; i++)\n        table[rowNum - 1][i] = temp[i - 1];\n\n\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize = table[i][0];\n\n        if(colSize == 0)\n        {\n            printf(\"NULL\\n\");\n            continue;\n        }\n\n        for(int j = 0 ; j <= colSize ; j++)\n            printf(\"%d\\t\", table[i][j]);\n\n        printf(\"\\n\");\n\n        free(table[i]);\n    }\n\n    free(table);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#define MAX 100\n\ntypedef struct\n{\n    int q[100];\n    int front;\n    int rear;\n}QUEUE;\n\nint isEmpty(QUEUE* pq)\n{\n    if (pq->front == pq->rear)\n        return 1;\n    else\n        return 0;\n}\n\nint isFull(QUEUE* pq)\n{\n    if (pq->rear == MAX - 1)\n        return 1;\n    else\n        return 0;\n}\n\nvoid enqueue(QUEUE* pq, int x)\n{\n    if(isFull(pq) == 0)\n        pq->q[(pq->rear)++] = x;\n    else\n        printf(\"FULL\");\n}\n\nint dequeue(QUEUE* pq)\n{\n    if (isEmpty(pq) == 1)\n        return -1;\n    else\n        return pq->q[(pq->front)++];\n}\n\nvoid display(QUEUE* pq)\n{\n    for(int i = pq->front ; i < pq->rear ; i++)\n        printf(\"%d \", pq->q[i]);\n\n    printf(\"\\n\");\n\n}\n\nvoid reverse(QUEUE* q1, QUEUE* q2, int n)                                   \n{\n    if(n == 0)\n        return;\n\n    int x = dequeue(q1);\n    reverse(q1, q2, n - 1);\n    enqueue(q2, x);\n}\n\nint main()\n{\n    QUEUE q1, q2; q1.front = q1.rear = q2.front = q2.rear = 0;            \n\n    int n;\n    printf(\"Enter no. of elements: \");\n    scanf(\"%d\", &n);\n    \n    printf(\"Enter elements: \");\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        int a;\n        scanf(\"%d\", &a);\n        enqueue(&q1, a);\n    }\n\n\n    \n\n    printf(\"QUEUE 1:\");    display(&q1);\n    \n    reverse(&q1, &q2,n);\n\n    \n\n    printf(\"QUEUE 2:\");    display(&q2);\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"paawankohli","func":"nptr copy(nptr original)\n{\n    if (original == NULL)\n        return NULL;\n\n    temp = createNode(original -> data);\n    temp -> lchild = copy(original -> lchild);\n    temp -> rchild = copy(original -> rchild);\n    return temp;\n}\n\nint searchBT(nptr root, int x)\n{\n    if(root == NULL)\n        return 0;\n\n    else if (root -> data  == x  ||  searchBT(root -> lchild, x)  ||   searchBT(root -> rchild, x) )\n        return 1;\n}\n\nint height(nptr root)\n{\n    if (root == NULL)\n        return 0;\n    \n    return max(height(root->right), height(root->left)) + 1;\n}\n\nint Equal( Nodeptr root1, Nodeptr root2)\n{\n    return  ((root1 == NULL && root2 == NULL) || (root1 && root2 && root1 -> data == root2 -> data)) \n            && Equal(root1->lchild, root2->lchild) \n            && Equal(root1->rchild, root2->rchild);\n}\n\nvoid getlevel(node* r, int level)\n{\n    if (level == 0)\n        printf(\"%d\\t\", r -> data);\n    \n    else\n    {\n        getlevel(r->left, level-1);\n        getlevel(r->right, level-1);\n    } \n}\n\n"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n    int real;\n    int imag;\n} cNum;\n\ncNum add(cNum a, cNum b)\n{\n    cNum temp;\n\n    temp.real = a.real + b.real;\n    temp.imag = a.imag + b.imag;\n\n    return temp;\n}\n\ncNum subtract(cNum a, cNum b)\n{\n    cNum temp;\n\n    temp.real = a.real - b.real;\n    temp.imag = a.imag - b.imag;\n\n    return temp;\n}\n\ncNum multiply(cNum a, cNum b)\n{\n    cNum temp;\n\n    temp.real = a.real * b.real - a.imag * b.imag;\n    temp.imag = a.imag * b.real + a.real * b.imag;\n\n    return temp;\n}\n\nvoid display(cNum a)\n{\n    printf(\" %d + %di \\n\", a.real, a.imag);\n}\n\nint main()\n{\n    cNum a, b, c;\n\n    \n    printf(\"Enter real and imaginary part of first number: \");\n    scanf(\"%d %d\", &a.real, &a.imag);\n\n    printf(\"Enter real and imaginary part of second number: \");\n    scanf(\"%d %d\", &b.real, &b.imag);\n\n    printf(\"Addition: \");\n    display(add(a, b));\n\n    printf(\"Subtract: \");\n    display(subtract(a, b));\n\n    printf(\"Multiply: \");\n    display(multiply(a, b));\n\n}\n\n\n"}
{"target":"paawankohli","func":"void insertNode(nptr root, int x, char path[])\n{\n    int i = 0;\n    nptr parent = NULL, curr = root;\n\n    while(curr && path[i])\n    {\n        parent = curr;\n\n        if (path[i] == 'L')\n            curr = parent -> lchild;\n        else if (path[i] == 'R')\n            curr = parent -> rchild;\n\n        i++;\n    }\n\n    if (curr == NULL || path[i] == '\\0')\n    {\n        if (path[i - 1] == 'R')\n            parent -> rchild = createNode(x);\n        else if (path[i - 1] == 'L')\n            parent -> lchild = createNode(x);\n    }\n    else\n        printf(\"Path error!\");\n}\n\nnptr createBT()\n{\n    int x;    printf(\"Insert Element: \");    scanf(\"%d\", &x);\n\n    if(x == -1)\n        return NULL;\n\n    nptr temp = createNode(x);\n    temp -> lchild = createBT();\n    temp -> rchild = createBT();\n    return temp;\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\ntypedef struct\n{\n    int c[20];\n    int front;\n    int rear;\n}queue;\nvoid enqueueright(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}\nvoid enqueueleft(queue *q,int n)\n{\n    if (q->front==0)\n        printf(\"Side Full\\n\");\n    else\n        q->c[--(q->front)]=n;\n}\nint dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[(q->front)++];\n}\nint dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}\nvoid display(queue *q)\n{\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    printf(\"\\n\");\n}\nint main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=10;\n    q.rear=10;\n    while (z==0)\n    {\n        printf(\"1. Enqueue Right\\t2. Enqueue Left\\t3. Dequeue Left\\t4. Dequeue Right\\t5. Display \\t6. Exit\\n\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                scanf(\"%d\",&e);\n                enqueueright(&q,e);\n                break;\n            }\n            case 2:\n            {\n                scanf(\"%d\",&e);\n                enqueueleft(&q,e);\n                break;\n            }\n            case 3:\n            {\n                printf (\"%d\\n\",dequeueleft(&q));\n                break;\n            }\n            case 4:\n            {\n                printf (\"%d\\n\",dequeueright(&q));\n                break;\n            }\n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr left, right;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n\n    return temp;\n}\n\nnptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n        return createNode(x);\n\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> right = head;\n        head -> left = temp;\n\n        return temp;\n    }\n}\n\nnptr insertRight(nptr head, int x)\n{\n    if (head == NULL)\n        return createNode(x);\n\n    else\n    {\n        nptr curr = head;\n\n        while(curr -> right != NULL)\n            curr = curr -> right;\n        \n        nptr temp = createNode(x);\n        curr -> right = temp;\n        temp -> left = curr;\n\n        return head;\n    }\n}\n\nnptr deleteLeft(nptr head)\n{\n    if(head == NULL)\n        return head;\n\n    if(head -> left == NULL && head -> right == NULL)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n\n    nptr temp = head;\n    head = head -> right;\n    head -> left = NULL;\n    \n    printf(\"%d deleted\\n\", temp -> data);\n    free(temp);\n\n    return head;\n}\n\nnptr deleteRight(nptr head)\n{\n    if(head == NULL)\n        return head;\n\n    if(head -> left == NULL && head -> right == NULL)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n\n    nptr curr = head;\n\n    while(curr -> right != NULL)\n        curr = curr -> right;\n\n    (curr -> left) -> right = NULL;\n\n    printf(\"%d deleted\\n\", curr -> data);\n    free(curr);\n    return head;\n}\n\nvoid display(nptr head)\n{\n    printf(\"                 \");\n    \n    if(head == NULL)\n        printf(\"EMPTY\");\n\n    while(head)\n    {\n        printf(\" %d \", head -> data);\n        head = head -> right;\n    }\n\n    printf(\"\\n\");\n}\n\nint main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n\n    int ch,  ele;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n\n            case 3: head = deleteLeft(head);\n                    break;\n            \n            case 4: head = deleteRight(head);\n                    break;\n\n            case 5: display(head);\n        }\n\n    }while(ch != 6);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr left, right;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n\n    return temp;\n}\n\nnptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> left = head -> left;\n        temp -> right = head;\n\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n\n        return temp;\n    }\n}\n\nnptr insertRight(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n\n    else\n    {\n        nptr curr = head;\n\n        while(curr -> right != head)\n            curr = curr -> right;\n        \n        nptr temp = createNode(x);\n\n        temp -> left = head -> left;\n        temp -> right = head;\n\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n\n        return head;\n    }\n}\n\nnptr deleteLeft(nptr head)\n{\n    if(head == NULL)\n        return head;\n\n    if(head -> left == head && head -> right == head)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n\n    nptr temp = head;\n    head = head -> right;\n    head -> left = temp -> left;\n    \n    printf(\"%d deleted\\n\", temp -> data);\n    free(temp);\n\n    return head;\n}\n\nnptr deleteRight(nptr head)\n{\n    if(head == NULL)\n        return head;\n\n    if(head -> left == head && head -> right == head)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n\n    nptr curr = head;\n\n    while(curr -> right != head)\n        curr = curr -> right;\n\n    (curr -> left) -> right = head;\n    head -> left = curr -> left;\n\n    printf(\"%d deleted\\n\", curr -> data);\n    free(curr);\n    return head;\n}\n\nvoid display(nptr head)\n{\n    nptr curr = head;\n    printf(\"                 \");\n    \n    if(curr == NULL)\n        printf(\"EMPTY\");\n\n    while(curr -> right != head)\n    {\n        printf(\" %d \", curr -> data);\n        curr = curr -> right;\n    }\n\n    printf(\" %d\\n\", curr -> data);\n}\n\nint main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n\n    int ch,  ele;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n\n            case 3: head = deleteLeft(head);\n                    break;\n            \n            case 4: head = deleteRight(head);\n                    break;\n\n            case 5: display(head);\n                    break;\n\n            case 6: exit(0);\n        }\n\n    }while(ch != 6);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr next;\n} node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid insertRear(nptr &head, int x)\n{\n    if (head == NULL)\n    {\n        head = createNode(x);\n        return;\n    }\n\n    nptr temp = head;\n\n    while (temp -> next != NULL)\n        temp = temp -> next;\n\n    temp -> next = createNode(x);\n}\n\nvoid display(nptr head)\n{\n    nptr temp = head;\n\n    while (temp)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n\n    printf(\"NULL\\n\");\n}\n\nvoid removeDuplicate(nptr head)\n{\n    if (head == NULL || head -> next == NULL)\n        return;\n\n    nptr temp1 = head, temp2 = head -> next;\n\n    if (temp1 -> data == temp2 -> data)\n    {\n        temp1 -> next = temp2 -> next;\n        free(temp2);\n    }\n    else\n        temp1 = temp1 -> next;\n\n    removeDuplicate(temp1);\n}\n\nvoid removeDuplicate2(nptr head)\n{\n    if (head == NULL)\n        printf(\"Empty list\\n\");\n\n    nptr curr = head, dup = NULL;\n\n    while(curr != NULL && curr -> next != NULL)\n    {\n        if (curr -> data == curr -> next -> data)\n        {\n            dup = curr -> next;\n            curr -> next = dup -> next;\n            free(dup);\n        }\n        else\n            curr = curr -> next;\n    }\n}\n\nint main()\n{\n    printf(\"1. Insert Rear     2. Display     3. Remove Duplicates     0. Exit\\n\");\n    int ch, ele;\n\n    nptr head = NULL;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1:\n                    \n                    scanf(\"%d\", &ele);\n                    insertRear(head, ele);\n                    break;\n\n            case 2:\n                    display(head);\n                    break;\n\n            case 3: \n                    removeDuplicate2(head);\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include \"charStack.h\"\n\n\n\nint toInt(char c)\n{\n    return c - '0';\n}\n\nint main()\n{\n    stack s;\n    char exp[15];\n\n    printf(\"Enter exp: \");\n    scanf(\"%s\", exp);\n\n    for(int i = 0 ; exp[i] != '\\0' ; i++)\n    {\n        char token = exp[i];\n\n        if (token >= '0' && token <= '9')\n            push(&s, token);\n        \n        else\n        {\n            char b = pop(&s);\n            char a = pop(&s);\n\n            switch(token)\n            {\n                case '+':   push(&s, toInt(a) + toInt(b) + '0');\n                            break;\n\n                case '-':   push(&s, toInt(a) - toInt(b) + '0');\n                            break;\n\n                case '\/':   push(&s, toInt(a) \/ toInt(b) + '0');\n                            break;\n\n                case '*':   push(&s, toInt(a) * toInt(b) + '0');\n                            break;\n            }\n\n        }\n    }\n\n    printf(\"Ans = %d \\n\", toInt(pop(&s)));\n}\n"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr next;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid insertFront(nptr &head, int ele)\n{\n    nptr temp = createNode(ele);\n    temp -> next = head;\n    head = temp;\n}\n\nvoid insertAfter(nptr &head, int x, int key)\n{\n    nptr temp = head;\n\n    while(temp != NULL)\n    {\n        if (temp -> data == key)\n        {\n            nptr newNode = createNode(x);\n            newNode -> next = temp -> next;\n            temp -> next = newNode;\n            return;\n        }\n        \n        temp = temp -> next;\n    }\n\n    printf(\"Element wasn't found\\n\");\n}\n\nvoid display(nptr head)\n{\n    nptr temp = head;\n\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp->next;\n    }\n\n    printf(\"NULL\\n\");\n}\n\nint main()\n{\n    nptr head = NULL;\n    int ch, ele, key;\n\n    printf(\"0. Exit      1. Insert Front      2. Insert After      3. Display\\n\");\n\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1: printf(\"Element: \");\n                    scanf(\"%d\", &ele);\n                    insertFront(head, ele);\n                    break;\n\n            case 2: printf(\"Element and key element to insert after: \");\n                    scanf(\"%d %d\", &ele, &key);\n                    insertAfter(head, ele, key);\n                    break;\n\n            case 3: display(head);\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n#include \"charStack.h\"\n\n\n\nint isOperand(char ch)      \n{ \n    return (ch >= 'a' && ch <= 'z');\n} \n\nint prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n\n    if (ch == '*' || ch == '\/')\n        return 2; \n\n    if (ch == '^')\n        return 3;  \n    \n    return -1; \n} \n\nint infixToPostfix(char* exp, char* ans) \n{ \n    int i, k = 0; \n\n    stack s;\n\n    for (i = 0 ; exp[i] != '\\0' ; i++) \n    { \n    \n        if (isOperand(exp[i]))      \n            ans[k++] = exp[i]; \n        \n        else if (exp[i] == '(')     \n            push(&s, exp[i]); \n        \n        else if (exp[i] == ')')     \n        { \n            while (!isEmpty(&s) && top(&s) != '(') \n                ans[k++] = pop(&s); \n            \n            pop(&s);  \n        } \n        \n        else            \n        { \n            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) \n                ans[k++] = pop(&s); \n            \n            push(&s, exp[i]); \n        } \n    } \n\n    while (!isEmpty(&s))            \n        ans[k++] = pop(&s); \n\n    ans[k- 1] = '\\0';  \n} \n\nint main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);   \n    \n    infixToPostfix(exp, ans);\n\n    printf(\"%s \\n\", ans); \n} "}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\ntypedef struct node\n{\n    int data;\n    struct node* next;\n}*NODE;\nNODE insert(NODE first,int e,int pr)\n{\n    NODE temp=(NODE)malloc(sizeof(struct node));\n    temp->data=e;\n    temp->next=NULL;\n    if (first==NULL)\n        return temp;\n    else if(first->next==NULL)\n    {\n        if (first->data>e)\n        {\n            temp->next=first;\n            return temp;\n        }\n        else if(first->data<e)\n            first->next=temp;\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n    }\n    else\n    {\n        NODE m=first;\n        while(m->next!=NULL && m->next->data<=e)\n            m=m->next;\n        if (m->data!=e)\n        {\n            temp->next=m->next;\n            m->next=temp;\n        }\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n        return first;\n    }\n}\nNODE lunion(NODE l1, NODE l2)\n{\n    NODE uni=NULL;\n    while(l1!=NULL)\n    {\n        uni=insert(uni,l1->data,0);\n        l1=l1->next;\n    }\n    while(l2!=NULL)\n    {\n        uni=insert(uni,l2->data,0);\n        l2=l2->next;\n    }\n    return uni;\n}\nNODE lintersection(NODE l1, NODE l2)\n{\n    NODE in=NULL;\n    while (l1!=NULL)\n    {\n        NODE pl2=l2;\n        while(pl2!=NULL)\n        {\n            if (l1->data==pl2->data)\n            {\n                in=insert(in,l1->data,0);\n                break;\n            }\n            pl2=pl2->next;\n        }\n        l1=l1->next;\n    }\n    return in;\n}\nvoid display(NODE first)\n{\n    if (first==NULL)\n        printf(\"List Empty\\n\");\n    else\n    {\n        NODE p=first;\n        while (p->next!=NULL)\n        {\n            printf(\"%d \",p->data);\n            p=p->next;\n        }\n        printf(\"%d\\n\",p->data);\n    }\n}\nint main()\n{\n    NODE first=NULL;\n    NODE second=NULL;\n    NODE uni=NULL;\n    NODE in=NULL;\n    int z=0,k;\n    while (z==0)\n    {\n        printf(\"1. Insert 1\\t2. Insert 2\\t3. Display 1\\t4. Display 2\\t5. Union\\t6. Intersection\\t7. Exit\\t\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                int i;\n                printf(\"Insert:\\t\");\n                scanf(\"%d\",&i);\n                first=insert(first,i,1);\n                break;\n            }\n            case 2:\n            {\n                int i;\n                printf(\"Insert:\\t\");\n                scanf(\"%d\",&i);\n                second=insert(second,i,1);\n                break;\n            }\n            case 3:\n            {\n                display(first);\n                break;\n            }\n            case 4:\n            {\n                display(second);\n                break;\n            }\n            case 5:\n            {\n                uni=lunion(first,second);\n                display(uni);\n                break;\n            }\n            case 6:\n            {\n                in=lintersection(first,second);\n                display(in);\n                break;\n            }\n            case 7:\n                z=1;\n        }\n    }\n    return 0;\n}"}
{"target":"paawankohli","func":"void postorder(node *t)     \n{ \n    STACK s;\n    node*curr;\n    curr=t;\n    s.tos=-1;\n\n    do\n    { \n        while (curr!=NULL) \n        { \n            if (curr->right!=NULL) \n                push(&s, curr->right); \n            \n            push(&s, curr); \n            curr=curr->left; \n        } \n        \n        curr = pop(&s); \n        \n        if (curr->right!=NULL && s.s[s.tos]==curr->right) \n        { \n            pop(&s); \n            push(&s,curr);\n            curr=curr->right;\n        } \n        \n        else \n        { \n            printf(\"%d\\t\",curr->data); \n            curr=NULL; \n        } \n    \n    }while (s.tos!=-1); \n}"}
{"target":"paawankohli","func":"void Levelorder(Nodeptr root) \n{\n    queue q;\n    q.front = MAX\/2;\n    q.rear = MAX\/2;\n\n    InsertQ(&q, root);\n    \n    while (!QIsEmpty(&q)) \n    {\n        Nodeptr temp = DeleteQ(&q);\n        printf(\"%d \", temp->data);\n    \n        if (temp->lchild) \n            InsertQ(q, temp->lchild);\n        \n        if (temp->rchild) \n            InsertQ(q, temp->rchild);\n    }\n}\n\nvoid iterative_inorder(Nodeptr root)\n{\n    Nodeptr cur = root;\n    int done = false;\n    \n    STACK s; s.top = -1;\n    \n    while (!done) \n    {\n        while (cur != NULL) \n        {\n            push(&s, cur);\n            cur = cur -> lchild;\n        }\n        \n        if (isEmptyStack(s) == 0) \n        {\n            cur = pop(&s);\n            printf(\"%d \", cur -> data);\n            cur = cur -> rchild;\n        }\n        else\n            done = true;\n    }\n}\n\nvoid iterative_preorder(nptr root)\n{\n    stack s; s.top = -1;\n    nptr cur;\n\n    push(&s, root);\n    \n    while (!IsEmpty(s)) \n    {\n        cur = Pop(s);\n        printf(\"%d\", cur->data);\n        \n        if (cur -> rchild) \n            push(&s, cur -> rchild);\n        \n        if (cur -> lchild) \n            push(&s, cur -> lchild);\n    }\n}\n\nvoid iterative_postorder(Nodeptr root)\n{\n    cur = root;\n    for (; ;) \n    {\n        while (cur != NULL) \n        { \n            s[++top].node = cur;\n            s[top].flag = 1;\n            cur = cur -> llink;\n        }\n        \n        while (s[top].flag < 0) \n        {\n            cur = s[top--].node;\n            printf(\u201c % d\u201d, cur\uf0e0info);\n            if (stack_empty(top))\n                return;\n\n        }\n        cur = s[top].node; \n\n        cur = cur -> rlink;\n        s[top].flag = -1;\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    nptr next;\n    int data;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid push(nptr &head, int x)\n{\n    nptr temp = createNode(x);\n    temp -> next = head;\n    head = temp;\n}\n\nint pop(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n\n    nptr rear2 = head;\n    nptr rear = head -> next;\n\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n\n    rear2 -> next = NULL;\n    int x = rear -> data;\n\n    free(rear);\n    return x;\n}\n\nvoid display(nptr &head)\n{\n    if (head == NULL)\n    {   \n        printf(\"EMPTY\\n\");\n        return;\n    }\n\n    nptr curr = head;\n\n    while(curr)\n    {\n        printf(\"    %d \\n\", curr -> data);\n        curr = curr -> next;\n    }\n}\n\nint main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n\n    nptr queue = NULL;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(queue, ele);\n                    break;\n            \n            case 2:\n                    ele = pop(queue);\n                    \n                    if(ele == -1)\n                        printf(\"Queue empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                        \n                    break;\n\n            case 3:\n                    display(queue);\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    nptr next;\n    int data;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid push(nptr &stack, int x)\n{\n    nptr temp = createNode(x);\n    temp -> next = stack;\n    stack = temp;\n}\n\nint pop(nptr &stack)\n{\n    if(stack == NULL)\n        return -1;\n\n    nptr temp = stack;\n    stack = stack -> next;\n\n    int x = temp -> data;\n    free(temp);\n    return x;\n}\n\nvoid display(nptr &stack)\n{\n    if (stack == NULL)\n    {   \n        printf(\"EMPTY\\n\");\n        return;\n    }\n\n    nptr curr = stack;\n\n    while(curr)\n    {\n        printf(\"    %d \\n\", curr -> data);\n        curr = curr -> next;\n    }\n}\n\nint main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n\n    nptr stack = NULL;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(stack, ele);\n                    break;\n            \n            case 2:\n                    ele = pop(stack);\n                    \n                    if(ele == -1)\n                        printf(\"Stack empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                        \n                    break;\n\n            case 3:\n                    display(stack);\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr next;\n} node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid insertRear(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n\n    nptr rear = head;\n    \n    while(rear -> next != NULL)\n        rear = rear -> next;\n\n    nptr temp = createNode(ele);\n    rear -> next = temp;\n}\n\nvoid display(nptr head)\n{\n    nptr temp = head;\n\n    while (temp)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n\n    printf(\"NULL\\n\");\n}\n\nint elementFound(nptr head, int x)\n{\n    while(head)\n        if(head -> data == x)\n            return 1;\n        else\n            head = head -> next;\n\n    return 0;\n}\n\nnptr listUnion(nptr head1, nptr head2)\n{\n    nptr head3 = NULL;;\n    \n    nptr temp = head1;\n    while(temp)\n    {\n        insertRear(head3, temp -> data);\n        temp = temp -> next;\n    }\n\n    temp = head2;\n    while(temp)\n    {\n        if (elementFound(head3, temp -> data) == 0) \n            insertRear(head3, temp -> data);\n\n        temp = temp -> next;\n    }\n\n    return head3;\n}\n\nint main()\n{\n    nptr head1 = NULL, head2 = NULL, head3 = NULL;\n    int ele;\n\n    printf(\"Elements in list 1: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        \n        if(ele == -1)\n            break;\n        \n        insertRear(head1, ele);\n    } \n\n    display(head1);\n\n    printf(\"Elements in list 2: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        \n        if(ele == -1)\n            break;\n        \n        insertRear(head2, ele);\n    } \n\n    display(head2);  \n    \n    printf(\"\\nUnion: \\n\");\n    display(head3 = listUnion(head1, head2));\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node* nptr;\ntypedef struct Node\n{\n    nptr llink;\n    nptr rlink;\n    int ele;\n}node;\n\nnptr createNode()\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp->llink = temp;\n    temp->rlink = temp;\n    return temp;\n}\n\nvoid insert(nptr list,int x)\n{\n    nptr temp = createNode();\n    temp->ele = x;\n\n    temp-> llink = list;\n    temp-> rlink = list -> rlink;\n    list -> rlink = temp;\n    (temp -> rlink) -> llink = temp;\n}\n\nnptr getnum(char num[50])\n{\n    nptr head = createNode();\n\n    for(int i = strlen(num) - 1 ; i >= 0 ; i--)\n        insert(head, num[i] - '0');\n\n    return head;\n}\n\nnptr add(nptr num1, nptr num2)\n{\n    nptr sum = createNode();\n    nptr n1 = num1 -> llink;\n    nptr n2 = num2 -> llink;\n\n    int cin = 0;\n    int s = 0;\n\n    while(n1 != num1 && n2 != num2)\n    {\n        s = (n1 -> ele) + (n2 -> ele) + cin;\n\n        if(s >= 10)\n        { \n            cin = 1;\n            insert(sum, s - 10);\n        }\n        else\n        {\n            cin = 0;\n            insert(sum, s);\n        }\n\n        n1 = n1 -> llink;\n        n2 = n2 -> llink;\n    }\n    \n    while(n1 != num1)\n    {\n        s = (n1 -> ele) + cin;\n        \n        if(s > 9)\n        { \n            cin = 1; \n            insert(sum, s - 10);\n        }\n        else \n        {\n            cin = 0; \n            insert(sum, s);\n        }\n        \n        n1 = n1 -> llink;\n    }\n    \n    while(n2 != num2)\n    {\n        s = (n2 -> ele) + cin;\n        \n        if(s > 9)\n        { \n            cin = 1; \n            insert(sum, s - 10);\n        }\n        else \n        {\n            cin = 0; \n            insert(sum, s);\n        }\n        \n        n2 = n2 -> llink;\n    }\n\n    return sum;\n}\n\nvoid disp(nptr list)\n{\n    nptr i = list -> rlink;\n    \n    while(i != list)\n    {\n        printf(\"%d\", i -> ele);\n        i = i -> rlink;\n    }\n    \n    printf(\"\\n\");\n}\n\nint main()\n{\n    char num1[50],num2[50];\n    \n    printf(\"Enter the first number: \");\n    scanf(\"%s\",num1);\n    printf(\"Enter the second number: \");\n    scanf(\"%s\",num2);\n\n    nptr n1 = getnum(num1);\n    nptr n2 = getnum(num2);\n    \n    \n    \n    \n    nptr sum = add(n1,n2);\n    \n    printf(\"The sum of the given numbers is \");\n    disp(sum);\n}"}
{"target":"paawankohli","func":"node* mergeTwoLLs(node *head1, node *head2) \n{\n    node* t1 = head1;\n    node* t2 = head2;\n    \n    node* head;\n    node* tail;\n    \n    if(head1->data <= head2->data)\n    {\n        head = head1;\n        tail = head1;\n        t1 = t1->next;\n    }   \n    else \n    {\n        head = head2;  \n        tail = head2;\n        t2 = t2->next;\n    }\n        \n    while(t1 != NULL && t2 != NULL)\n        if(t1->data <= t2->data)\n        {\n            tail->next = t1;\n            tail = t1;\n            t1 = t1->next;\n        }   \n        else\n        {\n            tail->next = t2;\n            tail = t2;\n            t2 = t2->next;\n        }\n    \n    if(t1 == NULL)\n        tail->next = t2;\n    \n    else\n        tail->next = t1;\n    \n    return head;\n}"}
{"target":"paawankohli","func":"Node* mergeTwoLLs(Node *head1, Node *head2) \n{\n    Node* t1 = head1;\n    Node* t2 = head2;\n    \n    Node* head;\n    Node* tail;\n    \n    if(head1->data <= head2->data)\n    {\n        head = head1;\n        tail = head1;\n        t1 = t1->next;\n    }   \n    \n    else \n    {\n        head = head2;  \n        tail = head2;\n        t2 = t2->next;\n    }\n        \n    while(t1 != NULL && t2 != NULL)    \n        if(t1->data <= t2->data)\n        {\n            tail->next = t1;\n            tail = t1;\n            t1 = t1->next;\n        }\n        else\n        {\n            tail->next = t2;\n            tail = t2;\n            t2 = t2->next;\n        }\n    \n    if(t1 == NULL)\n        tail->next = t2;\n    \n    else\n        tail->next = t1;\n    \n    return head;\n}"}
{"target":"paawankohli","func":"#include <stdlib.h>\n#include <stdio.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr next;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid insert(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n\n    else if (ele < head -> data)\n    {\n        nptr temp = createNode(ele);\n        temp -> next = head;\n        head = temp;\n        return;\n    }\n\n    else\n    {\n        nptr prev = NULL, curr = head;\n\n        while(curr != NULL && curr -> data <= ele)\n        {\n            prev = curr;\n            curr = curr -> next;\n        }\n\n        nptr temp = createNode(ele);\n        prev -> next = temp;\n        temp -> next = curr;\n    }\n}\n\nvoid display(nptr head)\n{\n    nptr temp = head;\n\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp->next;\n    }\n\n    printf(\"NULL\\n\");\n}\n\nint main()\n{\n    nptr head = NULL;\n    int ch, ele;\n\n    printf(\"0. Exit      1. Insert      2. Display\\n\");\n\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1: printf(\"Element: \");\n                    scanf(\"%d\", &ele);\n                    insert(head, ele);\n                    break;\n\n            case 2: display(head);\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int coeff, exp;\n    nptr next;\n}node;\n\nnptr createNode(int c, int e)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> coeff = c;\n    temp -> exp = e;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nnptr insert(nptr head, int c, int e)\n{\n    if(head == NULL)\n        return head = createNode(c, e);\n\n    nptr temp = head;\n    while(temp -> next != NULL)\n        temp = temp -> next;\n\n    temp -> next = createNode(c, e);\n    return head;\n}\n\nvoid display(nptr head)\n{\n    while(head)\n    {\n        printf(\"%dx^%d\", head -> coeff, head -> exp);\n        if(head -> next)\n            printf(\" + \");\n\n        head = head -> next;\n    }\n\n    printf(\"\\n\");\n}\n\nint getCoeff(nptr poly, int exp)\n{\n    while(poly)\n    {\n        if (poly -> exp == exp)\n            return poly -> coeff;\n    }\n\n    return 0;\n}\n\nnptr add(nptr poly1, nptr poly2)\n{\n    nptr poly3, temp1 = poly1, temp2 = poly2;\n\n    while(temp1)\n    {\n        if ( getCoeff(poly2, temp1 -> exp) )\n            poly3 = insert(poly3,               temp1 -> coeff + getCoeff(poly2, poly1 -> exp),            poly1 -> exp);\n\n        poly1 = poly1 -> next;\n    }\n\n    temp1 = poly1, temp2 = poly2;\n\n    while(temp1)\n    {\n        if (getCoeff(poly3, temp1 -> exp) == 0)\n            poly3 = insert(poly3, temp1 -> coeff, temp1 -> exp);\n\n        temp1 = temp1 -> next;\n    }\n\n    while(temp2)\n    {\n        if (getCoeff(poly3, temp2 -> exp) == 0)\n            poly3 = insert(poly3, temp2 -> coeff, temp2 -> exp);\n\n        temp2 = temp2 -> next;\n    }\n\n    return poly3;\n\n}\n\nint main()\n{\n    nptr poly1  = NULL, poly2 = NULL, poly3 = NULL;\n    \n    int n, m;\n    int coeff, exp;\n\n    printf(\"Enter terms in poly1: \"); \n    scanf(\"%d\", &n);\n    \n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter coeff and exp: \"); \n        scanf(\"%d %d\", &coeff, &exp);\n        poly1 = insert(poly1, coeff, exp);\n    }\n\n    printf(\"Enter terms in poly2: \"); \n    scanf(\"%d\", &m);\n    \n    for(int i = 0 ; i < m ; i++)\n    {\n        printf(\"Enter coeff and exp: \"); \n        scanf(\"%d %d\", &coeff, &exp);\n        poly2 = insert(poly2, coeff, exp);\n    }\n\n    printf(\"\\n\");\n    display(poly1);\n    display(poly2);\n    \n    printf(\"\\n\");\n    display(poly3 = add(poly1, poly2));\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\ntypedef struct\n{\n    int c[20];\n    int front;\n    int rear;\n}queue;\nvoid enqueue(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Queue Full\\n\");\n    else\n    {\n        int i,j,t;\n        q->c[(q->rear)++]=n;\n        for (i=0;i<q->rear-1;i++)\n        {\n            for (j=0;j<q->rear-i-1;j++)\n            {\n                if (q->c[j]>q->c[j+1])\n                {\n                    t=q->c[j];\n                    q->c[j]=q->c[j+1];\n                    q->c[j+1]=t;\n                }\n            }\n        }\n    }\n}\nint dequeue(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}\nvoid display(queue *q)\n{\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    printf(\"\\n\");\n}\nint main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=0;\n    q.rear=0;\n    while (z==0)\n    {\n        printf(\"1. Enqueue \\t4. Dequeue \\t5. Display \\t6. Exit\\n\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                scanf(\"%d\",&e);\n                enqueue(&q,e);\n                break;\n            }\n            case 2:\n            {\n                break;\n            }\n            case 3:\n            {\n                break;\n            }\n            case 4:\n            {\n                printf (\"%d\\n\",dequeue(&q));\n                break;\n            }\n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    int data;\n    nptr lchild, rchild;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp->lchild = temp->rchild = NULL;\n    temp->data = x;\n    return temp;\n}\n\nnptr insertNode(nptr root, char path[])\n{\n    int i = 0;\n    nptr parent = NULL, curr = root;\n\n    while(curr && path[i])\n    {\n        parent = curr;\n\n        if (path[i] == 'L')\n            curr = parent -> lchild;\n        else if (path[i] == 'R')\n            curr = parent -> rchild;\n\n        i++;\n    }\n\n    if (curr == NULL && path[i] == '\\0')\n    {\n        printf(\"Path Found! Enter element: \");\n        int x; scanf(\"%d\", &x);\n\n        if (path[i - 1] == 'R')\n            parent -> rchild = createNode(x);\n        else if (path[i - 1] == 'L')\n            parent -> lchild = createNode(x);\n    }\n    else\n        printf(\"Path error!\");\n\n    return root;\n}\n\nvoid inorder(nptr root)\n{\n    if (root == NULL)\n        return;\n    \n    inorder(root->lchild);\n    printf(\"%d \", root->data);\n    inorder(root->rchild);\n}\n\nvoid preorder(nptr root)\n{\n    if (root == NULL)\n        return;\n\n    printf(\"%d \", root->data);\n    preorder(root->lchild);\n    preorder(root->rchild);\n}\n\nvoid postorder(nptr root)\n{\n    if (root == NULL)\n        return;\n\n    postorder(root->lchild);\n    postorder(root->rchild);\n    printf(\"%d \", root->data);\n}\n\nint main()\n{\n    printf(\"Enter Value of Root: \");\n    int key;\n    scanf(\"%d\", &key);\n\n    nptr root = createNode(key);\n\n    int ch;\n    \n    printf(\"1. Insert node    2. In-Order    3. Pre-Order    4. Post-Order      5. Exit\\n\");\n\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n        \n        switch (ch)\n        {\n            case 1: char P[10];\n                    printf(\"Enter Path: \");\n                    scanf(\"%s\", P);\n                    root = insertNode(root, P);\n                    break;\n\n            case 2: inorder(root);\n                    printf(\"\\n\");\n                    break;\n\n            case 3: preorder(root);\n                    printf(\"\\n\");\n                    break;\n\n            case 4: postorder(root);\n                    printf(\"\\n\");\n                    break;\n        }\n\n    }while(ch != 5);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n\nvoid reverse(int arr[], int size)\n{\n    int *start = arr , *end = arr + size - 1;\n\n    for(int i = 0 ; i < size\/2 ; i++)\n    {\n        int temp = *(start + i);\n        *(start + i) = *(end - i);\n        *(end - i) = temp;\n    }\n}\n\nint main()\n{\n    int a[50], n;\n\n    printf(\"Enter number of elements: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter elements: \");\n\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &a[i]);\n\n    reverse(a, n);\n\n    for(int i = 0 ; i < n ; i++)\n        printf(\"%d  \", a[i]);\n\n}"}
{"target":"paawankohli","func":"#define MAX 10\n#define true 1\n#define false 0\n\ntypedef struct \n{\n    char item[MAX];\n    int top;\n}stack;\n\nvoid isFull()\n{\n    printf(\"\\nError! Stack is full!\\n\");\n}\n\nint isEmpty()\n{\n    printf(\"\\nError ! Stack is empty!\\n\")\n}\n\nvoid push(stack* ps, char x)\n{\n    if(ps->top == MAX - 1)\n        isFull();\n    else\n        ps->item[++(ps->top)] = x;\n}\n\nchar pop(stack* ps)\n{\n    if(ps->top > -1)\n        return ps->item[(ps->top)--];\n    else\n    {\n        isEmpty();  \n        return '\\0';\n    }\n}\n\nvoid display(stack* ps)\n{\n    if(ps->top > -1)\n    {\n        for(int i = 0 ; i < ps->top ; i++)\n            printf(\"%d  \", ps->item[i]);\n    }\n}\n\nint main()\n{\n    printf()\n}\n\n"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include \"charStack.h\"\n#include <string.h>\n\n\n\nvoid strrev(char *str)\n{\n    int i = strlen(str) - 1, j = 0;\n\n    char ch;\n    \n    while (i > j)\n    {\n        ch = str[i];\n        str[i] = str[j];\n        str[j] = ch;\n        \n        i--;  j++;\n    }\n    \n}\n\nint toInt(char c)\n{\n    return c - '0';\n}\n\nint main()\n{\n    stack s;\n    char exp[15];\n\n    printf(\"Enter exp: \");\n    scanf(\"%s\", exp);\n\n    strrev(exp);        \n                        \n\n\n    for(int i = 0 ; exp[i] != '\\0' ; i++)\n    {\n        char token = exp[i];\n\n        if (token >= '0' && token <= '9')\n            push(&s, token);\n        \n        else\n        {\n            char a = pop(&s);                       \n            char b = pop(&s);\n\n            switch(token)\n            {\n                case '+':   push(&s, toInt(a) + toInt(b) + '0');\n                            break;\n\n                case '-':   push(&s, toInt(a) - toInt(b) + '0');\n                            break;\n\n                case '\/':   push(&s, toInt(a) \/ toInt(b) + '0');\n                            break;\n\n                case '*':   push(&s, toInt(a) * toInt(b) + '0');\n                            break;\n            }\n\n        }\n    }\n\n    printf(\"Ans = %d \\n\", toInt(pop(&s)));\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n#define size 5\n\ntypedef struct\n{\n    char* queue[size];\n    int front;\n    int rear;\n\n}que;\n\nvoid insertq(que* pq, char* item)\n{\n    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))\n    {\n        printf(\"queue is full\");\n        return;\n    }\n\n    else if (pq->rear ==  -1)\n    {\n        pq->rear++;\n        pq->front++;\n    }\n\n    else if (pq->rear == size - 1 && pq->front > 0)\n    {\n        pq->rear = 0;\n    }\n\n    else\n    {\n        pq->rear++;\n    }\n\n    pq->queue[pq->rear] = item;\n}\n\nvoid display(que* pq)\n{\n    int i;\n    printf(\"\\n\");\n\n    if (pq->front ==  -1)\n    {\n        printf(\"Queue is empty\");\n        return;\n    }\n\n    if (pq->front > pq->rear)\n    {\n        for (i = pq->front; i < size; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n        \n        for (i = 0; i <= pq->rear; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n    }\n\n    else\n    {\n        for (i = pq->front; i <= pq->rear; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n    }\n}\n\nvoid deleteq(que* pq)\n{\n    if (pq->front ==  -1)\n        printf(\"Queue is empty\");\n    \n    else if (pq->front == pq->rear)\n    {\n        printf(\"\\n%s deleted\", pq->queue[pq->front]);\n        pq->front =  -1;\n        pq->rear =  -1;\n    }\n\n    else if (pq->front == size - 1) \n    {\n        printf(\"\\n%s deleted\", pq->queue[pq->front]);\n        pq->front = 0;\n    }\n    \n    else\n        printf(\"\\n%s deleted\", pq->queue[(pq->front)++]);\n\n}\n\nint main()\n{\n    int ch;\n    que q;\n\n    q.front = q.rear = -1;\n\n    do\n    {\n        printf(\"\\nCircular Queue:\\n1. Insert \\n2. Delete\\n3. Display\\n0. Exit\");\n        printf(\"\\nEnter Choice 0-3? : \");\n        scanf(\"%d\", &ch);\n\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter String: \");\n                \n                char *n = malloc(30);\n                scanf(\"%s\", n);\n\n                insertq(&q, n);\n                break;\n\n            case 2:\n                deleteq(&q);\n                break;\n\n            case 3:\n                display(&q);\n                break;\n        }\n\n    }while (ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\ntypedef struct\n{\n    int c[20];\n    int front;\n    int rear;\n}queue;\n\nvoid enqueue(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Queue Full\\n\");\n    \n    else\n    {\n        int i,j,t;\n        q->c[(q->rear)++]=n;\n    \n        for (i=0 ; i<q->rear-1 ; i++)                          \n            for (j=0 ; j<q->rear-i-1 ; j++)\n                if (q->c[j] < q->c[j+1])\n                {\n                    t=q->c[j];\n                    q->c[j]=q->c[j+1];\n                    q->c[j+1]=t;\n                }\n       \n       \n    }\n}\n\nint dequeue(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n\n    else\n        return q->c[--(q->rear)];\n}\n\nvoid display(queue *q)\n{\n    printf(\"Cuurent queue: \\n\");\n    \n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    \n    printf(\"\\n\");\n}\n\nint main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=0;\n    q.rear=0;\n\n    printf(\"1. Enqueue \\t2. Dequeue \\t3. Display \\t4. Exit\\n\");\n\n\n    while (z==0)\n    {\n        printf(\"\\nCommand: \");\n        scanf(\"%d\",&k);\n\n        switch(k)\n        {\n            case 1:\n                    printf(\"Enter element : \");\n                    scanf(\"%d\",&e);\n                    enqueue(&q,e);\n                    break;\n\n            case 2:\n                    printf (\"%d dequed. \\n\", dequeue(&q));\n                    break;\n            \n            case 3:\n                    display(&q);\n                    break;\n            \n            case 4:\n                    z=1;\n        }\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node* nptr;\ntypedef struct Node\n{\n    nptr llink;\n    nptr rlink;\n    int ele;\n}node;\n\nnptr createNode(int x)\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=x;\n    temp->llink=NULL;\n    temp->rlink=NULL;\n    return temp;\n}\n\nvoid insertst(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n\n    if(!*start)\n    {\n        *start=temp;\n        *end=temp;\n    }\n    else\n    {\n        temp->rlink=*start;\n        (*start)->llink=temp;\n        *start=temp;\n    }\n}\n\nvoid inserten(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n    \n    if(!*end)\n    {\n        *start=temp; *end=temp; \n        return;\n    }\n    else\n    {\n        (*end)->rlink=temp;\n        temp->llink=*end;\n        *end=temp;\n    }\n}\n\nint delst(nptr* start,nptr* end)\n{\n    if(!*start)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    \n    nptr temp; int x;\n    temp=*start;\n    x=temp->ele;\n    \n    if(!((*start)->rlink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    \n    *start=(*start)->rlink;\n    (*start)->llink=NULL;\n\n    free(temp);\n    return x;\n}\n\nint delen(nptr* start,nptr* end)\n{\n    if(!*end)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    \n    nptr temp; int x;\n    temp=*end;\n    x=temp->ele;\n    \n    if(!((*end)->llink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    \n    *end=(*end)->llink;\n    (*end)->rlink=NULL;\n    \n    free(temp);\n    return x;\n}\n\nvoid disp(nptr front)\n{\n    printf(\"NULL <--->\");\n    for(nptr i=front;i;i=i->rlink)\n        printf(\" %d <---> \",i->ele);\n    \n    printf(\"NULL \\n\");\n}\n\nint main()\n{\n    printf(\"1:Insert@start 2:Insert@end 3:Delete@start\\n4:Delete@end 5:Display 6:Exit\\n\");\n    int i=1,ch,ele;\n    \n    nptr start=NULL,end=NULL;\n    \n    while(i)\n    {\n        printf(\"Command: \"); \n        scanf(\"%d\",&ch);\n        \n        switch(ch)\n        {\n            case 1:\n                    printf(\"Enter element to insert: \");\n                    scanf(\"%d\",&ele);\n                    insertst(&start,&end,ele);\n                    break;\n            \n            case 2:\n                    printf(\"Enter element to insert: \");\n                    scanf(\"%d\",&ele);\n                    inserten(&start,&end,ele);\n                    break;\n            \n            case 3:\n                    ele=delst(&start,&end);\n                    if(ele!=-99) \n                        printf(\"Deleted %d\\n\",ele);\n                    break;\n            \n            case 4:\n                    ele=delen(&start,&end);\n                    if(ele!=-99) \n                        printf(\"Deleted %d\\n\",ele);\n                    break;\n            \n            case 5:\n                    disp(start);\n                    break;\n            \n            case 6:\n                    i=0; break;\n        }\n\n    }\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node* nodePointer;\ntypedef struct node\n{\n    int data;\n    nodePointer link;\n}node;\n\ntypedef struct\n{\n    nodePointer front;\n    nodePointer rear;\n}queue;\n\nvoid init(queue* q)\n{\n    q->front=NULL;\n    q->rear=NULL;\n}\n\nvoid queueFull()\n{\n    fprintf(stderr,\"Queue Full\");\n    exit(EXIT_FAILURE);\n}\n\nint queueEmpty()\n{\n    return -1;\n}\n\nvoid insert(queue* q,int x)\n{\n    node* temp;\n\n    if(q->front==NULL)\n    {\n        temp=(nodePointer)malloc(sizeof(node));\n        temp->data=x;\n        temp->link=NULL;\n        q->front=temp;\n        q->rear=temp;\n    }\n\n    else\n    {\n        temp=(nodePointer)malloc(sizeof(node));\n        temp->data=x;\n        temp->link=NULL;\n        q->rear->link=temp;\n        q->rear=temp;\n    }\n}\n\nint deletee(queue* q)\n{\n    int temp;\n    node* t;\n\n    if(q->front==NULL)\n        return queueEmpty();\n    \n    else if(q->front==q->rear)\n    {\n        temp=q->front->data;\n        init(q);\n    }\n    \n    else\n    {\n        temp=q->front->data;\n        t=q->front;\n        q->front=q->front->link;\n        free(t);\n    }\n    \n    return temp;\n}\n\nvoid display(queue* q)\n{\n    queue temp;\n    init(&temp);\n    int i;\n\n    while(q->front!=NULL)\n    {\n        i=deletee(q);\n        printf(\" %d --> \",i);\n        insert(&temp,i);\n    }\n\n    printf(\" NULL\\n\");\n\n    \n    *q=temp;\n}\n\nint main()\n{\n    queue q;\n    int opt ,ele;\n\n    printf(\"\\n1. Insert \\n2. Delete \\n3. Display \\n4. Exit\");\n    \n    printf(\"\\nEnter option: \");\n    scanf(\"%d\",&opt);\n    \n    init(&q);\n    \n    while(opt!=4)\n    {\n        switch(opt)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter element: \");\n                scanf(\"%d\",&ele);\n                insert(&q,ele);\n                break;\n            }\n            \n            case 2:\n            {\n                printf(\"\\nYou have deleted %d\",deletee(&q));\n                break;\n            }\n            \n            case 3:\n            {\n                display(&q);\n                break;\n            }\n        }\n        printf(\"\\nEnter option: \");\n        scanf(\"%d\",&opt);\n    }\n    return 0;\n}           "}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\n\ntypedef struct node\n{\n    int data;\n    struct node *left;\n    struct node *right;\n}node;\n\ntypedef struct\n{\n    node* s[MAX];\n    int tos;\n}STACK;\n\nvoid push(STACK *s, node* n)\n{\n    s->s[++(s->tos)] = n;\n}\n\nnode* pop(STACK *s)\n{\n    return s->s[(s->tos)--];\n}\n\ntypedef struct\n{\n    node* c[MAX];\n    int front;\n    int rear;\n}queue;\n\nvoid InsertQ(queue *q, node* n)\n{\n    if (q->rear == MAX)\n        printf(\"Side Full\\n\");\n    \n    else\n        q->c[(q->rear)++]=n;\n}\n\nint QIsEmpty(queue *q)\n{\n    if (q->front == q->rear)\n        return 1;\n    else\n        return 0;\n}\n\nnode* DeleteQ(queue *q)\n{\n    return q->c[(q->front)++];\n}\n\nnode* create()\n{\n    node *p;\n    int x;\n    printf(\"Enter data(-1 for no data):\");\n    scanf(\"%d\", &x);\n    \n    if (x == -1)\n        return NULL;\n    \n    p = (node*)malloc(sizeof(node));\n    p->data = x;\n    \n    printf(\"Enter left child of %d:\\n\", x);\n    p->left = create();\n    printf(\"Enter right child of %d:\\n\", x);\n    p->right = create();\n    \n    return p;\n}\n\nvoid levelorder(node* root) \n{\n    queue q;\n    q.front = MAX\/2;\n    q.rear = MAX\/2;\n\n    InsertQ(&q, root);\n    \n    while (!QIsEmpty(&q)) \n    {\n        node* temp = DeleteQ(&q);\n        printf(\"%d\\t\", temp->data);\n    \n        if (temp->left) \n            InsertQ(&q, temp->left);\n        \n        if (temp->right) \n            InsertQ(&q, temp->right);\n    }\n}\n\nvoid inorder(node *t)\n{\n    node* curr;\n    curr = t;\n    STACK s;\n    s.tos = -1;\n    \n    push(&s, t);\n    curr = curr->left;\n    \n    while (s.tos != -1 || curr != NULL)\n    {\n        while (curr != NULL)\n        {\n            push(&s, curr);\n            curr = curr->left;\n        }\n    \n        curr = pop(&s);\n        printf(\"%d\\t\", curr->data);\n        curr = curr->right;\n    }\n}\n\nvoid preorder(node *t)\n{\n    node* curr;\n    STACK s;\n    \n    s.tos = -1;\n    \n    push(&s, t);\n    \n    while (s.tos != -1)\n    {\n        curr = pop(&s);\n        printf(\"%d\\t\", curr->data);\n    \n        if (curr->right)\n            push(&s, curr->right);\n\n        if (curr->left)\n            push(&s, curr->left);\n    }\n}\n\nvoid postorder(node *t)\n{\n    STACK s;\n    node*curr;\n    curr = t;\n    s.tos = -1;\n    \n    do\n    {\n        while (curr != NULL)\n        {\n            if (curr->right != NULL)\n                push(&s, curr->right);\n    \n            push(&s, curr);\n            curr = curr->left;\n        }\n    \n        curr = pop(&s);\n    \n        if (curr->right != NULL && s.s[s.tos] == curr->right)\n        {\n            pop(&s);\n            push(&s, curr);\n            curr = curr->right;\n        }\n        else\n        {\n            printf(\"%d\\t\", curr->data);\n            curr = NULL;\n        }\n    \n    }while (s.tos != -1);\n}\n\nint main()\n{\n    node *root;\n    root = create();\n\n    printf(\"\\nThe inorder traversal of tree is:\\n\");\n    inorder(root);\n\n    printf(\"\\nThe postorder traversal of tree is:\\n\");\n    postorder(root);\n\n    printf(\"\\nThe levelorder traversal of tree is:\\n\");\n    levelorder(root);\n\n    printf(\"\\nThe preorder traversal of tree is:\\n\");\n    preorder(root);\n\n    return 0;\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n\nint* bsearch(int* first, int size, int x)\n{\n    int* last = first + size - 1;\n\n    while(first <= last)\n    {\n        int *mid = first + (last - first)\/2;\n\n        if(*mid == x)\n            return mid;\n\n        else if(*mid > x)\n            last = mid - 1;\n\n        else if(*mid < x)\n            first = mid + 1;\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    int arr[20];\n    int n;\n    int toSearch;\n\n    printf(\"Enter array size: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter array elements in sorted order: \");\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &arr[i]);\n\n    printf(\"Enter element to be searched: \");\n    scanf(\"%d\", &toSearch);\n\n    if(bsearch(arr, n, toSearch) != NULL)\n    {\n        int pos = bsearch(arr, n, toSearch) - arr + 1;\n        printf(\"Element found at %dth position. \\n \\n\", pos);\n    }\n\n    else\n        printf(\"Element not found \\n\\n\");\n\n    printf(\"Use of Double pointers. Enter a two numbers:\");\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    \n    int *p1 = &a;\n    int **p2 = &p1;\n\n    int *p3 = &b;\n    int **p4 = &p3;\n\n\n    printf(\"Product = %d \\n \\n\", **p2 * **p4);\n\n}"}
{"target":"paawankohli","func":"#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n#include \"charStack.h\"\n\n\n\nvoid strrev(char *str)\n{\n    int i = strlen(str) - 1, j = 0;\n\n    char ch;\n    \n    while (i > j)\n    {\n        ch = str[i];\n        str[i] = str[j];\n        str[j] = ch;\n        \n        i--;  j++;\n    }\n}\n\nint isOperand(char ch)      \n{ \n    return (ch >= 'a' && ch <= 'z');\n} \n\nint prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n\n    if (ch == '*' || ch == '\/')\n        return 2; \n\n    if (ch == '^')\n        return 3;  \n    \n    return -1; \n} \n\nint infixToPostfix(char* exp, char* ans) \n{ \n    int i, k = 0; \n\n    stack s;\n\n    for (i = 0 ; exp[i] != '\\0' ; i++) \n    { \n    \n        if (isOperand(exp[i]))      \n            ans[k++] = exp[i]; \n        \n        else if (exp[i] == '(')     \n            push(&s, exp[i]); \n        \n        else if (exp[i] == ')')     \n        { \n            while (!isEmpty(&s) && top(&s) != '(') \n                ans[k++] = pop(&s); \n            \n            pop(&s);  \n        } \n        \n        else            \n        { \n            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) \n                ans[k++] = pop(&s); \n            \n            push(&s, exp[i]); \n        } \n    } \n\n    while (!isEmpty(&s))            \n        ans[k++] = pop(&s); \n\n    ans[k- 1] = '\\0';  \n} \n\nint main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);\n\n    strrev(exp);\n\n    for(int i = 0 ; i < strlen(exp) ; i++)\n    {\n        if (exp[i] == ')')\n            exp[i] ='(';\n\n        else if (exp[i] == '(')\n            exp[i] =')';\n    }\n\n    infixToPostfix(exp, ans);\n\n    strrev(ans);\n\n    printf(\"%s \\n\", ans); \n} "}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n    char *c[20];\n    int front;\n    int rear;\n}queue;\n\nvoid enqueueright(queue *q,char* n)\n{\n    if (q->rear == 20)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}\n\nvoid enqueueleft(queue *q,char* n)\n{\n    if (q->front == 0)\n        printf(\"Side Full\\n\");\n    else\n        q->c[--(q->front)]=n;\n}\n\nvoid dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n\n    else\n        printf(\"\\n%s deleted\", q->c[(q->front)++] );\n\n}\n\nvoid dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n    \n    else\n        printf(\"\\n%s deleted\", q->c[--(q->rear)] );\n}\n\nvoid display(queue *q)\n{\n    int i;\n\n    for (i = q->front ; i<q->rear ; i++)\n        printf(\"%s\\t\",q->c[i]);\n    \n    printf(\"\\n\");\n}\n\nint main()\n{\n    int z=0,k,e;\n    queue q;\n\n    q.front=10;\n    q.rear=10;\n\n    printf(\"1. Enqueue Right\\n2. Enqueue Left\\n3. Dequeue Left\\n4. Dequeue Right\\n5. Display \\n6. Exit\\n\");\n    \n    while (z == 0)\n    {\n        printf(\"\\nCommand: \");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter String: \");\n                char *n = malloc(30);\n                scanf(\"%s\", n);\n\n                enqueueright(&q,n);\n                break;\n            }\n            \n            case 2:\n            {\n                printf(\"\\nEnter String: \");\n                char *n = malloc(30);\n                scanf(\"%s\", n);\n\n                enqueueleft(&q,n);\n                break;\n            }\n            \n            case 3:\n            {\n                dequeueleft(&q);\n                break;\n            }\n            \n            case 4:\n            {\n                \n                printf (\"\\n:::::::::OPERATION NOT ALLOWED:::::::\\n\");\n\n                break;\n            }\n            \n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            \n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node* nptr;\ntypedef struct Node\n{\n    nptr llink;\n    nptr rlink;\n    int ele;\n}node;\n\nnptr createNode()\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->llink=temp;\n    temp->rlink=temp;\n    return temp;\n}\n\nvoid insert(nptr list,int x)\n{\n    nptr temp=createNode();\n    temp->ele=x;\n    temp->llink=list;\n    temp->rlink=list->rlink;\n    list->rlink=temp;\n    (temp->rlink)->llink=temp;\n}\n\nnptr getnum(char num[50])\n{\n    nptr head=createNode();\n\n    for(int i=strlen(num)-1;i>=0;i--)\n        insert(head,num[i]-'0');\n\n    return head;\n}\n\nnptr add(nptr num1,nptr num2)\n{\n    nptr sum=createNode();\n    nptr n1=num1->llink,n2=num2->llink;\n\n    int cin=0;\n    int s=0;\n\n    while(n1!=num1&&n2!=num2)\n    {\n        s=n1->ele+n2->ele+cin;\n\n        if(s>=10)\n        { \n            cin=1;\n            insert(sum, s-10);\n        }\n        else\n        {\n            cin=0;\n            insert(sum,s);\n        }\n        n1=n1->llink;\n        n2=n2->llink;\n    }\n    \n    while(n1!=num1)\n    {\n        s=n1->ele+cin;\n        \n        if(s>9)\n        { \n            cin=1; \n            insert(sum,s-10);\n        }\n        else \n        {\n            cin=0; \n            insert(sum,s);\n        }\n        \n        n1=n1->llink;\n    }\n    \n    while(n2!=num2)\n    {\n        s=n2->ele+cin;\n        \n        if(s>9)\n        { \n            cin=1; \n            insert(sum,s-10);\n        }\n        else \n        {\n            cin=0; \n            insert(sum,s);\n        }\n        \n        n2=n2->llink;\n    }\n    \n    return sum;\n}\n\nvoid disp(nptr list)\n{\n    nptr i=list->rlink;\n    \n    while(i!=list)\n    {\n        printf(\"%d\",i->ele);\n        i=i->rlink;\n    }\n    \n    printf(\"\\n\");\n}\n\nint main()\n{\n    char num1[50],num2[50];\n    \n    printf(\"Enter the first number: \");\n    scanf(\"%s\",num1);\n    printf(\"Enter the second number: \");\n    scanf(\"%s\",num2);\n\n    nptr n1=getnum(num1);\n    nptr n2=getnum(num2);\n    \n    \n    nptr sum=add(n1,n2);\n    \n    printf(\"The sum of the given numbers is \");\n    disp(sum);\n}\n"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node* nodeptr;\n\ntypedef struct node\n{\n    int data;\n    nodeptr link;\n}node;\n\n\n\nvoid add(nodeptr* head,int x)\n{\n    nodeptr temp=(nodeptr)malloc(sizeof(node));\n    nodeptr t;\n\n    temp->data=x;\n    temp->link=NULL;\n\n    if(!(*head))\n        *head=temp;\n    \n    else\n    {\n        for(t=(*head);t->link;t=t->link);\n        \n        t->link=temp;\n    }\n}\n\nnodeptr set_union(nodeptr a,nodeptr b)\n{\n    int i,flag=1;\n    \n    nodeptr c,at,bt;\n    c=NULL;\n    at=a;\n    bt=b;\n\n    for(;at;at=at->link)\n        add(&c,at->data);\n\n    at=a;\n\n    for(;bt;bt=bt->link)\n    {\n        for(;at;at=at->link)          \n            if(bt->data==at->data)\n            {\n                flag=0;\n                break;\n            }\n\n        if(flag)                    \n            add(&c,bt->data);                       \n    \n        flag=1;\n        at=a;\n    }\n    \n    return c;\n}\n\nnodeptr intersection(nodeptr a,nodeptr b)\n{\n    nodeptr c,at;\n    at=a;\n    c=NULL;\n\n    for(;b;b=b->link)\n    {\n        for(;at;at=at->link)\n            if(b->data==at->data)\n            {\n                add(&c,b->data);\n                break;\n            }\n\n        at=a;\n    }\n    \n    return c;\n}\n\nvoid display(nodeptr a)\n{\n    printf(\"\\n\");\n\n    for(;a;a=a->link)\n        printf(\"%d --> \",a->data);\n\n    printf(\"NULL\\n\");\n}\n\nint main()\n{\n    nodeptr a,b;\n    int n,m,i,t;\n\n    a=NULL;\n    b=NULL;\n\n    printf(\"\\nEnter number elements of first set: \");\n    scanf(\"%d\",&n);\n\n    printf(\"\\nEnter elements: \");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&a,t);\n    }\n    \n    printf(\"\\nEnter number elements of second set: \");\n    scanf(\"%d\",&m);\n    \n    printf(\"\\nEnter elements: \");\n    for(i=0;i<m;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&b,t);\n    }\n    \n    printf(\"\\nList one: \");\n    display(a);\n    printf(\"\\nList two: \");\n    display(b);\n\n    nodeptr u,in;\n    \n    u=set_union(a,b);\n    in=intersection(a,b);\n    \n    printf(\"\\nUnion: \");\n    display(u);\n    printf(\"\\nIntersection: \");\n    display(in);\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 10\n#define size 20\n#include <math.h>\n\ntypedef struct node\n{\n    char data;\n    struct node *left;\n    struct node *right;\n}node;\n\ntypedef struct\n{\n    node* s[MAX];\n    int tos;\n}STACK;\n\nnode* newNode(int v)\n{\n    node *temp = (node*)malloc(sizeof(node));\n    temp->left = temp->right = NULL;\n    temp->data = v;\n    return temp;\n}\n\ntypedef struct\n{\n    float a[size];\n    int tos;\n} STACKs;\n\nvoid pushs(STACKs *s, float x)\n{\n    s->a[++(s->tos)] = x;\n}\n\nfloat pops(STACKs *s)\n{\n    return s->a[(s->tos)--];\n}\n\nvoid push(STACK *s, node* n)\n{\n    s->s[++(s->tos)] = n;\n}\n\nnode* pop(STACK *s)\n{\n    return s->s[(s->tos)--];\n}\n\nvoid inorder(node* root)\n{\n    if (root == NULL)\n        return;\n\n    inorder(root->left);\n    printf(\"%c \", root->data);\n    inorder(root->right);\n}\n\nfloat calcu(node *root)\n{\n    node* curr;\n    curr = root;\n    \n    STACK s;\n    STACKs expression;\n    s.tos = -1;\n    expression.tos = -1;\n    \n    char m;\n    float p, q;\n    \n    do\n    {\n        while (curr != NULL)\n        {\n            if (curr->right != NULL)\n                push(&s, curr->right);\n    \n            push(&s, curr);\n            curr = curr->left;\n        }\n    \n        curr = pop(&s);\n    \n        if (curr->right != NULL && s.s[s.tos] == curr->right)\n        {\n            pop(&s);\n            push(&s, curr);\n            curr = curr->right;\n        }\n        else\n        {\n            m = curr->data;\n\n            switch (m)\n            {\n                case '*':   pushs(&expression, pops(&expression)*pops(&expression));\n                            break;\n                \n                case '\/':   pushs(&expression, pops(&expression) \/ pops(&expression));\n                            break;\n                \n                case '-':   pushs(&expression, pops(&expression) - pops(&expression));\n                            break;\n        \n                case '+':   pushs(&expression, pops(&expression) + pops(&expression));\n                            break;\n        \n                case '$':   p = pops(&expression);\n                            q = pops(&expression);\n                            pushs(&expression, pow(p, q));\n                            break;\n\n                default:    pushs(&expression, (float)(m - '0'));\n                            break;\n            }\n            curr = NULL;\n        }\n    }while (s.tos != -1);\n    \n    return expression.a[0];\n}\n\nint isOperator(char c)\n{\n    if (c == '+' || c == '-' || c == '*' || c == '\/' || c == '^')\n        return 1;\n    else\n        return 0;\n}\n\nnode* constructTree(char postfix[])\n{\n    STACK st;\n    st.tos = -1;\n    node *t, *t1, *t2;\n    \n    int i, j;\n    \n    for (j = 0; postfix[j] != '\\0'; j++);\n    \n    for (i = 0; i < j; i++)\n    {\n        if (!isOperator(postfix[i]))\n        {\n            t = newNode(postfix[i]);\n            push(&st, t);\n        }\n        else\n        {\n            t = newNode(postfix[i]);\n            t2 = pop(&st);\n            t1 = pop(&st);\n\n            t->right = t2;\n            t->left = t1;\n\n            push(&st, t);\n        }\n    }\n\n    return t;\n}\n\nint main()\n{\n    char postfix[MAX];\n    scanf(\" %s\", postfix);\n    node* r = constructTree(postfix);\n\n    printf(\"infix expression is \\n\");\n    inorder(r);\n\n    printf(\"\\n%.2f\", calcu(r));\n    return 0;\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n\nvoid multiply(int **arr1, int **arr2, int m, int n, int p, int q, int **product)\n{\n    int sum = 0;\n\n    for(int c = 0 ; c < m ; c++)\n        for(int d  = 0 ; d < q; d++)\n        {\n            for(int k = 0 ; k < p ; k++)\n                sum += arr1[c][k] * arr2[k][d];\n\n            product[c][d] = sum;\n            sum = 0;\n        }\n}\n\nint main()\n{\n    int m, n, p, q;\n\n    printf(\"Enter dimensions of first array:\");\n    scanf(\"%d %d\", &m, &n);\n\n    int **arr1 = calloc(m, sizeof(int*));\n\n    for(int i = 0 ; i < m ; i++)\n        arr1[i] = calloc(n, sizeof(int));\n\n    for(int i = 0 ; i < m; i++)\n        for(int j = 0; j < n; j++)\n            scanf(\"%d\", &arr1[i][j]);\n\n    printf(\"Enter dimensions of second array:\");\n    scanf(\"%d %d\", &p, &q);\n\n    int **arr2 = calloc(p, sizeof(int*));\n\n    for(int i = 0 ; i < p ; i++)\n        arr2[i] = calloc(q, sizeof(int));\n\n    for(int i = 0 ; i < p; i++)\n        for(int j = 0; j < q; j++)\n            scanf(\"%d\", &arr2[i][j]);\n\n    if(n != p)\n    {\n        printf(\"Invalid Order\");\n        return 0;\n    }\n\n    else if (n == p)\n    {\n        int **product = calloc(m, sizeof(int*));\n\n        for(int i = 0 ; i < m ; i++)\n            product[i] = calloc(q, sizeof(int));\n\n        multiply(arr1, arr2, m, n, p, q, product);\n\n        printf(\"Product: \\n\");\n\n        for(int i = 0 ; i < m ; i++)\n        {\n            for(int j = 0; j < q ; j++)\n                printf(\"%d \\t\", product[i][j]);\n\n            printf(\"\\n\");\n        }\n\n    }\n\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#define MAX 10\n\ntypedef struct\n{\n    int a[MAX];\n    int tos1;\n    int tos2;\n}stack;\n\nvoid push1(stack *s)\n{\n    if(s->tos2 - s->tos1 == 1)\n        printf(\"Array Full\");\n    else\n    {\n        printf(\"Push: \");\n        int ele;\n        scanf(\"%d\", &ele);\n        s->a[++(s->tos1)] = ele;\n    }\n}\n\nvoid push2(stack *s)\n{\n    if(s->tos2 - s->tos1 == 1)\n        printf(\"Array Full\");\n    else\n    {\n        printf(\"Push: \");\n        int ele;\n        scanf(\"%d\", &ele);\n        s->a[--(s->tos2)] = ele;\n    }\n}\n\nvoid pop1(stack *s)\n{\n    if (s->tos1 == -1)\n        printf(\"Underflow! \\n\");\n    else\n        printf(\"%d popped\\n\", s->a[(s->tos1)--]);\n}\n\nvoid pop2(stack *s)\n{\n    if (s->tos2 == MAX)\n        printf(\"Underflow! \\n\");\n    else\n        printf(\"%d popped\\n\", s->a[(s->tos2)++]);\n}\n\nvoid display(stack *s)\n{\n    printf(\"\\nStack 1: \");\n    for(int i = 0 ; i <= s->tos1 ; i++)\n        printf(\"%d \", s->a[i]);\n\n    printf(\"\\nStack 1: \");\n    for(int i = MAX - 1 ; i >= s->tos2 ; i--)\n        printf(\"%d \", s->a[i]);\n\n    printf(\"\\n\");\n\n\n}\n\nint main()\n{\n    stack s;\n    s.tos2 = MAX;\n    s.tos1 = -1;\n\n    int z = 0, k;\n\n    while (z == 0)\n    {\n        printf(\"1. Push1   2. Push2   3. Pop1    4. Pop2    5. Display    6. Exit \\n\");\n        scanf(\"%d\", &k);\n\n        switch(k)\n        {\n            case 1: push1(&s); break;\n            case 2: push2(&s); break;\n            case 3: pop1(&s); break;\n            case 4: pop2(&s); break;\n            case 5: display(&s); break;\n            case 6: z = 1;\n        }\n    }\n}\n"}
{"target":"paawankohli","func":"#include<stdio.h>\n#define MAX 40\ntypedef enum {True=1,False=0} Ans;\ntypedef struct \n{\n    int arr[MAX];\n    int front,rear;\n}QUEUE;\nvoid init(QUEUE* q)\n{\n    q->front=-1;\n    q->rear=-1;\n}\nvoid add(int e,QUEUE* q)\n{\n    if(q->rear==MAX-1)\n    {\n        printf(\"QUEUE FULL\\n\");\n        return;\n    }\n    q->rear+=1;\n    q->arr[q->rear]=e;\n}\nint del(QUEUE* q)\n{\n    if(q->front==q->rear)\n    {\n        printf(\"QUEUE EMPTY\\n\");\n        return -1;\n    }\n    q->front+=1;\n    return q->arr[q->front];\n}\nAns find(QUEUE* q,int e)\n{\n    QUEUE q1;\n    QUEUE* nq=&q1;\n    int num;\n    Ans f=False;\n    init(nq);\n    while(q->front!=q->rear)\n    {\n        num=del(q);\n        if(num==e)\n        {\n            f=True;\n            add(num,nq);\n        }\n        else\n            add(num,nq);\n    }\n    while(nq->front!=nq->rear)\n    {\n        add(del(nq),q);\n    }\n    return f;\n}\nvoid display(QUEUE* q)\n{\n    int i;\n    for(i=q->front+1;i<=q->rear;i=i+1)\n        printf(\"%d\\t\",q->arr[i]);\n    printf(\"\\n\");\n}\nint main()\n{\n    QUEUE q;\n    QUEUE* q1=&q;\n    init(q1);\n    add(1,q1);\n    add(2,q1);\n    add(3,q1);\n    add(4,q1);\n    add(5,q1);\n    add(6,q1);\n    add(7,q1);\n    if(find(q1,9))\n        printf(\"Found\\n\");\n    else\n        printf(\"Not Found\\n\");\n    if(find(q1,5))\n        printf(\"Found\\n\");\n    else\n        printf(\"Not Found\\n\");\n    display(q1);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include<string.h>\n#define CAPACITY 100\n\ntypedef struct\n{\n    char c[CAPACITY];\n    int front;\n    int rear;\n}queue;\n\nvoid enqueueright(queue *q,char n)\n{\n    if (q->rear == CAPACITY)\n        printf(\"Side Full\\n\");\n    \n    else\n        q->c[(q->rear)++]=n;\n}\n\nvoid enqueueleft(queue *q,char n)\n{\n    if (q->front==0)\n        printf(\"Side Full\\n\");\n    \n    else\n        q->c[--(q->front)]=n;\n}\n\nchar dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return '\\0';\n    }\n    \n    else\n        return q->c[(q->front)++];\n}\n\nchar dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return '\\0';\n    }\n    \n    else\n        return q->c[--(q->rear)];\n}\n\nvoid display(queue *q)\n{\n    int i;\n\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%c \",q->c[i]);\n    \n    printf(\"\\n\");\n}\n\nint getSize(queue *q)\n{\n    return q->rear - q->front;\n}\n\nint main()\n{\n    queue q;\n    q.front = CAPACITY\/2;\n    q.rear = CAPACITY\/2;\n\n    char word[20];\n    int isPalin  = 1;          \n\n    printf(\"Enter word: \");\n    scanf(\"%s\", word);\n\n    for(int i = 0 ; i < strlen(word) ; i++)\n        enqueueright(&q, word[i]);\n\n\n    for(int i = 0 ; i < strlen(word)\/2 ; i++)\n        if (dequeueleft(&q) != dequeueright(&q))\n        {\n            isPalin = 0;              \n            break;\n        }\n\n    isPalin ? printf(\"YES\\n\") : printf(\"NO\\n\");\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct node* nodeptr;\ntypedef struct node{\n    int data;\n    nodeptr link;\n}node;\n\n\nvoid add(nodeptr head,int x){\n    nodeptr temp=malloc(sizeof(node));\n    nodeptr t;\n    temp->data=x;\n    temp->link=head;\n        for(t=head;t->link!=head;t=t->link);\n        t->link=temp;\n}\nvoid init(nodeptr* head){\n    nodeptr temp=malloc(sizeof(node));\n    temp->data=-1;\n    temp->link=temp;\n    *head=temp;\n}\nvoid merge(nodeptr a,nodeptr b){\n    nodeptr trail1,trail2,temp1,temp2,i;\n    trail1=a;\n    trail2=b;\n    temp1=trail1->link;\n    temp2=trail2->link;\n    while(temp1!=a&&temp2!=b){\n        if(temp1->data<temp2->data){\n            trail1=trail1->link;\n            temp1=temp1->link;\n        }\n        else if(temp1->data==temp2->data){\n            trail2->link=temp2->link;\n            temp2->link=temp1->link;\n            temp1->link=temp2;\n            temp2=trail2->link;\n            trail1=trail1->link->link;\n            temp1=temp1->link->link;\n        }\n        else{\n            trail2->link=temp2->link;\n            trail1->link=temp2;\n            temp2->link=temp1;\n            temp2=trail2->link;\n            trail1=trail1->link;\n        }\n    }\n    if(temp2!=b){\n    trail1->link=temp2;\n    for(i=temp2;i->link!=b;i=i->link);\n    i->link=temp1;\n    free(trail2);\n}\n}\nvoid display(nodeptr a){\n    nodeptr t=a;\n    printf(\"\\n\");\n    for(a=a->link;a!=t;a=a->link){\n        printf(\"\\t%d\",a->data);\n    }\n}\nint main(){\n    nodeptr a,b,u,in;\n    int n,m,i,t;\n    init(&a);\n    init(&b);\n    printf(\"\\nEnter number elements of first list\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter elements\");\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&t);\n        add(a,t);\n    }\n    printf(\"\\nEnter number elements of second list\");\n    scanf(\"%d\",&m);\n    printf(\"\\nEnter elements\");\n    for(i=0;i<m;i++){\n        scanf(\"%d\",&t);\n        add(b,t);\n    }\n    display(a);\n    display(b);\n    merge(a,b);\n    display(a);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define SIZE 50\n\ntypedef struct Node* nptr;\ntypedef struct Node\n{\n    nptr llink;\n    nptr rlink;\n    char* ele;\n}node;\n\nnptr createNode()\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=(char*)malloc(SIZE*sizeof(char));\n\n    temp->llink=NULL;\n    temp->rlink=NULL;\n\n    return temp;\n}\n\nvoid insertf(nptr list,char* x)\n{\n    nptr temp=createNode();\n    strcpy(temp->ele,x);\n\n    if(!list->rlink)\n    {\n        list->rlink=temp;\n        temp->llink=list;\n        temp->rlink=NULL;\n\n        return;\n    }\n\n    (list->rlink)->llink=temp;\n    temp->llink=list;\n    temp->rlink=list->rlink;\n    list->rlink=temp;\n}\n\nchar* delf(nptr list)\n{\n    if(!(list->rlink))\n    {\n        printf(\"Underflow!!\\n\"); \n        return NULL;\n    }\n\n    nptr temp=list->rlink;\n    list->rlink=temp->rlink;\n\n    if(temp->rlink)\n        (temp->rlink)->llink=list;\n    \n    char* str=(char*)malloc(SIZE*sizeof(char));\n    strcpy(str,temp->ele);\n    free(temp);\n\n    return str;\n}\n\nvoid rev(nptr list)\n{\n    nptr trv=list;\n\n    while(trv->rlink)\n        trv=trv->rlink;\n\n    nptr last=trv;\n    \n    while(trv!=list)\n    {\n        nptr temp=trv->llink;\n        trv->llink=trv->rlink;\n        trv->rlink=temp;\n        trv=temp;\n    }\n    \n    (list->rlink)->rlink=NULL;\n    list->rlink=last;\n    last->llink=list;\n}\n\nvoid disp(nptr list)\n{\n    nptr i=list->rlink;\n    \n    while(i)\n    {\n        printf(\"%s  \",i->ele);\n        i=i->rlink;\n    }\n    \n    printf(\"\\n\");\n}\n\nint main()\n{\n    int n;\n    printf(\"Enter no. of elemnts: \");\n    scanf(\"%d\", &n);\n    \n    char str[SIZE];\n    nptr list=createNode();\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter word to insert: \"); \n        scanf(\"%s\", str);\n        insertf(list, str);\n    }\n\n    disp(list);\n    rev(list);\n    disp(list);\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 10\n\ntypedef struct node\n{\n    int data;\n    struct node *left;\n    struct node *right;\n} node;\n\nnode* create()\n{\n    node *p;\n    \n    int x;\n    printf(\"Enter data(-1 for no data):\");\n    scanf(\"%d\", &x);\n\n    if (x == -1)\n        return NULL;\n\n    p = (node*)malloc(sizeof(node));\n    p->data = x;\n\n    printf(\"Enter left child of %d:\\n\", x);\n    p->left = create();\n\n    printf(\"Enter right child of %d:\\n\", x);\n    p->right = create();\n    \n    return p;\n}\n\nvoid inorder(node *t)\n{\n    if (t == NULL)\n        return;\n\n    inorder(t->left);\n    printf(\"%d \", t->data);\n    inorder(t->right);\n}\n\nnode* copy(node *t)\n{\n    node *p;\n\n    if (t == NULL)\n        return NULL;\n\n    p = (node*)malloc(sizeof(node));\n    p->data = t->data;\n\n    p->left = copy(t->left);\n    p->right = copy(t->right);\n\n    return p;\n}\n\nint Equal(node* root1, node* root2)\n{\n    return  (root1 == NULL && root2 == NULL) || ((root1 && root2 && root1 -> data == root2 -> data)\n            && Equal(root1->left, root2->left) && Equal(root1->right, root2->right));\n}\n\nint main()\n{\n    node *root, *c;\n    root = create();\n    c = copy(root);\n\n    printf(\"\\nThe inorder traversal of copied tree is:\\n\");\n    inorder(c);\n\n    printf(\"\\nThe inorder traversal of original tree is:\\n\");\n    inorder(root);\n\n    if(Equal(root, c))\n        printf(\"\\nEqual!\\n\");\n    else\n        printf(\"\\nNot Equal!\\n\");\n    \n    return 0;\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <string.h>\n\ntypedef struct\n{\n    char a[20][20];\n    int tos;\n}stack;\n\nvoid push(stack *s, char a[])\n{\n    strcpy(s->a[(++s->tos)], a);\n}\n\nvoid pop(stack * s, char temp[])\n{\n    strcpy(temp, s->a[(s->tos)--]);\n}\n\nint alnum(char t)\n{\n    switch(t)\n    {\n        case '+':\n        case '-':\n        case '\/':\n        case '*':\n        case '$':\n                    return 0;\n    }\n\n    return 1;\n}\n\nint main()\n{\n    stack s;\n    s.tos = -1;\n    char pre[20], pos[20], t;\n\n    printf(\"Enter prefix: \");\n    scanf(\"%s\", pre);\n\n    int i, j;\n\n    int l = strlen(pre);\n\n    for(int i = 0 ; i < l ; i++)\n    {\n        t = pre[i];\n        char temp[2] = {t, '\\0'};\n\n        push(&s, temp);\n\n        while (alnum(s.a[s.tos][0]) && alnum(s.a[(s.tos - 1)][0]) && s.tos != 0)\n        {\n            char temp1[20], temp2[20], temp3[20];\n            pop(&s, temp1);\n            pop(&s, temp2);\n            pop(&s, temp3);\n\n            strcat(temp2, temp1);\n            strcat(temp2, temp3);\n            push(&s, temp2);\n        }\n    }\n\n    strcpy(pos, s.a[0]);\n\n    printf(\"Postfix expression is %s\", pos);\n}\n"}
{"target":"paawankohli","func":"#include<stdio.h>\n#define MAX 40\n\ntypedef struct \n{\n    int stack1[MAX];\n    int stack2[MAX];\n    int top1,top2;\n}QUEUE;\n\nvoid add(QUEUE* q, int ele)\n{\n    if(q->top1 == MAX)\n    {\n        printf(\"QUEUE FULL \\n\");\n        return;\n    }\n    \n    q->top1++;\n    q->stack1[q->top1] = ele;\n}\n\nint del(QUEUE* q)\n{\n    if(q->top1 == -1 && q->top2 == -1)\n    {\n        printf(\"QUEUE EMPTY\\n\");\n        return -1;\n    }\n\n    if(q->top2 == -1)\n        while(q->top1 != -1)\n            q->stack2[++(q->top2)] = q->stack1[(q->top1)--];\n        \n    return q->stack2[(q->top2)--];\n}\n\nint main()\n{\n    QUEUE q;\n\n    q.top1 = -1;\n    q.top2 = -1;\n\n    int ch, n;\n\n    do\n    {\n        printf(\"\\n\\n1. Insert\\n2. Delete\\n0. Exit\");\n        printf(\"\\nEnter Choice? : \");\n        scanf(\"%d\", &ch);\n\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter number: \");\n                scanf(\"%d\", &n);\n                add(&q, n);\n                break;\n\n            case 2:\n                printf(\"\\n%d deleted \\n\", del(&q));\n                break;\n        }\n\n    }while (ch != 0);\n    \n    return 0;\n}"}
{"target":"paawankohli","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node* nodeptr;\n\ntypedef struct node\n{\n    int data;\n    nodeptr link;\n}node;\n\nvoid add(nodeptr* head,int x)\n{\n    nodeptr temp=malloc(sizeof(node));\n    nodeptr t;\n\n    temp->data=x;\n    temp->link=NULL;\n\n    if(!(*head))\n        *head=temp;\n    else\n    {\n        for(t=(*head);t->link;t=t->link);\n        t->link=temp;\n    }\n}\n\nvoid del(nodeptr a)\n{\n    nodeptr t;\n\n    for(t=a->link;t;)\n    {\n        if(a->data==t->data)\n        {\n            a->link=t->link;\n            free(t);\n            t=a->link;\n        }\n        else\n        {\n            a=a->link;\n            t=t->link;\n        }\n    }\n}\n\nvoid display(nodeptr a)\n{\n    printf(\"\\n\");\n\n    for(;a;a=a->link)\n        printf(\"\\t%d\",a->data);\n}\n\nint main()\n{\n    nodeptr a,b,u,in;\n    int n,i,t;\n    \n    a=NULL;\n    \n    printf(\"\\nEnter number elements of list\");\n    scanf(\"%d\",&n);\n    \n    printf(\"\\nEnter elements\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&a,t);\n    }\n    \n    display(a);\n    del(a);\n    display(a);\n}"}
{"target":"paawankohli","func":"#include<stdio.h> \n#include <stdlib.h>\n\nstruct Node \n{ \n    int coeff; \n    int pow; \n    struct Node *next; \n}; \n            \n \nvoid create_node(int x, int y, struct Node **temp) \n{ \n    struct Node *r, *z; \n    z = *temp; \n\n    if(z == NULL) \n    { \n        r =(struct Node*)malloc(sizeof(struct Node)); \n        r->coeff = x; \n        r->pow = y; \n        *temp = r; \n        r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n    else\n    { \n        r->coeff = x; \n        r->pow = y; \n        r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n} \n\nvoid polyadd(struct Node *poly1, struct Node *poly2, struct Node *poly) \n{ \n    while(poly1->next && poly2->next) \n    { \n        \n        \n        if(poly1->pow > poly2->pow) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        \n        \n        \n        else if(poly1->pow < poly2->pow) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        } \n        \n        \n        else\n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff+poly2->coeff; \n            poly1 = poly1->next; \n            poly2 = poly2->next; \n        } \n        \n        \n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    } \n\n    while(poly1->next || poly2->next) \n    { \n        if(poly1->next) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        \n        if(poly2->next) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        }\n\n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    } \n} \n\n \nvoid show(struct Node *node) \n{ \n    while(node->next != NULL) \n    { \n        printf(\"%dx^%d\", node->coeff, node->pow); \n        node = node->next; \n    \n        if(node->next != NULL) \n            printf(\" + \"); \n    }\n\n    printf(\"\\n\"); \n} \n \nint main() \n{ \n    struct Node *poly1 = NULL, *poly2 = NULL, *poly = NULL; \n    \n    int n , m, coeff, power;\n\n    printf(\"Enter no. of terms in the first polynomial: \");\n    scanf(\"%d\", &n);\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter coeff and power of x : \");\n        scanf(\"%d %d\", &coeff, &power);\n        create_node(coeff, power, &poly1); \n\n    }\n\n    printf(\"Enter no. of terms in the second polynomial: \");\n    scanf(\"%d\", &m);\n    for(int i = 0 ; i < m ; i++)\n    {\n        printf(\"Enter coeff and power of x : \");\n        scanf(\"%d %d\", &coeff, &power);\n        create_node(coeff, power, &poly2); \n\n    }\n\n    printf(\"1st Number: \");     show(poly1); \n    printf(\"2nd Number: \");     show(poly2); \n    \n    poly = (struct Node *)malloc(sizeof(struct Node)); \n    \n    polyadd(poly1, poly2, poly); \n     \n    printf(\"Added polynomial: \"); show(poly); \n\n    return 0; \n} \n"}
{"target":"paawankohli","func":"#include <stdio.h>\n#define size 5\n\ntypedef struct\n{\n    char queue[size];\n    int front;\n    int rear;\n\n}que;\n\nvoid insertq(que* pq, int item)\n{\n    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))\n    {\n        printf(\"queue is full\");\n        return;\n    }\n\n    else if (pq->rear ==  -1)\n    {\n        pq->rear++;\n        pq->front++;\n    }\n\n    else if (pq->rear == size - 1 && pq->front > 0)\n    {\n        pq->rear = 0;\n    }\n\n    else\n    {\n        pq->rear++;\n    }\n\n    pq->queue[pq->rear] = item;\n}\n\nvoid display(que* pq)\n{\n    int i;\n    printf(\"\\n\");\n\n    if (pq->front ==  -1)\n    {\n        printf(\"Queue is empty\");\n        return;\n    }\n\n    if (pq->front > pq->rear)\n    {\n        for (i = pq->front; i < size; i++)\n            printf(\"%d \", pq->queue[i]);\n        \n        for (i = 0; i <= pq->rear; i++)\n            printf(\"%d \", pq->queue[i]);\n    }\n\n    else\n    {\n        for (i = pq->front; i <= pq->rear; i++)\n            printf(\"%d \", pq->queue[i]);\n    }\n}\n\nvoid deleteq(que* pq)\n{\n    if (pq->front ==  -1)\n        printf(\"Queue is empty\");\n    \n    else if (pq->front == pq->rear)\n    {\n        printf(\"\\n%d deleted\", pq->queue[pq->front]);\n        pq->front =  -1;\n        pq->rear =  -1;\n    }\n\n    else if (pq->front == size-1) \n    {\n        printf(\"\\n%d deleted\", pq->queue[pq->front]);\n        pq->front = 0;\n    }\n    \n    else\n        printf(\"\\n%d deleted\", pq->queue[(pq->front)++]);\n\n}\n\nint main()\n{\n    int n, ch;\n    que q;\n\n    q.front = q.rear = -1;\n\n    do\n    {\n        printf(\"\\nCircular Queue:\\n1. Insert \\n2. Delete\\n3. Display\\n0. Exit\");\n        printf(\"\\nEnter Choice 0-3? : \");\n        scanf(\"%d\", &ch);\n\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter number: \");\n                scanf(\"%d\", &n);\n                insertq(&q, n);\n                break;\n\n            case 2:\n                deleteq(&q);\n                break;\n\n            case 3:\n                display(&q);\n                break;\n        }\n\n    }while (ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int rowNum;\n    printf(\"Enter no. of rows:\");\n    scanf(\"%d\", &rowNum);\n\n    int **table = calloc(rowNum, sizeof(int*));\n\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize;\n        printf(\"Enter no. of columns of %dth row: \", i + 1);\n        scanf(\"%d\", &colSize);\n\n        table[i] = calloc(colSize + 1, sizeof(int));\n\n        table[i][0] = colSize;  \n\n        printf(\"Enter %d elements: \", colSize);\n        for(int j = 1 ; j <= table[i][0] ; j++)\n            scanf(\"%d\", &table[i][j]);\n    }\n\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize = table[i][0];\n\n        for(int j = 1 ; j <= colSize ; j++)\n            printf(\"%d\\t\", table[i][j]);\n\n        printf(\"\\n\");\n\n        free(table[i]);\n    }\n\n    free(table);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node* nptr;\ntypedef struct node\n{\n    nptr next;\n    int data;\n}node;\n\nnptr reverse(nptr head)\n{\n    if (head -> next == NULL)\n        return head; \n\n    nptr newList = reverse(head -> next);\n    head -> next = NULL;\n\n    nptr temp = newList;\n\n    while(temp -> next != NULL)\n        temp = temp -> next;\n\n    temp -> next = head;\n\n    return newList;\n}\n\nnptr reverse2(nptr head)\n{\n    if(head -> next == NULL)\n        return head;\n\n    nptr prev = NULL; \n    nptr curr = head;\n    nptr after = head -> next;\n\n\n    while(curr)\n    {\n        after = curr -> next;\n        curr -> next = prev;\n        \n        prev = curr;\n        curr = after;\n    }\n\n    return prev;\n}\n\nnptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> next = NULL;\n\n    return temp;\n}\n\nvoid insertFront(nptr &head, int ele)\n{\n    nptr temp = createNode(ele);\n    temp -> next = head;\n\n    head = temp;\n}\n\nvoid insertRear(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n\n    nptr rear = head;\n    \n    while(rear -> next != NULL)\n        rear = rear -> next;\n\n    nptr temp = createNode(ele);\n    rear -> next = temp;\n}\n\nint deleteFront(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n\n    nptr temp = head;\n    head = head -> next;\n\n    int x = temp -> data;\n    free(temp);\n    return x;\n}\n\nint deleteRear(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n\n    nptr rear2 = head;\n    nptr rear = head -> next;\n\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n\n    rear2 -> next = rear2 -> next -> next;\n    int x = rear -> data;\n\n    free(rear);\n    return x;\n}\n\nvoid display(nptr &head)\n{\n    nptr temp = head;\n\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n\n    printf(\"NULL\\n\");\n}\n\nint main()\n{\n    printf(\"1. Insert Front   2. Insert Rear   3. Delete Front   4. Delete Rear   5. Display   6. Reverse 7. Reverse2   0. Exit\\n\");\n    int ch, ele;\n\n    nptr head = NULL;\n\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    insertFront(head, ele);\n                    break;\n\n            case 2:\n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    insertRear(head, ele);\n                    break;\n            \n            case 3: ele = deleteFront(head);\n                    \n                    if(ele == -1)\n                        printf(\"List empty!\\n\");\n                    else\n                        printf(\"%d removed\\n\", ele);\n                        \n                    break;\n\n            case 4: ele = deleteRear(head);\n                    \n                    if(ele == -1)\n                        printf(\"List empty!\\n\");\n                    else\n                        printf(\"%d removed\\n\", ele);\n                        \n                    break;\n\n            case 5: display(head);\n                    break;\n\n            case 6: head = reverse(head);\n                    break; \n            \n            case 7: head = reverse2(head);\n                    break;\n        }\n\n    }while(ch != 0);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n\nvoid strCopy(char *source, char* destin)\n{\n    if (*source == '\\0')\n    {\n        *destin = '\\0';\n        return;\n    }\n\n    *destin = *source;\n    strCopy(source + 1, destin + 1);\n}\n\n\nint main()\n{\n    char a[50] = \"\", b[50] = \"\";\n\n    printf(\"Enter string:\\n\");\n    scanf(\"%s\", a);\n    \n    printf(\"\\nstring 1: %s string2 2: %s\\n\", a, b);\n    printf(\"\\nCopying strings...\\n\");\n\n    strCopy(a, b);\n\n    printf(\"\\nstring 1: %s string2 2: %s\\n\", a, b);\n\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct\n{\n    char name[20];\n    int rollNum;\n    float gpa;\n} STUDENT;\n\nvoid readData(STUDENT* s)\n{\n    printf(\"Enter name: \");\n    scanf(\"%s\", (s->name));\n\n    printf(\"Enter roll number: \");\n    scanf(\"%d\", &(s->rollNum));\n\n    printf(\"Enter GPA: \");\n    scanf(\"%f\", &(s->gpa));\n}\n\nvoid printData(STUDENT* s)\n{\n    printf(\"Name: %s \\n\", (s->name)); \n    printf(\"Roll number: %d \\n\", s->rollNum);\n    printf(\"GPA: %f \\n\", s->gpa);\n}\n\nint main()\n{\n\n    int n;\n    printf(\"Enter no. of students:\");\n    scanf(\"%d\", &n);\n\n    STUDENT* ptr = calloc(n, sizeof(STUDENT));\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nEnter data of %dth student: \\n\", i + 1);\n        readData(ptr + i);\n    }\n\n    \n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        STUDENT temp;\n        \n        for(int j = 0 ; j < n - i - 1 ; j++)\n            if( ptr[j].rollNum  > ptr[j+1].rollNum )\n            {\n                temp = ptr[j];\n                ptr[j] = ptr[j+1];\n                ptr[j+1] = temp;\n            }\n    }\n\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nData of %dth student: \\n\", i + 1);\n        printData(ptr + i);\n    }\n\n    free(ptr);\n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n#include <string.h>\n\nint move(int n, char s, char d, char a)\n{\n    \n    \n    \n\n    if (n == 1)\n    {\n        printf(\"Move disk from %c to %c \\n\", s, d);\n        return 1;\n    }\n\n    else\n\n    {\n        int n1  = move(n - 1, s, a, d);\n    \n        int n2 = 1; \n        printf(\"Move disk from %c to %c \\n\", s, d);\n\n        int n3 = move(n - 1, a, d, s);\n\n        return n1 + n2 + n3;\n    }\n}\n\n\nint main()\n{\n    int plates;\n    char source = 'A', destin = 'C', aux = 'B';\n\n    printf(\"Enter number of plates on A:\");\n    scanf(\"%d\", &plates);\n\n    printf(\"No. of moves: %d \\n\", move(plates, source, destin, aux));\n\n    \n}"}
{"target":"paawankohli","func":"#include <stdio.h>\n\ndouble add(double L[], int n)\n{\n    double sum = 0;\n\n    for(int i = 0 ; i < n ; i++)\n        sum += L[i];\n\n    return sum;\n}\n\nint Lsearch(int arr[], int n, int x)\n{\n    for(int i = 0 ; i < n ; i++)\n        if(arr[i] == x)\n            return i + 1;\n\n    return -1;\n}\n\nvoid multiply(int a[][10], int b[][10], int m, int n, int p, int q)\n{\n    int f[10][10], sum = 0;\n\n    if(n != p)\n    {\n        printf(\"Invalid Order\\n\");\n        return;\n    }\n\n    for(int c = 0 ; c < m ; c++)\n        for(int d = 0 ; d < q ; d++)\n        {\n            for(int k = 0 ; k < p ; k++)\n                sum += a[c][k] * b[k][d];\n\n            f[c][d] = sum;\n            sum = 0;\n        }\n\n    printf(\"Product of matrices: \\n\");\n\n    for(int c = 0 ; c < m ; c++)\n    {\n        for(int d = 0 ; d < q ; d++)\n            printf(\"%d\\t\", f[c][d]);\n\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\nint secLar(int a[], int n)\n{\n    int first, second;\n\n    first = second = -99999;\n\n    for(int i = 0; i < n ; i++)\n        if(a[i] > first)\n        {\n            second = first;\n            first = a[i];\n        }\n        else if(a[i] > second && a[i] < first)\n            second = a[i];\n\n    return second;\n}\n\nint main()\n{\n    int ch;\n\n    do\n    {\n        printf(\"1. Add array elements\\n\");\n        printf(\"2. Linear Search\\n\");\n        printf(\"3. Multiply Matrices\\n\");\n        printf(\"4. Find second largest element in an array\\n\");\n        printf(\"5. Exit\\n\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &ch);\n\n        int size1; double arr1[50];                         \n        int size2, arr2[50], x;                             \n        int m, n, p, q, first[10][10], second[10][10];      \n        int size3, arr3[50];                                \n\n        switch(ch)\n        {\n            case 1:\n                    \n\n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size1);\n                    \n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size1 ; i++)\n                        scanf(\"%lf\", &arr1[i]);\n\n                    printf(\"Sum of elements is %lf \\n\\n\", add(arr1, size1));\n                    break;\n\n            case 2:\n                    \n\n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size2);\n\n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size2 ; i++)\n                        scanf(\"%d\", &arr2[i]);\n\n                    printf(\"Enter element to be searched: \");\n                    scanf(\"%d\", &x);\n\n                    printf(\"Element found at %dth position.\\n\\n\", Lsearch(arr2, size2, x));\n                    break;\n\n            case 3:\n                    \n\n                    printf(\"Enter order of first matrice: \");\n                    scanf(\"%d %d\", &m, &n);\n                    printf(\"Enter elements: \\n\");\n                    for(int i = 0 ; i < m ; i++)\n                        for(int j = 0 ; j < n ; j++)\n                            scanf(\"%d\", &first[i][j]);\n\n                    printf(\"Enter order of second matrice: \");\n                    scanf(\"%d %d\", &p, &q);\n                    printf(\"Enter elements: \\n\");\n                    for(int i = 0 ; i < p ; i++)\n                        for(int j = 0 ; j < q ; j++)\n                            scanf(\"%d\", &second[i][j]);\n\n                    multiply(first, second, m, n, p, q);\n                    break;\n            \n            case 4: \n                    \n\n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size3);\n\n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size3 ; i++)\n                        scanf(\"%d\", &arr3[i]);\n\n                    printf(\"Second largest element is %d.\\n\\n\", secLar(arr3, size3));\n                    break;\n            \n            case 5: \n                    break;\n\n            default:\n                    printf(\"Invalid input. Please try again!\\n\\n\");\n        }\n\n    }while(ch != 5);\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nsize_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}\n\nsize_t num_cols(char *filename) {\n    size_t m = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != '\\n'; c = fgetc(f))\n        m++;\n    fclose(f);\n    return m;\n}\n\nbool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    \n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n\n    fclose(f);\n    return trees;\n}\n\nint main() {\n    char *filename = \"Trees.txt\";\n    size_t n = num_rows(filename);\n    size_t m = num_cols(filename);\n    bool **trees = get_trees(filename, n, m);\n\n    size_t count = 0;\n    size_t j = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (trees[i][j]) count++;\n        j = (j + 3) % m;\n    }\n    printf(\"Answer: %zu\\n\", count);\n\n    for (size_t i = 0; i < n; i++)\n        free(trees[i]);\n    free(trees);\n    \n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool is_pass(bool* info) {\n    for (int i = 0; i < 7; i++)\n        if (!info[i]) return false;\n    return true;\n}\n\nint main() {\n    char *filename = \"Passports.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t count = 0;\n\n    char cur = '\\0';\n    bool *info = calloc(sizeof(bool), 7);\n    char *curs = calloc(sizeof(char), 3);\n\n    for (cur = fgetc(f); cur != EOF; cur = fgetc(f)) {\n        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {\n            case 333: \n                info[0] = true; break;\n            case 340: \n                info[1] = true; break;\n            case 336: \n                info[2] = true; break;\n            case 323: \n                info[3] = true; break;\n            case 311: \n                info[4] = true; break;\n            case 308: \n                info[5] = true; break;\n            case 317: \n                info[6] = true; break;\n        }\n        if (cur == '\\n' && curs[2] == '\\n') {\n            if (is_pass(info)) count++;\n            free(info);\n            info = calloc(sizeof(bool), 7);\n        }\n        curs[0] = curs[1];\n        curs[1] = curs[2];\n        curs[2] = cur;\n    }\n\n    printf(\"Answer: %zu\\n\", count);\n\n    free(info);\n    free(curs);\n    fclose(f);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n\nint main() {\n    char *filename = \"Passwords.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL;\n    size_t n = 0;\n    size_t valids = 0;\n    while (getline(&line, &n, f) != -1) {\n        char *str = strchr(line, ':');\n        char *pass = calloc(sizeof(char), strlen(str) - 2);\n        strcpy(pass, &str[2]);\n        int i = strtol(line, &line, 10);\n        line++;\n        int j = strtol(line, &line, 10);\n        char c = line[1];\n        \n        if ((pass[i - 1] == c || pass[j - 1] == c) && pass[i - 1] != pass[j - 1])\n            valids++;\n\n        free(pass);\n    }\n\n    printf(\"Answer: %zu\\n\", valids);\n    fclose(f);\n\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nsize_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}\n\nsize_t num_cols(char *filename) {\n    size_t m = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != '\\n'; c = fgetc(f))\n        m++;\n    fclose(f);\n    return m;\n}\n\nbool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    \n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n\n    fclose(f);\n    return trees;\n}\n\nsize_t encountered(bool **trees, int n, int m, int rowadd, int coladd) {\n    size_t count = 0;\n    size_t j = 0;\n    for (size_t i = 0; i < n; i += rowadd) {\n        if (trees[i][j]) count++;\n        j = (j + coladd) % m;\n    }\n\n    return count;\n}\n\nint main() {\n    char *filename = \"Trees.txt\";\n    size_t n = num_rows(filename);\n    size_t m = num_cols(filename);\n    bool **trees = get_trees(filename, n, m);\n\n    size_t count = 1;\n    count *= encountered(trees, n, m, 1, 1);\n    count *= encountered(trees, n, m, 1, 3);\n    count *= encountered(trees, n, m, 1, 5);\n    count *= encountered(trees, n, m, 1, 7);\n    count *= encountered(trees, n, m, 2, 1);\n    printf(\"Answer: %zu\\n\", count);\n\n    for (size_t i = 0; i < n; i++)\n        free(trees[i]);\n    free(trees);\n    \n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <ctype.h>\n\nbool is_pass(bool* info) {\n    for (int i = 0; i < 7; i++)\n        if (!info[i]) return false;\n    return true;\n}\n\nchar *get_field(size_t *n, FILE *f) { \n    char *field = calloc(sizeof(char), 20);\n    size_t i = 0;\n    for (char cur = fgetc(f); cur != ' ' && cur != '\\n'; cur = fgetc(f)) {\n        field[i] = cur;\n        i++;\n    }\n    *n = i;\n    return field;\n}\n\nbool is_hair_color(char *field, size_t n) {\n    if (field[0] != '#') return false;\n    for (size_t i = 1; i < n; i++)\n        if ((field[i] < '0' || '9' < field[i])\n            && (field[i] < 'a' || 'f' < field[i]))\n            return false;\n    return true;\n}\n\nbool is_eye_color(char *field) {\n    return strcmp(field, \"amb\") == 0 || strcmp(field, \"blu\") == 0\n        || strcmp(field, \"brn\") == 0 || strcmp(field, \"gry\") == 0\n        || strcmp(field, \"grn\") == 0 || strcmp(field, \"hzl\") == 0\n        || strcmp(field, \"oth\") == 0;\n}\n\nbool is_pid(char *field, size_t n) {\n    if (n != 9) return false;\n    for (size_t i = 0; i < n; i++) {\n        if (!isdigit(field[i])) return false;\n    }\n    return true;\n}\n\nint main() {\n    char *filename = \"Passports.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t count = 0;\n\n    bool *valids = calloc(sizeof(bool), 7);\n    char *curs = calloc(sizeof(char), 3);\n\n    for (char cur = fgetc(f); cur != EOF; cur = fgetc(f)) {\n        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {\n            case 333: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int byr = strtol(field, &tmp, 10);\n                if (1920 <= byr && byr <= 2002)\n                    valids[0] = true;\n                free(field); break;\n            } case 340: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int iyr = strtol(field, &tmp, 10);\n                if (2010 <= iyr && iyr <= 2020)\n                    valids[1] = true;\n                free(field); break;\n            } case 336: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int eyr = strtol(field, &tmp, 10);\n                if (2020 <= eyr && eyr <= 2030)\n                    valids[2] = true;\n                free(field); break;\n            } case 323: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int hgt = strtol(field, &tmp, 10);\n                if (strcmp(tmp, \"cm\") == 0 && 150 <= hgt && hgt <= 193\n                    || strcmp(tmp, \"in\") == 0 && 59 <= hgt && hgt <= 76)\n                    valids[3] = true;\n                free(field); break;\n            } case 311: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_hair_color(field, n))\n                    valids[4] = true;\n                free(field); break;\n            } case 308: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_eye_color(field))\n                    valids[5] = true;\n                free(field); break;\n            } case 317: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_pid(field, n))\n                    valids[6] = true;\n                free(field); break;\n            } case 304: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                free(field); break;\n            }\n        }\n        \n        if (cur == '\\n') {\n            if (is_pass(valids)) count++;\n            free(valids);\n            valids = calloc(sizeof(bool), 7);\n        }\n        curs[0] = curs[1];\n        curs[1] = curs[2];\n        curs[2] = cur;\n    }\n\n    printf(\"Answer: %zu\\n\", count);\n\n    free(valids);\n    free(curs);\n    fclose(f);\n\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nsize_t find_empty(bool *seats) {\n    for (size_t i = 8; i < 126 * 8 + 7; i++)\n        if (seats[i - 1] && !seats[i] && seats[i + 1]) return i;\n    return 0;\n}\n\nint main() {\n    char *filename = \"Seats.txt\";\n    FILE *f = fopen(filename, \"r\");\n    bool *seats = calloc(sizeof(bool), 128 * 8);\n    char *seat = NULL; size_t n = 0;\n\n    while (getline(&seat, &n, f) != -1) {\n        size_t low = 0; size_t high = 127;\n        for (int i = 0; i < 7; i++) {\n            if (seat[i] == 'F') high -= (high - low + 1) \/ 2;\n            else low += (high - low + 1) \/ 2;\n        }\n        size_t row = low;\n        low = 0; high = 7;\n        for (int i = 7; i < 10; i++) {\n            if (seat[i] == 'L') high -= (high - low + 1) \/ 2;\n            else low += (high - low + 1) \/ 2;\n        }\n        size_t col = low;\n        size_t id = row * 8 + col;\n        seats[id] = true;\n    }\n    printf(\"Answer: %zu\\n\", find_empty(seats));\n    free(seat);\n    free(seats);\n    fclose(f);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nsize_t count_yes(size_t *yes, size_t num) {\n    size_t count = 0;\n    for (size_t i = 0; i < 26; i++)\n        if (yes[i] == num) count++;\n    return count;\n}\n\nint main() {\n    char *filename = \"Answers.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t *yes = calloc(sizeof(size_t), 26);\n    char *person = NULL; size_t n = 0;\n    size_t num = 0; size_t count = 0;\n\n    while (getline(&person, &n, f) != -1) {\n        if (strcmp(person, \"\\n\") == 0) {\n            count += count_yes(yes, num);\n            free(yes); yes = calloc(sizeof(size_t), 26);\n            num = 0;\n        } else {\n            num++;\n            for (size_t i = 0; i < strlen(person) - 1; i++)\n                yes[person[i] - 'a']++;\n        }\n    }\n    printf(\"Answer: %zu\\n\", count);\n    fclose(f);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <ctype.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL; size_t len = 0; char *thing = NULL;\n    getline(&line, &len, f);\n    \n    size_t max = strtol(line, &thing, 10);\n    size_t *primes = calloc(sizeof(size_t), max \/ 4);\n    size_t num = 0;\n    for (size_t test = 2; test < max; test++) {\n        bool isPrime = true;\n        for (size_t i = 0; i < num; i++) {\n            if (test % primes[i] == 0)\n                isPrime = false;\n        }\n        if (isPrime) {\n            primes[num] = test;\n            num++;\n        }\n    }\n    \n    size_t sum = 0;\n    for (size_t i = 0; i < num; i++)\n        sum += primes[i];\n    printf(\"Answer: %zu\\n\", sum);\n    free(primes);\n    fclose(f);\n    free(line);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n\nint main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL; size_t len = 0; char *tmp = NULL;\n    getline(&line, &len, f);\n    size_t p = strtol(line, &tmp, 10);\n    size_t size = ceil(sqrt(p));\n    bool *primes = calloc(sizeof(bool), size + 1); \n\n    for (size_t i = 2; i < size + 1; i++) {\n        if (!primes[i])\n            for (size_t j = 2 * i; j < size + 1; j += i)\n                primes[j] = true;\n    }\n    size_t maxp = 0;\n    for (size_t i = 2; i < size + 1; i++) {\n        if (!primes[i] && p % i == 0 && i > maxp)\n            maxp = i;\n    }\n    printf(\"Answer: %zu\\n\", maxp);\n    free(primes);\n    fclose(f); free(line);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n\nint num_digits(size_t i) {\n    if (i < 10) return 1;\n    return 1 + num_digits(i \/ 10);\n}\n\nint power(size_t x, size_t y) {\n    if (y == 0) return 1;\n    return x * pow(x, y - 1);\n}\n\nbool is_palin(size_t i, size_t num_digits) {\n    if (num_digits < 2) return true;\n    return i % 10 == i \/ power(10, num_digits - 1)\n        && is_palin((i % power(10, num_digits - 1)) \/ 10, num_digits - 2);\n}\n\nint main() {\n    size_t max_palin = 0;\n    for (size_t i = 100; i < 1000; i++)\n        for (size_t j = i; j < 1000; j++)\n            if (is_palin(i * j, num_digits(i * j)) && i * j > max_palin)\n                max_palin = i * j;\n    printf(\"Answer: %zu\\n\", max_palin);\n    return 0;\n}"}
{"target":"qtgeo1248","func":"#include <ctype.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n\n    size_t num_ints = 0;\n    for (char c = fgetc(f); c != EOF; c = fgetc(f)) {\n        if (isdigit(c))\n            num_ints++;\n    }\n    fclose(f);\n    size_t *digits = calloc(sizeof(size_t), num_ints);\n    f = fopen(filename, \"r\");\n    for (size_t i = 0; i < num_ints; i++) {\n        char c = fgetc(f);\n        if (!isdigit(c))\n            c = fgetc(f);\n        digits[i] = c - '0';\n    }\n    size_t max_prod = 0;\n    for (size_t i = 0; i < num_ints - 12; i++) {\n        size_t tmp_prod = digits[i] * digits[i + 1] * digits[i + 2] * digits[i + 3]\n                        * digits[i + 4] * digits[i + 5] * digits[i + 6] * digits[i + 7]\n                        * digits[i + 8] * digits[i + 9] * digits[i + 10]\n                        * digits[i + 11] * digits[i + 12];\n        if (tmp_prod > max_prod)\n            max_prod = tmp_prod;\n    }\n    printf(\"Answer: %zu\\n\", max_prod);\n    free(digits);\n    fclose(f);\n    return 0;\n}"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[2000];  \nunsigned char sta_addr[6];\nunsigned char des_addr[6];\nunsigned short protocol;\nunsigned char *payload;\nunsigned int frame_len;\nunsigned int payload_len;\nunsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame receiver process.\\n\");\n    printf(\"[INFO] My address  : \");\n    output_octal(my_addr,6);\n}\n\n \nint addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}\n\n \nint output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \nint receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n\n    \n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    \n    fread(&frame,sizeof(char),frame_len,file);\n    \n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    \n    \n    if(!addr_check(des_addr))   exit(1);\n\n    \n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n\n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}\n\nint main(){\n    welcome();\n    receive_frame();\n}\n\n\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[2000];  \nunsigned char sta_addr[6];\nunsigned char des_addr[6];\nunsigned short protocol;\nunsigned char *payload;\nunsigned int frame_len;\nunsigned int payload_len;\nunsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame receiver process.\\n\");\n    printf(\"[INFO] My address  : \");\n    output_octal(my_addr,6);\n}\n\n \nint addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}\n\n \nint output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \nint receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n\n    \n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    \n    fread(&frame,sizeof(char),frame_len,file);\n    \n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    \n    \n    if(!addr_check(des_addr))   exit(1);\n\n    \n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n\n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}\n\nint main(){\n    welcome();\n    receive_frame();\n}\n\n\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[1546];  \n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  \nunsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \nunsigned short protocol = 1; \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\n \nvoid output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n \nint frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    \n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    \n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    \n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}\n\n \nint send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}\n\nint main(){\n    unsigned int length;\n    \n    welcome();\n    \n\n\n\n\n    \n    \n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[1546];  \n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  \nunsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \nunsigned short protocol = 1; \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\n \nvoid output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n \nint frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    \n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    \n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    \n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}\n\n \nint send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}\n\nint main(){\n    unsigned int length;\n    \n    welcome();\n    \n\n\n\n\n    \n    \n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"sender.h\"\n\nunsigned char frame[1546]; \nunsigned char data[] = \"Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. \";\nunsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; \nunsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; \nunsigned short protocol = 1;\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\nint main(){\n    unsigned int length;\n\n    welcome();\n\n    \n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    \n\n\n\n\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"sender.h\"\n\nunsigned char frame[1546]; \nunsigned char data[] = \"Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. \";\nunsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; \nunsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; \nunsigned short protocol = 1;\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\nint main(){\n    unsigned int length;\n\n    welcome();\n\n    \n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    \n\n\n\n\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n\n#define BUFSIZE     1024*4\n\nstatic unsigned int crc_table[256];\nconst static char * program_name = \"crc32\";\n\nstatic void usage(void);\nstatic void init_crc_table(void);\nstatic unsigned int crc32(unsigned char * buffer, unsigned int size);\nstatic int calc_img_crc(const char * in_file, unsigned int * img_crc);\n\nstatic void usage(void)\n{\n    fprintf(stderr, \"Usage: %s input_file\\n\", program_name);\n}\n\n\nstatic void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    \n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}\n\n\n\nunsigned int crc32_table[256];\n \nvoid make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    \n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        \n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n            \n        }\n        crc32_table[i] = c;\n    }\n}\n \nunsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}\n\n\nstatic unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}\n\nunsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};\nunsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};\n\n\nint main(int argc, char **argv)\n{\n    \n    \n    \n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    printf(\"%d\",sizeof(data)); \n\n    return 0;\n}\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n\n#define BUFSIZE     1024*4\n\nstatic unsigned int crc_table[256];\nconst static char * program_name = \"crc32\";\n\nstatic void usage(void);\nstatic void init_crc_table(void);\nstatic unsigned int crc32(unsigned char * buffer, unsigned int size);\nstatic int calc_img_crc(const char * in_file, unsigned int * img_crc);\n\nstatic void usage(void)\n{\n    fprintf(stderr, \"Usage: %s input_file\\n\", program_name);\n}\n\n\nstatic void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    \n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}\n\n\n\nunsigned int crc32_table[256];\n \nvoid make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    \n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        \n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n            \n        }\n        crc32_table[i] = c;\n    }\n}\n \nunsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}\n\n\nstatic unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}\n\nunsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};\nunsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};\n\n\nint main(int argc, char **argv)\n{\n    \n    \n    \n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    printf(\"%d\",sizeof(data)); \n\n    return 0;\n}\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[2000];  \nunsigned char sta_addr[6];\nunsigned char des_addr[6];\nunsigned short protocol;\nunsigned char *payload;\nunsigned int frame_len;\nunsigned int payload_len;\nunsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame receiver process.\\n\");\n    printf(\"[INFO] My address  : \");\n    output_octal(my_addr,6);\n}\n\n \nint addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}\n\n \nint output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \nint receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n\n    \n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    \n    fread(&frame,sizeof(char),frame_len,file);\n    \n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    \n    \n    if(!addr_check(des_addr))   exit(1);\n\n    \n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n\n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}\n\nint main(){\n    welcome();\n    receive_frame();\n}\n\n\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[2000];  \nunsigned char sta_addr[6];\nunsigned char des_addr[6];\nunsigned short protocol;\nunsigned char *payload;\nunsigned int frame_len;\nunsigned int payload_len;\nunsigned char my_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame receiver process.\\n\");\n    printf(\"[INFO] My address  : \");\n    output_octal(my_addr,6);\n}\n\n \nint addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}\n\n \nint output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \nint receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n\n    \n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    \n    fread(&frame,sizeof(char),frame_len,file);\n    \n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    \n    \n    if(!addr_check(des_addr))   exit(1);\n\n    \n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n\n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}\n\nint main(){\n    welcome();\n    receive_frame();\n}\n\n\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[1546];  \n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  \nunsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \nunsigned short protocol = 1; \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\n \nvoid output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n \nint frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    \n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    \n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    \n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}\n\n \nint send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}\n\nint main(){\n    unsigned int length;\n    \n    welcome();\n    \n\n\n\n\n    \n    \n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n# include \"crc32.h\"\n\nunsigned char frame[1546];  \n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[6] = {0x11,0x33,0x55,0x44,0x22,0x55};  \nunsigned char des_addr[6] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};  \nunsigned short protocol = 1; \n\n\nvoid welcome()\n{\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\n \nvoid output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\n \nint frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    \n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    \n    \n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    \n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}\n\n \nint send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}\n\nint main(){\n    unsigned int length;\n    \n    welcome();\n    \n\n\n\n\n    \n    \n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"UDP_sender.h\"\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: sender process.\\n\");\n    printf(\"\\n\");\n}\n\nint main(){\n    welcome();\n    printf(\"Please input your message:\");\n    \n    int strSize = 20; \n    int payload_len = 0; \n    char input  = NULL; \n    unsigned char *payload = (unsigned char*)malloc(sizeof(char)*20);\n    while((input=getc(stdin))!='\\n') {\n        payload[payload_len++] = input;\n        if(payload_len%20==0) { \n            strSize+=20;    \n            payload =(unsigned char*)realloc(payload,strSize);\n        }\n    }\n    payload[payload_len] = '\\0';\n    \n    udp_sender(payload,payload_len);\n    printf(\"[INFO] message send successfully!\\n\");\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"UDP_sender.h\"\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: sender process.\\n\");\n    printf(\"\\n\");\n}\n\nint main(){\n    welcome();\n    printf(\"Please input your message:\");\n    \n    int strSize = 20; \n    int payload_len = 0; \n    char input  = NULL; \n    unsigned char *payload = (unsigned char*)malloc(sizeof(char)*20);\n    while((input=getc(stdin))!='\\n') {\n        payload[payload_len++] = input;\n        if(payload_len%20==0) { \n            strSize+=20;    \n            payload =(unsigned char*)realloc(payload,strSize);\n        }\n    }\n    payload[payload_len] = '\\0';\n    \n    udp_sender(payload,payload_len);\n    printf(\"[INFO] message send successfully!\\n\");\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"sender.h\"\n\nunsigned char frame[1546]; \nunsigned char data[] = \"Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. \";\nunsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; \nunsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; \nunsigned short protocol = 1;\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\nint main(){\n    unsigned int length;\n\n    welcome();\n\n    \n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    \n\n\n\n\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n#include \"sender.h\"\n\nunsigned char frame[1546]; \nunsigned char data[] = \"Hello! This is a frame payload data. It's a computer project for quxiangjun 20186471. \"; \nunsigned char sta_addr[6] = {0x11, 0x33, 0x55, 0x44, 0x22, 0x55}; \nunsigned char des_addr[6] = {0x42, 0x23, 0x52, 0xb5, 0xa6, 0xc3}; \nunsigned short protocol = 1;\n\n\nvoid welcome(){\n    printf(\"[INFO] Usage: frame sender process.\\n\");\n}\n\nint main(){\n    unsigned int length;\n\n    welcome();\n\n\n\n\n    \n     \n    length = frame_construction(frame,sta_addr,des_addr,protocol,data,sizeof(data));\n    frame[length-10] = ~frame[length-10];    \n    send_frame(frame,length);\n\n    return 0;\n}\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys\/stat.h>\n\n#define BUFSIZE     1024*4\n\nstatic unsigned int crc_table[256];\nconst static char * program_name = \"crc32\";\n\nstatic void usage(void);\nstatic void init_crc_table(void);\nstatic unsigned int crc32(unsigned char * buffer, unsigned int size);\nstatic int calc_img_crc(const char * in_file, unsigned int * img_crc);\n\nstatic void usage(void)\n{\n    fprintf(stderr, \"Usage: %s input_file\\n\", program_name);\n}\n\n\nstatic void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    \n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}\n\n\n\nunsigned int crc32_table[256];\n \nvoid make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    \n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        \n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n            \n        }\n        crc32_table[i] = c;\n    }\n}\n \nunsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}\n\n\nstatic unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}\n\nunsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunsigned char data[] = {0x64,0x62,0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,\n                        0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,\n                        0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,\n                        0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,\n                        0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,\n                        0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,\n                        0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,\n                        0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,\n                        0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,\n                        0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,\n                        0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,\n                        0x12,0x15,0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,\n                        0x52,0x22,0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,\n                        0xa2,0xa2,0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,\n                        0x96,0x31,0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,\n                        0x52,0xb5,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,\n                        0xd3,0xd3,0xd1,0x62,0x12,0x15,0x45,0x55,0x11,0x33,\n                        0x55,0x44,0x22,0x55,0x52,0x22,0x55,0x66,0x33,0x55,\n                        0x88,0x66,0x45,0xaa,0xa2,0xa2,0xb2,0x13,0x56,0x85,\n                        0x25,0x36,0x41,0x85,0x96,0x31,0x65,0x42,0x62,0x32,\n                        0x42,0x62,0x42,0x23,0x52,0xb5,0xa6,0xc3,0xd2,0xd2,\n                        0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,0xd1,0x62,0x12,0x15,\n                        0x45,0x55,0x11,0x33,0x55,0x44,0x22,0x55,0x52,0x22,\n                        0x55,0x66,0x33,0x55,0x88,0x66,0x45,0xaa,0xa2,0xa2,\n                        0xb2,0x13,0x56,0x85,0x25,0x36,0x41,0x85,0x96,0x31,\n                        0x65,0x42,0x62,0x32,0x42,0x62,0x42,0x23,0x52,0xb5,\n                        0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3,0xd3,\n                        0xd1,0xa6,0xc3,0xd2,0xd2,0xd5,0xd5,0xd5,0xd3,0xd3};\nunsigned char sta_addr[] = {0x11,0x33,0x55,0x44,0x22,0x55};\nunsigned char des_addr[] = {0x42,0x23,0x52,0xb5,0xa6,0xc3};\n\n\nint main(int argc, char **argv)\n{\n    \n    \n    \n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    printf(\"%d\",sizeof(data)); \n\n    return 0;\n}\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned short Checksum(unsigned char* buffer, unsigned short size){\n    unsigned int sum = 0;\n    unsigned short cksum;\n    unsigned char lower,higher;\n    unsigned short temp;\n    while(size > 1){\n        lower = buffer[size-1];\n        higher = buffer[size - 2];\n        temp = higher;\n        temp = (temp << 8) + lower;\n        printf(\"%04x\\n\",temp);\n        sum += temp;\n        size -= 2;\n    }\n    if(size == 1){  \n        lower = buffer[size-1];\n        higher = 0x00;\n        temp = higher;\n        temp = (temp << 8) + lower;\n        sum += temp;\n    }\n    cksum = (sum >> 16) + (sum & 0xffff);\n    cksum = ~cksum;\n    printf(\"%04x\\n\",cksum);\n    return cksum;\n}\n\n  int main(){\n      unsigned char data[] = {0x47,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x4d,0x5f,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x00};\n      unsigned short ck = Checksum(data,sizeof(data));\n      printf(\"%04x\",ck);\n  }\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"crc16.h\"\n#include \"output_octal.h\"\n\nint fragmention(){\n    \n}\n\n\nunsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,\n                            unsigned char Differentialted_Services,unsigned short Identification,\n                            unsigned short DF, unsigned short MF,\n                            unsigned short Fragment_offset, unsigned char TTL, \n                            unsigned char Protocol,\n                            unsigned char *Source_address, unsigned char *Destination_address,\n                            unsigned char *Option,unsigned int Option_len,\n                            unsigned *payload,unsigned short payload_len){\n    \n    if (payload_len > 65515){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    \n    \n    unsigned char IHL = 5 + Option_len; \n    printf(\"IHL%d\\n\",IHL);\n\n    \n    unsigned char temp = 0x00;\n    Version = Version << 4;  \n    temp = temp | IHL; \n    temp = temp | Version; \n    memcpy(&datagram[0],&temp,1);\n\n    memcpy(&datagram[1],&Differentialted_Services,1);\n\n    \n    unsigned short Total_length = payload_len + IHL*4; \n    memcpy(&datagram[2],&Total_length,2);\n    memcpy(&datagram[4],&Identification,2);\n\n    \n    unsigned short temp2;\n    short df = DF;\n    df = df << 14;\n    df = df & 0x4000;  \n    short mf = MF;\n    mf = mf << 13;\n    mf = mf & 0x2000; \n    Fragment_offset = Fragment_offset & 0x1FFF; \n    temp2 = df | mf | Fragment_offset;\n    memcpy(&datagram[6],&temp2,2);\n\n    memcpy(&datagram[8],&TTL,1);\n    memcpy(&datagram[9],&Protocol,1);\n    memcpy(&datagram[12],Source_address,4);\n    memcpy(&datagram[16],Destination_address,4);\n    memcpy(&datagram[20],Option,Option_len*4);\n    \n    \n    unsigned char Header[IHL * 4 - 2]; \n    memcpy(&Header[0],&datagram[0],10);\n    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);\n    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);\n    memcpy(&datagram[10],&Header_checksum,2); \n    \n    unsigned char crc16_result[2];\n    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));\n\n    memcpy(&datagram[20 + Option_len*4],payload,payload_len);\n\n     \n    printf(\"******Send datagrame information******\\n\");\n    printf(\"Source address: \");\n    output_octal(Source_address,4);\n    printf(\"Destinamtion address  : \");\n    output_octal(Destination_address,4);\n    printf(\"payload      : %s\\n\",payload);\n    printf(\"CRC16        : \");\n    output_octal(crc16_result, 2);    \n    printf(\"payload length  : %d\\n\", payload_len);\n    printf(\"Header length   : %d(row*4bytes)\\n\", IHL);\n    printf(\"datagram length : %d\\n\", Total_length);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] datagram send success!\\n\");\n    return Total_length;\n}\n\nint send_datagram(){\n\n}\n\n"}
{"target":"Qu-Xiangjun","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"crc16.h\"\n#include \"output_octal.h\"\n\nint fragmention(){\n    \n}\n\n\nunsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,\n                            unsigned char Differentialted_Services,unsigned short Identification,\n                            unsigned short DF, unsigned short MF,\n                            unsigned short Fragment_offset, unsigned char TTL, \n                            unsigned char Protocol,\n                            unsigned char *Source_address, unsigned char *Destination_address,\n                            unsigned char *Option,unsigned int Option_len,\n                            unsigned *payload,unsigned short payload_len){\n    \n    if (payload_len > 65515){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    \n    \n    unsigned char IHL = 5 + Option_len; \n    printf(\"IHL%d\\n\",IHL);\n\n    \n    unsigned char temp = 0x00;\n    Version = Version << 4;  \n    temp = temp | IHL; \n    temp = temp | Version; \n    memcpy(&datagram[0],&temp,1);\n\n    memcpy(&datagram[1],&Differentialted_Services,1);\n\n    \n    unsigned short Total_length = payload_len + IHL*4; \n    memcpy(&datagram[2],&Total_length,2);\n    memcpy(&datagram[4],&Identification,2);\n\n    \n    unsigned short temp2;\n    short df = DF;\n    df = df << 14;\n    df = df & 0x4000;  \n    short mf = MF;\n    mf = mf << 13;\n    mf = mf & 0x2000; \n    Fragment_offset = Fragment_offset & 0x1FFF; \n    temp2 = df | mf | Fragment_offset;\n    memcpy(&datagram[6],&temp2,2);\n\n    memcpy(&datagram[8],&TTL,1);\n    memcpy(&datagram[9],&Protocol,1);\n    memcpy(&datagram[12],Source_address,4);\n    memcpy(&datagram[16],Destination_address,4);\n    memcpy(&datagram[20],Option,Option_len*4);\n    \n    \n    unsigned char Header[IHL * 4 - 2]; \n    memcpy(&Header[0],&datagram[0],10);\n    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);\n    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);\n    memcpy(&datagram[10],&Header_checksum,2); \n    \n    unsigned char crc16_result[2];\n    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));\n\n    memcpy(&datagram[20 + Option_len*4],payload,payload_len);\n\n     \n    printf(\"******Send datagrame information******\\n\");\n    printf(\"Source address: \");\n    output_octal(Source_address,4);\n    printf(\"Destinamtion address  : \");\n    output_octal(Destination_address,4);\n    printf(\"payload      : %s\\n\",payload);\n    printf(\"CRC16        : \");\n    output_octal(crc16_result, 2);    \n    printf(\"payload length  : %d\\n\", payload_len);\n    printf(\"Header length   : %d(row*4bytes)\\n\", IHL);\n    printf(\"datagram length : %d\\n\", Total_length);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] datagram send success!\\n\");\n    return Total_length;\n}\n\nint send_datagram(){\n\n}\n\n"}
{"target":"RafaelFelisbino-hub","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <conio.h>\n\n\nint main() \n{\n\n    int i;\n    int num = 0;\n    int inter1=0, inter2=0, inter3=0, inter4=0;\n    \n\n    system(\"color 17\");\n\n    for (i = 1; i <= 10; i++) {\n\n        printf(\"\\n%d - Digite os numeros:  \", i);\n        scanf_s(\"%i\", &num);\n\n        if (num < 0) \n        {\n            printf(\"Numero invalido\\n\");\n            break;\n        }\n        \n        if ((num > 0) && (num <= 25))\n        {\n            \n            inter1++;\n        }\n\n        if ((num > 25) && (num <= 50))\n        {\n\n            inter2++;\n        }\n\n        if ((num > 50) && (num <= 75))\n        {\n\n            inter3++;\n        }\n\n        if ((num > 75) && (num <= 100))\n        {\n\n            inter4++;\n        }\n\n    }\n\n    printf(\"Os numeros no 1 intervalo sao:  %i\\n\", inter1);\n    printf(\"Os numeros no 2 intervalo sao:  %i\\n\", inter2);\n    printf(\"Os numeros no 3 intervalo sao:  %i\\n\", inter3);\n    printf(\"Os numeros no 4 intervalo sao:  %i\\n\", inter4);\n    \n\n    system(\"pause\");\n\n\n\n}"}
{"target":"RafaelFelisbino-hub","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <conio.h>\n#include <locale.h>\n\n\nint main()\n{\n    int N1, N2, impar = 0, n3,i,r;\n\n    setlocale(LC_ALL, \"Portuguese\");\n    \n    system(\"color 17\");\n\n    printf(\"Digite o valor de N1:  \");\n    scanf_s(\"%i\", &N1);\n\n    printf(\"\\nDigite o valor de N2:  \");\n    scanf_s(\"%i\", &N2);\n\n    for (i =N1++ ; i < N2; i++)\n    {\n        if (i % 2 == 1) \n        {\n            impar++;\n        }\n        \n    }\n    printf(\"\\nExistem %i numeros \u00edmpares entre N1 e N2 mano, \u00c9OBIXO\\n\", impar);\n\n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <conio.h>\n#include <locale.h>\n#include <ctype.h>\n\nint main() \n{\n    float altura = 0,maioralt = 0,menoralt = 999,mediamulher = 0,mediaalt = 0,maiorhomem = 0,menorhomem = 999,quantF = 0;\n    char sexo;\n    int i;\n\n    system(\"color 17\");\n\n    for (i = 0; i < 4; i++) \n    {\n        \n        printf(\"Digite sua altura separado por ponto:Ex: 1.00  \");\n        scanf_s(\"%f\", &altura);\n        (void)getchar();\n        \n\n        printf(\"Digite seu sexo: M ou F:  \");\n        scanf_s(\"%c\", &sexo,1);\n        sexo = toupper(sexo);\n        \n        if (altura < menoralt) \n        {\n            menoralt = altura;\n        }\n        if (altura > maioralt) \n        {\n            maioralt = altura;\n        }\n\n        if (sexo == 'F') \n        {\n            quantF++;\n            mediamulher += altura;\n        }\n\n        if (sexo == 'M' && altura < menorhomem) \n        {\n            menorhomem = altura;\n        }\n        if (sexo == 'M' && altura > maiorhomem)\n        {\n            maiorhomem = altura;\n        }\n\n        mediaalt += altura;\n    }\n    \n    if (mediamulher != 0)\n    {\n        mediamulher = mediamulher \/ quantF;\n    }\n    \n    mediaalt = mediaalt \/ i;\n    \n    printf(\"\\n\\n\");\n    printf(\"A maior altura da turma e:  %.2f\\n\", maioralt);\n    printf(\"A maior altura da turma e:  %.2f\\n\", menoralt);\n    printf(\"A media de altura das mulheres e:  %.2f\\n\", mediamulher);\n    printf(\"A maior altura dos homens e:  %.2f\\n\", maiorhomem);\n    printf(\"A menor altura dos homens e:  %.2f\\n\", menorhomem);\n    printf(\"A media de altura da turma e:  %.2f\\n\", mediaalt);\n\n\n\n\n}"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat cubo(float N);\n\nint main() \n{\n    float volumeEsfera, equacao, PI, y, N;\n    \n    printf(\"Digite o numero para o cubo:  \");\n    scanf_s(\"%f\", &N);\n    \n    printf(\"Digite o valor de PI:  \");\n    scanf_s(\"%f\", &PI);\n\n    volumeEsfera = 4 * PI * cubo(N) \/ 3;\n\n    printf(\"O volume da esfera e:  %.2f\\n\\n\", volumeEsfera);\n\n    N = 0;\n\n    printf(\"Digite o valor de X para a equacao:  \");\n    scanf_s(\"%f\", &N);\n\n    printf(\"Digite o valor de Y para a equacao:  \");\n    scanf_s(\"%f\", &y);\n\n    equacao = cubo(N) + cubo(y) + 2;\n\n    printf(\"O resultado da equacao e: %.2f\\n\", equacao);\n}\n\nfloat cubo(float N)\n{\n    float resultado;\n    resultado = pow(N,3);\n    return(resultado);\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nfloat cubo(float N);\nint diasVividos(int idade);\n\nfloat N = 0;\nint idade = 0, dia = 0, mes = 0, ano = 0;\n\nint main() \n{\n    float res1;\n    int res2;\n    \n    res1 = cubo(N);\n    printf(\"O cubo e:  %.2f\\n\\n\",res1);\n    \n    res2 = diasVividos(idade);\n    printf(\"A quantidade de dias vividos e:  %i\", res2);\n}\n\nfloat cubo(float N)\n{\n    float resultado;\n    \n    printf(\"Digite o numero para saber seu cubo:  \");\n    scanf_s(\"%f\", &N);\n    \n    resultado = N * N * N;\n    return(resultado);\n}\n\nint diasVividos(int idade)\n{\n    int anos, meses = 0, ano1 = 0;\n\n    printf(\"Digite sua idade em anos:  \");\n    scanf_s(\"%i\", &idade);\n\n    printf(\"Digite sua data de nascimento separado por barra 00\/00\/0000:  \");\n    scanf_s(\"%i\/%i\/%i\", &dia, &mes, &ano);\n\n    ano1 = (2020 - ano) * 365;\n    meses = (11 - mes) * 30;\n\n    anos = dia + meses + ano1;\n    return(anos);\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid metade();\n\nfloat A[30], B[30];\n\nint main() \n{\n    int i;\n\n    for (i = 0; i < 30; i++) \n    {\n        printf(\"Digite os valores de A:  \");\n        scanf_s(\"%f\", &A[i]);\n\n        metade();\n    }\n    \n    for (i = 0; i < 30; i++)\n        printf(\"Os valores de A pela metade sao:  %.2f\\n\", B[i]);\n}\n\nvoid metade() \n{\n    int i;\n    \n    for (i = 0; i < 30; i++) \n    {\n        B[i] = A[i] \/ 2;\n    }\n}\n\n"}
{"target":"RafaelFelisbino-hub","func":"#include <stdio.h>\n#include <Windows.h>\n#include <stdlib.h>\n\nvoid gotoxy(int x, int y);\nint i;\nint main()\n{\n    gotoxy(0,0); printf(\"%c\",218);\n    for(i = 1; i <= 69; i++)\n    {\n        gotoxy(i,0); printf(\"%c\",196);\n    }\n    gotoxy(70,0); printf(\"%c\",191);\n    for(i = 1; i <= 15; i++)\n    {\n        gotoxy(0,i); printf(\"%c\",179);\n    }\n     for(i = 1; i <= 15; i++)\n    {\n        gotoxy(70,i); printf(\"%c\",179);\n    }\n    gotoxy(0,16); printf(\"%c\",192);\n    gotoxy(70,16); printf(\"%c\",217);\n    for(i = 1; i <= 69; i++)\n    {\n        gotoxy(i,16); printf(\"%c\",196);\n    }\n    gotoxy(19,1); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,1); printf(\"%c\",196);\n    }\n    gotoxy(51,1); printf(\"%c\",191);\n    gotoxy(19,2); printf(\"%c\",179);\n    gotoxy(51,2); printf(\"%c\",179);\n    gotoxy(19,3); printf(\"%c\",192);\n    gotoxy(51,3); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,3); printf(\"%c\",196);\n    }\n    gotoxy(19,5); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,5); printf(\"%c\",196);\n    }\n    gotoxy(51,5); printf(\"%c\",191);\n    gotoxy(19,6); printf(\"%c\",179);\n    gotoxy(51,6); printf(\"%c\",179);\n    gotoxy(19,7); printf(\"%c\",192);\n    gotoxy(51,7); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,7); printf(\"%c\",196);\n    }\n    gotoxy(19,9); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,9); printf(\"%c\",196);\n    }\n    gotoxy(51,9); printf(\"%c\",191);\n    gotoxy(19,10); printf(\"%c\",179);\n    gotoxy(51,10); printf(\"%c\",179);\n    gotoxy(19,11); printf(\"%c\",192);\n    gotoxy(51,11); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,11); printf(\"%c\",196);\n    }\n    \n    gotoxy(19,13); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,13); printf(\"%c\",196);\n    }\n    gotoxy(51,13); printf(\"%c\",191);\n    gotoxy(19,14); printf(\"%c\",179);\n    gotoxy(51,14); printf(\"%c\",179);\n    gotoxy(19,15); printf(\"%c\",192);\n    gotoxy(51,15); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,15); printf(\"%c\",196);\n    }\n\n    \n    gotoxy(6,3); printf(\"%c\",218);\n    gotoxy(7,3); printf(\"%c\",196);\n    gotoxy(8,3); printf(\"%c\",191);\n    for (i = 4; i <= 13; i++)\n    {\n        gotoxy(6,i); printf(\"%c\",179);\n    }\n     for (i = 4; i <= 13; i++)\n    {\n        gotoxy(8,i); printf(\"%c\",179);\n    }\n    gotoxy(6,14); printf(\"%c\",192);\n    gotoxy(7,14); printf(\"%c\",196);\n    gotoxy(8,14); printf(\"%c\",217);\n    gotoxy(7,4); printf(\"T\");\n    gotoxy(7,5); printf(\"A\");\n    gotoxy(7,6); printf(\"X\");\n    gotoxy(7,7); printf(\"I\");\n    gotoxy(7,9); printf(\"A\");\n    gotoxy(7,10); printf(\"E\");\n    gotoxy(7,11); printf(\"R\");\n    gotoxy(7,12); printf(\"E\");\n    gotoxy(7,13); printf(\"O\");\n\n\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    system(\"pause\");\n}\n\nvoid gotoxy(int x, int y)\n{\n    COORD coord;\n    coord.X = x;\n    coord.Y = y;\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float matriz[3][3] = { {10,20,30}, {40,50,60}, {70,80,90} }, media, acimaMedia = 0, somaMedia = 0, repeticao = 0;\n    int i, j;\n    \n    \n    for (i = 0; i < 1; i++)\n        for (j = 0; j < 1; j++)\n            printf(\"Os elementos da diagonal sao :  %.0f, %.0f, %.0f\\n\", matriz[0][0], matriz[1][1], matriz[2][2]);\n        \n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) \n        {\n            somaMedia += matriz[i][j];\n            repeticao++;\n        }\n    \n    media = somaMedia \/ repeticao;\n    \n    printf(\"\\nA media dos elementos e:  %.2f\", media);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) \n        {\n            if (matriz[i][j] > media)\n                acimaMedia++;\n        }\n    \n    printf(\"\\nExistem %.0f valores acima da media\\n\",acimaMedia);\n    \n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() \n{\n    int vetorA[5], vetorB[5], matrizC[2][5], i , j;\n\n    for (i = 0; i < 5; i++)\n    {\n        printf(\"Informe os valores do vetor A:  \");\n        scanf_s(\"%i\", &vetorA[i]);\n    }\n        \n    for (i = 0; i < 5; i++) \n    {\n        printf(\"Informe os valores do vetor B:  \");\n        scanf_s(\"%i\", &vetorB[i]);\n    }\n    \n    for (j = 0; j < 5; j++)\n    {\n        matrizC[0][j] = vetorA[j];\n        matrizC[1][j] = vetorB[j];\n    }\n    \n    for (i = 0; i < 2; i++)\n        for (j = 0; j < 5; j++)\n            printf(\"A matriz com os vetores A e B e: %d linha,  %d coluna  %i\\n\", i, j, matrizC[i][j]);\n        \n        \n    \n\n    system(\"pause\");\n}"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() \n{\n    char nomesProdutos[5][100], nomeCaro[100], loja[4][20] = {\"Adidas\",\"Nike\",\"Cervejaria\",\"Cachoeiras\"};\n    float lojaProduto[4][5], matrizImpostos[4][5], maisCaro = 0;\n    int i, j;\n\n    for (i = 0; i < 5; i++)\n    {\n        printf(\"Digite os nomes dos produtos [%d]:  \", i);\n        scanf_s(\"%[^\\n]s\", &nomesProdutos[i], 100);\n        getchar();\n    }\n    \n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++) \n        {\n            printf(\"Digite o preco dos produtos [%s] loja [%s] produto:  \", loja[i], nomesProdutos[j]);\n            scanf_s(\"%f\", &lojaProduto[i][j]);\n        }\n\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++)\n        {\n            if (lojaProduto[i][j] <= 50) \n                matrizImpostos[i][j] = lojaProduto[i][j] * 5 \/ 100 + lojaProduto[i][j];\n            if(lojaProduto[i][j] > 50 && lojaProduto[i][j] <= 100)\n                matrizImpostos[i][j] = lojaProduto[i][j] * 10 \/ 100 + lojaProduto[i][j];\n            if (lojaProduto[i][j] > 100)\n                matrizImpostos[i][j] = lojaProduto[i][j] * 20 \/ 100 + lojaProduto[i][j];\n        }\n\n    for (i = 3; i < 4; i++)\n        for (j = 0; j < 5; j++) \n        {\n            if (matrizImpostos[i][j] > maisCaro) \n            {\n                maisCaro = matrizImpostos[i][j];\n                nomeCaro[99] = strcpy_s(nomeCaro, 99, nomesProdutos[i]);\n            }\n        }\n\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++)\n        {\n            printf(\"A matriz com os impostos [%d][%d]:  %.2f\\n\", i, j, matrizImpostos[i][j]);\n        }\n\n    printf(\"O produto mais caro da 3 linha e %s com o valor de %.0f\\n\", nomeCaro, maisCaro);\n\n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() \n{\n    float matriz[5][4], somaMes[100], somaSemana = 0, totalVendas = 0;\n    int i, j;\n    \n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 4; j++)\n        {\n            printf(\"Digite as vendas da %d loja e %d semana:  \", i + 1, j+1);\n            scanf_s(\"%f\", &matriz[i][j]);\n        }\n    for (i = 0; i < 5; i++) \n    {\n        somaMes[i] = 0;\n        for (j = 0; j < 4; j++)\n        {\n            somaMes[i] += matriz[i][j];\n        }\n        somaSemana += somaMes[i];\n        totalVendas += somaSemana;\n    }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 1; j++)\n            printf(\"O total de vendas do mes do %d vendedor e %.2f:  \\n\", i+1, somaMes[i]);\n            \n    printf(\"O total de vendas de cada semana de todos os vendedores e %.2f:  \\n\", somaSemana);\n    printf(\"O total de vendas do mes e %.2f:  \\n\", totalVendas);\n\n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() \n{\n    int matrizA[5][3], matrizB[5][3], matrizC[5][3], i, j;\n\n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            printf(\"Digite os valores da primeira matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizA[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++)\n        {\n            printf(\"Digite os valores da segunda matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizB[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            matrizC[i][j] = matrizA[i][j] + matrizB[i][j];\n\n            printf(\"A soma dos elementos e:  %i\\n\", matrizC[i][j]);\n        }\n    system(\"pause\");\n}"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>  \n\n\nint main() \n{\n    int temperaturasOutubro[31], i,somaTemperatura = 0, diaInferior = 0;\n    float media;\n\n    for (i = 0; i < 31; i++) \n    {\n        printf(\"Digite as temperaturas:  \");\n        scanf_s(\"%i\", &temperaturasOutubro[i]);\n        somaTemperatura += temperaturasOutubro[i];\n    }\n\n    media = somaTemperatura \/ i;\n    printf(\"A temperatura media e:  %.2f\\n\", media);\n    \n    for (i = 0; i < 31; i++)\n    {\n        if (temperaturasOutubro[i] < media)\n        {\n            diaInferior++;\n        }\n    }\n    for (i = 0; i < 31; i++)\n    {\n        if (temperaturasOutubro[i] > media)\n        {\n            printf(\"Temperatura maior que a media no dia %i = %i Graus Celsius\\n\\n\",i, temperaturasOutubro[i]);\n        }\n    }\n    printf(\"Quantidade de dias com a temperatura inferior a media:  %i\\n\", diaInferior);\n    \n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main(void)\n{\n    int n, i = 0, primo = 0;\n\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n\n    printf(\"Digite o valor de N:  \");\n    scanf_s(\"%i\", &n);\n\n    while (i <= n)\n    {\n        i++;\n        if (n % i == 0)\n        {\n            primo ++;\n        }                       \n    }\n\n    if (primo == 2)\n    {\n        printf(\"%i \u00e9 um n\u00famero primo\\n\", n);\n    }\n    else\n    {\n        printf(\"%i n\u00e3o \u00e9 um n\u00famero primo\\n\\n\", n);\n    }\n\n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\nint main()\n{\n    int escolha;\n    float saque, deposito, saldo = 0;\n    \n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n\n    printf(\"Digite o que quer fazer: (1)Consulta saldo, (2)saque, (3)dep\u00f3sito, (4)sair:  \");\n    scanf_s(\"%i\", &escolha);\n\n    while (escolha != 4)\n    {\n        \n        if (escolha == 1)\n        {\n\n            printf(\"\\nSeu saldo \u00e9:  %.2f\", saldo);\n\n        }\n    \n        if (escolha == 2)\n        {\n            printf(\"\\nDigite o valor do saque:  \");\n            scanf_s(\"%f\", &saque);\n            if ((saldo - saque) <= 0)\n            {\n                printf(\"Voc\u00ea n\u00e3o possui saldo\");\n            }\n            else\n            {\n                saldo = saldo - saque;\n                printf(\"\\nSeu saldo \u00e9:  %.2f\", saldo);\n            }\n            \n        }\n        \n        if (escolha == 3)\n        {\n            printf(\"\\nDigite o valor a ser depositado:  \");\n            scanf_s(\"%f\", &deposito);\n\n            saldo = saldo + deposito;\n            printf(\"Seu saldo \u00e9 %.2f reais\", saldo);\n        }\n        printf(\"\\n===============================================================================================\");\n        printf(\"\\n\\nDigite o que quer fazer: (1)Consulta saldo, (2)saque, (3)dep\u00f3sito, (4)sair:  \");\n        scanf_s(\"%i\", &escolha);\n    } \n    system(\"pause\");\n}\n"}
{"target":"RafaelFelisbino-hub","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() \n{\n    int  numeroDivisivel = 0, inicioIntervalo = 0, fimIntervalo = 0, qtdDivisoesExatas = 0,soma = 0;\n\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n\n    printf(\"Digite o n\u00famero que queira dividir:  \");\n    scanf_s(\"%i\", &numeroDivisivel);\n\n    printf(\"Digite o primeiro intervalo:  \");\n    scanf_s(\"%i\", &inicioIntervalo);\n\n    printf(\"Digite o segundo intervalo:  \");\n    scanf_s(\"%i\", &fimIntervalo);\n\n    while (inicioIntervalo <= fimIntervalo)\n    {\n        if (inicioIntervalo % numeroDivisivel == 0)\n        {\n            qtdDivisoesExatas++;\n            soma += inicioIntervalo;\n        }\n        inicioIntervalo++;\n    }\n\n    printf(\"\\n\\nO n\u00famero pode ser dividido por %i n\u00fameros inteiros\\n\\n\", qtdDivisoesExatas);\n    printf(\"A soma dos n\u00fameros inteiros divididos por %i \u00e9:  %i\\n\\n\",numeroDivisivel, soma);\n\n    system(\"pause\");\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n#include <stdlib.h> \n#include <unistd.h> \n\nvoid mostrar(int X_1, int X_2, int contador);\n\nint main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    do{\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }while(X_1 != 41);\n    return 0;\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n#include <stdlib.h> \n#include <unistd.h> \n\nvoid mostrar(int X_1, int X_2, int contador);\n\nint main()\n{\n    system(\"cls\"); \n    int contador = 0;\n    int X_1 = 1;\n    int X_2 = 80;\n    for(contador =1; X_1 != 41; ++contador){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n         --X_2;\n        contador = 1;\n         }\n    }\n        return 0;\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n#include <stdlib.h> \n#include <unistd.h> \n\nvoid mostrar(int X_1, int X_2, int contador);\n\nint main()\n{\n    system(\"cls\"); \n    mostrar(1,80,1);\n    return 0;\n}\n\nvoid mostrar(int X_1, int X_2, int contador)\n{\n    if(X_1 != 41){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n            mostrar(X_1,X_2, ++contador);\n        }else{\n            sleep(0.4);\n            system(\"cls\");\n            mostrar(++X_1, --X_2, 1);\n        }\n    }   \n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n#include <stdlib.h> \n#include <unistd.h> \n\nvoid mostrar(int X_1, int X_2, int contador);\n\nint main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    while(X_1 != 41){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }\n    return 0;\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas(int contador, int pibote);\nvoid Filas(int contador);\n\nint main()\n{\n    Filas(1);\n    return 0;\n}\n\nvoid Columnas(int contador, int pibote)\n{\n    if(contador < 80){\n        if(contador > (80 - pibote))\n            printf(\"A\");\n        else\n            printf(\" \");\n        Columnas(++contador,pibote);\n    }\n}\n\nvoid Filas(int contador)\n{\n    if(contador < 25){\n        Columnas(1, contador);\n        printf(\"\\n\");\n        Filas(++contador);\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int contador, int pibote, char letra_c);\nvoid Filas(int contador);\n\nint main()\n{\n    Filas(0);\n    return 0;\n}\n\nvoid Columna(int contador, int pibote, char letra_A){\n    if(contador <= 13){\n        if(contador >= (1 + pibote) && contador <= (13 - pibote))\n            printf(\"%c\", letra_A);\n        else\n            printf(\" \");\n        Columna(++contador,pibote,letra_A);\n    }\n}\n\nvoid Filas(int contador){\n    if(contador < 7){\n        switch (contador){\n            case 0: Columna(1,contador,'P');break;\n            case 1: Columna(1,contador,'N');break;\n            case 2: Columna(1,contador,'L');break;\n            case 3: Columna(1,contador,'J');break;\n            case 4: Columna(1,contador,'H');break;\n            case 5: Columna(1,contador,'F');break;\n            case 6: Columna(1,contador,'D');break;\n        }\n        printf(\"\\n\");\n        Filas(++contador);\n    }\n}\n\n\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint main()\n{\n    char letra;\n    int i = 0;\n    int j;\n    do{\n    switch (i){\n            case 0: letra = 'P';break;\n            case 1: letra = 'N';break;\n            case 2: letra = 'L';break;\n            case 3: letra = 'J';break;\n            case 4: letra = 'H';break;\n            case 5: letra = 'F';break;\n            case 6: letra = 'D';break;\n    }\n    j = 0;\n    do{\n        if(j >= (1 + i) && j <= (13-i))\n            printf(\"%c\", letra);\n        else\n        printf(\" \");\n        ++j;\n    }while(j <= 13);\n        printf(\"\\n\");\n        ++i;\n    }while( i< 7);\n    return 0; \n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint main()\n{\n    char letra;\n    int i = 0;\n    int j;\n    while( i< 7){\n    switch (i){\n            case 0: letra = 'P';break;\n            case 1: letra = 'N';break;\n            case 2: letra = 'L';break;\n            case 3: letra = 'J';break;\n            case 4: letra = 'H';break;\n            case 5: letra = 'F';break;\n            case 6: letra = 'D';break;\n    }\n    j = 0;\n    while(j <= 13){\n        if(j >= (1 + i) && j <= (13-i))\n            printf(\"%c\", letra);\n        else\n        printf(\" \");\n        ++j;\n    }\n        printf(\"\\n\");\n        ++i;\n    }\n    return 0; \n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int contador, int pibote);\nvoid Filas(int contador);\n\nint main()\n{\n        Filas(0);\n        return 0;\n}\n\nvoid Columnas(int contador, int pibote){\n    if(contador <= 46){\n        if(contador >= (34 + pibote) && contador <= (46 - pibote))\n            printf(\"P\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}\n\nvoid Filas(int contador)\n{\n    if(contador < 7){\n        Columnas(0, contador);\n        printf(\"\\n\");\n        Filas(++contador);\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int contador, int pibote);\nvoid Filas(int contador);\n\nint main()\n{\n        Filas(1);\n        return 0;\n}\n\nvoid Columnas(int contador, int pibote){\n    if(contador <= 13){\n        if(contador >= (1 + pibote) && contador <= (13 - pibote))\n                        printf(\"P\");\n                else\n                        printf(\" \");\n                Columnas(++contador, pibote);\n        }\n}\n\nvoid Filas(int contador)\n{\n        if(contador < 8){\n                Columnas(1, (contador-1));\n                printf(\"\\n\");\n                Filas(++contador);\n        }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas(int contador, int pibote);\nvoid Filas(int contador, int contador2);\n\nint main()\n{\n    \n    Filas(1, 7);\n    return 0;\n}\n\nvoid Columnas(int contador, int pibote)\n{\n    if(contador <= 34){\n        if(contador >= 28){\n            if(contador >= (28 + pibote) && contador <= (34 - pibote))\n                printf(\" \");\n            else\n                printf(\"A\");\n            Columnas(++contador, pibote);\n        }else{\n            printf(\" \");\n            Columnas(++contador, pibote);\n        }\n    }\n}\n\n\nvoid Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 8){\n        if(contador >= 4){\n            Columnas(1,contador2);\n            Filas(++contador,--contador2);\n\n        }else{\n            Columnas(1,contador);\n            Filas(++contador, --contador2);\n        }\n    }\n}\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int i = 1;\n    do\n    {\n        if(i >= 28){\n            if(i >= (28 + pibote) && i <= 34 - pibote){\n            printf(\" \");\n        }else{\n            printf(\"A\");\n        }\n        }else{\n            printf(\" \");\n        }\n        ++i;\n    }while(i <= 34);\n}\n\n\nint main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    do\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        \n        --contador2;\n        ++contador1;\n    }while(contador1 < 8);\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    for(int i = 1; i <= 34; ++i)\n    {\n    if(i >= 28){\n        if(i >= (28 + pibote) && i <= 34 - pibote){\n        printf(\" \");\n        }else{\n        printf(\"A\");\n        }\n    }else{\n        printf(\" \");\n    }\n    }\n}\n\n\nint main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    for(contador1 = 1; contador1 < 8; ++contador1)\n    {\n    printf(\"\\n\");\n        if(contador1 >= 4)\n        Columna(contador2);\n    else\n        Columna(contador1);\n        --contador2;\n    }\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int i = 1;\n    while(i <= 34)\n    {\n        if(i >= 28){\n            if(i >= (28 + pibote) && i <= 34 - pibote){\n            printf(\" \");\n        }else{\n            printf(\"A\");\n        }\n        }else{\n            printf(\" \");\n        }\n        ++i;\n    }\n}\n\n\nint main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        \n        --contador2;\n        ++contador1;\n    }\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas(int contador, int pibote);\nvoid Filas(int contador1,int contador2);\n\n\nint main()\n{\n    Filas(1,7);\n    return 0;\n}\n\nvoid Columnas(int contador, int pibote)\n{\n    if(contador <= 20){\n        if(contador >= (10 - pibote) && contador <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n\n}\n\nvoid Filas(int contador1, int contador2)\n{\n    printf(\"\\n\");\n    if(contador1 < 8){\n        if(contador1 > 4){\n            Columnas(1, (contador2 - 1));\n            Filas(++contador1, --contador2);\n        }else{\n            Columnas(1,( contador1 - 1));\n            Filas(++contador1, --contador2);\n        }\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int j = 1;\n    do\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        ++j;\n    }while(j <= 20);\n}\n\nint main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    do\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    ++contador1;\n    }while(contador1 < 8);\n    return 0;\n\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    for(int j = 1; j <= 20; ++j)\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n        printf(\"Z\");\n    else\n        printf(\" \");\n    }\n}\n\nint main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    for(contador1 = 1; contador1 < 8; ++contador1)\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    }\n    return 0;\n\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int j = 1;\n    while(j <= 20)\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        ++j;\n    }\n}\n\nint main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    ++contador1;\n    }\n    return 0;\n\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas(int contador, int pibote);\nvoid Filas(int contador);\n\n\nint main()\n{\n    Filas(1);\n    return 0;\n\n}\nvoid Columnas(int contador, int pibote){\n    if(contador <= 19){\n        if(contador == (1 + pibote) || contador == (19 - pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n\n}\n\nvoid Filas(int contador)\n{\n    if(contador < 11){\n        Columnas(1, (contador - 1));\n        printf(\"\\n\");\n        Filas(++contador);      \n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas(int contador, int pibote);\nvoid Filas(int contador);\n\n\nint main()\n{\n        Filas(1);\n        return 0;\n\n}\nvoid Columnas(int contador, int pibote){\n        if(contador <= 19){\n                if(contador == (1 + pibote) || contador == (19 - pibote))\n                        printf(\"Z\");\n                else\n                        printf(\" \");\n                Columnas(++contador, pibote);\n        }\n\n}\n\nvoid Filas(int contador)\n{\n        if(contador < 11){\n                Columnas(1, (10 - contador));\n                printf(\"\\n\");\n                Filas(++contador);\n        }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columnas();\nvoid Filas();\n\nint main()\n{\n\n    Filas(0, 10);\n    return 0;\n\n}\n\nvoid Columnas(int contador, int pibote)\n{\n    if(contador <= 40){\n        if(contador >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n        Columnas(++contador,pibote);\n    }\n}\n\n\nvoid Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 11){\n        if(contador > 5){\n            Columnas(1,contador2);\n            Filas(++contador, --contador2);\n        }else{\n            Columnas(1,contador);\n            Filas(++contador,--contador2);\n        }\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int j = 0;\n    do{\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }while(j <= 40);\n}\n\n\nint main()\n{\n    int contador1 = 0;\n    int contador2 = 10;\n    do\n    {\n        if(contador1 > 5)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        printf(\"\\n\");\n        ++contador1;\n    }while(contador1 < 11);\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Columna(int pibote)\n{\n    int j = 0;\n    while(j <= 40){\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }\n}\n\n\nint main()\n{\n    int contador1 = 0;\n    int contador2 = 10;\n    while(contador1 < 11)\n    {\n        if(contador1 > 5)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        printf(\"\\n\");\n        ++contador1;\n    }\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    do{Factorial *= ++i;}while(i < N);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        Suma_total += (Exp(X,i) \/ Fac(i));\n        ++i;\n    }while(i <= veces);\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Fac(double num) \n{\n        if(num == 1)\n                return 1;\n        else\n                return num * Fac(num - 1);\n}\n\ndouble Exp(int Exponente, double numero) \n{\n        if(Exponente == 1){\n                return numero;\n        }else{\n                return numero * Exp(--Exponente, numero);\n        }\n}\n\n\n\n\n\nvoid E(int contador, int iteraciones,double suma, double X);\n\n\nint main()\n{\n        double X;\n    int Numero_iteraciones;\n        printf(\"Programa para calcular Euler elevado a X me diante sumas de Taylor\\nIngresa X: \");\n        scanf(\"%lf\", &X);\n        \n        E(1,30,0,X);\n        return 0;\n}\n\nvoid E(int contador, int iteraciones,double suma, double X)\n{\n        if(contador <= iteraciones){\n                printf(\"\\n->%i %0.0lf \/ %0.0lf = %0.6lf\",contador,Exp(contador,X),Fac((contador + 0.0)), Exp(contador,X) \/ (Fac(contador) + 0.0));\n                suma = suma + Exp(contador,X) \/ (Fac(contador));\n                printf(\"\\tSuma por el momento: %0.6lf\\n\", suma);\n                E(++contador,iteraciones,suma,X);\n        }else{                \n        printf(\"\\nEl resultado de e^%0.0lf es: %lf\",X , (suma + 1.0));\n        }\n}\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    for(int i = 1;i < N; Factorial *= ++i);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n    Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas\");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += (Exp(X,i) \/ Fac(i));\n    }\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    while(i < N){Factorial *= ++i;}\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += (Exp(X,i) \/ Fac(i));\n        ++i;\n    }\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Fac(double num) \n{\n        if(num == 1)\n                return 1;\n        else\n                return num * Fac(num - 1);\n}\n\ndouble Exp(int Exponente, double numero)\n{\n        if(Exponente == 1){\n                return numero;\n        }else{\n                return numero * Exp(--Exponente, numero);\n        }\n}\n\n\n\n\nvoid cos(int contador,int iteraciones, double suma, double X);\n\n\nint main()\n{\n        double X;\n    int  I;\n        printf(\"Programa para calcular cos(X) mediante sumas de taylor \\nIngresa X: \");\n        \n    scanf(\"%lf\", &X);\n    \n    cos(1,50,0,X); \n        return 0;\n}\n\nvoid cos(int contador, int iteraciones, double suma, double X)\n{\n    if(contador <= iteraciones){    \n        if(contador%2 == 0){\n            printf(\"\\n%i -> %lf \/ %0.0lf = %0.6lf\", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) \/ Fac(contador * 2));\n\n            suma = suma + (Exp(contador*2,X) \/ Fac(contador * 2));\n            printf(\"   Suma Actual: %lf\", suma);\n            cos(++contador, iteraciones,suma,X);\n        }else{\n            printf(\"\\n%i -> %lf \/ %0.0lf = %0.6lf\", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) \/ Fac(contador * 2));\n            suma = suma - (Exp(contador*2,X) \/ Fac(contador * 2));\n            printf(\"  Suma Actual: %lf\", suma);\n            cos(++contador, iteraciones,suma,X);\n        }\n    }else{\n        printf(\"\\nCos(%lf) es igual a: %lf\", X, (suma + 1));\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    do{Factorial *= ++i;}while(i < N);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += (Exp(X, i*2) \/ Fac(i*2));\n        else\n            Suma_total -= (Exp(X, i*2) \/ Fac(i*2));\n        ++i;\n    }while(i <= veces);\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    for(int i = 1;i < N; Factorial *= ++i);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n        Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n        Suma_total += (Exp(X, i*2) \/ Fac(i*2));\n    else\n        Suma_total -= (Exp(X, i*2) \/ Fac(i*2));\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    while(i < N){Factorial *= ++i;}\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += (Exp(X, i*2) \/ Fac(i*2));\n        else\n            Suma_total -= (Exp(X, i*2) \/ Fac(i*2));\n        ++i;\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    do{Factorial *= ++i;}while(i < N);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        Suma_total += Exp(X,(i*2)+1) \/ Fac((i*2)+1);\n        ++i;\n    }while(i <= veces);\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    for(int i = 1;i < N; Factorial *= ++i);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n        Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)+1) \/ Fac((i*2)+1);\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Fac(double num)\n{\n    if(num == 1)\n        return 1;\n    else\n        return num * Fac(num - 1);\n}\n\ndouble Exp(int Exponente, double numero)\n{\n    if(Exponente == 1){\n        return numero;\n    }else{\n        return numero * Exp(--Exponente, numero);\n    }\n}\n\n\n\n\n\nvoid Senh(int contador, int iteraciones, double total, double X);\n\n\nint main(){\n    \n    double X;\n    printf(\"Programa para calcular el senh(X) por medio de sumas de Taylor\\nValor de X:\");\n    scanf(\"%lf\", &X);\n    Senh(1,30,0,X);\n    return 0;\n}\n\nvoid Senh(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        total = total + Exp((contador*2)+1,X) \/ Fac((contador*2)+1);\n        Senh(++contador,iteraciones,total,X);\n    }else{\n        printf(\"\\n**El Senh(%lf) es igual a: %lf\",X,total+X);\n\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    while(i < N){Factorial *= ++i;}\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)+1) \/ Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Fac(double num)\n{\n        if(num == 1)\n                return 1;\n        else\n                return num * Fac(num - 1);\n}\n\ndouble Exp(int Exponente, double numero)\n{\n        if(Exponente == 1){\n                return numero;\n        }else{\n                return numero * Exp(--Exponente, numero);\n        }\n}\n\n\n\n\n\nvoid cosh(int contador, int iteraciones, double total, double X);\n\n\nint main(){\n\n        double X;\n        printf(\"Programa para calcular el cosh(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n        cosh(1,30,0,X);\n        return 0;\n}\n\nvoid cosh(int contador, int iteraciones, double total, double X)\n{\n        if(contador <= iteraciones){\n                total = total + Exp((contador*2),X) \/ Fac((contador*2));\n                cosh(++contador,iteraciones,total,X);\n        }else{\n                printf(\"\\n**El cosh(%lf) es igual a: %lf\",X,total+1);\n\n        }\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    do{Factorial *= ++i;}while(i < N);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    {\n        Suma_total += Exp(X,(i*2)) \/ Fac((i*2));\n        ++i;\n    }while(i <= veces);\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    for(int i = 1;i < N; Factorial *= ++i);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n        Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)) \/ Fac((i*2));\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n\n    return 0;\n}\n\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    while(i < N){Factorial *= ++i;}\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)) \/ Fac((i*2));\n        ++i;\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += Exp(X-1, i+1) \/ (i+1);\n        else\n            Suma_total -= Exp(X-1, i+1) \/ (i +1);\n        ++i;\n    }while(i <= veces);\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n        Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n       if(i%2 == 0)\n      Suma_total += Exp(X-1, i+1) \/ (i+1);\n       else\n      Suma_total -= Exp(X-1, i+1) \/ (i +1);\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\n\ndouble Exp(int Exponente, double numero)\n{\n        if(Exponente == 1){\n                return numero;\n        }else{\n                return numero * Exp(--Exponente, numero);\n        }\n}\n\n\n\n\n\nvoid ln(int contador, int iteraciones, double total, double X);\n\nint main(){\n\n        double X;\n        printf(\"Programa para calcular el cosh(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n    if(X == 0.0){\n        printf(\"Fuera de rango\");\n    }else{\n            ln(1,10,0,X);\n    }\n    return 0;\n}\n\n\n\nvoid ln(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        if(contador%2 == 0){\n            printf(\"+ %lf\", (Exp(contador + 1, X-1) \/ (contador+1)));\n            total = total + (Exp(contador + 1, X-1) \/ (contador+1));\n            \n            ln(++contador,iteraciones,total,X);\n        }else{\n                        printf(\"- %lf\",(Exp(contador + 1, X-1) \/ (contador+1)));\n                        total = total - (Exp(contador + 1, X-1) \/ (contador+1));\n            \n                        ln(++contador,iteraciones,total,X);\n                }\n    }else{\n        printf(\"\\n\\n\\n**El ln(%lf) es %lf\", X, total + (X -1));\n    }\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += Exp(X-1, i+1) \/ (i+1);\n        else\n            Suma_total -= Exp(X-1, i+1) \/ (i +1);\n        ++i;\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    do{Factorial *= ++i;}while(i < N);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n        else\n            Suma_total -= Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n        ++i;\n    }while(i <= veces);\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    for(int i = 1;i < N; Factorial *= ++i);\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    for(int i = 0; i < exponente; ++i)\n    {\n        Total *= numero;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n    else\n        Suma_total -= Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\ndouble Fac(double num)\n{\n        if(num == 1)\n                return 1;\n        else\n                return num * Fac(num - 1);\n}\n\ndouble Exp(int Exponente, double numero)\n{\n        if(Exponente == 1){\n                return numero;\n        }else{\n                return numero * Exp(--Exponente, numero);\n        }\n}\n\n\n\n\nvoid Sen(int contador, int iteraciones, double total, double X);\n\n\nint main(){\n        double X;\n        printf(\"Programa para calcular el sen(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n        Sen(1,50,0,X);\n        return 0;\n}\n\nvoid Sen(int contador, int iteraciones, double total, double X)\n{\n        if(contador <= iteraciones){\n        if(contador%2 == 0){\n            total = total + (Exp((contador*2)+1, X) \/ Fac((contador*2)+1));\n            Sen(++contador, iteraciones,total,X);\n        }else{\n            total = total - (Exp((contador*2)+1, X) \/ Fac((contador*2)+1));\n                        Sen(++contador, iteraciones,total,X);\n        }\n        }else{\n                printf(\"\\n**El Sen(%lf) es igual a: %lf\",X,total+X);\n        }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\ndouble Fac(int N)\n{\n    double Factorial = 1.0;\n    int i = 1;\n    while(i < N){Factorial *= ++i;}\n    return Factorial;\n}\ndouble Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    while(i < exponente)\n    {\n    Total *= numero;\n    ++i;\n    }\n    return Total;\n}\n\n\nint main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n        else\n            Suma_total -= Exp(X, (i*2)+1) \/ Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Pedir_numeros(int Mayor, int menor, int Mayor_150, int negativos,int promedio_P, int contador, int num_p)\n{\n    int numero = 0;\n    if(contador <= 10){\n        printf(\"\\nIngrese por favor el numero: \");\n        scanf(\"%i\", &numero);\n        if(numero != 0){\n            if(numero > 150){\n                ++Mayor_150;    \n            }\n\n            if(numero > Mayor){\n                Mayor = numero;    \n            }else if(numero < menor){   \n                menor = numero;    \n            }\n\n            if(numero > 0){\n                ++num_p;\n                promedio_P += numero; \n            }else{\n                ++negativos;          \n            }\n            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,++contador,num_p);\n        }else{\n            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,contador,num_p);\n        }\n    }else{\n        printf(\"\\n***Fin del Ciclo***\\n\");\n        promedio_P = promedio_P \/ num_p;\n\n        printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n        printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n        printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n        printf(\"\\nPromedio positivos encontrados: %i\", promedio_P);\n    }\n}\n\n\nint main()\n{\n    Pedir_numeros(0,0,0,0,0,1,0); \n    return 0;\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint main()\n{\n    int Mayor = 0;\n    int menor = 0;\n    int Mayor_150 = 0;\n    int negativos = 0;\n    float promedio_P = 0.0;\n    int contador = 0;\n    int num_p = 0;\n    do\n    {\n     int numero = 0;\n     printf(\"\\nIngrese por favor el numero:\");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }while(contador < 10);\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P \/ num_p;\n\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint main()\n{\n    int Mayor = 0;\n    int menor = 0; \n    int Mayor_150 = 0; \n    int negativos = 0;\n    float promedio_P = 0.0; \n    int contador = 1; \n    int num_p = 0;  \n    for(contador = 0; contador < 10;)\n    {\n     int numero = 0;\n        \n     printf(\"\\nIngrese por favor el numero: \");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P \/ num_p;\n\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint main()\n{\n    int Mayor = 0;\n    int menor = 0;\n    int Mayor_150 = 0;\n    int negativos = 0;\n    float promedio_P = 0.0;\n    int contador = 0;\n    int num_p = 0;\n    while(contador < 10)\n    {\n     int numero = 0;\n\n     printf(\"\\nIngrese por favor el numero: \");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P \/ num_p;\n\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}\n\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid Multipli(int numero, int contador)\n{\n    if(contador <= 10){\n        printf(\"\\n%i X %i = %i\", numero, contador, numero*contador);\n        Multipli(numero, ++contador);\n    }\n\n}\n\n\nvoid Tablas(int numero)\n{\n    if(numero <= 10){\n        printf(\"\\n*** Tabla del %i ***\", numero);\n        Multipli(numero, 1);\n        Tablas(++numero);\n    }else{\n        printf(\"\\n***Fin del ciclo***\");\n    }\n}\n\nint main()  \n{\n    printf(\"\\nEste programa Muestra todas las tablas de multiplicar de base 10\\n\");\n    Tablas(1);\n    return 0;\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint factorial(int num)\n{\n    if(num == 1)\n        return 1;\n    else\n        return num * factorial(num - 1);\n}\n\nint Suma(int numero, int sumatoria);\n\n\n\nint main()\n{\n    int numero = 0;\n    printf(\"Programa calcula la suma de 0 hasta un numero N ingresado por el usuario\\nIngresa un numero:\");\n    scanf(\"%i\",&numero);\n\n    if(numero == 0)\n        printf(\"La suma de los factoriales de 0 es 1\");\n    else\n        printf(\"La suma de los factoriales de %i es %i\",numero,Suma(numero,0));\n\n    return 0;\n}\n\nint Suma(int numero, int Sumatoria)\n{\n    if(numero >= 1){\n        Sumatoria += factorial(numero);\n        Suma(--numero, Sumatoria);  \n    }else{\n        return Sumatoria + 1;\n    }\n}\n"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n int potencia(int, int);\n int potencia(int numero, int exponente){\n    int resultado = 1;\n    if(exponente == 0)\n        return 1;\n    else{\n        for(int i = 1; i <= exponente; i++) resultado *= numero;\n        return resultado;\n    }\n }\n\nint atoi(char *str);\nint atoi(char *str){\n    int longitud = 0;\n    int Valores = 0;\n    int Total = 0;\n    for( longitud = 0; str[longitud] != '\\0'; ++longitud);\n    for(int i = 0; i < longitud; i++){\n        Valores = ((int)(str[i]) - 48) * potencia(10, (longitud - i - 1));\n        Total += Valores;\n    }\n    return Total;\n}\n\n\nint main(){\n\n    char palabra[10] = \"23456\";\n    int value = 0;\n    value = atoi(palabra);\n    printf(\"%i\", value );\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint ft_eight_queens_puzzle(void);\nint Mov_Queen(int [8][8], int, int);\n\n\nint main(){\n    printf(\"%i\", ft_eight_queens_puzzle());\n}\n\nint ft_eight_queens_puzzle(void){\n    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     \n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0}};\n    int  contador = 0;\n\n    for(int Col_0 = 0; Col_0 < 8; Col_0++){  \n        Tabla[Col_0][0] = 1; \n\n        for(int Col_1 = 0; Col_1 < 8; Col_1++){ \n            if(Mov_Queen(Tabla, Col_1, 1) == 0){\n               Tabla[Col_1][1] = 1; \n\n               for (int Col_2 = 0; Col_2 < 8; Col_2++){ \n                   if(Mov_Queen(Tabla, Col_2, 2) == 0){\n                        Tabla[Col_2][2] = 1; \n\n                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ \n                            if(Mov_Queen(Tabla, Col_3, 3) == 0){\n                                Tabla[Col_3][3] = 1; \n\n                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  \n                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){\n                                        Tabla[Col_4][4] = 1; \n\n                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ \n                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){\n                                                Tabla[Col_5][5] = 1; \n\n                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ \n                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){\n                                                        Tabla[Col_6][6] = 1; \n\n                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) \n                                                        {\n                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){\n                                                                Tabla[Col_7][7] = 1; \n                                                                contador++;\n                                                            }\n                                                            Tabla[Col_7][7] = 0;  \n                                                        }\n                                                    }\n                                                    Tabla[Col_6][6] = 0;\n                                                }\n                                            }\n                                            Tabla[Col_5][5] = 0;\n                                        }  \n                                    } \n                                    Tabla[Col_4][4] = 0;\n                                }\n                            }\n                            Tabla[Col_3][3] = 0;\n                        }\n                    }\n                    Tabla[Col_2][2] = 0; \n                }\n            }\n            Tabla[Col_1][1] = 0;\n        }\n        Tabla[Col_0][0] = 0;\n    }\n    return contador; \n}\n\n\nint Mov_Queen(int Tabla[8][8], int fila, int columna){   \n                                                         \n    int fila_actual = 0; \n    int columna_actual = 0; \n    int estado = 0; \n    \n    for(int i = columna + 1; i < 8; i++) \n        if(Tabla[fila][i] == 1)\n            estado = 1;\n    \n    for(int i = columna - 1; i >= 0; i--) \n       if(Tabla[fila][i] == 1)\n            estado = 1; \n\n    for(int i = fila - 1; i >= 0; i--) \n       if(Tabla[i][columna] == 1)\n            estado = 1; \n\n    for(int i = fila + 1; i < 8; i++) \n       if(Tabla[i][columna] == 1)\n            estado = 1;\n\n    fila_actual = fila - 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual++;\n    }\n\n    fila_actual = fila - 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual--;\n    }\n\n    fila_actual = fila + 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual--;\n    }\n\n    fila_actual = fila + 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual++;\n    }\n    return estado;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid ft_eight_queens_puzzle_2(void);\nint Mov_Queen(int [8][8], int, int);\n\n\nint main(){\n    ft_eight_queens_puzzle_2();\n}\n\nvoid ft_eight_queens_puzzle_2(void){\n    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     \n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0}}; \n\n    for(int Col_0 = 0; Col_0 < 8; Col_0++){  \n        Tabla[Col_0][0] = 1; \n\n        for(int Col_1 = 0; Col_1 < 8; Col_1++){ \n            if(Mov_Queen(Tabla, Col_1, 1) == 0){\n               Tabla[Col_1][1] = 1; \n\n               for (int Col_2 = 0; Col_2 < 8; Col_2++){ \n                   if(Mov_Queen(Tabla, Col_2, 2) == 0){\n                        Tabla[Col_2][2] = 1; \n\n                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ \n                            if(Mov_Queen(Tabla, Col_3, 3) == 0){\n                                Tabla[Col_3][3] = 1; \n\n                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  \n                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){\n                                        Tabla[Col_4][4] = 1; \n\n                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ \n                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){\n                                                Tabla[Col_5][5] = 1; \n\n                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ \n                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){\n                                                        Tabla[Col_6][6] = 1; \n\n                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) \n                                                        {\n                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){\n                                                                Tabla[Col_7][7] = 1; \n                                                                printf(\"\\n%i%i%i%i%i%i%i%i\", Col_0+1, Col_1+1, Col_2+1, Col_3+1, Col_4+1, Col_5+1, Col_6+1, Col_7+1);\n                                                            }\n                                                            Tabla[Col_7][7] = 0;  \n                                                        }\n                                                    }\n                                                    Tabla[Col_6][6] = 0;\n                                                }\n                                            }\n                                            Tabla[Col_5][5] = 0;\n                                        }  \n                                    } \n                                    Tabla[Col_4][4] = 0;\n                                }\n                            }\n                            Tabla[Col_3][3] = 0;\n                        }\n                    }\n                    Tabla[Col_2][2] = 0; \n                }\n            }\n            Tabla[Col_1][1] = 0;\n        }\n        Tabla[Col_0][0] = 0;\n    }\n    printf(\"\\n\");\n}\n\n\nint Mov_Queen(int Tabla[8][8], int fila, int columna){   \n                                                         \n    int fila_actual = 0; \n    int columna_actual = 0; \n    int estado = 0; \n    \n    for(int i = columna + 1; i < 8; i++) \n        if(Tabla[fila][i] == 1)\n            estado = 1;\n    \n    for(int i = columna - 1; i >= 0; i--) \n       if(Tabla[fila][i] == 1)\n            estado = 1; \n\n    for(int i = fila - 1; i >= 0; i--) \n       if(Tabla[i][columna] == 1)\n            estado = 1; \n\n    for(int i = fila + 1; i < 8; i++) \n       if(Tabla[i][columna] == 1)\n            estado = 1;\n\n    fila_actual = fila - 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual++;\n    }\n\n    fila_actual = fila - 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual--;\n    }\n\n    fila_actual = fila + 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual--;\n    }\n\n    fila_actual = fila + 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual++;\n    }\n    return estado;\n}"}
{"target":"RaigoXD","func":"\n\n#include<stdio.h>\nvoid comb(int, int, int, int *);\nvoid comb(int i, int j,int k, int *datos){\n    if( i <= 7){\n        if(j <= 8){\n            if(k <= 9 ){\n                if(datos[i] != datos[j] && datos[i] != datos[k] && datos[j] != datos[k]){\n                    if(datos[i] < datos[j] && datos[i] < datos[k] && datos[j] < datos[k]){\n                        printf(\"%i%i%i  \", datos[i], datos[j], datos[k]);\n                    }               \n                }\n                comb(i, j, k+1, datos);\n            }else\n                comb(i, j+1, 2, datos);\n        }else\n           comb(i+1, 1, k, datos);\n    }\n}\n\n\nvoid ft_print_comb(); \nvoid ft_print_comb(){\n    int datos[10] = {0,1,2,3,4,5,6,7,8,9};\n    comb(0, 1,2, datos);\n    \n}\n\nint main(){\n    ft_print_comb(); \n    return 0;\n}"}
{"target":"RaigoXD","func":"\n\n#include<stdio.h>\n\nvoid ft_print_comb2(); \n\nvoid ft_print_comb2(){\n    int x = 9;\n    int m = 0;\n    for(int i = 0; i<= 9; i++){\n        if(i == 9)\n            x = 8;\n        for(int j = 0; j <= x; j++){\n            for(int k = 0; k <= 9; k++){    \n                if(j != 0)\n                    m = 0;\n                for(int l = m; l <= 9; l++){\n                    if( i*10 + j != k*10+l){\n                        printf(\"%i%i %i%i, \", i,j,k,l);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    ft_print_comb2(); \n    return 0;\n}"}
{"target":"RaigoXD","func":"#include <stdio.h>\nvoid ft_print_combn(int n);\n\nvoid comb1(int *numeros,int a);\nvoid comb2(int *numeros,int a, int b);\nvoid comb3(int *numeros,int a, int b,int c);\nvoid comb4(int *numeros,int a, int b,int c,int d);  \nvoid comb5(int *numeros,int a, int b,int c,int d,int e);\nvoid comb6(int *numeros,int a, int b,int c,int d,int e,int f);\nvoid comb7(int *numeros,int a, int b,int c,int d,int e,int f,int g);\nvoid comb8(int *numeros,int a, int b,int c,int d,int e,int f,int g, int h);\nvoid comb9(int *numeros,int a, int b,int c,int d,int e,int f,int g, int h, int i);\n\nint main()\n{\n    ft_print_combn (2);\n    return 0;\n}\n\nvoid ft_print_combn(int n)\n{\n    int numeros[10]={ 0, 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9}; \n\n    int a =0, b =1, c =2,d =3, e =4, f =5, g =6, h =7, i =8;    \n    \n    if(n==1)\n      comb1(numeros,a);\n      else{\n           if(n==2)\n              comb2(numeros,a,b);\n              else{\n                   if(n==3)\n                     comb3(numeros,a,b,c);                      \n                     else{\n                          if(n==4)\n                            comb4(numeros,a,b,c,d);\n                            else{\n                                 if(n==5)\n                                   comb5(numeros,a,b,c,d,e);\n                                   else{\n                                        if(n==6)\n                                          comb6(numeros,a,b,c,d,e,f);\n                                          else{\n                                               if(n==7)\n                                                  comb7(numeros,a,b,c,d,e,f,g);\n                                                  else{\n                                                       if(n==8)\n                                                          comb8(numeros,a,b,c,d,e,f,g,h);\n                                                          else{\n                                                               if(n==9)\n                                                                  comb9(numeros,a,b,c,d,e,f,g,h,i);\n                                                                  else{\n                                                                       printf(\"Valor no procesable\");\n                                                                      }\n                                                              }\n                                                      }\n                                              }\n                                       }\n                                }\n                         }\n                  }\n          }  \n}\n\nvoid comb1(int *numeros,int a)\n{\n  while(a<=9)\n       {\n        printf(\"%i, \",numeros[a]); \n        a=a+1;\n       }\n}\n\nvoid comb2(int *numeros,int a,int b)\n{\n  while(a<=8)\n       {\n        while(b<=9)\n            {\n              printf(\"%i%i, \",numeros[a],numeros[b]);    \n              b=b+1;\n            }\n        a=a+1;\n        b=a+1;\n       }\n}\n\nvoid comb3(int *numeros,int a,int b,int c)\n{\n  while(a<=7)\n       {\n        while(b<=8)\n             {\n              while(c<=9)\n                  {\n                    printf(\"%i%i%i, \",numeros[a],numeros[b],numeros[c]);\n                    c=c+1;\n                  }\n              b=b+1;\n              c=b+1;\n             }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n       }\n}\n\nvoid comb4(int *numeros,int a,int b,int c, int d)\n{\n  while(a<=6)\n       {\n          while(b<=7)\n               {\n                while(c<=8)\n                     {\n                      while(d<=9)\n                          {\n                            printf(\"%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d]);\n                            d=d+1;\n                          }\n                      c=c+1;\n                      d=c+1;\n                     }     \n                b=b+1;\n                c=b+1;\n                d=c+1;\n               } \n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n       }\n}\n\nvoid comb5(int *numeros,int a,int b,int c, int d,int e)\n{\n  while(a<=5)\n       {\n          while(b<=6)\n               {\n                while(c<=7)\n                    {\n                      while(d<=8)\n                           {\n                            while(e<=9)\n                                {\n                                  printf(\"%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e]);\n                                  e=e+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                           }\n                      c=c+1;\n                      d=c+1;\n                      e=d+1;\n                    }\n                b=b+1;\n                c=b+1;\n                d=c+1;\n                e=d+1;\n               } \n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n          e=d+1;\n       }\n}\n\nvoid comb6(int *numeros,int a,int b,int c, int d,int e,int f)\n{\n  while(a<=4)\n       {\n          while(b<=5)\n              {\n                  while(c<=6)\n                      {\n                        while(d<=7)\n                            {\n                              while(e<=8)\n                                   {\n                                    while(f<=9)\n                                        {\n                                          printf(\"%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f]);\n                                          f=f+1;\n                                        }\n                                    e=e+1;\n                                    f=e+1;\n                                   }\n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                            }\n                        c=c+1;\n                        d=c+1;\n                        e=d+1;\n                        f=e+1;\n                      } \n                  b=b+1;\n                  c=b+1;\n                  d=c+1;\n                  e=d+1;\n                  f=e+1;\n              }\n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n          e=d+1;\n          f=e+1;\n      }\n}\n\nvoid comb7(int *numeros,int a,int b,int c, int d,int e,int f,int g)\n{\n  while(a<=3)\n       {\n        while(b<=4)\n            {\n                while(c<=5)\n                    {\n                        while(d<=6)\n                            {\n                              while(e<=7)\n                                  {\n                                    while(f<=8)\n                                         {\n                                          while(g<=9)\n                                              {\n                                                printf(\"%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g]);\n                                                g=g+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                         }\n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                  }\n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                              g=f+1;\n                            } \n                        c=c+1;\n                        d=c+1;\n                        e=d+1;\n                        f=e+1;\n                        g=f+1;\n                    }\n                b=b+1;\n                c=b+1;\n                d=c+1;\n                e=d+1;\n                f=e+1;\n                g=f+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n       }\n}\n\nvoid comb8(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h)\n{\n  while(a<=2)\n       {\n        while(b<=3)\n            {\n              while(c<=4)\n                  {\n                      while(d<=5)\n                          {\n                              while(e<=6)\n                                  {\n                                    while(f<=7)\n                                        {\n                                          while(g<=8)\n                                               {\n                                                while(h<=9)\n                                                    {\n                                                      printf(\"%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h]);\n                                                      h=h+1;\n                                                    }\n                                                g=g+1;\n                                                h=g+1;\n                                               }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                        }\n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                  } \n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                              g=f+1;\n                              h=g+1;\n                          }\n                      c=c+1;\n                      d=c+1;\n                      e=d+1;\n                      f=e+1;\n                      g=f+1;\n                      h=g+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n       }\n}\n\nvoid comb9(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h,int i)\n{\n  while(a<=1)\n       {\n        while(b<=2)\n            {\n              while(c<=3)\n                  {\n                    while(d<=4)\n                        {\n                            while(e<=5)\n                                {\n                                    while(f<=6)\n                                        {\n                                          while(g<=7)\n                                              {\n                                                while(h<=8)\n                                                     {\n                                                      while(i<=9)\n                                                          {\n                                                            printf(\"%i%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h],numeros[i]);\n                                                            i=i+1;\n                                                          }\n                                                      h=h+1;\n                                                      i=h+1;\n                                                     }\n                                                g=g+1;\n                                                h=g+1;\n                                                i=h+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                          i=h+1;\n                                        } \n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                    i=h+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                            f=e+1;\n                            g=f+1;\n                            h=g+1;\n                            i=h+1;\n                        }\n                    c=c+1;\n                    d=c+1;\n                    e=d+1;\n                    f=e+1;\n                    g=f+1;\n                    h=g+1;\n                    i=h+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n              i=h+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n        i=h+1;\n       }\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint longitud_N(int numero, int contador){\n    if(numero > 0){\n        longitud_N(numero\/10, contador + 1);\n    }else{\n        return contador;\n    }\n}\n\nvoid llenar_string(char *str, int numero, int longitud_N){\n    if(numero > 0){\n        str[longitud_N - 1] = (numero%10)+48;\n        llenar_string(str, numero\/10, longitud_N-1);\n    }\n}\n\n\nvoid ft_putnbr(int );\nvoid ft_putnbr(int numero){\n    int longitud = longitud_N(numero, 0);\n    int negativo = 0;\n    char string_intermedio[11] = \"\";\n\n    if(numero < 0){\n        numero = numero*(-1);\n        longitud++;\n        llenar_string(string_intermedio, numero, longitud);\n        string_intermedio[0] = '-';\n    }else{\n        llenar_string(string_intermedio, numero, longitud);\n    }\n    printf(\"%s\", string_intermedio);\n}\n\nint main()\n{\n    ft_putnbr(123);\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nvoid ft_putnbr(int );\nvoid ft_putnbr(int numero){\n    int negativo = 0;\n\n    if(numero < 0){\n        numero = numero*(-1);\n        negativo = 1;\n    }\n    else\n        negativo = 0;\n    \n    int longitud_N = 0; \n    for(int  i = numero; i > 0; i= i\/10){\n        ++longitud_N; \n    }\n\n    if(negativo)\n        longitud_N++;\n\n    char string_intermedio[11] = \" \"; \n\n    for(int i = numero; i > 0; i = i\/10){ \n        string_intermedio[longitud_N-1] = (i%10)+48;\n        --longitud_N;\n    }\n    if(negativo)\n        string_intermedio[0] = '-';\n\n\n    printf(\"%s\", string_intermedio); \n}\n\nint main()\n{\n    ft_putnbr(-204);\n    return 0;\n}"}
{"target":"RaigoXD","func":"\n#include <stdio.h>\n\nint ft_strlen(char *);\nint ft_strlen(char *dato){\n    int i = 0;\n    while(dato[i] != '\\0')++i;\n    return i;\n}\n\nchar *ft_strrev (char *);\nchar *ft_strrev (char * str){\n    int longitud = ft_strlen(str);\n    char *string; \n\n    for(int i = 1; i <= longitud + 1; i++){\n        if(i > longitud)\n            string[longitud] = '\\0';\n        else\n            string[i -1] = str[longitud - i];\n    }\n    return string;\n}\n\n\n\nint main(){\n    char *palabra = \"casa\";\n    palabra = ft_strrev(palabra);\n    printf(\"%s\", palabra);\n    return 0;\n}"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<errno.h>\n#include<fcntl.h>\n#include<string.h>\n\n#define FILE_SIZE 100\n\nint read_lines(char s[FILE_SIZE]);\nint read_char();\nchar s[FILE_SIZE];\nint main()\n{\n    FILE *f;\n    int pid,c_cnt,fd[2];\n    pipe(fd);\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    \n    pid=fork();\n    if(pid==0)\n    {\n        int c_cnt=0;\n        printf(\"------inside the child process--------\\n\");\n        close(fd[0]);\n        c_cnt=read_char();\n        printf(\"readed the character\\n\");\n        printf(\"character :%d\\n\",c_cnt);\n        write(fd[1],&c_cnt,sizeof(c_cnt));\n        close(fd[1]);\n    }\n    else\n    {\n        wait(NULL);\n        \n        printf(\"-----back to parent process-----\\n\");\n        int cnt;\n        read_lines(s);\n        close(fd[1]);\n        read(fd[0],&cnt,sizeof(cnt));\n        printf(\"The count of character in the file is :%d\\n\",cnt);\n        close(fd[0]);\n    }\n    \n    return 0;\n}\n\nint read_char()\n{\n    FILE *f;\n    int character=0;\n    char ch;\n    f=fopen(s,\"r\");\n    if (f == NULL) \n    { \n        printf(\"Could not open file\"); \n        return 0; \n    }\n    while ((ch = fgetc(f)) != EOF)\n    {\n        if (ch != ' ' || ch != '\\t' || ch != '\\n' || ch != '\\0'|| ch!='.')\n        character++;\n    }\n    return(character);\n}\n\n\n\nint read_lines(char s[FILE_SIZE])\n{\n    FILE *f;\n    int words;\n    char ch;\n    f=fopen(s,\"r\");\n    if (f == NULL) \n    { \n        printf(\"Could not open file\"); \n        return 0; \n    }\n    words = 0;\n    while ((ch = fgetc(f)) != EOF)\n    {\n        \n\n        \n        if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0'|| ch=='.')\n            words++;\n    }\n    \n    printf(\"\\tthe number of words are :%d\\n\",words);    \n    fclose(f);\n    return (1);\n}\n    "}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/shm.h>\n#include<sys\/stat.h>\n#include<sys\/mman.h>\n#include<string.h>\n#include<fcntl.h>\n#include<string.h>\n\nint main()\n{\nconst char* name=\"odd_even\";\nconst int SIZE=15*1024;\nint shmid;\nchar words;\nvoid* shmptr;\nshmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (shmid< 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n     printf(\"inside client\\n\");\n     while(1)\n     {\n         puts(shmptr);\n         shmptr+=15*sizeof(char);\n     }\n     shm_unlink(name);\n     return 0;\n}"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<ctype.h>\n#include<errno.h>\n\nchar words[15];\nvoid odd_file_open();\nvoid even_file_open();\n\nint main()\n{\n    \n    memset(words,0,sizeof(words));\n    char ch;\n    int wrd=0,i=0;\n    FILE *fp,*fpe,*fpo;\n    fp=fopen(\"input.txt\",\"r\");\n    fpe=fopen(\"even.txt\",\"w+\");\n    fpo=fopen(\"odd.txt\",\"w+\");\n\n    while ((ch = fgetc(fp)) != EOF)\n    {\n    if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0'||ch=='.')\n    {\n        wrd++;\n        if((wrd%2)==0)\n        {\n            fprintf(fpe,\"%s\\n\",words);\n        }\n        else\n        {\n            fprintf(fpo,\"%s\\n\",words);\n    }\n    memset(words,0,sizeof(words));\n    i=0;\n    }\n    else\n    {\n    words[i]=ch;\n    i=i+1;\n    }\n    }\n    fclose(fp);\n    fclose(fpo);\n    fclose(fpe);\n    int pid1,pid2;\n    pid1=fork();\n    if (pid1==0)\n    {\n        printf(\"inside first child\\n\");\n        even_file_open();\n    }\n    else{\n        wait(NULL);\n        pid2=fork();\n    if (pid2==0)\n       {\n        printf(\"inside second child\\n\");\n        odd_file_open();\n        }\n        else{\n            wait(NULL);\n            printf(\"i am done\\n\");\n        }\n    }\n        return 0;\n}\n        \nvoid even_file_open()\n{\n    FILE *fpe;\nprintf(\"even file opening-----\\n\");\nfpe=fopen(\"even.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpe)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpe);\n}\nvoid odd_file_open()\n{\n    FILE *fpo;\nprintf(\"odd file opening-----\\n\");\nfpo=fopen(\"odd.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpo)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpo);\n}\n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/shm.h>\n#include<sys\/stat.h>\n#include<sys\/mman.h>\n#include<string.h>\n#include<fcntl.h>\n#include<string.h>\n\nchar words[15];\n\nint main()\n{\nconst char* name=\"odd_even\";\nconst int SIZE=15*1024;\nint shmid;\nvoid* shmptr;\nshmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (shmid< 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n     printf(\"atached to the shared memory\\n\");\n     \n    memset(words,0,sizeof(words));\n    char ch;\n    int wrd=0,i=0;\n    FILE *fp,*fpe,*fpo;\n    fp=fopen(\"input.txt\",\"r\");\n    fpe=fopen(\"even.txt\",\"w+\");\n    fpo=fopen(\"odd.txt\",\"w+\");\n\n    while ((ch = fgetc(fp)) != EOF)\n    {\n    if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0'||ch=='.')\n    {\n        wrd++;\n        if((wrd%2)==0)\n        {\n            fprintf(fpe,\"%s\\n\",words);\n        }\n        else\n        {\n            fprintf(fpo,\"%s\\n\",words);\n    }\n    memset(words,0,sizeof(words));\n    i=0;\n    }\n    else\n    {\n    words[i]=ch;\n    i=i+1;\n    }\n    }\n    fclose(fp);\n    fclose(fpo);\n    fclose(fpe);\n    printf(\"i am here\\n\");\nprintf(\"even file opening-----\\n\");\nfpe=fopen(\"even.txt\",\"r\");\nsprintf(shmptr,\"%s\",\"even_file\");\nshmptr+=15*sizeof(char);\n    \nwhile (fgets(words,sizeof(words),fpe)!=NULL)\n{\n    sprintf(shmptr,\"%s\",words);\n    shmptr+=15*sizeof(char);\n}\nfclose(fpe);\n\nprintf(\"odd file opening-----\\n\");\nfpo=fopen(\"odd.txt\",\"r\");\nsprintf(shmptr,\"%s\",\"odd_file\");\nshmptr+=SIZE;\nprintf(\"fine till\\n\");\nwhile (fgets(words,sizeof(words),fpo)!=NULL)\n{\n    sprintf(shmptr,\"%s\",words);\n    shmptr+=15*sizeof(char);\n}\nfclose(fpo);\nsleep(15);\nmunmap(shmptr,SIZE);\nshm_unlink(name);\nreturn 0;\n}\n\n\n\n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<unistd.h>\n#include<pthread.h>\n#include<errno.h>\n\nchar words[15];\nvoid *odd_file_open(void *para);\nvoid *even_file_open(void *para);\n\nint main()\n{\n    \n    memset(words,0,sizeof(words));\n    char ch;\n    int wrd=0,i=0;\n    FILE *fp,*fpe,*fpo;\n    pthread_t thread1,thread2;\n    fp=fopen(\"input.txt\",\"r\");\n    fpe=fopen(\"even.txt\",\"w+\");\n    fpo=fopen(\"odd.txt\",\"w+\");\n\n    while ((ch = fgetc(fp)) != EOF)\n    {\n    if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0'||ch=='.')\n    {\n        wrd++;\n        if((wrd%2)==0)\n        {\n            fprintf(fpe,\"%s\\n\",words);\n        }\n        else\n        {\n            fprintf(fpo,\"%s\\n\",words);\n    }\n    memset(words,0,sizeof(words));\n    i=0;\n    }\n    else\n    {\n    words[i]=ch;\n    i=i+1;\n    }\n    }\n    fclose(fp);\n    fclose(fpo);\n    fclose(fpe);\n    pthread_create(&thread1,NULL,even_file_open,NULL);\n    pthread_join(thread1,NULL);\n    pthread_create(&thread2,NULL,even_file_open,NULL);\n    pthread_join(thread2,NULL);\n    printf(\"\\ti am done:) \\n\");\n    \n        return 0;\n}\n        \nvoid *even_file_open(void *para)\n{\n    FILE *fpe;\nprintf(\"even file opening-----\\n\");\nfpe=fopen(\"even.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpe)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpe);\n}\nvoid *odd_file_open(void *para)\n{\n    FILE *fpo;\nprintf(\"odd file opening-----\\n\");\nfpo=fopen(\"odd.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpo)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpo);\n}\n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<fcntl.h>\n#include<errno.h>\n\n#define SIZE 10\n\nint n;\nvoid choice_zero(char b[SIZE]);\nvoid choice_one(char b[SIZE]);\n\nint main(int argc,char *argv [])\n{\n    char s[SIZE],b[SIZE];\n    int a,p[2],pid;\n    pipe(p);\n    if (argc<2)\n    {printf(\"enter the format .\/'name',stringFFF,choice'1 or 0'\");}\n    strcpy(s,argv[1]);\n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {return 1;}\n    printf(\"writing to child\\n\");\n\n    pid=fork();\n    if(pid==0)\n    {printf(\"inside  child-------\\n\");\n    char c[SIZE];\n    close(p[1]);\n    read(p[0],c,10);\n    n=strlen(c);\n    printf(\"the string count is %d\\n\",(n-3));\n    close(p[0]);\n    }\n    else{\n    close(p[0]);\n    write(p[1],s,10);\n    close(p[1]);\n    printf(\"writed\\n\");\n        wait(NULL);\n    }\n    return 0;\n}\n\nvoid choice_one(char b[SIZE])\n{\n    char p[SIZE]=\"SIOSFFF\";\n    \n\n        if (strcmp(b,p)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");}\n        \n}\n    \nvoid choice_zero(char b[SIZE])\n{\n        char r[SIZE]=\"MCISFFF\";\n        if (strcmp(b,r)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        }\n}   \n        "}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/shm.h>\n#include<sys\/stat.h>\n#include<sys\/mman.h>\n#include<string.h>\n#include<fcntl.h>\n\nvoid choice_zero(char b[10]);\nvoid choice_one(char b[10]);\n\nint main(int argc,char *argv [])\n{\n    char s[10],b[10];\n    int a,n;\n    const int SIZE =4096;\n    const char* name =\"os\";\n    int key,shmid;\n    void* shmptr;\n    if (argc<2)\n    {printf(\"enter the format .\/'name',stringFFF,choice'1 or 0'\");}\n    \n    \n    key=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (key < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(key,SIZE);\n    shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,key,0);\n    printf(\"atached to the shared memory\\n\");\n    strcpy(s,argv[1]);\n    n=strlen(s);\n    sprintf(shmptr,\"%d\",n-3);\n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {return 0;}\n    sleep(10);\n    shmid=munmap(shmptr,SIZE);\n    key=shm_unlink(name);\n    \n    return 1;\n}\n    \n    \n    \n    void choice_one(char b[10])\n{\n    char p[10]=\"SIOSFFF\";\n    \n\n        if (strcmp(b,p)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");\n        }\n        \n}\n    \nvoid choice_zero(char b[10])\n{\n        char r[10]=\"MCISFFF\";\n        if (strcmp(b,r)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        }\n}\n    "}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<errno.h>\n#include<fcntl.h>\n#include<string.h>\n\n#define SIZE 30\n\nint main()\n{\n    char str[SIZE];\n    int i,n=0,pid,fd[2],f1[2];\n    pipe(fd);\n    \n    printf(\"enter the string with in 30 letter or else change the string size  in pgm:\\n\");\n    fgets(str,sizeof(str),stdin);\n    \n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    \n    \n    \n    pid=fork();\n    if (pid==0)\n    {\n        \n        printf(\"inside the child process--------\\n\");\n        char b[SIZE],ch;\n        int n,vowel=0,i=0;\n        close(fd[1]);\n        read(fd[0],b,sizeof(b));\n        close(fd[0]);\n        \n        \n        \n        n=strlen(b);\n        printf(\"the string gets to the child using pipes is :%s\\n\",b);\n        while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the vowel count in the given string is %d\",vowel);\n    }\n    else{\n        close(fd[0]);\n    write(fd[1],str,sizeof(str));\n    close(fd[1]);\n        wait(NULL);\n        printf(\"\\n********back to parent process******!\");\n    }\n        return 0;\n}       \n    \n    \n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<pthread.h>\n#include<unistd.h>\n#include<string.h>\n\n#define SIZE 30\n\nvoid *count_vowels(void *string);\n\nint main()\n{\n    \n    char str[SIZE];\n    printf(\"enter the string\\n\");\n    int i,n=0;\n    fgets(str,sizeof(str),stdin);\n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    pthread_t thread;\n    pthread_create(&thread,NULL,count_vowels,&str);\n    pthread_join(thread,NULL);\n    \n    return 0;\n}\n\nvoid *count_vowels(void *string)\n\n{\n    char *b=(char *)string;\n    int n,i,vowel=0;\n    char ch;\n    n=strlen(b);\n    while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the number of vowels in the strings is  %d\\n\",vowel);\n        return 0;\n}"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<errno.h>\n#include<fcntl.h>\n\n\n#define SI 10\n\n\nint array[SI],i;\nfloat sum_of_num();\nfloat product_of_num();\n\nint main()\n{\n    int pid,fd[2];\n    pipe(fd);\n    printf(\"enter the 10 values to be calculated\\n\");\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n    }\n    pid=fork();\n    if (pid==0)\n    {\n        printf(\"inside child-----\\n\");\n        close(fd[0]);\n        float product,sum;\n        sum=sum_of_num();\n        printf(\"the sum is %f\\n\",sum);\n        write(fd[1],&sum,sizeof(sum));\n        product=product_of_num();\n        printf(\"the product is %f\\n\",product);\nclose(fd[1]);       \n    }\n    else\n    {\n        wait(NULL);\n        printf(\"-----inside parent process------\\n\");\n        close(fd[1]);\n        float avg=0,sum;\n        read(fd[0],&sum,sizeof(sum));\n        printf(\"\\tthe sum is %f\\n\",sum);\n        avg=sum\/SI;\n        printf(\"\\tthe average is %f\\n\",avg);\n    }\n    return 0;\n}\n    \n        \n    float product_of_num()\n{\n    float product=1;\n    for(i=0;i<SI;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}\n\n\nfloat sum_of_num()\n{\n    float sum=0;\n    for(i=0;i<SI;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}\n\n\n    \n        \n        \n\n"}
{"target":"revathy16296","func":"#include  <stdio.h>\n#include  <stdlib.h>\n#include  <sys\/ipc.h>\n#include  <sys\/shm.h>\n#include  <stdlib.h>\n#include  <sys\/types.h>\n#include <fcntl.h>\n#include<sys\/wait.h>\n#include<unistd.h>\n#include<errno.h>\n\nint  ClientProcess(float SharedMem[]);\nint main()\n{\n     int    ShmID,p[2];\n     pipe(p);\n     float    *ShmPTR; \n     pid_t  pid; \n     int    status;\n     int a[10],i;\n     \n     printf(\"enter the 10 array elements\\n\");\n     for(i=0;i<10;i++)\n     {\n         scanf(\"%d\",&a[i]);\n     }\n     ShmID = shmget(IPC_PRIVATE, 10*sizeof(int), IPC_CREAT | 0666); \n     if (ShmID < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n\n     printf(\"Server has received a shared memory of 10 integers...\\n\");\n     ShmPTR = (float *) shmat(ShmID, NULL, 0);\n\n    \n\n     printf(\"Server has attached the shared memory...\\n\");\n     \n     for(i=0;i<10;i++)\n     {\n         ShmPTR[i]=a[i];\n     }\n     pid=fork();\n     if (pid == 0) {\n        float sum;\n        sum=ClientProcess(ShmPTR);\n        close(p[0]);\n        write(p[1],&sum,sizeof(sum));\n        close(p[1]);\n          exit(0);\n     }\n     \n     else{\n         wait(&status);\n         float sum,avg;\n         close(p[1]);\n         read(p[0],&sum,sizeof(sum));\n         avg=sum\/10;\n        printf(\"the average is %f\\n\",avg);\n        shmdt((void *) ShmPTR); \n        shmctl(ShmID, IPC_RMID, NULL);\n     }\n     return 0;\n}\n     \n     \n     \n     int  ClientProcess(float  SharedMem[])\n     {\n     float sum=0,product=1;\n     int i;\n     \n     for(i=0;i<10;i++)\n     {\n         sum+=(SharedMem[i]);\n     }\n     printf(\"the sum is %f\\n\",sum);\n     \n     for(i=0;i<10;i++)\n     {\n         product*=(SharedMem[i]);\n     }\n     printf(\"the product are %f\\n\",product);\n     return (sum);\n     }"}
{"target":"revathy16296","func":"#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include<unistd.h>\n\n#define SIZE 10\nvoid *sum_array(void *a[SIZE]);\nvoid* product_of_elements(void* a[SIZE]);\npthread_mutex_t mutex;\nint  array[SIZE];\n    int i;\nint main()\n{\n    \n    printf(\"enter the array numbers\\n\");\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&(array[i]));\n    }\n    pthread_t thread1, thread2;\n    printf(\"the thread is created\\n\");\n    pthread_create(&thread1, NULL, sum_array, &array);\n    pthread_create(&thread2, NULL, product_of_elements,&array );\n    \n    \n    pthread_join(thread1,NULL);\n    pthread_join (thread2,NULL);\n    \n    \n    pthread_mutex_destroy(&mutex);\n    \nreturn 0;\n}\n\n\nvoid* sum_array(void *a[SIZE])\n{\n    pthread_mutex_lock(&mutex);\n    float sum=0;\n    int *ar=(int *)a;\n    printf(\"inside the first thread\\n\");\n    for(i=0;i<SIZE;i++)\n    {\n        sum += ar[i];\n        printf(\"%f\\t\",sum);\n    }\n    printf(\"the sum is %f\\n\",sum);\n    float average;\n    average=sum\/10;\n    printf(\"the average is %f\\n\",average);\n    pthread_mutex_unlock(&mutex);\n}\n\nvoid* product_of_elements(void* a[SIZE])\n{\n    float product=1;\n    int* ar=(int*) a;\n    for(i=0;i<SIZE;i++)\n    {\n         product =ar[i] * product;\n    }\n    printf(\"product=%f\\n\",product);\n}"}
{"target":"revathy16296","func":"#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include<unistd.h>\n\n#define SIZE 10\n\nvoid *sumofnum(void *arra);\nvoid *productofnum(void *arra);\n\nint n,i;\nint main()\n{\n    int array[SIZE];\n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n\n    }\n    }\n    pthread_t thread1, thread2;\n    pthread_create(&thread1, NULL,sumofnum,&array);\n    pthread_create(&thread2, NULL,productofnum,&array);\n\n    \n   pthread_join(thread1,NULL);\n \n   \n    pthread_join (thread2,NULL);\n    \n    return 0;\n    \n    \n}\n\n\nvoid *sumofnum(void *arra)\n{\n    int sum=0;\n    int *arr=(int *)arra;\n    for(i=0;i<n;i++)\n    {\n        sum+=arr[i];\n    }\n    printf(\"the sum is %d\\n\",sum);\n    \n}\n\n\nvoid *productofnum(void *arra)\n{\n    float product=1;\n    int *arr=(int *)arra;\n    for(i=0;i<n;i++)\n    {\n        product=arr[i]*product;\n        printf(\"%f\\t\",product);\n    }\n    printf(\"the product is %f\\n\",product);\n}\n\n\n\n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<errno.h>\n#include<fcntl.h>\n\n#define SI 10\n\nint i, array[SI],n=0;\nfloat sum_of_num();\nfloat product_of_num();\n\n\n\nint main()\n{\n    int fd1[2],fd2[2];\n    pipe(fd1);\n    pipe(fd2);\n    \n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n\n    }\n    }\n    pid_t pid;\n    pid=fork();\n    if(pid==0)\n    {\n        printf(\"inside child-----\\n\");\n        close(fd1[0]);\n        close(fd2[0]);\n        float product,sum;\n        sum=sum_of_num();\n        printf(\"the sum is %f\\n\",sum);\n        write(fd1[1],&sum,sizeof(sum));\n        product=product_of_num();\n        printf(\"the product is %f\\n\",product);\n        write(fd2[1],&product,sizeof(product));\n\n        close(fd1[1]);\n        close(fd2[1]);      \n        \n    }\n    else\n    {\n        wait(NULL);\n        printf(\"-----inside parent process------\\n\");\n        close(fd1[1]);\n        close(fd2[1]);\n        float avg=0,sum,product;\n        read(fd1[0],&sum,sizeof(sum));\n        read(fd2[0],&product,sizeof(product));\n\n        printf(\"\\tthe sum is %f\\n\",sum);\n        avg=sum\/SI;\n        printf(\"\\tthe average is %f\\n\",avg);\n        printf(\"\\tthe product is %f\\n\",product);\n\n        close(fd1[0]);\n        close(fd2[0]);\n    }\n        \n        return 0;\n}\n\n        \n    float product_of_num()\n{\n    float product=1;\n    for(i=0;i<n;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}\n\n\nfloat sum_of_num()\n{\n    float sum=0;\n    for(i=0;i<n;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}"}
{"target":"revathy16296","func":"#include<stdlib.h>\n#include<stdio.h>\n#include<unistd.h>\n#include<errno.h>\n#include<sys\/types.h>\n#include<sys\/wait.h>\n#include<sys\/shm.h>\n#include<sys\/ipc.h>\n#include<fcntl.h>\n\n#include\"shm_head.h\"\n\n#define SIZE 10\n\nint main()\n{\n    key_t key;\n    int shmid,i;\n    struct Memory *shmptr;\n    key = ftok(\".\", 'x');\n    printf(\"key:%d\\n\",key);\n    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);\n     if (shmid < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     shmptr=(struct Memory*)shmat(shmid,NULL,0);\n     if ((int) shmptr == -1) {\n          printf(\"*** shmat error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"client attached to shared memory\\n\");\n     printf(\"sum is %f\\n\",shmptr->arr[0]);\n     printf(\"product is %f\\n\",shmptr->arr[1]);\n     printf(\"average is %f\\n\",shmptr->arr[2]);\n     shmptr->status=TAKEN;\n     shmdt((void*)shmptr);\n     exit(0);\n}\n\n    \n     "}
{"target":"revathy16296","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<errno.h>\n#include<sys\/types.h>\n#include<sys\/wait.h>\n#include<sys\/shm.h>\n#include<sys\/ipc.h>\n#include<fcntl.h>\n\n#include\"shm_head.h\"\n\n#define SIZE 10\n\nint main()\n{\n    key_t key;\n    int array[10],i,n;\n    int shmid;\n    struct Memory *shmptr;\n    key = ftok(\".\", 'x');\n    printf(\"key:%d\\n\",key);\n    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);\n     if (shmid < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     \n     shmptr=(struct Memory*)shmat(shmid,NULL,0);\n     if ((int) shmptr == -1) {\n          printf(\"*** shmat error (server) ***\\n\");\n          exit(1);\n     }\n     \n     printf(\"enter the array elements less than 10 numbers and use 999 to stop the number\\n\");\n     while(array[i]!=999)\n    {\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n\n    }\n    }\n    float product=1,sum=0;\n    for(i=0;i<n;i++)\n    {\n        sum+=array[i];\n        product*=array[i];\n    }\n    shmptr->status  = NOT_READY;\n    shmptr->arr[0]=sum;\n    shmptr->arr[1]=product;\n    shmptr->arr[2]=sum\/n;\n     shmptr->status=FILLED;\n     printf(\"please start the client in another window\\n\");\n     while (shmptr->status != TAKEN)\n          sleep(1);\n    shmdt((void *) shmptr);\n    printf(\"back to server and shared memory detached\\n\");\n     \n     shmctl(shmid, IPC_RMID, NULL);\n     exit(0);\n}\n\n     \n     \n     \n     \n     \n     \n     "}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<unistd.h>\n#include<sys\/wait.h>\n#include<sys\/types.h>\n#include<errno.h>\n#include<fcntl.h>\nstruct tele\n{\n    char name[15],sir_name[15],number[15];\n};\nint main()\n{\n    FILE *fp;\n    struct tele cust[10];\n    struct tele temp;\n    int choice,limit,beg=0,i,j,c,count=0,pid;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n                \n                break;\n            case 2:\n            pid=fork();\n            \n            if(pid==0)\n            {\n                printf(\"entered in to the child  process!\\n\");\n            FILE *fp;\n            \n                printf(\"\\ncustomer details\\n\");\n                fp=fopen(\"details.txt\",\"r\");\n                if(fp==NULL)\n                {\n                    printf(\"error!\");\n                    exit(1);\n                }\n                \n                for (i=0;i<beg;i++)\n                {\n                    fread(&cust,sizeof(struct tele),1,fp);\n                    printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n                }\n                fclose(fp);\n            }\n            else\n            {\n            wait(NULL);\n            exit(0);\n            }\n            break;\n            \n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}\n    \n\n"}
{"target":"revathy16296","func":"#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include<unistd.h>\n#include<string.h>\n\n\nvoid *display_dir(void *para);\nvoid *add_element(void *para);\n\nstruct tele\n{\n    char name[15],sir_name[15],number[15];\n};\n\nint choice,limit,beg,i,j,c,count=0;\nstruct tele cust[10];\n\nint main()\n{\n    pthread_t thread2,thread1;\n    beg=0;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            pthread_create(&thread1,NULL,add_element,NULL);\n            pthread_join(thread1,NULL);\n                break;\n            case 2:\n            \n            pthread_create(&thread2,NULL,display_dir,NULL);\n            pthread_join(thread2,NULL);\n            break;\n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}\n\nvoid *display_dir(void *para)\n{\n    \n    printf(\"entered in to the thread2  process!\\n\");\n    FILE *fp;\n    printf(\"\\ncustomer details\\n\");\n    fp=fopen(\"details.txt\",\"r\");\n    if(fp==NULL)\n    {\n        printf(\"error!\");\n        exit(1);\n    }\n                \n    for (i=0;i<beg;i++)\n    {\n        fread(&cust,sizeof(struct tele),1,fp);\n        printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n    }\n        fclose(fp);\n}\nvoid *add_element(void *para)\n{\n    FILE *fp;\n    struct tele temp;\n    fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n}"}
{"target":"revathy16296","func":"#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include<unistd.h>\n#include<string.h>\n\n#define FILE_SIZE 100\n\nvoid *read_lines(void *para);\nvoid *read_char(void *para);\nchar s[FILE_SIZE];\nint main()\n{\n    pthread_t thread1,thread2;\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    pthread_create(&thread1,NULL,read_char,NULL);\n    pthread_join(thread1,NULL);\n    pthread_create(&thread1,NULL,read_lines,NULL);\n    pthread_join(thread1,NULL);\n    \n    return 0;\n}\n\nvoid *read_char(void *para)\n{\n    FILE *f;\n    int character=0;\n    char ch;\n    f=fopen(s,\"r\");\n    if (f == NULL) \n    { \n        printf(\"Could not open file\"); \n        return 0; \n    }\n    while ((ch = fgetc(f)) != EOF)\n    {\n        if (ch != ' ' || ch != '\\t' || ch != '\\n' || ch != '\\0'|| ch!='.')\n        character++;\n    }\n    printf(\"the character count is %d\\n\",character);\n    fclose(f);\n    pthread_exit(NULL);\n}\n\n\n\nvoid *read_lines(void *para)\n{\n    FILE *f;\n    int words;\n    char ch;\n    f=fopen(s,\"r\");\n    if (f == NULL) \n    { \n        printf(\"Could not open file\"); \n        return 0; \n    }\n    words = 0;\n    while ((ch = fgetc(f)) != EOF)\n    {\n        \n        if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0'|| ch=='.')\n            words++;\n    }\n    printf(\"the number of words are :%d\\n\",words);  \n    fclose(f);\n}\n    "}
{"target":"revathy16296","func":"#include  <stdio.h>\n#include  <stdlib.h>\n#include  <sys\/mman.h>\n#include  <sys\/stat.h>\n#include  <sys\/shm.h>\n#include<errno.h>\n#include<fcntl.h>\n#include<string.h>\n#include<sys\/wait.h>\n#include<unistd.h>\n\n#define GIVE 0\n#define TAKE 1\n\nint main()\n{\n     int     shmid;\n     void* shmptr;\n     \n    const int SIZE=4096;\n    const char* name=\"vowels\";\n      shmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      ftruncate(shmid,SIZE);\n      shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n      printf(\"inside client\\n\");\n      \n     \n      printf(\"the word count  is:\\n\");\n      \n      puts(shmptr);\n      printf(\"the character count  is:\\n\");\n      shmptr+=sizeof(int);\n      puts(shmptr);\n      shm_unlink(name);\n      return 0;\n}"}
{"target":"revathy16296","func":"#include  <stdio.h>\n#include  <stdlib.h>\n#include  <sys\/stat.h>\n#include  <sys\/mman.h>\n#include  <sys\/shm.h>\n#include<errno.h>\n#include<fcntl.h>\n#include<string.h>\n#include<sys\/wait.h>\n#include<unistd.h>\n\n\n#define FILESI 20\n#define GIVE 0\n#define TAKE 1\n\nint read_count(char s[FILESI]);\n int n,m;\nint main()\n{\n    const int SIZE=4096;\n    const char* name=\"vowels\";\n     int     shmid;\n     void* shmptr;\n     char s[FILESI];\n    \n     printf(\"enter the file path\\n\");\n     scanf(\"%s\",s);\n     read_count(s);\n     shmid=shm_open(name,O_CREAT|O_RDWR,0666);\n     if(shmid<0){\n         perror(\"shmget\");\n         exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n    printf(\"shared mym attached\\n\");\n    sprintf(shmptr,\"%d\",m);\n    shmptr +=sizeof(int);\n    \n    sprintf(shmptr,\"%d\",n);\n    shmptr +=sizeof(int);\n    \n     printf(\"open client\\n\");\n     \n     \n     sleep(10);\n     \n     munmap(shmptr,SIZE);\n     shm_unlink(name);\n     return 0;\n}\n\nint read_count(char s[FILESI])\n{\n    FILE(*fp);\n    fp=fopen(s,\"r\");\n    char ch;\n    if (fp==NULL){\n        printf(\"error in opening file\\n\");\n        return 0;\n    }\n    n=m=0;\n    while((ch=fgetc(fp))!=EOF)\n    {\n        n++;\n        if (ch=='\\n'||ch=='\\t'||ch=='.'||ch==' '||ch=='\\0')\n        m++;\n    }\n    \n    \n    fclose(fp);\n    return 1;\n}"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#define SI 10\n\nfloat sum_of_num(int array[]);\nfloat average_of_num(float sum);\nfloat product_of_num(int array[]);\n\nint i;\n\n\n\nint main()\n{\n    int array[SI];\n    float product,average,sum;\n    printf(\"enter the array elements\\n\");\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n    }\n    sum=sum_of_num(array);\n    printf(\"the sum of number is %f\\n\",sum);\n    average=average_of_num(sum);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array);\n    printf(\"product of number is %f\",product);\n    return 0;\n}\n\n\n\nfloat sum_of_num(int array[])\n{\n    float sum=0;\n    for(i=0;i<SI;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}\n\n\n\nfloat average_of_num(float sum)\n{\n    float average=0;\n    average=sum\/SI;\n    return average;\n}\n\n\n\nfloat product_of_num(int array[])\n{\n    float product=1;\n    for(i=0;i<SI;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}\n\n\n\n    \n\n\n\n\n\n    \n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#define SI 10\n\nint sum_of_num(int array[],int n);\nfloat average_of_num(int sum,int n);\nfloat product_of_num(int array[],int n);\n\nint i;\n\n\n\nint main()\n{\n    int array[SI],n=0,sum;\n    float product,average;\n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n\n    }\n    }\n    sum=sum_of_num(array,n);\n    printf(\"the sum of number is %d\\n\",sum);\n    average=average_of_num(sum,n);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array,n);\n    printf(\"product of number is %f\",product);\n    return 0;\n}\n\n\n\nint sum_of_num(int array[],int n)\n{\n    int sum=0;\n    for(i=0;i<n;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}\n\n\n\nfloat average_of_num(int sum,int n)\n{\n    float average=0;\n    average=sum\/n;\n    return average;\n}\n\n\n\nfloat product_of_num(int array[],int n)\n{\n    float product=1;\n    for(i=0;i<n;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#define SI 10\n\nint sum_of_num(int array[],int n);\nfloat average_of_num(int sum,int n);\nfloat product_of_num(int array[],int n);\n\nint i;\n\n\n\nint main(int argc,char *argv[])\n{\n    int array[SI],n=0,sum;\n    float product,average;\n\n\n    while(atoi(argv[i])!=999)\n    {\n    for(i=1;i<SI;i++)\n    {\n        array[i]=atoi(argv[i]);\n        n=n+1;\n        if(atoi(argv[i])==999)\n        break;\n\n    }\n    }\n    \n    for(i=1;i<n;i++){\n    printf(\"%d\\n\",array[i]);}\n    sum=sum_of_num(array,n);\n    printf(\"the sum of number is %d\\n\",sum);\n    average=average_of_num(sum,n);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array,n);\n    printf(\"product of number is %f\",product);\n    return 0;\n}\n\n\n\nint sum_of_num(int array[],int n)\n{\n    int sum=0;\n    for(i=1;i<n;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}\n\n\n\nfloat average_of_num(int sum,int n)\n{\n    float average=0;\n    average=sum\/(n-1);\n    return average;\n}\n\n\n\nfloat product_of_num(int array[],int n)\n{\n    float product=1;\n    for(i=1;i<n;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#define SI 10\n\n\n\nint i;\n\nint main()\n{ \nFILE *fp;\nint n,sum=0;\nfloat product=1,average;\nint array[SI];\n\nfp=fopen(\"file.txt\",\"w+\");\nprintf(\"inside the file called 'file.txt'\");\nprintf(\"\\n ------writing to the file------\\n\");\nprintf(\"enter the  number of elements in array\\n\");\nscanf(\"%d\",&n);\nprintf(\"enter the elements in the array\\n\");\nfor(i=0;i<n;i++)\n{\n    scanf(\"%d\",&array[i]);\n}\n\n    for(i=0;i<n;i++)\n    {\n        sum=sum+array[i];\n    }\n\n\n    average=sum\/n;\n    \n    for(i=0;i<n;i++)\n    {\n        product=product*array[i];\n    }\n\nfclose(fp);\n\nfp=fopen(\"file.txt\",\"r\");\nprintf(\"\\n----reading from the file----\\n\");\nprintf(\"the array elements are \\n\");\nfor(i=0;i<n;i++)\n{\n    printf(\"%d\\t\",array[i]);\n}\nprintf(\"\\nthe sum of number is %d\\n\",sum);\nprintf(\"the average is %f\\n\",average);\nprintf(\"product of number is %f\",product);\nfclose(fp);\n\n\nreturn 0;\n}"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct tele\n{\n    char name[15],sir_name[15],number[15];\n};\nint main()\n{\n    FILE *fp;\n    struct tele cust[50];\n    struct tele temp;\n    int choice,limit,beg=0,i,j,c,count=0;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n                \n                break;\n            case 2:\n                printf(\"\\ncustomer details\\n\");\n                fp=fopen(\"details.txt\",\"r\");\n                if(fp==NULL)\n                {\n                    printf(\"error!\");\n                    exit(1);\n                }\n                \n                for (i=0;i<beg;i++)\n                {\n                    fread(&cust,sizeof(struct tele),1,fp);\n                    printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n                }\n                fclose(fp);\n                break;\n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}\n    \n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct dates{\n    int day,month,year;\n}date;\n\nvoid comp_dat(date d1,date d2);\n\nint main()\n{\n    date d1,d2;\n    printf(\"enter the date 1 in format DD-MM-YYYY:\\t\");\n    scanf(\"%d-%d-%d\",&d1.day,&d1.month,&d1.year);\n    printf(\"enter the date 2 in format DD-MM-YYYY:\\t\");\n    scanf(\"%d-%d-%d\",&d2.day,&d2.month,&d2.year);\n    comp_dat(d1,d2);\n    return 0;\n}\n\n\nvoid comp_dat(date d1,date d2)\n{\n    if((d1.year==d2.year)&&(d1.month==d2.month)&&(d1.day==d2.day))\n    {printf(\"\\nBoth the dates are same\");}\n    else if(d1.year>d2.year||(d1.year==d2.year&&d1.month>d2.month)||(d1.year==d2.year&&d1.month==d2.month&&d1.day>d2.day))\n    {printf(\"\\nThe latest date is %d-%d-%d\",d1.day,d1.month,d1.year);}\n    else\n        {printf(\"\\nThe latest date is %d-%d-%d\",d2.day,d2.month,d2.year);}\n}\n    "}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<string.h>\n#define FILE_SIZE 100\n#define LINE 20\nint read_lines(char s[FILE_SIZE]);\nint main()\n{\n    FILE *f;\n    char s[FILE_SIZE];\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    read_lines(s);\n    return 0;\n}\n\nint read_lines(char s[FILE_SIZE])\n{\n    FILE *f;\n    int words,lines;\n    char ch;\n    f=fopen(s,\"r\");\n    if (f == NULL) \n    { \n        printf(\"Could not open file\"); \n        return 0; \n    }\n    words = lines = 0;\n    while ((ch = fgetc(f)) != EOF)\n    {\n\n        \n        if (ch == '\\n' || ch == '\\0')\n            lines++;\n\n        \n        if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\0')\n            words++;\n    }\n    printf(\"\\tthe number of lines are :%d\\n\",lines);\n    printf(\"\\tthe number of words are :%d\\n\",words);    \n    fclose(f);\n    return 1;\n}\n    \n    \n\n    \n    \n\n"}
{"target":"revathy16296","func":"#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\n\n#define SIZE 10\n\nvoid choice_zero(char b[SIZE]);\nvoid choice_one(char b[SIZE]);\n\nint n;\n\nint main(int argc,char *argv [])\n{\n    char s[SIZE],b[SIZE];\n    int a,i;\n    if (argc<2)\n    {printf(\"enter the format .\/'name',stringFFF,choice'1 or 0'\");}\n    strcpy(s,argv[1]);\n    n=strlen(s);\n    \n    \n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {printf(\"\\nthe length of the given string is %d\",(n-3));}\n    return 0;\n}\n\nvoid choice_one(char b[SIZE])\n{\n    char p[4]=\"SIOS\";\n    \n\n        if (strncmp(b,p,4)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");\n        printf(\"the length of given string is %d\",n-3);}\n}\n    \nvoid choice_zero(char b[SIZE])\n{\n        char r[4]=\"MCIS\";\n        if (strncmp(b,r,4)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        printf(\"the length of given string is %d\",n-3);}\n}   \n        "}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#define CAPACITY 5\nint stack[CAPACITY], top=-1;\n\nvoid push(int item);\nint pop();\nvoid traverse();\n\nint isFull();\nint isEmpty();\nint main()\n{\n    while(1)\n    {\n        int ch, item;\n        printf(\"1. Push \\n\");\n        printf(\"2. Pop\\n\");\n        printf(\"3. Traverse \\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &ch);\n        \n        switch (ch)\n        {\n        case 1:\n            printf(\"Enter element to push\\n\");\n            scanf(\"%d\", &item);\n            push(item);\n            break;\n        case 2:\n            item = pop();\n            if(item == 0)\n            {\n                printf(\"Stack is underflow\\n\");\n            }\n            else\n            {\n                printf(\"Popped item is %d \\n\", item);\n            }\n            break;\n        case 3:\n            traverse();\n            break;\n        case 4:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Input\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid push(int ele)\n{\n    if(isFull())\n    {\n        printf(\"Stack is Full \\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = ele;\n        printf(\"%d pushed \\n\", ele);\n    }\n}\n\nint pop()\n{\n    if(isEmpty())\n    {\n        return 0;\n    }\n    else\n    {\n        return stack[top--];\n    }\n}\n\nvoid traverse()\n{\n    if(isEmpty())\n    {\n        printf(\"Stack is Empty\\n\");\n    }\n    else\n    {\n        int i;\n        for(i = 0; i<=top; i++)\n        {\n            printf(\"%d \\n\", stack[i]);\n        }\n    }\n}\n\n\nint isFull()\n{\n    if(top == CAPACITY -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint isEmpty()\n{\n    if(top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#define CAPACITY 50\n\nchar stack[CAPACITY];\nint i, len; count = 0;\nint top = -1;\n\nvoid push(char arg)\n{\n    top++;\n    stack[top] = arg;\n}\nchar pop()\n{\n    char c;\n    c = stack[top];\n    top--;\n    return c;\n}\n\nint main()\n{\n    printf(\"Enter a String to Check\\n\");\n    scanf(\"%s\", stack);\n    len = strlen(stack);\n    \n    for(i = 0; i<len; i++)\n    {\n        push(stack[i]);\n    }\n    for(i = 0; i<len; i++)\n    {\n        if(stack[i]==pop())\n        {\n            count++;\n        }\n    }\n    if(count == len)\n    {\n        printf(\"Given string is Palindrome\\n\");\n    }\n    else\n    {\n        printf(\"Given string is not Palindrome\\n\");\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#define CAPACITY 100\n\n\nint top = -1;\nchar stack[CAPACITY];\n\nvoid push(char item)\n{\n    if(top>= CAPACITY-1)\n    {\n        printf(\"Stack is Full\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = item;\n    }\n}\nchar pop()\n{\n    char item;\n    item = stack[top];\n    top--;\n    return(item);\n}\nint precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '\/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\nint is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '\/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\n\n\nint main()\n{\n    char infix[CAPACITY], postfix[CAPACITY], item, temp;\n    int i = 0, j = 0;\n    printf(\"Enter an Infix Expression to Convert into Postfix : \");\n    gets(infix);\n\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == '(')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            postfix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == ')')\n        {\n            temp = pop();\n            while(temp != '(')\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"\\nInvalid Expression\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        postfix[j] = pop();\n        j++;\n    }\n    printf(\"\\nArithmetic Expression in Postfix form is : \");\n    puts(postfix);\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid addend(void);\nvoid addbegin(void);\nvoid addafter(void);\nvoid display(void);\nvoid del(void);\nvoid delval(int value);\nvoid dellist(void);\n\nint len;\nint length(void);\nint search(int value);\n\nstruct node\n{\n    int data;\n    struct node* link;\n};\nstruct node* root = NULL;\n\n\nint main()\n{\n    int choice, value;\n    while(1)\n    {\n        printf(\"Single Linked List Operations : \\n\");\n        printf(\"1. Add at End\\n\");\n        printf(\"2. Add at Begin\\n\");\n        printf(\"3. Add at After\\n\");\n        printf(\"4. Display\\n\");\n        printf(\"5. Delete\\n\");\n        printf(\"6. Delete Value\\n\");\n        printf(\"7. Delete List\\n\");\n        printf(\"8. Quit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            addend();\n            break;\n        case 2:\n            addbegin();\n            break;\n        case 3:\n            addafter();\n            break;\n        case 4:\n            display();\n            break;\n        case 5:\n            del();\n            break;\n        case 6:\n            printf(\"Enter the value to delete : \");\n            scanf(\"%d\", &value);\n            delval(value);\n            break;\n        case 7:\n            dellist();\n            break;\n        case 8:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Entry\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid addend()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter Node Data : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->link = NULL;\n\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        struct node* p;\n        p = root;\n        while(p->link != NULL)\n        {\n            p = p->link;\n        }\n        p->link = temp;\n    }\n}\n\nvoid addbegin()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter a node to insert : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\", temp->data);\n    temp->link = root;\n    root = temp;\n}\n\nvoid addafter()\n{\n    struct node* temp, * p;\n    int key, i = 1;\n    printf(\"Enter location : \");\n    scanf(\"%d\", &key);\n    len = length();\n    if(key > len)\n    {\n        printf(\"Unable to insert\\n\");\n        printf(\"The list is having only %d nodes.\\n\", len);\n    }\n    else\n    {\n        p = root;\n        while(i < key)\n        {\n            p = p->link;\n            i++;\n        }\n        temp = (struct node*)malloc(sizeof(struct node));\n        printf(\"Enter a node to insert : \");\n        scanf(\"%d\", &temp->data);\n        printf(\"%d inserted.\\n\", temp->data);\n        temp->link = p->link;\n        p->link = temp;\n    }\n}\n\nvoid display()\n{\n    struct node* temp;\n    temp = root;\n    if(temp == NULL)\n    {\n        printf(\"List is Empty\\n\");\n    }\n    else\n    {\n        while(temp != NULL)\n        {\n            printf(\"%d-->\", temp->data);\n            temp = temp->link;\n        }\n        printf(\"\\n\\n\");\n    }\n}\n\nvoid del()\n{\n    struct node* temp;\n    int key;\n    printf(\"Enter the key : \");\n    scanf(\"%d\", &key);\n    if(key > length())\n    {\n        printf(\"Invalid Location\\n\");\n    }\n    else if(key == 1)\n    {\n        temp = root;\n        root = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n    else\n    {\n        struct node* p = root, *q;\n        int i = 1;\n        while(i < key - 1)\n        {\n            p = p->link;\n            i++;\n        }\n        q = p->link;\n        p->link = q->link;\n        q->link = NULL;\n        free(q);\n    }\n}\n\nvoid delval(int value)\n{\n    struct node* temp, *p = root, *q;\n    q = root->link;\n    if(root->data == value)\n    {\n        temp = root;\n        root = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n    else if(search(value) == 1)\n    {\n        while(q->data != value)\n        {\n            p = p->link;\n            q = p->link;\n        }\n        p->link = q->link;\n        q->link = NULL;\n        free(q);\n    }\n    else\n    {\n        printf(\"Value not found in the list.\\n\\n\");\n    }\n}\n\nvoid dellist()\n{\n    struct node *temp = root, *p;\n    while(temp != NULL)\n    {\n        p = temp->link;\n        free(temp);\n        temp = p;\n    }\n    printf(\"All the elements in the list deleted successfully.\\n\\n\");\n    root = NULL;\n}\n\n\nint length()\n{\n    int count = 0;\n    struct node* temp;\n    temp = root;\n    while(temp != NULL)\n    {\n        count++;\n        temp = temp->link;\n    }\n    printf(\"The length of the linked list is : %d\\n\\n\", count);\n    return count;\n}\n\nint search(int value)\n{\n    struct node *p = root;\n    while(p != NULL)\n    {\n        if(p->data == value)\n        {\n            return 1;\n        }\n        else\n        {\n            p = p->link;\n        }\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node* left;\n    struct node* right;\n};\nint len;\nstruct node * root = NULL;\nvoid addend(void);\nvoid addbegin(void);\nvoid addafter(void);\nvoid display(void);\nvoid reverse(void);\nvoid del(void);\nvoid delvalue(int value);\nvoid dellist(void);\n\nint search(int value);\nint length(void);\n\nint main()\n{\n    int choice, value;\n    while(1)\n    {\n        printf(\"Double Linked List Operations : \\n\");\n        printf(\"1. Append\\n\");\n        printf(\"2. Add at Begin\\n\");\n        printf(\"3. Add at After\\n\");\n        printf(\"4. Display\\n\");\n        printf(\"5. Reverse\\n\");\n        printf(\"6. Delete\\n\");\n        printf(\"7. Delete Value\\n\");\n        printf(\"8. Delete List\\n\");\n        printf(\"9. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            addend();\n            break;\n        case 2:\n            addbegin();\n            break;\n        case 3:\n            addafter();\n            break;\n        case 4:\n            display();\n            break;\n        case 5:\n            reverse();\n            break;\n        case 6:\n            del();\n            break;\n        case 7:\n            printf(\"Enter the value to delete : \");\n            scanf(\"%d\", &value);\n            delvalue(value);\n            printf(\"\\n\\n\");\n            break;\n        case 8:\n            dellist();\n            break;\n        case 9:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid addend()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to append : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        struct node* p = root;\n        while(p->right != NULL)\n        {\n            p = p->right;\n        }\n        p->right = temp;\n        temp->left = p;\n    }\n}\n\nvoid addbegin()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to insert : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        temp->right = root;\n        root->left = temp;\n        root = temp;\n    }\n}\n\nvoid addafter()\n{\n    struct node* temp, *p = root, *q;\n    int key, i = 1;\n    printf(\"Enter the location where you want to insert : \");\n    scanf(\"%d\", &key);\n    if(key > len)\n    {\n        printf(\"Unable to insert \\n\\n\");\n    }\n    else\n    {\n        while(i < key)\n        {\n            p = p->right;\n            i++;\n        }\n        q = p->right;\n        temp = (struct node*)malloc(sizeof(struct node));\n        printf(\"Enter an element to insert : \");\n        scanf(\"%d\", &temp->data);\n        printf(\"%d inserted\\n\\n\", temp->data);\n        temp->left = NULL;\n        temp->right = NULL;\n        temp->right = q;\n        q->left = temp;\n        p->right = temp;\n        temp->left = p;\n    }\n}\n\n\nvoid display()\n{\n    struct node * temp = root;\n    if(root == NULL)\n    {\n        printf(\"List is Empty\\n\\n\");\n    }\n    else\n    {\n        while(temp != NULL)\n        {\n            printf(\"%d --> \", temp->data);\n            temp = temp->right;\n        }\n        printf(\"\\n\\n\");\n    }\n}\n\nvoid reverse()\n{\n    struct node* temp = root;\n    if(root == NULL)\n    {\n        printf(\"List is Empty\\n\\n\");\n    }\n    else\n    {\n        while(temp->right != NULL)\n        {\n            temp = temp->right;\n        }\n        while(temp != NULL)\n        {\n            printf(\"%d --> \", temp->data);\n            temp = temp->left;\n        }\n        printf(\"\\n\\n\");\n    }\n}\n\n\nvoid del()\n{\n    struct node* temp;\n    int key, i = 1;\n    printf(\"Enter the location of element to delete : \");\n    scanf(\"%d\", &key);\n    if(key > length())\n    {\n        printf(\"Invalid Location to perform delete\\n\\n\");\n    }\n    else if(key == 1)\n    {\n        temp = root;\n        root = temp->right;\n        temp->left = NULL;\n        free(temp);\n    }\n    else if(key == length())\n    {\n        struct node * temp, *p;\n        p = root;\n        while(p->right != NULL)\n        {\n            p = p->right;\n        }\n        temp = p->left;\n        temp->right = NULL;\n        free(p);\n    }\n    else\n    {\n        struct node *p, *q;\n        temp = root;\n        while(i < key)\n        {\n            temp = temp->right;\n            i++;\n        }\n        q = temp->right;\n        p = temp->left;\n        p->right = q;\n        q->left = p;\n        free(temp);\n    }\n}\n\nvoid delvalue(int value)\n{\n    struct node* temp = root, *p, *q;\n    \n    if(root->data == value)\n    {\n        root = temp->right;\n        free(temp);\n    }\n    else if(search(value) == 1)\n    {\n        while(temp->data != value)\n        {\n            temp = temp->right;\n        }\n        q = temp->right;\n        p = temp->left;\n        if(temp->right != NULL)\n        {\n            p->right = q;\n            q->left = p;\n            free(temp);\n        }\n        else\n        {\n            p->right = NULL;\n            free(temp);\n        }\n    }\n    else\n    {\n        printf(\"Value not found in the list.\\n\\n\");\n    }\n}\n\nvoid dellist()\n{\n    struct node *temp = root, *p;\n    while(temp != NULL)\n    {\n        p = temp->right;\n        free(temp);\n        temp = p;\n    }\n    printf(\"All the elements in the list deleted successfully.\\n\\n\");\n    root = NULL;\n}\n\n\nint length()\n{\n    struct node* temp = root;\n    int count = 0;\n    while(temp != NULL)\n    {\n        count++;\n        temp = temp->right;\n    }\n    return count;\n}\n\nint search(int value)\n{\n    struct node *p = root;\n    while(p != NULL)\n    {\n        if(p->data == value)\n        {\n            return 1;\n        }\n        else\n        {\n            p = p->right;\n        }\n    }\n    return 0;\n}\n\n\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node* link;\n};\nstruct node* top = NULL;\nvoid enqueue();\nvoid dequeue();\nvoid traverse();\n\nint main()\n{\n    int choice;\n    while(1)\n    {\n        printf(\"Queue Operations : \\n\");\n        printf(\"1. Enqueue\\n\");\n        printf(\"2. Dequeue\\n\");\n        printf(\"3. Traverse\\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            enqueue();\n            break;\n        case 2:\n            dequeue();\n            break;\n        case 3:\n            traverse();\n            break;\n        case 4:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\");\n        }\n    }\n    return 0;\n}\nvoid enqueue()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to insert : \");\n    scanf(\"%d\", &temp->data);\n    temp->link = NULL;\n\n    if(top == NULL)\n    {\n        top = temp;\n    }\n    else\n    {\n        struct node* p;\n        p = top;\n        while(p->link != NULL)\n        {\n            p = p->link;\n        }\n        p->link = temp;\n    }\n}\nvoid dequeue()\n{\n    struct node* temp;\n    printf(\"%d deleted.\\n\", top->data);\n    if(top == NULL)\n    {\n        printf(\"Queue is Empty\\n\");\n    }\n    else\n    {\n        temp = top;\n        top = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n}\nvoid traverse()\n{\n    struct node* temp;\n    if(top == NULL)\n    {\n        printf(\"Queue is Empty\\n\");\n    }\n    else\n    {\n        temp = top;\n        while(temp != NULL)\n        {\n            printf(\"%d-->\",temp->data);\n            temp = temp->link;\n        }\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    int data;\n    struct node* left;\n    struct node* right;\n};\nstruct node * root = NULL;\n\nvoid insert(int ele);\nvoid traverse_inorder(struct node* root);\nvoid traverse_preorder(struct node* root);\nvoid traverse_postorder(struct node* root);\nint count_leaves(struct node* root);\nint height(struct node* root);\nint main()\n{\n    while(1)\n    {\n        int choice, ele;\n        printf(\"<--- Operations on BST --->\\n\");\n        printf(\"1. Insertion\\n\");\n        printf(\"2. In order Traversal\\n\");\n        printf(\"3. Pre-order Traversal\\n\");\n        printf(\"4. Post order Traversal\\n\");\n        printf(\"5. Count Leaves\\n\");\n        printf(\"6. Height\\n\");\n        printf(\"7. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            printf(\"Enter an element to insert : \");\n            scanf(\"%d\", &ele);\n            printf(\"%d successfully inserted.\\n\\n\", ele);\n            insert(ele);\n            break;\n        case 2:\n            traverse_inorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 3:\n            traverse_preorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 4:\n            traverse_postorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 5:\n            printf(\"Total Leaf Count : %d\\n\\n\", count_leaves(root));\n            break;\n        case 6:\n            printf(\"Maximum Height : %d\\n\\n\", height(root));\n            break;\n        case 7:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid insert(int ele)\n{\n    struct node* temp, *p, *q;\n    temp = (struct node*)malloc(sizeof(struct node));\n    temp->data = ele;\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        q = root;\n        while(1)\n        {\n            p = q;\n            if(temp->data < p->data)\n            {\n                q = q->left;\n                if(q == NULL)\n                {\n                    p->left = temp;\n                    return;\n                }\n            }\n            else\n            {\n                q = q->right;\n                if(q == NULL)\n                {\n                    p->right = temp;\n                    return;\n                }\n            }\n        }\n    }\n}\n\nvoid traverse_inorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_inorder(root->left);\n        printf(\"%d\\t\", root->data);\n        traverse_inorder(root->right);\n    }\n}\nvoid traverse_preorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        printf(\"%d\\t\", root->data);\n        traverse_preorder(root->left);\n        traverse_preorder(root->right);\n    }\n}\nvoid traverse_postorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_postorder(root->left);\n        traverse_postorder(root->right);\n        printf(\"%d\\t\", root->data);\n    }\n}\n\nint count_leaves(struct node* root)\n{\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else if (root->left == NULL && root->right == NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        return count_leaves(root->left)+count_leaves(root->right);\n    }\n}\n\nint height(struct node* root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        int c1 = height(root->left);\n        int c2 = height(root->right);\n        if(c1>c2)\n        {\n            return c1+1;\n        }\n        else\n        {\n            return c2+1;\n        }\n    }\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <conio.h>\n\nint i, j, k, m = 1, n, a, b;\nint min, mincost = 0, cost[9][9], parent[9];\nint find(int i);\nint uni(int i, int j);\nint main()\n{\n    printf(\"Implementation of Kruskal's Algorithm\\n\");\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n\n    \n    printf(\"\\nEnter the cost adjacency matrix: \\n\");\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j<= n; j++)\n        {\n            scanf(\"%d\", &cost[i][j]);\n            if (i == j)\n            {\n                cost[i][j] = 0;\n            }\n            else if(cost[i][j]==0)\n            {\n                cost[i][j] = 999;\n            }\n        }\n    }\n    \n    printf(\"The Adjacency Matrix is:\\n\");\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n        {\n            printf(\"%d\\t\", cost[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"The edges of Minimum Cost Spanning Tree are: \");\n    while(m < n)\n    {\n        for(i = 1, min = 999; i <= n; i++)\n        {\n            for(j = 1; j <= n; j++)\n            {\n                if(cost[i][j] < min)\n                {\n                    min = cost[i][j];\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n        if(uni(find(a), find(b)))\n        {\n            printf(\"\\n%d. edge (%d, %d) = %d\\n\", m++, a, b, min);\n            mincost += min;\n        }\n        cost[a][b] = cost[b][a] = 999;\n    }\n    printf(\"\\nMinimum Cost = %d\\n\", mincost);\n    return 0;\n}\nint find(int i)\n{\n    while(parent[i])\n        i = parent[i];\n    return i;\n}\nint uni(int i, int j)\n{\n    if(i != j)\n    {\n        parent[j] = i;\n        return 1;\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    \n    int i, ele, loc, n;\n    printf(\"Enter the length of array\\n\");\n    scanf(\"%d\", &n);\n    printf(\"Enter Array Elements\\n\");\n    int arr[50];\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    for(i = 0; i<n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    \n    printf(\"\\n Enter element to inset\\n\");\n    scanf(\"%d\", &ele);\n    printf(\"Enter location to insert\\n\");\n    scanf(\"%d\", &loc);\n    for(i = n-1; i>=loc; i-- )\n    {\n        arr[i+1] = arr[i];\n    }\n    arr[loc] = ele;\n    for(i = 0; i<=n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    \n    int m;\n    printf(\"\\nEnter the position of element to delete\\n\");\n    scanf(\"%d\", &m);\n\n    for(i = m; i<n; i++)\n    {\n        arr[i] = arr[i+1];\n    }\n\n    for(i = 0; i<n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    \n    printf(\"\\nArray in Reverse Order: \\n\");\n    for(i = n-1; i>=0; i--)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <conio.h>\n\nint i, j, k, m = 1, n, a, b;\nint min, mincost = 0, cost[9][9], parent[9];\nint find(int i);\nint uni(int i, int j);\nint main()\n{\n    printf(\"Implementation of Kruskal's Algorithm\\n\");\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n\n    \n    printf(\"\\nEnter the cost adjacency matrix: \\n\");\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j<= n; j++)\n        {\n            scanf(\"%d\", &cost[i][j]);\n            if (i == j)\n            {\n                cost[i][j] = 0;\n            }\n            else if(cost[i][j]==0)\n            {\n                cost[i][j] = 999;\n            }\n        }\n    }\n    \n    printf(\"The Adjacency Matrix is:\\n\");\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n        {\n            printf(\"%d\\t\", cost[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"The edges of Minimum Cost Spanning Tree are: \");\n    while(m < n)\n    {\n        for(i = 1, min = 999; i <= n; i++)\n        {\n            for(j = 1; j <= n; j++)\n            {\n                if(cost[i][j] < min)\n                {\n                    min = cost[i][j];\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n        if(uni(find(a), find(b)))\n        {\n            printf(\"\\n%d. edge (%d, %d) = %d\\n\", m++, a, b, min);\n            mincost += min;\n        }\n        cost[a][b] = cost[b][a] = 999;\n    }\n    printf(\"\\nMinimum Cost = %d\\n\", mincost);\n    return 0;\n}\nint find(int i)\n{\n    while(parent[i])\n        i = parent[i];\n    return i;\n}\nint uni(int i, int j)\n{\n    if(i != j)\n    {\n        parent[j] = i;\n        return 1;\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int arr[10][10], i,j,k, arr2[10][10],arr3[10][10], sum=0;\n\n    \n    printf(\"Read first 3x3 matrix\\n\");\n    for(i = 0; i<3; i++)\n    {\n\n        for(j = 0; j<3; j++)\n        {\n            printf(\"Element - [%d],[%d] : \", i, j);\n            scanf(\"%d\", &arr[i][j]);\n        }\n    }\n    printf(\"The first matrix is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        printf(\"\\n\");\n        for(j = 0; j<3; j++)\n        {\n            printf(\"%d \", arr[i][j]);\n        }\n    }\n\n    \n    printf(\"Read second 3x3 matrix\\n\");\n    for(i = 0; i<3; i++)\n    {\n\n        for(j = 0; j<3; j++)\n        {\n            printf(\"Element - [%d],[%d] : \", i, j);\n            scanf(\"%d\", &arr2[i][j]);\n        }\n    }\n    printf(\"The second matrix is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        printf(\"\\n\");\n        for(j = 0; j<3; j++)\n        {\n            printf(\"%d \", arr2[i][j]);\n        }\n    }\n    printf(\"\\n\");\n\n\n    \n    for(i = 0; i<=2; i++)\n    {\n        for(j=0; j<=2; j++)\n        {\n\n            for(k = 0; k<=2; k++)\n            {\n                sum = sum + arr[i][k] * arr2[k][j];\n            }\n            arr3[i][j] = sum;\n            sum  = 0;\n        }\n    }\n\n    \n    printf(\"The result is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        for(j=0; j<3; j++)\n        {\n\n            printf(\"%d \\t\", arr3[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#define CAPACITY 100\n\n\nint top = -1;\nchar stack[CAPACITY];\n\nvoid push(char item)\n{\n    if(top>= CAPACITY-1)\n    {\n        printf(\"Stack is Full\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = item;\n    }\n}\nchar pop()\n{\n    char item;\n    item = stack[top];\n    top--;\n    return(item);\n}\nint precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '\/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\nint is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '\/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\n\n\nint main()\n{\n    char infix[CAPACITY], postfix[CAPACITY], item, temp;\n    int i = 0, j = 0;\n    printf(\"Enter an Infix Expression to Convert into Postfix : \");\n    gets(infix);\n\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == '(')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            postfix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == ')')\n        {\n            temp = pop();\n            while(temp != '(')\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"\\nInvalid Expression\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        postfix[j] = pop();\n        j++;\n    }\n    printf(\"\\nArithmetic Expression in Postfix form is : \");\n    puts(postfix);\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define CAPACITY 100\n\nint top = -1;\nchar stack[CAPACITY];\n\nvoid push(char item)\n{\n    if(top>= CAPACITY-1)\n    {\n        printf(\"Stack is Full\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = item;\n    }\n}\nchar pop()\n{\n    char item;\n    item = stack[top];\n    top--;\n    return(item);\n}\nint precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '\/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\nint is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '\/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    char infix[CAPACITY], prefix[CAPACITY], tempo[CAPACITY], item, temp;\n    int i = 0, j = 0, k = 0, l = 0;\n    printf(\"Enter an Infix Expression to Convert into Prefix : \");\n    gets(tempo);\n    for(k = strlen(tempo)-1; k>=0; k--)\n    {\n        infix[l] = tempo[k];\n        l++;\n    }\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == ')')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            prefix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                prefix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == '(')\n        {\n            temp = pop();\n            while(temp != ')')\n            {\n                prefix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"Invalid Expression\\n\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        prefix[j] = pop();\n        j++;\n    }\n    printf(\"Arithmetic Expression in Prefix form is : \");\n    for(i = strlen(prefix)-1; i>= 0 ; i--)\n    {\n        printf(\"%c\", prefix[i]);\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#define CAPACITY 50\n\nchar stack[CAPACITY];\nint i, len; count = 0;\nint top = -1;\n\nvoid push(char arg)\n{\n    top++;\n    stack[top] = arg;\n}\nchar pop()\n{\n    char c;\n    c = stack[top];\n    top--;\n    return c;\n}\n\nint main()\n{\n    printf(\"Enter a String to Check\\n\");\n    scanf(\"%s\", stack);\n    len = strlen(stack);\n    \n    for(i = 0; i<len; i++)\n    {\n        push(stack[i]);\n    }\n    for(i = 0; i<len; i++)\n    {\n        if(stack[i]==pop())\n        {\n            count++;\n        }\n    }\n    if(count == len)\n    {\n        printf(\"Given string is Palindrome\\n\");\n    }\n    else\n    {\n        printf(\"Given string is not Palindrome\\n\");\n    }\n    return 0;\n}\n"}
{"target":"rgautam320","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define CAPACITY 50\n\nint top = -1;\nint stack[CAPACITY];\nchar postfix_expression[CAPACITY];\nvoid push(int ch);\nint pop();\nint isEmpty();\nint evaluation();\n\nint main()\n{\n    int final_answer;\n    printf(\"Enter Expression to Evaluate : \\n\");\n    scanf(\"%s\", postfix_expression);\n    final_answer = evaluation();\n    printf(\"Evaluation of Postfix Expression : %d\", final_answer);\n    return 0;\n}\nvoid push(int ch)\n{\n    if(top > CAPACITY)\n    {\n        printf(\"Stack Overflow\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = ch;\n    }\n}\nint pop()\n{\n    if(isEmpty())\n    {\n        printf(\"Stack is Empty\\n\");\n    }\n    else\n    {\n        return stack[top--];\n    }\n}\nint isEmpty()\n{\n    if(top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\nint evaluation()\n{\n    int x, y, temp, value, i;\n    for(i = 0; i<strlen(postfix_expression); i++)\n    {\n        if(postfix_expression[i] <= '9' && postfix_expression[i]>= '0')\n        {\n            push(postfix_expression[i]-'0');\n        }\n        else\n        {\n            x = pop();\n            y = pop();\n            switch(postfix_expression[i])\n            {\n            case '+':\n                temp = y+x;\n                break;\n            case '-':\n                temp = y-x;\n                break;\n            case '*':\n                temp = y*x;\n                break;\n            case '\/':\n                temp = y\/x;\n                break;\n            case '%':\n                temp = y%x;\n                break;\n            case '^':\n                temp = pow(y,x);\n                break;\n            default:\n                printf(\"Invalid\\n\");\n            }\n            push(temp);\n        }\n    }\n    value = pop();\n    return value;\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    int a[90],i,n;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    printf(\"enter the array elements\");\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    sorting(a,n);\n}\nvoid sorting(int a[],int n)\n{\n    int i,j,t;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j]>a[j+1])\n            {\n                t=a[j];\n                a[j]=a[j+1];\n                a[j+1]=t;\n            }\n        }\n\n    }\n    for(i=0;i<n;i++)\n        printf(\"%d\",a[i]);\n\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sumofrows(a,r,c);\n    sumofcolumns(a,r,c);\n\n}\nvoid sumofrows(int a[][90],int r,int c)\n{\n    int i,j,sumofrows;\n    for(i=0;i<r;i++)\n    {\n        sumofrows=0;\n        for(j=0;j<c;j++)\n        {\n            sumofrows=sumofrows+a[i][j];\n        }\n        printf(\"%d\",sumofrows);\n\n    }\n}\nvoid sumofcolumns(int a[][90],int r,int c)\n{\n    int i,j,sumofcolumns;\n    for(i=0;i<r;i++)\n    {\n        sumofcolumns=0;\n        for(j=0;j<c;j++)\n        {\n            sumofcolumns=sumofcolumns+a[j][i];\n        }\n        printf(\"%d\",sumofcolumns);\n    }\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sum(a,r,c);\n}\nvoid sum(int a[][90],int r,int c)\n{\n    int i,j,sum=0;\n    if(r!=c)\n        printf(\"not a square matrix\");\n    else\n    {\n        for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n            {\n                if(j<i)\n                    sum=sum+a[i][j];\n            }\n        }\n    }\n    printf(\"%d\",sum);\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid largest(int a[][90],int ,int);\nvoid main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter ele\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    largest(a,r,c);\n}\nvoid largest(int a[][90],int r,int c)\n{\n    int max=a[0][0],i,j;\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            if(max<a[i][j])\n                max=a[i][j];\n        }\n    }\n    printf(\"%d\",max);\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    int ar[90],n,i;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&ar[i]);\n    largest(ar,n);\n    sumaverage(ar,n);\n    sorting(ar,n);\n}\nvoid largest(int ar[],int n)\n{\n    int max,i;\n    max=ar[0];\n    for(i=0;i<n;i++)\n    {\n        if(max<ar[i])\n            max=ar[i];\n    }\n    printf(\"%d\",max);\n}\nvoid sumaverage(int ar[],int n)\n{\n    int i,sum=0;\n    float avg;\n    for(i=0;i<n;i++)\n        sum=sum+ ar[i];\n        avg=(float)sum\/n;\n    printf(\"%d%f\",sum,avg);\n}\nvoid sorting(int a[],int n)\n{\n    int i,j,t;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j]>a[j+1])\n            {\n                t=a[j];\n                a[j]=a[j+1];\n                a[j+1]=t;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n    printf(\"\\n%d\",a[i]);\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nint compare(char[],char[]);\nvoid main()\n{\n    char str1[90],str2[90];\n    int z;\n    printf(\"enter string1\");\n    gets(str1);\n    printf(\"enter string2\");\n    gets(str2);\n    z=compare(str1,str2);\n    if(z==1)\n        printf(\"equal\");\n    else\n        printf(\"notequal\");\n}\nint compare(char str1[],char str2[])\n{\n    int i=0,j=0,f=0;\n   while(str1[i]==str2[j])\n   {\n       if(str1[i]!='\\0'||str2[j]!='\\0')\n       {\n           f=1;\n           break;\n       }\n       i++;\n       j++;\n   }\n   if(f==1)\n    return 1;\n   else\n    return 0;\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid sumofdigits(void);\nvoid sumofseries(void);\nvoid perfectno(void);\nvoid exit(void);\nvoid main()\n{\n    char option;\n    printf (\"choose the option\");\n    scanf(\"%c\",&option);\n    switch(option)\n    {\n    case'A':\n        sumofdigits();\n        break;\n    case'B':\n        perfectno();\n        break;\n    case'C':\n        sumofseries();\n        break;\n    case'D':\n        exit();\n        break;\n    }\n}\nvoid sumofdigits(void)\n{\n    int n,sum=0,d;\n    printf(\"enter a number\");\n    scanf(\"%d\",&n);\n    while(n>0)\n    {\n        d=n%10;\n        sum+=d;\n        n=n\/10;\n    }\n    printf(\"%d\",sum);\n}\nvoid sumofseries(void)\n{\n    int n,i,sum=0;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i=i+2)\n    {\n        sum+=i;\n    }\n    printf(\"%d\",sum);\n}\n\nvoid perfectno(void)\n{\n\n    int i,sum=0,r;\n    printf(\"enter the number\");\n    scanf(\"%d\",&r);\n   for(i=1;i<=r\/2;i++)\n   {\n       if(r%i==0)\n        sum+=i;\n\n   }\n   if(sum==r)\n   printf(\"perfect no.\");\n   else\n    printf(\"not\");\n\n}\n\nvoid exit(void)\n{\n    return;\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n\n}\nvoid sumofrows(int b[][90],int r,int c)\n{\n    int sum=0,i,j;\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            sum=sum+b[i][j];\n        }\n        printf(\"hggh\");\n        printf(\"%d\",sum);\n    }\n\n}\n"}
{"target":"ria3999","func":"#include <stdio.h>\n#include <conio.h>\nchar square[10] = { 'o', '1', '2', '3', '4', '5', '6', '7', '8', '9' };\nint checkwin();\nvoid board();\nint main()\n{\n    int player = 1, i, choice;\n    char mark;\n    do\n    {\n        board();\n        player = (player % 2) ? 1 : 2;\n        printf(\"Player %d, enter a number:  \", player);\n        scanf(\"%d\", &choice);\n        mark = (player == 1) ? 'X' : 'O';\n        if (choice == 1 && square[1] == '1')\n            square[1] = mark;\n        else if (choice == 2 && square[2] == '2')\n            square[2] = mark;\n        else if (choice == 3 && square[3] == '3')\n            square[3] = mark;\n        else if (choice == 4 && square[4] == '4')\n            square[4] = mark;\n        else if (choice == 5 && square[5] == '5')\n            square[5] = mark;\n        else if (choice == 6 && square[6] == '6')\n            square[6] = mark;\n        else if (choice == 7 && square[7] == '7')\n            square[7] = mark;\n        else if (choice == 8 && square[8] == '8')\n            square[8] = mark;\n        else if (choice == 9 && square[9] == '9')\n            square[9] = mark;\n        else\n        {\n            printf(\"Invalid move \");\n            player--;\n            getch();\n        }\n        i = checkwin();\n        player++;\n    }while (i ==  - 1);\n    board();\n    if (i == 1)\n        printf(\"==>\\aPlayer %d win \", --player);\n    else\n        printf(\"==>\\aGame draw\");\n    getch();\n    return 0;\n}\n\nint checkwin()\n{\n    if (square[1] == square[2] && square[2] == square[3])\n        return 1;\n    else if (square[4] == square[5] && square[5] == square[6])\n        return 1;\n    else if (square[7] == square[8] && square[8] == square[9])\n        return 1;\n    else if (square[1] == square[4] && square[4] == square[7])\n        return 1;\n    else if (square[2] == square[5] && square[5] == square[8])\n        return 1;\n    else if (square[3] == square[6] && square[6] == square[9])\n        return 1;\n    else if (square[1] == square[5] && square[5] == square[9])\n        return 1;\n    else if (square[3] == square[5] && square[5] == square[7])\n        return 1;\n    else if (square[1] != '1' && square[2] != '2' && square[3] != '3' &&\n        square[4] != '4' && square[5] != '5' && square[6] != '6' && square[7]\n        != '7' && square[8] != '8' && square[9] != '9')\n        return 0;\n    else\n        return  - 1;\n}\nvoid board()\n{\n\n    printf(\"\\n\\n\\tTic Tac Toe\\n\\n\");\n    printf(\"Player 1 (X)  -  Player 2 (O)\\n\\n\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[1], square[2], square[3]);\n    printf(\"__|_|__\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[4], square[5], square[6]);\n    printf(\"__|_|__\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[7], square[8], square[9]);\n    printf(\"     |     |     \\n\\n\");\n}\n\n"}
{"target":"ria3999","func":"# include<stdio.h>\n# include<math.h>\nfloat function(float);\nvoid main()\n{\n    float a,b,fa,fb,c,fc;\n    do\n    {\n        printf(\"Enter interval\\n\");\n        scanf(\"%f%f\",&a,&b);\n        fa=function(a);\n        printf(\"Value of fa=%f\\n\",fa);\n        fb=function(b);\n        printf(\"Value of fb=%f\\n\",fb);\n    }while(fa*fb>0);\n    printf(\"next loop\");\n    do\n    {\n        c=(a+b)\/2.0;\n        printf(\"c is now=%f\\n\",c);\n        fa=function(a);\n        fb=function(c);\n        printf(\"fb becomes=%f\\n\",fb);\n        if(fa*fb<0)\n            b=c;\n        else\n            a=c;\n        printf(\"fabs=%f\",fabs(fb));\n    }while(fabs(fb)>=0.0001);\n    printf(\"The root is %f\",c);\n}\nfloat function(float x)\n{\n    float f;\n    f=x+cos(x);\n    return(f);\n}\n"}
{"target":"ria3999","func":"#include<stdio.h>\nint main()\n{\n    int m,i,j;\n    float Y[20][20]={0},x,res=1.0,sum=0;\n    printf(\"\\n\\n\\t\\t\\t\\t***INPUT*\");\n    printf(\"\\nEnter the limit:\");\n    scanf(\"%d\",&m);\n    printf(\"\\nEnter the elements of x and y:\");\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<2;j++)\n            scanf(\"%f\",&Y[i][j]);\n    }\n    printf(\"\\nThe table entered is:\\n\");\n     for(i=0;i<m;i++)\n    {\n        for(j=0;j<2;j++)\n            printf(\"%0.3f  \",Y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\nEnter the value of x to find y:\");\n    scanf(\"%f\",&x);\n    printf(\"\\n\\n\\t\\t\\t\\t***OUTPUT*\\n\");\n    for(i=0;i<m;i++)\n    {\n        res=1.0;\n        for(j=0;j<m;j++)\n        {\n            if(j!=i)\n                res*=((x-Y[j][0])*1.0)\/(Y[i][0]-Y[j][0]);\n            else\n                continue;\n        }\n        sum+=res*Y[i][1];\n    }\n    printf(\"The value of y at x=%0.3f is %0.3f\",x,sum);\n}\n"}
{"target":"ria3999","func":"#include <stdio.h>\n\nfloat u_cal(float u, int n)\n{\n    float temp = u;\n    for (int i = 1; i < n; i++)\n        temp = temp * (u + i);\n    return temp;\n}\nint fact(int n)\n{\n    int f = 1;\n    for (int i = 2; i <= n; i++)\n        f *= i;\n    return f;\n}\n\nint main()\n{\n    int n,i,j;\n    float x[90],value,sum=0;\n    float y[90][90];\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter n\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter value of x:\\n\");\n    for(i=0;i<n;i++)\n        scanf(\"%f\",&x[i]);\n    printf(\"Enter value of y:\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<1;j++)\n        {\n            printf(\"Enter y[%d][%d] \",i,j);\n            scanf(\"%f\",&y[i][j]);\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = n - 1; j >= i; j--)\n            y[j][i] = y[j][i - 1] - y[j - 1][i - 1];\n    }\n    printf(\"Backward difference table:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++)\n            printf(\"%.2f \",y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"Enter value of which you want the answer:\\n\");\n    scanf(\"%f\",&value);\n    sum = y[n - 1][0];\n    float u = (value - x[n - 1]) \/ (x[1] - x[0]);\n    for (int i = 1; i < n; i++) {\n        sum = sum + (u_cal(u, i) * y[n - 1][i]) \/\n                                     fact(i);\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"\\n Value at %f is %f\",value,sum);\n    return 0;\n}\n"}
{"target":"ria3999","func":"#include <stdio.h>\nfloat cal(float u, int n)\n{\n    float temp = u;\n    for (int i = 1; i < n; i++)\n        temp = temp * (u - i);\n    return temp;\n}\nint fact(int n)\n{\n    int f = 1;\n    for (int i = 2; i <= n; i++)\n        f *= i;\n    return f;\n}\nint main()\n{\n    int n,i,j,u;\n    float x[90],value;\n    float y[90][90],sum=0;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter n:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the values of x\\n\");\n    for(i=0;i<n;i++)\n        scanf(\"%f\",&x[i]);\n    printf(\"Enter the values of y\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<1;j++)\n        {\n            scanf(\"%f\",&y[i][j]);\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        for (int j = 0; j < n - i; j++)\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1];\n    }\n    printf(\"forward difference table is:\\n\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%f \",x[i]);\n        for (int j = 0; j < n - i; j++)\n            printf(\"%f \",y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"Enter value:\\n\");\n    scanf(\"%f\",&value);\n    sum = y[0][0];\n    u = (value - x[0]) \/ (x[1] - x[0]);\n    for (int i = 1; i < n; i++) {\n        sum = sum + (cal(u, i) * y[0][i]) \/\n                                 fact(i);\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Value at %f is %f\",value,sum);\n    return 0;\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nvoid main()\n{\n    float a,b,c,d,x1,x2,realpart,imaginarypart;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"enter coefficients a,b and c \\n\");\n    scanf(\"%f%f%f\",&a,&b,&c);\n    d=b*b-4*a*c;\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    if(d>0)\n    {\n        x1=(-b+sqrt(d))\/(2*a);\n        x2=(-b-sqrt(d))\/(2*a);\n        printf(\"root1 is %f and root2 is %f\",x1,x2);\n    }\n    else if(d==0)\n    {\n        x2=(-b)\/(2*a);\n        x1=x2;\n        printf(\"equal roots are %f and %f\",x1,x2);\n    }\n    else\n    {\n        realpart=-b\/(2*a);\n        imaginarypart=sqrt(-d)\/(2*a);\n        printf(\"root1=%f+i%f & root2=%f-i%f\",realpart,imaginarypart,realpart,imaginarypart);\n\n    }\n\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nfloat func(float x,float y)\n{\n    return ((x-y)\/(x+y));\n}\nint main()\n{\n    int i,n;\n    float x0,y0,h,xn,k1,k2,k3,k4,x,y,k;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter x0,y0,h,xn:\\n\");\n    scanf(\"%f%f%f%f\",&x0,&y0,&h,&xn);\n    n=(xn-x0)\/h;\n    x=x0;\n    y=y0;\n    for(i=0;i<=n;i++)\n    {\n        k1=h*func(x,y);\n        k2=h*func(x+(h\/2),y+(k1\/2));\n        k3=h*func(x+(h\/2),y+(k2\/2));\n        k4=h*func(x+h,y+k3);\n        k=(k1+2*(k2+k3)+k4)\/6.0;\n        x=x+h;\n        y=y+k;\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Result is:\\n\");\n    printf(\"x=%f y=%f\",x,y);\n    return 0;\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nfloat function(float x)\n{\n    return(2*x-log10(x)-7);\n}\nvoid main()\n{\n    float a,b,fa,fb,c,fc;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    do\n    {\n        printf(\"Enter intervals a and b\");\n        \n        scanf(\"%f%f\",&a,&b);\n        fa=function(a);\n        fb=function(b);\n    }while(fa*fb>0);\n    int i=-1;\n    float d=-1;\n    do\n    {\n        i++;\n        if(i!=0)\n        d=c;\n        fa=function(a);\n        fb=function(b);\n        c=a-((b-a)\/(function(b)-function(a)))*function(a);\n        fc=function(c);\n        if(fa*fc>0)\n            a=c;\n        else\n            b=c;\n    }while(d!=c);\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"The required root is %f \\n\",c);\n}\n"}
{"target":"ria3999","func":"# include<stdio.h>\nfloat fun(float x)\n{\n    float temp;\n    temp=1\/(1+(x*x));\n    return temp;\n}\nint main()\n{\n    float x0,xn;\n    int n;\n    float h,s=0,sume=0,sumo=0;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter value of n\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter x0 and xn\\n\");\n    scanf(\"%f%f\",&x0,&xn);\n    h=(xn-x0)\/n;\n    s=fun(x0)+fun(xn);\n    for(int i=1;i<n;i++)\n    {\n        if(i%2==0)\n            s=s+2*fun(x0+i*h);\n        else\n            s=s+4*fun(x0+i*h);\n    }\n    s=s*h\/3;\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Result is %f\",s);\n    return 0;\n}\n"}
{"target":"RobertoBenjami","func":"\n\n\n\n\n#pragma config FOSFPR = ECIO            \n#pragma config FCKSMEN = CSW_FSCM_OFF   \n\n\n#pragma config FWPSB = WDTPSB_16        \n#pragma config FWPSA = WDTPSA_512       \n#pragma config WDT = WDT_OFF            \n\n\n#pragma config FPWRT = PWRT_64          \n#pragma config BODENV = BORV20          \n#pragma config BOREN = PBOR_ON          \n#pragma config MCLRE = MCLR_EN          \n\n\n#pragma config GWRP = GWRP_OFF          \n#pragma config GCP = CODE_PROT_OFF      \n\n\n#pragma config ICS = ICS_PGD            \n\n\n\n\n#include <xc.h>\n"}
{"target":"RobertoBenjami","func":"\n\n#include <string.h>\n#include <stdlib.h>\n#include \"main.h\"\n#include \"charlcd.h\"\n\n\n#define TIMEBASE              200\n\n\n#ifdef  osCMSIS\n#define Delay(t)              osDelay(t)\n#define GetTime()             osKernelSysTick()\n#else\n#define Delay(t)              HAL_Delay(t)\n#define GetTime()             HAL_GetTick()\n#endif\n\n\n#ifdef osCMSIS\nvoid StartDefaultTask(void const * argument)\n#else\nvoid mainApp(void)\n#endif\n{\n  static uint32_t cycle;\n  uint32_t lastmsec = 0, t, ca = 0, cycle1 = 0, cycle2 = 0, c;\n\n  LcdInit();                            \n  #if (1UL * LCD_WIDTH * LCD_LINES) < 80\n  \n  #if LCD_BLINKCHAR == 1\n  for(c = 24; c < 32; c++)\n    LcdBlinkChar(c);\n  #endif \n  #else  \n  \n  memcpy((char *)LcdText +   0, \"****************************************\", 40);\n  memcpy((char *)LcdText +  40, \"*          LCD CPU used meter          *\", 40);\n  memcpy((char *)LcdText +  80, \"*                                      *\", 40);\n  memcpy((char *)LcdText + 120, \"****************************************\", 40);\n  #if LCD_BLINKCHAR == 1\n  for(c = 41; c < 78; c++)\n    LcdBlinkChar(c);\n  #endif \n  #endif \n\n  while(1)\n  {\n    t = GetTime();\n\n    if(lastmsec + TIMEBASE <= t)\n    {\n\n      if(!ca)\n      {\n        LcdRefreshStop();\n        cycle1 = cycle;\n        cycle = 0;\n      }\n      else\n      {\n        LcdRefreshStart();\n        cycle2 = cycle;\n        cycle = 0;\n      }\n      ca = 1 - ca;\n\n      if(cycle1 && cycle2)\n      {\n        \n        #if (1UL * LCD_WIDTH * LCD_LINES) < 80\n        \n        memcpy((char *)LcdText, \"                                \", 32);\n        utoa(cycle1,  (char *)LcdText +  0, 10);\n        utoa(cycle2,  (char *)LcdText +  8, 10);\n        utoa(100 - (201 * cycle1 \/ (2 * cycle2)), (char *)LcdText + 16, 10);\n        #else  \n        \n        \n        memcpy((char *)LcdText +  80, \"*With:        Without:              %  *\", 40);\n        utoa(cycle1,  (char *)LcdText +  86, 10);\n        utoa(cycle2,  (char *)LcdText + 102, 10);\n        utoa(100 - (201 * cycle1 \/ (2 * cycle2)), (char *)LcdText + 113, 10);\n        #endif \n      }\n\n      lastmsec = GetTime();\n    }\n    cycle++;\n  }\n}\n"}
{"target":"RobertoBenjami","func":"\n\n#include <string.h>\n#include <stdlib.h>\n#include \"main.h\"\n#include \"charlcd.h\"\n\n\n#ifdef  osCMSIS\n#define Delay(t)              osDelay(t)\n#define GetTime()             osKernelSysTick()\n#else\n#define Delay(t)              HAL_Delay(t)\n#define GetTime()             HAL_GetTick()\n#endif\n\n\n#ifdef osCMSIS\nvoid StartDefaultTask(void const * argument)\n#else\nvoid mainApp(void)\n#endif\n{\n  LcdInit();                            \n  memcpy((char *)LcdText, \"   Hello world                  \", 32);\n  #if LCD_MODE == 1 || LCD_MODE == 2 || LCD_MODE == 3\n  LcdRefreshAll();\n  #endif\n  while(1)\n  {\n    #if LCD_MODE == 4\n    LcdProcess();\n    #endif\n  }\n}\n"}
{"target":"RobertoBenjami","func":"\n\n#include <string.h>\n#include <stdlib.h>\n#include \"main.h\"\n#include \"charlcd.h\"\n\n\n#define TIMEBASE              1000\n\n#if LCD_MODE != 1\n#error LCD MODE is wrong setting !\n#endif\n\n\n#ifdef  osCMSIS\n#define Delay(t)              osDelay(t)\n#define GetTime()             osKernelSysTick()\n#else\n#define Delay(t)              HAL_Delay(t)\n#define GetTime()             HAL_GetTick()\n#endif\n\n#if (1UL * LCD_WIDTH * LCD_LINES < 80)\n#define  FPSPOZ     0\n#define  CPSPOZ     16\n#else  \n#define  FPSPOZ     82\n#define  CPSPOZ     98\n#endif \n\n\n#ifdef osCMSIS\nvoid StartDefaultTask(void const * argument)\n#else\nvoid mainApp(void)\n#endif\n{\n  uint32_t lastmsec = 0, t1, t2, res, cycle = 0;\n\n  LcdInit();                            \n  #if (1UL * LCD_WIDTH * LCD_LINES) < 80\n  \n  #else  \n  \n  memcpy((char *)LcdText +   0, \"****************************************\", 40);\n  memcpy((char *)LcdText +  40, \"*            LCD speed meter           *\", 40);\n  memcpy((char *)LcdText +  80, \"*                                      *\", 40);\n  memcpy((char *)LcdText + 120, \"****************************************\", 40);\n  #endif \n\n  while(1)\n  {\n    LcdRefreshAll();\n    cycle++;                            \n\n    t1 = GetTime();\n    if(lastmsec + TIMEBASE <= t1)\n    {\n      t2 = GetTime();\n      memcpy((char *)LcdText + FPSPOZ, \"FPS:      \", 10);\n      memcpy((char *)LcdText + CPSPOZ, \"CPS:      \", 10);\n      res = cycle * 1000 \/ (t2 - lastmsec);\n      utoa(res, (char *)LcdText +  FPSPOZ + 4, 10);\n      utoa(res * (1UL * LCD_LINES * (LCD_WIDTH + 1)), (char *)LcdText +  CPSPOZ + 4, 10);\n      lastmsec = GetTime();\n      cycle = 0;\n    }\n  }\n}\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f1xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_MODULE_ENABLED\n\n\n\n\n\n\n#define __STM32F1xx_HAL_VERSION_MAIN   (0x01U) \n#define __STM32F1xx_HAL_VERSION_SUB1   (0x01U) \n#define __STM32F1xx_HAL_VERSION_SUB2   (0x02U) \n#define __STM32F1xx_HAL_VERSION_RC     (0x00U) \n#define __STM32F1xx_HAL_VERSION         ((__STM32F1xx_HAL_VERSION_MAIN << 24)\\\n                                        |(__STM32F1xx_HAL_VERSION_SUB1 << 16)\\\n                                        |(__STM32F1xx_HAL_VERSION_SUB2 << 8 )\\\n                                        |(__STM32F1xx_HAL_VERSION_RC))\n\n#define IDCODE_DEVID_MASK    0x00000FFFU\n\n\n\n\n\n\n\n__IO uint32_t uwTick;\nuint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); \nHAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  \n\n\n\n\n\n\n\n\n\nHAL_StatusTypeDef HAL_Init(void)\n{\n  \n#if (PREFETCH_ENABLE != 0)\n#if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \\\n    defined(STM32F102x6) || defined(STM32F102xB) || \\\n    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \\\n    defined(STM32F105xC) || defined(STM32F107xC)\n\n  \n  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();\n#endif\n#endif \n\n  \n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n\n  \n  HAL_InitTick(TICK_INT_PRIORITY);\n\n  \n  HAL_MspInit();\n\n  \n  return HAL_OK;\n}\n\n\nHAL_StatusTypeDef HAL_DeInit(void)\n{\n  \n  __HAL_RCC_APB1_FORCE_RESET();\n  __HAL_RCC_APB1_RELEASE_RESET();\n\n  __HAL_RCC_APB2_FORCE_RESET();\n  __HAL_RCC_APB2_RELEASE_RESET();\n\n#if defined(STM32F105xC) || defined(STM32F107xC)\n  __HAL_RCC_AHB_FORCE_RESET();\n  __HAL_RCC_AHB_RELEASE_RESET();\n#endif\n\n  \n  HAL_MspDeInit();\n\n  \n  return HAL_OK;\n}\n\n\n__weak void HAL_MspInit(void)\n{\n  \n}\n\n\n__weak void HAL_MspDeInit(void)\n{\n  \n}\n\n\n__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n{\n  \n  if (HAL_SYSTICK_Config(SystemCoreClock \/ (1000U \/ uwTickFreq)) > 0U)\n  {\n    return HAL_ERROR;\n  }\n\n  \n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\n  {\n    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);\n    uwTickPrio = TickPriority;\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n\n  \n  return HAL_OK;\n}\n\n\n\n\n\n\n__weak void HAL_IncTick(void)\n{\n  uwTick += uwTickFreq;\n}\n\n\n__weak uint32_t HAL_GetTick(void)\n{\n  return uwTick;\n}\n\n\nuint32_t HAL_GetTickPrio(void)\n{\n  return uwTickPrio;\n}\n\n\nHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n\n    \n    status = HAL_InitTick(uwTickPrio);\n  }\n\n  return status;\n}\n\n\nHAL_TickFreqTypeDef HAL_GetTickFreq(void)\n{\n  return uwTickFreq;\n}\n\n\n__weak void HAL_Delay(uint32_t Delay)\n{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n\n  \n  if (wait < HAL_MAX_DELAY)\n  {\n    wait += (uint32_t)(uwTickFreq);\n  }\n\n  while ((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}\n\n\n__weak void HAL_SuspendTick(void)\n{\n  \n  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);\n}\n\n\n__weak void HAL_ResumeTick(void)\n{\n  \n  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);\n}\n\n\nuint32_t HAL_GetHalVersion(void)\n{\n  return __STM32F1xx_HAL_VERSION;\n}\n\n\nuint32_t HAL_GetREVID(void)\n{\n  return ((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);\n}\n\n\nuint32_t HAL_GetDEVID(void)\n{\n  return ((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGSleepMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGSleepMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGStopMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGStopMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGStandbyMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGStandbyMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\n}\n\n\nvoid HAL_GetUID(uint32_t *UID)\n{\n  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));\n  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\n  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\n}\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f1xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_CORTEX_MODULE_ENABLED\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n{\n  \n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n  \n  \n  NVIC_SetPriorityGrouping(PriorityGroup);\n}\n\n\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  \n  \n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  \n  prioritygroup = NVIC_GetPriorityGrouping();\n  \n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}\n\n\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n\n  \n  NVIC_EnableIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n\n  \n  NVIC_DisableIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_SystemReset(void)\n{\n  \n  NVIC_SystemReset();\n}\n\n\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n{\n   return SysTick_Config(TicksNumb);\n}\n\n\n\n\n#if (__MPU_PRESENT == 1U)\n\nvoid HAL_MPU_Disable(void)\n{\n  \n  __DMB();\n\n  \n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\n  \n  \n  MPU->CTRL = 0U;\n}\n\n\nvoid HAL_MPU_Enable(uint32_t MPU_Control)\n{\n  \n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\n  \n  \n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\n  \n  \n  __DSB();\n  __ISB();\n}\n\n\nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\n{\n  \n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\n\n  \n  MPU->RNR = MPU_Init->Number;\n\n  if ((MPU_Init->Enable) != RESET)\n  {\n    \n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\n    \n    MPU->RBAR = MPU_Init->BaseAddress;\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\n  }\n  else\n  {\n    MPU->RBAR = 0x00U;\n    MPU->RASR = 0x00U;\n  }\n}\n#endif \n\n\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\n{\n  \n  return NVIC_GetPriorityGrouping();\n}\n\n\nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\n{\n  \n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n \n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\n}\n\n\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  NVIC_SetPendingIRQ(IRQn);\n}\n\n\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n\n  \n  return NVIC_GetPendingIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n\n  \n  NVIC_ClearPendingIRQ(IRQn);\n}\n\n\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n\n  \n  return NVIC_GetActive(IRQn);\n}\n\n\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n{\n  \n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\n  {\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\n  }\n}\n\n\nvoid HAL_SYSTICK_IRQHandler(void)\n{\n  HAL_SYSTICK_Callback();\n}\n\n\n__weak void HAL_SYSTICK_Callback(void)\n{\n  \n}\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f1xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_GPIO_MODULE_ENABLED\n\n\n\n\n#define GPIO_MODE             0x00000003U\n#define EXTI_MODE             0x10000000U\n#define GPIO_MODE_IT          0x00010000U\n#define GPIO_MODE_EVT         0x00020000U\n#define RISING_EDGE           0x00100000U\n#define FALLING_EDGE          0x00200000U\n#define GPIO_OUTPUT_TYPE      0x00000010U\n\n#define GPIO_NUMBER           16U\n\n\n#define  GPIO_CR_MODE_INPUT         0x00000000U \n#define  GPIO_CR_CNF_ANALOG         0x00000000U \n#define  GPIO_CR_CNF_INPUT_FLOATING 0x00000004U \n#define  GPIO_CR_CNF_INPUT_PU_PD    0x00000008U \n#define  GPIO_CR_CNF_GP_OUTPUT_PP   0x00000000U \n#define  GPIO_CR_CNF_GP_OUTPUT_OD   0x00000004U \n#define  GPIO_CR_CNF_AF_OUTPUT_PP   0x00000008U \n#define  GPIO_CR_CNF_AF_OUTPUT_OD   0x0000000CU \n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t temp = 0x00U;\n  uint32_t config = 0x00U;\n  __IO uint32_t *configregister; \n  uint32_t registeroffset = 0U; \n\n  \n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\n\n  \n  for (position = 0U; position < GPIO_NUMBER; position++)\n  {\n    \n    ioposition = (0x01U << position);\n\n    \n    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;\n\n    if (iocurrent == ioposition)\n    {\n      \n      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));\n\n      \n      switch (GPIO_Init->Mode)\n      {\n        \n        case GPIO_MODE_OUTPUT_PP:\n          \n          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;\n          break;\n\n        \n        case GPIO_MODE_OUTPUT_OD:\n          \n          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;\n          break;\n\n        \n        case GPIO_MODE_AF_PP:\n          \n          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;\n          break;\n\n        \n        case GPIO_MODE_AF_OD:\n          \n          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;\n          break;\n\n        \n        case GPIO_MODE_INPUT:\n        case GPIO_MODE_IT_RISING:\n        case GPIO_MODE_IT_FALLING:\n        case GPIO_MODE_IT_RISING_FALLING:\n        case GPIO_MODE_EVT_RISING:\n        case GPIO_MODE_EVT_FALLING:\n        case GPIO_MODE_EVT_RISING_FALLING:\n          \n          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\n          if (GPIO_Init->Pull == GPIO_NOPULL)\n          {\n            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;\n          }\n          else if (GPIO_Init->Pull == GPIO_PULLUP)\n          {\n            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;\n\n            \n            GPIOx->BSRR = ioposition;\n          }\n          else \n          {\n            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;\n\n            \n            GPIOx->BRR = ioposition;\n          }\n          break;\n\n        \n        case GPIO_MODE_ANALOG:\n          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;\n          break;\n\n        \n        default:\n          break;\n      }\n\n      \n      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;\n      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);\n\n      \n      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));\n\n      \n      \n      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)\n      {\n        \n        __HAL_RCC_AFIO_CLK_ENABLE();\n        temp = AFIO->EXTICR[position >> 2U];\n        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));\n        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));\n        AFIO->EXTICR[position >> 2U] = temp;\n\n\n        \n        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)\n        {\n          SET_BIT(EXTI->IMR, iocurrent);\n        }\n        else\n        {\n          CLEAR_BIT(EXTI->IMR, iocurrent);\n        }\n\n        \n        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)\n        {\n          SET_BIT(EXTI->EMR, iocurrent);\n        }\n        else\n        {\n          CLEAR_BIT(EXTI->EMR, iocurrent);\n        }\n\n        \n        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)\n        {\n          SET_BIT(EXTI->RTSR, iocurrent);\n        }\n        else\n        {\n          CLEAR_BIT(EXTI->RTSR, iocurrent);\n        }\n\n        \n        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)\n        {\n          SET_BIT(EXTI->FTSR, iocurrent);\n        }\n        else\n        {\n          CLEAR_BIT(EXTI->FTSR, iocurrent);\n        }\n      }\n    }\n  }\n}\n\n\nvoid HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\n{\n  uint32_t position = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t tmp = 0x00U;\n  __IO uint32_t *configregister; \n  uint32_t registeroffset = 0U;\n\n  \n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  \n  while ((GPIO_Pin >> position) != 0U)\n  {\n    \n    iocurrent = (GPIO_Pin) & (1U << position);\n\n    if (iocurrent)\n    {\n      \n      \n      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;\n      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);\n\n      \n      MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);\n\n      \n      CLEAR_BIT(GPIOx->ODR, iocurrent);\n\n      \n      \n\n      tmp = AFIO->EXTICR[position >> 2U];\n      tmp &= 0x0FU << (4U * (position & 0x03U));\n      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))\n      {\n        tmp = 0x0FU << (4U * (position & 0x03U));\n        CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);\n\n        \n        CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);\n        CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);\n\n        \n        CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);\n        CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);\n      }\n    }\n\n    position++;\n  }\n}\n\n\n\n\n\n\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\n{\n  GPIO_PinState bitstatus;\n\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\n  {\n    bitstatus = GPIO_PIN_SET;\n  }\n  else\n  {\n    bitstatus = GPIO_PIN_RESET;\n  }\n  return bitstatus;\n}\n\n\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n\n  if (PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}\n\n\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\n{\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  GPIOx->ODR ^= GPIO_Pin;\n}\n\n\nHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\n{\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\n\n  \n  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  \n  SET_BIT(tmp, GPIO_Pin);\n  \n  GPIOx->LCKR = tmp;\n  \n  GPIOx->LCKR = GPIO_Pin;\n  \n  GPIOx->LCKR = tmp;\n  \n  tmp = GPIOx->LCKR;\n\n  if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))\n  {\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n}\n\n\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n{\n  \n  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)\n  {\n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n}\n\n\n__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n  \n  UNUSED(GPIO_Pin);\n  \n}\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f1xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_GPIO_MODULE_ENABLED\n\n\n\n\n\n\nvoid HAL_GPIOEx_ConfigEventout(uint32_t GPIO_PortSource, uint32_t GPIO_PinSource)\n{\n  \n  assert_param(IS_AFIO_EVENTOUT_PORT(GPIO_PortSource));\n  assert_param(IS_AFIO_EVENTOUT_PIN(GPIO_PinSource));\n\n  \n  MODIFY_REG(AFIO->EVCR, (AFIO_EVCR_PORT) | (AFIO_EVCR_PIN), (GPIO_PortSource) | (GPIO_PinSource));\n}\n\n\nvoid HAL_GPIOEx_EnableEventout(void)\n{\n  SET_BIT(AFIO->EVCR, AFIO_EVCR_EVOE);\n}\n\n\nvoid HAL_GPIOEx_DisableEventout(void)\n{\n  CLEAR_BIT(AFIO->EVCR, AFIO_EVCR_EVOE);\n}\n\n\n\n\n\n#endif \n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n#include \"stm32f1xx_hal.h\"\nextern void _Error_Handler(char *, int);\n\n\n\n\nvoid HAL_MspInit(void)\n{\n  \n\n  \n\n  __HAL_RCC_AFIO_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n\n  \n  \n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n\n    \n  __HAL_AFIO_REMAP_SWJ_NOJTAG();\n\n  \n\n  \n}\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f1xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_PWR_MODULE_ENABLED\n\n\n\n\n\n  \n \n#define PVD_MODE_IT               0x00010000U\n#define PVD_MODE_EVT              0x00020000U\n#define PVD_RISING_EDGE           0x00000001U\n#define PVD_FALLING_EDGE          0x00000002U\n\n\n\n \n\n#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)\n#define PWR_CR_OFFSET            0x00U\n#define PWR_CSR_OFFSET           0x04U\n#define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)\n#define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)\n\n   \n  \n\n\n#define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos\n#define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BIT_NUMBER * 4U)))\n\n\n#define DBP_BIT_NUMBER            PWR_CR_DBP_Pos\n#define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_NUMBER * 4U)))\n\n\n#define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos\n#define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_NUMBER * 4U)))\n\n\n\n\n\n\n\n#define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION_VAL(VAL) * 4U)))\n\n  \n\n\n\n\n\nstatic void PWR_OverloadWfe(void);\n\n\n__NOINLINE\nstatic void PWR_OverloadWfe(void)\n{\n  __asm volatile( \"wfe\" );\n  __asm volatile( \"nop\" );\n}\n\n\n\n\n\n\n\n\n\nvoid HAL_PWR_DeInit(void)\n{\n  __HAL_RCC_PWR_FORCE_RESET();\n  __HAL_RCC_PWR_RELEASE_RESET();\n}\n\n\nvoid HAL_PWR_EnableBkUpAccess(void)\n{\n  \n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWR_DisableBkUpAccess(void)\n{\n  \n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;\n}\n\n\n\n\n\n\nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\n{\n  \n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\n\n  \n  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);\n  \n  \n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\n\n  \n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\n  }\n  \n  \n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\n  }\n  \n  \n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\n  }\n  \n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\n  }\n}\n\n\nvoid HAL_PWR_EnablePVD(void)\n{\n  \n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWR_DisablePVD(void)\n{\n  \n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)\n{\n  \n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\n  \n  *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)\n{\n  \n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\n  \n  *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\n{\n  \n  \n  \n  UNUSED(Regulator);\n\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\n\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n\n  \n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\n  {\n    \n    __WFI();\n  }\n  else\n  {\n    \n    __SEV();\n    __WFE();\n    __WFE();\n  }\n}\n\n\nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  \n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n\n   \n  CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);\n\n  \n  MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);\n\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n\n  \n  if(STOPEntry == PWR_STOPENTRY_WFI)\n  {\n    \n    __WFI();\n  }\n  else\n  {\n    \n    __SEV();\n    PWR_OverloadWfe(); \n    PWR_OverloadWfe(); \n  }\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n}\n\n\nvoid HAL_PWR_EnterSTANDBYMode(void)\n{\n  \n  SET_BIT(PWR->CR, PWR_CR_PDDS);\n\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n\n  \n#if defined ( __CC_ARM)\n  __force_stores();\n#endif\n  \n  __WFI();\n}\n\n\n\nvoid HAL_PWR_EnableSleepOnExit(void)\n{\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\n}\n\n\n\nvoid HAL_PWR_DisableSleepOnExit(void)\n{\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\n}\n\n\n\nvoid HAL_PWR_EnableSEVOnPend(void)\n{\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\n}\n\n\n\nvoid HAL_PWR_DisableSEVOnPend(void)\n{\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\n}\n\n\n\n\nvoid HAL_PWR_PVD_IRQHandler(void)\n{\n  \n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)\n  {\n    \n    HAL_PWR_PVDCallback();\n\n    \n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\n  }\n}\n\n\n__weak void HAL_PWR_PVDCallback(void)\n{\n   \n}\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n#include \"stm32f1xx_hal.h\"\n#include \"stm32f1xx.h\"\n#include \"stm32f1xx_it.h\"\n\n\n\n\n\n\n\n\n \n\n\n\nvoid NMI_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid HardFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid MemManage_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid BusFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid UsageFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid SVC_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid DebugMon_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid PendSV_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid SysTick_Handler(void)\n{\n  \n\n  \n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  \n\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include <stdint.h>\n#include <sys\/stat.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include <time.h>\n#include <sys\/time.h>\n#include <sys\/times.h>\n#include <stm32f1xx.h>\n\n\n#undef errno\nextern int32_t errno;\n\nuint8_t *__env[1] = { 0 };\nuint8_t **environ = __env;\n\n\n\nvoid initialise_monitor_handles()\n{\n}\n\nint _getpid(void)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _gettimeofday(struct timeval  *ptimeval, void *ptimezone)\n{\n  errno = ENOSYS;\n  return -1;\n}\n\nint _kill(int32_t pid, int32_t sig)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nvoid _exit(int32_t status)\n{\n    while (1) {}        \n}\n\nint _write(int32_t file, uint8_t *ptr, int32_t len)\n{\n    \n    \n    int i;\n    for(i = 0; i < len; i++)\n        ITM_SendChar(*ptr++);\n    return len;\n}\n\nvoid * _sbrk(int32_t incr)\n{\n    extern char   end; \n    static char * heap_end;\n    char *        prev_heap_end;\n\n    if (heap_end == 0) {\n        heap_end = & end;\n    }\n\n    prev_heap_end = heap_end;\n    heap_end += incr;\n\n    return (void *) prev_heap_end;\n}\n\nint _close(int32_t file)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\n\nint _fstat(int32_t file, struct stat *st)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _isatty(int32_t file)\n{\n    errno = ENOSYS;\n    return 0;\n}\n\nint _lseek(int32_t file, int32_t ptr, int32_t dir)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _read(int32_t file, uint8_t *ptr, int32_t len)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _readlink(const char *path, char *buf, size_t bufsize)\n{\n  errno = ENOSYS;\n  return -1;\n}\n\nint _open(const uint8_t *path, int32_t flags, int32_t mode)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _wait(int32_t *status)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _unlink(const uint8_t *name)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _times(struct tms *buf)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _stat(const uint8_t *file, struct stat *st)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _symlink(const char *path1, const char *path2)\n{\n  errno = ENOSYS;\n  return -1;\n}\n\nint _link(const uint8_t *old, const uint8_t *new)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _fork(void)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\nint _execve(const uint8_t *name, uint8_t * const *argv, uint8_t * const *env)\n{\n    errno = ENOSYS;\n    return -1;\n}\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n\n  \n  \n\n\n#include \"stm32f1xx.h\"\n\n\n\n\n\n\n\n\n\n#if !defined  (HSE_VALUE) \n  #define HSE_VALUE               8000000U \n#endif \n\n#if !defined  (HSI_VALUE)\n  #define HSI_VALUE               8000000U \n#endif \n\n \n#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)\n\n#endif \n\n \n\n#define VECT_TAB_OFFSET  0x00000000U \n\n\n\n\n\n\n\n\n\n\n\n#if defined(STM32F100xB) ||defined(STM32F100xE)\n  uint32_t SystemCoreClock         = 24000000U;        \n#else \n  uint32_t SystemCoreClock         = 72000000U;        \n#endif\n\nconst uint8_t AHBPrescTable[16U] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};\nconst uint8_t APBPrescTable[8U] =  {0, 0, 0, 0, 1, 2, 3, 4};\n\n\n\n\n\n#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)\n#ifdef DATA_IN_ExtSRAM\n  static void SystemInit_ExtMemCtl(void); \n#endif \n#endif \n\n\n\n\n\n\nvoid SystemInit (void)\n{\n  \n  \n  RCC->CR |= 0x00000001U;\n\n  \n#if !defined(STM32F105xC) && !defined(STM32F107xC)\n  RCC->CFGR &= 0xF8FF0000U;\n#else\n  RCC->CFGR &= 0xF0FF0000U;\n#endif    \n  \n  \n  RCC->CR &= 0xFEF6FFFFU;\n\n  \n  RCC->CR &= 0xFFFBFFFFU;\n\n  \n  RCC->CFGR &= 0xFF80FFFFU;\n\n#if defined(STM32F105xC) || defined(STM32F107xC)\n  \n  RCC->CR &= 0xEBFFFFFFU;\n\n  \n  RCC->CIR = 0x00FF0000U;\n\n  \n  RCC->CFGR2 = 0x00000000U;\n#elif defined(STM32F100xB) || defined(STM32F100xE)\n  \n  RCC->CIR = 0x009F0000U;\n\n  \n  RCC->CFGR2 = 0x00000000U;      \n#else\n  \n  RCC->CIR = 0x009F0000U;\n#endif \n    \n#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)\n  #ifdef DATA_IN_ExtSRAM\n    SystemInit_ExtMemCtl(); \n  #endif \n#endif \n\n#ifdef VECT_TAB_SRAM\n  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; \n#else\n  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; \n#endif \n}\n\n\nvoid SystemCoreClockUpdate (void)\n{\n  uint32_t tmp = 0U, pllmull = 0U, pllsource = 0U;\n\n#if defined(STM32F105xC) || defined(STM32F107xC)\n  uint32_t prediv1source = 0U, prediv1factor = 0U, prediv2factor = 0U, pll2mull = 0U;\n#endif \n\n#if defined(STM32F100xB) || defined(STM32F100xE)\n  uint32_t prediv1factor = 0U;\n#endif \n    \n  \n  tmp = RCC->CFGR & RCC_CFGR_SWS;\n  \n  switch (tmp)\n  {\n    case 0x00U:  \n      SystemCoreClock = HSI_VALUE;\n      break;\n    case 0x04U:  \n      SystemCoreClock = HSE_VALUE;\n      break;\n    case 0x08U:  \n\n      \n      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;\n      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;\n      \n#if !defined(STM32F105xC) && !defined(STM32F107xC)      \n      pllmull = ( pllmull >> 18U) + 2U;\n      \n      if (pllsource == 0x00U)\n      {\n        \n        SystemCoreClock = (HSI_VALUE >> 1U) * pllmull;\n      }\n      else\n      {\n #if defined(STM32F100xB) || defined(STM32F100xE)\n       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1U;\n       \n       SystemCoreClock = (HSE_VALUE \/ prediv1factor) * pllmull; \n #else\n        \n        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)\n        {\n          SystemCoreClock = (HSE_VALUE >> 1U) * pllmull;\n        }\n        else\n        {\n          SystemCoreClock = HSE_VALUE * pllmull;\n        }\n #endif\n      }\n#else\n      pllmull = pllmull >> 18U;\n      \n      if (pllmull != 0x0DU)\n      {\n         pllmull += 2U;\n      }\n      else\n      { \n        pllmull = 13U \/ 2U; \n      }\n            \n      if (pllsource == 0x00U)\n      {\n        \n        SystemCoreClock = (HSI_VALUE >> 1U) * pllmull;\n      }\n      else\n      {\n        \n        \n        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;\n        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1U;\n        \n        if (prediv1source == 0U)\n        { \n          \n          SystemCoreClock = (HSE_VALUE \/ prediv1factor) * pllmull;          \n        }\n        else\n        {\n          \n          \n          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4U) + 1U;\n          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8U) + 2U; \n          SystemCoreClock = (((HSE_VALUE \/ prediv2factor) * pll2mull) \/ prediv1factor) * pllmull;                         \n        }\n      }\n#endif  \n      break;\n\n    default:\n      SystemCoreClock = HSI_VALUE;\n      break;\n  }\n  \n  \n  \n  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];\n  \n  SystemCoreClock >>= tmp;  \n}\n\n#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)\n \n#ifdef DATA_IN_ExtSRAM\n \nvoid SystemInit_ExtMemCtl(void) \n{\n  __IO uint32_t tmpreg;\n  \n\n  \n  RCC->AHBENR = 0x00000114U;\n\n  \n  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_FSMCEN);\n  \n  \n  RCC->APB2ENR = 0x000001E0U;\n  \n  \n  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPDEN);\n\n  (void)(tmpreg);\n  \n\n\n  \n\n\n  \n  GPIOD->CRL = 0x44BB44BBU;  \n  GPIOD->CRH = 0xBBBBBBBBU;\n\n  GPIOE->CRL = 0xB44444BBU;  \n  GPIOE->CRH = 0xBBBBBBBBU;\n\n  GPIOF->CRL = 0x44BBBBBBU;  \n  GPIOF->CRH = 0xBBBB4444U;\n\n  GPIOG->CRL = 0x44BBBBBBU;  \n  GPIOG->CRH = 0x444B4B44U;\n   \n  \n\n  \n  FSMC_Bank1->BTCR[4U] = 0x00001091U;\n  FSMC_Bank1->BTCR[5U] = 0x00110212U;\n}\n#endif \n#endif \n\n\n\n\n  \n    \n\n"}
{"target":"RobertoBenjami","func":"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"main.h\"\n\n#include \"multi_heap.h\"\n\n#define POINTERS_NUM          512     \n#define IMALLOC_SIZE          1024    \n#define EMALLOC_SIZE          128000  \n\n#define PRINTF_DELAY          20\n\n\n\n#ifdef  osCMSIS\n#define Delay(t)              osDelay(t)\n#define GetTime()             osKernelSysTick()\n#else\n#define Delay(t)              HAL_Delay(t)\n#define GetTime()             HAL_GetTick()\n#endif\n\n\n\n#ifdef osCMSIS\nvoid StartDefaultTask(void const * argument)\n#else\nvoid mainApp(void)\n#endif\n{\n  static uint8_t * p[POINTERS_NUM];\n  uint32_t i;\n  printf(\"\\r\\nMem malloc test\\r\\n\");\n  Delay(PRINTF_DELAY);\n\n  i = 0;\n  do\n  {\n    p[i] = malloc_int(IMALLOC_SIZE);\n    printf(\"int ram malloc:p%d:0x%x, 0x%x\\r\\n\", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_int());\n    Delay(PRINTF_DELAY);\n    i++;\n  } while((i < POINTERS_NUM) && p[i - 1]);\n  i = 0;\n  do\n  {\n    if(p[i] == NULL)\n      break;\n    else\n    {\n      free(p[i]);\n      printf(\"int ram free:p%d:0x%x, 0x%x\\r\\n\", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_int());\n      Delay(PRINTF_DELAY);\n    }\n    i++;\n  } while(i < POINTERS_NUM);\n\n  i = 0;\n  do\n  {\n    p[i] = malloc_ext(EMALLOC_SIZE);\n    printf(\"ext ram malloc:p%d:0x%x, 0x%x\\r\\n\", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_ext());\n    Delay(PRINTF_DELAY);\n    i++;\n  } while((i < POINTERS_NUM) && p[i - 1]);\n  i = 0;\n  do\n  {\n    if(p[i] == NULL)\n      break;\n    else\n    {\n      free(p[i]);\n      printf(\"ext ram free:p%d:0x%x, 0x%x\\r\\n\", (unsigned int)i, (unsigned int)p[i], (unsigned int)heapsize_ext());\n      Delay(PRINTF_DELAY);\n    }\n    i++;\n  } while(i < POINTERS_NUM);\n\n  printf(\"End test\\r\\n\");\n\n  while(1)\n  {\n    Delay(1000);\n  }\n}\n\n\n\n#ifdef osCMSIS\nvoid StartTask02(void const * argument)\n{\n  for(;;)\n  {\n    Delay(1);\n  }\n}\n#endif\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"main.h\"\n#include \"stm32f4xx_hal.h\"\n\n\n#include \"sdinit.h\"\n\n\n\nSDRAM_HandleTypeDef hsdram1;\n\n\n\n\n\n\n\nvoid SystemClock_Config(void);\nstatic void MX_GPIO_Init(void);\nstatic void MX_FMC_Init(void);\n\n\n\nvoid mainApp(void);\n\n\n\n\n\n\n\n\nint main(void)\n{\n  \n\n  \n\n  \n\n  \n  HAL_Init();\n\n  \n\n  \n\n  \n  SystemClock_Config();\n\n  \n\n  \n\n  \n  MX_GPIO_Init();\n  MX_FMC_Init();\n  \n  SDRAM_Initialization_Sequence(&hsdram1);\n  \n\n  \n  \n  mainApp();\n  while (1)\n  {\n\n  \n\n  \n\n  }\n  \n\n}\n\n\nvoid SystemClock_Config(void)\n{\n\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n\n    \n  __HAL_RCC_PWR_CLK_ENABLE();\n\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);\n\n    \n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLM = 4;\n  RCC_OscInitStruct.PLL.PLLN = 168;\n  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;\n  RCC_OscInitStruct.PLL.PLLQ = 4;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n\n    \n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n\n    \n  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()\/1000);\n\n    \n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n\n  \n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n\n\nstatic void MX_FMC_Init(void)\n{\n  FMC_SDRAM_TimingTypeDef SdramTiming;\n\n  \n  hsdram1.Instance = FMC_SDRAM_DEVICE;\n  \n  hsdram1.Init.SDBank = FMC_SDRAM_BANK2;\n  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;\n  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;\n  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;\n  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;\n  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;\n  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;\n  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;\n  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;\n  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_1;\n  \n  SdramTiming.LoadToActiveDelay = 2;\n  SdramTiming.ExitSelfRefreshDelay = 7;\n  SdramTiming.SelfRefreshTime = 4;\n  SdramTiming.RowCycleDelay = 7;\n  SdramTiming.WriteRecoveryTime = 3;\n  SdramTiming.RPDelay = 2;\n  SdramTiming.RCDDelay = 2;\n\n  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n\n}\n\n\nstatic void MX_GPIO_Init(void)\n{\n\n  \n  __HAL_RCC_GPIOF_CLK_ENABLE();\n  __HAL_RCC_GPIOH_CLK_ENABLE();\n  __HAL_RCC_GPIOC_CLK_ENABLE();\n  __HAL_RCC_GPIOG_CLK_ENABLE();\n  __HAL_RCC_GPIOE_CLK_ENABLE();\n  __HAL_RCC_GPIOD_CLK_ENABLE();\n  __HAL_RCC_GPIOA_CLK_ENABLE();\n  __HAL_RCC_GPIOB_CLK_ENABLE();\n\n}\n\n\n\n\n\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n  \n\n  \n  if (htim->Instance == TIM6) {\n    HAL_IncTick();\n  }\n  \n\n  \n}\n\n\nvoid _Error_Handler(char *file, int line)\n{\n  \n  \n  while(1)\n  {\n  }\n  \n}\n\n#ifdef  USE_FULL_ASSERT\n\nvoid assert_failed(uint8_t* file, uint32_t line)\n{ \n  \n  \n  \n}\n#endif \n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n#include \"stm32f4xx_hal.h\"\n\n#define SDRAM_BANK_ADDR                 ((uint32_t)0xD0000000)\n\n\n#define SDRAM_MEMORY_WIDTH            FMC_SDRAM_MEM_BUS_WIDTH_16\n\n\n#define SDCLOCK_PERIOD                FMC_SDRAM_CLOCK_PERIOD_3\n\n#define SDRAM_TIMEOUT                            ((uint32_t)0xFFFF)\n\n#define SDRAM_MODEREG_BURST_LENGTH_1             ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_LENGTH_2             ((uint16_t)0x0001)\n#define SDRAM_MODEREG_BURST_LENGTH_4             ((uint16_t)0x0002)\n#define SDRAM_MODEREG_BURST_LENGTH_8             ((uint16_t)0x0004)\n#define SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL      ((uint16_t)0x0000)\n#define SDRAM_MODEREG_BURST_TYPE_INTERLEAVED     ((uint16_t)0x0008)\n#define SDRAM_MODEREG_CAS_LATENCY_2              ((uint16_t)0x0020)\n#define SDRAM_MODEREG_CAS_LATENCY_3              ((uint16_t)0x0030)\n#define SDRAM_MODEREG_OPERATING_MODE_STANDARD    ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_PROGRAMMED ((uint16_t)0x0000)\n#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)\n\n#define REFRESH_COUNT       ((uint32_t)0x056A)   \n\n\nvoid SDRAM_Initialization_Sequence(SDRAM_HandleTypeDef *hsdram)\n{\n  __IO uint32_t tmpmrd =0;\n  FMC_SDRAM_CommandTypeDef Command;\n  \n  Command.CommandMode       = FMC_SDRAM_CMD_CLK_ENABLE;\n  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;\n  Command.AutoRefreshNumber   = 1;\n  Command.ModeRegisterDefinition = 0;\n\n  \n  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);\n\n  \n  HAL_Delay(100);\n\n  \n  Command.CommandMode       = FMC_SDRAM_CMD_PALL;\n  Command.CommandTarget       = FMC_SDRAM_CMD_TARGET_BANK2;\n  Command.AutoRefreshNumber   = 1;\n  Command.ModeRegisterDefinition = 0;\n\n  \n  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);\n\n  \n  Command.CommandMode       = FMC_SDRAM_CMD_AUTOREFRESH_MODE;\n  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;\n  Command.AutoRefreshNumber   = 4;\n  Command.ModeRegisterDefinition = 0;\n\n  \n  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);\n\n  \n  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_2          |\n                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\n                     SDRAM_MODEREG_CAS_LATENCY_3           |\n                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\n                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;\n\n  Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;\n  Command.CommandTarget     = FMC_SDRAM_CMD_TARGET_BANK2;\n  Command.AutoRefreshNumber   = 1;\n  Command.ModeRegisterDefinition = tmpmrd;\n\n  \n  HAL_SDRAM_SendCommand(hsdram, &Command, 0x1000);\n\n  \n  \n  \n  HAL_SDRAM_ProgramRefreshRate(hsdram, REFRESH_COUNT);\n}\n"}
{"target":"RobertoBenjami","func":" \n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n\n\n\n\n#define __STM32F4xx_HAL_VERSION_MAIN   (0x01U) \n#define __STM32F4xx_HAL_VERSION_SUB1   (0x07U) \n#define __STM32F4xx_HAL_VERSION_SUB2   (0x04U) \n#define __STM32F4xx_HAL_VERSION_RC     (0x00U)  \n#define __STM32F4xx_HAL_VERSION         ((__STM32F4xx_HAL_VERSION_MAIN << 24U)\\\n                                        |(__STM32F4xx_HAL_VERSION_SUB1 << 16U)\\\n                                        |(__STM32F4xx_HAL_VERSION_SUB2 << 8U )\\\n                                        |(__STM32F4xx_HAL_VERSION_RC))\n                                        \n#define IDCODE_DEVID_MASK    0x00000FFFU\n\n\n#define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)\n \n \n#define MEMRMP_OFFSET             SYSCFG_OFFSET \n#define UFB_MODE_BIT_NUMBER       SYSCFG_MEMRMP_UFB_MODE_Pos\n#define UFB_MODE_BB               (uint32_t)(PERIPH_BB_BASE + (MEMRMP_OFFSET * 32U) + (UFB_MODE_BIT_NUMBER * 4U)) \n\n \n \n#define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20U) \n#define CMP_PD_BIT_NUMBER         SYSCFG_CMPCR_CMP_PD_Pos\n#define CMPCR_CMP_PD_BB           (uint32_t)(PERIPH_BB_BASE + (CMPCR_OFFSET * 32U) + (CMP_PD_BIT_NUMBER * 4U))\n\n \n \n#define MCHDLYCR_OFFSET            (SYSCFG_OFFSET + 0x30U) \n#define BSCKSEL_BIT_NUMBER         SYSCFG_MCHDLYCR_BSCKSEL_Pos\n#define MCHDLYCR_BSCKSEL_BB        (uint32_t)(PERIPH_BB_BASE + (MCHDLYCR_OFFSET * 32U) + (BSCKSEL_BIT_NUMBER * 4U))\n\n\n\n\n\n__IO uint32_t uwTick;\nuint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); \nHAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  \n\n\n\n\n\n\n\n\n\nHAL_StatusTypeDef HAL_Init(void)\n{\n   \n#if (INSTRUCTION_CACHE_ENABLE != 0U)\n  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();\n#endif \n\n#if (DATA_CACHE_ENABLE != 0U)\n  __HAL_FLASH_DATA_CACHE_ENABLE();\n#endif \n\n#if (PREFETCH_ENABLE != 0U)\n  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();\n#endif \n\n  \n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n\n  \n  HAL_InitTick(TICK_INT_PRIORITY);\n\n  \n  HAL_MspInit();\n\n  \n  return HAL_OK;\n}\n\n\nHAL_StatusTypeDef HAL_DeInit(void)\n{\n  \n  __HAL_RCC_APB1_FORCE_RESET();\n  __HAL_RCC_APB1_RELEASE_RESET();\n\n  __HAL_RCC_APB2_FORCE_RESET();\n  __HAL_RCC_APB2_RELEASE_RESET();\n\n  __HAL_RCC_AHB1_FORCE_RESET();\n  __HAL_RCC_AHB1_RELEASE_RESET();\n\n  __HAL_RCC_AHB2_FORCE_RESET();\n  __HAL_RCC_AHB2_RELEASE_RESET();\n\n  __HAL_RCC_AHB3_FORCE_RESET();\n  __HAL_RCC_AHB3_RELEASE_RESET();\n\n  \n  HAL_MspDeInit();\n    \n  \n  return HAL_OK;\n}\n\n\n__weak void HAL_MspInit(void)\n{\n  \n}\n\n\n__weak void HAL_MspDeInit(void)\n{\n   \n}\n\n\n__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n{\n  \n  if (HAL_SYSTICK_Config(SystemCoreClock \/ (1000U \/ uwTickFreq)) > 0U)\n  {\n    return HAL_ERROR;\n  }\n\n  \n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\n  {\n    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);\n    uwTickPrio = TickPriority;\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n\n  \n  return HAL_OK;\n}\n\n\n\n\n\n\n__weak void HAL_IncTick(void)\n{\n  uwTick += uwTickFreq;\n}\n\n\n__weak uint32_t HAL_GetTick(void)\n{\n  return uwTick;\n}\n\n\nuint32_t HAL_GetTickPrio(void)\n{\n  return uwTickPrio;\n}\n\n\nHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n\n    \n    status = HAL_InitTick(uwTickPrio);\n  }\n\n  return status;\n}\n\n\nHAL_TickFreqTypeDef HAL_GetTickFreq(void)\n{\n  return uwTickFreq;\n}\n\n\n__weak void HAL_Delay(uint32_t Delay)\n{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n\n  \n  if (wait < HAL_MAX_DELAY)\n  {\n    wait += (uint32_t)(uwTickFreq);\n  }\n\n  while((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}\n\n\n__weak void HAL_SuspendTick(void)\n{\n  \n  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;\n}\n\n\n__weak void HAL_ResumeTick(void)\n{\n  \n  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;\n}\n\n\nuint32_t HAL_GetHalVersion(void)\n{\n  return __STM32F4xx_HAL_VERSION;\n}\n\n\nuint32_t HAL_GetREVID(void)\n{\n  return((DBGMCU->IDCODE) >> 16U);\n}\n\n\nuint32_t HAL_GetDEVID(void)\n{\n  return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGSleepMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGSleepMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGStopMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGStopMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);\n}\n\n\nvoid HAL_DBGMCU_EnableDBGStandbyMode(void)\n{\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\n}\n\n\nvoid HAL_DBGMCU_DisableDBGStandbyMode(void)\n{\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);\n}\n\n\nvoid HAL_EnableCompensationCell(void)\n{\n  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_DisableCompensationCell(void)\n{\n  *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_GetUID(uint32_t *UID)\n{\n  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));\n  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\n  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\n}\n\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\\\n    defined(STM32F469xx) || defined(STM32F479xx)\n\nvoid HAL_EnableMemorySwappingBank(void)\n{\n  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_DisableMemorySwappingBank(void)\n{\n  *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)DISABLE;\n}\n#endif \n\n\n\n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_CORTEX_MODULE_ENABLED\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n{\n  \n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n  \n  \n  NVIC_SetPriorityGrouping(PriorityGroup);\n}\n\n\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  \n  \n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  \n  prioritygroup = NVIC_GetPriorityGrouping();\n  \n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}\n\n\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  NVIC_EnableIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  NVIC_DisableIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_SystemReset(void)\n{\n  \n  NVIC_SystemReset();\n}\n\n\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n{\n   return SysTick_Config(TicksNumb);\n}\n\n\n\n\n#if (__MPU_PRESENT == 1U)\n\nvoid HAL_MPU_Disable(void)\n{\n  \n  __DMB();\n\n  \n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\n  \n  \n  MPU->CTRL = 0U;\n}\n\n\nvoid HAL_MPU_Enable(uint32_t MPU_Control)\n{\n  \n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\n  \n  \n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\n  \n  \n  __DSB();\n  __ISB();\n}\n\n\nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\n{\n  \n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\n\n  \n  MPU->RNR = MPU_Init->Number;\n\n  if ((MPU_Init->Enable) != RESET)\n  {\n    \n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\n    \n    MPU->RBAR = MPU_Init->BaseAddress;\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\n  }\n  else\n  {\n    MPU->RBAR = 0x00U;\n    MPU->RASR = 0x00U;\n  }\n}\n#endif \n\n\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\n{\n  \n  return NVIC_GetPriorityGrouping();\n}\n\n\nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\n{\n  \n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n \n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\n}\n\n\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  NVIC_SetPendingIRQ(IRQn);\n}\n\n\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  return NVIC_GetPendingIRQ(IRQn);\n}\n\n\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  NVIC_ClearPendingIRQ(IRQn);\n}\n\n\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\n{\n  \n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  \n  return NVIC_GetActive(IRQn);\n}\n\n\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n{\n  \n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\n  {\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\n  }\n}\n\n\nvoid HAL_SYSTICK_IRQHandler(void)\n{\n  HAL_SYSTICK_Callback();\n}\n\n\n__weak void HAL_SYSTICK_Callback(void)\n{\n  \n}\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_DMA_MODULE_ENABLED\n\n\n\n\n\n\n\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\n\n\n\n\n\n\n\n\n\n\n\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  \n  \n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  \n  \n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    status = HAL_ERROR;\n  }\n  else\n  {\n    \n    __HAL_LOCK(hdma);\n    \n    if(HAL_DMA_STATE_READY == hdma->State)\n    {\n      \n      hdma->State = HAL_DMA_STATE_BUSY; \n      \n      \n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n      \n      \n      hdma->Instance->M1AR = SecondMemAddress;\n      \n      \n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\n      \n      \n      __HAL_DMA_ENABLE(hdma);\n    }\n    else\n    {\n      \n      status = HAL_BUSY;\n    }\n  }\n  return status;\n}\n\n\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  \n  \n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  \n  \n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    return HAL_ERROR;\n  }\n  \n  \n  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  \n  \n  __HAL_LOCK(hdma);\n  \n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    \n    hdma->State = HAL_DMA_STATE_BUSY;\n    \n    \n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n    \n    \n    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n    \n    \n    hdma->Instance->M1AR = SecondMemAddress;\n    \n    \n    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); \n    \n    \n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));\n\n    \n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\n    hdma->Instance->FCR |= DMA_IT_FE;\n    \n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\n    {\n      hdma->Instance->CR  |= DMA_IT_HT;\n    }\n    \n    \n    __HAL_DMA_ENABLE(hdma); \n  }\n  else\n  {     \n    \n    __HAL_UNLOCK(hdma);   \n    \n    \n    status = HAL_BUSY;\n  }  \n  return status; \n}\n\n\nHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)\n{\n  if(memory == MEMORY0)\n  {\n    \n    hdma->Instance->M0AR = Address;\n  }\n  else\n  {\n    \n    hdma->Instance->M1AR = Address;\n  }\n\n  return HAL_OK;\n}\n\n\n\n\n\n\n\n\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{  \n  \n  hdma->Instance->NDTR = DataLength;\n  \n  \n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n  {   \n    \n    hdma->Instance->PAR = DstAddress;\n    \n    \n    hdma->Instance->M0AR = SrcAddress;\n  }\n  \n  else\n  {\n    \n    hdma->Instance->PAR = SrcAddress;\n    \n    \n    hdma->Instance->M0AR = DstAddress;\n  }\n}\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":" \n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n#ifdef HAL_FLASH_MODULE_ENABLED\n#if defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \\\n    defined(STM32F412Rx) || defined(STM32F412Cx)\n\n\n\n\n\n\n\n\n\n\n\n\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StopFlashInterfaceClk(void)\n{\n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n    \n  SET_BIT(PWR->CR, PWR_CR_FISSR);\n   \n  return HAL_OK;\n}\n\n\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_StartFlashInterfaceClk(void)\n{\n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  CLEAR_BIT(PWR->CR, PWR_CR_FISSR);\n\n  return HAL_OK;\n}\n\n\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableFlashSleepMode(void)\n{\n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  SET_BIT(PWR->CR, PWR_CR_FMSSR);\n\n  return HAL_OK;\n}\n\n\n__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableFlashSleepMode(void)\n{\n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  CLEAR_BIT(PWR->CR, PWR_CR_FMSSR);\n  \n  return HAL_OK;\n}\n\n\n\n\n\n#endif \n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":" \n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_GPIO_MODULE_ENABLED\n\n\n\n\n#define GPIO_MODE             0x00000003U\n#define EXTI_MODE             0x10000000U\n#define GPIO_MODE_IT          0x00010000U\n#define GPIO_MODE_EVT         0x00020000U\n#define RISING_EDGE           0x00100000U\n#define FALLING_EDGE          0x00200000U\n#define GPIO_OUTPUT_TYPE      0x00000010U\n\n#define GPIO_NUMBER           16U\n\n\n\n\n\n\n\n\n\n\n\n\nvoid HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t temp = 0x00U;\n\n  \n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\n  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\n\n  \n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    \n    ioposition = 0x01U << position;\n    \n    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;\n\n    if(iocurrent == ioposition)\n    {\n      \n      \n      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))\n      {\n        \n        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));\n        \n        temp = GPIOx->AFR[position >> 3U];\n        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));\n        GPIOx->AFR[position >> 3U] = temp;\n      }\n\n      \n      temp = GPIOx->MODER;\n      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));\n      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));\n      GPIOx->MODER = temp;\n\n      \n      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||\n         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))\n      {\n        \n        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n        \n        temp = GPIOx->OSPEEDR; \n        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n        temp |= (GPIO_Init->Speed << (position * 2U));\n        GPIOx->OSPEEDR = temp;\n\n        \n        temp = GPIOx->OTYPER;\n        temp &= ~(GPIO_OTYPER_OT_0 << position) ;\n        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);\n        GPIOx->OTYPER = temp;\n      }\n\n      \n      temp = GPIOx->PUPDR;\n      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n      temp |= ((GPIO_Init->Pull) << (position * 2U));\n      GPIOx->PUPDR = temp;\n\n      \n      \n      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)\n      {\n        \n        __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n        temp = SYSCFG->EXTICR[position >> 2U];\n        temp &= ~(0x0FU << (4U * (position & 0x03U)));\n        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));\n        SYSCFG->EXTICR[position >> 2U] = temp;\n\n        \n        temp = EXTI->IMR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->IMR = temp;\n\n        temp = EXTI->EMR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->EMR = temp;\n\n        \n        temp = EXTI->RTSR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->RTSR = temp;\n\n        temp = EXTI->FTSR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->FTSR = temp;\n      }\n    }\n  }\n}\n\n\nvoid HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t tmp = 0x00U;\n\n  \n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  \n  \n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    \n    ioposition = 0x01U << position;\n    \n    iocurrent = (GPIO_Pin) & ioposition;\n\n    if(iocurrent == ioposition)\n    {\n      \n      \n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));\n\n      \n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n\n      \n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n\n      \n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\n\n      \n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n\n      \n      tmp = SYSCFG->EXTICR[position >> 2U];\n      tmp &= (0x0FU << (4U * (position & 0x03U)));\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))\n      {\n        \n        tmp = 0x0FU << (4U * (position & 0x03U));\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\n\n        \n        EXTI->IMR &= ~((uint32_t)iocurrent);\n        EXTI->EMR &= ~((uint32_t)iocurrent);\n        \n        \n        EXTI->RTSR &= ~((uint32_t)iocurrent);\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\n      }\n    }\n  }\n}\n\n\n\n\n\n\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n  GPIO_PinState bitstatus;\n\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\n  {\n    bitstatus = GPIO_PIN_SET;\n  }\n  else\n  {\n    bitstatus = GPIO_PIN_RESET;\n  }\n  return bitstatus;\n}\n\n\nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n\n  if(PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}\n\n\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  GPIOx->ODR ^= GPIO_Pin;\n}\n\n\nHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\n\n  \n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n\n  \n  tmp |= GPIO_Pin;\n  \n  GPIOx->LCKR = tmp;\n  \n  GPIOx->LCKR = GPIO_Pin;\n  \n  GPIOx->LCKR = tmp;\n  \n  tmp = GPIOx->LCKR;\n\n if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)\n  {\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n}\n\n\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n{\n  \n  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)\n  {\n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n}\n\n\n__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n  \n  UNUSED(GPIO_Pin);\n  \n}\n\n\n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n#include \"stm32f4xx_hal.h\"\nextern void _Error_Handler(char *, int);\n\n\n\n\nvoid HAL_MspInit(void)\n{\n  \n\n  \n\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n\n  \n  \n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  \n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n\n  \n\n  \n}\n\nstatic uint32_t FMC_Initialized = 0;\n\nstatic void HAL_FMC_MspInit(void){\n  \n\n  \n  GPIO_InitTypeDef GPIO_InitStruct;\n  if (FMC_Initialized) {\n    return;\n  }\n  FMC_Initialized = 1;\n  \n  __HAL_RCC_FMC_CLK_ENABLE();\n  \n  \n  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 \n                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 \n                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);\n\n  GPIO_InitStruct.Pin = GPIO_PIN_0;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);\n\n  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 \n                          |GPIO_PIN_8|GPIO_PIN_15;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);\n\n  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 \n                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);\n\n  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);\n\n  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\n\n  \n\n  \n}\n\nvoid HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){\n  \n\n  \n  HAL_FMC_MspInit();\n  \n\n  \n}\n\nstatic uint32_t FMC_DeInitialized = 0;\n\nstatic void HAL_FMC_MspDeInit(void){\n  \n\n  \n  if (FMC_DeInitialized) {\n    return;\n  }\n  FMC_DeInitialized = 1;\n  \n  __HAL_RCC_FMC_CLK_DISABLE();\n  \n  \n  HAL_GPIO_DeInit(GPIOF, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 \n                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 \n                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);\n\n  HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0);\n\n  HAL_GPIO_DeInit(GPIOG, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 \n                          |GPIO_PIN_8|GPIO_PIN_15);\n\n  HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 \n                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);\n\n  HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);\n\n  HAL_GPIO_DeInit(GPIOB, GPIO_PIN_5|GPIO_PIN_6);\n\n  \n\n  \n}\n\nvoid HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef* hsdram){\n  \n\n  \n  HAL_FMC_MspDeInit();\n  \n\n  \n}\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":" \n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_PWR_MODULE_ENABLED\n\n\n\n\n  \n     \n#define PVD_MODE_IT               0x00010000U\n#define PVD_MODE_EVT              0x00020000U\n#define PVD_RISING_EDGE           0x00000001U\n#define PVD_FALLING_EDGE          0x00000002U\n\n\n    \n\n\n\n\n\n\n\n\n\n\nvoid HAL_PWR_DeInit(void)\n{\n  __HAL_RCC_PWR_FORCE_RESET();\n  __HAL_RCC_PWR_RELEASE_RESET();\n}\n\n\nvoid HAL_PWR_EnableBkUpAccess(void)\n{\n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWR_DisableBkUpAccess(void)\n{\n  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;\n}\n\n\n\n\n\n\nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\n{\n  \n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\n  \n  \n  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);\n  \n  \n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \n\n  \n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\n  }\n  \n  \n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\n  }\n  \n  \n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\n  }\n  \n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\n  }\n}\n\n\nvoid HAL_PWR_EnablePVD(void)\n{\n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWR_DisablePVD(void)\n{\n  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)\n{\n  \n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));\n\n  \n  SET_BIT(PWR->CSR, WakeUpPinx);\n}\n\n\nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)\n{\n  \n  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));  \n\n  \n  CLEAR_BIT(PWR->CSR, WakeUpPinx);\n}\n  \n\nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\n{\n  \n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\n\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n\n  \n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\n  {   \n    \n    __WFI();\n  }\n  else\n  {\n    \n    __SEV();\n    __WFE();\n    __WFE();\n  }\n}\n\n\nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  \n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n  \n  \n  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS), Regulator);\n  \n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  \n  \n  if(STOPEntry == PWR_STOPENTRY_WFI)\n  {   \n    \n    __WFI();\n  }\n  else\n  {\n    \n    __SEV();\n    __WFE();\n    __WFE();\n  }\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  \n}\n\n\nvoid HAL_PWR_EnterSTANDBYMode(void)\n{\n  \n  SET_BIT(PWR->CR, PWR_CR_PDDS);\n\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  \n  \n#if defined ( __CC_ARM)\n  __force_stores();\n#endif\n  \n  __WFI();\n}\n\n\nvoid HAL_PWR_PVD_IRQHandler(void)\n{\n  \n  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)\n  {\n    \n    HAL_PWR_PVDCallback();\n    \n    \n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();\n  }\n}\n\n\n__weak void HAL_PWR_PVDCallback(void)\n{\n   \n}\n\n\nvoid HAL_PWR_EnableSleepOnExit(void)\n{\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\n}\n\n\nvoid HAL_PWR_DisableSleepOnExit(void)\n{\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));\n}\n\n\nvoid HAL_PWR_EnableSEVOnPend(void)\n{\n  \n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\n}\n\n\nvoid HAL_PWR_DisableSEVOnPend(void)\n{\n  \n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));\n}\n\n\n  \n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":" \n\n\n#include \"stm32f4xx_hal.h\"\n\n\n\n\n\n#ifdef HAL_PWR_MODULE_ENABLED\n\n\n\n    \n#define PWR_OVERDRIVE_TIMEOUT_VALUE  1000U\n#define PWR_UDERDRIVE_TIMEOUT_VALUE  1000U\n#define PWR_BKPREG_TIMEOUT_VALUE     1000U\n#define PWR_VOSRDY_TIMEOUT_VALUE     1000U\n\n\n   \n\n\n\n\n\n\n\n\n\nHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)\n{\n  uint32_t tickstart = 0U;\n\n  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;\n\n  \n  tickstart = HAL_GetTick();\n\n    \n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    } \n  }\n  return HAL_OK;\n}\n\n\nHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)\n{\n  uint32_t tickstart = 0U;\n\n  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;\n\n  \n  tickstart = HAL_GetTick();\n\n    \n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    } \n  }\n  return HAL_OK;\n}\n\n\nvoid HAL_PWREx_EnableFlashPowerDown(void)\n{\n  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWREx_DisableFlashPowerDown(void)\n{\n  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;\n}\n\n  \nuint32_t HAL_PWREx_GetVoltageRange(void)\n{\n  return (PWR->CR & PWR_CR_VOS);\n}\n\n#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\n\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\n{\n  uint32_t tickstart = 0U;\n  \n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\n  \n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  \n  __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\n  \n  \n  tickstart = HAL_GetTick();\n  while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    } \n  }\n\n  return HAL_OK;\n}\n\n#elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \\\n      defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \\\n      defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) || \\\n      defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || \\\n      defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)\n\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\n{\n  uint32_t tickstart = 0U;\n  \n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\n  \n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  \n  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\n  {\n    \n    __HAL_RCC_PLL_DISABLE();\n    \n    \n    tickstart = HAL_GetTick();    \n      \n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\n    {\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    \n    \n    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\n    \n    \n    __HAL_RCC_PLL_ENABLE();\n    \n    \n    tickstart = HAL_GetTick();\n      \n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\n    {\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      } \n    }\n    \n    \n    tickstart = HAL_GetTick();\n    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\n    {\n      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      } \n    }\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n\n  return HAL_OK;\n}\n#endif \n\n#if defined(STM32F469xx) || defined(STM32F479xx)\n\nvoid HAL_PWREx_EnableWakeUpPinPolarityRisingEdge(void)\n{\n  *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_PWREx_EnableWakeUpPinPolarityFallingEdge(void)\n{\n  *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)ENABLE;\n}\n#endif \n\n#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\\\n    defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\\\n    defined(STM32F413xx) || defined(STM32F423xx)\n\nvoid HAL_PWREx_EnableMainRegulatorLowVoltage(void)\n{\n  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void)\n{\n  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;\n}\n\n\nvoid HAL_PWREx_EnableLowRegulatorLowVoltage(void)\n{\n  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;\n}\n\n\nvoid HAL_PWREx_DisableLowRegulatorLowVoltage(void)\n{\n  *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;\n}\n\n#endif \n\n#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\\\n    defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)\n\nHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\n{\n  uint32_t tickstart = 0U;\n\n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  \n  __HAL_PWR_OVERDRIVE_ENABLE();\n\n  \n  tickstart = HAL_GetTick();\n\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  \n  \n  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();\n\n  \n  tickstart = HAL_GetTick();\n\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  } \n  return HAL_OK;\n}\n\n\nHAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)\n{\n  uint32_t tickstart = 0U;\n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n    \n  \n  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();\n  \n  \n  tickstart = HAL_GetTick();\n \n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  } \n  \n  \n  __HAL_PWR_OVERDRIVE_DISABLE();\n\n  \n  tickstart = HAL_GetTick();\n\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  \n  return HAL_OK;\n}\n\n\nHAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  uint32_t tmpreg1 = 0U;\n\n  \n  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n  \n  \n  __HAL_RCC_PWR_CLK_ENABLE();\n  \n  \n  __HAL_PWR_CLEAR_ODRUDR_FLAG();\n  \n   \n  __HAL_PWR_UNDERDRIVE_ENABLE();\n\n  \n  tmpreg1 = PWR->CR;\n  \n  tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);\n  \n  \n  tmpreg1 |= Regulator;\n  \n  \n  PWR->CR = tmpreg1;\n  \n  \n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n  \n  \n  if(STOPEntry == PWR_SLEEPENTRY_WFI)\n  {   \n    \n    __WFI();\n  }\n  else\n  {\n    \n    __WFE();\n  }\n  \n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\n\n  return HAL_OK;  \n}\n\n#endif \n\n\n\n\n#endif \n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n\n#include \"stm32f4xx_hal.h\"\n#include \"stm32f4xx_hal_tim.h\"\n\n\n \n\n\n\n\n\nTIM_HandleTypeDef        htim6; \nuint32_t                 uwIncrementState = 0;\n\n\n\n\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n{\n  RCC_ClkInitTypeDef    clkconfig;\n  uint32_t              uwTimclock = 0;\n  uint32_t              uwPrescalerValue = 0;\n  uint32_t              pFLatency;\n  \n  \n  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0); \n  \n  \n  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn); \n  \n  \n  __HAL_RCC_TIM6_CLK_ENABLE();\n  \n  \n  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);\n  \n  \n  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();\n   \n  \n  uwPrescalerValue = (uint32_t) ((uwTimclock \/ 1000000) - 1);\n  \n  \n  htim6.Instance = TIM6;\n  \n  \n  htim6.Init.Period = (1000000 \/ 1000) - 1;\n  htim6.Init.Prescaler = uwPrescalerValue;\n  htim6.Init.ClockDivision = 0;\n  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;\n  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)\n  {\n    \n    return HAL_TIM_Base_Start_IT(&htim6);\n  }\n  \n  \n  return HAL_ERROR;\n}\n\n\nvoid HAL_SuspendTick(void)\n{\n  \n  __HAL_TIM_DISABLE_IT(&htim6, TIM_IT_UPDATE);                                                  \n}\n\n\nvoid HAL_ResumeTick(void)\n{\n  \n  __HAL_TIM_ENABLE_IT(&htim6, TIM_IT_UPDATE);\n}\n\n \n\n \n\n\n"}
{"target":"RobertoBenjami","func":"\n\n#include \"stm32f4xx_hal.h\"\n#include \"stm32f4xx.h\"\n#include \"stm32f4xx_it.h\"\n\n\n\n\n\n\n\nextern TIM_HandleTypeDef htim6;\n\n\n \n\n\n\nvoid NMI_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid HardFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid MemManage_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid BusFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid UsageFault_Handler(void)\n{\n  \n\n  \n  while (1)\n  {\n    \n    \n  }\n  \n\n  \n}\n\n\nvoid SVC_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid DebugMon_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid PendSV_Handler(void)\n{\n  \n\n  \n  \n\n  \n}\n\n\nvoid SysTick_Handler(void)\n{\n  \n\n  \n  HAL_SYSTICK_IRQHandler();\n  \n\n  \n}\n\n\n\n\n\n\n\n\n\nvoid TIM6_DAC_IRQHandler(void)\n{\n  \n\n  \n  HAL_TIM_IRQHandler(&htim6);\n  \n\n  \n}\n\n\n\n\n\n"}
{"target":"RobertoBenjami","func":"\n\n#include <stdio.h>\n#include \"main.h\"\n#include \"uart.h\"\n\n\n\n\n\n#define MODE_DIGITAL_INPUT    0x0\n#define MODE_OUT              0x1\n#define MODE_ALTER            0x2\n#define MODE_ANALOG_INPUT     0x3\n\n\n#define MODE_SPD_LOW          0x0\n#define MODE_SPD_MEDIUM       0x1\n#define MODE_SPD_HIGH         0x2\n#define MODE_SPD_VHIGH        0x3\n\n\n#define MODE_OT_PP            0x0\n#define MODE_OT_OD            0x1\n\n\n#define MODE_PU_NONE          0x0\n#define MODE_PU_UP            0x1\n#define MODE_PU_DOWN          0x2\n\n#define GPIOX_(a,b,c)         GPIO ## a\n#define GPIOX(a)              GPIOX_(a)\n\n#define GPIOX_PIN_(a,b,c)     b\n#define GPIOX_PIN(a)          GPIOX_PIN_(a)\n\n#define GPIOX_AFR_(a,b,c)     GPIO ## a->AFR[b >> 3] = (GPIO ## a->AFR[b >> 3] & ~(0x0F << (4 * (b & 7)))) | (c << (4 * (b & 7)));\n#define GPIOX_AFR(a)          GPIOX_AFR_(a)\n\n#define GPIOX_MODER_(a,b,c,d) GPIO ## b->MODER = (GPIO ## b->MODER & ~(3 << (2 * c))) | (a << (2 * c));\n#define GPIOX_MODER(a, b)     GPIOX_MODER_(a, b)\n\n#define GPIOX_OTYPER_(a,b,c,d) GPIO ## b->OTYPER = (GPIO ## b->OTYPER & ~(1 << c)) | (a << c);\n#define GPIOX_OTYPER(a, b)    GPIOX_OTYPER_(a, b)\n\n#define GPIOX_OSPEEDR_(a,b,c,d) GPIO ## b->OSPEEDR = (GPIO ## b->OSPEEDR & ~(3 << (2 * c))) | (a << (2 * c));\n#define GPIOX_OSPEEDR(a, b)   GPIOX_OSPEEDR_(a, b)\n\n#define GPIOX_PUPDR_(a,b,c,d) GPIO ## b->PUPDR = (GPIO ## b->PUPDR & ~(3 << (2 * c))) | (a << (2 * c));\n#define GPIOX_PUPDR(a, b)     GPIOX_PUPDR_(a, b)\n\n#define GPIOX_SET_(a,b,c)     GPIO ## a ->BSRR = 1 << b\n#define GPIOX_SET(a)          GPIOX_SET_(a)\n\n#define GPIOX_CLR_(a,b,c)     GPIO ## a ->BSRR = 1 << (b + 16)\n#define GPIOX_CLR(a)          GPIOX_CLR_(a)\n\n#define GPIOX_IDR_(a,b,c)     (GPIO ## a ->IDR & (1 << b))\n#define GPIOX_IDR(a)          GPIOX_IDR_(a)\n\n#define GPIOX_LINE_(a,b,c)    EXTI_Line ## b\n#define GPIOX_LINE(a)         GPIOX_LINE_(a)\n\n#define GPIOX_PORTSRC_(a,b,c) GPIO_PortSourceGPIO ## a\n#define GPIOX_PORTSRC(a)      GPIOX_PORTSRC_(a)\n\n#define GPIOX_PINSRC_(a,b,c)  GPIO_PinSource ## b\n#define GPIOX_PINSRC(a)       GPIOX_PINSRC_(a)\n\n#define GPIOX_CLOCK_(a,b,c)   RCC_AHB1ENR_GPIO ## a ## EN\n#define GPIOX_CLOCK(a)        GPIOX_CLOCK_(a)\n\n#define GPIOX_PORTNUM_A       1\n#define GPIOX_PORTNUM_B       2\n#define GPIOX_PORTNUM_C       3\n#define GPIOX_PORTNUM_D       4\n#define GPIOX_PORTNUM_E       5\n#define GPIOX_PORTNUM_F       6\n#define GPIOX_PORTNUM_G       7\n#define GPIOX_PORTNUM_H       8\n#define GPIOX_PORTNUM_I       9\n#define GPIOX_PORTNUM_J       10\n#define GPIOX_PORTNUM_K       11\n#define GPIOX_PORTNUM_(a,b,c) GPIOX_PORTNUM_ ## a\n#define GPIOX_PORTNUM(a)      GPIOX_PORTNUM_(a)\n\n#define GPIOX_PORTNAME_(a,b,c) a\n#define GPIOX_PORTNAME(a)     GPIOX_PORTNAME_(a)\n\n\n#if UART1_BAUDRATE > 0 && (GPIOX_PORTNUM(UART1_RX) >= GPIOX_PORTNUM_A && RXBUF1_SIZE >= 4 || GPIOX_PORTNUM(UART1_TX) >= GPIOX_PORTNUM_A && TXBUF1_SIZE >= 4)\n#define UARTX                 USART1\n#define UARTX_IRQHandler      USART1_IRQHandler\n#define UARTX_IRQn            USART1_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB2ENR |= RCC_APB2ENR_USART1EN\n#define UARTX_BRR_CALC        (UART_1_6_CLK) \/ UART1_BAUDRATE\n#define UARTX_RX              UART1_RX\n#define UARTX_TX              UART1_TX\n#define TXBUFX_SIZE           TXBUF1_SIZE\n#define RXBUFX_SIZE           RXBUF1_SIZE\n#define UARTX_PRINTF          UART1_PRINTF\n#define uartx_inited          uart1_inited\n#define txx_restart           tx1_restart\n#define bufx_r                buf1_r\n#define bufx_t                buf1_t\n#define rbufx                 rbuf1\n#define tbufx                 tbuf1\n#define uartx_init            uart1_init\n#define uartx_sendchar        uart1_sendchar\n#define uartx_getchar         uart1_getchar\n#define uartx_cbrx            uart1_cbrx\n#define uartx_cbrxof          uart1_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART2_BAUDRATE > 0 && (GPIOX_PORTNUM(UART2_RX) >= GPIOX_PORTNUM_A && RXBUF2_SIZE >= 4 || GPIOX_PORTNUM(UART2_TX) >= GPIOX_PORTNUM_A && TXBUF2_SIZE >= 4)\n#define UARTX                 USART2\n#define UARTX_IRQHandler      USART2_IRQHandler\n#define UARTX_IRQn            USART2_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_USART2EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART2_BAUDRATE\n#define UARTX_RX              UART2_RX\n#define UARTX_TX              UART2_TX\n#define TXBUFX_SIZE           TXBUF2_SIZE\n#define RXBUFX_SIZE           RXBUF2_SIZE\n#define UARTX_PRINTF          UART2_PRINTF\n#define uartx_inited          uart2_inited\n#define txx_restart           tx2_restart\n#define bufx_r                buf2_r\n#define bufx_t                buf2_t\n#define rbufx                 rbuf2\n#define tbufx                 tbuf2\n#define uartx_init            uart2_init\n#define uartx_sendchar        uart2_sendchar\n#define uartx_getchar         uart2_getchar\n#define uartx_cbrx            uart2_cbrx\n#define uartx_cbrxof          uart2_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART3_BAUDRATE > 0 && (GPIOX_PORTNUM(UART3_RX) >= GPIOX_PORTNUM_A && RXBUF3_SIZE >= 4 || GPIOX_PORTNUM(UART3_TX) >= GPIOX_PORTNUM_A && TXBUF3_SIZE >= 4)\n#define UARTX                 USART3\n#define UARTX_IRQHandler      USART3_IRQHandler\n#define UARTX_IRQn            USART3_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_USART3EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART3_BAUDRATE\n#define UARTX_RX              UART3_RX\n#define UARTX_TX              UART3_TX\n#define TXBUFX_SIZE           TXBUF3_SIZE\n#define RXBUFX_SIZE           RXBUF3_SIZE\n#define UARTX_PRINTF          UART3_PRINTF\n#define uartx_inited          uart3_inited\n#define txx_restart           tx3_restart\n#define bufx_r                buf3_r\n#define bufx_t                buf3_t\n#define rbufx                 rbuf3\n#define tbufx                 tbuf3\n#define uartx_init            uart3_init\n#define uartx_sendchar        uart3_sendchar\n#define uartx_getchar         uart3_getchar\n#define uartx_cbrx            uart3_cbrx\n#define uartx_cbrxof          uart3_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART4_BAUDRATE > 0 && (GPIOX_PORTNUM(UART4_RX) >= GPIOX_PORTNUM_A && RXBUF4_SIZE >= 4 || GPIOX_PORTNUM(UART4_TX) >= GPIOX_PORTNUM_A && TXBUF4_SIZE >= 4)\n#define UARTX                 UART4\n#define UARTX_IRQHandler      UART4_IRQHandler\n#define UARTX_IRQn            UART4_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART4EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART4_BAUDRATE\n#define UARTX_RX              UART4_RX\n#define UARTX_TX              UART4_TX\n#define TXBUFX_SIZE           TXBUF4_SIZE\n#define RXBUFX_SIZE           RXBUF4_SIZE\n#define UARTX_PRINTF          UART4_PRINTF\n#define uartx_inited          uart4_inited\n#define txx_restart           tx4_restart\n#define bufx_r                buf4_r\n#define bufx_t                buf4_t\n#define rbufx                 rbuf4\n#define tbufx                 tbuf4\n#define uartx_init            uart4_init\n#define uartx_sendchar        uart4_sendchar\n#define uartx_getchar         uart4_getchar\n#define uartx_cbrx            uart4_cbrx\n#define uartx_cbrxof          uart4_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART5_BAUDRATE > 0 && (GPIOX_PORTNUM(UART5_RX) >= GPIOX_PORTNUM_A && RXBUF5_SIZE >= 4 || GPIOX_PORTNUM(UART5_TX) >= GPIOX_PORTNUM_A && TXBUF5_SIZE >= 4)\n#define UARTX                 UART5\n#define UARTX_IRQHandler      UART5_IRQHandler\n#define UARTX_IRQn            UART5_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART5EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART5_BAUDRATE\n#define UARTX_RX              UART5_RX\n#define UARTX_TX              UART5_TX\n#define TXBUFX_SIZE           TXBUF5_SIZE\n#define RXBUFX_SIZE           RXBUF5_SIZE\n#define UARTX_PRINTF          UART5_PRINTF\n#define uartx_inited          uart5_inited\n#define txx_restart           tx5_restart\n#define bufx_r                buf5_r\n#define bufx_t                buf5_t\n#define rbufx                 rbuf5\n#define tbufx                 tbuf5\n#define uartx_init            uart5_init\n#define uartx_sendchar        uart5_sendchar\n#define uartx_getchar         uart5_getchar\n#define uartx_cbrx            uart5_cbrx\n#define uartx_cbrxof          uart5_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART6_BAUDRATE > 0 && (GPIOX_PORTNUM(UART6_RX) >= GPIOX_PORTNUM_A && RXBUF6_SIZE >= 4 || GPIOX_PORTNUM(UART6_TX) >= GPIOX_PORTNUM_A && TXBUF6_SIZE >= 4)\n#define UARTX                 USART6\n#define UARTX_IRQHandler      USART6_IRQHandler\n#define UARTX_IRQn            USART6_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB2ENR |= RCC_APB2ENR_USART6EN;\n#define UARTX_BRR_CALC        (UART_1_6_CLK) \/ UART6_BAUDRATE\n#define UARTX_RX              UART6_RX\n#define UARTX_TX              UART6_TX\n#define TXBUFX_SIZE           TXBUF6_SIZE\n#define RXBUFX_SIZE           RXBUF6_SIZE\n#define UARTX_PRINTF          UART6_PRINTF\n#define uartx_inited          uart6_inited\n#define txx_restart           tx6_restart\n#define bufx_r                buf6_r\n#define bufx_t                buf6_t\n#define rbufx                 rbuf6\n#define tbufx                 tbuf6\n#define uartx_init            uart6_init\n#define uartx_sendchar        uart6_sendchar\n#define uartx_getchar         uart6_getchar\n#define uartx_cbrx            uart6_cbrx\n#define uartx_cbrxof          uart6_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART7_BAUDRATE > 0 && (GPIOX_PORTNUM(UART7_RX) >= GPIOX_PORTNUM_A && RXBUF7_SIZE >= 4 || GPIOX_PORTNUM(UART7_TX) >= GPIOX_PORTNUM_A && TXBUF7_SIZE >= 4)\n#define UARTX                 UART7\n#define UARTX_IRQHandler      UART7_IRQHandler\n#define UARTX_IRQn            UART7_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1ENR |= RCC_APB1ENR_UART7EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART7_BAUDRATE\n#define UARTX_RX              UART7_RX\n#define UARTX_TX              UART7_TX\n#define TXBUFX_SIZE           TXBUF7_SIZE\n#define RXBUFX_SIZE           RXBUF7_SIZE\n#define UARTX_PRINTF          UART7_PRINTF\n#define uartx_inited          uart7_inited\n#define txx_restart           tx7_restart\n#define bufx_r                buf7_r\n#define bufx_t                buf7_t\n#define rbufx                 rbuf7\n#define tbufx                 tbuf7\n#define uartx_init            uart7_init\n#define uartx_sendchar        uart7_sendchar\n#define uartx_getchar         uart7_getchar\n#define uartx_cbrx            uart7_cbrx\n#define uartx_cbrxof          uart7_cbrxof\n#include \"uartx.h\"\n#endif\n\n#if UART8_BAUDRATE > 0 && (GPIOX_PORTNUM(UART8_RX) >= GPIOX_PORTNUM_A && RXBUF8_SIZE >= 4 || GPIOX_PORTNUM(UART8_TX) >= GPIOX_PORTNUM_A && TXBUF8_SIZE >= 4)\n#define UARTX                 UART8\n#define UARTX_IRQHandler      UART8_IRQHandler\n#define UARTX_IRQn            UART8_IRQn\n#define UARTX_CLOCLK_ON       RCC->APB1LENR |= RCC_APB1LENR_UART8EN\n#define UARTX_BRR_CALC        (UART_2_3_4_5_7_8_CLK) \/ UART8_BAUDRATE\n#define UARTX_RX              UART8_RX\n#define UARTX_TX              UART8_TX\n#define TXBUFX_SIZE           TXBUF8_SIZE\n#define RXBUFX_SIZE           RXBUF8_SIZE\n#define UARTX_PRINTF          UART8_PRINTF\n#define uartx_inited          uart8_inited\n#define txx_restart           tx8_restart\n#define bufx_r                buf8_r\n#define bufx_t                buf8_t\n#define rbufx                 rbuf8\n#define tbufx                 tbuf8\n#define uartx_init            uart8_init\n#define uartx_sendchar        uart8_sendchar\n#define uartx_getchar         uart8_getchar\n#define uartx_cbrx            uart8_cbrx\n#define uartx_cbrxof          uart8_cbrxof\n#include \"uartx.h\"\n#endif\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a;\n    int b;\n    int c;\n\n    printf(\"Digite o primeiro numero: \");\n    scanf(\"%d\",&a);\n\n    printf(\"Digite o segundo numero: \");\n    scanf(\"%d\",&b);\n\n    printf(\"Digite o terceiro numero: \");\n    scanf(\"%d\",&c);\n\n    if\n\n    ((a>b) && (b>c)){\n    printf (\"%d,%d,%d\", c,b,a);\n    }\n    if\n\n    ((a>b) && (c>b)){\n    printf (\"%d,%d,%d\", b,c,a);\n    }\n    if\n\n    ((b>a) && (a>c)){\n    printf (\"%d,%d,%d\", c,a,b);\n    }\n    if\n\n    ((b>c) && (c>a)){\n    printf (\"%d,%d,%d\", a,c,b);\n    }\n    if\n\n    ((c>b) && (b>a)){\n    printf (\"%d,%d,%d\", a,b,c);\n    }\n    if\n\n    ((c>a) && (a>b)){\n    printf (\"%d,%d,%d\", b,a,c);\n    }\n}\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a;\n    int b;\n\n    printf(\"Escolha um prato:\\n\\n\");\n    printf(\"---------------------------\\n\");\n    printf(\"1 - Lazanha\\n\");\n    printf(\"2 - Macarronada\\n\");\n    printf(\"3 - Strogonff\\n\");\n    printf(\"4 - Churrasco\\n\");\n    printf(\"5 - Sair\\n\");\n    printf(\"---------------------------\\n\\n\");\n\n    printf(\"Digite o prato: \");\n    scanf(\"%d\",&a);\n\n    while(a<=4)\n    {\n        printf(\"Escolha um prato:\\n\\n\");\n    printf(\"---------------------------\\n\");\n    printf(\"1 - Lazanha\\n\");\n    printf(\"2 - Macarronada\\n\");\n    printf(\"3 - Strogonff\\n\");\n    printf(\"4 - Churrasco\\n\");\n    printf(\"5 - Sair\\n\");\n    printf(\"---------------------------\\n\\n\");\n\n    printf(\"Digite o prato: \");\n    scanf(\"%d\",&a);\n    }\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a;\n    int b;\n    float c;\n    int d =0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n\n    printf(\"Digite o tamanho da sequencia: \");\n    scanf(\"%d\",&a);\n\n    for(b = 0; b < a; b++)\n    {\n        printf(\"Digite os numeros: \");\n        scanf(\"%f\",&c);\n\n        if(c >= 0 && c <= 25)\n        {\n            d++;\n        }else if(c >= 26 && c <= 50)\n        {\n            e++;\n        }else if(c >= 51 && c <= 75)\n        {\n            f++;\n        }else if(c >= 76 && c <= 100)\n        {\n            g++;\n        }\n\n    }\n        printf(\"[0...25]: %d\\n\",d);\n        printf(\"[26...50]: %d\\n\",e);\n        printf(\"[51...75]: %d\\n\",f);\n        printf(\"[76...100]: %d\\n\",g);\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a;\n    int b;\n    int c = 2;\n    int d;\n\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n\n    for(b = 0; b <= a; b++)\n    {\n        if(a>=0)\n        {\n            d = a \/ c;\n            c++;\n        }if(a % c == 0)\n        {\n            printf(\"%d \/ %d = %d\\n\",a,c,d);\n        }\n\n    }\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a;\n    int b;\n    int c;\n    int d = 0;\n    int cont = 0;\n\n    printf(\"digite o tamanho da sequencia: \");\n    scanf(\"%d\",&a);\n\n\n    for(b = 0;b < a; b++)\n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&c);\n\n        if(c < d)\n        {\n            cont++;\n\n            d = 0 + c;\n\n        }\n\n    }\n\n        if(cont <= 0)\n        {\n            printf(\"esta ordenado.\");\n\n        }else\n        {\n            printf(\"nao esta ordenada.\");\n        }\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int m;\n    int n;\n\n    printf(\"digite o primeiro numero: \");\n    scanf(\"%d\",&m);\n\n    printf(\"digite o segundo numero: \");\n    scanf(\"%d\",&n);\n\nwhile ( m!=n)\n\n{\n\nif (m > n){\n\n    m = m - n;\n\n}else\n\n    n = n - m;\n\n}\n    printf(\"o maximo divisor comum eh:%d\", m);\n}\n\n\n\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\nint main() {\n\n    int primo;\n    int a;\n    int b;\n    int c;\n\n\n    printf(\"Digite um numero: \");\n    scanf(\"%d\", &a);\n\n\n\n    for (b=a; ; b++) {\n\n\n        primo = 1;\n        for (c=2; c<b; c++) {\n\n            if (b % c == 0)\n                primo = 0;\n}\n\n                if (primo == 1) {\n            printf(\"\\n\\nO numero a direita primo mais proximo: %d\\n\", b);\n            break;\n        }\n    }\n\n\n\n\n    for (b=a;b > 0; b--) {\n\n\n        primo = 1;\n        for (c=2; c<b; c++) {\n\n            if (b % c == 0)\n                primo = 0;\n}\n\n                if (primo == 1) {\n            printf(\"O numero a esquerda primo mais proximo: %d\\n\", b);\n            break;\n        }\n    }\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    unsigned long int dec;\n    unsigned long int c;\n    unsigned long int d = 1;\n    unsigned long int e = 0;\n    unsigned long int f = 1;\n    unsigned long int g;\n\n    printf(\"Digite um numero decimal: \");\n    scanf(\"%lu\",&dec);\n\n\n    while(dec != 0)\n    {\n        c = dec % 2;\n        printf(\"Passo %3lu: %10lu\/2, Resto = %3lu, Quociente = %8lu\\n\",d++,dec,c, dec \/ 2);\n\n        dec \/= 2;\n        e += c * f;\n        f *= 10;\n\n    }\n        printf(\"o numero em binario eh: %lu\",e);\n        printf(\"\\n\");\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int c; \n    int l; \n    int a;\n    int b = 1;\n\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n\n  for (l=0; l<a; l++)\n    {\n        for (c=0; c<a;c++)\n        {\n           if (l == c )\n           {\n\n               printf(\"%d \",b);\n               b++;\n           }else\n            {\n                printf(\"  \");\n            }\n\n        }\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n\n\n\n\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\nint c; \nint l; \nint a;\nint b;\n\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n\n    for (l=1; l<a; l++)\n    {\n        for (c=1; c<=a; c++)\n        {\n            if(c<=l){\n\n                    b = c;\n                printf(\"%d \",b);\n\n            }\n        }\n\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int c; \n    int l; \n\n\nfor (l=1; l<6; l++)\n    {\n        for (c=1; c<6; c++)\n        {\n            if(c<l){\n                printf(\"# \");\n\n            }else if (c == l)\n                {\n                    printf(\"+ \");\n\n                }else if(c > 1)\n                {\n                    printf(\"# \");\n                }\n\n        }\n\n\n\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int d1,d2,d3,d4,d5,d6;\n    unsigned long int contadora = 0;\n\n    for (d1 = 1; d1<=60;d1++)\n\n        if(d1 %2 != 1)\n\n    for (d2 = d1+1; d2<=60;d2++)\n\n        if(d2 %2 != 0)\n\n    for (d3 = d2+1; d3<=60;d3++)\n\n        if(d3 %2 != 1)\n\n    for (d4 = d3+1; d4<=60;d4++)\n\n        if(d4 % 2 != 0)\n\n    for (d5 = d4+1; d5<=60;d5++)\n\n        if(d5 % 2 !=1)\n\n    for (d6 = d5+1; d6<=60;d6++)\n\n        if(d6 % 2 != 0)\n\n\n    printf(\"[%d] [%d] [%d] [%d] [%d] [%d] \\n\",d1,d2,d3,d4,d5,d6);\n    contadora++;\n\n\n    printf(\"%u\",contadora);\n\n\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float a[10],b[10];\n    int i;\n\n    for(i=0; i<10; i++)\n    {\n        printf(\" digite o %d valor: \",i);\n        scanf(\"%f\",&a[i]);\n    }\n    for(i=0; i<10; i++)\n        b[i] = a[i] * a[i];\n    printf(\"\\n\\nConjunto 1: \\n\");\n\n    for(i=0; i<10; i++)\n    printf(\"\\n%2.f \",a[i]);\n    printf(\"\\n\\nConjunto 2: \\n\");\n\n    for(i=0; i<10; i++)\n\n        printf(\" \\n%2.f \",b[i]);\n\n\n\n\nreturn 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\n     int i, maior, menor,posmaior,x;\n     int vet[10];\n    for (i = 0 ; i < 10 ; i++){\n        printf(\"Digite o valor:\\n\");\n        scanf(\"%d\",&vet[i]);\n\n    }\n    maior=vet[0];\n    posmaior=0;\n    for (i=1;i<10;i++){\n        if(vet[i]>maior){\n            maior=vet[i];\n            posmaior=i;\n        }\n    }\n    menor=vet[0];\n    for(i=1;i<10;i++){\n    if(vet[i]<menor){\n    menor=vet[i];\n        }\n    }\n         printf(\"vetor: \");\n    for (i = 0 ; i < 10 ; i++){\n\n        printf(\"%d \",vet[i]);\n\n    }\n    printf(\"\\nO maior valor eh: %d \\n \",maior);\n    printf(\"Posicao: %d\\n\",posmaior);\n\n\n\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int vetor[6];\n\n    for(int i=0; i<6; i++){\n\n        printf(\"digite os valores do vetor: \\n\");\n        scanf(\"%d\",&vetor[i]);\n\n    }\n       printf(\"\\nRESULTADO\\n\");\n        for(int i=5; i>=0; i--){\n\n        printf(\"%d \",vetor[i]);\n\n\n\n        }\n\n\n\n\n\n\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a[10];\n    int b[10];\n    int c[10];\n\n    int i;\n                printf(\"--------------------------------------\\n\");\n                printf(\"digite um numero para o primeiro vetor\\n\");\n                printf(\"--------------------------------------\\n\\n\");\n\n    for(i=0;i<10;i++) \n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&a[i]);\n    }\n\n                printf(\"--------------------------------------\\n\");\n                printf(\"digite um numero para o segundo vetor\\n\");\n                printf(\"--------------------------------------\\n\\n\");\n\n    for(i=0;i<10;i++) \n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&b[i]);\n    }\n\n                printf(\"\\n------------------------------------------\\n\");\n    for(i=0;i<10;i++) \n    {\n        c[i] = a[i] - b[i];\n        printf(\"[%d] - [%d] = [%d]\\n\",a[i],b[i],c[i]);\n    }\n                printf(\"\\n------------------------------------------\\n\");\n\n\n\n\n\n\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n\n{\n    int i,j,z;\n    int a[3];\n    int b[3];\n    int c[3];\n\n\n\n    for(i = 0; i < 3; i++){\n\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n\n    }\n\n        printf(\"\\n \\n\");\n\n    for(j = 0; j < 3; j++){\n\n        printf(\"Digite um valor para b: \", j);\n        scanf(\"%d\",&b[j]);\n\n    }\n\n\n    for(i = 0; i < 3; i++){\n    printf(\"\\n vetor a:  %d \\n \", a[i]);\n    }\n\n    for(j = 0; j < 3; j++){\n    printf(\"\\n vetor b: %d \\n \", b[j]);\n    }\n\n\n    for(z = 0; z < 3; z++){\n\n        if( z %2 ==0){\n\n            c[z] = a[z];\n        }\n\n        else if( z %2 != 0){\n            c[z] = b[z];\n\n        }\n\n        printf(\"\\n vetor c: %d \\n\",c[z]);\n    }\n\n\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n\n{\n\n    int i,j,z;\n    int conjunto1[5];\n    int conjunto2[5];\n\n\n    for(i = 0; i < 5; i++){\n\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&conjunto1[i]);\n\n    }\n\n        printf(\"\\n \\n\");\n\n    for(j = 0; j < 5; j++){\n\n        printf(\"Digite um valor para b: \", j);\n        scanf(\"%d\",&conjunto2[j]);\n\n    }\n\n\n\n        int produto = 0;\n\n       for (int i = 0; i < 5; i++){\n\n       produto = produto + conjunto1[i] * conjunto2[i];\n\n\n        }\n\n        printf(\" \\n produto escalar dos dois conjuntos eh: %d \\n\", produto);\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n\n{\n\n    float maior_tam_aluno = 0;\n    int num_maior_aluno = 0;\n\n    float menor_tam_aluno = 100000;\n    int num_menor_aluno = 0;\n\n    int num_aluno[3];\n    float altura_aluno[3];\n    int i;\n    int j = 0;\n\n    for(i = 0; i <3; i++){\n\n\n\n            printf(\"Digite o numero do aluno %d: \",i);\n            scanf(\"%d\",&num_aluno[i]);\n\n            printf(\"Digite a altura do aluno %d: \",j);\n            scanf(\"%f\",&altura_aluno[i]);\n\n\n\n        }\n            for(j = 0; j <3; j++){\n\n            if(altura_aluno[j] > maior_tam_aluno){\n\n                maior_tam_aluno = altura_aluno[j];\n                num_maior_aluno = num_aluno[j];\n            }\n\n            if(altura_aluno[j] < menor_tam_aluno){\n                menor_tam_aluno = altura_aluno[j];\n                num_menor_aluno = num_aluno[j];\n            }\n\n\n\n    }\n\n    printf(\"\\n O maior aluno eh: %d %.2f \\n\",num_maior_aluno, maior_tam_aluno);\n    printf(\"\\n O menor aluno eh: %d %.2f \\n\",num_menor_aluno, menor_tam_aluno);\n\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n\n{\n\n    int vetor[50];\n    int i;\n\n\n    for(i= 0; i < 50; i++){\n\n        if(i %7 != 0 && i % 10 != 7 ){\n            printf(\"\\n %d \\n\", i);\n\n        }\n\n\n        else{\n            continue;\n        }\n    }\n\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat calculaDesvioPadrao(float vet[]);\n\nint main()\n{\n        int i;\n\n        float vet[10];\n\n\n        for (i = 0; i < 10; ++i){\n\n            printf(\"Digite um numero: \");\n            scanf(\"%f\", &vet[i]);\n        }\n            printf(\"\\n Desvio Padrao = %.6f\", calculaDesvioPadrao(vet));\n\n            system(\"PAUSE\");\n            return 0;\n}\n\n    float calculaDesvioPadrao(float vet[]) {\n\n        float soma = 0.0, mean, desvio = 0.0;\n        int i;\n\n        for (i = 0; i < 10; i++) {\n            soma += vet[i];\n        }\n\n        mean = soma \/ 10;\n        for (i = 0; i < 10; i++)\n            desvio += pow(vet[i] - mean, 2);\n        return sqrt(desvio \/ 10);\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main()\n\n{\n\n    int vetor[5];\n    int primos[5];\n    int i,j;\n    int c = 0;\n    int t = 0;\n\n\n        for(i = 0; i < 5; i++){\n\n\n            printf(\"Digite um numero %d: \",i+1);\n            scanf(\"%d\",&vetor[i]);\n\n        }\n\n        for(i= 0; i < 5; i++){\n\n            c = 0;\n\n\n\n            for(j =2; j < vetor[i]; j++){\n\n                if(vetor[i]%j == 0){\n                    c=1;\n                    break;\n                }\n\n            }\n\n        if(c == 0){\n            primos[t] = vetor[i];\n            t++;\n        }\n    }\n\n    printf(\"\\n \\n Numeros primos do array : \\n \\n\");\n\n    for(i =0; i < t; i++){\n        printf(\"\\n %d \\n\",primos[i]);\n    }\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main()\n\n{\n        int i,j,z;\n    int a[5];\n    int b[5];\n    int c[5];\n\n\n\n    for(i = 0; i < 5; i++){\n\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n\n    }\n\n        printf(\"\\n \\n\");\n\n\n\n\n    for(z = 0; z < 5; z++){\n\n        if( z %2 ==0){\n\n            c[z] = a[z];\n        printf(\"\\n vetor c(impar): %d \\n\",c[z]);\n        }\n\n         if( z %2 != 0){\n            b[z] = a[z];\n\n        printf(\"\\n vetor b (par): %d \\n\",b[z]);\n        }\n\n    }\n\n\n\n\n    system(\"PAUSE\");\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint quantidadeTotalPar = 0;\nint quantidadeTotalImpar = 0;\nint pares[6];\nint impares[6];\n\nvoid calcularTotal(int numero[6]) {\n\n    for (int i = 0; i < 6; i++) {\n\n        if (numero[i] % 2 == 0) {\n\n            quantidadeTotalPar = quantidadeTotalPar + numero[i];\n            pares[i] = numero[i];\n\n        } else {\n\n            quantidadeTotalImpar = quantidadeTotalImpar + numero[i];\n            impares[i] = numero[i];\n\n        }\n    }\n}\n\nvoid imprimirResultados() {\n\n    printf(\"Soma total numeros pares digitados: %d\\n\\n\", quantidadeTotalPar);\n    printf(\"Valores pares digitados: \\n\");\n\n    for (int i = 0; i < 6; i++) {\n\n        if (pares[i] > 0) {\n\n            printf(\"%d\\n\", pares[i]);\n        }\n    }\n\n    printf(\"Soma total numeros impares digitados: %d\\n\\n\", quantidadeTotalImpar);\n    printf(\"Valores impares digitados: \\n\");\n\n    for (int i = 0; i < 6; i++) {\n\n        if (impares[i] > 0) {\n\n            printf(\"%d\\n\", impares[i]);\n        }\n    }\n\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    int numero[6];\n\n    for (int i = 0; i < 6; i++) {\n\n        printf(\"Preencha o valor numero %d\\n\", i);\n        scanf(\"%d\", &numero[i]);\n    }\n\n    system(\"cls\");\n\n    calcularTotal(numero);\n    imprimirResultados();\n\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint vet1[10];\nint vet2[10];\nint intersecao[10];\n\nvoid criarVetorIntersecao() {\n\n    for (int i = 0; i < 10; i++) {\n\n        for (int j = 0; j < 10; j++) {\n\n            if (vet1[i] == vet2[j]) {\n                intersecao[i] = vet1[i];\n            }\n        }\n    }\n}\n\nint verificarValorRepetido(int vet1[10], int valorComparar) {\n\n    for (int i = 0; i < 10; i++) {\n\n        if (vet1[i] == valorComparar) {\n            return valorComparar;\n        }\n\n    }\n\n    return 0;\n}\n\nvoid imprimirVetorIntersecao() {\n\n    for (int i = 0; i < 10; i++) {\n\n        if (intersecao[i] > 0) {\n\n            printf(\"%d\\n\", intersecao[i]);\n        }\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    for (int i = 0; i < 10; i++) {\n\n        int valorAlocar = 0;\n\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n\n        int retorno = verificarValorRepetido(vet1, valorAlocar);\n\n        if (retorno != 0) {\n\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n\n            vet1[i] = valorAlocar;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n\n        int valorAlocar = 0;\n\n        printf(\"Preencha o valor do vetor2 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n\n        int retorno = verificarValorRepetido(vet2, valorAlocar);\n\n        if (retorno != 0) {\n\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n\n            vet2[i] = valorAlocar;\n        }\n    }\n\n    system(\"cls\");\n\n    printf(\"\\n ------------------------------ \\n\");\n\n    criarVetorIntersecao();\n    imprimirVetorIntersecao();\n\n    return 0;\n}\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint vet1[10];\nint vet2[10];\nint uniao[20];\n\nvoid populaVetorUniao() {\n\n    for (int c = 0; c < 10; c++) {\n        uniao[c] = vet1[c];\n    }\n\n    for (int i = 0; i <= 10; i++) {\n        int valorJaInseridoUniao = 0;\n\n        for (int j = 0; j < 10; j++) {\n\n            if (vet2[i] == uniao[j]) {\n                valorJaInseridoUniao = 1;\n            }\n        }\n\n        if (valorJaInseridoUniao == 0) {\n            uniao[i + 10] = vet2[i];\n        }\n    }\n}\n\nint verificarValorRepetido(int valorComparar) {\n\n    for (int i = 0; i < 10; i++) {\n\n        if (vet1[i] == valorComparar) {\n            return valorComparar;\n        }\n\n        if (vet2[i] == valorComparar) {\n            return valorComparar;\n        }\n\n    }\n\n    return 0;\n}\n\nvoid imprimirVetores() {\n\n    for (int i = 0; i < 20; i++) {\n\n        printf(\"%d\\n\", uniao[i]);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    for (int i = 0; i < 10; i++) {\n\n        int valorAlocar = 0;\n\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n\n        int retorno = verificarValorRepetido(valorAlocar);\n\n        if (retorno != 0) {\n\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\", retorno);\n            i--;\n            continue;\n        } else {\n\n            vet1[i] = valorAlocar;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n\n        int valorAlocar = 0;\n\n        printf(\"Preencha o valor do vetor2 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n\n        int retorno = verificarValorRepetido(valorAlocar);\n\n        if (retorno != 0) {\n\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n\n            vet2[i] = valorAlocar;\n        }\n    }\n\n    system(\"cls\");\n\n    printf(\"\\n ------------------------------ \\n\");\n\n    populaVetorUniao();\n\n    printf(\"--- Uniao entre vetores ---\\n\");\n\n    imprimirVetores(uniao, 10);\n\n    printf(\"--------------------------------\\n\");\n\n    return 0;\n}\n\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint vetor[15];\n\nvoid compactarVetor() {\n    for (int i = 0; i < 15; i++) {\n\n        if (vetor[i] == 0) {\n\n            for (int j = i; j < 15; j++) {\n\n                vetor[j] = vetor[j + 1];\n            }\n        }\n    }\n}\n\nvoid imprimirVetor() {\n\n    for (int i = 0; i < 15; i++) {\n\n        if (vetor[i] != 0) {\n            printf(\"Posicao %d valor do vetor: %d\\n\", i, vetor[i]);\n        }\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    for (int i = 0; i < 15; i++) {\n\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &vetor[i]);\n    }\n\n    system(\"cls\");\n\n    compactarVetor();\n    imprimirVetor();\n\n    return 0;\n}\n\n\n\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint vetor[11];\nint posicaoReporNumero;\n\nvoid ordenarVetorCrescente() {\n\n    for (int i = 0; i <= 5; i++) {\n\n        int menorValorPosicao = buscarMenorValor(i);\n\n        int valorPosicaoAnterior = vetor[i];\n        vetor[i] = menorValorPosicao;\n        vetor[posicaoReporNumero] = valorPosicaoAnterior;\n    }\n}\n\nvoid ordenarVetorDecrescente() {\n\n    for (int i = 6; i <= 11; i++) {\n\n        int maiorValorPosicao = buscarMaiorValor(i);\n\n        int valorPosicaoAnterior = vetor[i];\n        vetor[i] = maiorValorPosicao;\n        vetor[posicaoReporNumero] = valorPosicaoAnterior;\n    }\n}\n\nint buscarMenorValor(int j) {\n\n    int valorAAssumirPosicao = vetor[j];\n    posicaoReporNumero = NULL;\n\n    for (int i = j; i < 11; i++) {\n\n        if (valorAAssumirPosicao > vetor[i]) {\n\n            valorAAssumirPosicao = vetor[i];\n            posicaoReporNumero = i;\n        }\n    }\n\n    return valorAAssumirPosicao;\n}\n\nint buscarMaiorValor(int j) {\n\n    int valorAAssumirPosicao = vetor[j];\n    posicaoReporNumero = NULL;\n\n    for (int i = j; i < 11; i++) {\n\n        if (valorAAssumirPosicao < vetor[i]) {\n\n            valorAAssumirPosicao = vetor[i];\n            posicaoReporNumero = i;\n        }\n    }\n\n    return valorAAssumirPosicao;\n}\n\nvoid imprimirVetor() {\n\n    for (int i = 0; i < 11; i++) {\n\n        printf(\"Posicao %d valor do vetor: %d\\n\", i, vetor[i]);\n    }\n}\n\nint main()\n{\n    for (int i = 0; i < 11; i++){\n        printf(\"Preencha o valor do vetor numero %d\\n\", i);\n        scanf(\"%d\", &vetor[i]);\n    }\n\n    ordenarVetorCrescente();\n    ordenarVetorDecrescente();\n    imprimirVetor();\n\n    return 0;\n}\n\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int i, x, aux, v[10];\n\n    for(i=0;i<10;i++){\n        printf(\"Digite o valor da posicao [%i]: \", i);\n        scanf(\"%i\", &v[i]);\n    }\n\n\n    for(i=0;i<10;i++){\n        for(x=i+1;x<10;x++){\n            if(v[i]>v[x]){\n\n                aux=v[i];\n                v[i]=v[x];\n                v[x]=aux;\n            }\n        }\n    }\n\n     for(i=0;i<10;i++){\n         printf(\"\\nO valor da posicao [%i] agora eh: [%i]\", i,v[i]);\n     }\n\n\n    return 0;\n}\n"}
{"target":"RobsonRafaeldeOliveiraBasseto","func":"\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fatorial(int x);\nint comb(int lin, int col);\n\nint main()\n{\n    int lin, col, n, num;\n\n    printf(\"Digite a quantidade de linhas: \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n\n    for(lin=0;lin<=n;lin++){\n        for(col=n-lin;col!=0;col--){\n            printf(\"   \");\n        }\n        for(col=0;col<=lin;col++){\n            num = comb(lin, col);\n            printf(\" %4d \", num);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nint fatorial(int x){\n  int i, fatorial=1;\n\n  for(i=x;i>0;i--){\n    fatorial = fatorial*i;\n  }\n  return fatorial;\n}\n\nint comb(int lin, int col){\n\n return fatorial(lin) \/ (fatorial(col) * fatorial(lin-col));\n}\n"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nvoid insertion_sort(int array[MAX], int length);\n\nvoid main()\n{\n    int i = 0;\n    int size = 0;\n    \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    insertion_sort(input_array, size);\n\n    \n    printf(\"\\nAfter Insertion Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n\n    printf(\"\\n\");\n}\n\n\nvoid insertion_sort(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n\n    for(i=1; i<size; i++)\n    {\n        j = i;\n        while((array[j] < array[j-1]) && j>0)\n        {\n            \n            temp = array[j];\n            array[j] = array[j-1];\n            array[j-1] = temp;\n            j--;\n        }\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX_WEIGHT 20\n#define MAX_ARR_SIZE 3\n\n\nstruct Object\n{\n    char *name;\n    float profit;\n    float weight;\n    float pw_ratio;\n};\n\n\nvoid sort_decreasing(struct Object arr[]);\n\n\nvoid main()\n{\n    int i, j, k = 0;\n    int remaining_weight = MAX_WEIGHT;  \n    double total_profit = 0.0;\n\n    \n    struct Object obj[MAX_ARR_SIZE];\n\n    \n    obj[0].name = \"Object1\";\n    obj[1].name = \"Object2\";\n    obj[2].name = \"Object3\";\n\n    \n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        printf(\"\\nEnter PROFIT%d: \", (i+1));\n        scanf(\"%f\", &obj[i].profit);\n        printf(\"\\nEnter WEIGHT%d: \", (i+1));\n        scanf(\"%f\", &obj[i].weight);\n    }\n\n    \n    for(j=0; j<MAX_ARR_SIZE; j++)\n        obj[j].pw_ratio = (obj[j].profit \/ obj[j].weight);\n    \n    \n    printf(\"\\nObject Details:- \\n\");\n    for(k=0; k<MAX_ARR_SIZE; k++)\n    {\n        printf(\"\\n------------------------------\");\n        printf(\"\\nNAME: %s\", obj[k].name);\n        printf(\"\\nPROFIT: %f\", obj[k].profit);\n        printf(\"\\nWEIGHT: %f\", obj[k].weight);\n        printf(\"\\nProfit\/Weight Ratio: %f\", obj[k].pw_ratio);\n    }\n    printf(\"\\n\");\n\n    \n    sort_decreasing(obj);\n\n    \n    printf(\"\\nObjects after Sorting:- \\n\");\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        printf(\"\\n------------------------------\");\n        printf(\"\\nNAME: %s\", obj[i].name);\n        printf(\"\\nPROFIT: %f\", obj[i].profit);\n        printf(\"\\nWEIGHT: %f\", obj[i].weight);\n        printf(\"\\nProfit\/Weight Ratio: %f\", obj[i].pw_ratio);\n    }\n    printf(\"\\n\");\n\n    \n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        if((remaining_weight>0) && (obj[i].weight<=remaining_weight))\n        {\n            remaining_weight = remaining_weight - obj[i].weight;\n            total_profit = total_profit + obj[i].profit;\n            printf(\"\\nObject with profit %f and weight %f is selected...\", obj[i].profit, obj[i].weight);\n            printf(\"\\nRemaining Capacity in the KnapSack: %d\", (remaining_weight));\n            printf(\"\\nTotal Profit upto now: %f\", total_profit);\n        }\n        else if(remaining_weight > 0)\n        {\n            total_profit = total_profit + ((obj[i].profit * remaining_weight) \/ obj[i].weight);\n            printf(\"\\nObject with profit %f and weight %f is selected...\", obj[i].profit, obj[i].weight);\n            printf(\"\\nRemaining Capacity in the KnapSack: %d\", (remaining_weight));\n            printf(\"\\nTotal Profit upto now: %f\", total_profit);\n            break;\n        }   \n    }\n\n    printf(\"\\n\\nTotal Profit of Knapsack: %f\\n\", total_profit); \n}\n\n\nvoid sort_decreasing(struct Object arr[])\n{\n    int i, j = 0;\n    float temp = 0;\n    char *temp1;\n\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        for(j=i+1; j<MAX_ARR_SIZE; j++)\n        {\n            if(arr[i].pw_ratio < arr[j].pw_ratio)\n            {\n                \n                \n                temp = arr[j].pw_ratio;\n                arr[j].pw_ratio = arr[i].pw_ratio;\n                arr[i].pw_ratio = temp;\n\n                \n                temp1 = arr[j].name;\n                arr[j].name = arr[i].name;\n                arr[i].name = temp1;\n\n                \n                temp = arr[j].profit;\n                arr[j].profit = arr[i].profit;\n                arr[i].profit = temp;\n\n                \n                temp = arr[j].weight;\n                arr[j].weight = arr[i].weight;\n                arr[i].weight = temp;\n            }\n        }\n    }\n}\n\n\n"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nint linear_search(int array[MAX], int length, int key);\n\nvoid main()\n{\n    int i, size, key = 0;\n        \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    printf(\"\\nEnter the key to be searched: \\n\");\n    scanf(\"%d\", &key);\n\n    \n    printf(\"\\n%d is found in Index %d\\n\", key, linear_search(input_array, size, key));\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n\n    printf(\"\\n\");\n}\n\n\nint linear_search(int array[MAX], int length, int key)\n{\n    int i, index = -1;\n    int size = length;\n\n    for(i=0; i<size; i++)\n    {\n        \n        if(array[i] == key)\n        {\n            index = i;\n            break;\n        }\n        else\n            continue;\n    }\n\n    return index;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid add_matrices(int m1[R][C], int m2[R][C]);\nvoid subtract_matrices(int m1[R][C], int m2[R][C]);\nvoid multiply_matrices(int m1[R][C], int m2[R][C]);\nvoid display_matrix(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int choice = 0;\n    int contin = 0;\n\n    int matrix1[R][C];\n    int matrix2[R][C];\n    int matrix3[R][C];\n\n    \n    printf(\"\\nEnter elements of Matrix1...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix1[i][j]);\n        }\n    }\n    printf(\"\\nEnter elements of Matrix2...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix2[i][j]);\n        }\n    }\n\n    do\n    {\n        printf(\"\\nPress:- \");\n        printf(\"\\n1 for ADDITION\");\n        printf(\"\\n2 for SUBTRACTION\");\n        printf(\"\\n3 for  MULTIPLICATION\");\n        printf(\"\\n4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice)\n        {\n            case 1:\n                add_matrices(matrix1, matrix2);\n                break;\n\n            case 2:\n                subtract_matrices(matrix1, matrix2);\n                break;\n\n            case 3:\n                multiply_matrices(matrix1, matrix2);\n                break;\n\n            case 4:\n                exit(0);\n                break;\n\n            default:\n                printf(\"\\nEnter a correct choice...\");\n        }\n        printf(\"\\nPress 5 to continue, else press any other number: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 5);\n}\n\n\nvoid add_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j = 0;\n    int output[R][C];\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            output[i][j] = m1[i][j] + m2[i][j];\n        }\n    }\n\n    \n    printf(\"\\nResultant Matrix after ADDITION:- \\n\");\n    display_matrix(output);\n}\n\n\nvoid subtract_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j = 0;\n    int output[R][C];\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            output[i][j] = m1[i][j] - m2[i][j];\n        }\n    }\n\n    \n    printf(\"\\nResultant Matrix after SUBTRACTION:- \\n\");\n    display_matrix(output);\n}\n\n\nvoid multiply_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j, k = 0;\n    int sum = 0;\n    int output[R][C];\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            for(k=0; k<R; k++)\n            {\n                sum += m1[i][k] * m2[k][j];\n            }\n            output[i][j] = sum;\n            sum = 0;\n        }\n    }\n\n    \n    printf(\"\\nResultant Matrix after MULTIPLICATION:- \\n\");\n    display_matrix(output);\n}\n\n\nvoid display_matrix(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nvoid odd_even_sort(int array[MAX], int length);\n\nvoid main()\n{\n    int i = 0;\n    int size = 0;\n    \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    odd_even_sort(input_array, size);\n\n    \n    printf(\"\\nAfter Odd-Even Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n\n    printf(\"\\n\");\n}\n\n\nvoid odd_even_sort(int array[MAX], int length)\n{\n    int i, j, temp, flag = 0;\n    int size = length;\n\n    do\n    {\n        flag = 0;\n\n        \n        for(i=0; i<size-1; i=i+2)\n        {\n            \n            if(array[i] > array[i+1])\n            {\n                temp = array[i+1];\n                array[i+1] = array[i];\n                array[i] = temp;\n                flag = 1;\n            }\n        }\n\n        \n        for(j=1; j<size-1; j=j+2)\n        {\n            \n            if(array[j] > array[j+1])\n            {\n                temp = array[j+1];\n                array[j+1] = array[j];\n                array[j] = temp;\n                flag = 1;\n            }\n        }\n    }while(flag);\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid display(int matrix[R][C]);\nint check_Identity_Matrix(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j, k, temp, sum = 0;\n    int rows = R;\n    int columns = C;\n    int input_matrix[R][C];\n    int transposed_matrix[R][C];\n    int product_matrix[R][C];\n    \n\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n\n    \n    temp = rows;\n    rows = columns;\n    columns = rows;\n\n    \n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            transposed_matrix[i][j] = input_matrix[j][i];\n        }\n    }\n\n    \n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            for(k=0; k<R; k++)\n            {\n                sum += input_matrix[i][k] * transposed_matrix[k][j];\n            }\n            product_matrix[i][j] = sum;\n            sum = 0;\n        }\n    }\n\n    \n    if(check_Identity_Matrix(product_matrix) == 0)\n        printf(\"\\nInput Matrix is orthogonal...\\n\");\n    else\n        printf(\"\\nInput Matrix is NOT orthogonal...\\n\");\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nint check_Identity_Matrix(int matrix[R][C])\n{\n    int i, j, flag, output = 0;\n    int rows = R;\n    int columns = C;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            \n            if((i==j) && (matrix[i][j]==1))\n                continue;\n\n            else if((i!=j) && (matrix[i][j]==0))\n                continue;\n            \n            else\n            {\n                flag = 1;\n                break;\n            }\n        }\n\n        \n        if(flag == 1)\n        {\n            output = 1;\n            break;\n        }\n    }\n\n    \n    return output;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#include<string.h>\n\n\nstruct Book\n{\n    int book_id;\n    float book_price;\n    char book_name[100];\n}b;\n\n\nvoid displayBookDetails(struct Book b1);\n\n\nvoid main()\n{\n    \n    printf(\"\\nEnter Book_ID: \");\n    scanf(\"%d\", &b.book_id);\n    printf(\"\\nEnter Book_Price: \");\n    scanf(\"%f\", &b.book_price);\n    printf(\"\\nEnter Book_Name: \");\n    scanf(\"%s\", &b.book_name);\n\n    \n    displayBookDetails(b);\n}\n\n\nvoid displayBookDetails(struct Book b1)\n{\n    \n    printf(\"\\nGetting the Book Details....\\n\");\n    printf(\"\\nBook_ID: %d\", b1.book_id);\n    printf(\"\\nBook_Price: %f\", b1.book_price);\n    printf(\"\\nBook_Name: %s\", b1.book_name);\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nvoid selection_sort(int array[MAX], int length);\n\nvoid main()\n{\n    int i = 0;\n    int size = 0;\n    \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    selection_sort(input_array, size);\n\n    \n    printf(\"\\nAfter Selection Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n\n    printf(\"\\n\");\n}\n\n\nvoid selection_sort(int array[MAX], int length)\n{\n    int i, j, temp, pointer = 0;\n    int size = length;\n\n    for(i=0; i<size-1; i++)\n    {\n        \n        pointer = i;\n        for(j=i+1; j<size; j++)\n        {\n            \n            if(array[pointer] > array[j])\n            {\n                \n                pointer = j;\n            }\n\n            if(pointer != i)\n            {\n                \n                temp = array[pointer];\n                array[pointer] = array[i];\n                array[i] = temp;\n            }\n        }\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nvoid sorting(int array[MAX], int length);\n\n\nvoid main()\n{\n    int i = 0;\n    int size = 0;\n    \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n}\n\n\nvoid sorting(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n    \n    for(i=0; i<length; i++)\n    {\n        for(j=i+1; j<length; j++)\n        {\n            \n            if(array[i] > array[j])\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n\n    \n    display(array, size);\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#define MAX 10\n\n\nvoid display(int array[MAX], int length);\nvoid sorting(int array[MAX], int length);\n\n\nvoid main()\n{\n    int i = 0;\n    int size = 0;\n    \n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n\n    \n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n\n    \n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}\n\n\nvoid display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n\n    printf(\"\\n\");\n}\n\n\nvoid sorting(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n    \n    for(i=0; i<length; i++)\n    {\n        for(j=i+1; j<length; j++)\n        {\n            \n            if(array[i] < array[j])\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n\n    \n    display(array, size);\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid display(int matrix[R][C]);\nint check_sparse(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n\n    printf(\"\\nEnter elements of input matrix...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nOriginal Matrix is a follows:- \\n\");\n    display(input_matrix);\n\n    \n    if(check_sparse(input_matrix) == 1)\n        printf(\"\\nIt is a Sparse Matrix...\\n\");\n    else\n        printf(\"\\nIt is not a Sparse Matrix...\\n\");\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n    int rows = R;\n    int columns = C;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nint check_sparse(int matrix[R][C])\n{\n    int i, j, output = 0;\n    int size, count_zeros = 0;\n    int rows = R;\n    int columns = C;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            if(matrix[i][j] == 0)\n                count_zeros++;\n            else\n                continue;\n        }\n    }\n\n    \n    size = rows * columns;\n    if(count_zeros > (size\/2))\n        output = 1;\n\n    return output;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#include<stdlib.h>\n\n#define size 10\n\n\nstruct Stack\n{\n    int array[size];\n    int top;\n}ptr;\n\n\n\nvoid push();\nvoid pop();\nvoid display();\nint checkStackFull();\nint checkStackEmpty();\n\n\nvoid main()\n{\n    int choice = 0;\n    int contin = 0;\n    ptr.top = -1;\n\n    do{\n        printf(\"\\nPress 1 for PUSH\");\n        printf(\"\\nPress 2 for POP\");\n        printf(\"\\nPress 3 for DISPLAY\");\n        printf(\"\\nPress 4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice)\n        {\n            case 1:\n                \n                push();\n                break;\n\n            case 2:\n                \n                pop();\n                break;\n\n            case 3:\n                \n                display();\n                break;\n\n            case 4:\n                \n                exit(0);\n                break;\n\n            default:\n                printf(\"\\nEnter a valid choice!!!\");\n        }\n        printf(\"\\nPress 1 to continue, else press any other number to EXIT: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 1);\n}\n\n\n\nvoid push()\n{\n    int flag = checkStackFull();\n    if(flag == 1)\n    {\n        int element = 0;\n        printf(\"\\nEnter the element to be pushed: \");\n        scanf(\"%d\", &element);\n        ptr.array[++(ptr.top)] = element;\n    }\n    else\n        printf(\"\\nStack is FULL!!!\");\n}\n\n\nvoid pop()\n{\n    int flag = checkStackEmpty();\n    if(flag == 1)\n    {\n        printf(\"\\nPopped Element: %d\", (ptr.array[(ptr.top)--]));\n    }\n    else\n        printf(\"\\nStack is EMPTY!!!\");\n}\n\n\nvoid display()\n{\n    int i = 0;\n    int flag = checkStackEmpty();\n\n    if(flag == 1)\n    {\n        printf(\"\\nElements present in the Stack are:- \\n\");\n        for(i=(ptr.top); i>-1; i--)\n        {\n            printf(\"%d\\t\", (ptr.array[i]));\n        }\n        printf(\"\\n\");\n    }\n    else\n        printf(\"\\nStack is EMPTY!!!\");\n}\n\n\nint checkStackFull()\n{\n    if((ptr.top) == size-1)\n        return 0;\n\n    return 1;\n}\n\n\nint checkStackEmpty()\n{\n    if((ptr.top) == -1)\n        return 0;\n\n    return 1;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid display(int matrix[R][C]);\nint find_sum_principal(int matrix[R][C]);\nint find_sum_counter(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    int sum_of_principal_diagonal = 0;\n    int sum_of_counter_diagonal = 0;\n    \n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nInput Matrix is as follows:- \\n\");\n    display(input_matrix);\n\n    \n    sum_of_principal_diagonal = find_sum_principal(input_matrix);\n    printf(\"\\nSum of Principal Diagonal = %d\\n\", sum_of_principal_diagonal);\n\n    \n    sum_of_counter_diagonal = find_sum_counter(input_matrix);\n    printf(\"\\nSum of Counter Diagonal = %d\\n\", sum_of_counter_diagonal);\n}\n\n\nint find_sum_principal(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, sum_principal = 0;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            if(i == j)\n                sum_principal += matrix[i][j];\n            else\n                continue;\n        }\n    }\n\n    return sum_principal;\n}\n\n\nint find_sum_counter(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, sum_counter = 0;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=columns-1; j>=0; j--)\n        {\n            if((i+j) == (columns-1))\n                sum_counter += matrix[i][j];\n            else\n                continue;\n        }\n    }\n\n    return sum_counter;\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid find_Sum_Of_Rows(int matrix[R][C]);\nvoid find_Sum_Of_Columns(int matrix[R][C]);\nvoid display(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nInput Matrix is as follows:- \\n\");\n    display(input_matrix);\n\n    \n    find_Sum_Of_Rows(input_matrix);\n\n    \n    find_Sum_Of_Columns(input_matrix);\n}\n\n\nvoid find_Sum_Of_Rows(int matrix[R][C])\n{\n    int i, j, row_sum = 0;\n    int rows = R;\n    int columns = C;\n\n    for(i=0; i<rows; i++)\n    {\n        row_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            row_sum += matrix[i][j];\n        }\n        printf(\"\\nSum of Row %d: %d\", i, row_sum);\n    }\n}\n\n\nvoid find_Sum_Of_Columns(int matrix[R][C])\n{\n    int i, j, col_sum = 0;\n    int rows = R;\n    int columns = C;\n    int temp = 0;\n    int output_matrix[R][C];\n\n    \n    temp = rows;\n    rows = columns;\n    columns = temp;\n\n    \n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n\n    \n    for(i=0; i<rows; i++)\n    {\n        col_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            col_sum += output_matrix[i][j];\n        }\n        printf(\"\\nSum of Column %d: %d\\n\", i, col_sum);\n    }\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 3;\nconst int C = 3;\n\n\nvoid transpose_and_display(int matrix[R][C]);\nvoid display(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    \n    printf(\"\\nEnter the matrix elements...\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n\n    \n    transpose_and_display(input_matrix);\n}\n\n\nvoid transpose_and_display(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, temp = 0;\n    int output_matrix[R][C];\n\n    \n    temp = columns;\n    columns = rows;\n    rows = temp;\n\n    \n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n\n    \n    printf(\"\\nTransposed Matrix is as follows:- \\n\");\n    display(output_matrix);\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\nconst int R = 5;\nconst int C = 5;\n\n\nvoid display_upper_triangular(int matrix[R][C]);\nvoid display_lower_triangular(int matrix[R][C]);\nvoid display(int matrix[R][C]);\n\nvoid main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n\n    \n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n\n    \n    printf(\"\\nUpper Triangular Matrix is as follows:- \\n\");\n    display_upper_triangular(input_matrix);\n\n    \n    printf(\"\\nLower Triangular Matrix is as follows:- \\n\");\n    display_lower_triangular(input_matrix);\n}\n\n\nvoid display_upper_triangular(int matrix[R][C])\n{\n    int i, j = 0;\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            \n            if(i < j)\n            {\n                printf(\"%d\\t\", matrix[i][j]);\n            }\n            else\n                continue;\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nvoid display_lower_triangular(int matrix[R][C])\n{\n    int i, j = 0;\n\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            \n            if(i > j)\n                printf(\"%d\\t\", matrix[i][j]);\n            else\n                continue;\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nvoid display(int matrix[R][C])\n{\n    int i, j = 0;\n    int rows = R;\n    int columns = C;\n\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n#include<math.h>\n\nvoid main()\n{\n    int number = 0;\n    int count = 0;\n    int copy = 0;\n    int second_copy = 0;\n    int sum = 0;\n\n    printf(\"\\nEnter any number: \");\n    scanf(\"%d\", &number);\n\n    copy = number;\n    second_copy = copy;\n    while(copy != 0)\n    {\n        count++;\n        copy \/= 10;\n    }\n\n    \n    while(second_copy != 0)\n    {\n        sum += pow((second_copy%10), count);\n        second_copy \/= 10;\n    }\n\n    if(sum == number)\n        printf(\"\\n%d is an Armstrong Number\\n\", number);\n\n    else\n        printf(\"\\n%d is NOT an Armstrong Number\\n\", number);\n\n}"}
{"target":"sahadipanjan6","func":"\n\n#include<stdio.h>\nint factorial(int number);\nvoid main()\n{\n    float sum=0.0f;\n    int n=0;\n    int i=0;\n        \n    printf(\"Enter the value of n: \");\n    scanf(\"%d\", &n);\n    for(i=1; i<=n; i++)\n    {\n        sum = sum + (factorial(i)\/i);   \n    }\n    \n    \n    printf(\"Sum = %f\", sum);    \n}\n\nint factorial(int number)\n{\n    int copy=number;\n    int i=0;\n    int fact=1;\n    \n    for(i=1; i<=copy; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\n"}
{"target":"sahadipanjan6","func":"\n\n#include<stdio.h>\nint isSparse(int arr[10][10], int rows, int cols);\n\nvoid main()\n{\n    int arr[10][10];\n    int rows=0;\n    int columns=0;\n    int i=0;\n    int j=0;\n    \n    printf(\"Enter number of rows: \\n\");\n    scanf(\"%d\", &rows);\n    printf(\"Enter number of columns: \\n\");\n    scanf(\"%d\", &columns);\n    \n    printf(\"Enter the array elements...\\n\");\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            scanf(\"%d\", &arr[i][j]);\n        }\n    }\n    \n    if(isSparse(arr, rows, columns) == 1)\n        printf(\"Given Matrix is a SPARSE MATRIX...\\n\");\n    else\n        printf(\"Given Matrix is NOT a SPARSE MATRIX...\\n\");\n        \n}\n\nint isSparse(int arr[10][10], int rows, int cols)\n{\n    int count=0;\n    int i=0;\n    int j=0;\n    \n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<cols; j++)\n        {\n            if(arr[i][j] == 0)\n                count++;\n            else\n                continue;\n        }\n    }\n    \n    if(count > (rows*cols))\n        return 1;\n    else\n        return 0;\n}\n"}
{"target":"sahadipanjan6","func":"\n\n#include<stdio.h>\nint isPalindrome(int number);\n\nvoid main()\n{\n    int n;\n    printf(\"Enter any number:\\n\");\n    scanf(\"%d\", &n);\n    \n    if(isPalindrome(n) == 1)\n        printf(\"%d is a Palindrome...\\n\", n);\n        \n    else\n        printf(\"%d is NOT a Palindrome...\\n\", n);\n}\n\nint isPalindrome(int number)\n{\n    int copy=number;\n    int sum=0;\n    \n    while(copy != 0)\n    {\n        sum = sum*10 + (copy%10);\n        copy \/= 10;\n    }\n    \n    if(sum == number)\n        return 1;\n    else\n        return 0;\n}\n"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\n\nint isPerfect(int number);\n\nvoid main()\n{\n    int number = 0;\n\n    printf(\"\\nEnter any number: \");\n    scanf(\"%d\", &number);\n\n    if(isPerfect(number) == 1)\n        printf(\"%d is a Perfect Number\\n\", number);\n\n    else\n        printf(\"%d is NOT a Perfect Number\\n\", number);\n}\n\n\nint isPerfect(int number)\n{\n    int i = 0;\n    int sum_factors = 0;\n\n    for(i=1; i<number; i++)\n    {\n        if(number%i == 0)\n            sum_factors += i;\n    }\n\n    if(sum_factors == number)\n        return 1;\n\n    return 0;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\n\nint isPerfect(int number);\n\nvoid main()\n{\n    int lower = 0;\n    int upper = 0;\n    int i = 0;\n\n    printf(\"\\nEnter lower bound: \");\n    scanf(\"%d\", &lower);\n    printf(\"\\nEnter upper bound: \");\n    scanf(\"%d\", &upper);\n\n    \n    printf(\"\\nPerfect Numbers within %d and %d are as follows:- \\n\", lower, upper); \n    for(i=lower; i<=upper; i++)\n    {\n        if(isPerfect(i) == 1)\n            printf(\"%d\\t\", i);\n    }\n    printf(\"\\n\");\n}\n\n\nint isPerfect(int number)\n{\n    int i = 0;\n    int sum_factors = 0;\n\n    for(i=1; i<number; i++)\n    {\n        if(number%i == 0)\n            sum_factors += i;\n    }\n\n    if(sum_factors == number)\n        return 1;\n\n    return 0;\n}"}
{"target":"sahadipanjan6","func":"#include<stdio.h>\n\n\nint isPrime(int number);\n\nvoid main()\n{\n    int lower = 0;\n    int upper = 0;\n    int count = 0;\n    int i, j = 0;\n\n    printf(\"\\nEnter the lower bound: \");\n    scanf(\"%d\", &lower);\n    printf(\"\\nEnter the upper bound: \");\n    scanf(\"%d\", &upper);\n\n    \n    printf(\"\\nPrime Numbers within %d and %d are as follows:- \\n\", lower, upper);\n    for(i=lower; i<=upper; i++)\n    {\n        if(isPrime(i) == 1)\n            printf(\"%d\\t\", i);\n        else\n            continue;\n    }\n    printf(\"\\n\");\n}\n\n\nint isPrime(int number)\n{\n    int i, count = 0;\n    int flag = 0;\n\n    for(i=1; i<=number; i++)\n    {\n        if(number%i == 0)\n            count++;\n    }\n\n    if(count == 2)\n        flag = 1;\n\n    return flag;\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\nvoid merge(int a[], int m, int b[], int n, int sorted[]);\nint main()\n{\n  int a[100], b[100], m, n, c, sorted[200];\n  \n  scanf(\"%d\", &m); \n  for (c = 0; c < m; c++){\n    scanf(\"%d\", &a[c]); \n  }\n  scanf(\"%d\", &n); \n  for (c = 0; c < n; c++){\n    scanf(\"%d\", &b[c]); \n  }\n  merge(a, m, b, n, sorted);\n  \n  printf(\"Sorted array:\\n\");\n  for (c = 0; c < m + n; c++) {\n    printf(\"%d\\n\", sorted[c]);\n  }\n  return 0;\n}\nvoid merge(int a[], int m, int b[], int n, int sorted[])\n{\n    int i,j,f;\n    for(i=0;i<m;i++)\n        sorted[i]=a[i];\n    for(j=m,i=0;j<m+n;j++,i++)\n        sorted[j]=b[i];\n    for(i=0;i<m+n;i++)\n    {\n        for(j=0;j<(m+n)-i-1;j++)\n        {\n            if(sorted[j]>sorted[j+1])\n            {\n                f=sorted[j];\n                sorted[j]=sorted[j+1];\n                sorted[j+1]=f;\n            }\n        }\n    }\n}\n"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include <stdlib.h>\nint max(int* arr, int n){\n    int m=0;\n    for (int i = 0; i < n; i++){\n        if(arr[i]>m)\n            m=arr[i];\n    }\n    return m;\n}\nint min(int* arr, int n){\n    int m=arr[0];\n    for (int i = 0; i < n; i++){\n        if(arr[i]<m)\n            m=arr[i];\n    }\n    return m;\n}\nint main(){\n    int n;\n    int* arr;\n    printf(\"Enter the size of the dynamic array: \");\n    scanf(\"%d\",&n);\n    arr=(int*) malloc(sizeof(int)*n);\n    for (int i = 0; i < n; i++){\n        printf(\"Enter the %dth element: \",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"\\nMaximum Element = %d\\n\",max(arr,n));\n    printf(\"Minimum Element = %d\\n\",min(arr,n));\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\n#include <stdlib.h>\n#define NROWS 10\n#define NCOLS  10\nint isValidRC(int r,int c)\n{\n    if(r>NROWS||r<=0)\n    {\n        printf(\"ERROR: Number of rows must be 1-10\");\n        return 0;\n    }\n    else if(c>NCOLS||c<=0)\n    {\n        printf(\"ERROR: Number of columns must be 1-10\");\n        return 0;\n    }\n    else\n    return 1;\n}\nvoid readMat(int mat[NROWS][NCOLS],int r,int c)\n{\n    for(int i=0;i<r;i++)\n    {\n        for(int j=0;j<c;j++)\n            scanf(\"%d\",&mat[i][j]);\n    }\n}\nvoid multMat(int r1,int c1,int mat1[][NCOLS],int r2,int c2,int mat2[][NCOLS],int sum[][NCOLS])\n{\n    if(c1!=r2)\n    {\n        printf(\"ERROR: Number of columns in 1st matrix must equal number of rows in 2nd Matrix\");\n        exit(1);\n    }\n    else\n    {\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            sum[i][j]=0;\n        }\n    }\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            for(int k=0;k<c1;k++)\n            {\n                sum[i][j]+=mat1[i][k]*mat2[k][j];\n            }\n        }\n    }\n    }\n}\nvoid dispMat(int sum[][NCOLS],int r1,int c2)\n{\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            printf(\"%d \",sum[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n        int r1, c1, mat1[NROWS][NCOLS],r2, c2, mat2[NROWS][NCOLS],sum[NROWS][NCOLS];\n        scanf(\"%d%d\", &r1, &c1);\n        if (!isValidRC(r1, c1)) return 1;\n        readMat(mat1, r1, c1);\n        scanf(\"%d%d\", &r2, &c2);\n        if (!isValidRC(r2, c2)) return 1;\n        readMat(mat2, r2, c2);\n        multMat(r1, c1, mat1, r2, c2, mat2, sum);\n        dispMat(sum, r1, c2);\n        return 0;\n}\n"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<math.h>\nlong convert(int decimalnum)\n{\n    long binarynum = 0;\n    int rem, temp = 1;\n    while (decimalnum!=0)\n    {\n        rem = decimalnum%2;\n        decimalnum = decimalnum \/ 2;\n        binarynum = binarynum + rem*temp;\n        temp = temp * 10;\n    }\n    return binarynum;\n}\nint check(int num)\n{\n    long bin=convert(num);\n    int last = bin%10;\n    if(last==0)\n        return 1;\n    else\n        return 2;\n}\nint main()\n{\n    int t,n,i,j,parity,chk;\n    scanf(\"%d\",&t);\n    for (int i = 0; i < t; i++)\n    {\n        scanf(\"%d\",&n);\n        int arr[n];\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\",arr+j);\n        for (int j = 0; j < n; j++)\n        {\n            chk=check(arr[j]);\n            if(j==0)\n                parity=chk;\n            else if(parity!=chk)\n            {\n                parity=0; \n                break;\n            }\n            else \n                continue;\n        }\n        if(parity==0)\n            printf(\"NO\\n\");\n        else\n            printf(\"YES\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\nint bSearch(int arr[],int n,int val,int* p){\n    static int c=0;\n    static int l=0;\n    if(n==0){\n        printf(\"ERROR: Empty list\\n\");\n        exit(1);\n    }\n    if(n<l){\n        printf(\"ERROR:Not found\\n\");\n        exit(1);\n    }\n    int m=(l+n)\/2;\n    if(arr[m]==val){\n        *p=m;\n        return c;\n    }\n    c++;\n    if(arr[m]>val)\n        return bSearch(arr, m-1, val, p);\n    else\n    {\n        l=m+1;\n        return bSearch(arr, n, val, p);\n    }\n}\nint main()\n{\n    int arr[MAX], pos, n, val, passes;\n    \n    scanf(\"%d\",&n);\n    \n    for(int i=0;i<n;i++)\n        scanf(\"%d\",&arr[i]);\n    \n    scanf(\"%d\",&val);\n    passes = bSearch(arr, n, val, &pos);\n    printf(\"%d found at index: %d. Number of passes: %d\", val, pos, passes);\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 50\nint arr[MAX], n;\nstatic int c=1;\nvoid printArray()\n{\n    int i;\n    for (i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\nvoid merge_array(int a, int b, int c, int d) {\n    int temp[n];\n    int i = a, j = c, k = 0;\n    while (i <= b && j <= d) {\n        if (arr [i] < arr[j])\n            temp[k++] = arr [i++];\n        else\n            temp[k++] = arr[j++];\n    }\n    while (i <= b)\n        temp[k++] = arr[i++];\n    while (j <= d)\n        temp[k++] = arr[j++];\n    for (i = a, j = 0; i <= d; i++, j++)\n        arr[i] = temp[j];\n}\nvoid merge_sort(int i, int j) {\n    int m;\n    if (i < j) {\n        m = (i + j) \/ 2;\n        merge_sort(i, m);\n        merge_sort(m + 1, j);\n        merge_array(i, m, m + 1, j);\n        printf(\"%d: \",c++);\n        printArray();\n    }\n}\nint main() {\n    int i;\n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &arr[i]);\n    printf(\"Original: \");\n    printArray();\n    merge_sort(0, n - 1);\n    printf(\"Sorted: \");\n    printArray();\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\nint n;\nstatic int c=1;\nvoid printArray(int arr[])\n{\n    int i;\n    for (i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\nvoid swap(int* a, int* b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nint partition (int arr[], int low, int high)\n{\n    int pivot = high;\n    int i = low,j=high;\n    while (i < j) {\n        while (arr[i] < arr[pivot] && i <= high)\n            i++;\n        while (arr[j] >= arr[pivot] && j >= low)\n            j--;\n        if(i<j)\n            swap(&arr[i],&arr[j]);\n    }\n    swap(&arr[i],&arr[pivot]);\n    return (i);\n}\nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        printf(\"%d: \",c++);\n        printArray(arr);\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\nint main()\n{\n    \n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    int arr[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\",&arr[i]);\n    printf(\"Original: \");\n    printArray(arr);\n    printf(\"%d: \",c++);\n    printArray(arr);\n    quickSort(arr, 0, n-1);\n    printf(\"Sorted: \");\n    printArray(arr);\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\n#include <stdlib.h>\nvoid inputArray(int arr[], int len){   \n    for (int i = 0; i < len; i++)\n        scanf(\"%d\", &arr[i]);\n}\nvoid printArray(int arr[], int len){   \n    for (int i = 0; i < len; i++)\n            printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\nvoid selectionSort(int arr[], int len){ \n    int min,i,j,t;\n    for(i=0;i<len-1;i++)\n    {\n        min=i;   \n        for(j=i+1;j<len;j++)   \n        {\n            if(arr[j]<arr[min])\n                min=j;;\n        }\n        t=arr[i];\n        arr[i]=arr[min];   \n        arr[min]=t;\n        printf(\"Pass %d: \",i+1); \n        printArray(arr,len);   \n    }\n}\nint main(){\n    int len;\n    scanf(\"%d\", &len);   \n    int arr[len];\n    if (len<=0){   \n            printf(\"ERROR: Empty list\\n\");\n            exit(1);\n    }\n    inputArray( arr, len );   \n    selectionSort(arr, len);   \n    printf(\"Sorted: \");\n        printArray(arr,len);   \n    return 0;\n}\n"}
{"target":"sdukesameer","func":"#include    <stdio.h>\n#include    <stdlib.h>\n#define     MAX 20                      \nvoid inputArray(int arr[], int len) {   \n    int i;\n    for (i = 0; i < len; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n}\nint search(int arr[],int n,int val)\n{\n    for(int i=0;i<n;i++)\n    {\n        printf(\"Pass %d: Comparing %d with %d\\n\",i,arr[i],val);\n        if(arr[i]==val)\n            return i;\n    }\n    return -1;\n}\nint main() {\n    int arr[MAX], n, val, pos;\n    scanf(\"%d\", &n);                    \n    if (n<=0) {\n            printf(\"ERROR: Empty list\\n\");\n            exit(EXIT_FAILURE);\n    }\n    inputArray( arr, n );             \n    scanf(\"%d\", &val);                \n    pos = search(arr, n, val); \n    if (pos != -1)\n        printf(\"Position of %d: %d\\n\", val, pos);\n    else\n        printf(\"All checked: %d not found\\n\", val);\n    return 0;\n}\n"}
{"target":"sdukesameer","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 100\n#define NAME_SIZE 50\ntypedef struct x{\n    int rollNo;\n    char name[50];\n}StudentType;\nint enterStudents(StudentType students[]){\n    int c=0;\n    while(1)\n    {\n        if(c>NAME_SIZE){\n            printf(\"OVERFLOW\");\n            break;\n        }\n        scanf(\"%d\",&students[c].rollNo);\n        if(students[c].rollNo==0)\n            break;\n        scanf(\"%[^\\n]s\",students[c].name);\n        c++;\n    }\n    if(c==0){\n        printf(\"Empty list\");\n        exit(1);\n    }\n    return c;\n}\nvoid sortStudents(StudentType students[], int n ){\n    StudentType t;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n-i;j++)\n        {\n            if(students[j].rollNo<students[j+1].rollNo)\n            {\n                t=students[j];\n                students[j]=students[j+1];\n                students[j+1]=t;\n            }\n        }\n    }\n}\nvoid dispStudents ( StudentType students[], int n ) {\n    int i;\n    for (i=0; i<n; i++)\n        printf(\"#%d Roll: %d | Name:%s\\n\",i+1, students[i].rollNo, students[i].name );\n}\n\nint main() {\n    int n;\n    StudentType students[MAX]; \n    \n    n = enterStudents( students );    \n    sortStudents( students, n );\n    \n    dispStudents( students, n );\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 125\n#define NAME_SIZE 50\ntypedef struct student {\n    int rollNo;\n    char name[NAME_SIZE];\n} studentType;\nvoid dispStudents ( studentType students[], int n ) {\n    int i;\n    for (i=0; i<n; i++)\n        printf(\"#%d Roll: %d | Name:%s\\n\",i+1, students[i].rollNo, students[i].name );\n}\nint enterStudents( studentType students[MAX] )\n{\n    int i;\n    for (i = 0; i < MAX; i++)\n    {\n        scanf(\"%d\",&students[i].rollNo);\n        if(students[i].rollNo==0)\n            break;\n        scanf(\"%[^\\n]s\",students[i].name);\n    }\n    return i;\n}\n\nint main() {\n    int n;\n    studentType students[MAX]; \n    \n    n = enterStudents( students );\n    \n    dispStudents( students, n );\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct student\n{\n    int rollno;\n    char name[30];\n    float grade;\n}class;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    if(n<1)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    class arr[n],t;\n    \n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\",&arr[i].rollno);\n        for(int j=0;j<30;j++) arr[i].name[j]=' ';\n        gets(arr[i].name);\n        \n        \n        scanf(\"%f\",&arr[i].grade);\n    }\n    \n    for (int i = 0; i < n-1; i++)\n    {\n        for (int j = 0; j < n-1; j++)\n        {\n            if(arr[j+1].grade > arr[j].grade)\n            {\n                t=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=t;\n            }\n        }\n    }\n    \n    printf(\"Merit List: \\n\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \",arr[i].rollno);\n        printf(\"%-30s\",arr[i].name);\n        printf(\" %.2f\\n\",arr[i].grade);\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\nint sum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            ans+=f;\n            n=n\/10;\n        }\n    }\n    return ans;\n}\nint evensum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            if(f%2==0)\n                ans+=f;\n            n=n\/10;\n        }\n    }\n    return ans;\n}\nint oddsum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            if(f%2!=0)\n                ans+=f;\n            n=n\/10;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int ch;\n    while(1)\n    {\n        int n,ans=0;\n        printf(\"\\n1. Sum of the digits of a given number\\n\");\n        printf(\"2. Sum of even digits of a given number\\n\");\n        printf(\"3. Sum of the odd digits of a given number\\n\");\n        printf(\"4. Exit program\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=sum(n);\n            printf(\"Sum of digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==2)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=evensum(n);\n            printf(\"Sum of even digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=oddsum(n);\n            printf(\"Sum of odd digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\nExitting program. Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE. TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\n#define SRC 'A'\n#define INTER 'B'\n#define DEST 'C'\nvoid move(int n, char src, char dest, char inter);\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);                \n    printf(\"Number of disks: %d\\n\", n);\n    move(n, SRC, DEST, INTER);\n    return 0;\n}\nvoid move(int n,char src, char dest, char inter)\n{\n    if(n<1)\n        printf(\"ERROR\");\n    else\n    {\n        static int c=0;\n        if(n==1)\n        {\n            c++;\n            printf(\"%d: Move top disk from %c to %c\\n\",c,src,dest);\n            return;\n        }\n        move(n-1,src,inter,dest);\n        c++;\n        printf(\"%d: Move top disk from %c to %c\\n\",c,src,dest);\n        move(n-1,inter,dest,src);\n    }\n}\n"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    int n, arr[10], c=0, ch;\n    while(1)\n    {\n        printf(\"1. To enter elements in the array\\n\");\n        printf(\"2. To delete elements from the array\\n\");\n        printf(\"3. Print the array\\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            if (c+1>10)\n                    printf(\"Array full. Try deleting elements.\\n\\n\");\n            else\n                scanf(\"%d\",&arr[c++]);\n        }\n        else if(ch==2)\n        {\n            if(c-1<0)\n                printf(\"Array empty, try adding elements.\\n\\n\");\n            else\n                arr[c--]=0;\n        }\n        else if(ch==3)\n        {\n            for(int j=0;j<c;j++)\n            {\n                printf(\"%d \",arr[j]);\n            }\n            printf(\"\\n\\n\");\n        }\n        else if (ch==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n        {\n            printf(\"Invalid, choice try again\\n\\n\");\n        }\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n    int n;\n    int** mat;\n}gph;\ntypedef struct{\n    int end;\n    int* items;\n}que;\nvoid input(gph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    g->mat=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->mat[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->mat[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->mat[i][j]==1 || g->mat[i][j]==0)\n                continue;\n            if(i==j){\n                g->mat[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->mat[i][j]=f;\n                    g->mat[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input.\\n\");\n            }\n        }\n}\nvoid initialiseQueue(que* q, int n){\n    q->end=-1;\n    q->items=(int*) malloc(sizeof(int)*n);\n}\nvoid enqueue(que* q, int n){\n    q->items[++(q->end)]=n;\n}\nint dequeue(que* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}\nvoid bfs(gph g, int s){\n    que q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.mat[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}\nvoid free_graph(gph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->mat[i]);\n    free(g->mat);\n}\nint main(){\n    gph g;\n    int f=1,s;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&s);\n        if(s>0 && s<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    bfs(g,s-1);\n    free_graph(&g);\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n    int n;\n    int** arr;\n}graph;\ntypedef struct{\n    int end;\n    int* items;\n}queue;\ntypedef struct{\n    int top;\n    int* items;\n}stack;\nvoid input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}\nvoid initialiseQueue(queue* q, int n){\n    q->end=-1;\n    q->items=(int*) malloc(sizeof(int)*n);\n}\nvoid initialiseStack(stack* s, int n){\n    s->top=-1;\n    s->items=(int*)malloc(sizeof(int)*n);\n}\nvoid enqueue(queue* q, int n){\n    q->items[++(q->end)]=n;\n}\nvoid push(stack* s, int n){\n    s->items[++(s->top)]=n;\n}\nint dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}\nvoid pop(stack* s){\n    s->top--;\n}\nint peek(stack* s){\n    return s->items[s->top];\n}\nvoid bfs(graph g, int s){\n    queue q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}\nvoid dfs(graph g, int x){\n    stack s;\n    initialiseStack(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}\nvoid free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}\nint main(){\n    graph g;\n    input(&g);\n    while(1){\n        int f=1,s,ch=1;\n        printf(\"\\n\\n****************\\n\");\n        printf(\"1. BFS Traversal\\n\");\n        printf(\"2. DFS Traversal\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Select the traversal you want to execute: \");\n        scanf(\"%d\",&ch);\n        if(ch==1){\n            printf(\"\\n\\' If\");\n            for(int i=0; i<g.n;i++)\n                printf(\" %c=%d\",'A'+i,i+1);\n            printf(\" \\'\\nEnter the initial vertex: \");\n            while(f){\n                scanf(\"%d\",&s);\n                if(s>0 && s<g.n+1)\n                    f=0;\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n            bfs(g,s-1);\n        }\n        else if(ch==2){\n            printf(\"\\n\\' If\");\n            for(int i=0; i<g.n;i++)\n                printf(\" %c=%d\",'A'+i,i+1);\n            printf(\" \\'\\nEnter the initial vertex: \");\n            while(f){\n                scanf(\"%d\",&s);\n                if(s>0 && s<g.n+1)\n                    f=0;\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n            dfs(g,s-1);\n        }\n        else if(ch==3)\n            break;\n        else\n            printf(\"\\nInvalid input. Try again.\\n\");\n    }\n    printf(\"\\nExitting program. Thank You.\\n\");\n    free_graph(&g);\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n    int n;\n    int** arr;\n}graph;\ntypedef struct{\n    int end;\n    int* items;\n}queue;\nvoid input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}\nvoid initialiseQueue(queue* q, int n){\n    q->end=-1;\n    q->items=(int*) malloc(sizeof(int)*n);\n}\nvoid enqueue(queue* q, int n){\n    q->items[++(q->end)]=n;\n}\nint dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}\nvoid bfs(graph g, int s){\n    queue q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}\nvoid free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}\nint main(){\n    graph g;\n    int f=1,s;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&s);\n        if(s>0 && s<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    bfs(g,s-1);\n    free_graph(&g);\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct x\n{\n    int data;\n    struct x* left;\n    struct x* right;\n}node;\nnode* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}\nnode* insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n < root->data) root->left=insertion(root->left,n);\n    else if(n > root->data) root->right=insertion(root->right,n);\n    return root; \n}\nint search(node* root, int key)\n{\n    if (root==NULL)\n        return 0;\n    else\n    {\n        if (key<root->data)\n            search(root->left,key);\n        else if(key>root->data)\n            search(root->right,key);\n        else\n            return 1;\n    }\n}\nnode* deletion(node* root, int n)\n{\n    if (root==NULL) return root;\n    if (n<root->data)\n        root->left=deletion(root->left,n);\n    else if (n>root->data)\n        root->right=deletion(root->right,n);\n    else\n    {\n        if(root->left==NULL)\n        {\n            node* temp=root->right;\n            free(root);\n            return temp;\n        }\n        else if(root->right==NULL)\n        {\n            node* temp=root->left;\n            free(root);\n            return temp;\n        }\n        node* temp=root->right;\n        while (temp&&temp->left!=NULL)\n            temp=temp->left;\n        root->data=temp->data;\n        root->right=deletion(root->right,temp->data);\n    }\n    return root;\n}\nvoid display(node* root,int n)\n{\n    if (root==NULL)\n    {\n        for (int i = 0; i < n-2; i++)\n            printf(\" \");\n        printf(\"NULL\\n\");\n    }\n    else\n    {\n        display(root->right,n+5);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\/\\n\");\n        for (int i = 0; i < n; i++)\n            printf(\" \");\n        printf(\"%d\\n\",root->data);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\\\\\\n\");\n        display(root->left,n+5);\n    }\n}\nint nodes(node* root)\n{\n    if(root==NULL)\n        return 0;\n    else\n        return 1 + nodes(root->left) + nodes(root->right);\n}\nvoid inorder(node* root)\n{\n    node* stack[nodes(root)];\n    int c=-1;\n    node* cur=root;\n    while(1)\n    {\n        while (cur)\n        {\n            stack[++c]=cur;\n            cur=cur->left;\n        }\n        if (c!=-1)\n        {\n            printf(\"\\t%d\\n\",stack[c--]->data);\n            cur=stack[c+1]->right;\n        }\n        else\n            break;\n    }\n}\nvoid preorder(node* root) \n{ \n    int c=-1;\n    node* stack[nodes(root)];\n    stack[++c]=root;\n    while(c!=-1)\n    {\n        printf(\"\\t%d\\n\",stack[c--]->data);\n        node* temp=stack[c+1];\n        if(temp->right)\n            stack[++c]=temp->right;\n        if(temp->left)\n            stack[++c]=temp->left;\n    }\n}\nint main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. INSERTION OF INTEGER\\n\");\n        printf(\"2. DELETION OF INTEGER\\n\");\n        printf(\"3. DISPLAY TREE\\n\");\n        printf(\"4. IN-ORDER TRAVERSAL\\n\");\n        printf(\"5. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=insertion(root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE.\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter the element to be deleted: \");\n            scanf(\"%d\",&n);\n            if(search(root,n)==1)\n            {\n                root=deletion(root,n);\n                printf(\"%d deleted from BINARY SEARCH TREE.\\n\",n);\n            }\n            else\n                printf(\"COULDN'T DELETE %d. NOT FOUND IN BS TREE.\\n\");\n        }\n        else if(ch==3)\n        {\n            printf(\"\\n\");\n            display(root,1);\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                inorder(root);\n            }\n        }\n        else if(ch==5)\n        {\n            if(root==NULL)\n                printf(\"\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                preorder(root);\n            }\n        }\n        else if(ch==6)\n        {\n            printf(\"Exitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h> \n#include<stdlib.h> \ntypedef struct node \n{ \n    int key; \n    struct node *left, *right; \n}list;\nlist *newNode(int item) \n{ \n    list *temp = (list *)malloc(sizeof(list)); \n    temp->key = item; \n    temp->left = temp->right = NULL; \n    return temp; \n} \nlist* rec_insert(list* node, int key) \n{ \n    if (node == NULL) \n    return newNode(key); \n    if (key < node->key) \n        node->left = rec_insert(node->left, key); \n    else if (key > node->key) \n        node->right = rec_insert(node->right, key); \n    return node; \n}\nlist *insert(list* root, int n)\n{\n    list **temp=&root;\n    while(*temp!=NULL)\n    {\n        if(n < (*temp)->key) temp=&(*temp)->left;\n        else temp=&(*temp)->right;\n    }\n    *temp=newNode(n);\n    return root;\n}\nvoid inorder(list *root) \n{ \n    if (root != NULL) \n    { \n        inorder(root->left); \n        printf(\"   %d \\n\", root->key); \n        inorder(root->right); \n    } \n}\nvoid preorder(list *root)\n{\n    if (root != NULL)\n    {\n        printf(\"   %d \\n\", root->key); \n        preorder(root->left);\n        preorder(root->right);\n    }\n}\nvoid postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"   %d \\n\", root->key); \n    }\n}\nint rec_height(list* node)\n{\n    if(node==NULL)\n    return 0;\n    else\n    {\n    int lheight=rec_height(node->left);\n    int rheight=rec_height(node->right);\n    if(lheight> rheight)\n        return (lheight+1);\n    else return (rheight+1);\n    }\n}\nvoid mirror_ins(list* node)\n{\n    if(node==NULL)\n    return ;\n    else\n    {\n        list* temp;\n        mirror_ins(node->left);\n        mirror_ins(node->right);\n        temp=node->left;\n        node->left=node->right;\n        node->right=temp;\n    }\n}\nint rec_count(list* node)\n{\n    int x=1;\n    if(node==NULL)\n        return 0;\n    else\n    {\n        x+=rec_count(node->left);\n        x+=rec_count(node->right);\n        return x;\n    }\n}\nint leafcount(list* node)\n{\n    if(node==NULL)\n        return 0;\n    if(node->left==NULL && node->right==NULL)\n        return 1;\n    else\n        return leafcount(node->left)+leafcount(node->right);\n}\nint InternalNodeCount(list* node)\n{\n    if(node==NULL ||(node->left==NULL && node->right==NULL))\n        return 0;\n    else\n        return 1 + InternalNodeCount(node->left)+InternalNodeCount(node->right);\n}\nint findmax(list* node)\n{\n    if(node==NULL || node->right==NULL)\n        return node->key;\n    else\n        findmax(node->right);\n}\nint findmin(list* node)\n{\n    if(node==NULL || node->left==NULL)\n        return node->key;\n    else\n        findmin(node->left);\n}\nvoid deleteTree(list* node)\n{\n    if(node == NULL)\n        return;\n    deleteTree(node->left);\n    deleteTree(node->right);\n    printf(\"\\n Deleting Node: %d\",node->key);\n    free(node);\n}\nint main() \n{ \n    int ch;\n    list* root=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. Insertion Using Recursive Function \\n\");\n        printf(\"2. Insertion Using Iterative Function \\n\");\n        printf(\"3. In-order Traversal  using a Recursive Function \\n\");\n        printf(\"4. Pre-order Traversal  using a Recursive Function \\n\");\n        printf(\"5. Post-order Traversal  using a Recursive Function \\n\");\n        printf(\"6. Determine the height of the Binary Search Tree \\n\");\n        printf(\"7. Construct the Binary Search Tree which is mirror image of the given Binary Search Tree \\n\");\n        printf(\"8. Count the total number of nodes of the Binary Search Tree \\n\");\n        printf(\"9. Count the total number of leaf nodes of the Binary Search Tree \\n\");\n        printf(\"10. Count the total number of internal nodes of the Binary Search Tree \\n\");\n        printf(\"11. Find maximum and minimum elements in the Binary Search Tree \\n\");\n        printf(\"12. Deallocate the memory space occupied by Binary Search Tree \\n\");\n        printf(\"13. Exit Program \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=rec_insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nIN-ORDER\\n\");\n            inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\nPRE-ORDER\\n\");\n            preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"\\nPOST-ORDER\\n\");\n            postorder(root);\n        }\n        else if (ch==6)\n        {\n            printf(\"Height of tree= %d\\n\",rec_height(root));\n        }\n        else if (ch==7)\n        {\n            mirror_ins(root);\n            printf(\"Mirror of tree constructed\\n\");\n        }\n        else if (ch==8)\n        {\n            printf(\"Total number of nodes= %d\\n\",rec_count(root));\n        }\n        else if (ch==9)   \n        {\n            printf(\"Number of leaf nodes= %d\\n\",leafcount(root));\n        }\n        else if (ch==10)\n        {\n            printf(\"Number of internal nodes= %d\\n\",InternalNodeCount(root));\n        }\n        else if (ch==11)\n        {\n            printf(\"Maximum= %d\\n\",findmax(root));\n            printf(\"Minimum= %d\\n\",findmin(root));\n        }\n        else if (ch==12)\n        {\n            deleteTree(root);\n            root=NULL;\n        }\n        else if (ch==13)\n        {\n            printf(\"Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0; \n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct x\n{\n    int data;\n    struct x* left;\n    struct x* right;\n}node;\nnode* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}\nnode* rec_insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n<root->data) root->left=rec_insertion(root->left,n);\n    else if(n>root->data) root->right=rec_insertion(root->right,n);\n    return root;\n}\nvoid iter_insertion(node** root, int n)\n{\n    node*** temp=&root;\n    while(**temp!=NULL)\n    {\n        if(n < (**temp)->data) *temp=&(**temp)->left;\n        else *temp=&(**temp)->right;\n    }\n    **temp=createNode(n);\n}\nvoid rec_inorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_inorder(root->left); \n        printf(\"\\t%d\\n\", root->data); \n        rec_inorder(root->right); \n    } \n}\nvoid rec_preorder(node* root) \n{ \n    if (root != NULL) \n    {\n        printf(\"\\t%d\\n\", root->data); \n        rec_preorder(root->left);\n        rec_preorder(root->right);\n    } \n} \nvoid rec_postorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_postorder(root->left);\n        rec_postorder(root->right);\n        printf(\"\\t%d\\n\", root->data); \n    }\n}\nint height(node* root)\n{\n    if(root==NULL)\n        return 0;\n    else\n    {\n        int lheight=height(root->left);\n        int rheight=height(root->right);\n        if(lheight>rheight)\n            return lheight+1;\n        else\n            return rheight+1;\n    }\n}\nvoid mirror_image(node** root)\n{\n    node* temp;\n    if((*root)!=NULL)\n    {\n        mirror_image(&(*root)->left);\n        mirror_image(&(*root)->right);\n        temp=(*root)->left;\n        (*root)->left=(*root)->right;\n        (*root)->right=temp;\n    }\n}\nint count_totalnodes(node* root)\n{\n    if(root==NULL)\n        return 0;\n    else\n        return 1 + count_totalnodes(root->left) + count_totalnodes(root->right);\n}\nint count_leafnodes(node* root)\n{\n    if (root==NULL)\n        return 0;\n    if (root->left == NULL && root->right == NULL)\n        return 1;\n    else\n        return count_leafnodes(root->left) + count_leafnodes(root->right);\n}\nint count_internalnodes(node* root)\n{\n    if(root == NULL || (root->left == NULL && root->right == NULL))\n        return 0;\n    else\n        return 1 + count_internalnodes(root->left)+count_internalnodes(root->right);\n}\nint largest_element(node* root)\n{\n    if(root==NULL||root->right==NULL)\n        return root->data;\n    else\n        largest_element(root->right);\n}\nint smallest_element(node* root)\n{\n    if(root==NULL||root->left==NULL)\n        return root->data;\n    else\n        smallest_element(root->left);\n}\nvoid deallocate_space(node* root)\n{\n    if((root)!=NULL)\n    {\n        deallocate_space(root->left);\n        deallocate_space(root->right);\n        printf(\"\\nDeallocating space occupied by element: %d\",root->data);\n        free(root);\n    }\n}\nint main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. HEIGHT OF BINARY TREE\\n\");\n        printf(\"7. CONSTRUCT MIRROR IMAGE\\n\");\n        printf(\"8. COUNT TOTAL NUMBER OF NODES\\n\");\n        printf(\"9. COUNT TOTAL NUMBER OF LEAF NODES\\n\");\n        printf(\"10. COUNT TOTAL NUMBER OF INTERNAL NODES\\n\");\n        printf(\"11. MAX AND MIN ELEMENTS IN THE BINARY TREE\\n\");\n        printf(\"12. DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n\");\n        printf(\"13. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                rec_inorder(root);\n            }\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                rec_preorder(root);\n            }\n        }\n        else if(ch==5)  \n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     POST-ORDER\\n\");\n                rec_postorder(root);\n            }\n        }\n        else if(ch==6)\n            printf(\"\\nHeight of the tree: %d\\n\",height(root));\n        else if(ch==7)\n        {\n            mirror_image(&root);\n            printf(\"\\nImage Tree Created\\n\");\n        }\n        else if(ch==8)\n                printf(\"\\nTotal number of nodes: %d\\n\",count_totalnodes(root));\n        else if(ch==9)\n            printf(\"\\nNumber of leaf nodes: %d\\n\",count_leafnodes(root));\n        else if(ch==10)\n            printf(\"\\nNumber of internal nodes: %d\\n\",count_internalnodes(root));\n        else if(ch==11)\n        {\n            printf(\"\\nMaximum element: %d\\n\",largest_element(root));\n            printf(\"Minimum element: %d\\n\",smallest_element(root));\n        }\n        else if(ch==12)\n        {\n            deallocate_space(root);\n            root=NULL;\n            printf(\"\\n\\nDeallocated the space occupied by Binary Tree.\\n\");\n        }\n        else if(ch==13)\n        {\n            \n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h> \n#include<stdlib.h> \ntypedef struct node \n{ \n    int key; \n    struct node *left, *right; \n}list;\nlist *newNode(int item) \n{ \n    list *temp = (list *)malloc(sizeof(list)); \n    temp->key = item; \n    temp->left = temp->right = NULL; \n    return temp; \n} \nlist* rec_insert(list* node, int key) \n{ \n    if (node == NULL) \n    return newNode(key); \n    if (key < node->key) \n        node->left = rec_insert(node->left, key); \n    else if (key > node->key) \n        node->right = rec_insert(node->right, key); \n    return node; \n}\nlist *insert(list* root, int n)\n{\n    list **temp=&root;\n    while(*temp!=NULL)\n    {\n        if(n < (*temp)->key) temp=&(*temp)->left;\n        else temp=&(*temp)->right;\n    }\n    *temp=newNode(n);\n    return root;\n}\nvoid inorder(list *root) \n{ \n    if (root != NULL) \n    { \n        inorder(root->left); \n        printf(\"%d \\n\", root->key); \n        inorder(root->right); \n    } \n}\nvoid preorder(list *root)\n{\n    if (root != NULL)\n    {\n        printf(\"%d \\n\", root->key); \n        preorder(root->left);\n        preorder(root->right);\n    }\n}\nvoid postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \\n\", root->key); \n    }\n}\nint main() \n{ \n    int ch;\n    list* root=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. Insertion Using Recursive Function\\n\");\n        printf(\"2. Insertion Using Iterative Function\\n\");\n        printf(\"3. In-order Traversal  using a Recursive Function\\n\");\n        printf(\"4. Pre-order Traversal  using a Recursive Function\\n\");\n        printf(\"5. Post-order Traversal  using a Recursive Function\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=rec_insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"IN-ORDER\\n\");\n            inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"PRE-ORDER\\n\");\n            preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"POST-ORDER\\n\");\n            postorder(root);\n        }\n        else if(ch==6)\n        {\n            printf(\"Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0; \n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct x\n{\n    int data;\n    struct x* left;\n    struct x* right;\n}node;\nnode* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}\nnode* rec_insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n<root->data) root->left=rec_insertion(root->left,n);\n    else if(n>root->data) root->right=rec_insertion(root->right,n);\n    return root;\n}\nvoid iter_insertion(node** root, int n)\n{\n    node*** temp=&root;\n    while(**temp!=NULL)\n    {\n        if(n < (**temp)->data) *temp=&(**temp)->left;\n        else *temp=&(**temp)->right;\n    }\n    **temp=createNode(n);\n}\nvoid rec_inorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_inorder(root->left); \n        printf(\"\\t%d\\n\", root->data); \n        rec_inorder(root->right); \n    } \n}\nvoid rec_preorder(node* root) \n{ \n    if (root != NULL) \n    {\n        printf(\"\\t%d\\n\", root->data); \n        rec_preorder(root->left);\n        rec_preorder(root->right);\n    }\n} \nvoid rec_postorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_postorder(root->left);\n        rec_postorder(root->right);\n        printf(\"\\t%d\\n\", root->data); \n    }\n} \nint main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\n     IN-ORDER\\n\");\n            rec_inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\n     PRE-ORDER\\n\");\n            rec_preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"\\n     POST-ORDER\\n\");\n            rec_postorder(root);\n        }\n        else if(ch==6)\n        {\n            printf(\"Exitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX 50\ntypedef struct bs_tree{\n    int data;\n    struct bs_tree *left, *right;\n}BS_TREE; \ntypedef struct queue{\n   BS_TREE *elements[MAX];\n    int front, rear; \n}QUEUE;\nvoid initialiseQueue (QUEUE *aq){\n    aq->front =-1; \n    aq->rear =-1;\n}\nvoid addQueue (BS_TREE * at, QUEUE *aq){\n\n    if (aq->rear == MAX-1)\n        exit(0); \n \n    else\n        aq->elements [++(aq->rear)]=at;\n\n}\nBS_TREE* deleteQueue (QUEUE *aq){\n     BS_TREE *p;\n    \n    if (aq->front != aq->rear){\n        p= aq->elements [++(aq->front)];\n        if (aq->front == aq->rear)\n        \n        initialiseQueue (aq);\n        return p; \n    }\n    else \n        return NULL; \n}\nint  isEmptyQueue (QUEUE q) {\n    return (q.front == -1);\n}\nvoid initialise_tree (BS_TREE **aar){\n        *aar = NULL;\n}\nvoid rec_insert (BS_TREE **aar, int n){\n    if (*aar == NULL){\n       *aar=(BS_TREE *)malloc(sizeof(BS_TREE));\n        (*aar)->data=n;\n        (*aar)->left=(*aar)->right=NULL;\n    } \n    else if (n<(*aar)->data)\n        rec_insert(&((*aar)->left), n); \n    else\n        rec_insert(&((*aar)->right), n); \n}\nvoid level_order_Traversal (BS_TREE *ar){\n    QUEUE q;\n    BS_TREE *ptr;\n    \n    initialiseQueue (&q);\n    \n    addQueue (ar, &q);\n        \n    while (! isEmpty(q)){\n            \n        ptr = deleteQueue (&q);\n            \n        if ( ptr->left != NULL ) \n            addQueue (ptr->left, &q);\n            \n        if ( ptr->right != NULL ) \n            addQueue (ptr->right, &q);\n        printf(\"\\t %d\", ptr->data);            \n    }\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct x\n{\n    int data;\n    struct x* next;\n}node;\nnode* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->next=NULL;\n    return newNode;\n}\nvoid sort_insertion(node** head, int n)\n{\n    node* cll=createNode(n);\n    if (*head==NULL)\n    {\n        *head=cll;\n        cll->next=cll;\n    }\n    else if((*head)->data >= cll->data)\n    {\n        node* last=*head;\n        while(last->next!=(*head))\n            last=last->next;\n        cll->next=*head;\n        last->next=cll;\n        *head=cll;\n    }\n    else if((*head)->data < cll->data)\n    {\n        node* temp=*head;\n        while(temp->next!=*head && temp->next->data<cll->data)\n            temp=temp->next;\n        cll->next=temp->next;\n        temp->next=cll;\n    }\n}\nvoid seq_insertion(node** head, int n)\n{\n    node* cll=createNode(n);\n    if(*head==NULL)\n    {\n        *head=cll;\n        cll->next=cll;\n    }\n    else\n    {\n        cll->next=*head;\n        node* last=*head;\n        while(last->next!=(*head))\n            last=last->next;\n        last->next=cll;\n        *head=cll;\n    }\n}\nnode* search(node* head, int n)\n{\n    node* cll=head;\n    do\n    {\n        if(cll->data==n)\n            return cll;\n        cll=cll->next;\n    }\n    while(cll!=head);\n    return NULL;\n}\nvoid deletion(node** head, node* del)\n{\n    if (*head==del)\n    {\n        if((*head)->next==*head)\n            *head=NULL;\n        else\n        {\n            node* last=*head;\n            while(last->next!=(*head))\n                last=last->next;\n            *head=(*head)->next;\n            last->next=*head;\n        }\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=del)\n            temp=temp->next;\n        temp->next=del->next;\n    }\n    free(del);\n}\nvoid print(node* head)\n{\n    node* temp=head;\n    do\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    while(temp!=head);\n}\nint main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SEQUENTAIL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n    int n;\n    int** mat;\n}gph;\ntypedef struct{\n    int top;\n    int* items;\n}stk;\nvoid input(gph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    g->mat=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->mat[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->mat[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->mat[i][j]==1 || g->mat[i][j]==0)\n                continue;\n            if(i==j){\n                g->mat[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->mat[i][j]=f;\n                    g->mat[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input.\\n\");\n            }\n        }\n}\nvoid initialise(stk* s, int n){\n    s->top=-1;\n    s->items=(int*)malloc(sizeof(int)*n);\n}\nvoid push(stk* s, int n){\n    s->items[++(s->top)]=n;\n}\nint peek(stk* s){\n    return s->items[s->top];\n}\nvoid pop(stk* s){\n    s->top--;\n}\nvoid dfs(gph g, int x){\n    stk s;\n    initialise(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.mat[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}\nvoid free_graph(gph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->mat[i]);\n    free(g->mat);\n}\nint main(){\n    gph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct{\n    int n;\n    int** arr;\n}graph;\ntypedef struct{\n    int top;\n    int* items;\n}stack;\nvoid input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}\nvoid initialiseStack(stack* s, int n){\n    s->top=-1;\n    s->items=(int*)malloc(sizeof(int)*n);\n}\nvoid push(stack* s, int n){\n    s->items[++(s->top)]=n;\n}\nint peek(stack* s){\n    return s->items[s->top];\n}\nvoid pop(stack* s){\n    s->top--;\n}\nvoid dfs(graph g, int x){\n    stack s;\n    initialiseStack(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}\nvoid free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}\nint main(){\n    graph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct n\n{ \n    int key;\n    struct n *prev, *next; \n}list;\nvoid sort_insertion(list** head, int n)\n{\n    list* node=(list*)malloc(sizeof(list));\n    node->key=n;\n    node->next=NULL;\n    node->prev=NULL;\n    if(*head==NULL)\n        *head=node;\n    else if(node->key <= (*head)->key)\n    {\n        (*head)->prev=node;\n        node->next=*head;\n        *head=node;\n    }\n    else\n    {\n        list* temp=*head;\n        while(temp->next != NULL && temp->next->key < node->key)\n            temp=temp->next;\n        node->prev=temp;\n        node->next=temp->next;\n        temp->next=node;\n        if(node->next!=NULL)\n            node->next->prev=node;\n    }\n}\nvoid seq_insertion(list** head, int n)\n{\n    list* dll=(list*)malloc(sizeof(list));\n    dll->key=n;\n    dll->next=*head;\n    dll->prev=NULL;\n    if (*head!=NULL)\n        (*head)->prev=dll;\n    *head=dll;\n}\nlist* search_node(list* head, int n) \n{\n    list* dll=head;\n    while (dll!=NULL)\n    {\n        if(dll->key==n)\n            return dll;\n        dll=dll->next;\n    }\n    return NULL;\n}\nvoid deletion(list** head, list* del)\n{\n    if (*head==del)\n        *head=del->next;\n    else \n    {\n        if (del->next!=NULL)\n            del->next->prev=del->prev;\n        if (del->prev!=NULL)\n            del->prev->next=del->next;\n    }\n    free(del);\n}\nvoid printfwd(list* head)\n{\n    list* dll=head;\n    while (dll!=NULL)\n    {\n        printf(\"%d  \",dll->key);\n        dll=dll->next;\n    }\n}\nvoid printrev(list* head)\n{\n    list* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->key);\n        dll=dll->prev;\n    }\n}\nint main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            list* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST IS EMPTY\\n\",n);\n                    else\n                    {\n                        list* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printfwd(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printrev(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            list* head=NULL;\n            int c;\n            while(1)\n            {\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST IS EMPTY\\n\",n);\n                    else\n                    {\n                        list* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printfwd(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printrev(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if(c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct x\n{\n    struct x* prev;\n    int data;\n    struct x* next;\n}node;\nvoid sort_insertion(node** head, int n)\n{\n    node* dll=(node*)malloc(sizeof(node));\n    dll->data=n;\n    dll->next=NULL;\n    dll->prev=NULL;\n    if(*head==NULL)\n        *head=dll;\n    else if(dll->data <= (*head)->data)\n    {\n        (*head)->prev=dll;\n        dll->next=*head;\n        *head=dll;\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next != NULL && temp->next->data < dll->data)\n            temp=temp->next;\n        dll->prev=temp;\n        dll->next=temp->next;\n        temp->next=dll;\n        if(dll->next!=NULL)\n            dll->next->prev=dll;\n    }\n}\nvoid seq_insertion(node** head, int n)\n{\n    node* dll=(node*)malloc(sizeof(node));\n    dll->data=n;\n    dll->next=*head;\n    dll->prev=NULL;\n    if (*head!=NULL)\n        (*head)->prev=dll;\n    *head=dll;\n}\nnode* search_node(node* head, int n) \n{\n    node* dll=head;\n    while (dll!=NULL)\n    {\n        if(dll->data==n)\n            return dll;\n        dll=dll->next;\n    }\n    return NULL;\n}\nvoid deletion(node** head, node* del)\n{\n    if (*head==del)\n        *head=del->next;\n    else \n    {\n        if (del->next!=NULL)\n            del->next->prev=del->prev;\n        if (del->prev!=NULL)\n            del->prev->next=del->next;\n    }\n    free(del);\n}\nvoid printforward(node* head)\n{\n    node* dll=head;\n    while (dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->next;\n    }\n}\nvoid printreversed(node* head)\n{\n    node* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->prev;\n    }\n}\nint main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST EMPTY\\n\",n);\n                    else\n                    {\n                        node* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printforward(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printreversed(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SEQUENTIAL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST EMPTY\\n\",n);\n                    else\n                    {\n                        node* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printforward(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printreversed(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if(c==5)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct s\n{\n    int data;\n    struct s* next;\n}node;\nnode* createNode()\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=0;\n    newnode->next=NULL;\n    return newnode;\n}\nvoid push(node** head, int n)\n{\n    node* linklist=createNode();\n    linklist->data=n;\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d pushed to stack\\n\",n);\n}\nint isempty(node* head)\n{\n    if(head==NULL)\n        return 1;\n    else\n        return 0;\n}\nvoid pop(node** head)\n{\n    if(isempty(*head))\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* temp=*head;\n        *head=(*head)->next;\n        printf(\"%d popped from stack\\n\",temp->data);\n        free(temp);\n    }\n}\nint main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(&head,n);\n        }\n        else if (ch==2)\n            pop(&head);\n        else if (ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct s\n{\n    int data;\n    struct s* next;\n}node;\nnode* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}\nnode* insert(node* head, int data)\n{\n    if(head==NULL)\n        return createNode(head,data);\n    else\n        head->next=insert(head->next,data);\n    return head;\n}\nvoid delete(node** head, int key)\n{\n    if(*head==NULL)\n        printf(\"Oops! Can't delete, STACK EMPTY\\n\");\n    else\n    {\n        int c=0,f=0;\n        node* prev;\n        node* cur=*head;\n        while(cur != NULL)\n        {\n            c++;\n            if(c==1)\n            {    \n                if (cur->data==key)\n                {\n                    *head=cur->next;\n                    free(cur);\n                    cur=*head;\n                    f=1;c=0;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n            else\n            {\n                if(cur->data==key)\n                {\n                    prev->next=cur->next;\n                    free(cur);\n                    cur=prev->next;\n                    f=1;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n        }\n        if(f==0)\n            printf(\"NO MATCH FOUND\\n\");\n        else\n            printf(\"MATCH FOUND!\\nAll matching elements deleted\\n\");\n    }\n}\nnode* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}\nint count(node* head)\n{\n    if(head==NULL)\n        return 0;\n    else\n        return count(head->next)+1;\n}\nnode* print(node* head)\n{\n    if(head==NULL)\n        return NULL;\n    else if(head->next==NULL)\n    {\n        printf(\"      STACK      \\n\");\n        return head;\n    }\n    else\n    {\n        printf(\"\\t%d\\n\",(print(head->next))->data);\n        return head;\n    }\n}\nint main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. INSERT\\n\");\n        printf(\"2. DELETE\\n\");\n        printf(\"3. REVERSE\\n\");\n        printf(\"4. COUNT\\n\");\n        printf(\"5. PRINT\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=insert(head, n);\n        }\n        else if (ch==2)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==3)\n        {\n            if(head==NULL)\n                printf(\"Oops!, Can't REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==4)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==5)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==6)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct a\n{\n    int data;\n    struct a* next;\n}node;\nnode* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}\nvoid insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}\nvoid removeeven(node** head)\n{\n    while((*head)!=NULL && (*head)->data%2==0)\n        *head=(*head)->next;\n    node* h=*head;\n    if((*head)==NULL)\n        return;\n    while(h->next!=NULL)\n    {\n        if(h->next->data%2==0)\n            h->next=h->next->next;\n        else\n            h=h->next;\n    }\n}\nvoid print(node** head)\n{\n    if(*head==NULL)\n        printf(\"\\nSTACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"\\n LINK-LIST:\");\n        while(h!=NULL)\n        {\n            printf(\"  %d\",h->data);\n            h=h->next;\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    int n;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n1. INSERT\\n\");\n        printf(\"2. REMOVE EVEN\\n\");\n        printf(\"3. PRINT\\n\");\n        printf(\"4. EXIT\\n\");\n        printf(\"Enter choice: \");\n        scanf(\"%d\",&n);\n        if(n==1)\n        {\n            int inp;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&inp);\n            insert(&head,inp);\n        }\n        else if(n==2)\n        {\n            removeeven(&head);\n            printf(\"All even integers removed.\\n\");\n        }\n        else if(n==3)\n            print(&head);\n        else if(n==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct a\n{\n    int data;\n    struct a* next;\n}node;\nnode* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}\nvoid sequential_insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}\nvoid sorted_insert(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}\nvoid print(node** head)\n{\n    if(*head==NULL)\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"      STACK      \\n\");\n        while(h!=NULL)\n        {\n            printf(\"\\t%d\\n\",h->data);\n            h=h->next;\n        }\n    }\n}\nint main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\n1. SORTED ORDER\\n\");\n        printf(\"2. SEQUENTIAL ORDER\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if (n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sorted_insert(&head,inp);\n                }\n                else if (n==2)\n                    print(&head);\n                else if (n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if(n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sequential_insert(&head,inp);\n                }\n                else if(n==2)\n                    print(&head);\n                else if(n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"SORRY, INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct a\n{\n    int data;\n    struct a* next;\n}node;\nnode* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}\nvoid sequential_insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}\nvoid sorted_insert_asc(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}\nvoid sorted_insert_dec(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data > (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data > newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}\nvoid print(node** head)\n{\n    if(*head==NULL)\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"      STACK      \\n\");\n        while(h!=NULL)\n        {\n            printf(\"\\t%d\\n\",h->data);\n            h=h->next;\n        }\n    }\n}\nint main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\n1. SORTED ORDER\\n\");\n        printf(\"2. SEQUENTIAL ORDER\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int x;\n            while(1)\n            {\n                printf(\"\\n1. ASCENDING ORDER\\n\");\n                printf(\"2. DESCENDING ORDER\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&x);\n                if(x==1)\n                {\n                    int n;\n                    node* head=NULL;\n                    printf(\"\\n\\t ASCENDING ORDER\\n\");\n                    while(1)\n                    {\n                        printf(\"\\n1. INSERT\\n\");\n                        printf(\"2. PRINT\\n\");\n                        printf(\"3. EXIT\\n\");\n                        printf(\"Enter choice: \");\n                        scanf(\"%d\",&n);\n                        if (n==1)\n                        {\n                            int inp;\n                            printf(\"Enter the element: \");\n                            scanf(\"%d\",&inp);\n                            sorted_insert_asc(&head,inp);;\n                        }\n                        else if (n==2)\n                        {\n                            print(&head);\n                        }\n                        else if (n==3)\n                        {\n                            printf(\"Exitting, Thank you.\\n\");\n                            break;\n                        }\n                        else\n                            printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                    }\n                }\n                else if(x==2)\n                {\n                    int n;\n                    node* head=NULL;\n                    printf(\"\\n\\t DESCENDING ORDER\\n\");\n                    while(1)\n                    {\n                        printf(\"\\n1. INSERT\\n\");\n                        printf(\"2. PRINT\\n\");\n                        printf(\"3. EXIT\\n\");\n                        printf(\"Enter choice: \");\n                        scanf(\"%d\",&n);\n                        if (n==1)\n                        {\n                            int inp;\n                            printf(\"Enter the element: \");\n                            scanf(\"%d\",&inp);\n                            sorted_insert_dec(&head,inp);;\n                        }\n                        else if (n==2)\n                        {\n                            print(&head);\n                        }\n                        else if (n==3)\n                        {\n                            printf(\"Exitting, Thank you.\\n\");\n                            break;\n                        }\n                        else\n                            printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                    }\n                }\n                else if(x==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                {\n                    printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                }\n            }\n        }\n        else if(ch==2)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if(n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sequential_insert(&head,inp);\n                }\n                else if(n==2)\n                    print(&head);\n                else if(n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n                break;\n        }\n        else\n            printf(\"SORRY, INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\ntypedef struct s\n{\n    int data;\n    struct s* next;\n}node;\nnode* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}\nnode* push(node* head, int data)\n{\n    if(head==NULL)\n        return createNode(head,data);\n    else\n        head->next=push(head->next,data);\n    return head;\n}\nnode* pop(node* head)\n{\n    if(head==NULL)\n        printf(\"CAN'T POP, STACK EMPTY\\n\");\n    else if(head->next==NULL)\n    {\n        printf(\"%d popped from stack\\n\",head->data);\n        free(head);\n        return NULL;\n    }\n    else\n    {\n        head->next=pop(head->next);\n        return head;\n    }\n}\nvoid delete(node** head, int key)\n{\n    if(*head==NULL)\n        printf(\"CAN'T DELETE, STACK EMPTY\\n\");\n    else\n    {\n        int c=0,f=0;\n        node* prev;\n        node* cur=*head;\n        while(cur != NULL)\n        {\n            c++;\n            if(c==1)\n            {    if (cur->data==key)\n                {\n                    *head=cur->next;\n                    free(cur);\n                    cur=*head;\n                    f=1;c=0;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n            else\n            {\n                if(cur->data==key)\n                {\n                    prev->next=cur->next;\n                    free(cur);\n                    cur=prev->next;\n                    f=1;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n        }\n        if(f==0)\n            printf(\"NO MATCH FOUND\\n\");\n        else\n            printf(\"Match found!\\nAll matching elements deleted successfully.\\n\");\n    }\n}\nnode* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}\nint count(node* head)\n{\n    if(head==NULL)\n        return 0;\n    else\n        return count(head->next)+1;\n}\nnode* print(node* head)\n{\n    if(head==NULL)\n        return NULL;\n    else if(head->next==NULL)\n    {\n        printf(\"      STACK      \\n\");\n        return head;\n    }\n    else\n    {\n        printf(\"\\t%d\\n\",(print(head->next))->data);\n        return head;\n    }\n}\nint main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. DELETE\\n\");\n        printf(\"4. REVERSE\\n\");\n        printf(\"5. COUNT\\n\");\n        printf(\"6. PRINT\\n\");\n        printf(\"7. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=push(head, n);\n        }\n        else if (ch==2)\n            head=pop(head);\n        else if (ch==3)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==4)\n        {\n            if(head==NULL)\n                printf(\"CAN'T REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==5)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==6)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==7)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h> \n#include<stdlib.h> \ntypedef struct n{\n    int key;\n    struct n *left, *right;\n}list;\ntypedef struct{\n    int top;\n    unsigned int size;\n    int* arr;\n}stack;\nlist* initialise_tree(list* root){\n    root=NULL;\n    return root;\n}\nstack* initialise_stack(unsigned int x){\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int*)malloc(x * sizeof(int));\n    return ret;\n}\nlist *newNode(int item){\n    list *temp = (list*)malloc(sizeof(list));\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp; \n}\nlist* insert(list* node, int key){\n    if (node == NULL)\n    return newNode(key); \n    if (key < node->key) \n        node->left = insert(node->left, key);\n    else if (key > node->key) \n        node->right = insert(node->right, key); \n    return node;\n}\nint is_full(stack* stk){\n    if(stk->top==(stk->size-1))\n        return 1;\n    else\n        return 0;\n}\nvoid push(stack* stk, int n){\n    if(is_full(stk))\n        printf(\"OVERFLOW OCCURRED!\\n\");\n    else{\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}\nint is_empty(stack* stk){\n    if(stk->top==-1)\n        return 1;\n    else\n        return 0;\n}\nlist* minValNode(list* node){\n    list* curr=node;\n    while(curr && curr->left!=NULL)\n        curr=curr->left;\n    return curr;\n}\nint find(list* root, int n){\n    if (root==NULL)\n        return 0;\n    else{\n        if (n<root->key)\n            find(root->left,n);\n        else if(n>root->key)\n            find(root->right,n);\n        else\n            return 1;\n    }\n}\nlist* del_Node(list* node, int n){\n    if(node==NULL)\n        return node;\n    if(n<node->key)\n        node->left=del_Node(node->left,n);\n    else if(n>node->key)\n        node->right=del_Node(node->right,n);\n    else{\n        if(node->left==NULL){\n            list*temp=node->right;\n            free(node);\n            return temp;\n        }\n        else if (node->right==NULL){\n            list* temp=node->left;\n            free(node);\n            return temp;\n        }\n        list* temp=minValNode(node->right);\n        node->key=temp->key;\n        node->right=del_Node(node->right,temp->key);\n    }\n    return node;\n}\nvoid pop(stack* stk){\n    if(is_empty(stk))\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}\nvoid preorder(list* node){\n    int top=-1;\n    list *s[50];\n    while(1){\n        while(node!=NULL){\n            printf(\" %d\",node->key);\n            s[++top]=node;\n            node=node->left;\n        }\n        if(top==-1)\n            break;\n        node=s[top]->right;\n        top=top-1;\n    }\n    printf(\"\\n\");\n}\nvoid display(stack* stk){\n    if(stk->top==-1)\n        printf(\"STACK EMPTY\\n\");\n    else{\n        printf(\"  STACK\\n\");\n        for(int i=stk->top; i>=0; i--)\n            printf(\"    %d\\n\",stk->arr[i]);\n    }\n}\nvoid display_tree(list* root, int n){\n    if (root==NULL){\n        for (int i = 0; i < n-2; i++)\n            printf(\" \");\n        printf(\"NULL\\n\");\n    }\n    else{\n        display_tree(root->right,n+5);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\/\\n\");\n        for (int i = 0; i < n; i++)\n            printf(\" \");\n        printf(\"%d\\n\",root->key);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\\\\\\n\");\n        display_tree(root->left,n+5);\n    }\n}\nint main(){\n    int ch,d,x;\n    stack *stk;\n    list *T, *root;\n    while(1){\n        printf(\"\\n\");\n        printf(\"1. Initialise Binary Search Tree \\n\");\n        printf(\"2. Initialise the stack \\n\");\n        printf(\"3. Insert in Tree \\n\");\n        printf(\"4. Push in stack \\n\");\n        printf(\"5. Delete an element from tree \\n\");\n        printf(\"6. Pop from stack \\n\");\n        printf(\"7. Pre-Order Traversal of Tree \\n\");\n        printf(\"8. Display the stack \\n\");\n        printf(\"9. Display Graphical Tree \\n\");\n        printf(\"10. Exit Program \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1){\n            root=initialise_tree(root);\n            printf(\"Binary Search Tree Initialised. \\n\");\n        }\n        else if(ch==2){\n            printf(\"Enter size of the working Stack:\\n\");\n            scanf(\"%d\",&x);\n            stk=initialise_stack(x);\n            printf(\"Stack initialised. \\n\");\n        }\n        else if (ch==3){\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if (ch==4){\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if (ch==5){\n            int d;\n            printf(\"Enter No.to be deleted: \");\n            scanf(\"%d\",&d);\n            if(find(root,d)==1){\n                root=del_Node(root,d);\n                printf(\"%d has been Deleted \\n\",d);\n            }\n            else\n                printf(\"%d not found in tree.\\n\");\n        }\n        else if(ch==6)\n            pop(stk);\n        else if(ch==7){\n            if(root==NULL)\n                printf(\"SORRY, TREE EMPTY\\n\");\n            else{\n                printf(\"\\nPRE-ORDER:\\n\");\n                preorder(root);\n            }\n        }\n        else if(ch==8)\n            display(stk);\n        else if(ch==9)\n            display_tree(root,1);\n        else if(ch==10){\n            printf(\"Exitting, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\nint N;\nvoid printboard(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R \");\n            else\n                printf(\" - \");\n        }\n        printf(\"\\n\");\n    }\n}\nint safe(int arr[N][N], int row, int col){\n    int i,j;\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col+1; i < N && j < N; i++, j++)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col-1; i < N && j >= 0; i++, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row-1, j = col+1; i >= 0 && j < N; i--, j++)\n        if(arr[i][j])\n            return 0;\n    return 1;\n}\nvoid bishops(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        if(N>1){\n            int trs[N][N];\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    trs[j][i]=arr[i][j];\n            printboard(trs);\n        }\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            bishops(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}\nint main(){\n    int x=1;\n    while(x){\n        printf(\"Enter valid N i.e. for no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            x=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    bishops(arr,0);\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\nint N;\nint safe(int arr[N][N], int row, int col){\n    int i,j;\n    for ( i = 0; i < col; i++){\n        if(arr[row][i])\n            return 0;\n    }\n    for ( i = row, j = col; i >= 0 && j >= 0; i--, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    for ( i = row, j = col; i < N && j >= 0; i++, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    return 1;\n}\nint queens(int arr[N][N],int n){\n    if(n>=N)\n        return 1;\n    for (int i = 0; i < N; i++)\n    {\n        if(safe(arr,i,n)){\n            arr[i][n]=1;\n            if(queens(arr,n+1))\n                return 1;\n            arr[i][n]=0;\n        }\n    }\n    return 0;\n}\nint main(){\n    int n=1;\n    while(n){\n        printf(\"Enter valid N i.e no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            n=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    }\n    int ans=queens(arr,0);\n    if(ans==0)\n        printf(\"\\nSolution doesn't exist.\\n\");\n    else{\n        printf(\"\\nSolution by placing queens at:\");\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(arr[i][j])\n                    printf(\" %d,%d\",i,j);\n        printf(\".\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\nint N;\nvoid printboard(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R \");\n            else\n                printf(\" - \");\n        }\n        printf(\"\\n\");\n    }\n}\nint safe(int arr[N][N], int row, int col){\n    for (int i = 0; i < row; i++)\n        if(arr[row][i])\n            return 0;\n    for (int i = 0; i < col; i++)\n        if(arr[row][i])\n            return 0;\n    return 1;\n}\nvoid rooks(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        int trs[N][N], t=0;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                trs[j][i]=arr[i][j];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(trs[i][j]==arr[i][j])\n                    t++;\n        if(t!=(N*N))\n            printboard(trs);\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            rooks(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}\nint main(){\n    int x=1;\n    while(x){\n        printf(\"Enter valid N i.e for no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            x=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    rooks(arr,0);\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\nint N;\nvoid display(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        if(i==0){\n            for (int k = 0; k < N; k++)\n                printf(\" ---\");\n            printf(\"\\n\");\n        }\n        printf(\"|\");\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R |\");\n            else\n                printf(\"   |\");\n        }\n        printf(\"\\n\");\n        for (int k = 0; k < N; k++)\n            printf(\" ---\");\n        printf(\"\\n\");\n    }\n}\nint safe(int arr[N][N], int row, int col){\n    for (int i = 0; i < row; i++)\n        if(arr[row][i])\n            return 0;\n    for (int i = 0; i < col; i++)\n        if(arr[row][i])\n            return 0;\n    return 1;\n}\nvoid rooks(int arr[N][N], int n){\n    if(n>=N){\n        display(arr);\n        int trs[N][N], t=0;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                trs[j][i]=arr[i][j];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(trs[i][j]==arr[i][j])\n                    t++;\n        if(t!=(N*N))\n            display(trs);\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,n)){\n            arr[i][n]=1;\n            rooks(arr,n+1);\n            arr[i][n]=0;\n        }\n    }\n}\nint main(){\n    int n=1;\n    while(n){\n        printf(\"Enter valid N i.e no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            n=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    rooks(arr,0);\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct q{\n    int coeff;\n    int pow;\n    struct q* next;\n}node;\nvoid createNode(int c, int p, node** exp)\n{\n    if(c==0)\n        return;\n    node* x=*exp;\n    while(x)\n    {\n        if(x->pow == p)\n        {\n            if(x->coeff < 0 && c < 0)\n                x->coeff=-(x->coeff+c);\n            else\n                x->coeff=x->coeff+c;\n            return;\n        }\n        x=x->next;\n    }\n    node* ret=(node*) malloc(sizeof(node));\n    ret->coeff=c;\n    ret->pow=p;\n    if(*exp==NULL)\n    {\n        ret->next=*exp;\n        *exp=ret;\n    }\n    else\n    {\n            if(p > (*exp)->pow)\n            {\n                ret->next=*exp;\n                *exp=ret;\n            }\n            else\n            {\n                x=*exp;\n                while(x->next!=NULL && x->next->pow > p)\n                    x=x->next;\n                ret->next=x->next;\n                x->next=ret;\n            }\n    }\n}\nnode* poly_add_sub(char task, node* exp1, node* exp2)\n{\n    node* res=NULL;\n    while(exp1 || exp2)\n    {\n        if(!exp2)\n        {\n            createNode(exp1->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n        }\n        else if(!exp1)\n        {\n            if(task=='+')\n                createNode(exp2->coeff,exp2->pow,&res);\n            else\n            createNode(-(exp2->coeff),exp2->pow,&res);\n            exp2=exp2->next;\n        }\n        else if(exp1->pow > exp2->pow)\n        {\n            createNode(exp1->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n        }\n        else if(exp1->pow < exp2->pow)\n        {\n            if(task=='+')\n                createNode(exp2->coeff,exp2->pow,&res);\n            else\n                createNode(-(exp2->coeff),exp2->pow,&res);\n            exp2=exp2->next;\n        }\n        else if(exp1->pow == exp2->pow )\n        {\n            if(task=='+' && (exp1->coeff + exp2->coeff)!=0)\n                createNode(exp1->coeff+exp2->coeff,exp1->pow,&res);\n            else if(task=='-' && (exp1->coeff - exp2->coeff)!=0)\n                createNode(exp1->coeff-exp2->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n            exp2=exp2->next;\n        }\n    }\n    return res;\n}\nnode* poly_mul(node* exp1, node* exp2)\n{\n    node* res=NULL;\n    node* t=exp2;\n    while(exp1)\n    {\n        while(t)\n        {\n            createNode(exp1->coeff * t->coeff,exp1->pow + t->pow,&res);\n            t=t->next;\n        }\n        t=exp2;\n        exp1=exp1->next;\n    }\n    return res;\n}\nvoid display(node* res)\n{\n    int f=0;\n    while(res)\n    {\n        if(res->coeff>0)\n        {\n            if(f==0)\n                printf(\" %dx^%d \",res->coeff,res->pow);\n            else\n                printf(\"+ %dx^%d \",res->coeff,res->pow);\n        }\n        else if(res->coeff<0)\n            printf(\"- %dx^%d \",-res->coeff,res->pow);\n        f=1;\n        res=res->next;\n    }\n}\nint main()\n{\n    {\n        node* exp1=NULL; node* exp2=NULL;\n        char fexp[51],sexp[51];\n        printf(\"Input in this format \\\" +\/- ax^y +\/- ... +\/- ... \\\"\\n\");\n        printf(\"Enter 1st Exp. = \");\n        gets(fexp);\n        printf(\"Enter 2nd Exp. = \");\n        gets(sexp);\n        if(strlen(fexp)==0 && strlen(sexp)==0)\n        {\n            printf(\"No expression found.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)>=51 || strlen(sexp)>=51)\n        {\n            printf(\"Expressions too lengthy.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)!=0 && strlen(sexp)==0)\n            printf(\" %s\\n\",fexp);\n        else if(strlen(fexp)==0 && strlen(sexp)!=0)\n            printf(\" %s\\n\",sexp);\n        else\n        {\n            {\n                if(fexp[0]!='-'){\n                    for(int i=50; i>0; i--) fexp[i]=fexp[i-1];\n                    fexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(fexp); i++)\n                {\n                    if(fexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(fexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(fexp[i+1]=='-' && fexp[i+2]!=' ')\n                            {\n                                i++;\n                                b[c2++]=fexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=fexp[i];\n                    }\n                    else if(fexp[i]=='+' || fexp[i]=='-' || fexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp1);\n                            if(fexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=fexp[i];\n                            }\n                        }\n                    else if(t==1)\n                            b[c2++]=fexp[i];\n                }\n            }\n            {\n                if(sexp[0]!='-'){\n                    for(int i=50; i>0; i--) sexp[i]=sexp[i-1];\n                    sexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(sexp); i++)\n                {\n                    if(sexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(sexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(sexp[i+1]=='-')\n                            {\n                                i++;\n                                b[c2++]=sexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=sexp[i];\n                    }\n                    else if(t==1)\n                    {\n                        if(sexp[i]=='+' || sexp[i]=='-' || sexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp2);\n                            if(sexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=sexp[i];\n                            }\n                        }\n                        else\n                            b[c2++]=sexp[i];\n                    }\n                }\n            }\n            while(1)\n            {\n                int ch;\n                printf(\"\\n\\n1. ADDITION\\n\");\n                printf(\"2. SUBTRACTION\\n\");\n                printf(\"3. MULTIPLICATION\\n\");\n                printf(\"4. PRINT EXPRESSIONS\\n\");\n                printf(\"5. EXIT PROGRAM\\n\");\n                printf(\"What operation do you want to perform: \");\n                scanf(\"%d\",&ch);\n                if(ch==5)\n                {\n                    printf(\"Exitting Program, Thank You.\\n\");\n                    break;\n                }\n                switch (ch)\n                {\n                case 1:\n                    printf(\"\\n\");\n                    display(poly_add_sub('+',exp1,exp2));\n                    break;\n                case 2:\n                    printf(\"\\n\");\n                    display(poly_add_sub('-',exp1,exp2));\n                    break;\n                case 3:\n                    printf(\"\\n\");\n                    display(poly_mul(exp1,exp2));\n                    break;\n                case 4:\n                    printf(\"\\nExpression 1: \");\n                    display(exp1);\n                    printf(\"\\nExpression 2: \");\n                    display(exp2);\n                    break;\n                default:\n                    printf(\"Invalid choice!\\n\");\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MAX 50\ntypedef struct\n{\n    int top;\n    unsigned int size;\n    float* arr;\n}stack;\nstack* createStack(unsigned int x)\n{\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(float*) malloc(x * sizeof(float));\n    return ret;\n}\nfloat c2i(char x)\n{\n    return (int)x - (int)'0';\n}\nvoid push(stack* stk, float n)\n{\n    stk->arr[++(stk->top)]=n;\n}\nfloat pop(stack* stk)\n{\n    return stk->arr[stk->top--];\n}\nint isOperator(char ch)\n{\n    if (ch=='+' || ch=='-' || ch=='*' || ch=='\/')\n        return 1;\n    else\n        return 0;\n}\nfloat operation(float f, char x, float s)\n{\n    if (x=='+')\n        return f+s;\n    if (x=='-')\n        return f-s;\n    if (x=='*')\n        return f*s;\n    else\n        return f\/s;\n}\nfloat evaluatePostfix(char exp[])\n{\n    stack* stk=createStack(strlen(exp));\n    int i=0;\n    float f=0,s=0,t=0;\n    while (exp[i]!='\\0')\n    {\n        if((exp[i]==',' && exp[i+1]==',') || (exp[i]==' ' && exp[i+1]==' '))\n            i++;\n        else if((exp[i]==',' && exp[i+1]==' ') || (exp[i]==' ' && exp[i+1]==','))\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        else if((int)exp[i]>47 && (int)exp[i]<58)\n            t=(t*10)+c2i(exp[i]);\n        else if(exp[i]==',' || exp[i]==' ')\n        {\n            push(stk,t);\n            t=0;\n        }\n        else if(isOperator(exp[i]))\n        {\n            if(stk->top-2<-1)\n            {\n                printf(\"Underflow, not enough operands.\\n\");\n                return 0;\n            }\n            s=pop(stk);\n            f=pop(stk);\n            push(stk,operation(f,exp[i],s));\n            if(i+1<stk->size)\n                i++;\n        }\n        else\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        i++;\n    }\n    if(stk->top!=0)\n    {\n        printf(\"Overflow, too may operands.\\n\");\n        return 0;\n    }\n    return stk->arr[stk->top];\n}\nint main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePostfix(exp);\n            if(ans)\n                printf(\"Postfix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MAX 50\ntypedef struct\n{\n    int top;\n    unsigned int size;\n    float* arr;\n}stack;\nstack* createStack(unsigned int x)\n{\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(float*) malloc(x * sizeof(float));\n    return ret;\n}\nint reverse(int x)\n{\n    int f=0;\n    while(x>0){\n        f=(f*10)+x%10;\n        x=x\/10;\n    }\n    return f;\n}\nfloat c2i(char x)\n{\n    return (int)x - (int)'0';\n}\nvoid push(stack* stk, float n)\n{\n    printf(\"Pushed %f\\n\",n);\n    stk->arr[++(stk->top)]=n;\n}\nfloat pop(stack* stk)\n{\n    printf(\"\\nPopped %f\\n\",stk->arr[stk->top]);\n    return stk->arr[stk->top--];\n}\nint isOperator(char ch)\n{\n    if (ch=='+' || ch=='-' || ch=='*' || ch=='\/')\n        return 1;\n    else\n        return 0;\n}\nfloat operation(float f, char x, float s)\n{\n    if (x=='+')\n        return f+s;\n    if (x=='-')\n        return f-s;\n    if (x=='*')\n        return f*s;\n    else\n        return f\/s;\n}\nfloat evaluatePrefix(char exp[])\n{\n    stack* stk=createStack(strlen(exp));\n    int i=strlen(exp)-1;\n    float f=0,s=0,t=0;\n    while (i>=0)\n    {\n        if((exp[i]==',' && exp[i-1]==',') || (exp[i]==' ' && exp[i-1]==' '))\n            i--;\n        else if((exp[i]==',' && exp[i-1]==' ') || (exp[i]==' ' && exp[i-1]==','))\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        else if((int)exp[i]>47 && (int)exp[i]<58)\n            t=(t*10)+c2i(exp[i]);\n        else if(exp[i]==',' || exp[i]==' ')\n        {\n            push(stk,reverse(t));\n            t=0;\n        }\n        else if(isOperator(exp[i]))\n        {\n            if(stk->top-2<-1)\n            {\n                printf(\"Underflow, not enough operands.\\n\");\n                return 0;\n            }\n            f=pop(stk);\n            s=pop(stk);\n            push(stk,operation(f,exp[i],s));\n            if(i-1>-1)\n                i--;\n        }\n        else\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        i--;\n    }\n    if(stk->top!=0)\n    {\n        printf(\"Overflow, too may operands.\\n\");\n        return 0;\n    }\n    return stk->arr[stk->top];\n}\nint main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePrefix(exp);\n            if(ans)\n                printf(\"Prefix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct\n{\n    int top;\n    unsigned int size;\n    int* arr;\n}stack;\nstack* createstack(unsigned int x)\n{\n    stack* ret=(stack* ) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int* )malloc(x * sizeof(int));\n    return ret;\n}\nvoid push(stack* stk, int n)\n{\n    if(stk->top==(stk->size-1))\n        printf(\"OVERFLOW!\\n\");\n    else\n    {\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}\nvoid pop(stack* stk)\n{\n    if(stk->top==-1)\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}\nvoid peek(stack* stk)\n{\n    if(stk->top==-1)\n        printf(\"SORRY, STACK EMPTY!\\n\");\n    else\n        printf(\"Top element is %d\\n\",stk->arr[stk->top]);\n}\nint main()\n{\n    int ch,x;\n    printf(\"Enter size of the working Stack:\\n\");\n    scanf(\"%d\",&x);\n    stack* stk=createstack(x);\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. PEEK\\n\");\n        printf(\"4. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if(ch==2)\n            pop(stk);\n        else if(ch==3)\n            peek(stk);\n        else if (ch==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"target":"sdukesameer","func":"\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct\n{\n    int top;\n    unsigned int size;\n    int* arr;\n}stack;\nstack* createstack(unsigned int x)\n{\n    stack* ret=(stack* ) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int* )malloc(x * sizeof(int));\n    return ret;\n}\nint is_full(stack* stk)\n{\n    if(stk->top==(stk->size-1))\n        return 1;\n    else\n        return 0;\n}\nvoid push(stack* stk, int n)\n{\n    if(is_full(stk))\n        printf(\"OVERFLOW!\\n\");\n    else\n    {\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}\nint is_empty(stack* stk)\n{\n    if(stk->top==-1)\n        return 1;\n    else\n        return 0;\n}\nvoid pop(stack* stk)\n{\n    if(is_empty(stk))\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}\nint main()\n{\n    int ch,x;\n    printf(\"Enter size of the working Stack:\\n\");\n    scanf(\"%d\",&x);\n    stack* stk=createstack(x);\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if(ch==2)\n            pop(stk);\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n \nint     ft_to_lower(char c, char d)\n{\n    if (c >= 'A' && c <= 'Z')\n    {\n        if (d != ' ' && d != '\\t' && d != '\\0')\n            return (1);\n    }\n    return (0);\n}\n \nint     ft_to_upper(char c, char d)\n{\n    if (c >= 'a' && c <= 'z')\n    {\n        if (d == ' ' || d == '\\t' || d == '\\0')\n            return (1);\n    }\n    return (0);\n}\n \nint     main(int ac, char **av)\n{\n    int i;\n    int i2;\n \n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                else if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n#include \"biggest_pal.h\"\n\nint     ft_strlen(char *str)\n{\n    int i = 0;\n    while (str[i] != '\\0')\n        i++;\n    return (i);\n}\n\nvoid        ft_putstr(char *str)\n{\n    int i = 0;\n    while (str[i] != '\\0')\n    {\n        write(1, &str[i], 1);\n        i++;\n    }\n}\n\nvoid        pal(char *str)\n{\n    t_pal   pal;\n    t_pal   count;\n    t_pal   old;\n    int     i = 0;\n    int     max;\n\n    count.end = ft_strlen(str) - 1;\n    max = count.end;\n    while (str[i] != '\\0')\n    {\n        count.length = 1;\n        count.start = i;\n        old.start = i;\n        old.end = count.end;\n        max = count.end;\n        while (str[count.start] == str[count.end])\n        {\n            if (count.start == count.end || count.start + 1 == count.end)\n            {\n                if (old.end - old.start >= pal.length)\n                {\n                    pal.start = old.start;\n                    pal.end = old.end + 1;\n                    pal.length = old.end - old.start;\n                }\n                break ;\n            }\n            count.length++;\n            count.start++;\n            count.end--;\n        }\n        count.start = old.start;\n        count.end = old.end;\n        if (max == pal.length)\n            break ;\n        if (str[i + 1] == '\\0' && count.end > 0)\n        {\n            count.end--;\n            i = -1;\n        }\n        i++;\n    }\n    if (pal.length == 0)\n    {\n        ft_putstr(&str[ft_strlen(str) - 1]);\n        return ;\n    }\n    str[pal.end] = '\\0';\n    ft_putstr(&str[pal.start]);\n}\n\nint         main(int ac, char **av)\n{\n\n    if (ac == 2)\n    {\n        pal(av[1]);\n    }\n    ft_putstr(\"\\n\");\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     matching(char b1, char b2)\n{\n    if (b1 == '(' && b2 == ')')\n        return (1);\n    if (b1 == '[' && b2 == ']')\n        return (1);\n    if (b1 == '{' && b2 == '}')\n        return (1);\n    return (0);\n}\n\nint     brackets(char   *str, char *store)\n{\n    int     ctrl;\n    int     top;\n\n    ctrl = 0;\n    top = -1;\n    while (str[ctrl])\n    {\n        if (str[ctrl] == '(' || str[ctrl] == '[' || str[ctrl] == '{')\n        {\n            top++;\n            store[top] = str[ctrl];\n        }\n        if (str[ctrl] == ')' || str[ctrl] == ']' || str[ctrl] == '}')\n        {\n            if (!store[top])\n                return(0);\n            if (!matching(store[top],str[ctrl]))\n                return (0);\n            else\n            {\n                store[top] = 0;\n                top--;\n            }\n        }\n        ctrl++;\n    }\n    if (store[top] == 0)\n        return(1);\n    return (0);\n}\n\nint     main(int ac, char **av)\n{\n    char    store[500];\n\n    if (ac > 1)\n    {\n        if (brackets(av[1],store))\n            write(1, \"OK\",2);\n        else\n            write(1, \"Error\",5);\n    }\n    write(1,\"\\n\",1);\n    return(0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdlib.h>\n#include <unistd.h>\n\nint     counter(char *src, int ctrl)\n{\n    int dir;\n    int count;\n    count = 0;\n\n    if (src[ctrl] == '[')\n        dir = 1;\n    if (src[ctrl] == ']')\n        dir = -1;\n    while(src[ctrl])\n    {\n        if (src[ctrl] == '[')\n            count++;\n        if (src[ctrl] == ']')\n            count--;\n        if ((src[ctrl] == '[' || src[ctrl] == ']') && count == 0)\n            return (ctrl);\n        ctrl += dir;\n    }\n    return (0);\n}\n\nvoid    brainfuck(char *src)\n{\n    char    *str;\n    int     pointer;\n    int     ctrl;\n\n    ctrl = 0;\n    pointer = 0;\n    str = (char*)malloc(sizeof(char) * 2048);\n    while (src[ctrl])\n    {\n        if (src[ctrl] == '>')\n            pointer++;\n        else if (src[ctrl] == '<')\n            pointer--;\n        else if (src[ctrl] == '+')\n            str[pointer]++;\n        else if (src[ctrl] == '-')\n            str[pointer]--;\n        else if ((src[ctrl] == '[' && !str[pointer]) || (src[ctrl] == ']' && str[pointer]))\n                ctrl = counter(src, ctrl);\n        else if (src[ctrl] == '.')\n            write(1, &str[pointer], 1);\n        ctrl++;\n    }\n}\nint     main(int argc, char **av)\n{\n    if (argc > 1)\n        brainfuck(av[1]);\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"header.h\"\n\nstatic void p(t_m *m, int x, int y)\n{\n    int att_x;\n    int att_y;\n\n    att_x = x - 1;\n    att_y = y - 1;\n    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))\n        m->mate = 1;\n    att_x = x + 1;\n    att_y = y - 1;\n    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))\n        m->mate = 1;\n}\n\nstatic void recursive_check(t_m *m, int x, int y)\n{\n    if (is_in_range(m, x, y))\n    {\n        if (is_king(m, x, y))\n            m->mate = 1;\n        else if (!is_enemy(m, x, y))\n            recursive_check(m, x + m->off_x, y + m->off_y);\n    }\n}\n\nstatic void special_check(t_m *m, int x, int y)\n{\n    m->off_x = x;\n    m->off_y = y;\n    recursive_check(m, m->act_x + x, m->act_y + y);\n}\n\nvoid        check_enemy(t_m *m, int x, int y)\n{\n    m->act_x = x;\n    m->act_y = y;\n    if (m->enemy == 'P')\n        p(m, x, y);\n    if (m->enemy == 'B' || m->enemy == 'Q')\n    {\n        special_check(m, -1, -1);\n        special_check(m, 1, -1);\n        special_check(m, 1, 1);\n        special_check(m, -1, 1);\n    }\n    if (m->enemy == 'R' || m->enemy == 'Q')\n    {\n        special_check(m, 0, -1);\n        special_check(m, 1, 0);\n        special_check(m, 0, 1);\n        special_check(m, -1, 0);\n    }\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     ft_strlen(char *str)\n{\n    int     len;\n\n    len = 0;\n    while (str[len])\n        len++;\n    return (len);\n}\n\nint     is_piece(char p)\n{\n    return (p == 'P' || p == 'B' || p == 'R' || p == 'Q');\n}\n\nint     check_pawn(char **tab, int r, int c, int size)\n{\n    return (r - 1 >= 0\n            && ((c - 1 >= 0 && tab[r - 1][c - 1] == 'K')\n                || (c + 1 < size && tab[r - 1][c + 1] == 'K')));\n}\n\nint     check_bishop(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n\n    r = row - 1;\n    c = col - 1;\n    while (r >= 0 && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c--] == 'K')\n            return (1);\n    r = row - 1;\n    c = col + 1;\n    while (r >= 0 && c < size && !is_piece(tab[r][c]))\n        if (tab[r--][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col - 1;\n    while (r < size && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r++][c--] == 'K')\n            return (1);\n    r = row + 1;\n    c = col + 1;\n    while (r < size && c < size && !is_piece(tab[r][c]))\n        if (tab[r++][c++] == 'K')\n            return (1);\n    return (0);\n}\n\nint     check_rook(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n\n    r = row - 1;\n    c = col;\n    while (r >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c] == 'K')\n            return (1);\n    r = row;\n    c = col + 1;\n    while (c < size && !is_piece(tab[r][c]))\n        if (tab[r][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col;\n    while (r < size && !is_piece(tab[r][c]))\n        if (tab[r++][c] == 'K')\n            return (1);\n    r = row;\n    c = col - 1;\n    while (c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r][c--] == 'K')\n            return (1);\n    return (0);\n}\n\nint     is_checkmate(char **tab, int size)\n{\n    int     r;\n    int     c;\n\n    r = 0;\n    while (r < size)\n    {\n        c = 0;\n        while (c < size)\n        {\n            if (tab[r][c] == 'P' && check_pawn(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'B' && check_bishop(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'R' && check_rook(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'Q' && (check_bishop(tab, r, c, size)\n                        || check_rook(tab, r, c, size)))\n                return (1);\n            c++;\n        }\n        r++;\n    }\n    return (0);\n}\n\nint     main(int ac, char **av)\n{\n    if (ac < 2)\n        return (write(1, \"\\n\", 1));\n    if (is_checkmate(av + 1, ac - 1))\n        return (write(1, \"Success\\n\", 8));\n    else\n        return (write(1, \"Fail\\n\", 5));\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"list.h\"\n#include <stdlib.h>\n\nint     cycle_detector(const t_list *list)\n{\n    const t_list *p;\n    const t_list *q;\n\n    p = list;\n    q = list;\n    while (p && q && q->next)\n    {\n        p = p->next;\n        q = q->next->next;\n        if (p == q)\n            return (1);\n    }\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     main(int ac, char **av)\n{\n    int     i;\n\n    i = 0;\n    if (ac == 2)\n    {\n        while (av[1][i] == ' ' || av[1][i] == '\\t')\n            i++;\n        while(av[1][i])\n        {\n            if (av[1][i] > 32)\n                write(1, &av[1][i], 1);\n            if (av[1][i] <= 32 && av[1][i + 1] > 32)\n                write(1, \" \", 1);\n            i++;\n        }\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"header.h\"\n\nstatic int  check_empty(t_m *m)\n{\n    if (m->ac > 1)\n        return (0);\n    else\n        return (1);\n}\n\nstatic void loop(t_m *m, int x, int y)\n{\n    if (y == m->ac)\n        final_print(m);\n    else if (m->av[y][x] == 0)\n        loop(m, 0, y + 1);\n    else\n    {\n        if (is_enemy(m, x, y))\n        {\n            m->enemy = m->av[y][x];\n            check_enemy(m, x, y);\n        }\n        loop(m, x + 1, y);\n    }\n}\n\nvoid        execute(t_m *m)\n{\n    if (!check_empty(m))\n        loop(m, 0, 1);\n    else\n        write(1, \"\\n\", 1);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     main(int ac, char **av)\n{\n    int     i;\n\n    i = 0;\n    if (ac == 2)\n    {\n        while (av[1][i] == ' ' || av[1][i] == '\\t')\n            i++;\n        while (av[1][i])\n        {\n            if ((av[1][i] == ' ') || (av[1][i] == '\\t'))\n            {\n                if (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n                    write(1, \"   \", 3);\n            }\n            else if (av[1][i] != ' ' || av[1][i] != '\\t')\n                write(1, &av[1][i],1);\n            i++;\n        }\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid    fprime(int nb)\n{\n    int i;\n\n    i = 2;\n    if (nb == 1)\n    {\n        printf(\"1\");\n        return ;\n    }\n    while (nb >= i)\n    {\n        if (nb % i == 0)\n        {\n            printf(\"%d\",i);\n            if (nb != i)\n            {\n                printf(\"%c\",'*');\n                nb \/= i;\n                i--;\n            }\n        }\n        i++;\n    }\n}\nint     main(int ac, char **av)\n{\n    if (ac == 2)\n        fprime(atoi(av[1]));\n    printf(\"\\n\");\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\nint     ft_len(int nb)\n{\n    int len;\n\n    len = 1;\n    if (nb < 0)\n    {\n        nb *= -1\n        len++;\n    }\n    while (nb > 9)\n    {\n        nb \/= 10;\n        len++;\n    }\n    return (len);\n}\n\nint     ft_div(int nb)\n{\n    int div;\n    div = 1;\n    if (nb == 1)\n        return (div);\n    while (nb > 1)\n    {\n        div *= 10;\n        nb--;\n    }\n    return (div);\n}\n\nchar    *ft_itoa(int nbr)\n{\n    int     i;\n    int     len;\n    int     lne2;\n    char    *res;\n\n    len = ft_len(nbr);\n    len2 = len;\n    if (!(res = (char*)malloc(sizeof(char*) * (len + 1))))\n        return (NULL);\n    if (nbr == -2147483648)\n        return (\"-2147483648\");\n    i = 0;\n    if (nbr < 0)\n    {\n        nbr *= -1;\n        len--;\n        res[0] = '-';\n        i++;\n    }\n    while (i < len2)\n    {\n        res[i++] = (((nbr \/ ft_div(len--)) % 10) + 48);\n    }\n    res[i] = '\\0';\n    return (res);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\nchar    *ft_str_dup(char *str)\n{\n    int     ctrl;\n    int     len;\n    char    *cpy;\n\n    len = 0;\n    ctrl = 0;\n    while (str[len])\n        len++;\n    if (!(cpy = (char*)malloc(sizeof(char) len + 1)))\n        return (NULL);\n    while (str[ctrl])\n    {\n        cpy[ctrl] = str[ctrl];\n        ctrl++;\n    }\n    cpy[ctrl] = '\\0';\n    return (ctrl);\n}\n\nint     ft_len(int nb, int base)\n{\n    int     ctrl;\n\n    if (nb < 0)\n        nb *= -1;\n    ctrl = 0;\n    while(nb > 0)\n    {\n        nb \/= base;\n        ctrl++;\n    }\n    return (ctrl);\n}\n\nchar    *ft_itoa_base(int value, int base)\n{\n    int     ctrl;\n    int     len;\n    int     n;\n    char    *radix;\n    char    *res;\n\n    if (value == 0 && base == 10)\n        ft_strdup(\"0\");\n    if (value == -2147483648 && base == 10)\n        ft_strdup(\"-2147483648\");\n    if (value < 0 base == 0)\n        n = 1;\n    if (!(res = (char*)malloc(sizeof(char) * (len + n + 1))))\n        return (NULL);\n    if (n == 1)\n    {\n        res[0] = '-';\n        len++;\n    }\n    res[len] = '\\0';\n    if(value < 0)\n        value *= -1;\n    while (len > n)\n    {\n        res[len - 1] = radix[value % base];\n        value \/= base; \n        len--;\n    }\n    return (res);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nvoid        ft_putchar(char c)\n{\n    write(1, &c, 1);\n}\n\nvoid        ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb \/ 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}\n\nint     ft_atoi(char *str)\n{\n    int     i;\n    int     res;\n\n    i = 0;\n    res = 0;\n    while (str[i])\n    {\n        res *= 10;\n        res = str[i] - 48;\n        i++;\n    }\n    return (res);\n}\n\nint     ft_is_prime(int nb)\n{\n    int i;\n\n    i = 2;\n    while (i < nb)\n    {\n        if (nb % i == 0)\n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nint     ft_add_prime_sum(int nb)\n{\n    int     i;\n    int     sum;\n\n    i = 2;\n    sum = 0;\n        if (nb <= 0)\n            return (0);\n    while (i <= nb)\n    {\n        if (ft_is_prime(i))\n            sum += i;\n        i++;\n    }\n    return (sum);\n}\n\nint     main(int ac, char **av)\n{\n    if (ac == 2)\n        ft_putnbr(ft_add_prime_sum(ft_atoi(av[1])));\n    else if (ac != 2 || ft_atoi(av[1]) < 0)\n        write(1, \"0\", 1);\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n\nint     ft_abs(int a)\n{\n    if (a < 0)\n        return (-a);\n    return (a);\n}\n\nint     *ft_range(int start, int end)\n{\n    int     *tab;\n    int     i;\n\n    i = 0;\n    if (!(tab = (int*)malloc(sizeof(int*) *ft_abs (start - end) + 1)))\n        return (NULL);\n    if (start > end)\n    {\n            while (start >= end)\n        {\n            tab[i] = start--;\n            i++;\n        }\n        tab[i] = '\\0';\n    }\n    else if (start < end)\n    {\n        while (start <= end)\n        {\n            tab[i] = start++;\n            i++;\n        }\n        tab[i] = '\\0';\n    }\n    return (tab);\n}\n\nint main()\n{\n    int a = 0;\n    int b = -3;\n\n    int     i;\n    i = 0;\n    int *tab =ft_range(a,b);\n    while (tab[i])\n    {\n        printf(\"%d \",tab[i]);\n        i++;\n    }\n    printf(\"%d \",tab[i]);\n    i++;\n    while (tab[i])\n    {\n        printf(\"%d \",tab[i]);\n        i++;\n    }\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint     ft_abs(int x)\n{\n    if (x < 0)\n        return (x *  -1);\n    return (x);\n}\nint     *ft_rrange(int start, int end)\n{\n    int     i;\n    int     *tab;\n\n    i = 0;\n    if (!(tab = (int*)malloc(sizeof(int*) * (ft_abs(end - start) + 1))))\n        return (NULL);\n    if (end > start)\n    {\n        while (end >= start)\n        tab[i++] = end--;\n    }\n    else if (end < start)\n    {\n        while (end <= start)\n        tab[i++] = end++;\n    }\n    tab[i] = '\\0';\n    return (tab);\n}\nint     main ()\n{\n    int a;\n    int *b;\n\n    b = ft_rrange(0,-3);\n    printf(\"%d %d %d %d %d %d\",b[0],b[1],b[2],b[3],b[4],b[5]);\n    \n    return(0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar    **ft_split(char *str)\n{\n    char    **tab;\n    int i;\n    int i2;\n    int i3;\n\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char**) * 1000);\n    while (str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n            {\n                tab[i2][i3] = str[i];\n                i++;\n                i3++;\n            }\n            tab[i2][i3] = '\\0';\n            i2++;\n        }\n        i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}\nint     main(int ac, char **av)\n{\n    if (ac > 1)\n    {\n        char **a = ft_split(av[1]);\n    \n        printf(\"%s\\n%s\\n%s\\n\",a[0],a[1],a[2]);\n    }\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n#include <stdio.h>\n\nint     main(int ac, char **av)\n{\n    int     i;\n    int     j;\n    int     count;\n\n    count = 0;\n    i = 0;\n    j = 0;\n    if (ac == 3)\n    {\n        while (av[1][i] != '\\0')\n        {\n            while (av[2][j] != '\\0')\n            {\n                if (av[1][i] == av[2][j])\n                {\n                    count++;\n                    break;\n                }\n                j++;\n            }\n            i++;\n        }\n        if (av[1][count] == '\\0')\n            write(1, \"1\", 1);\n        else\n            write(1, \"0\", 1);\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"#include \"header.h\"\n\nint is_in_range(t_m *m, int x, int y)\n{\n    if (x < 0 || x >= m->len || y < 1 || y >= m->ac)\n        return (0);\n    return (1);\n}\n\nint is_king(t_m *m, int x, int y)\n{\n    char    c;\n\n    c = m->av[y][x];\n    if (c == 'K')\n        return (1);\n    else\n        return (0);\n}\n\nint is_enemy(t_m *m, int x, int y)\n{\n    char    c;\n\n    c = m->av[y][x];\n    if (c == 'P' || c == 'B' || c == 'R' || c == 'Q')\n        return (1);\n    else\n        return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include \"header.h\"\n\nstatic int  ft_strlen(char *s)\n{\n    int i;\n\n    i = 0;\n    if (s != 0)\n    {\n        while (s[i])\n        {\n            ++i;\n        }\n    }\n    return (i);\n}\n\nt_m         m_init(int ac, char **av)\n{\n    t_m m;\n\n    m.debug = 1;\n    m.ac = ac;\n    m.av = av;\n    m.len = ft_strlen(av[1]);\n    m.enemy = 0;\n    m.mate = 0;\n    m.act_x = 0;\n    m.act_y = 0;\n    m.off_x = 0;\n    m.off_y = 0;\n    return (m);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     main(int argc, char **argv)\n{\n    int i = 1;\n    int t[32] = {0};\n    int j = 0;\n\n    if (argc == 1)\n    {\n        write(1, \"options: abcdefghijklmnopqrstuvwxyz\\n\", 36);\n        return (0);\n    }\n    i = 1;\n    while (i < argc)\n    {\n        j = 1;\n        if (argv[i][0] == '-')\n        {\n            while (argv[i][j] && argv[i][j] >= 'a' && argv[i][j] <= 'z')\n            {\n                if (argv[i][j] == 'h')\n                {\n                    write(1, \"options: abcdefghijklmnopqrstuvwxyz\\n\", 36);\n                    return (0);\n                }\n                t['z' - argv[i][j] + 6] = 1;\n                j++;\n            }\n            if (argv[i][j])\n            {\n                write(1, \"Invalid Option\\n\", 15);\n                return (0);\n            }\n            j++;\n        }\n        i++;\n    }\n    i = 0;\n    while (i < 32)\n    {\n        t[i] = '0' + t[i];\n        write(1, &t[i++], 1);\n        if (i == 32)\n            write(1, \"\\n\", 1);\n        else if (i % 8 == 0)\n            write(1, \" \", 1);\n    }\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n \nvoid    ft_print_hex(unsigned char c)\n{\n    char *radix;\n \n    radix = \"0123456789abcdef\";\n    write(1, &radix[c \/ 16], 1);\n    write(1, &radix[c % 16], 1);\n}\n \nvoid    ft_print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}\n \nvoid    print_memory(const void *addr, size_t size)\n{\n    size_t i;\n    size_t j;\n    unsigned char *ptr;\n \n    i = 0;\n    j = 0;\n    ptr = (unsigned char*)addr;\n    while (i < size)\n    {\n        j = 0;\n        while (j < 16 && i + j < size)\n        {\n            ft_print_hex(ptr[i + j]);\n            if (j % 2)\n                write(1, \" \", 1);\n            j++;\n        }\n        while (j < 16)\n        {\n            write(1, \"  \", 2);\n            if (j % 2)\n                write(1, \" \", 1);\n            j++;\n        }\n        j = 0;\n        while (j < 16 && i + j < size)\n        {\n            ft_print_char(ptr[i + j]);\n            j++;\n        }\n        write(1, \"\\n\", 1);\n        i += 16;\n    }\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n#include <stdlib.h>\n\nvoid    ft_putchar(char c)\n{\n    write(1, &c, 1);\n}\n\nvoid    ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb \/ 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}\n\nvoid    ft_pgcd(int a, int b)\n{\n    int     cdn;\n    int     i;\n\n    i = 1;\n    cdn = 0;\n    while (i < a && i < b)\n    {\n        if (a % i == 0 && b % i == 0)\n            cdn = i;\n        i++;\n    }\n    ft_putnbr(cdn);\n}\n\nint     main(int ac, char **av)\n{\n    if (ac == 3)\n    {\n        ft_pgcd(atoi(av[1]), atoi(av[2]));\n    \n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nvoid    ft_putchar(char c)\n{\n    write(1, &c, 1);\n}\n\nint     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n\n    res = 0;\n    sign = 1;\n    if (str[0] == '-')\n        sign = -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + str[i] - 48;\n        i++;\n    }\n    return (res * sign);\n}\n\nvoid    ft_print_hex(int nb)\n{\n    if (nb > 16)\n    {\n        ft_print_hex(nb \/ 16);\n        ft_print_hex(nb % 16);\n    }\n    if (nb < 10)\n        ft_putchar(nb + 48);\n    else if (nb < 16)\n        ft_putchar(nb + 87);\n}\n\nint     main(int ac, char **av)\n{\n    if (ac == 2)\n    {\n        ft_print_hex(ft_atoi(av[1]));\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nvoid    print_hex(unsigned char c)\n{\n    char    *radix;\n\n    radix = \"0123456789abcdef\";\n    write(1, &radix[c \/ 16], 1);\n    write(1, &radix[c % 16], 1);\n}\n\nvoid    print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}\n\nvoid    print_memory(const void *addr, size_t size)\n{\n    unsigned char   *adr;\n    size_t  i;\n    size_t  j;\n\n    i = 0;\n    j = 0;\n    adr = (unsigned char*)addr;\n    while (i < size)\n    {\n        j = 0;\n        while (j < 16 && i+j < size)\n        {\n            print_hex(adr[i + j]);\n            if (j%2)\n                write(1,\" \",1);\n            j++;\n        }\n        while (j < 16)\n        {\n            write(1, \"  \", 2);\n            if (j%2)\n                write(1, \" \",1);\n            j++;\n        }\n        j = 0;\n        while (j < 16 && i+j < size)\n        {\n            print_char(adr[i +j]);\n            j++;\n        }\n        write(1,\"\\n\",1);\n        i += 16;\n    }\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid    ft_pustr(char *str)\n{\n    int i;\n    i = 0;\n    while (str[i])\n        write(1, &str[i++], 1);\n}\n\nchar    **ft_split(char *str)\n{\n    int i;\n    int i1;\n    int i2;\n    int i3;\n    char    **tab;\n\n    i = 0;\n    i2 = 0;\n    if (!(tab = (char**)malloc(sizeof(char**) * 1000)))\n        return (NULL);\n    while (str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n                tab[i2][i3++] = str[i++];\n            tab[i2++][i3] = '\\0';\n        }\n        else\n            i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}\nint main(int ac, char **av)\n{\n    char **word;\n    int i;\n\n    i = 0;\n    if (ac ==  2)\n    {\n        word = ft_split(av[1]);\n        while (word[i] != 0)\n            i++;\n        while(--i >= 0)\n        {\n            ft_pustr(word[i]);\n            write(1, \" \", 1);\n        }\n    }\n    write(1, \"\\n\", 1);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n#include <stdlib.h>\n\nvoid    ft_putstr(char *str)\n{\n    int i;\n\n    i = 0;\n    while(str[i])\n        write(1, &str[i++], 1);\n}\n\nchar    **ft_split(char *str)\n{\n    int i;\n    int i2;\n    int i3;\n    char **tab;\n\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char*) * 1000);\n    while(str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n                tab[i2][i3++] = str[i++];\n            tab[i2++][i3] = '\\0';\n        }\n        else\n            i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}\nint     main(int ac, char **av)\n{\n    int i;\n    char    **word;\n\n    i = 1;\n    if(ac == 2)\n    {\n        word = ft_split(av[1]);\n        while (word[i] != 0)\n        {\n            ft_putstr(word[i++]);\n            write(1, \" \", 1);\n        }\n        ft_putstr(word[0]);\n    }\n    write(1, \"\\n\",1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\nint     operation(int a, int b, char op)\n{\n    if (op == '+')\n        return (a + b);\n    if (op == '-')\n        return (a - b);\n    if (op == '*')\n        return (a * b);\n    if (op == '\/')\n    {\n        if (b == 0)\n            return (99);\n        return (a \/ b);\n    }\n    if (op == '%')\n    {\n        if (b == 0)\n            return (99);\n        return (a % b);\n    }\n    return (99);\n}\n\nint     isop(char   op)\n{\n    if (op == '+' || op == '-' || op == '\/' || op == '%' || op == '*')\n        return (1);\n    return(0);\n}\n\nint     isnum(char *str)\n{\n    int ctrl;\n    ctrl = 0;\n    if (str[ctrl] == '+' || str[ctrl] == '-')\n        ctrl++;\n    if (str[ctrl] >= 0 && str[ctrl] <= 9)\n        return (1);\n    return (0);\n}\n\nint     rpn_calc(char *str, int *stack)\n{\n    int     ctrl;\n    int     top;\n\n    top = -1;\n    ctrl = 0;\n    while(str[ctrl])\n    {\n        if(isnum(str))\n        {\n            top++;\n            stack[top] = atoi(&str[ctrl]);\n            while (str[ctr] != ' ' && str[ctrl] != '\\0')\n                ctrl++;\n        }\n        if (isop(str[ctrl]))\n        {\n            if (top > 0)\n            {\n                if(stack[top - 1] = operate(stack[top - 1],stack[top],str[ctrl]) == 99)\n                    write(1, \"Error\\n\",6);\n                top--;\n            }\n            else\n                write(1,\"Error\\n\",6);\n        }\n        ctrl++;\n    }\n    if(top == 0)\n        printf(\"%d\\n\",stack[top]);\n    else\n        write(1,\"Error\\n\",6);\n    return(0);\n}\nint     main(int ac, char **av)\n{\n    int stack[512];\n\n    if (ac == 2)\n        rpn_calc(av[1], stack);\n    else\n        write(1, \"Error\\n\", 6);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\nvoid sort_int_tab(int *tab, unsigned int size)\n{\n    int     i;\n    int     tmp;\n\n    i = 0;\n    while (i < size)\n    {\n        if (tab[i] > tab[i + 1])\n        {\n            tmp = tab[i];\n            tab[i] = tab[i + 1];\n            tab[i + 1] = tmp;\n            i = -1\n        }\n        i++;\n    }\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\nt_list  *sort_list(t_list* lst, int (*cmp)(int, int))\n{\n    int swap;\n    t_list  *tmp;\n\n    tmp = lst;\n    while (lst->next)\n    {\n        if (((*cmp)(lst->data,lst->next->data))==0)\n        {\n            swap = lst->data;\n            lst->data = lst->next->data;\n            lst->next->data = swap;\n            lst = tmp;\n        }\n        else\n            lst->lst->next;\n    }\n    lst= tmp;\n    return (lst);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n \nint     ft_to_lower(char c, char d, int i)\n{\n    if (c != ' ' && c != '\\t' && i != -1)\n    {\n        if (d >= 'A' && d <= 'Z')\n            return (1);\n    }\n    return (0);\n}\n \nint     ft_to_upper(char c, char d)\n{\n    if (c == ' ' || c == '\\t')\n    {\n        if (d >= 'a' && d <= 'z')\n            return (1);\n    }\n    return (0);\n}\n \nint     main(int ac, char **av)\n{\n    int i;\n    int i2;\n \n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (av[i][0] >= 'a' && av[i][0] <= 'z')\n                    av[i][0] -= 32;\n                else if (ft_to_lower(av[i][i2 - 1], av[i][i2], i2 - 1))\n                    av[i][i2] += 32;\n                else if (ft_to_upper(av[i][i2 - 1], av[i][i2]))\n                    av[i][i2] -= 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     toupperr(char a, char d)\n{\n    if (a >= 'a' && a <= 'z')\n    {\n        if (d  == ' ' || d == '\\t' || d == '\\0')\n            return (1);\n    }\n    return(0);\n}\n\nint     tolowerr(char a, char d)\n{\n    if (a >= 'A' && a <= 'Z')\n    {\n        if (d != ' ' && d != '\\t' && d != '\\0')\n        {\n            return (1);\n        }\n    }\n    return (0);\n}\n\nint     main(int ac,char **av)\n{\n    int     i;\n    int     i2;\n\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)  \n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2])\n            {\n                if (tolowerr(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                else if (toupperr(av[i][i2] , av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            i++;\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\",1);\n    return(0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n\nint     ft_toupper(char  a,char b)\n{\n    if ( a == ' ' || a == '\\t')\n    {\n        if (b >= 'a' && b <= 'z')\n            return (1);\n    }\n    return (0);\n}\n\nint     ft_tolower(char a, char b, int i)\n{\n    if (a != ' ' && a != '\\t' && i != -1)\n    {\n        if (b >= 'A' && b <= 'Z')\n            return (1);\n    }\n    return (0);\n}\n\nint     main(int ac, char **av)\n{\n    int i;\n    int j;\n    if (ac > 1)\n    {\n        i = 1;\n        while (i < ac)\n        {\n\n            \n            j = 0;\n            while (av[i][j])\n            {\n                if (av[i][0] >= 'a' && av[i][0] <= 'z')\n                    av[i][0] -= 32;\n                else if (ft_tolower(av[i][j - 1], av[i][j], j - 1))\n                    av[i][j] += 32;\n                else if (ft_toupper(av[i][j - 1] , av[i][j]))\n                    av[i][j] -= 32;\n                write(1, &av[i][j], 1);\n                j++;\n            }\n            i++;\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\",1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"\n\n\n\n\n\n\n\n\n\n\n\n#include <unistd.h>\n#include <stdio.h>\n\nvoid    ft_putchar(char c)\n{\n    write(1, &c,1);\n}\n\nvoid    ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb \/ 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}\n\nint     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n\n    sign = -1;\n    res = 0;\n    if (str[0] == '-')\n        sign *= -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + (str[i] - 48);\n        i++;\n    }\n    return (res * sign);\n}\n\nint     main(int    ac,char **av)\n{\n    int     n;\n    int     i;\n\n    if (ac == 2)\n    {\n        n = ft_atoi(av[1]);\n        i = 1;\n        while (i <= 9)\n        {\n            ft_putnbr(i);\n            write(1, \" x \", 3);\n            ft_putnbr(n);\n            write(1, \" = \", 3); \n            ft_putnbr(i * n);\n            write(1, \"\\n\", 1);\n            i++;\n        }\n    }\n    else\n        write(1 , \"\\n\", 1);\n    return (0);\n}\n"}
{"target":"seefeesaw","func":"#include <stdio.h>\n\nint fib(int n)\n{\n    int t0=0,t1=1,s=0,i;\n\n    if(n<=1)return n;\n    for(i = 2;i<=n;i++)\n    {\n        s=t0 + t1;\n        t0 = t1;\n        t1 = s;\n    }\n    return s;\n}\n\nint rfib(int n)\n{\n    if(n <=1)return n;\n    return rfib(n-2) + rfib(n - 1);\n}\n\nint F[10];\nint mfib(int n)\n{\n     if (n <= 1)\n     {\n         F[n] = n;\n         return n;\n     }\n     else\n     {\n         if (F[n - 2] == -1)\n         {\n             F[n - 2] = mfib(n - 2);\n         }\n         if (F[n - 1] == -1)\n         {\n             F[n - 1] = mfib(n - 1);\n         }\n         F[n] = F[n - 2] + F[n - 1];\n         return F[n - 2] + F[n - 1];\n     }\n}\n     int main()\n     {\n         int i;\n         for ( i = 0; i < 10; i++)\n         {\n             F[i] =-1;\n         }\n         printf(\"%d \\n\",mfib(5));\n         return 0;\n     }\n"}
{"target":"seefeesaw","func":"#include <stdio.h>\n\ndouble e(int x,int n)\n{\n    static double p = 1, f = 1;\n    double r;\n\n    if(n == 0)\n    {\n        return 1;\n    }\n    r = e(x,n-1);\n    p = p * x;\n    f = f*n;\n    return r + p\/f;\n}\ndouble e1(int x,int n)\n{\n    static double s = 1;\n    if(n == 0)\n    {\n        return s;\n    }\n    s = 1+s*x\/n;\n    return e1(x,n-1);\n}\ndouble ei(int x,int n)\n{\n    double s=1;\n    int i;\n    double num = 1;\n    double den = 1;\n    for(i = 1;i<=n;i++)\n    {\n        num*=x;\n        den*=i;\n        s+=num\/den;\n    }\n    return s;\n}\n\nint main()\n{\n    printf(\"%lf \\n\",ei(4,10));\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    long double min, max, kolejna, suma = 0, srednia;\n\n    printf(\"Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\\nLiczby:\\n\");\n    scanf(\"%Lf\", &kolejna);\n\n    suma += kolejna;\n\n\n    if (kolejna != 0)\n    {\n        int i = 1;\n        min = kolejna;\n        max = kolejna;\n        scanf(\"%Lf\", &kolejna);\n        suma += kolejna;\n        srednia = suma \/ i++;\n        while (kolejna)\n        {\n            if (kolejna > max)\n                max = kolejna;\n            else {\n                if (kolejna < min)\n                    min = kolejna;\n            }\n            scanf(\"%Lf\", &kolejna);\n            suma += kolejna;\n            srednia = suma \/ i++;\n        }\n\n        printf(\"min = %.2Lf, max = %.2Lf\\n\", min, max);\n        printf(\"suma = %.2Lf, \", suma);\n        printf(\"srednia = %.2Lf, \", srednia);\n    }\n    else\n        printf(\"Ciag wejsciowy jest pusty.\\n\");\n\n    return 0;\n}\n"}
{"target":"shengelenge","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX 1000\n\nlong oblicz(int A[], int n)\n{\n    long w = A[0];\n    for (int i = 1; i <= n ; i++)\n    {\n        w = w*2 + A[i];\n    }\n    return w;\n}\n\nint main()\n{\n    int A[MAX];\n    long w;\n    int n;\n    printf(\"podaj liczbe cyfr wczytywanej liczby binarnej: \");\n    scanf(\"%d\", &n);\n    printf(\"Podaj %d cyfr liczby (od lewej): \", n);\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"A[%d] = \", i);\n        scanf(\"%d\", &A[i]);\n    }\n\n    w = oblicz(A, n-1);\n    printf(\"Iteracyjnie: wynik = %ld\", w);\n    printf(\"(10)\");\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n#include <math.h>\n\ndouble E = 0.000001;\n\ndouble pierwiastek(double p, double E)\n{\n    double a = 1, b = p;\n\n    while (fabs(a - b) >= E)\n    {\n        a = (a + b) \/ 2;\n        b = p \/ a;\n    }\n\n    return a;\n}\n\nint main()\n{\n    double x, y;\n\n    printf(\"Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: \");\n    scanf(\"%2lf\", &x);\n\n    y = pierwiastek(x, E);\n\n    printf(\"Pierwiastek = %.3lf\", y);\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\ntypedef enum { false, true } bool;\n\nbool czy_pierwsza(int n)\n{\n    if (n <2)\n        return false;\n\n    for (int i = 2; i*i <= n ; i++) {\n        if (n % i == 0)\n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    unsigned int n;\n\n    printf(\"Podaj liczbe naturlana: \");\n    scanf(\"%d\", &n);\n\n    if (czy_pierwsza(n))\n        printf(\"Liczba %u jest pierwsza.\\n\", n);\n    else\n        printf(\"Liczba %u nie jest pierwsza.\\n\", n);\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    int sum1 = 0;\n    int sum2 = 0;\n    int sum3 = 0;\n    int i = 1;\n    int j = 1;\n\n    printf(\"Petla for:\\n\");\n    for (int i = 1; i <=100; i +=2)\n    {\n        sum1 += i;\n        printf (\"%d\\n\", sum1 );\n    }\n\n    printf(\"\\nPetla while:\\n\");\n    while (i <= 100)\n    {\n        sum2 += i;\n        printf(\"%d\\n\", sum2);\n        i += 2;\n    }\n\n    printf(\"\\nPetla do while:\\n\");\n    do {\n        sum3 += j;\n        printf(\"%d\\n\", sum3);\n        j += 2;\n    } while (j <= 100);\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    long double min, max, kolejna, suma = 0, srednia;\n\n    printf(\"Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\\nLiczby:\\n\");\n    scanf(\"%Lf\", &kolejna);\n\n    suma += kolejna;\n\n\n    if (kolejna != 0)\n    {\n        int i = 1;\n        min = kolejna;\n        max = kolejna;\n        scanf(\"%Lf\", &kolejna);\n        suma += kolejna;\n        srednia = suma \/ i++;\n        while (kolejna)\n        {\n            if (kolejna > max)\n                max = kolejna;\n            else {\n                if (kolejna < min)\n                    min = kolejna;\n            }\n            scanf(\"%Lf\", &kolejna);\n            suma += kolejna;\n            srednia = suma \/ i++;\n        }\n\n        printf(\"min = %.2Lf, max = %.2Lf\\n\", min, max);\n        printf(\"suma = %.2Lf, \", suma);\n        printf(\"srednia = %.2Lf, \", srednia);\n    }\n    else\n        printf(\"Ciag wejsciowy jest pusty.\\n\");\n\n    return 0;\n}\n"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    char ch;\n\n    printf(\"Podaj jeden znak: \");\n    scanf(\"%c\", &ch);\n\n    switch (ch)\n    {\n        case 65:\n            printf(\"S\");\n            break;\n        case 66:\n            printf(\"N\");\n            break;\n        case 67:\n            printf(\"V\");\n            break;\n        case 68:\n            printf(\"F\");\n            break;\n        case 69:\n            printf(\"R\");\n            break;\n        case 70:\n            printf(\"G\");\n            break;\n        case 71:\n            printf(\"H\");\n            break;\n        case 72:\n            printf(\"J\");\n            break;\n        case 73:\n            printf(\"O\");\n            break;\n        case 74:\n            printf(\"K\");\n            break;\n        case 75:\n            printf(\"L\");\n            break;\n        case 76:\n            printf(\":\");\n            break;\n        case 77:\n            printf(\"<\");\n            break;\n        case 78:\n            printf(\"M\");\n            break;\n        case 79:\n            printf(\"P\");\n            break;\n        case 80:\n            printf(\"{\");\n            break;\n        case 81:\n            printf(\"W\");\n            break;\n        case 82:\n            printf(\"T\");\n            break;\n        case 83:\n            printf(\"D\");\n            break;\n        case 84:\n            printf(\"Y\");\n            break;\n        case 85:\n            printf(\"I\");\n            break;\n        case 86:\n            printf(\"B\");\n            break;\n        case 87:\n            printf(\"E\");\n            break;\n        case 88:\n            printf(\"C\");\n            break;\n        case 89:\n            printf(\"U\");\n            break;\n        case 90:\n            printf(\"X\");\n            break;\n        case 97:\n            printf(\"s\");\n            break;\n        case 98:\n            printf(\"n\");\n            break;\n        case 99:\n            printf(\"v\");\n            break;\n        case 100:\n            printf(\"f\");\n            break;\n        case 101:\n            printf(\"r\");\n            break;\n        case 102:\n            printf(\"g\");\n            break;\n        case 103:\n            printf(\"h\");\n            break;\n        case 104:\n            printf(\"j\");\n            break;\n        case 105:\n            printf(\"o\");\n            break;\n        case 106:\n            printf(\"k\");\n            break;\n        case 107:\n            printf(\"l\");\n            break;\n        case 108:\n            printf(\";\");\n            break;\n        case 109:\n            printf(\",\");\n            break;\n        case 110:\n            printf(\"m\");\n            break;\n        case 111:\n            printf(\"p\");\n            break;\n        case 112:\n            printf(\"[\");\n            break;\n        case 113:\n            printf(\"w\");\n            break;\n        case 114:\n            printf(\"t\");\n            break;\n        case 115:\n            printf(\"d\");\n            break;\n        case 116:\n            printf(\"y\");\n            break;\n        case 117:\n            printf(\"i\");\n            break;\n        case 118:\n            printf(\"b\");\n            break;\n        case 119:\n            printf(\"e\");\n            break;\n        case 120:\n            printf(\"c\");\n            break;\n        case 121:\n            printf(\"u\");\n            break;\n        case 122:\n            printf(\"x\");\n            break;\n        default:\n            printf(\"Podany znak nie jest litera.\");\n            break;\n    }\n\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX 1000\n\nlong oblicz(int A[], int n)\n{\n    long w = A[0];\n    for (int i = 1; i <= n ; i++)\n    {\n        w = w*2 + A[i];\n    }\n    return w;\n}\n\nint main()\n{\n    int A[MAX];\n    long w;\n    int n;\n    printf(\"podaj liczbe cyfr wczytywanej liczby binarnej: \");\n    scanf(\"%d\", &n);\n    printf(\"Podaj %d cyfr liczby (od lewej): \", n);\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"A[%d] = \", i);\n        scanf(\"%d\", &A[i]);\n    }\n\n    w = oblicz(A, n-1);\n    printf(\"Iteracyjnie: wynik = %ld\", w);\n    printf(\"(10)\");\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n#include <math.h>\n\ndouble E = 0.000001;\n\ndouble pierwiastek(double p, double E)\n{\n    double a = 1, b = p;\n\n    while (fabs(a - b) >= E)\n    {\n        a = (a + b) \/ 2;\n        b = p \/ a;\n    }\n\n    return a;\n}\n\nint main()\n{\n    double x, y;\n\n    printf(\"Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: \");\n    scanf(\"%2lf\", &x);\n\n    y = pierwiastek(x, E);\n\n    printf(\"Pierwiastek = %.3lf\", y);\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    double a, b, c;\n\n    printf(\"Podaj 3 liczby typu double:\\n\");\n    scanf(\"%lf\\n%lf\\n%lf\", &a, &b, &c);\n\n    if (a > b && a > c)\n    {\n        if (b > c)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", c, b,a);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", b, c, a);\n    }\n\n    if (b > a && b > c)\n    {\n        if (a > c)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", c, a, b);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", a, c, b);\n    }\n\n    if (c > a && c > b)\n    {\n        if (a > b)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", b, a, c);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", a, b, c);\n    }\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\ntypedef enum { false, true } bool;\n\nbool czy_pierwsza(int n)\n{\n    if (n <2)\n        return false;\n\n    for (int i = 2; i*i <= n ; i++) {\n        if (n % i == 0)\n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    unsigned int n;\n\n    printf(\"Podaj liczbe naturlana: \");\n    scanf(\"%d\", &n);\n\n    if (czy_pierwsza(n))\n        printf(\"Liczba %u jest pierwsza.\\n\", n);\n    else\n        printf(\"Liczba %u nie jest pierwsza.\\n\", n);\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    double a, b, c;\n    double x1, x2;\n    double delta;\n\n    printf(\"Podaj liczby a, b i c:\\n\");\n    printf(\"a = \");\n    scanf(\"%lf\", &a);\n    printf(\"b = \");\n    scanf(\"%lf\", &b);\n    printf(\"c = \");\n    scanf(\"%lf\", &c);\n\n    delta = b*b - 4*a*c;\n\n    if (delta > 0)\n    {\n        x1 = (-1*b +  sqrt(delta))\/2*a;\n        x2 = (-1*b -  sqrt(delta))\/2*a;\n        printf(\"Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf\", a,  b, c, x1, x2);\n    }\n\n    if (delta == 0)\n    {\n        x1 = (-1*b)\/2*a;\n        printf(\"Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf\", a,  b, c, x1);\n    }\n\n    if (delta < 0)\n        printf(\"Brak miejsc zerowych.\");\n\n    return 0;\n}"}
{"target":"shengelenge","func":"#include <stdio.h>\n\nint main()\n{\n    int sum1 = 0;\n    int sum2 = 0;\n    int sum3 = 0;\n    int i = 1;\n    int j = 1;\n\n    printf(\"Petla for:\\n\");\n    for (int i = 1; i <=100; i +=2)\n    {\n        sum1 += i;\n        printf (\"%d\\n\", sum1 );\n    }\n\n    printf(\"\\nPetla while:\\n\");\n    while (i <= 100)\n    {\n        sum2 += i;\n        printf(\"%d\\n\", sum2);\n        i += 2;\n    }\n\n    printf(\"\\nPetla do while:\\n\");\n    do {\n        sum3 += j;\n        printf(\"%d\\n\", sum3);\n        j += 2;\n    } while (j <= 100);\n\n    return 0;\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint Last_Occurence(char P[],int m,char c)\n{\n    int i,k=0;\n    for(i=m-1;i>=0;i--)\n    {\n        if(P[i]==c)\n        k=i;\n    }\n    return(k);\n}\nint Boyre_Moore(char S[],char P[],int n,int m)\n{\n    int i=m-1,j=m-1,l;\n    while(i<n && i>=0)\n    {\n        if(P[j]==S[i])\n        {\n            if(j==0)\n            return(i);\n            else\n            {\n                i=i-1;\n                j=j-1;\n            }\n        }\n        else\n        {\n            l=Last_Occurence(P,m,S[i]);\n            i=i+m-(l+1);\n            j=m-1;\n        }\n    }\n}\nvoid main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    scanf(\"%s\",S);\n    printf(\"\\nEnter Pattern:\");\n    scanf(\"%s\",P);\n    n=strlen(S);\n    m=strlen(P);\n    i=Boyre_Moore(S,P,n,m);\n    printf(\"\\nThe pattern is found at position %d\",i);\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nvoid Brute_Force(char S[],char P[],int n,int m)\n{\n    int i=0,j=0,k;\n    while(i<n && j<m)\n    {\n        k=i-m+1;\n        if(P[j]==S[i])\n        {\n            i=i+1;\n            j=j+1;\n        }\n        else\n        {\n            i=i+1;\n            j=0;\n        }\n    }\n    if(j==m)    \n    {\n        printf(\"pattern found at %d\",k);\n    }\n    else\n    {\n        printf(\"pattern not found\");\n    }\n}\nvoid main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    scanf(\"%s\",S);\n    printf(\"\\nEnter Pattern:\");\n    scanf(\"%s\",P);\n    n=strlen(S);\n    m=strlen(P);\n    Brute_Force(S,P,n,m);\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct tree\n{\n    int val;\n    struct tree *left;\n    struct tree *right;\n}*root=NULL,*temp=NULL,*q=NULL;\nint value;\nstruct tree* find_max(struct tree* root)\n{\n    if(root==NULL || root->right==NULL)\n    return(root);\n    else\n    return(find_max(root->right));  \n}\nstruct tree* insert(struct tree* root,int tar)\n{\n    struct tree* p=(struct tree*)malloc(sizeof(struct tree));\n    p->val=tar;\n    p->left=NULL;\n    p->right=NULL;\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=insert(root->left,tar);\n        else if(tar>root->val)\n        root->right=insert(root->right,tar);\n        else if(tar==root->val)\n        return(root);\n    }\n    else\n    {\n        root=p;\n        return(root);\n    }\n}\nstruct tree* delete(struct tree* root,int tar)\n{\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=delete(root->left,tar);\n        else if(tar>root->val)\n        root->right=delete(root->right,tar);\n        else if(tar==root->val)\n        {\n            if(root->left==NULL && root->right==NULL)\n            {\n                root=NULL;\n            }\n            else if(root->left==NULL && root->right!=NULL)\n            {\n                temp=root;\n                root=root->right;\n                free(temp);\n            }\n            else if(root->left!=NULL && root->right==NULL)\n            {\n                temp=root;\n                root=root->left;\n                free(temp);\n            }\n            else\n            {\n                temp=find_max(root->left);\n                root->val=temp->val;\n                root->left=delete(root->left,temp->val);\n            }\n        }\n        return(root);\n    }\n    else\n    {\n        return(root);\n    }\n}\nstruct tree* search(struct tree* root,int tar)\n{\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=search(root->left,tar);\n        else if(tar>root->val)\n        root->right=search(root->right,tar);\n        else if(tar==root->val)\n        {\n            printf(\"\\nElement found\");\n            return(root);\n        }       \n    }\n    else\n    {\n        printf(\"\\neither tree is empty or element not found\");\n        return(root);\n    }\n}\nvoid inorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        inorder(root->left);\n        printf(\"\\t%d\",root->val);\n        inorder(root->right);\n    }\n}\nvoid preorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        printf(\"\\t%d\",root->val);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\nvoid postorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"\\t%d\",root->val);\n    }\n}\nvoid main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter value to insert:\");\n                scanf(\"%d\",&value);\n                root=insert(root,value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                root=delete(root,value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                root=search(root,value);\n                break;\n            }\n            case 4:\n            {\n                inorder(root);\n                break;\n            }\n            case 5:\n            {\n                preorder(root);\n                break;\n            }\n            case 6:\n            {\n                postorder(root);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX 4\n#define MIN 2\n\n  struct btreeNode {\n        int val[MAX + 1], count;\n        struct btreeNode *link[MAX + 1];\n  };\n\n  struct btreeNode *root;\n\n  \n  struct btreeNode * createNode(int val, struct btreeNode *child) {\n        struct btreeNode *newNode;\n        newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        newNode->val[1] = val;\n        newNode->count = 1;\n        newNode->link[0] = root;\n        newNode->link[1] = child;\n        return newNode;\n  }\n\n  \n  void addValToNode(int val, int pos, struct btreeNode *node,\n                        struct btreeNode *child) {\n        int j = node->count;\n        while (j > pos) {\n                node->val[j + 1] = node->val[j];\n                node->link[j + 1] = node->link[j];\n                j--;\n        }\n        node->val[j + 1] = val;\n        node->link[j + 1] = child;\n        node->count++;\n  }\n\n  \n  void splitNode (int val, int *pval, int pos, struct btreeNode *node,\n     struct btreeNode *child, struct btreeNode **newNode) {\n        int median, j;\n\n        if (pos > MIN)\n                median = MIN + 1;\n        else\n                median = MIN;\n\n        *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        j = median + 1;\n        while (j <= MAX) {\n                (*newNode)->val[j - median] = node->val[j];\n                (*newNode)->link[j - median] = node->link[j];\n                j++;\n        }\n        node->count = median;\n        (*newNode)->count = MAX - median;\n\n        if (pos <= MIN) {\n                addValToNode(val, pos, node, child);\n        } else {\n                addValToNode(val, pos - median, *newNode, child);\n        }\n        *pval = node->val[node->count];\n        (*newNode)->link[0] = node->link[node->count];\n        node->count--;\n  }\n\n  \n  int setValueInNode(int val, int *pval,\n     struct btreeNode *node, struct btreeNode **child) {\n\n        int pos;\n        if (!node) {\n                *pval = val;\n                *child = NULL;\n                return 1;\n        }\n\n        if (val < node->val[1]) {\n                pos = 0;\n        } else {\n                for (pos = node->count;\n                        (val < node->val[pos] && pos > 1); pos--);\n                if (val == node->val[pos]) {\n                        printf(\"Duplicates not allowed\\n\");\n                        return 0;\n                }\n        }\n        if (setValueInNode(val, pval, node->link[pos], child)) {\n                if (node->count < MAX) {\n                        addValToNode(*pval, pos, node, *child);\n                } else {\n                        splitNode(*pval, pval, pos, node, *child, child);\n                        return 1;\n                }\n        }\n        return 0;\n  }\n\n  \n  void insertion(int val) {\n        int flag, i;\n        struct btreeNode *child;\n\n        flag = setValueInNode(val, &i, root, &child);\n        if (flag)\n                root = createNode(i, child);\n  }\n\n  \n  void copySuccessor(struct btreeNode *myNode, int pos) {\n        struct btreeNode *dummy;\n        dummy = myNode->link[pos];\n\n        for (;dummy->link[0] != NULL;)\n                dummy = dummy->link[0];\n        myNode->val[pos] = dummy->val[1];\n\n  }\n\n  \n  void removeVal(struct btreeNode *myNode, int pos) {\n        int i = pos + 1;\n        while (i <= myNode->count) {\n                myNode->val[i - 1] = myNode->val[i];\n                myNode->link[i - 1] = myNode->link[i];\n                i++;\n        }\n        myNode->count--;\n  }\n\n  \n  void doRightShift(struct btreeNode *myNode, int pos) {\n        struct btreeNode *x = myNode->link[pos];\n        int j = x->count;\n\n        while (j > 0) {\n                x->val[j + 1] = x->val[j];\n                x->link[j + 1] = x->link[j];\n        }\n        x->val[1] = myNode->val[pos];\n        x->link[1] = x->link[0];\n        x->count++;\n\n        x = myNode->link[pos - 1];\n        myNode->val[pos] = x->val[x->count];\n        myNode->link[pos] = x->link[x->count];\n        x->count--;\n        return;\n  }\n\n  \n  void doLeftShift(struct btreeNode *myNode, int pos) {\n        int j = 1;\n        struct btreeNode *x = myNode->link[pos - 1];\n\n        x->count++;\n        x->val[x->count] = myNode->val[pos];\n        x->link[x->count] = myNode->link[pos]->link[0];\n\n        x = myNode->link[pos];\n        myNode->val[pos] = x->val[1];\n        x->link[0] = x->link[1];\n        x->count--;\n\n        while (j <= x->count) {\n                x->val[j] = x->val[j + 1];\n                x->link[j] = x->link[j + 1];\n                j++;\n        }\n        return;\n  }\n\n  \n  void mergeNodes(struct btreeNode *myNode, int pos) {\n        int j = 1;\n        struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];\n\n        x2->count++;\n        x2->val[x2->count] = myNode->val[pos];\n        x2->link[x2->count] = myNode->link[0];\n\n        while (j <= x1->count) {\n                x2->count++;\n                x2->val[x2->count] = x1->val[j];\n                x2->link[x2->count] = x1->link[j];\n                j++;\n        }\n\n        j = pos;\n        while (j < myNode->count) {\n                myNode->val[j] = myNode->val[j + 1];\n                myNode->link[j] = myNode->link[j + 1];\n                j++;\n        }\n        myNode->count--;\n        free(x1);\n  }\n\n  \n  void adjustNode(struct btreeNode *myNode, int pos) {\n        if (!pos) {\n                if (myNode->link[1]->count > MIN) {\n                        doLeftShift(myNode, 1);\n                } else {\n                        mergeNodes(myNode, 1);\n                }\n        } else {\n                if (myNode->count != pos) {\n                        if(myNode->link[pos - 1]->count > MIN) {\n                                doRightShift(myNode, pos);\n                        } else {\n                                if (myNode->link[pos + 1]->count > MIN) {\n                                        doLeftShift(myNode, pos + 1);\n                                } else {\n                                        mergeNodes(myNode, pos);\n                                }\n                        }\n                } else {\n                        if (myNode->link[pos - 1]->count > MIN)\n                                doRightShift(myNode, pos);\n                        else\n                                mergeNodes(myNode, pos);\n                }\n        }\n  }\n\n  \n  int delValFromNode(int val, struct btreeNode *myNode) {\n        int pos, flag = 0;\n        if (myNode) {\n                if (val < myNode->val[1]) {\n                        pos = 0;\n                        flag = 0;\n                } else {\n                        for (pos = myNode->count;\n                                (val < myNode->val[pos] && pos > 1); pos--);\n                         if (val == myNode->val[pos]) {\n                                flag = 1;\n                        } else {\n                                flag = 0;\n                        }\n                }\n                if (flag) {\n                        if (myNode->link[pos - 1]) {\n                                copySuccessor(myNode, pos);\n                                flag = delValFromNode(myNode->val[pos], myNode->link[pos]);\n                                if (flag == 0) {\n                                        printf(\"Given data is not present in B-Tree\\n\");\n                                }\n                        } else {\n                                removeVal(myNode, pos);\n                        }\n                } else {\n                        flag = delValFromNode(val, myNode->link[pos]);\n                }\n                if (myNode->link[pos]) {\n                        if (myNode->link[pos]->count < MIN)\n                                adjustNode(myNode, pos);\n                }\n        }\n        return flag;\n  }\n\n  \n  void deletion(int val, struct btreeNode *myNode) {\n        struct btreeNode *tmp;\n        if (!delValFromNode(val, myNode)) {\n                printf(\"Given value is not present in B-Tree\\n\");\n                return;\n        } else {\n                if (myNode->count == 0) {\n                        tmp = myNode;\n                        myNode = myNode->link[0];\n                        free(tmp);\n                }\n        }\n        root = myNode;\n        return;\n  }\n\n  \n  void searching(int val, int *pos, struct btreeNode *myNode) {\n        if (!myNode) {\n                return;\n        }\n\n        if (val < myNode->val[1]) {\n                *pos = 0;\n        } else {\n                for (*pos = myNode->count;\n                        (val < myNode->val[*pos] && *pos > 1); (*pos)--);\n                if (val == myNode->val[*pos]) {\n                        printf(\"Given data %d is present in B-Tree\", val);\n                        return;\n                }\n        }\n        searching(val, pos, myNode->link[*pos]);\n        return;\n  }\n\n  \n  void traversal(struct btreeNode *myNode) {\n        int i;\n        if (myNode) {\n                for (i = 0; i < myNode->count; i++) {\n                        traversal(myNode->link[i]);\n                        printf(\"%d \", myNode->val[i + 1]);\n                }\n                traversal(myNode->link[i]);\n        }\n  }\n\n  int main() {\n        int val, ch;\n        while (1) {\n                printf(\"1. Insertion\\t2. Deletion\\n\");\n                printf(\"3. Searching\\t4. Traversal\\n\");\n                printf(\"5. Exit\\nEnter your choice:\");\n                scanf(\"%d\", &ch);\n                switch (ch) {\n                        case 1:\n                                printf(\"Enter your input:\");\n                                scanf(\"%d\", &val);\n                                insertion(val);\n                                break;\n                        case 2:\n                                printf(\"Enter the element to delete:\");\n                                scanf(\"%d\", &val);\n                                deletion(val, root);\n                                break;\n                        case 3:\n                                printf(\"Enter the element to search:\");\n                                scanf(\"%d\", &val);\n                                searching(val, &ch, root);\n                                break;\n                        case 4:\n                                traversal(root);\n                                break;\n                        case 5:\n                                exit(0);\n                        default:\n                                printf(\"U have entered wrong option!!\\n\");\n                                break;\n                }\n                printf(\"\\n\");\n        }\n  }\n\n"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct list\n{\n    int val;\n    struct list* next;\n}*front=NULL,*rear=NULL,*temp=NULL,*q=NULL;\nint value,i=0;\nvoid insert(int tar)\n{\n    struct list* p=(struct list*)malloc(sizeof(struct list));\n    p->val=tar;\n    p->next=NULL;\n    if(rear==NULL)\n    {\n        front=rear=p;\n    }\n    else\n    {\n        rear->next=p;\n        rear=p;\n        rear->next=front;\n    }\n}\nvoid delete(int tar)\n{\n    if(rear==NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        temp=front;\n        q=front;\n        while(temp!=rear)\n        {\n            if(temp->val==tar)\n            {\n                if(temp==front)\n                {\n                    front=front->next;\n                    rear->next=front;\n                    free(temp);\n                    temp=front;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==tar)\n        {\n            q->next=front;\n            temp=NULL;\n            free(temp);\n        }\n    }\n}\nvoid search(int tar)\n{\n    if(rear==NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            if(temp->val==tar)\n            {\n                printf(\"\\nvalue found\");\n                i++;\n            }\n        }\n        if(temp->val==tar)\n        {\n            printf(\"\\nvalue found\");\n            i++;\n        }\n    }\n    if(i==0)\n    printf(\"\\nvalue not found in the list\");\n}\nvoid display()\n{\n    if(rear==NULL)\n    printf(\"\\nlist is empty\");\n    else\n    {\n        printf(\"\\nList is:\\n\");\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            printf(\"\\t%d\",temp->val);\n        }\n        printf(\"\\t%d\",temp->val);\n        printf(\"\\t%d\",temp->next->val);\n    }\n}\nvoid main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                insert(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                delete(value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 5\nint queue[MAX];\nint value;\nint i=0,x=0;\nint f=-1,r=-1;\nvoid enqueue(int val)\n{\n    if(r==-1)\n    {\n        f=(f+1)%MAX;\n        r=(r+1)%MAX;\n        queue[r]=val;\n    }\n    else if((r==MAX-1 && f==0) || r==f-1)\n    {\n        printf(\"\\nQueue is FULL\");\n    }\n    else\n    {\n        r=(r+1)%MAX;\n        queue[r]=val;\n    }\n}\nint dequeue()\n{\n    if((f==-1 && r==-1))\n    {\n        printf(\"\\nQueue is Empty\");\n        return(-1);\n    }\n    else\n    {\n        if(f==(r+1)%MAX && queue[f]==-1)    \n        {\n            printf(\"\\nQueue is Empty\");\n            return(-1);\n        }\n        else\n        {\n            value=queue[f];\n            queue[f]=-1;\n            f=(f+1)%MAX;\n            return(value);\n        }\n    }\n}\nvoid search(int val)\n{\n    i=0;\n    if((f==-1 && r==-1))\n    printf(\"\\nQueue is Empty\");\n    else if(f==(r+1)%MAX && queue[f]==-1)\n    printf(\"\\nQueue is Empty\");\n    else\n    {   \n        i=f;\n        while(i!=r)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                x++;\n            }\n            i=(i+1)%MAX;\n        }\n        if(queue[i]==val)\n        {\n            printf(\"\\nvalue found\");\n            x++;\n        }\n        if(x==0)\n        printf(\"\\nthe value is not found in the queue\");\n    }\n\n}\nvoid display()\n{\n    if((f==-1 && r==-1))\n    printf(\"\\nQueue is Empty\");\n    else if(f==(r+1)%MAX && queue[f]==-1)\n    printf(\"\\nQueue is Empty\");\n    else\n    {\n        printf(\"\\nQueue is:\\n\");\n        i=f;\n        while(i!=r)\n        {           \n            printf(\"\\t%d\",queue[i]);\n            i=(i+1)%MAX;\n        }\n        printf(\"\\t%d\",queue[r]);\n    }\n}\nvoid main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter value to insert:\");\n                scanf(\"%d\",&value);\n                enqueue(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nthe popped value is %d\",dequeue()); \n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\nint queue[MAX];\nint value,front=-1,rear=-1;\nvoid enqueueF(int val)\n{\n    if(front==-1 && rear==-1)\n    {\n        front=front+1;\n        rear=rear+1;\n        queue[front]=val;\n    }\n    else if(front==0)\n    {\n        printf(\"\\ncannot be inserted\");\n    }\n    else\n    {\n        front=front-1;\n        queue[front]=val;\n    }\n}\nvoid enqueueR(int val)\n{\n    if(front==-1 && rear==-1)\n    {\n        front=front+1;\n        rear=rear+1;\n        queue[rear]=val;\n    }\n    if(rear==MAX-1)\n    printf(\"queue is full\");\n    else\n    {\n        rear=rear+1;\n        queue[rear]=val;\n    }\n}\nvoid dequeueF()\n{\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"queue is empty\");\n    else\n    {\n        printf(\"The value popped is %d\",queue[front]);\n        front=front+1;\n    }\n}\nvoid dequeueR()\n{\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"queue is empty\");\n    else\n    {\n        printf(\"The value popped is %d\",queue[rear]);\n        rear=rear-1;\n    }\n}\nvoid search(int val)\n{\n    int i,c=0;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}\nvoid display()\n{\n    int i;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        printf(\"\\nqueue is :\\n\");\n        for(i=front;i<=rear;i++)\n        printf(\"\\t%d\",queue[i]);\n    }\n}\nvoid main()\n{\n    int ch;\n    printf(\"1.enqueueF\\n2.enqueueR\\n3.dequeueF\\n4.dequeueR\\n5.search\\n6.print\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueueF(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueueR(value);\n                break;\n            }\n            case 3:\n            {\n                dequeueF();\n                break;\n            }\n            case 4:\n            {\n                dequeueR();\n                break;\n            }\n            case 5:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 6:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nint STACK[100],top=-1;\nvoid push(int x)\n{\n    if(top==99)\n    printf(\"Stack isFull\");\n    else\n    {\n        top=top+1;\n        STACK[top]=x;\n    }\n}\nint pop()\n{\n    int x;\n    if(top==-1)\n    printf(\"\\nStack is Empty\");\n    else\n    {\n        x=STACK[top];\n        top=top-1;\n        return(x);\n    }\n}\nvoid main()\n{\n    int graph[10][10],n,i,j,ct,v,x,vertices[10],visited[10]={1,1,1,1,1,1,1,1,1,1};\n    printf(\"\\nEnter the number of vertices of G:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the adjacency matrix of graph\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            scanf(\"%d\",&graph[i][j]);\n        }\n\n    }\n    printf(\"\\nThe adjacency matrix of given graph:\\n\");\n    {\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                printf(\"\\t%d\",graph[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    printf(\"\\nEnter the starting vertex:\");\n    scanf(\"%d\",&v);\n    push(v);\n    ct=0;\n    \n    while(top>=0)\n    {\n        vertices[ct]=pop(); \n        visited[v]=3;\n        v=vertices[ct];\n        ct++;\n        for(i=0;i<n;i++)\n        {\n            if(graph[v][i]==1 && visited[i]==1)\n            {\n                push(i);\n                visited[i]=2;   \n            }\n        }\n    }       \n    printf(\"\\nThe graph is:\\n\");\n    for(i=0;i<ct;i++)\n    {\n        printf(\"\\t%d\",vertices[i]);\n    }\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint STACK[100],top=-1;\nvoid push(int x)\n{\n    if(top==99)\n    printf(\"Stack isFull\");\n    else\n    {\n        top=top+1;\n        STACK[top]=x;\n    }\n}\nint pop()\n{\n    int x;\n    if(top==-1)\n    printf(\"\\nStack is Empty\");\n    else\n    {\n        x=STACK[top];\n        top=top-1;\n        return(x);\n    }\n}\nstruct graph\n{\n    int val;\n    struct graph* next;\n}*G[10],*last;\nvoid create(struct graph* G[],int n)\n{\n    int i,j,m,data;\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nenter the number of vertices adjacent to vertex %d :\",i);\n        scanf(\"%d\",&m);\n        for(j=0;j<m;j++)\n        {\n            printf(\"\\nEnter the vertex to be inserted:\");\n            scanf(\"%d\",&data);\n            struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n            p->val=data;\n            p->next=NULL;\n            if(G[i]==NULL)\n                G[i]=p;\n            else\n            {\n                last=G[i];\n                while(last->next!=NULL)\n                    last=last->next;\n                last->next=p;\n            }\n        }\n    }\n}\nvoid display(struct graph* G[],int n)\n{\n    int i,j;\n    for(i=0;i<n;i++)\n    {\n        last=G[i];\n        printf(\"\\nThe vertices adjacent to %d are :\\n\",i);\n        while(last->next!=NULL)\n        {\n            printf(\"\\t%d\",last->val);\n            last=last->next;\n        }\n        printf(\"\\t%d\",last->val);\n    }\n}\nvoid main()\n{\n    int n,i,vertices[10],ct=0,v,visited[10]={1,1,1,1,1,1,1,1,1,1};\n    printf(\"\\nEnter the number of vertices of graph:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    G[i]=NULL;\n    create(G,n);\n    display(G,n);\n    printf(\"\\nEnter the starting vertex:\");\n    scanf(\"%d\",&v);\n    push(v);\n    ct=0;\n    \n    while(top>=0)\n    {\n        vertices[ct]=pop(); \n        visited[v]=3;\n        v=vertices[ct];\n        ct++;\n        last=G[v];\n        while(last!=NULL)\n        {\n            if(visited[last->val]==1)\n            {   push(last->val);\n                visited[last->val]=2;\n            }\n            last=last->next;\n        }\n    }       \n    printf(\"\\nThe graph is:\\n\");\n    for(i=0;i<ct;i++)\n    {\n        printf(\"\\t%d\",vertices[i]);\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nstruct List\n{\n    int val;\n    struct List *prev;\n    struct List *next;\n}*start=NULL,*temp=NULL,*q=NULL;\nint value,pos,i=0;\nvoid insert(int tar,int pos)\n{\n    struct List* p=(struct List*)malloc(sizeof(struct List));\n    p->val=tar;\n    p->prev=NULL;\n    p->next=NULL;\n    if(start==NULL)\n    {\n        start=p;\n    }\n    else\n    {\n        if(pos==0)\n        {\n            p->next=start;\n            start=p;\n        }\n        else\n        {\n            temp=start;\n            for(i=0;i<(pos-1);i++)\n            {\n                temp=temp->next;\n            }\n            p->next=temp->next;\n            p->prev=temp;\n            temp->next->prev=p;\n            temp->next=p;   \n        }\n    }\n}\nvoid delete(int tar)\n{\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==start->val && temp->val==tar)\n            {\n                start=start->next;\n                start->prev=NULL;\n                free(temp);\n                temp=start;\n            }\n            else if(temp->val==tar)\n            {\n                q->next=temp->next;\n                temp->next->prev=q;\n                free(temp);\n                temp=q->next;\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==tar && temp->next==NULL)\n        {\n            q->next=NULL;\n            temp->prev=NULL;\n            free(temp);\n        }\n    }\n}\nvoid search(int tar)\n{\n    int ct=0;\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==tar)\n            {\n                printf(\"\\nElement found\");\n                ct++;\n                break;\n            }\n            temp=temp->next;\n        }\n        if(temp->val==tar && temp->next==NULL)\n        {\n            printf(\"\\nElement found\");\n            ct++;\n        }\n        if(ct==0)\n        {\n            printf(\"\\nthe element is not found in the list\");\n        }\n    }\n}\nvoid display()\n{\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        while(temp->next!=NULL)\n        {\n            printf(\"\\t%d\",temp->val);\n            temp=temp->next;\n        }\n    }\n    printf(\"\\t%d\",temp->val);\n}\nvoid main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value and position to insert:\");\n                scanf(\"%d%d\",&value,&pos);\n                insert(value,pos);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                delete(value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\nvoid RestoreHeapUp(int HEAP[],int index)\n{\n    int val=HEAP[index];\n    while(index>1 && (HEAP[index\/2]<val))\n    {\n        HEAP[index]=HEAP[index\/2];\n        index=index\/2;\n    }\n    HEAP[index]=val;\n}\nvoid RestoreHeapDown(int HEAP[],int index,int n)\n{\n    int val=HEAP[index];\n    int j=index*2;\n    while(j<=n)\n    {\n        if(j<n && HEAP[j]<HEAP[j+1])\n        j++;\n        if(HEAP[j]<HEAP[j\/2])\n        break;\n        else\n        {\n            HEAP[j\/2]=HEAP[j];\n            j=j*2;\n        }\n        HEAP[j\/2]=val;\n    }\n}\nvoid main()\n{\n    int HEAP[MAX],i,j,n,temp;\n    printf(\"\\nEnter the value of n:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the values:\");\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&HEAP[i]);\n        RestoreHeapUp(HEAP,i);\n    }\n    j=n;\n    for(i=1;i<=j;i++)\n    {\n        temp=HEAP[1];\n        HEAP[1]=HEAP[n];\n        HEAP[n]=temp;\n        n=n-1;\n        RestoreHeapDown(HEAP,1,n);\n    }\n    n=j;\n    printf(\"\\nThe sorted array:\\n\");\n    for(i=1;i<=n;i++)\n    {\n        printf(\"\\t%d\",HEAP[i]);\n    }\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint HASH[10],key,val,i;\nint H(int value)\n{\n    return(value%10);\n}\nvoid insert(int key,int value)\n{\n    int index=H(key);\n    int i;\n    if(HASH[index]==-1)\n    {\n        HASH[index]=value;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==-1)\n            {\n                HASH[i]=value;\n                break;\n            }\n        }\n    }\n}\nvoid delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0,i;\n    if(HASH[index]==value)\n    {\n        HASH[index]=-1;\n        printf(\"\\nValue deleted\");\n        ct++;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==value)\n            {\n                HASH[i]=-1;\n                printf(\"\\nValue deleted\");\n                ct++;\n                break;\n            }\n        }\n    }\n    if(ct==0)\n    {\n        printf(\"\\nThe key with that value is not found\");\n    }\n}\nvoid search(int key,int value)\n{\n    int index=H(key);\n    int i;\n    int ct=0;\n    if(HASH[index]==value)\n    {\n        printf(\"\\nThe value found at index %d \",index);\n        ct++;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==value)\n            {\n                printf(\"\\nValue found at index %d \",i);\n                ct++;\n                break;\n            }\n        }\n    }\n    if(ct==0)\n    {\n        printf(\"\\nThe key with that value is not found\");\n    }   \n}\nvoid display()\n{\n    int i;\n    for(i=0;i<10;i++)\n    {\n        if(HASH[i]!=-1)\n        printf(\"\\nkey : %d\\tvalue : %d\",i,HASH[i]);\n    }\n}\nvoid main()\n{\n    int ch,i;\n    for(i=0;i<10;i++)\n    HASH[i]=-1;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nint ARR[100];\nint TEMP[100];\nvoid Merge(int ARR[],int BEG,int MID,int END)\n{\n    int k=0,I=BEG,J=MID+1,INDEX=BEG;\n    while(I<=MID && J<=END)\n    {\n        if(ARR[I]<ARR[J])\n        {\n            TEMP[INDEX]=ARR[I];\n            I=I+1;\n        }\n        else\n        {\n            TEMP[INDEX]=ARR[J];\n            J=J+1;\n        }\n        INDEX=INDEX+1;\n    }\n    if(I>MID)\n    {\n        while(J<=END)\n        {\n            TEMP[INDEX]=ARR[J];\n            J=J+1;\n            INDEX=INDEX+1;\n        }\n    }\n    else\n    {\n        while(I<=MID)\n        {\n            TEMP[INDEX]=ARR[I];\n            I=I+1;\n            INDEX=INDEX+1;\n        }\n    }\n    for(k=BEG;k<INDEX;k++)\n    {\n        ARR[k]=TEMP[k];\n    }\n}\nvoid MergeSort(int ARR[],int BEG,int END)\n{\n    int MID;\n    if(BEG<END)\n    {\n        MID=(BEG+END)\/2;\n        MergeSort(ARR,BEG,MID);\n        MergeSort(ARR,MID+1,END);\n        Merge(ARR,BEG,MID,END);\n    }\n}\nvoid main()\n{\n    int n,i;\n    printf(\"\\nEnter the number of elements in the array:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the elements of the array:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&ARR[i]);\n    }\n    MergeSort(ARR,0,n-1);\n    printf(\"\\nThe sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\t%d\",ARR[i]);\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nstruct hash\n{\n    int val;\n    struct hash* next;\n}*temp,*q;\nstruct hash* HASH[5];\nint val,key;\nint H(int key)\n{\n    return(key%10);\n}\nvoid insert(int key,int value)\n{\n    int index=H(key);\n    struct hash* p=(struct hash*)malloc(sizeof(struct hash));\n    p->val=value;\n    p->next=NULL;\n    if(HASH[index]==NULL)\n    {\n        HASH[index]=p;\n    }\n    else\n    {\n        temp=HASH[index];\n        while(temp->next!=NULL)\n            temp=temp->next;\n        temp->next=p;\n    }\n}\nvoid delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                if(temp==HASH[index])\n                {\n                    HASH[index]=temp->next;\n                    free(temp);\n                    temp=HASH[index];\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            q->next=NULL;\n            free(temp);\n            printf(\"\\nValue deleted\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue is not found\");\n    }\n}\nvoid search(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                printf(\"\\nValue found\");\n                ct++;\n            }\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            printf(\"\\nValue found\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue not found\");\n    }\n}\nvoid display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        if(HASH[i]!=NULL)\n        {\n            printf(\"\\nvalues with index %d \\n\",i);\n            temp=HASH[i];\n            while(temp->next!=NULL)\n            {\n                printf(\"\\t%d\",temp->val);\n                temp=temp->next;\n            }\n            printf(\"\\t%d\",temp->val);\n        }\n    }\n}\nvoid main()\n{\n    int ch,i;\n    for(i=0;i<5;i++)\n    HASH[i]=NULL;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\nint queue[MAX];\nint value,front=-1,rear=-1;\nvoid enqueue(int queue[],int val)\n{\n    if(rear==MAX-1)\n    printf(\"\\nqueue is full\");\n    if(front==-1 && rear==-1)\n    {\n        front=0;\n        rear=rear+1;\n        queue[rear]=val;\n    }\n    else\n    {\n        rear=rear+1;\n        queue[rear]=val;\n    }\n}\nvoid dequeue(int queue[])\n{\n    if(front==-1 || front>rear)\n    {\n        printf(\"\\nqueue is empty\");\n    }\n    else\n    {\n        printf(\"\\nThe value popped is : %d\",queue[front]);\n        front=front+1;\n    }\n}\nvoid search(int queue[],int val)\n{\n    int i,c=0;\n    if(front==-1 || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}\nvoid display(int stack[])\n{\n    int i;\n    if(front==-1 || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        printf(\"\\nqueue is :\\n\");\n        for(i=front;i<=rear;i++)\n        printf(\"\\t%d\",queue[i]);\n    }\n}\nvoid main()\n{\n    int ch;\n    printf(\"1.ENQUEUE\\n2.DEQUEUE\\n3.SEARCH\\n4.PRINT\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueue(queue,value);\n                break;\n            }\n            case 2:\n            {\n                dequeue(queue);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(queue,value);\n                break;\n            }\n            case 4:\n            {\n                display(queue);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\nint ARR[100];\nint Partition(int ARR[],int BEG,int END)\n{\n    int Left=BEG,Right=END,LOC=BEG,FLAG=0,temp;\n    while(FLAG!=1)\n    {\n        while(ARR[LOC]<=ARR[Right] && LOC!=Right)\n        {\n            Right=Right-1;\n        }\n        if(LOC==Right)\n        {\n            FLAG=1;\n        }\n        else if(ARR[LOC]>ARR[Right])\n        {\n            temp=ARR[LOC];\n            ARR[LOC]=ARR[Right];\n            ARR[Right]=temp;\n            LOC=Right;\n        }\n        if(FLAG!=1)\n        {\n            while(ARR[LOC]>=ARR[Left] && LOC!=Left)\n            {\n                Left=Left+1;\n            }\n            if(LOC==Left)\n            {\n                FLAG=1;\n            }\n            else if(ARR[LOC]<ARR[Left])\n            {\n                temp=ARR[LOC];\n                ARR[LOC]=ARR[Left];\n                ARR[Left]=temp;\n                LOC=Left;\n            }\n        }\n    }\n    return(LOC);\n}   \nvoid QuickSort(int ARR[],int BEG,int END)\n{\n    int LOC;\n    if(BEG<END)\n    {\n        LOC=Partition(ARR,BEG,END);\n        QuickSort(ARR,BEG,LOC-1);\n        QuickSort(ARR,LOC+1,END);\n    }\n}\nvoid main()\n{\n    int n,i;\n    printf(\"\\nEnter the number of elements in the array:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the elements of the array:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&ARR[i]);\n    }\n    QuickSort(ARR,0,n-1);\n    printf(\"\\nThe sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\t%d\",ARR[i]);\n    }\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX 100\nint stack[MAX];\nint value,top=-1,key;\nvoid push(int stack[],int val)\n{\n    if(top==MAX-1)\n    printf(\"\\nstack is full\");\n    else\n    {\n        top=top+1;\n        stack[top]=val;\n    }\n}\nvoid pop(int stack[])\n{\n    if(top==-1)\n    {\n        printf(\"\\nstack is empty\");\n    }\n    else\n    {\n        printf(\"\\nThe value popped is : %d\",stack[top]);\n        top=top-1;\n    }\n}\nvoid search(int stack[],int val)\n{\n    int i,c=0;\n    if(top==-1)\n    printf(\"\\nstack is empty\");\n    else\n    {\n        for(i=0;i<=top;i++)\n        {\n            if(stack[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}\nvoid display(int stack[])\n{\n    int i;\n    if(top==-1)\n    printf(\"\\nstack is empty\");\n    else\n    {\n        printf(\"\\nstack is :\\n\");\n        for(i=0;i<=top;i++)\n        printf(\"\\t%d\",stack[i]);\n    }\n}\nvoid main()\n{\n    int ch;\n    printf(\"1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.PRINT\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                push(stack,value);\n                break;\n            }\n            case 2:\n            {\n                pop(stack);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(stack,value);\n                break;\n            }\n            case 4:\n            {\n                display(stack);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define m 3\n#define n 5\nint available[m],max[n][m],allocation[n][m],need[n][m],request[n][m];\nint safety_module()\n{\n    int work[m],finish[n],i,j,flag=0;\n    for(i=0;i<m;i++)\n        work[i]=available[i];\n    for(i=0;i<n;i++)\n        finish[i]=0;\n    while(1)\n    {\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            for(j=0;j<m;j++)\n            {\n                if(need[i][j]<=work[j])\n                    continue;\n                else\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0 && finish[i]==0)\n            {\n                finish[i]=1;\n                for(j=0;j<m;j++)\n                    work[j]=work[j]+allocation[i][j];\n                break;\n            }\n        }\n        if(i==5)\n            break;\n        else\n            continue;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(finish[i]!=1)\n            break;\n    }\n    if(i==5)\n        return(1);\n    else\n        return(0);\n}\nvoid resource_request(int pr)\n{\n    int i,s,flag=-1;\n    for(i=0;i<m;i++)\n    {\n        if(request[pr][i]<=need[pr][i])\n            continue;\n        else\n        {\n            flag=1;\n            break;\n        }\n    }\n    if(flag==1)\n        printf(\"Terminate!\");\n    else\n    {\n        for(i=0;i<m;i++)\n        {\n            if(request[pr][i]<=available[i])\n                continue;\n            else\n            {\n                flag=1;\n                break;\n            }\n        }   \n        if(flag==1)\n            printf(\"Process has to wait\");\n        else\n        {\n            for(i=0;i<m;i++)\n            {\n                available[i]=available[i]-request[pr][i];\n                allocation[pr][i]=allocation[pr][i]+request[pr][i];\n                need[pr][i]=need[pr][i]-request[pr][i];\n            }\n            s=safety_module();\n            if(s==1)\n                printf(\"\\nRequest Granted\");\n            else\n            {\n                printf(\"\\nRestore\");\n                for(i=0;i<m;i++)\n                {\n                    available[i]=available[i]+request[pr][i];\n                    allocation[pr][i]=allocation[pr][i]-request[pr][i];\n                    need[pr][i]=need[pr][i]+request[pr][i];\n                }\n            }\n        }\n    }\n}\nvoid main()\n{\n    int i,j,pr;\n    printf(\"\\nEnter the available resources  : \");\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&available[i]);\n    printf(\"\\nEnter maximum : \");   \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"\\nEnter allocation : \");    \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&allocation[i][j]);\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<m;j++)\n        {\n            need[i][j]=max[i][j]-allocation[i][j];\n        }\n    }\n    printf(\"\\nenter the process to take request : \");\n    scanf(\"%d\",&pr);\n    printf(\"\\nEnter request : \");\n    for(j=0;j<m;j++)\n    {\n        scanf(\"%d\",&request[pr][j]);\n    }\n    resource_request(pr);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint pos;\nstruct graph\n{\n    char name;\n    int id;\n    char parent;\n    struct graph* next;\n}*G[10],*temp,*q;\nvoid add_dir(char dir)\n{\n    int i,flag=-1;\n    char root[10];\n    struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n    p->name=dir;\n    p->id=1;\n    printf(\"\\nEnter root directory : \");\n    scanf(\"%s\",root);\n    p->parent=root[0];\n    p->next=NULL;\n    if(root[0]=='!')\n    {\n        G[pos]=p;\n        pos=pos+1;\n    }\n    else\n    {\n        for(i=0;i<pos;i++)\n        {\n            temp=G[i];\n            q=temp->next;\n            while(temp!=NULL)\n            {\n                if(temp->name==root[0])\n                {\n                    p->next=temp->next;\n                    temp->next=p;\n                    flag=1;\n                    break;\n                }\n                else\n                {\n                    temp=temp->next;\n                    q=temp->next;\n                }\n            }\n            if(flag==1)\n                break;\n        }\n    }\n}\nvoid add_file(char dir,char file)\n{\n    int i,flag=-1;\n    struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n    p->name=file;\n    p->id=2;\n    p->parent=dir;\n    p->next=NULL;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        q=temp->next;\n        while(temp!=NULL)\n        {\n            if(temp->name==dir && temp->id==1)\n            {\n                p->next=temp->next;\n                temp->next=p;\n                flag=1;\n                break;\n            }\n            else\n            {\n                q=temp;\n                temp=temp->next;\n            }\n        }\n        if(flag==1)\n            break;\n    }\n}\nvoid del_dir(char dir)\n{\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        if(temp->name==dir)\n        {\n            temp->next=NULL;\n            free(temp);\n            break;\n        }\n        else\n        {\n            q=temp;\n            while(temp!=NULL)\n            {\n                if(temp->name==dir && temp->id==1)\n                {\n                    q->next=temp->next;\n                    \n                    temp=q->next;\n                    continue;\n                }\n                else if(temp->parent==dir && temp->id==2)\n                {\n                    q->next=temp->next;\n                    \n                    temp=q->next;\n                    continue;   \n                }\n                q=temp;\n                temp=temp->next;\n            }\n            \n        }\n    }\n}\nvoid del_file(char dir,char file)\n{\n    int i,flag=-1;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        q=temp;\n        while(temp!=NULL)\n        {\n            if(temp->name==file && temp->id==2 && temp->parent==dir)\n            {\n                q->next=temp->next;\n                temp=q->next;\n                flag=1;\n                break;\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(flag==1)\n            break;\n    }\n}\nvoid display()\n{\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        printf(\"\\nDirectory (%c) : \",temp->name);\n        while(temp!=NULL)\n        {\n            printf(\"(%c,%d,%c)\",temp->name,temp->id,temp->parent);\n            temp=temp->next;\n        }\n    }\n}\nint check(char dir)\n{\n    int flag=-1;\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        while(temp!=NULL)\n        {\n            if(temp->name==dir && temp->id==1)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                temp=temp->next;\n            }\n        }\n        if(flag==1)\n            break;\n    }\n    return(flag);\n}\nvoid main()\n{\n    int status=-1,ch;\n    char dir[10],file[10];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the name of directory : \");\n                scanf(\"%s\",dir);\n                add_dir(dir[0]);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the name of file to add : \");\n                scanf(\"%s\",file);\n                printf(\"\\nEnter the directory : \");\n                scanf(\"%s\",dir);\n                status=check(dir[0]);\n                if(status==1)\n                    add_file(dir[0],file[0]);\n                else\n                {\n                    add_dir(dir[0]);\n                    add_file(dir[0],file[0]);\n                }\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the directory to delete : \");\n                scanf(\"%s\",dir);\n                del_dir(dir[0]);\n                break;\n            }\n            case 4:\n            {\n                printf(\"\\nEnter the file to delete : \");\n                scanf(\"%s\",file);\n                printf(\"\\nEnter the directory to which it belongs : \");\n                scanf(\"%s\",dir);\n                del_file(dir[0],file[0]);\n                break;\n            }\n            case 5:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define m 3\n#define n 4\nint available[m],allocation[n][m],request[n][m];\nint safety_module()\n{\n    int work[m],finish[n],i,j,flag=0,set;\n    for(i=0;i<m;i++)\n        work[i]=available[i];\n    for(i=0;i<n;i++)\n    {\n        flag=0;\n        for(j=0;j<m;j++)\n        {\n            if(allocation[i][j]!=0)\n            {\n                flag=1;\n                break;\n            }\n            else\n                continue;\n        }\n        if(flag==1)\n            finish[i]=0;\n        else\n            finish[i]=1;\n    }\n    while(1)\n    {\n        set=-1;\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            for(j=0;j<m;j++)\n            {\n                if(request[i][j]<=work[j])\n                    continue;\n                else\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0 && finish[i]==0)\n            {\n                set=i;\n                finish[i]=1;\n                for(j=0;j<m;j++)\n                    work[j]=work[j]+allocation[i][j];\n                break;\n            }\n        }\n        if(set==-1)\n            break;\n        else\n            continue;\n    }\n    flag=0;\n    printf(\"\\nProcessess in deadlock are : \\n\");\n    for(i=0;i<n;i++)\n    {\n        if(finish[i]!=1)\n        {\n            printf(\"%d\\t\",i);\n            flag=-1;\n        }\n    }\n    if(flag==0)\n        return(1);\n    else\n        return(0);\n}\nvoid main()\n{\n    int i,j,s;\n    printf(\"\\nEnter the available resources  : \");\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&available[i]);\n    printf(\"\\nEnter allocation : \");    \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&allocation[i][j]);\n        }\n    }\n    printf(\"\\nEnter request : \\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&request[i][j]);\n        }\n    }\n    s=safety_module();\n    if(s==1)\n        printf(\"No Deadlock\");\n    else\n        printf(\"\\nDeadlock\");\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct process\n{\n    char name[10];\n    int AT,BT,CT,TAT,WT;\n};\nvoid main()\n{\n    int n,i,j,temp,sum=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter process : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");    \n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    p[0].CT=p[0].AT;\n    for(i=0;i<n;i++)\n    {\n        if(i!=0)\n            p[i].CT=p[i-1].CT;\n        p[i].CT=p[i].CT+p[i].BT;\n        p[i].TAT=p[i].CT-p[i].AT;\n        p[i].WT=p[i].TAT-p[i].BT;\n        sum=sum+p[i].WT;\n    }\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    for(i=0;i<n;i++)\n        printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n    Waiting_time=(sum*1.0)\/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdio.h>\n#define F 3\nint n,i,j,page,Queue[F],f=-1,r=-1,PFR;\nvoid enqueue(int page)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        r=(r+1)%3;\n        Queue[r]=page;\n    }\n}\nint isthere(int page)\n{\n    int flag=-1;\n    for(j=0;j<3;j++)\n    {\n        if(Queue[j]==page)\n        {\n            flag=1;\n            break;\n        }\n    }\n    return(flag);\n}\nvoid main()\n{\n    for(i=0;i<3;i++)\n        Queue[i]=-1;    \n    printf(\"\\nEnter the number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter the page : \");\n        scanf(\"%d\",&page);\n        if(isthere(page)==-1)\n        {\n            enqueue(page);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint disk[16],d_array[16][16],pos=0;\nint ispossible()\n{\n    int i,ct=0;\n    for(i=1;i<16;i++)\n    {\n        if(disk[i]==0)\n            ct++;\n    }\n    return(ct);\n}\nvoid add_file(int id,int size)\n{\n    int ct=ispossible(),i,j;\n    if(ct>=size)\n    {\n        d_array[pos][0]=id;\n        j=1;\n        for(i=1;i<16 && size>0;i++)\n        {\n            if(disk[i]==0)\n            {\n                disk[i]=id;\n                size--;\n                d_array[pos][j]=i;\n                j++;\n            }\n        }\n        pos++;\n    }\n    else\n    {\n        printf(\"\\nNot possible\");\n    }\n}\nvoid rem_file(int id)\n{\n    int i,j;\n    for(i=1;i<16;i++)\n    {\n        if(disk[i]==id)\n        {\n            disk[i]=0;\n        }\n    }\n    for(i=0;i<16;i++)\n    {\n        if(d_array[i][0]==id)\n        {\n            d_array[i][0]=0;\n            for(j=1;j<16;j++)\n            {\n                if(d_array[i][j]!=0)\n                    d_array[i][j]=0;\n                else\n                    break;\n            }\n        }\n    }\n}\nvoid display()\n{\n    int i,j;\n    printf(\"\\nDisk is : \"); \n    for(i=1;i<16;i++)\n    {\n        printf(\"\\t%d\",disk[i]);\n    }\n    printf(\"\\nd_array is : \");\n    for(i=0;i<pos;i++)\n    {\n        if(d_array[i][0]!=0)\n        {\n            printf(\"\\n%d\",d_array[i][0]);\n            for(j=1;j<16;j++)   \n            {\n                if(d_array[i][j]!=0)\n                    printf(\"\\t%d\",d_array[i][j]);\n                else\n                    break;\n            }\n        }\n    }\n}\nvoid main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n    {\n        disk[i]=0;\n    }\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter size : \");\n                scanf(\"%d\",&size);\n                add_file(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                rem_file(id);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nstruct Disk\n{\n    int id,next_index;\n}disk[16];\nint ispossible()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(disk[i].id==0)\n            ct++;\n    }\n    return(ct);\n}\nvoid add_file(int id,int size)\n{\n    int ct=ispossible(),i,j;\n    if(ct>=size)\n    {\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(disk[i].id==0)\n            {\n                disk[i].id=id;\n                size--;\n                for(j=i+1;j<16;j++)\n                {\n                    if(disk[j].id==0 && size>0)\n                    {\n                        disk[i].next_index=j;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        printf(\"\\nNot possible\");\n    }\n}\nvoid rem_file(int id)\n{\n    int i;\n    for(i=0;i<16;i++)\n    {\n        if(disk[i].id==id)\n        {\n            disk[i].id=0;\n            disk[i].next_index=-1;\n        }\n    }\n}\nvoid display()\n{\n    int i;\n    printf(\"\\nDisk is : \"); \n    for(i=0;i<16;i++)\n    {\n        printf(\"\\n%d\\t%d\",disk[i].id,disk[i].next_index);\n    }\n}\nvoid main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n    {\n        disk[i].id=0;\n        disk[i].next_index=-1;\n    }\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter size : \");\n                scanf(\"%d\",&size);\n                add_file(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                rem_file(id);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define F 3\nint n,page[100];\nint Queue[F],r=-1,f=-1;\nint find_pos(int pg,int pos)\n{\n    int i,set=0;\n    for(i=pos;i>=0;i--)\n    {\n        if(page[i]==pg)\n        {\n            set=i;\n            break;\n        }\n    }\n    return(set);\n}\nvoid enqueue(int page,int pos)\n{\n    int i,new,set=0,min;\n    if(r==-1 && f==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else if(r<2)\n    {\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        min=1000;\n        for(i=0;i<3;i++)\n        {\n            new=find_pos(Queue[i],pos-1);\n            if(new<min)\n            {\n                min=new;\n                set=i;\n            }\n        }\n        Queue[set]=page;\n    }   \n}\nint isthere(int page)\n{\n    int i,flag=-1;\n    for(i=0;i<3;i++)\n    {\n        if(Queue[i]==page)\n        {\n            flag=1;\n            break;\n        }\n    }   \n    return(flag);\n}\nvoid main()\n{\n    int i,j,PFR=0;\n    for(i=0;i<3;i++)\n        Queue[i]=-1;\n    printf(\"\\nEnter the number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter the page : \");\n        scanf(\"%d\",&page[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        if(isthere(page[i])==-1)\n        {\n            enqueue(page[i],i);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint Mem,block;\nstruct program\n{\n    char name[10];\n    int If,size,status;\n};\nvoid main()\n{\n    int n,i,size,IF=0,EF=0;\n    printf(\"\\nEnter the size of memory : \");\n    scanf(\"%d\",&Mem);\n    printf(\"\\nEnter size of each block : \");\n    scanf(\"%d\",&block);\n    printf(\"\\nEnter the number of programs : \");\n    scanf(\"%d\",&n);\n    struct program p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter size : \");\n        scanf(\"%d\",&p[i].size);\n        p[i].If=0;\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(p[i].size<=block)\n        {\n            p[i].status=1;\n            p[i].If=block-p[i].size;\n            IF=IF+p[i].If;\n        }\n        else\n        {\n            EF=EF+block;\n        }\n    }\n    printf(\"\\nprogram\\tsize\\tIF\\n\");\n    for(i=0;i<n;i++)\n        printf(\"%s\\t%d\\t%d\\n\",p[i].name,p[i].size,p[i].If);\n    printf(\"\\nTotal Internal Fragmentation is : %d\",IF);\n    printf(\"\\nTotal External Fragmentation is : %d\",EF);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint Mem;\nstruct program\n{\n    char name[10];\n    int size,status;\n};\nvoid main()\n{\n    int n,i,rem,EF=0;\n    printf(\"\\Enter the size of memory : \");\n    scanf(\"%d\",&Mem);\n    printf(\"\\nEnter the number of programs : \");\n    scanf(\"%d\",&n);\n    struct program p[n];\n    rem=Mem;\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter size : \");\n        scanf(\"%d\",&p[i].size);\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(p[i].size<=rem)\n        {\n            p[i].status=1;\n            rem=rem-p[i].size;\n        }\n    }\n    EF=rem;\n    printf(\"\\nprogram\\tsize\\tstatus\\n\");\n    for(i=0;i<n;i++)\n        printf(\"%s\\t%d\\t%d\\n\",p[i].name,p[i].size,p[i].status);\n    printf(\"\\nTotal External Fragmentation is : %d\",EF);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#define F 3\nint Queue[F],r=-1,f=-1;\nint n,page[100];\nint find_pos(int pg,int x)\n{\n    int i,set=0;\n    for(i=x;i<n;i++)\n    {\n        if(page[i]==pg)\n        {\n            set=i;\n            break;\n        }\n    }\n    return(set);\n}\nvoid enqueue(int page,int pos)\n{\n    int i,new,max=0,set=0;\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else if(r<2)\n    {\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        max=0;\n        for(i=0;i<3;i++)\n        {\n            new=find_pos(Queue[i],pos+1);\n            if(new>max)\n            {\n                max=new;\n                set=i;\n            }\n            else if(new==0)\n            {\n                set=i;\n                break;\n            }\n        }\n        Queue[set]=page;\n    }\n}\nint isthere(int page)\n{\n    int i,flag=-1;\n    for(i=0;i<3;i++)\n    {\n        if(Queue[i]==page)\n        {\n            flag=1;\n            break;\n        }\n    }\n    return(flag);\n}\nvoid main()\n{\n    int PFR=0,j,i;\n    for(i=0;i<3;i++)\n        Queue[i]=-1;\n    printf(\"\\nEnter the  number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter page : \");\n        scanf(\"%d\",&page[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        if(isthere(page[i])==-1)\n        {\n            enqueue(page[i],i);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint Mem[16],index1;\nstruct table\n{\n    int id,size,indices[16];\n}t[16];\nint get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}\nvoid rem_program(int id1)\n{\n    int i,k;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==id1)\n        {\n            Mem[i]=0;\n        }\n    }\n    for(i=0;i<index1;i++)\n    {\n        if(t[i].id==id1)\n            break;\n    }\n    t[i].id=-1;\n    t[i].size=-1;\n    for(k=0;k<16;k++)\n    {\n        if(t[i].indices[k]!=-1)\n            t[i].indices[k]=-1;\n        else\n            break;\n    }\n}\nvoid add_program(int id,int size)\n{\n    int ct=get_count();\n    int temp=size;\n    int i,k,ch=1,id1;\n    if(ct>=size)\n    {\n        k=0;\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(Mem[i]==0)\n            {\n                Mem[i]=id;\n                size=size-1;\n                t[index1].indices[k]=i;\n                k++;\n            }\n        }\n        t[index1].id=id;\n        t[index1].size=temp;\n        t[index1].indices[k]=-1;\n        index1=index1+1;\n    }\n    else\n    {\n        while(ch==1)\n        {\n            printf(\"\\nIs there any possiblity of removing a program : \");\n            scanf(\"%d\",&ch);\n            if(ch==1)\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id1);\n                rem_program(id1);\n            }\n            else\n            {\n                break;\n            }\n        }\n        ct=get_count();\n        if(ct>=size)\n        {\n            k=0;\n            for(i=0;i<16 && size>0;i++)\n            {\n                if(Mem[i]==0)\n                {\n                    Mem[i]=id;\n                    size=size-1;\n                    t[index1].indices[k]=i;\n                    k++;\n                }\n            }\n            t[index1].id=id;\n            t[index1].size=temp;\n            t[index1].indices[k]=-1;\n            index1=index1+1;\n        }\n        else\n            printf(\"\\nNot possible\");\n    }\n}\nvoid display_table()\n{\n    int i,j;\n    printf(\"\\nProgram_id\\tsize\\tpages\\n\");\n    for(i=0;i<index1;i++)\n    {\n        printf(\"\\n%d\\t%d\\t\",t[i].id,t[i].size);\n        for(j=0;j<16;j++)\n        {\n            if(t[i].indices[j]!=-1)\n            {\n                printf(\"%d \",t[i].indices[j]);\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n}\nvoid display_Mem()\n{\n    int i;\n    printf(\"\\nMemory is : \");\n    for(i=0;i<16;i++)\n        printf(\"%d\\t\",Mem[i]);\n}\nvoid main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n        Mem[i]=0;\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter the size in terms of pages : \");\n                scanf(\"%d\",&size);\n                add_program(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                rem_program(id);\n                break;\n            }\n            case 3:\n            {\n                display_table();\n                break;\n            }\n            case 4:\n            {   \n                display_Mem();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}\n"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nvoid Brute_Force(char S[],char P[],int n,int m)\n{\n    int i=0,j=0;\n    int flag=-1;\n    while(i<n && j<m)\n    {\n        if(P[j]==S[i])\n        {\n            i=i+1;\n            j=j+1;\n        }\n        else\n        {\n            i=i+1;\n            j=0;\n        }\n    if(j==m)\n    {\n        flag=1;\n        printf(\"\\npattern found at %d\",(i-j+1));\n        j=0;\n    }\n}\n    if(flag==-1)\n    {\n        printf(\"pattern not found\");\n    }\n}\nvoid main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    gets(S);\n    printf(\"\\nEnter Pattern:\");\n    gets(P);\n    n=strlen(S);\n    m=strlen(P);\n    Brute_Force(S,P,n,m);\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct process\n{\n    char name[10];\n    int AT,BT,CT,TAT,WT,Pr,status;\n};\nvoid main()\n{\n    int n,i,j,sum=0,temp,init_temp,k=0,k1;\n    char s[10];\n    float Waiting_time;\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        printf(\"\\nEnter priority : \");\n        scanf(\"%d\",&p[i].Pr);\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].Pr>p[j].Pr)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].Pr;\n                p[i].Pr=p[j].Pr;\n                p[j].Pr=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    temp=0;\n    while(k<n)\n    {\n        init_temp;\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp && p[i].status==0)\n            {\n                p[i].CT=p[i].BT+temp;\n                temp=temp+p[i].BT;\n                k++;\n                p[i].status=k;\n                break;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)\/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nchar Queue[100];\nint r=-1,f=-1;\nstruct process\n{\n    char name[10];  \n    int AT,BT,CT,TAT,WT,BT1,status;\n};\nvoid enqueue(char c)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=c;\n    }\n    else\n    {\n        r=r+1;\n        Queue[r]=c;\n    }\n}\nchar dequeue()\n{\n    char c;\n    if(r!=-1 && f!=-1)\n    {\n        c=Queue[f];\n        f=f+1;\n        return(c);\n    }\n}\nint isempty()\n{\n    if(r==-1)\n        return(1);\n    else\n        return(0);\n}\nvoid main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0,T,flag=0,set=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter time slice : \");\n    scanf(\"%d\",&T);\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(isempty())\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp)\n            {\n                enqueue(p[i].name[0]);\n                break;\n            }\n        }\n        if(isempty())\n            temp++;\n    }\n    while(k<n)\n    {\n        s[0]=dequeue();\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            if(p[i].name[0]==s[0] && p[i].BT1!=0)\n            {\n                printf(\"%c\\t\",s[0]);\n                flag=1;\n                set=i;\n                if(p[i].BT1>T)\n                {\n                    p[i].BT1=p[i].BT1-T;\n                    temp=temp+T;\n                    p[i].CT=temp;\n                }\n                else\n                {\n                    temp=temp+p[i].BT1;\n                    p[i].CT=temp;\n                    p[i].BT1=0;\n                }\n            }\n            if(flag==1)\n            {\n                for(j=0;j<n;j++)\n                {\n                    if(p[j].name[0]!=s[0] && p[j].AT<=temp && p[j].BT1!=0)\n                        enqueue(p[j].name[0]);\n                }\n                if(p[set].BT1!=0)\n                    enqueue(p[set].name[0]);\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k++;\n                p[i].status=k;\n            }\n        }   \n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)\/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nint Mem[16];\nint get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}\nvoid rem_program(int id)\n{\n    int i,j,k;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==id)\n            break;\n    }\n    for(k=15;k>=0;k--)\n    {\n        if(Mem[k]==id)\n            break;\n    }\n    j=k-i+1;\n    k=k+1;\n    while(k<16)\n    {\n        Mem[i]=Mem[k];\n        i++;\n        k++;\n    }\n    k=15;\n    while(j!=0)\n    {\n        Mem[k]=0;\n        k--;\n        j--;\n    }\n}\nvoid add_program(int id,int size)\n{\n    int ct=get_count(),i,ch=1,id1;\n    if(ct>=size)\n    {\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(Mem[i]==0)\n            {\n                Mem[i]=id;\n                size--;\n            }\n        }\n    }\n    else\n    {\n        while(ch==1)\n        {\n            printf(\"\\nIs there any possibility of removing a program : \");\n            scanf(\"%d\",&ch);\n            if(ch==1)\n            {\n                printf(\"\\nEnter id : \");\n                scanf(\"%d\",&id1);\n                rem_program(id1);\n            }\n            else\n            {\n                break;\n            }\n        }\n        ct=get_count();\n        if(ct>=size)\n        {\n            for(i=0;i<16 && size>0;i++)\n            {\n                if(Mem[i]==0)\n                {\n                    Mem[i]=id;\n                    size--;\n                }\n            }\n        }\n        else\n        {\n            printf(\"\\nNot possible\");\n        }\n    }\n}\nvoid display_Mem()\n{\n    int i;\n    printf(\"\\nMemory is : \");\n    for(i=0;i<16;i++)\n        printf(\"%d\\t\",Mem[i]);\n}\nvoid main()\n{\n    int ch,id,size,temp;\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter program size in terms of no of segments : \");\n                scanf(\"%d\",&size);\n                add_program(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                rem_program(id);\n                break;\n            }\n            case 3:\n            {\n                display_Mem();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nstruct dir\n{\n    char file;\n    struct dir* next;\n}*start,*temp,*q;\nint isthere(char name)\n{\n    int flag=-1;\n    temp=start;\n    while(temp!=NULL)\n    {\n        if(temp->file==name)\n        {\n            flag=1;\n            break;\n        }\n        temp=temp->next;\n    }\n    return(flag);\n}\nvoid add_file(char name)\n{\n    struct dir* p=(struct dir*)malloc(sizeof(struct dir));\n    p->file=name;\n    p->next=NULL;\n    if(isthere(name)==-1)\n    {\n        if(start==NULL)\n            start=p;\n        else\n        {\n            temp=start;\n            while(temp->next!=NULL)\n                temp=temp->next;\n            temp->next=p;\n        }\n    }\n    else\n        printf(\"\\nFile already exists\");\n}\nvoid rem_file(char name)\n{\n    if(isthere(name)==-1)\n        printf(\"\\nFile does not exist\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==start)\n                {\n                    start=start->next;\n                    free(temp);\n                    temp=start;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}\nvoid display()\n{\n    temp=start;\n    printf(\"\\nFiles are : \");\n    while(temp!=NULL)\n    {\n        printf(\"%c\\t\",temp->file);\n        temp=temp->next;\n    }\n}\nvoid main()\n{\n    int ch;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nvoid main()\n{\n    char c[100];\n    int length,i,n,j,temp;\n    printf(\"Enter the string:\");\n    gets(c);\n    length=strlen(c);\n    printf(\"\\nEnter the number of shifts:\");\n    scanf(\"%d\",&n);\n    while(n!=0)\n    {\n        i=length-1;\n        j=i;\n        temp=c[i];\n        while(j>=0)\n        {\n            i--;\n             c[j]=c[i];\n             j--;\n\n        }\n        c[0]=temp;\n        n--;\n    }\n    printf(\"\\nAfter shifting:\");\n    puts(c);\n}\n\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct process\n{\n    char name[10];  \n    int AT,BT,CT,TAT,WT,BT1,status;\n};\nvoid main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(k<n)\n    {\n        init_temp=temp;\n        min=1000;\n        printf(\"\\nq\");\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nw\");\n            if(p[i].BT1<min && p[i].BT1!=0 && p[i].AT<=temp)\n            {\n                min=p[i].BT1;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\ne\");\n            if(p[i].AT<=temp && p[i].status==0 && p[i].BT1<=min)\n            {\n                p[i].BT1--;\n                temp++;\n                p[i].CT=temp;\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nr\");\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k=k+1;\n                p[i].status=k;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)\/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>  \nstruct process\n{\n    char name[10];\n    int AT,BT,CT,TAT,WT,Pr,status,BT1;\n};\nvoid main()\n{\n    int n,i,j,sum=0,temp,init_temp,k=0,k1,min;\n    char s[10];\n    float Waiting_time;\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        printf(\"\\nEnter priority : \");\n        scanf(\"%d\",&p[i].Pr);\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n        p[i].CT=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].Pr>p[j].Pr)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                temp=p[i].Pr;\n                p[i].Pr=p[j].Pr;\n                p[j].Pr=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    k=0;\n    temp=0;\n    while(k<n)\n    {\n        init_temp=temp;\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp && p[i].status==0)\n            {\n                p[i].BT1--;\n                temp++;\n                p[i].CT=temp;\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nr\");\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k=k+1;\n                p[i].status=k;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)\/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"target":"Sowmyamithra","func":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nvoid main()\n{\n    char a[100];\n    char b[100];\n    int i;\n    int s;\n    int ct=0;\n    printf(\"enter string-1:\");\n    gets(a);\n    printf(\"\\nenter string-2\");\n    gets(b);\n    s=(strlen(a)>strlen(b))?(strlen(a)):(strlen(b));\n    for(i=0;i<s;i++)\n    {\n        if(a[i]==b[i])\n        {\n            ct++;\n        }\n        else\n        {\n            ct=-1;\n            break;\n        }\n    }\n    if(ct==-1)\n    printf(\"\\nstrings are not equal\");\n    else\n    printf(\"\\nstrings are same\");\n}\n"}
{"target":"Sowmyamithra","func":"\n#include<stdio.h>\n#include<stdlib.h>\nstruct Dir\n{\n    char file;\n    struct Dir* next;\n}*dir[5],*temp,*q;\nint isthere(int d,char name)\n{\n    int flag=-1;\n    temp=dir[d];\n    while(temp!=NULL)\n    {\n        if(temp->file==name)\n        {\n            flag=1;\n            break;\n        }\n        temp=temp->next;\n    }\n    return(flag);\n}\nvoid add_file(int d,char name)\n{\n    struct Dir* p=(struct Dir*)malloc(sizeof(struct Dir));\n    p->file=name;\n    p->next=NULL;\n    if(isthere(d,name)==-1)\n    {\n        if(dir[d]==NULL)\n            dir[d]=p;\n        else\n        {\n            temp=dir[d];\n            while(temp->next!=NULL)\n                temp=temp->next;\n            temp->next=p;\n        }\n    }   \n    else\n        printf(\"file already exists in that directory\");\n}\nvoid rem_file(int d,char name)\n{\n    if(isthere(d,name)==-1)\n        printf(\"file doesnot exist in the directory\");\n    else\n    {\n        temp=dir[d];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==dir[d])\n                {\n                    dir[d]=dir[d]->next;\n                    free(temp);\n                    temp=dir[d];\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}\nvoid display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        temp=dir[i];\n        printf(\"\\nDirectory %d - \",i);\n        while(temp!=NULL)\n        {\n            printf(\"%c\\t\",temp->file);\n            temp=temp->next;\n        }\n    }\n}\nvoid main()\n{\n    int ch,dir;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(dir,name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(dir,name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n#include \"queue.h\"\n\n#define SIZE 10\n\nint queue[SIZE], front = -1, rear = -1;\n\nvoid enqueue(void);\nvoid dequeue(void);\nvoid display(void);\n\n\nint main()\n{\n    int choice;\n\n    while(1){\n        printf(\"Enter the choice\\n1. Insertion\\n2. Deletion\\n3. Display\\n4. Exit\\n\");\n        scanf(\"%d\",&choice);\n\n        switch (choice){\n            case 1:\n                enqueue();\n                break;\n            case 2:\n                dequeue();\n                break;\n            case 3:\n                display();\n                break;\n            case 4:\n                exit(0);\n            default:\n                printf(\"Invalid Choice\\n\");\n        }\n    }\n}\n\nvoid enqueue(void) {\n    int value;\n    printf(\"Enter the value to insert\\n\");\n    scanf(\"%d\",&value);\n\n    if(rear == SIZE-1){\n        printf(\"Queue is Full!!!\\n\");\n    }else {\n        if(front == -1)\n            front = 0;\n        rear = rear +1;\n        queue[rear] = value;\n        printf(\"Inserion Success..!!!\\n\");\n    }\n}\n\nvoid dequeue(void) {\n    if(front == rear)\n        printf(\"Queue is Empty!!\\n\");\n    else {\n        printf(\"Dleted : %d\",queue[front]);\n        front = front+1;\n        if(front == rear)\n            front = rear = -1;\n    }\n}\n\nvoid display(void){\n    if(rear == -1)\n        printf(\"Queue is empty\\n\");\n    else {\n        int i;\n        printf(\"Queue elements are:\\n\");\n        for(i=front; i<=rear; i++)\n            printf(\"%d\\t\",queue[i]);\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include\"queue.h\"\n\n#define MAX 6\n\nint arr[MAX];\nint front =0;\nint rear = -1;\nint count = 0;\n\n\nint peek()\n{\n    return arr[front];\n}\n\n\nint empty()\n{\n    if(count == 0)\n        return 1;\n    else\n        return 0;\n}\n\n\nint full()\n{\n    if(count == MAX )\n        return 1;\n    else\n        return 0;\n}\n\n\nint size()\n{\n    return count;\n}\n\n\nvoid insert(int data)\n{\n    if(full()==0)\n    {\n        if(rear == MAX-1)\n            rear = -1;\n        arr[++rear] = data;\n        count++;\n    }\n    else\n        printf(\"Queue is full\\n\");\n}\n\n\nint removedata()\n{\n    int data = arr[front++];\n    if(front == MAX)\n        front =0;\n    count--;\n    return data;\n}\n\nint main()\n{\n    \n    insert(1);\n    insert(2);\n    insert(3);\n    insert(4);\n    insert(5);\n    insert(6);\n\n    int num = removedata();\n    printf(\"%d \\n\",num);\n\n    insert(7);\n    \n    while(!empty())\n    {\n        int n = removedata();\n        printf(\"%d \",n);\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include\"single_linked_list.h\"\n\n\nvoid print_list();\n\n\nstruct node\n{\n    char data;\n    struct node *next;\n};\n\n\nstruct node *head=NULL;\nstruct node *print_ptr=NULL;\n\nint main()\n{\n    \n    struct node *ptr1 = (struct node *)malloc(sizeof(struct node));\n    ptr1->data = 'A';\n    ptr1->next = NULL;\n\n    \n    struct node *ptr2 = (struct node *)malloc (sizeof(struct node));\n    ptr2->data = 'B';\n    ptr2->next = NULL;\n\n    head = ptr1;\n    \n    ptr1->next = ptr2;\n\n    \n    printf(\"Before insertion\\n\");\n    print_list();\n\n    \n    struct node *insert_ptr = (struct node *)malloc(sizeof(struct node));\n    insert_ptr->data = 'C';\n    insert_ptr->next = NULL;\n\n    ptr2->next = insert_ptr;\n\n    \n    printf(\"After insertion\\n\");\n    print_list();\n\n    \n    ptr2->next = NULL;\n\n    printf(\"After deletion\\n\");\n    print_list();\n\n    \n    free(ptr1);\n    free(ptr2);\n    free(insert_ptr);\n}\nvoid print_list()\n{\n    int index=0;\n    print_ptr = head;\n    while(print_ptr!=NULL)\n    {\n        \n        index++;\n        \n        printf(\"Node Index %d Data value %c\\n\",index,print_ptr->data);\n        \n        print_ptr=print_ptr->next;\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n#include \"single_link_list.h\"\n\n\nstruct node\n{\n    int regno;\n    char *name;\n    struct node *next;\n};\nstruct node * head = NULL;\nstruct node * print_ptr = NULL;\nstruct node * sort = NULL;\nvoid sort_node();\n\nint i=0;\nvoid print_list();\n\nvoid insert_node(int data,char *ptr3)\n{\n    struct node *ptr = (struct node *)malloc(sizeof(struct node));\n    ptr->regno = data;\n    ptr->name = ptr3;\n    ptr->next = head;\n    head = ptr;\n    i++;\n}\n\nint main()\n{\n    \n    insert_node(3,\"you\");\n    insert_node(1,\"i\");\n    insert_node(2,\"love\");\n\n    printf(\"\\nBefore sorting\\n\");\n    print_list();\n\n    sort_node();\n\n    printf(\"\\nAfter sorting\\n\");\n    print_list();\n\n}\n\nvoid sort_node()\n{\n    print_ptr=sort= head;\n    int j=0,regno;\n    char *name;\n\n    \n    while(sort != NULL)\n    {\n        \n        print_ptr = head;\n        for(j=0 ;j<i; j++)\n        {\n            \n            if(sort->regno < print_ptr->regno)\n            {\n                \n                regno = print_ptr->regno;\n                name = print_ptr->name;\n                print_ptr->regno = sort->regno;\n                print_ptr->name = sort->name;\n                sort->regno = regno;\n                sort->name = name;\n            }\n            \n            print_ptr = print_ptr->next;\n        }\n        sort = sort->next;;\n    }\n}\n\nvoid print_list()\n{\n    int i=0;\n    \n    print_ptr = head;\n    while(print_ptr != NULL)\n    {\n        i++;\n        printf(\"node %d regno %d name %s\\n\",i,print_ptr->regno,print_ptr->name);\n        print_ptr = print_ptr->next;\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"sparse_matrix.h\"\n\nint main()\n{\n    int row,column;\n\n    printf(\"Enter the row value\\n\");\n    scanf(\"%d\",&row);\n    printf(\"Enter the column value\\n\");\n    scanf(\"%d\",&column);\n\n    if(row == 0 | column == 0) {\n        printf(\"Invalid row or column value\\n\");\n        exit(0);\n    }\n    int sparse_matrix[row][column];\n\n    int i, j, size = 0;\n    printf(\"Enter the values for Sparse matrix\\n\");\n\n    for(i = 0; i < row; i++ ) {\n        for(j = 0; j < column; j++) {\n            printf(\"Enter the value of Row %d\\t Column %d\\n\",i,j);\n            scanf(\"%d\",&sparse_matrix[i][j]);\n            if(sparse_matrix[i][j] != 0)\n                size = size + 1;\n        }\n    }\n\n    int new_matrix[row][size]; \n    int k = 0;\n    for(i = 0; i < row; i++ ) {\n        for(j = 0; j < column; j++) {\n            if( sparse_matrix[i][j] != 0) {\n                new_matrix[0][k] = i;\n                new_matrix[1][k] = j;\n                new_matrix[2][k] = sparse_matrix[i][j];\n                k++;\n            }\n        }\n    }\n\n\n    for(i = 0; i < row; i++ ) {\n        i==0 ? printf(\"Row   \\t\") : i==1 ? printf(\"column\\t\"):printf(\"Value \\t\");\n        for(j = 0; j < size; j++) {\n            printf(\"%d \",new_matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"stack.h\"\n\n#define MAXSIZE 5\n\nint push(void);\nint pop(void);\nint display(void);\n\nstruct stack\n{\n    int stack[MAXSIZE];\n    int data;\n}stack;\n\nint main(){\n\n    int input;\n\n    stack.data = -1;\n\n    while(1){\n    printf(\"Enter the choice\\n1.Push\\n2.Pop\\n3.Display\\n4.Exit\\n\");\n    scanf(\"%d\",&input);\n\n        switch(input){\n            case 1 :\n                push();\n                break ;\n            case 2 :\n                pop();\n                break ;\n            case 3 :\n                display();\n                break ;\n            case 4 :\n                exit(EXIT_SUCCESS);\n            default :\n                printf(\"Invalid Option\\n\");\n        }\n    }\n}\n\n\nint push(void)\n{\n    int data_input;\n\n    if(stack.data == (MAXSIZE - 1)){\n        printf(\"..........Stack is full...........\\n\");\n        return 0;\n    }else{\n        printf(\"Enter the Data to push\\n\");\n        scanf(\"%d\",&data_input);\n        stack.data = stack.data + 1;\n        stack.stack[stack.data] = data_input;\n    }\n\n}\n\nint pop(void)\n{\n    int data_input;\n    if(stack.data == -1){\n        printf(\"...............Stack is empty.............\\n\");\n        return 0;\n    }else{\n        data_input = stack.stack[stack.data];\n        printf(\"Deleted Data = %d\\n\",stack.stack[stack.data]);\n        stack.data = stack.data - 1;\n    }\n\n}\nint display(void)\n{\n    int count;\n    if(stack.data == -1){\n        printf(\"Stack is empty\\n\");\n        return 0;\n    }else{\n        printf(\"The status of stack\\n\");\n        for(count = stack.data; count>=0; count--)\n        {\n            printf(\"%d\\n\",stack.stack[count]);\n        }\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"stack.h\"\n\n#define MAX 5\n\nint count = -1;\nint arr[MAX];\n\n\nint full(void);\nint empty(void);\n\n\nvoid push(int data)\n{\n    if(full())\n    {\n        \n        printf(\"Stack is full\\n\");\n    }\n    else\n    {\n        \n        count++;\n        arr[count]=data;\n    }\n}\n\n\nvoid pop(void)\n{\n    if(empty())\n    {\n        \n        printf(\"Stack is empty\\n\");\n    }\n    else\n    {\n        \n        count = count-1;\n    }\n}\n\n\nint full()\n{\n    if(count == (MAX-1))\n        return 1;\n    else\n        return 0;\n}\n\n\nint empty()\n{\n    if(count == -1)\n        return 1;\n    else\n        return 0;\n\n}\n\nint main()\n{\n    \n    push(10);\n    push(11);\n    push(12);\n    push(13);\n    push(14);\n\n    printf(\"Before pop\\n\");\n    int i;\n    for(i=0;i<count+1;i++)\n        printf(\"%d\\n\",arr[i]);\n\n    \n    pop();\n    printf(\"After pop\\n\");\n    for(i=0;i<count+1;i++)\n        printf(\"%d\\n\",arr[i]);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n   \n\n\n\n\n#include \"tree.h\"\n\n\n\nstruct database {\n    int roll_no;\n    struct database *left;\n    struct database *right;\n};\n\nextern struct database * root;\nstruct database *root = NULL;\n\n\nvoid add_element(void);\n\n\nvoid print_element(void);\n\n\nvoid inorder(struct  database *node);\nvoid preorder(struct  database *node);\nvoid postorder(struct  database *node);\n\nvoid inorder_1(struct  database *node);\nvoid preorder_1(struct  database *node);\nvoid postorder_1(struct  database *node);\n\nint main(){\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n\n    printf(\"Inorder\\n\");\n    inorder(root);\n    printf(\"preorder\\n\");\n    preorder(root);\n    printf(\"postorder\\n\");\n    postorder(root);\n    printf(\"Inorder_1\\n\");\n    inorder_1(root);\n    printf(\"preorder_1\\n\");\n    preorder_1(root);\n    printf(\"postorder_1\\n\");\n    postorder_1(root);\n\n    return 0;\n}\n\nvoid add_element(void) \n{\n    struct database * current_node = root;\n    struct database * temp_ptr = (struct database* )malloc (sizeof(struct database ));\n\n    printf(\"Enter the value:\");\n    scanf(\"%d\",&temp_ptr->roll_no);\n\n    temp_ptr->left = NULL;\n    temp_ptr->right = NULL;\n    \n    if(root == NULL){\n        root = temp_ptr;\n    } else {\n        while (current_node != NULL) {\n            if(temp_ptr->roll_no > current_node->roll_no){\n                if (current_node->right !=NULL){\n                    current_node = current_node ->right;\n                } else {\n                    current_node->right = temp_ptr;\n                    return;\n                }\n            }else {\n                if(current_node->left !=NULL){\n                    current_node = current_node->left;\n                }else {\n                    current_node->left = temp_ptr;\n                    return;\n                }\n            }\n        }\n    }\n\n}\n\n\n\nvoid inorder(struct  database *node){\n    if(node == NULL){\n        return;\n    } else { \n        inorder(node->left);\n        printf(\"%d\\n\",node->roll_no);\n        inorder(node->right);\n    }\n}\n\nvoid preorder(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        printf(\"%d\\n\",node->roll_no);\n        preorder(node->left);\n        preorder(node->right);\n    }\n}\n\nvoid postorder(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        postorder(node->left);\n        postorder(node->right);\n        printf(\"%d\\n\",node->roll_no);\n    }\n}\n\nvoid inorder_1(struct database *node){\n    if(node == NULL){\n        return;\n    } else {\n        inorder_1(node->right);\n        printf(\"%d\\n\",node->roll_no);\n        inorder_1(node->left);\n    }\n}\n\nvoid preorder_1(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        printf(\"%d\\n\",node->roll_no);\n        preorder_1(node->right);\n        preorder_1(node->left);\n    }\n}\n\nvoid postorder_1(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        postorder_1(node->right);\n        postorder_1(node->left);\n        printf(\"%d\\n\",node->roll_no);\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"flock.h\"\n\nint main()\n{\n    int file_des;\n    ssize_t wt,rd;\n    char arr[]=\"sugukavi\";\n    char buf[10];\n    file_des = open(\".\/text\",O_CREAT | O_RDWR,0644);\n    perror(\"open\");              \n\n    wt = write(file_des,arr,8);  \n    perror(\"write\");\n\n    \n    \n    flock(file_des,LOCK_EX | LOCK_NB);\n    perror(\"flock\");\n    sleep(10);                   \n\n    rd = read(file_des,buf,8);   \n    perror(\"read\");\n\n    close(file_des);             \n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"flock1.h\"\n#include <stdio.h>\n#include <sys\/file.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n\nint main()\n{\n    int file_des;\n    ssize_t wt;\n    char arr[]=\"mara_mani\";  \n    file_des = open(\".\/text\",O_RDWR);\n    perror(\"open\");             \n\n    wt = write(file_des,arr,9); \n    perror(\"write\");  \n\n    flock(file_des,LOCK_UN);    \n    perror(\"flock\");\n\n    close(file_des);            \n}\n\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"fstat.h\"\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n\nint main()\n{\n    int fst,file_des;\n    struct stat detail;\n\n    file_des = open(\".\/text\",O_RDONLY);\n    perror(\"open\");\n    printf(\"fd %d\\n\",file_des);\n\n    fst = fstat(file_des,&detail);\n    perror(\"fstat\");\n    printf(\"fst %d\\n\",fst);\n\n    printf(\"inode number %lu\\n\",detail.st_ino);\n    printf(\"hard link  %lu\\n\",detail.st_nlink);\n    printf(\"user id %lu\\n\",detail.st_uid);\n    printf(\"group id %lu\\n\",detail.st_gid);\n    printf(\"size %lu\\n\",detail.st_size);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n \n\n#include \"ftruncate.h\"\n\n\nint main()\n{\n    int ftr,file_des;\n    char buf[10],snp[30],snp1[30];\n    char buf1[8]=\"sugukavi\";\n    ssize_t rd,wt;\n\n    file_des = open(\".\/ftext\",O_CREAT | O_RDWR,0644); \n    perror(\"open\");                  \n\n    wt = write(file_des,buf1,8);     \n    perror(\"write\");\n\n    ftr = ftruncate(file_des,4);     \n    perror(\"ftruncate\");\n    printf(\"ftruncate %d\\n\",ftr);    \n\n    lseek(file_des,0,SEEK_SET);      \n    rd = read(file_des,buf,5);       \n    perror(\"read\");\n\n    snprintf(snp1,5,\"%s\",buf);       \n    printf(\"%s\",snp1);\n\n    close(file_des);                 \n}\n"}
{"target":"SugumaranEvil","func":"                     \n       \n       \n       \n       \n                     \n\n\n#include \"receiver.h\"\n\nint main()\n{\n   int ret_val;\n   int fd,fd_1;\n   char buffer[9000000];\n   ssize_t ret_read,ret_write;\n\n   \n   fd = open(\"fifo\",O_RDONLY);\n   perror(\"open :\");\n\n   \n   ret_read = read(fd,buffer,9000000);\n   perror(\"read :\");\n\n   \n   fd_1 = open(\"rcv.mp3\", O_CREAT | O_WRONLY ,0764);\n   perror(\"read :\");\n\n   \n   ret_write = write(fd_1,buffer,9000000);\n   perror(\"close :\");\n\n   \n   close(fd);\n   close(fd_1);\n}\n"}
{"target":"SugumaranEvil","func":"                             \n\n                  \n                  \n                  \n                  \n\n                             \n\n\n#include \"sender.h\"\n\nint main()\n{\n   int create_pipe;\n   int fd,fd_1;\n   ssize_t ret_read,ret_write;\n\n   \n   char buffer[9000000];\n\n   \n   create_pipe = mknod(\"fifo\" , S_IFIFO | 0764,0);\n\n   \n   fd = open(\"\/home\/sugu\/Downloads\/baby.mp3\",O_RDONLY);\n\n   \n   ret_read = read(fd,buffer,9000000);\n \n   \n   fd_1 = open(\"fifo\",O_WRONLY);\n\n   \n   ret_write = write(fd_1,buffer,9000000);\n\n   \n   close(fd);\n   close(fd_1);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"open_read.h\"\n\nint main()\n{\n    int file_des,c;\n    ssize_t rd,wt;\n    char arr[50],arr1[50];\n\n    file_des = open(\"\/home\/sugu\/Linux_Programming\/file.txt\",O_RDONLY,0640);\n\n    perror(\"open\");\n    printf(\"File_descriptor %d\\n\",file_des);\n\n    rd = read(file_des,arr,10);\n    perror(\"read\");\n    printf(\"Read %d\\n\",rd);\n\n    snprintf(arr1,10,\"%s\\n\",arr);\n    printf(\"%s\\n\",arr1);\n\n    c = close(file_des);\n    perror(\"close\");\n    printf(\"close%d\\n\",c);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n  \n\n#include \"open_read_write.h\"\n\nint main()\n{\n    int file_des,i;\n    char arr[13]=\"hi i am arr1\\n\";\n    char arr1[13]=\"hi i am arr1\\n\";\n    char arr2[13]=\"hi i am arr2\\n\";\n    char rd_fd[100];\n    char sarr[100];\n\n    file_des = open(\"\/home\/sugu\/Linux_Programming\/file.txt\",O_CREAT | O_RDWR,0655);\n    perror(\"open\");\n\n    ssize_t wt,rd;\n\n    \n    i=lseek(file_des,0,SEEK_SET); \n    perror(\"lseek\");              \n    printf(\"lseek%d\\n\",i);        \n\n    \n    wt = write(file_des,arr,13);  \n    perror(\"write\");              \n    printf(\"write%d\\n\",wt);       \n\n    \n    rd = read(file_des,rd_fd,13); \n    perror(\"read\");               \n    printf(\"Read%d\\n\",rd);        \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,0,SEEK_CUR);  \n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n\n    \n    wt = write(file_des,arr1,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n\n    \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n\n    i=lseek(file_des,-15,SEEK_END);\n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n\n    \n    wt = write(file_des,arr2,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n\n    \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"Read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n\n    close(file_des);               \n    perror(\"close\");\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"store_txt_header.h\"\n\nint main()\n{\n   int fd,shmid;\n   ssize_t rd,op;\n   char buffer[30],*data_ptr;\n\n   \n   fd = open(\".\/txt\",O_RDONLY);\n\n   \n   rd = read(fd,buffer,20);\n\n   \n   shmid = shmget(100,8192,IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); \n   perror(\"shmget \");\n\n   \n   data_ptr = shmat(shmid,NULL,0);\n   perror(\"shmat  \");\n\n   \n   strcpy(data_ptr,buffer);\n\n   \n   shmdt(data_ptr);\n   perror(\"shmdt  \");\n   return 0;\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n\n#include \"read_txt_header.h\"\n\nint main()\n{\n    int shmid;\n    char data[30];\n    char *data_ptr;\n\n    \n    shmid = shmget(100, 8192, 0); \n    perror(\"shmget: \");\n    \n    \n    data_ptr = shmat(shmid, NULL,0);\n    perror(\"shmat: \");\n    \n   \n    strcpy(data, data_ptr);\n \n   \n    printf(\"%s\\n\",data);\n\n   \n    shmdt(data_ptr);\n    perror(\"shmdt: \");\n\n    return 0;\n}\n"}
{"target":"SugumaranEvil","func":"           \n\n\n\n\n            \n\n\n#include \"header.h\"\n\nstruct my_message\n{\n   long mtype; \n   char buffer[30]; \n};\n\nchar string1[]=\"string 14 through msgqueue\\n\";\n\nint main()\n{\n   int msgid;\n   int size;\n   int ret_msgsnd;\n   struct my_message msg_buffer;\n\n   \n   \n   \n   msgid = msgget(1004,IPC_CREAT | 0644);\n   perror(\"msgget\");\n\n   \n   strcpy(msg_buffer.buffer,string1);\n\n   \n   msg_buffer.mtype = 14; \n   size = strlen(string1)+1;\n\n   \n   \n   ret_msgsnd = msgsnd(msgid,&msg_buffer,size,0);\n   perror(\"msgget\");\n}\n"}
{"target":"SugumaranEvil","func":"           \n\n\n\n\n           \n\n#include \"collects_msg.h\"\n\nstruct my_message\n{\n  long mtype; \n  char Buffer[150]; \n};\n\nint main()\n{\n  int msgid;\n  int shmid1,i=0,j;\n  char *data_ptr;\n  int ret_msgrcv;\n  struct my_message msg_buffer;\n  char str[136];\n\n  \n  \n  msgid = msgget(1001,0644);\n  perror(\"msgget :\");\n\n  \n  \n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,11 ,0);\n  perror(\"msgrcv :\");\n\n  \n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  \n  str[i]='\\n';\n\n  \n  \n  msgid = msgget(1002,0644);\n  perror(\"msgget :\");\n\n  \n  \n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,12 ,0);\n  perror(\"msgrcv :\");\n\n  \n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  \n  str[i]='\\n';\n\n  \n  \n  msgid = msgget(1003,IPC_CREAT|0644);\n  perror(\"msgget :\");\n\n  \n  \n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,13 ,0); \n  perror(\"msgrcv :\");\n\n  \n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  \n  str[i]='\\n';\n\n  \n  \n  msgid = msgget(1004,IPC_CREAT|0644);\n  perror(\"msgget :\");\n\n  \n  \n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,14 ,0); \n  perror(\"msgrcv :\");\n\n  \n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  \n  str[i]='\\n';\n\n  \n  \n  msgid = msgget(1005,IPC_CREAT|0644);\n  perror(\"msgget :\");\n\n  \n  \n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,15 ,0); \n  perror(\"msgrcv :\");\n\n  \n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  \n  str[i]='\\n';\n\n  \n  printf(\"i = %d\\n\",i);\n\n  \n  shmid1 = shmget(111,8192,IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  perror(\"shmget :\");\n\n  \n  data_ptr = shmat(shmid1,NULL,0);\n  perror(\"shmat  :\");\n\n  \n  strcpy(data_ptr,str);\n\n  \n  shmdt(data_ptr);\n  perror(\"shmdt  :\");\n  return 0;\n}\n"}
{"target":"SugumaranEvil","func":"           \n\n\n\n\n           \n\n\n#include \"write_to_new_file.h\"\n\nint main()\n{\n    int shmid1;\n   int fd;\n   ssize_t ret_write;\n    char data[136];\n    char *data_ptr;\n\n   \n    shmid1 = shmget(111, 8192, 0);\n    perror(\"shmget: \");\n    \n    \n    \n    data_ptr = shmat(shmid1, NULL,0);\n    perror(\"shmat: \");\n\n    \n    strcpy(data, data_ptr);\n\n   \n    printf(\"%s\\n\",data);\n\n   \n   \n   fd = open(\".\/file\", O_CREAT | O_WRONLY ,0644 );\n\n   \n   ret_write = write(fd, data , 136);\n\n   \n    shmdt(data_ptr);\n    perror(\"shmdt: \");\n\n    return 0;\n}\n"}
{"target":"SugumaranEvil","func":"           \n\n\n\n\n           \n\n#include \"read_data_print.h\"\n\nint main()\n{\n   int fd,m_sync,unmap;\n   char *addr;\n   ssize_t rd;\n   char buffer[20];\n\n   \n   fd = shm_open(\"\/posix\", O_RDWR , 0);\n   perror(\"shm_open\");\n\n   \n   addr = mmap(NULL, 20 , PROT_READ | PROT_WRITE , MAP_SHARED, fd, 0);\n   perror(\"mmap\");\n\n   printf(\"%s\\n\",addr);\n\n   \n   \n   shm_unlink(\"\/posix\");\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n \n\n#include \"truncate.h\"\n\n\nint main()\n{\n    int tr,file_des,sn;\n    char buf[10],snp[30],snp1[30];\n    char buf1[8]=\"sugukavi\";\n    ssize_t rd,wt;\n\n    file_des = open(\".\/text\",O_CREAT | O_RDWR,0644);\n    perror(\"open\");                   \n    printf(\"fd %d\\n\",file_des);       \n\n    wt = write(file_des,buf1,8);      \n    perror(\"write\");\n    printf(\"write %d\\n\",wt);\n\n    rd = read(file_des,buf,8);        \n    perror(\"read\");\n    printf(\"read %d\\n\",rd);\n\n    sn = snprintf(snp1,20,\"%s\",buf);   \n    printf(\"%s\\n\",snp1);              \n    printf(\"snprintf %d\\n\",sn);\n\n    tr = truncate(\".\/text\",20);       \n    perror(\"truncate\");\n    printf(\"truncate %d\\n\",tr);\n\n    lseek(file_des,0,SEEK_SET);       \n    rd = read(file_des,buf,20);      \n    perror(\"read\");\n\n    snprintf(snp1,20,\"%s\",buf);\n    printf(\"%s\\n\",snp1);\n\n    close(file_des);                  \n}\n"}
{"target":"SugumaranEvil","func":"#include \"fork.h\"\n\nint main()\n{\n    pid_t pid;\n\n    pid = fork();\n\n    if(pid == 0) {\n        printf(\"child process....\\n\");\n        printf(\"PID = %d\\nPPID = %d\\n\",getpid(),getppid());\n        printf(\"child process exit......\\n\");\n    }\n    else if(pid > 0 ){\n        int status;\n        printf(\"Before child process creation\\n\");\n\n        pid_t wt_rv = wait(&status);\n        printf(\"Parent process....\\n\");\n\n        printf(\"PID = %d\\nPPID = %d\\n\",getpid(),getppid());\n        printf(\"Status %d\\n\",WIFEXITED(status));  \n\n        printf(\"Wait ret value %d\\n\",wt_rv);\n        printf(\"Parent process exit......\\n\");\n    }\n    else{\n        printf(\"Fork failed\\n\");\n    }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"msg_q_crt.h\"\n\n\nstruct mymsg {\n    long mtype;\n    char mtext[200];\n};\n\n\nchar str1[]=\"Message from str1\\n\";\nchar str2[]=\"Message from str2\\n\";\nchar str3[]=\"Message from str3\\n\";\n\nint main(){\n    printf(\"\\033[1;31mSystem V Message queue Creating a message\\033[0m\\n\");\n    int mesg_id,msgsnd_return;\n\n    struct mymsg my_data1,my_data2,my_data3;\n\n    \n    my_data1.mtype  = 1; \n    my_data2.mtype  = 2;\n    my_data3.mtype  = 3;\n\n    \n    strncpy(my_data1.mtext,str1,strlen(str1)+1);\n    strncpy(my_data2.mtext,str2,strlen(str2)+1);\n    strncpy(my_data3.mtext,str3,strlen(str3)+1);\n\n    \n    mesg_id = msgget(103,IPC_CREAT|0644);\n    perror(\"msgget\");\n\n    \n    \n    msgsnd_return = msgsnd(mesg_id, &my_data1, strlen(str1)+1, 1);\n    perror(\"msgsnd\");\n    msgsnd_return = msgsnd(mesg_id, &my_data2, strlen(str2)+1, 2);\n    perror(\"msgsnd\");\n    msgsnd_return = msgsnd(mesg_id, &my_data3, strlen(str3)+1, 3);\n    perror(\"msgsnd\");\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n#include \"P_msgq_rcv.h\"\n\nchar buffer[8192];\n\nint main()\n{\n    int mq_op_ret,mq_rcv_ret;\n    struct mq_attr my_mq_attr;\n    unsigned int msg_pri = 10;\n\n    my_mq_attr.mq_flags    = 0;\n    my_mq_attr.mq_maxmsg  = 10;\n    my_mq_attr.mq_msgsize = 8192;\n\n    \n    \n    mq_op_ret = mq_open(\"\/P_msgq\", O_RDONLY);\n    perror(\"mq_open\");\n\n    printf(\"ret value of mq_open = %d\\n\",mq_op_ret);\n\n    \n    \n    mq_rcv_ret = mq_receive(mq_op_ret, buffer, 8192,&msg_pri);\n    perror(\"mq_receive\");\n\n    printf(\"ret value of mq_receive = %d\\n\",mq_rcv_ret);\n    printf(\"Data from sender ==> %s\\n\",buffer);\n\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\n#include \"P_msgq_snd.h\"\n\nchar str[]=\"Data from POSIX msg queue send\\n\";\n\n\n\n\n\n\n\n\n\nint main()\n{\n    int mq_op_ret,mq_send_ret;\n    struct mq_attr my_mq_attr;\n\n    my_mq_attr.mq_flags   = 0;   \n    my_mq_attr.mq_maxmsg  = 10;\n    my_mq_attr.mq_msgsize = 8192;\n\n    \n    \n    mq_op_ret = mq_open(\"\/P_msgq\", O_CREAT | O_RDWR, 0644, &my_mq_attr);\n    perror(\"mq_open\");\n\n    printf(\"ret value of mq_open = %d\\n\",mq_op_ret);\n\n    \n    mq_send_ret = mq_send(mq_op_ret, str, strlen(str)+1,10);\n    perror(\"mq_send\");\n\n    printf(\"ret value of mq_send = %d\\n\",mq_send_ret);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"sys_v_shm.h\"\n\nint main()\n{\n    char string[100];\n    int shmid;\n    char *data;\n\n    shmid = shmget(1000, 100, 0);\n    perror(\"shmget \");\n\n    data = shmat(shmid, NULL, 0);\n    perror(\"shmat\");\n\n    strcpy(string, data);\n    perror(\"strcpy\");\n\n    printf(\"Data ==> %s\\n\",string);\n\n    shmdt(data);\n    perror(\"shmat\");\n\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"posix_shm.h\"\n\nint main()\n{\n   int open_fd, munmap_ret, msync_ret;\n   ssize_t read_fd;\n   char *mmap_ret;\n   char buff[50];\n\n   \n   open_fd = shm_open(\"\/posix\" , O_RDWR , 0644);\n   if(open_fd == -1){\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }else {\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }\n\n\n   \n   read_fd = read(open_fd,buff,4096);\n   if(read_fd == -1){\n    perror(\"read\");\n   }else {\n    perror(\"read\");\n   }\n\n   \n   \n   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);\n   perror(\"mmap\");\n\n   \n   msync_ret = msync(mmap_ret, 4096, MS_SYNC);\n   if(msync_ret == -1){\n       perror(\"msync\");\n   }else {\n       perror(\"msync\");\n   }\n\n   \n   printf(\"%s\\n\",buff);\n\n   \n   munmap_ret = munmap(mmap_ret, 4096);\n   if(munmap_ret == -1) {\n       perror(\"munmap\");\n   }else {\n       perror(\"munmap\");\n   }\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"semaphore.h\"\n\nchar str[]=\"semaphore is in lock\\n\";\nchar buff[1024];\n\nint main()\n{\n    int open_fd;\n        ssize_t write_fd,read_fd;\n    struct sembuf sem_buf;\n    sem_buf.sem_num = 3;\n    sem_buf.sem_op  = -1;\n\n    int semid;\n        \n    semid = semget(93, 5,IPC_CREAT | 0600);\n    perror(\"semget\");\n\n    \n    semop(semid, &sem_buf, 1); \n    perror(\"semop\");\n\n        open_fd = open(\"test.txt\",O_CREAT | O_RDONLY, 0644);\n        perror(\"open\");\n\n        read_fd = read(open_fd, buff, 1024);\n        perror(\"read\");\n  \n        close(open_fd);\n        perror(\"close\");\n   \n        for(int i=0; i<10; i++) {\n              printf(\"%s\\n\",buff);\n              sleep(1);\n        }\n\n    sem_buf.sem_op = 1;\n    semop(semid, &sem_buf, 1);\n    perror(\"semop\");\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\nint main()\n{\n    int soc_fd, bind_fd;\n    int connect_fd;\n    ssize_t write_fd;\n    char buff[]=\"data from client\\n\";\n\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n\n    \n    strcpy(addr.sun_path, PATHNAME);\n    perror(\"strcpy\");\n\n    \n    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    perror(\"socket\");\n    printf(\"Return value of Socket = %d\\n\",soc_fd);\n\n    \n    connect_fd = connect(soc_fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un));\n    perror(\"connect\");\n\n    \n    write_fd = write(soc_fd, buff, sizeof(buff));\n    perror(\"write\");\n\n    close(soc_fd);\n}\n"}
{"target":"SugumaranEvil","func":"\n\n\n\n\n\n\nint main()\n{\n    int soc_fd, bind_fd;\n    int listen_fd, accept_fd;\n    ssize_t read_fd;\n    char buff[1024];\n\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n\n    strcpy(addr.sun_path, PATHNAME);\n    perror(\"strcpy\");\n\n    \n    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    perror(\"socket\");\n\n    \n    bind_fd = bind(soc_fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));\n    perror(\"bind\");\n\n    \n    listen_fd = listen(soc_fd, 11);\n    perror(\"listen\");\n\n    \n    accept_fd = accept(soc_fd, NULL, NULL);\n    perror(\"accept\");\n\n    \n    read_fd = read(accept_fd, buff, 30);\n    perror(\"read\");\n\n    printf(\"Data from client\\n\");\n    printf(\"==> %s\\n\",buff);\n\n}\n"}
{"target":"SugumaranEvil","func":"\n\n         \n\n\n\n\n#include \"posix_shm.h\"\n\nint main()\n{\n   int open_fd, munmap_ret, msync_ret;\n   ssize_t write_fd;\n   char *mmap_ret;\n   char buff[50]=\"Data stored in posix shared memory\\n\";\n\n   \n   open_fd = shm_open(\"\/posix\" , O_CREAT | O_RDWR | O_TRUNC , 0644);\n   if(open_fd == -1){\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }else {\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }\n\n\n   \n   write_fd = write(open_fd,buff,strlen(buff)+1);\n   if(write_fd == -1){\n    perror(\"write\");\n   }else {\n    perror(\"write\");\n   }\n\n   \n   \n   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);\n   perror(\"mmap\");\n\n   \n   \n   msync_ret = msync(mmap_ret, 4096, MS_SYNC);\n   if(msync_ret == -1){\n       perror(\"msync\");\n   }else {\n       perror(\"msync\");\n   }\n\n   \n   munmap_ret = munmap(mmap_ret, 4096);\n   if(munmap_ret == -1) {\n       perror(\"munmap\");\n   }else {\n       perror(\"munmap\");\n   }       \n   \n}\n"}
{"target":"tadeograch","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"monty.h\"\n\n\nint analize(stack_t **stack, unsigned int line_number)\n{\n    int type_i;\n    instruction_t type[] = {\n                {\"push\", push_func},\n                {\"pall\", pall_func},\n                {\"pint\", pint_func},\n                {\"pop\", pop_func},\n                {\"swap\", swap_func},\n                {\"add\", add_func},\n                {\"nop\", nop_func},\n                {\"sub\", sub_func},\n                {\"div\", div_func},\n                {\"mul\", mul_func},\n                {\"mod\", mod_func},\n                {NULL, NULL}\n    };\n\n    for (type_i = 0; type[type_i].opcode != NULL; type_i++)\n    {\n        if (strcmp(code[0], type[type_i].opcode) == 0)\n        {\n            type[type_i].f(stack, line_number);\n            break;\n        }\n    }\n    if (type[type_i].opcode == NULL)\n    {\n        return (0);\n    }\n    return (1);\n}\n"}
{"target":"tadeograch","func":"#include <stdio.h>\n#include <stdlib.h>\n#include \"monty.h\"\n\n\nunsigned int print_dlistint(const stack_t *h)\n{\n    unsigned int n = 0;\n\n    while (h)\n    {\n        printf(\"%i\\n\", h->n);\n        n++;\n        h = h->next;\n    }\n    return (n);\n}\n\n\nunsigned int _strlen(char *s)\n{\n    unsigned int n, len;\n\n    n = len = 0;\n    while (*(s + n) != '\\0')\n    {\n        n++;\n        len++;\n    }\n    return (len);\n}\n\n\nunsigned int dlistint_len(const stack_t *h)\n{\n    unsigned int n = 0;\n\n    if (h == NULL)\n    {\n        return (0);\n    }\n    while (h != NULL)\n    {\n        n++;\n        h = h->next;\n    }\n    return (n);\n}\n\n\nvoid free_dlistint(stack_t *head)\n{\n    stack_t *aux;\n\n    while (head != NULL)\n    {\n        aux = head;\n        head = head->next;\n        free(aux);\n    }\n}\n"}
{"target":"tadeograch","func":"#include <string.h>\n#include <stdio.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"monty.h\"\n\nint get_bytecode(char *filename)\n{\n    FILE *fp;\n    char *line = NULL;\n    unsigned int line_number = 0;\n    size_t len = 0;\n    ssize_t read;\n    stack_t *stack = NULL;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Error: Can't open file %s\\n\", filename);\n        exit(EXIT_FAILURE);\n    }\n    while ((read = getline(&line, &len, fp)) != -1)\n    {\n        line_number++;\n        split_buffer(line);\n        if (code[0] == NULL)\n            continue;\n        if (strcmp(code[0], \"push\") == 0 && check_number(code[1]) == 1)\n        {\n            printf(\"L%d: usage: push integer\\n\", (line_number));\n            free(line);\n            free_dlistint(stack);\n            fclose(fp);\n            exit(EXIT_FAILURE);\n        }\n        if (analize(&stack, line_number) == 0)\n        {\n            printf(\"L%d: unknown instruction %s\\n\", line_number, code[0]);\n            free_dlistint(stack);\n            free(line);\n            fclose(fp);\n            exit(EXIT_FAILURE);\n        }\n    }\n    free(line);\n    free_dlistint(stack);\n    fclose(fp);\n    return (0);\n}\n"}
{"target":"tadeograch","func":"#include \"monty.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid push_func(stack_t **stack, unsigned int line_number)\n{\n    int n;\n    stack_t *new = malloc(sizeof(stack_t));\n    (void)line_number;\n\n    if (!new)\n    {\n        free(new);\n        return;\n    }\n    n = atoi(code[1]);\n    new->n = n;\n    new->prev = NULL;\n    if (!*stack)\n    {\n        new->next = NULL;\n        *stack = new;\n    }\n    else\n    {\n        new->next = *stack;\n        (*stack)->prev = new;\n        *stack = new;\n    }\n}\n"}
{"target":"tadeograch","func":"#include \"sort.h\"\n\n\nvoid insertion_sort_list(listint_t **list)\n{\n    listint_t *temp_n, *temp_sort, *swapper;\n\n    if (!list || *list == NULL)\n        return;\n\n    if ((*list)->next == NULL)\n        return;\n\n    temp_n = *list;\n\n    while (temp_n != NULL)\n    {\n        temp_sort = temp_n;\n        if (temp_sort->prev != NULL)\n        {\n            while (temp_sort->n < (temp_sort->prev)->n && temp_sort->prev != NULL)\n            {\n                swapper = temp_sort->prev;\n                if (swapper->prev == NULL)\n                {\n                    swap(temp_sort, swapper, list);\n                    print_list(*list);\n                    break;\n                }\n                swap(temp_sort, swapper, list);\n                print_list(*list);\n            }\n        }\n        temp_n = temp_n->next;\n    }\n}\n\n\nlistint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)\n{\n    listint_t *aux_prev, *aux_next = temp_sort->next;\n\n    swapper = temp_sort->prev;\n    if (temp_sort->next == NULL && swapper->prev == NULL)\n    {\n        temp_sort->next = temp_sort->prev;\n        temp_sort->prev = NULL;\n        swapper->prev = swapper->next;\n        swapper->next = NULL;\n        *list = temp_sort;\n    }\n    else if (swapper->prev == NULL)\n    {\n        temp_sort->prev = NULL;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = aux_next;\n        aux_next->prev = swapper;\n        *list = temp_sort;\n    }\n    else if (temp_sort->next == NULL)\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = NULL;\n    }\n    else\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->next = aux_next;\n        swapper->prev = temp_sort;\n        aux_next->prev = swapper;\n    }\n    return (list);\n}\n"}
{"target":"tadeograch","func":"#include \"sort.h\"\n\n\n\nvoid shell_sort(int *array, size_t size)\n{\n    size_t n = 0, i, j;\n    int temp = 0;\n\n    if (size < 2)\n        return;\n\n    while (n <= size)\n        n = (n * 3) + 1;\n\n    while (n > 1)\n    {\n        n = (n - 1) \/ 3;\n        for (i = 0; i < size - n; i++)\n        {\n            for (j = i + n; j > 0 && j >= n; j -= n)\n            {\n                if (array[j] < array[j - n])\n                {\n                    temp = array[j - n];\n                    array[j - n] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        print_array(array, size);\n    }\n}\n"}
{"target":"tadeograch","func":"#include \"sort.h\"\n\n\n\nvoid cocktail_sort_list(listint_t **list)\n{\n    listint_t *recorro, *temp;\n\n    if (!list || *list == NULL)\n        return;\n\n    if ((*list)->next == NULL)\n        return;\n\n    temp = (*list)->next;\n    while (temp != NULL)\n    {\n        recorro = *list;\n        while (recorro->next != NULL)\n        {\n            if (recorro->n > recorro->next->n)\n            {\n                swap(recorro->next, recorro, list);\n                print_list(*list);\n            }\n            else\n                recorro = recorro->next;\n        }\n        while (recorro->prev != NULL)\n        {\n            if (recorro->n < recorro->prev->n)\n            {\n                swap(recorro, recorro->prev, list);\n                print_list(*list);\n            }\n            else\n                recorro = recorro->prev;\n        }\n        temp = temp->next;\n    }\n}\n\n\nlistint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)\n{\n    listint_t *aux_prev, *aux_next = temp_sort->next;\n\n    if (temp_sort->next == NULL && swapper->prev == NULL)\n    {\n        temp_sort->next = temp_sort->prev;\n        temp_sort->prev = NULL;\n        swapper->prev = swapper->next;\n        swapper->next = NULL;\n        *list = temp_sort;\n    }\n    else if (swapper->prev == NULL)\n    {\n        temp_sort->prev = NULL;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = aux_next;\n        aux_next->prev = swapper;\n        *list = temp_sort;\n    }\n    else if (temp_sort->next == NULL)\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = NULL;\n    }\n    else\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->next = aux_next;\n        swapper->prev = temp_sort;\n        aux_next->prev = swapper;\n    }\n    return (list);\n}\n"}
{"target":"tadeograch","func":"#include \"sort.h\"\n\n\nvoid counting_sort(int *array, size_t size)\n{\n    int i, j, max = 0;\n    int *new_arr, *new_new;\n\n    if (size < 2)\n        return;\n\n    for (i = 0; i <= (int)size; i++)\n    {\n        if (array[i] > max)\n            max = array[i];\n    }\n    max += 1;\n    new_arr = (int *) malloc(sizeof(int) * max);\n    for (i = 0; i <= max; i++)\n        new_arr[i] = 0;\n\n    for (i = 0; i < (int)size; i++)\n        new_arr[array[i]] += 1;\n\n    for (i = 0; i < max; i++)\n    {\n        j = i + 1;\n        new_arr[j] += new_arr[i];\n    }\n    print_array(new_arr, max);\n\n    new_new = malloc(sizeof(int) * size);\n\n    for (i = 0; i < (int)size; i++)\n    {\n        new_arr[array[i]] -= 1;\n        new_new[new_arr[array[i]]] = array[i];\n    }\n    for (i = 0; i < (int)size; i++)\n        array[i] = new_new[i];\n\n    free(new_new);\n    free(new_arr);\n}\n"}
{"target":"tadeograch","func":"#include <stdio.h>\n#include \"sort.h\"\n\n\nvoid merge_sort(int *array, size_t size)\n{\n    int n = (int)size;\n    int *brray;\n\n    if (size < 2)\n        return;\n    brray = malloc(sizeof(int) * size);\n    CopyArray(array, 0, n, brray);\n    TopDownSplitMerge(brray, 0, n, array);\n    free(brray);\n}\n\n\nvoid TopDownSplitMerge(int B[], int iBegin, int iEnd, int A[])\n{\n    int iMiddle, index;\n\n    if (iEnd - iBegin <= 1)\n        return;\n    iMiddle = (iEnd + iBegin) \/ 2;\n\n    TopDownSplitMerge(A, iBegin,  iMiddle, B);\n    TopDownSplitMerge(A, iMiddle, iEnd, B);\n\n    printf(\"Merging...\\n\");\n    TopDownMerge(B, iBegin, iMiddle, iEnd, A);\n    printf(\"[Done]: \");\n    for (index = iBegin; index < iEnd; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iEnd - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n}\n\n\n\nvoid TopDownMerge(int A[], int iBegin, int iMiddle, int iEnd, int B[])\n{\n    int i = iBegin, j = iMiddle, k, index;\n\n    for (k = iBegin; k < iEnd; k++)\n    {\n        if (i < iMiddle && (j >= iEnd || A[i] <= A[j]))\n        {\n            B[k] = A[i];\n            i = i + 1;\n        }\n        else\n        {\n            B[k] = A[j];\n            j = j + 1;\n        }\n    }\n    printf(\"[left]: \");\n    for (index = iBegin; index < iMiddle; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iMiddle - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n    printf(\"[right]: \");\n    for (index = iMiddle; index < iEnd; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iEnd - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n}\n\n\nvoid CopyArray(int A[], int iBegin, int iEnd, int B[])\n{\n    int k;\n\n    for (k = iBegin; k < iEnd; k++)\n        B[k] = A[k];\n}\n"}
{"target":"tadeograch","func":"#include <stdio.h>\n#include \"sort.h\"\n\n\nvoid radix_sort(int *array, size_t size)\n{\n    int digits = 0, i, j, max_num = 0, start = 0, len, at_index = 0, div = 10, temp, a;\n    int *arr_aux;\n    int *arr_aux2;\n\n    len = (int)size;\n    arr_aux = malloc(sizeof(int) * size);\n    arr_aux2 = malloc(sizeof(int) * size);\n    arr_cpy(array, arr_aux2, len);\n    for(i = 0; i < len; i++)\n    {\n        if(array[i] > max_num)\n            max_num = array[i];\n    }\n    while(max_num > 0)\n    {\n        max_num = max_num \/ 10;\n        digits++;\n    }\n\n    while(digits >= 0)\n    {\n        for(a = 0; a < len; a++)\n        {\n            if(arr_aux2[a] != 0)\n                arr_aux[a] = arr_aux2[a] % 10;\n            else\n                arr_aux[a] = arr_aux2[a];\n        }\n        print_array(arr_aux, size);\n        for(start = 0; start < len; start++)\n        {\n            at_index = get_index_lower(arr_aux, start, len);\n            printf(\"index: %d\\n\", at_index);\n            temp = array[start];\n            array[start] = array[at_index];\n            array[at_index] = temp;\n        }\n        print_array(arr_aux2, size);\n        for(j = 1; j < len; j++)\n        {\n            arr_aux2[i] = arr_aux2[i] \/ div; \n        }\n        div = div * 10;\n        \n        digits--;\n    }\n}\n\n\n\nvoid arr_cpy(int *array1, int *array2, int size)\n{\n    int i;\n\n    for(i = 0; i < size; i++)\n    {\n        array2[i] = array1[i];\n    }\n}\n\nint get_index_lower(int *array, int start, int size)\n{\n    int min = 0, index = 0, i = start;\n\n    for(i = 0; i < size; i++)\n    {\n        if (array[i] < min)\n            min = array[i];\n            index = i;\n    }\n    return(index);\n}"}
{"target":"tadeograch","func":"#include <stdio.h>\n#include \"sort.h\"\n\n\nvoid selection_sort(int *array, size_t size)\n{\n    size_t i, j;\n    int lower = 0, position = 0, first = 0;\n\n    if (size < 2)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        first = array[i];\n        lower = first;\n        for (j = i; j < size; j++)\n        {\n            if (lower > array[j])\n            {\n                lower = array[j];\n                position = j;\n            }\n        }\n        if (lower < first)\n        {\n            array[i] = lower;\n            array[position] = first;\n            print_array(array, size);\n        }\n    }\n}\n"}
{"target":"Theemiss","func":"#include \"binary_trees.h\"\n\nint binary_tree_is_leaf(const binary_tree_t *node)\n{\n    if (node == NULL)\n        return (0);\n    else if (node->left == NULL && node->right == NULL)\n        return (1);\n    return (0);\n}\n\n\nsize_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t h_left, h_right;\n\n    if (tree == NULL || binary_tree_is_leaf(tree))\n        return (0);\n    h_left = binary_tree_height(tree->left);\n    h_right = binary_tree_height(tree->right);\n    if (h_right <= h_left)\n        return (h_left + 1);\n\n    return (h_right + 1);\n\n}\n\n\nint binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    binary_tree_t *left, *right;\n    size_t l_r, l_l;\n\n    if (tree == NULL)\n        return (0);\n    left = tree->left;\n    right = tree->right;\n\n    if (binary_tree_is_leaf(tree))\n        return (1);\n    if (left == NULL || right == NULL)\n        return (0);\n    l_r = binary_tree_height(right);\n    l_l = binary_tree_height(left);\n    if (l_r == l_l)\n    {\n        if (binary_tree_is_perfect(left) && binary_tree_is_perfect(right))\n            return (1);\n    }\n    return (0);\n\n}\n"}
{"target":"Theemiss","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"binary_trees.h\"\n\n\n\n\nstatic int print_t(const binary_tree_t *tree, int offset, int depth, char **s)\n{\n    char b[6];\n    int width, left, right, is_left, i;\n\n    if (!tree)\n        return (0);\n    is_left = (tree->parent && tree->parent->left == tree);\n    width = sprintf(b, \"(%03d)\", tree->n);\n    left = print_t(tree->left, offset, depth + 1, s);\n    right = print_t(tree->right, offset + left + width, depth + 1, s);\n    for (i = 0; i < width; i++)\n        s[depth][offset + left + i] = b[i];\n    if (depth && is_left)\n    {\n        for (i = 0; i < width + right; i++)\n            s[depth - 1][offset + left + width \/ 2 + i] = '-';\n        s[depth - 1][offset + left + width \/ 2] = '.';\n    }\n    else if (depth && !is_left)\n    {\n        for (i = 0; i < left + width; i++)\n            s[depth - 1][offset - width \/ 2 + i] = '-';\n        s[depth - 1][offset + left + width \/ 2] = '.';\n    }\n    return (left + width + right);\n}\n\n\nstatic size_t _height(const binary_tree_t *tree)\n{\n    size_t height_l;\n    size_t height_r;\n\n    height_l = tree->left ? 1 + _height(tree->left) : 0;\n    height_r = tree->right ? 1 + _height(tree->right) : 0;\n    return (height_l > height_r ? height_l : height_r);\n}\n\n\nvoid binary_tree_print(const binary_tree_t *tree)\n{\n    char **s;\n    size_t height, i, j;\n\n    if (!tree)\n        return;\n    height = _height(tree);\n    s = malloc(sizeof(*s) * (height + 1));\n    if (!s)\n        return;\n    for (i = 0; i < height + 1; i++)\n    {\n        s[i] = malloc(sizeof(**s) * 255);\n        if (!s[i])\n            return;\n        memset(s[i], 32, 255);\n    }\n    print_t(tree, 0, 0, s);\n    for (i = 0; i < height + 1; i++)\n    {\n        for (j = 254; j > 1; --j)\n        {\n            if (s[i][j] != ' ')\n                break;\n            s[i][j] = '\\0';\n        }\n        printf(\"%s\\n\", s[i]);\n        free(s[i]);\n    }\n    free(s);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\nvoid  exit_bul(char **cmd, char *input, char **argv, int c)\n{\n    int statue, i = 0;\n\n    if (cmd[1] == NULL)\n    {\n        free(input);\n        free(cmd);\n        exit(EXIT_SUCCESS);\n    }\n    while (cmd[1][i])\n    {\n        if (_isalpha(cmd[1][i++]) != 0)\n        {\n            _prerror(argv, c, cmd);\n            break;\n        }\n        else\n        {\n            statue = _atoi(cmd[1]);\n            free(input);\n            free(cmd);\n            exit(statue);\n        }\n    }\n}\n\n\n\nint change_dir(char **cmd, __attribute__((unused))int er)\n{\n    int value = -1;\n    char cwd[PATH_MAX];\n\n    if (cmd[1] == NULL)\n        value = chdir(getenv(\"HOME\"));\n    else if (_strcmp(cmd[1], \"-\") == 0)\n    {\n        value = chdir(getenv(\"OLDPWD\"));\n    }\n    else\n        value = chdir(cmd[1]);\n\n    if (value == -1)\n    {\n        perror(\"hsh\");\n        return (-1);\n    }\n    else if (value != -1)\n    {\n        getcwd(cwd, sizeof(cwd));\n        setenv(\"OLDPWD\", getenv(\"PWD\"), 1);\n        setenv(\"PWD\", cwd, 1);\n    }\n    return (0);\n}\n\nint dis_env(__attribute__((unused)) char **cmd, __attribute__((unused)) int er)\n{\nsize_t i;\n    int len;\n\n    for (i = 0; environ[i] != NULL; i++)\n    {\n        len = _strlen(environ[i]);\n        write(1, environ[i], len);\n        write(STDOUT_FILENO, \"\\n\", 1);\n    }\n    return (0);\n}\n\nint display_help(char **cmd, __attribute__((unused))int er)\n{\n    int fd, fw, rd = 1;\n    char c;\n\n    fd = open(cmd[1], O_RDONLY);\n    if (fd < 0)\n    {\n        perror(\"Error\");\n        return (0);\n    }\n    while (rd > 0)\n    {\n        rd = read(fd, &c, 1);\n        fw = write(STDOUT_FILENO, &c, rd);\n        if (fw < 0)\n        {\n            return (-1);\n        }\n    }\n    _putchar('\\n');\n    return (0);\n}\n\nint echo_bul(char **cmd, int st)\n{\n    char *path;\n    unsigned int  pid = getppid();\n\n    if (_strncmp(cmd[1], \"$?\", 2) == 0)\n    {\n        print_number_in(st);\n        PRINTER(\"\\n\");\n    }\n    else if (_strncmp(cmd[1], \"$$\", 2) == 0)\n    {\n        print_number(pid);\n        PRINTER(\"\\n\");\n\n    }\n    else if (_strncmp(cmd[1], \"$PATH\", 5) == 0)\n    {\n        path = _getenv(\"PATH\");\n        PRINTER(path);\n        PRINTER(\"\\n\");\n        free(path);\n\n    }\n    else\n        return (print_echo(cmd));\n\n    return (1);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\n\nint handle_builtin(char **cmd, int er)\n{\n     bul_t bil[] = {\n        {\"cd\", change_dir},\n        {\"env\", dis_env},\n        {\"help\", display_help},\n        {\"echo\", echo_bul},\n        {\"history\", history_dis},\n        {NULL, NULL}\n    };\n    int i = 0;\n\n    while ((bil + i)->command)\n    {\n        if (_strcmp(cmd[0], (bil + i)->command) == 0)\n        {\n            return ((bil + i)->fun(cmd, er));\n        }\n        i++;\n    }\n    return (-1);\n}\n\nint check_cmd(char **cmd, char *input, int c, char **argv)\n{\n    int status;\n    pid_t pid;\n\n    if (*cmd == NULL)\n    {\n        return (-1);\n    }\n\n    pid = fork();\n    if (pid == -1)\n    {\n        perror(\"Error\");\n        return (-1);\n    }\n\n    if (pid == 0)\n    {\n        if (_strncmp(*cmd, \".\/\", 2) != 0 && _strncmp(*cmd, \"\/\", 1) != 0)\n        {\n            path_cmd(cmd);\n        }\n\n        if (execve(*cmd, cmd, environ) == -1)\n        {\n            print_error(cmd[0], c, argv);\n            free(input);\n            free(cmd);\n            exit(EXIT_FAILURE);\n        }\n        return (EXIT_SUCCESS);\n    }\n    wait(&status);\n    return (0);\n}\n\nvoid signal_to_handel(int sig)\n{\n    if (sig == SIGINT)\n    {\n        PRINTER(\"\\n$ \");\n    }\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\nint path_cmd(char **cmd)\n{\n    char *path, *value, *cmd_path;\n    struct stat buf;\n\n    path = _getenv(\"PATH\");\n    value = _strtok(path, \":\");\n    while (value != NULL)\n    {\n        cmd_path = build(*cmd, value);\n        if (stat(cmd_path, &buf) == 0)\n        {\n            *cmd = _strdup(cmd_path);\n            free(cmd_path);\n            free(path);\n            return (0);\n        }\n        free(cmd_path);\n        value = _strtok(NULL, \":\");\n    }\n    free(path);\n\n    return (1);\n}\n\nchar *build(char *token, char *value)\n{\n    char *cmd;\n    size_t len;\n\n    len = _strlen(value) + _strlen(token) + 2;\n    cmd = malloc(sizeof(char) * len);\n    if (cmd == NULL)\n    {\n        return (NULL);\n    }\n\n    memset(cmd, 0, len);\n\n    cmd = _strcat(cmd, value);\n    cmd = _strcat(cmd, \"\/\");\n    cmd = _strcat(cmd, token);\n\n    return (cmd);\n}\n\nchar *_getenv(char *name)\n{\n    size_t nl, vl;\n    char *value;\n    int i, x, j;\n\n    nl = _strlen(name);\n    for (i = 0 ; environ[i]; i++)\n    {\n        if (_strncmp(name, environ[i], nl) == 0)\n        {\n            vl = _strlen(environ[i]) - nl;\n            value = malloc(sizeof(char) * vl);\n            if (!value)\n            {\n                free(value);\n                perror(\"unable to alloc\");\n                return (NULL);\n            }\n\n            j = 0;\n            for (x = nl + 1; environ[i][x]; x++, j++)\n            {\n                value[j] = environ[i][x];\n            }\n            value[j] = '\\0';\n\n            return (value);\n        }\n    }\n\n    return (NULL);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\nint history(char *input)\n{\n    char *filename = \".simple_shell_history\";\n    ssize_t fd, w;\n    int len = 0;\n\n    if (!filename)\n        return (-1);\n    fd = open(filename, O_CREAT | O_RDWR | O_APPEND, 00600);\n    if (fd < 0)\n        return (-1);\n    if (input)\n    {\n        while (input[len])\n            len++;\n        w = write(fd, input, len);\n        if (w < 0)\n            return (-1);\n    }\n    return (1);\n}\n\nvoid free_env(char **env)\n{\n    int i;\n\n    for (i = 0; env[i]; i++)\n    {\n        free(env[i]);\n    }\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\nvoid *_realloc(void *ptr, unsigned int old_size, unsigned int new_size)\n{\n    void *result;\n\n    if (new_size == old_size)\n        return (ptr);\n    if (new_size == 0 && ptr)\n    {\n        free(ptr);\n        return (NULL);\n    }\n    result = malloc(new_size);\n    if (result == NULL)\n        return (NULL);\n    if (ptr == NULL)\n    {\n        fill_an_array(result, '\\0', new_size);\n        free(ptr);\n    }\n    else\n    {\n        _memcpy(result, ptr, old_size);\n        free(ptr);\n    }\n    return (result);\n\n}\n\nvoid free_all(char **cmd, char *line)\n{\n    free(cmd);\n    free(line);\n    cmd = NULL;\n    line = NULL;\n}\n\n\nchar *_memcpy(char *dest, char *src, unsigned int n)\n{\n    unsigned int i;\n\n    for (i = 0; i < n; i++)\n    {\n        dest[i] = src[i];\n    }\n    return (dest);\n}\n\nvoid *fill_an_array(void *a, int el, unsigned int len)\n{\n    char *p = a;\n    unsigned int i = 0;\n\n    while (i < len)\n    {\n        *p = el;\n        p++;\n        i++;\n    }\n    return (a);\n}\n\nvoid *_calloc(unsigned int size)\n{\n    char *a;\n    unsigned int i;\n\n    if (size == 0)\n    return (NULL);\n    a = malloc(size);\n    if (a == NULL)\n    return (NULL);\n    for (i = 0; i < size; i++)\n    {\n        a[i] = '\\0';\n    }\n    return (a);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\nint history_dis(__attribute__((unused))char **c, __attribute__((unused))int s)\n{\n    char *filename = \".simple_shell_history\";\n    FILE *fp;\n    char *line = NULL;\n    size_t len = 0;\n    int counter = 0;\n    char *er;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL)\n    {\n        return (-1);\n    }\n    while ((getline(&line, &len, fp)) != -1)\n    {\n        counter++;\n        er = _itoa(counter);\n        PRINTER(er);\n        free(er);\n        PRINTER(\" \");\n        PRINTER(line);\n\n    }\n    if (line)\n        free(line);\n    fclose(fp);\n    return (0);\n}\n\nint print_echo(char **cmd)\n{\n    pid_t pid;\n    int status;\n\n    pid = fork();\n    if (pid == 0)\n    {\n    if (execve(\"\/bin\/echo\", cmd, environ) == -1)\n    {\n        return (-1);\n    }\n        exit(EXIT_FAILURE);\n    }\n    else if (pid < 0)\n    {\n        return (-1);\n    }\n    else\n    {\n        do {\n            waitpid(pid, &status, WUNTRACED);\n        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n    }\n    return (1);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\nint _strcmp(char *s1, char *s2)\n{\nint cmp = 0, i, len1, len2;\nlen1 = _strlen(s1);\nlen2 = _strlen(s2);\n\n    if (s1 == NULL || s2 == NULL)\n        return (1);\n    if (len1 != len2)\n        return (1);\n    for (i = 0; s1[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            cmp = s1[i] - s2[i];\n            break;\n        }\n        else\n            continue;\n    }\n    return (cmp);\n}\n\nint _isalpha(int c)\n{\nif (((c >= 97) && (c <= 122)) || ((c >= 65) && (c <= 90)))\n{\nreturn (1);\n}\nelse\n{\nreturn (0);\n}\n}\n\nchar *_itoa(unsigned int n)\n{\n    int len = 0, i = 0;\n    char *s;\n\n    len = intlen(n);\n    s = malloc(len + 1);\n    if (!s)\n        return (NULL);\n    *s = '\\0';\n    while (n \/ 10)\n    {\n        s[i] = (n % 10) + '0';\n        n \/= 10;\n        i++;\n    }\n    s[i] = (n % 10) + '0';\n    array_rev(s, len);\n    s[i + 1] = '\\0';\n    return (s);\n}\n\nvoid array_rev(char *arr, int len)\n{\n    int i;\n    char tmp;\n\n    for (i = 0; i < (len \/ 2); i++)\n    {\n        tmp = arr[i];\n        arr[i] = arr[(len - 1) - i];\n        arr[(len - 1) - i] = tmp;\n    }\n}\n\nint intlen(int num)\n{\n    int len = 0;\n\n    while (num != 0)\n    {\n        len++;\n        num \/= 10;\n    }\n    return (len);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\nchar *_strcpy(char *dest, char *src)\n{\nint i;\n\ni = 0;\n    while (src[i])\n    {\n        dest[i] = src[i];\n        i++;\n    }\ndest[i] = '\\0';\nreturn (dest);\n}\n\nchar *_strcat(char *dest, char *src)\n{\n    char *s = dest;\n\n    while (*dest != '\\0')\n    {\n        dest++;\n    }\n\n    while (*src != '\\0')\n    {\n        *dest = *src;\n        dest++;\n        src++;\n    }\n    *dest = '\\0';\n    return (s);\n}\n\nchar *_strchr(char *s, char c)\n{\n\n    do      {\n\n        if (*s == c)\n            {\n            break;\n            }\n        }   while (*s++);\n\nreturn (s);\n}\n\nint _strncmp(const char *s1, const char *s2, size_t n)\n{\n    size_t i;\n\n    if (s1 == NULL)\n        return (-1);\n    for (i = 0; i < n && s2[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            return (1);\n        }\n    }\n    return (0);\n}\n\nchar *_strdup(char *str)\n{\n    size_t len, i;\n    char *str2;\n\n    len = _strlen(str);\n    str2 = malloc(sizeof(char) * (len + 1));\n    if (!str2)\n    {\n        return (NULL);\n    }\n\n    for (i = 0; i <= len; i++)\n    {\n        str2[i] = str[i];\n    }\n\n    return (str2);\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\n\n\nint main(__attribute__((unused)) int argc, char **argv)\n{\n    char *input, **cmd;\n    int counter = 0, statue = 1, st = 0;\n\n    if (argv[1] != NULL)\n        read_file(argv[1], argv);\n    signal(SIGINT, signal_to_handel);\n    while (statue)\n    {\n        counter++;\n        if (isatty(STDIN_FILENO))\n            prompt();\n        input = _getline();\n        if (input[0] == '\\0')\n        {\n            continue;\n        }\n        history(input);\n        cmd = parse_cmd(input);\n        if (_strcmp(cmd[0], \"exit\") == 0)\n        {\n            exit_bul(cmd, input, argv, counter);\n        }\n        else if (check_builtin(cmd) == 0)\n        {\n            st = handle_builtin(cmd, st);\n            free_all(cmd, input);\n            continue;\n        }\n        else\n        {\n            st = check_cmd(cmd, input, counter, argv);\n\n        }\n        free_all(cmd, input);\n    }\n    return (statue);\n}\n\nint check_builtin(char **cmd)\n{\n    bul_t fun[] = {\n        {\"cd\", NULL},\n        {\"help\", NULL},\n        {\"echo\", NULL},\n        {\"history\", NULL},\n        {NULL, NULL}\n    };\n    int i = 0;\n        if (*cmd == NULL)\n    {\n        return (-1);\n    }\n\n    while ((fun + i)->command)\n    {\n        if (_strcmp(cmd[0], (fun + i)->command) == 0)\n            return (0);\n        i++;\n    }\n    return (-1);\n}\n\nvoid creat_envi(char **envi)\n{\n    int i;\n\n    for (i = 0; environ[i]; i++)\n        envi[i] = _strdup(environ[i]);\n    envi[i] = NULL;\n}\n"}
{"target":"Theemiss","func":"#include \"shell.h\"\n\nunsigned int check_delim(char c, const char *str)\n{\n    unsigned int i;\n\n    for (i = 0; str[i] != '\\0'; i++)\n    {\n        if (c == str[i])\n            return (1);\n    }\n    return (0);\n}\n\n\nchar *_strtok(char *str, const char *delim)\n{\n    static char *ts;\n    static char *nt;\n    unsigned int i;\n\n    if (str != NULL)\n        nt = str;\n    ts = nt;\n    if (ts == NULL)\n        return (NULL);\n    for (i = 0; ts[i] != '\\0'; i++)\n    {\n        if (check_delim(ts[i], delim) == 0)\n            break;\n    }\n    if (nt[i] == '\\0' || nt[i] == '#')\n    {\n        nt = NULL;\n        return (NULL);\n    }\n    ts = nt + i;\n    nt = ts;\n    for (i = 0; nt[i] != '\\0'; i++)\n    {\n        if (check_delim(nt[i], delim) == 1)\n            break;\n    }\n    if (nt[i] == '\\0')\n        nt = NULL;\n    else\n    {\n        nt[i] = '\\0';\n        nt = nt + i + 1;\n        if (*nt == '\\0')\n            nt = NULL;\n    }\n    return (ts);\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint data[9][3] = {\n   {22, 8, 165},\n   {8, 17, 114},\n   {18 , 6 , 103},\n   {25 , 6 , 145},\n   {11 , 12 , 125},\n   {21 , 6 , 121},\n   {18 , 3 , 50},\n   {20 , 4 , 75},\n   {7 , 20 , 119}\n};\n\nint temp[9][3] = {0};\nint distances[9] = {0}, points[9] = {0};\nint longest_distance, time_flown, time_rested;\n\n#define TOTAL_TIME 2503\n\nint main(){\n   \n   memcpy(temp, data, sizeof(data));\n\n   for(int time = 0; time < TOTAL_TIME; time++){\n      \n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(temp[reindeer][1] > 0){\n            distances[reindeer] += data[reindeer][0];\n            temp[reindeer][1]--;\n         }\n         else if(temp[reindeer][1] == 0){\n            temp[reindeer][2]--;\n            if(temp[reindeer][2] == 0){\n               temp[reindeer][1] = data[reindeer][1];\n               temp[reindeer][2] = data[reindeer][2];\n            }\n         }\n      }\n\n      \n      longest_distance = 0;\n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(distances[reindeer] > longest_distance){\n            longest_distance = distances[reindeer];\n         }\n      }\n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(distances[reindeer] == longest_distance){\n            points[reindeer]++;\n         }\n      }\n   }\n\n   \n   int most_points = 0;\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      if(points[reindeer] > most_points){\n         most_points = points[reindeer];\n      }\n   }\n\n   printf(\"winner=%d\\n\", most_points);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX(x, y) (((x) > (y)) ? (x) : (y))\n\nint properties[4][5];\nint line_count = 0, property_count = 0;\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   \n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      for(int char_count = 0; char_count < len; char_count++){\n         char c = data_read[char_count];\n\n         if(c == '-'){\n            properties[line_count][property_count] = (data_read[char_count + 1] - '0') * -1;\n            property_count++;\n            char_count++;\n         }\n         else if(isdigit(c) != 0){\n            properties[line_count][property_count] = data_read[char_count] - '0';\n            property_count++;\n         }\n      }\n\n      line_count++;\n      property_count = 0;\n   }\n\n   \n   for(int i = 0; i < 4; i++){\n      for(int j = 0; j < 5; j++){\n         printf(\"%d \", properties[i][j]);\n      }\n      printf(\"\\n\");\n   }\n\n   \n   int properties_data[5];\n   int score = 1, max_score = 0;\n   for(int a = 0; a <= 100; a++){\n      for(int b = 0; b <= 100; b++){\n         for(int c = 0; c <= 100; c++){\n            int d = 100 - a - b - c;\n\n            for(int i = 0; i < 5; i++){\n               properties_data[i] = a * properties[0][i] + b * properties[1][i] + c * properties[2][i] + d * properties[3][i];\n               properties_data[i] = MAX(properties_data[i], 0);\n\n               if(i < 4){ \n                  score = score * properties_data[i];\n               }\n            }\n\n            if((properties_data[4] <= 500) && (score > max_score)){\n               max_score = score;\n            }\n            score = 1;\n         }\n      }\n   }\n\n   printf(\"max score = %d\\n\", max_score);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdbool.h>\n\n#define NR_OF_SUES 500\n\nint main(void){\n    \n    \n    \n    int sues[NR_OF_SUES][10];\n    int analysis[10] = {3, 7, 2, 3, 0, 0, 5, 3, 2, 1};\n    int sue_nr = 0;\n    int index = 0, amount = 0;\n    bool found_her = true;\n\n\n    \n    for(int i = 0; i < NR_OF_SUES; i++){\n        for(int j = 0; j < 10; j++){\n            sues[i][j] = 999;\n        }\n    }\n\n    \n    FILE * fp_data;\n    fp_data = fopen(\"data\", \"r\");\n    char * data_read = NULL, * token = NULL, * dummy = NULL;\n    size_t len = 0;\n    ssize_t read;\n\n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        char * data_dummy = data_read;\n\n        \n        token = strtok(data_dummy, \":\");\n        data_dummy = strtok(NULL, \"\");\n\n        \n        token = strtok(data_dummy, \",\");\n        while(token != NULL){\n            \n            if(strstr(token, \"children\") != NULL){\n                index = 0;\n            }\n            else if(strstr(token, \"cats\") != NULL){\n                index = 1;\n            }\n            else if(strstr(token, \"samoyeds\") != NULL){\n                index = 2;\n            }           \n            else if(strstr(token, \"pomeranians\") != NULL){\n                index = 3;\n            }\n            else if(strstr(token, \"akitas\") != NULL){\n                index = 4;\n            }\n            else if(strstr(token, \"vizslas\") != NULL){\n                index = 5;\n            }\n            else if(strstr(token, \"goldfish\") != NULL){\n                index = 6;\n            }\n            else if(strstr(token, \"trees\") != NULL){\n                index = 7;\n            }\n            else if(strstr(token, \"cars\") != NULL){\n                index = 8;\n            }\n            else if(strstr(token, \"perfumes\") != NULL){\n                index = 9;\n            }\n\n            \n            dummy = token;\n            while (*dummy){\n                if(isdigit(*dummy)){\n                    amount = (int) strtol(dummy, &dummy, 10);\n                }\n                else{\n                    dummy++;\n                }\n            }\n\n            \n            sues[sue_nr][index] = amount;\n            \n            \n            token = strtok(NULL, \",\");\n        }\n\n        sue_nr++;\n    }\n\n    \n    for(int i = 0; i < NR_OF_SUES; i++){\n        for(int j = 0; j < 10; j++){\n            if(sues[i][j] != 999){\n                switch (j){\n                    case 1: case 7:\n                        \n                        if(sues[i][j] <= analysis[j]) found_her = false;\n                        break;\n\n                    case 3: case 6:\n                        \n                        if(sues[i][j] >= analysis[j])   found_her = false;\n                        break;\n\n                    default:\n                        if(sues[i][j] != analysis[j])   found_her = false;\n                }\n            }\n        }\n\n        if(found_her){\n            printf(\"answer=%d\\n\", i + 1);\n            break;\n        }\n        else{\n            found_her = true;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define NR_ELEMENTS 20\n#define LITERS_TO_STORE 150\n\nint main(void){\n    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};\n    int multiplier[NR_ELEMENTS] = {0};\n    int nr_jars_needed[10] = {0};\n    int result = 0, nr_jars = 0;\n\n    \n    \n    \n    \n    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){\n        for(int j = 0; j < NR_ELEMENTS; j++){\n            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;\n        }\n\n        \n        \n        for(int k = 0; k < NR_ELEMENTS; k++){\n            result += input[k] * multiplier[k];\n            if(multiplier[k] == 1){\n                nr_jars++;\n            }\n        }\n\n        \n        \n        if(result == LITERS_TO_STORE){\n            nr_jars_needed[nr_jars]++;\n        }\n\n        result = 0;\n        nr_jars = 0;\n    }\n\n    \n    for(int i = 0; i < 10; i++){\n        if(nr_jars_needed[i] > 0){\n            printf(\"answer=%d\\n\", nr_jars_needed[i]);\n            break;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define SIZE_GRID 100\n#define NR_OF_TIMES 100\n\n\nbool lights[SIZE_GRID + 2][SIZE_GRID + 2] = {false};\nbool dummy[SIZE_GRID + 2][SIZE_GRID + 2] = {false};\n\nint main(void){\n    \n    FILE * fp_data;\n    fp_data = fopen(\"data\", \"r\");\n    char * data_read = NULL;\n    size_t len = 0;\n    ssize_t read;\n    int x_coord = 1, y_coord = 1;\n    int nr_neighbours = 0, nr_lights_on = 0;\n\n    \n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        while(y_coord < SIZE_GRID + 1){\n            if(data_read[y_coord - 1] == '#'){\n                lights[x_coord][y_coord] = true;\n            }\n            else{\n                lights[x_coord][y_coord] = false;\n            }\n            y_coord++;\n        }\n        y_coord = 1;\n        x_coord++;\n    }\n\n    \n    lights[1][1] = true;\n    lights[1][SIZE_GRID] = true;\n    lights[SIZE_GRID][1] = true;\n    lights[SIZE_GRID][SIZE_GRID] = true;\n\n    \n    for(int times = 0; times < NR_OF_TIMES; times++){\n        \n        for(int i = 1; i < SIZE_GRID + 1; i++){\n            for(int j = 1; j < SIZE_GRID + 1; j++){\n                dummy[i][j] = lights[i][j];\n            }\n        }\n\n        for(int i = 1; i < SIZE_GRID + 1; i++){\n            for(int j = 1; j < SIZE_GRID + 1; j++){\n                \n                for(int k = -1; k < 2; k++){\n                    for(int l = -1; l < 2; l++){\n                        if(dummy[i + k][j + l]){\n                            nr_neighbours++;\n                        }\n                    }\n                }\n                \n                if(dummy[i][j]) nr_neighbours--;\n\n                if(dummy[i][j]){\n                    \n                    if((nr_neighbours != 2) && (nr_neighbours != 3)){\n                        lights[i][j] = false;\n                    }\n                }\n                else{\n                    \n                    if(nr_neighbours == 3){\n                        lights[i][j] = true;\n                    }\n                }\n\n                \n                lights[1][1] = true;\n                lights[1][SIZE_GRID] = true;\n                lights[SIZE_GRID][1] = true;\n                lights[SIZE_GRID][SIZE_GRID] = true;\n\n                nr_neighbours = 0;\n            }\n        }\n    }\n\n    for(int i = 1; i < SIZE_GRID + 1; i++){\n        for(int j = 1; j < SIZE_GRID + 1; j++){\n            if(lights[i][j]) nr_lights_on++;\n        }\n    }\n\n    printf(\"answer=%d\\n\", nr_lights_on);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n    long house_nr = 0, nr_presents = 0;\n\n    while(1){\n        \n        for(long i = 1; i <= house_nr; i++){\n            \n            if((house_nr%i == 0) && (house_nr \/ i < 50)){   \n                    \n                    nr_presents += i * 11;\n            }\n        }\n\n        \n        if(nr_presents >= 33100000){\n            printf(\"answer=%ld\\n\", house_nr);\n            break;\n        }\n\n        if(house_nr%10000 == 0)\n            printf(\"%ld - %ld\\n\", house_nr, nr_presents);\n        house_nr++;\n        nr_presents = 0;\n    }\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nint main(void){\n    char input[8] = \"hepxcrrq\";\n    bool incr_straight = false, banned_letter = false;\n    int amount_sequence = 0;\n    char first_pair[1];\n\n    printf(\"%s\\n\", input);\n\n    while(1){\n        \n        for(int i = 0; i < 5; i++){\n            if((input[i] + 1 == input[i + 1]) && (input[i + 1] + 1 == input[i + 2])){\n                incr_straight = true;\n                break;\n            }\n        }\n\n        \n        if((strstr(input, \"i\") != NULL) || (strstr(input, \"o\") != NULL) ||\n            (strstr(input, \"l\") != NULL)){\n            banned_letter = true;\n        }\n\n        \n        for(int i = 0; i < 7; i++){\n            if(input[i] == input[i + 1]){\n                if(amount_sequence == 0){\n                    amount_sequence++;\n                    first_pair[0] = input[i];\n                }\n\n                else if(input[i] != first_pair[0]){\n                    amount_sequence++;\n                }\n            }\n        }\n\n        \n        if(incr_straight && !banned_letter && (amount_sequence > 1)){\n            break;\n        }\n\n        \n        input[7]++;\n        for(int i = 7; i > 0; i--){\n            if(input[i] == '{'){\n                input[i] = 'a';\n                input[i - 1]++;\n            }\n            else{\n                break;\n            }\n        }\n\n        \n        incr_straight = false;\n        banned_letter = false;\n        amount_sequence = 0;\n    }\n\n    printf(\"%s\\n\", input);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint data[9][3] = {\n   {22, 8, 165},\n   {8, 17, 114},\n   {18 , 6 , 103},\n   {25 , 6 , 145},\n   {11 , 12 , 125},\n   {21 , 6 , 121},\n   {18 , 3 , 50},\n   {20 , 4 , 75},\n   {7 , 20 , 119}\n};\n\nint distances[9] = {0};\n\n#define TOTAL_TIME 2503\n\nint distance, time_flown, time_rested;\n\nint main(){\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      distance = 0;\n      time_flown = data[reindeer][1];\n      time_rested = 0;\n\n      for(int time = 0; time < TOTAL_TIME; time++){\n         if(time_flown > 0){\n            distance += data[reindeer][0];\n            time_flown--;\n         }\n\n         else if(time_flown == 0){\n            time_rested++;\n            if(time_rested == data[reindeer][2]){\n               time_flown = data[reindeer][1];\n               time_rested = 0;\n            }\n         }\n      }\n      distances[reindeer] = distance;\n   }\n\n   distance = 0;\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      if(distances[reindeer] > distance){\n         distance = distances[reindeer];\n      }\n   }\n\n   printf(\"winner=%d\\n\", distance);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdbool.h>\n\n#define NR_OF_SUES 500\n\nint main(void){\n    \n    \n    \n    int sues[NR_OF_SUES][10];\n    int analysis[10] = {3, 7, 2, 3, 0, 0, 5, 3, 2, 1};\n    int sue_nr = 0;\n    int index = 0, amount = 0;\n    bool found_her = true;\n\n\n    \n    for(int i = 0; i < NR_OF_SUES; i++){\n        for(int j = 0; j < 10; j++){\n            sues[i][j] = 999;\n        }\n    }\n\n    \n    FILE * fp_data;\n    fp_data = fopen(\"data\", \"r\");\n    char * data_read = NULL, * token = NULL, * dummy = NULL;\n    size_t len = 0;\n    ssize_t read;\n\n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        char * data_dummy = data_read;\n\n        \n        token = strtok(data_dummy, \":\");\n        data_dummy = strtok(NULL, \"\");\n\n        \n        token = strtok(data_dummy, \",\");\n        while(token != NULL){\n            \n            if(strstr(token, \"children\") != NULL){\n                index = 0;\n            }\n            else if(strstr(token, \"cats\") != NULL){\n                index = 1;\n            }\n            else if(strstr(token, \"samoyeds\") != NULL){\n                index = 2;\n            }           \n            else if(strstr(token, \"pomeranians\") != NULL){\n                index = 3;\n            }\n            else if(strstr(token, \"akitas\") != NULL){\n                index = 4;\n            }\n            else if(strstr(token, \"vizslas\") != NULL){\n                index = 5;\n            }\n            else if(strstr(token, \"goldfish\") != NULL){\n                index = 6;\n            }\n            else if(strstr(token, \"trees\") != NULL){\n                index = 7;\n            }\n            else if(strstr(token, \"cars\") != NULL){\n                index = 8;\n            }\n            else if(strstr(token, \"perfumes\") != NULL){\n                index = 9;\n            }\n\n            \n            dummy = token;\n            while (*dummy){\n                if(isdigit(*dummy)){\n                    amount = (int) strtol(dummy, &dummy, 10);\n                }\n                else{\n                    dummy++;\n                }\n            }\n\n            \n            sues[sue_nr][index] = amount;\n            \n            \n            token = strtok(NULL, \",\");\n        }\n\n        sue_nr++;\n    }\n\n    \n    for(int i = 0; i < NR_OF_SUES; i++){\n        for(int j = 0; j < 10; j++){\n            if((sues[i][j] != 999) && (sues[i][j] != analysis[j])){\n                    found_her = false;\n            }\n        }\n\n        if(found_her){\n            printf(\"answer=%d\\n\", i + 1);\n            break;\n        }\n        else{\n            found_her = true;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define NR_ELEMENTS 20\n#define LITERS_TO_STORE 150\n\nint main(void){\n    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};\n    int multiplier[NR_ELEMENTS] = {0};\n    int nr_combinations = 0, result = 0;\n\n    \n    \n    \n    \n    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){\n        for(int j = 0; j < NR_ELEMENTS; j++){\n            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;\n        }\n\n        \n        for(int k = 0; k < NR_ELEMENTS; k++){\n            result += input[k] * multiplier[k];\n        }\n\n        \n        if(result == LITERS_TO_STORE){\n            nr_combinations++;\n        }\n\n        result = 0;\n    }\n\n    printf(\"answer=%d\\n\", nr_combinations);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define SIZE_GRID 100\n#define NR_OF_TIMES 100\n\n\nbool lights[SIZE_GRID + 2][SIZE_GRID + 2] = {false};\nbool dummy[SIZE_GRID + 2][SIZE_GRID + 2] = {false};\n\nint main(void){\n    \n    FILE * fp_data;\n    fp_data = fopen(\"data\", \"r\");\n    char * data_read = NULL;\n    size_t len = 0;\n    ssize_t read;\n    int x_coord = 1, y_coord = 1;\n    int nr_neighbours = 0, nr_lights_on = 0;\n\n    \n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        while(y_coord < SIZE_GRID + 1){\n            if(data_read[y_coord - 1] == '#'){\n                lights[x_coord][y_coord] = true;\n            }\n            else{\n                lights[x_coord][y_coord] = false;\n            }\n            y_coord++;\n        }\n        y_coord = 1;\n        x_coord++;\n    }\n\n    \n    for(int times = 0; times < NR_OF_TIMES; times++){\n        \n        for(int i = 1; i < SIZE_GRID + 1; i++){\n            for(int j = 1; j < SIZE_GRID + 1; j++){\n                dummy[i][j] = lights[i][j];\n            }\n        }\n\n        for(int i = 1; i < SIZE_GRID + 1; i++){\n            for(int j = 1; j < SIZE_GRID + 1; j++){\n                \n                for(int k = -1; k < 2; k++){\n                    for(int l = -1; l < 2; l++){\n                        if(dummy[i + k][j + l]){\n                            nr_neighbours++;\n                        }\n                    }\n                }\n                \n                if(dummy[i][j]) nr_neighbours--;\n\n                if(dummy[i][j]){\n                    \n                    if((nr_neighbours != 2) && (nr_neighbours != 3)){\n                        lights[i][j] = false;\n                    }\n                }\n                else{\n                    \n                    if(nr_neighbours == 3){\n                        lights[i][j] = true;\n                    }\n                }\n\n                nr_neighbours = 0;\n            }\n        }\n    }\n\n    for(int i = 1; i < SIZE_GRID + 1; i++){\n        for(int j = 1; j < SIZE_GRID + 1; j++){\n            if(lights[i][j]) nr_lights_on++;\n        }\n    }\n\n    printf(\"answer=%d\\n\", nr_lights_on);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n    long house_nr = 0, nr_presents = 0;\n\n    while(1){\n        \n        for(long i = 1; i <= house_nr; i++){\n            if(house_nr%i == 0){\n                \n                nr_presents += i * 10;\n            }\n        }\n\n        \n        if(nr_presents >= 33100000){\n            printf(\"answer=%ld\\n\", house_nr);\n            break;\n        }\n\n        if(house_nr%10000 == 0)\n            printf(\"%ld - %ld\\n\", house_nr, nr_presents);\n        house_nr++;\n        nr_presents = 0;\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar str[] = \"R4,R1,L2,R1,L1,L1,R1,L5,R1,R5,L2,R3,L3,L4,R4,R4,R3,L5,L1,R5,R3,L4,R1,R5,L1,R3,L2,R3,R1,L4,L1,R1,L1,L5,R1,L2,R2,L3,L5,R1,R5,L1,R188,L3,R2,R52,R5,L3,R79,L1,R5,R186,R2,R1,L3,L5,L2,R2,R4,R5,R5,L5,L4,R5,R3,L4,R4,L4,L4,R5,L4,L3,L1,L4,R1,R2,L5,R3,L4,R3,L3,L5,R1,R1,L3,R2,R1,R2,R2,L4,R5,R1,R3,R2,L2,L2,L1,R2,L1,L3,R5,R1,R4,R5,R2,R2,R4,R4,R1,L3,R4,L2,R2,R1,R3,L5,R5,R2,R5,L1,R2,R4,L1,R5,L3,L3,R1,L4,R2,L2,R1,L1,R4,R3,L2,L3,R3,L2,R1,L4,R5,L1,R5,L2,L1,L5,L2,L5,L2,L4,L2,R3\";\n\nenum e_coord {NORTH, EAST, SOUTH, WEST};\n\nenum e_coord coord_next = NORTH;\nenum e_coord coord_prev = NORTH;\n\nint current_char = 0, current_step = 0, dummy_step = 0;\nchar c;\nsigned int x = 0, y = 0;\n\n\nint main() {\n   while (str[current_char] != '\\0') {\n      c = str[current_char];\n\n      if(c != ',') {\n         if(c == 'R'){\n            (coord_prev == WEST) ? coord_next = NORTH : coord_next++;\n         }\n\n         else if(c == 'L') {\n            (coord_prev == NORTH) ? coord_next = WEST : coord_next--;\n         }\n\n         else {\n            current_step = c - '0';\n            dummy_step = dummy_step * 10 + current_step;\n\n            if( (str[current_char + 1] == ',') || (str[current_char + 1] == '\\0') ) {\n               if(dummy_step != 0){\n                  current_step = dummy_step;\n                  dummy_step = 0;\n               }\n\n               coord_prev = coord_next;\n\n               switch(coord_next){\n                  case NORTH :\n                     y += current_step;\n                     break;\n                  case EAST :\n                     x += current_step;\n                     break;\n                  case SOUTH :\n                     y -= current_step;\n                     break;\n                  case WEST :\n                     x -= current_step;\n                     break;\n                  }\n            }\n         }\n      }\n      current_char++;\n   }\n\n   printf(\"done! (x=%d, y=%d => total=%d)\\n\", x, y, abs(x) + abs(y));\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <string.h>\n\nint main() {\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char c;\n   int x = 1, y = 1;\n\n   int answer_key[3][3] = {\n      {1, 2, 3},\n      {4, 5, 6},\n      {7, 8, 9}\n   };\n\n   for(int lines = 0; lines < 5; lines++){\n      while ((c = getc(fp_data)) != ('\\n') && c != EOF) {\n         switch(c){\n            case 'R' :\n               if(y < 2) {\n                  y++;\n               }\n               break;\n            case 'L' :\n               if(y > 0) {\n                  y--;\n               }\n               break;\n            case 'U' :\n               if(x > 0) {\n                  x--;\n               }\n               break;\n            case 'D' :\n               if(x < 2) {\n                  x++;\n               }\n               break;\n         }\n      }\n      printf(\"%d\", answer_key[x][y]);\n   }\n\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NR_DISCS 6\n\nint input[NR_DISCS][3] = {\n   { 5, 0,  2}, \n   {13, 0,  7},\n   {17, 0, 10},\n   { 3, 0,  2},\n   {19, 0,  9},\n   { 7, 0,  0}\n};\n\nbool not_zero = false;\nint time = 1;\n\nint main(){\n   \n   for(int i = 0; i < NR_DISCS; i++){\n      for(int j = 0; j < i + 1; j++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n   }\n\n   \n   while(1){\n      for(int i = 0; i < NR_DISCS; i++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n            not_zero = true;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n\n      \n      if(!not_zero){\n         printf(\"answer=%d\\n\", time);\n         break;\n      }\n      else{\n         not_zero = false;\n      }\n      time++;\n   }\n\n   return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DATA_TO_FILL 272\n\nchar input[60000000] = \"11110010111001001\";\nchar dummy[60000000], checksum[60000000];\n\n\nint main(void){\n    \n    while(strlen(input) < DATA_TO_FILL){\n        int len = strlen(input);\n\n        \n        input[len - 1] = '0';\n\n        \n        for(int i = len, j = len; i >= 0; i--, j++){\n            if(input[i] == '0'){\n                input[j] = '1';\n            }\n            else{\n                input[j] = '0';\n            }\n\n        }\n    }\n\n    \n    input[DATA_TO_FILL] = '\\0';\n    strcpy(checksum, input);\n    \n    \n    while((strlen(checksum))%2 == 0){\n        memset(dummy, 0, sizeof(dummy));\n\n        int len = strlen(checksum);\n        for(int i = 0, j = 0; i < len; i += 2, j++){\n            if(checksum[i] == checksum[i + 1]){\n                dummy[j] = '1';\n            }\n            else{\n                dummy[j] = '0';\n            }\n        }\n        strcpy(checksum, dummy);\n    }\n\n    printf(\"checksum=%s (len=%ld)\\n\", checksum, strlen(checksum));\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <time.h>\n\n#define NR_ROWS 400000 \n#define NR_COLS 100\n\nchar input[] = \"^^.^..^.....^..^..^^...^^.^....^^^.^.^^....^.^^^...^^^^.^^^^.^..^^^^.^^.^.^.^.^.^^...^^..^^^..^.^^^^\";\nbool traps[NR_ROWS][NR_COLS] = {false};\nbool left, center, right;\nint nr_safe = 0;\n\n\nint main(){\n   clock_t start = clock(), diff;\n\n   for(int i = 0; i < strlen(input); i++){\n      if(input[i] == '^'){\n         traps[0][i] = true;\n      }\n      else{\n         nr_safe++;\n      }\n   }\n\n   for(int row = 1; row < NR_ROWS; row++){\n      for(int col = 0; col < NR_COLS; col++){\n         if(col == 0){\n            left = false;\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         else if(col == NR_COLS - 1){\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = false;\n         }\n         else{\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n\n         if((left && center && !right) || (!left && center && right) ||\n               (!left && !center && right) || (left && !center && !right)){\n            traps[row][col] = true;\n         }\n         else{\n            traps[row][col] = false;\n            nr_safe++;\n         }\n      }\n   }\n\n   diff = clock() - start;\n   int msec = diff * 1000 \/ CLOCKS_PER_SEC;\n\n   printf(\"answer=%d\\n\", nr_safe);\n   printf(\"time: %ds %dms\", msec\/1000, msec%1000);\n\n   return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <string.h>\n\nint main() {\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char c;\n   int x = 2, y = 2;\n\n   char answer_key[5][5] = {\n      {'0', '0', '1', '0', '0'},\n      {'0', '2', '3', '4', '0'},\n      {'5', '6', '7', '8', '9'},\n      {'0', 'A', 'B', 'C', '0'},\n      {'0', '0', 'D', '0', '0'}\n   };\n\n   for(int lines = 0; lines < 5; lines++){\n      while ((c = getc(fp_data)) != ('\\n') && c != EOF) {\n         switch(c){\n            case 'R' :\n               if(y < 4) {\n                  if(answer_key[x][y + 1] != '0'){\n                     y++;\n                  }\n               }\n               break;\n            case 'L' :\n               if(y > 0) {\n                  if(answer_key[x][y - 1] != '0'){\n                     y--;\n                  }\n               }\n               break;\n\n            case 'U' :\n               if(x > 0) {\n                  if(answer_key[x - 1][y] != '0'){\n                     x--;\n                  }\n               }\n               break;\n            case 'D' :\n               if(x < 4) {\n                  if(answer_key[x + 1][y] != '0'){\n                     x++;\n                  }\n               }\n               break;\n         }\n      }\n\n      printf(\"%c\", answer_key[x][y]);\n   }\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdbool.h>\n\nchar line_nodash[100];\nlong char_counter = 0;\nchar c = 'a';\nint line_counter = 0, sector_ID = 0, processed = 0;\n\nint main() {\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t size = 0;\n\n   fseek(fp_data, 0, SEEK_END);\n   size = ftell(fp_data);\n   rewind(fp_data);\n   data_read = malloc((size + 1) * sizeof(* data_read));\n\n   fread(data_read, size, 1, fp_data);\n   data_read[size] = '\\0';\n\n\n   while(1){\n      c = data_read[char_counter];\n      if(c == '\\0'){\n         printf(\"WORD NOT FOUND (processed=%d)\\n\", processed);\n         return 0;\n      }\n\n      while(c != '\\n'){\n         if(c == '['){\n            char_counter++; size = 0;\n         }\n\n         else{\n            if(isalpha(c)){ \n               line_nodash[line_counter] = c;\n               line_counter++;\n            }\n            if(isdigit(c)){\n               sector_ID = sector_ID * 10 + (c - '0');\n            }\n            char_counter++;\n         }\n\n         c = data_read[char_counter];\n      }\n\n      line_nodash[line_counter] = '\\0';\n      line_counter = 0;\n      char_counter++;\n\n      #ifdef DEBUG\n         printf(\"line=%s\\tbrackets=%s\\tID=%d\\n\", line_nodash, line_brackets, sector_ID);\n      #endif\n\n      int key = sector_ID;\n\n      if(key > 26){\n         key %= 26;\n      }\n      for(int j = 0; j < strlen(line_nodash); j++) {\n         int char_val = line_nodash[j] - 'a';\n\n         if( (char_val + key) > 25){\n            int keytemp = key - (26 - char_val);\n            line_nodash[j] = keytemp + 'a';\n         }\n         else {\n            line_nodash[j] += key;\n         }\n\n      }\n\n      printf(\"output=%s\\n\", line_nodash);\n      if(strstr(line_nodash, \"north\") != NULL){\n         printf(\"ID=%d (processed=%d)\\n\", sector_ID, processed);\n         return 0;\n      }\n\n      sector_ID = 0;\n      processed++;\n   }\n\n   return 0;\n}\n"}
{"target":"theuwis","func":"#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <time.h>\n#include \"md5.c\"\n\nint main(){\n   char * msg = \"abbhdwsy\", * dummy = NULL;\n   char code[9] = \"--------\\0\"; int code_counter = 0;\n   bool done[8] = {false};\n\n   long index = 0;\n   size_t len = 0;\n   uint8_t * md5_result;\n\n   clock_t start = clock(), diff;\n   while(1){\n      asprintf(&dummy,\"%s%ld\" , msg, index);\n      len = strlen(dummy);\n      md5(dummy, len);\n\n      md5_result = (uint8_t *) &h0;\n\n      char str[10];\n      sprintf(str, \"%2.2X%2.2X%2.2X%2.2X\", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);\n\n      if(strncmp(str, \"00000\", 5) == 0){\n         printf(\"hash found - input=%s - MD5=%s - index=%ld\\n\", dummy, str, index);\n         int index = str[5] - '0';\n\n         if(code_counter >= 8){\n            printf(\"done! code=%s\\n\", code);\n            diff = clock() - start;\n            int msec = diff * 1000 \/ CLOCKS_PER_SEC;\n            printf(\"time: %ds %dms\", msec\/1000, msec%1000);\n            break;\n         }\n         else{\n            if( (index < 8) && (done[index] == false) ){\n               code[index] = str[6];\n               done[index] = true;\n               code_counter++;\n               printf(\"current code = %s\\n\\n\", code);\n            }\n         }\n      }\n      index++;\n   }\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint data_array[8][26] = {0};\nchar output[8];\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      for(int i = 0; i < 8; i++){\n         data_array[i][(int)(data_read[i] - 'a')]++;\n      }\n   }\n\n   int min = 100;\n   for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 26; j++){\n         if((data_array[i][j] < min) && (data_array[i][j] != 0)){\n            output[i] = j + 'a';\n            min = data_array[i][j];\n         }\n\n      }\n      min = 100;\n   }\n\n   printf(\"answer=%s\\n\", output);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nchar string[4];\nbool in_brackets = false;\nint ip_counter = 0;\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      char ABA[300] = \"\";\n      char BAB[300] = \"\";\n\n      for(int current_char = 0; current_char < (strlen(data_read) - 4); current_char++){\n         for(int i = 0; i < 3; i++){\n            string[i] = data_read[current_char + i];\n         }\n   \n\n         if(strstr(string, \"[\") != NULL){\n            in_brackets = true;\n         }\n         else if(strstr(string, \"]\") != NULL){\n            in_brackets = false;\n         }\n         else{\n            if((string[0] == string[2]) && (string[0] != string[1])){\n               if(in_brackets) strcat(BAB, string);\n               else strcat(ABA, string);\n            }\n         }\n      }\n\n      char ABA_temp[4]; char BAB_temp[4];\n      int ABA_loop = strlen(ABA) \/ 3;\n      bool not_added = false;\n\n      while(ABA_loop-- > 0){\n         memcpy(ABA_temp, ABA + (ABA_loop * 3), 3); ABA_temp[3] = '\\0';\n\n         int BAB_loop = strlen(BAB) \/ 3;\n         while(BAB_loop-- > 0){\n            memcpy(BAB_temp, BAB + (BAB_loop * 3), 3); BAB_temp[3] = '\\0';\n\n            if((ABA_temp[0] == BAB_temp[1]) && (ABA_temp[1] == BAB_temp[0])){\n               if(!not_added){\n                  ip_counter++;\n                  not_added = true;\n               }\n            }\n         }\n      }\n      in_brackets = false;\n   }\n\n   printf(\"answer=%d\\n\", ip_counter);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\nchar input[1000000] = \"(172x1)(3x7)XPJ(70x4)(40x7)WKQANMDILIQOOWQZDNGORPHFNHBKKKVQEJNUVNAQ(3x2)VFV(10x1)XUNNCAFYMV(9x13)OUIKISEPR(66x13)(10x6)JHDDURBDQC(3x11)SNT(2x11)EW(16x6)WMJFKTNQEACIZXLH(5x12)KPVAD(13x8)(8x2)ELNIDSSO(11x7)RFITQIJYVQB(6x5)HTVSFUVZ(89x12)(44x5)(7x1)VHEWGTT(5x11)GLDZO(14x13)DZVEJXGSGUDJKV(24x14)(18x3)AWXPFDVHVRRUAIELQO(2x13)UW(120x7)(62x7)(21x10)JFUYPPCABHPYTIJUUIEVK(5x5)UNAMQ(17x14)TFQKSOALOJYMSMLMK(17x2)NBDXRSHFDREHZPWMM(23x5)(1x11)O(10x6)QVOCIXBIQW(5x10)FOLCQ(6635x5)(3576x2)(456x13)(449x3)(1x2)M(1x11)I(215x14)(28x2)(1x14)R(9x7)OSMSWTRTV(2x3)RP(87x2)(14x9)QACULEYKFWPHFQ(41x15)LTBJBTBTFQLLEAWJTICLZBHGAYERVARMDLCBZXYPY(4x6)CEOP(4x13)JQJI(62x5)(15x6)YQPFVDNREIYOUKL(15x15)PUSBXTHCMLGOCNT(8x4)YAUHTKIM(1x1)E(14x2)(9x1)YHUAWBSED(37x12)(14x9)(8x11)SVYXKPGZ(10x13)WTQVTWIWGP(162x9)(68x1)(1x4)I(21x14)WTBNFSPQKDFYITBOFYYQN(3x8)UOY(13x14)KCDKDKYFQNNPX(1x6)K(20x9)PMGWXQWRLRWRETULVFPW(1x3)T(20x13)(7x7)YYHNWZC(2x10)HH(22x10)XDUOOOIDYYXQKQDBLGCPSR(1297x7)(359x13)(62x9)(7x15)LRERGOG(25x15)KYQSSJBREHLNZXSLSYGIIADSC(10x15)WMFZAHRNRU(283x14)(68x12)(16x10)QGQDCKCPTECIPTOW(19x6)WMPAPTDDUABBOLYMMBR(14x1)XRZVQKCBBBMCNI(29x5)HSGAQWQRLOILWCRJOCRDFZSOTPLBH(82x1)(12x1)RENHWOTHWXPZ(39x10)BIKLBTNHOLVUWVGTPRPXXROUGEJRHRADHASJDMJ(4x13)VRRP(3x1)BFC(79x9)(39x4)OINGYXONKTSXJBCNNYZMWSYGIUMFATXEUDZQZVL(9x13)OIMKIRFAT(5x1)MIUXM(3x13)EPG(496x13)(37x4)(31x9)(2x5)MF(18x2)MEVRXNGVBHEGENHJTL(11x13)TTCEWIFBGGJ(150x4)(68x13)(9x10)KJJRCHTUM(11x10)SVUDYGHJWKF(6x12)LNWLUN(8x11)LUVPHPZC(4x8)VFUZ(32x9)(2x3)RH(5x5)OOAGL(1x15)W(2x11)WM(3x4)GFG(22x13)(8x6)ZVCSHQXP(4x8)KOXS(193x3)(25x7)PXQFECGPYZOYUWTMOTBFZGGAO(28x12)(7x4)XHUHXEN(10x4)DTXYSILNLW(1x2)Q(101x13)(16x11)MZVPYIEPSLDSIEAF(27x11)NFACRSGETEPHFJQKPTXUQNNSPWT(6x13)UADYIT(2x8)LB(19x7)QYBDEBFMFAWOTYACZQM(6x13)YEABPA(72x6)(58x13)(3x15)UOO(43x6)GRXJNNQQXQVANDHYVVQTTWIKVLPHBJMCSEOPBELMGHG(1x10)G(178x10)(12x1)(6x15)JWYUKS(93x13)(5x11)CQCXM(56x7)(9x5)FIARQLQTK(11x3)NSXGBEOBVXI(9x15)QIBUNRTPC(5x8)GBIYV(13x10)(2x6)RC(1x5)T(33x14)(3x4)END(19x6)MYZTTHSNYAYANBPGVHZ(2x14)YD(6x12)(1x5)N(3x13)TFG(224x8)(11x15)XNMAIBBNTMC(199x8)(2x10)VG(23x11)(5x11)KOKXL(7x9)MIMRNXM(121x10)(10x9)OGYRDPVNEI(27x5)XUBNCPGOKJIXZNAHHLLDRUUTPRM(25x2)FVEEUXQTUBDUDSMIRLBFQYULY(13x5)JTJASJBCCKFHV(16x6)TVTTDIFACKNORYBR(4x2)LIFO(17x2)RZGYMXWONVKWJMSVW(833x6)(586x12)(230x10)(2x13)EL(41x15)(34x11)KPHSFJQJWTINMWYVNSVVZBABFYEBZCLNMQ(17x14)CRLPIZUEIBCKNKRJJ(62x15)(9x4)XTGHEGPMK(11x12)NCNNMDWDNMI(8x2)PKWGUNYT(10x15)DVAFJQIPSK(74x10)(5x15)ZLKKA(17x11)GIERLJRIDYLPWZCKG(33x2)OASXACZZRSCLVDVNLNGQHLRLMZCTMBCYP(153x7)(2x14)UX(49x8)(11x14)GEHZYBKESFQ(2x6)TE(6x3)THQOAO(8x6)FSPDZODL(42x11)(2x12)XO(10x7)IZTTYUPKBT(11x13)PVRXUXHBKQI(35x6)(5x5)UDRJC(1x9)B(13x9)YHHERZVEFSCFX(78x11)(36x3)(1x6)X(23x14)DHLGIIMPJGKDUOPFEBPKJZB(7x12)TMWJAJD(16x12)YVALDPNTHINYQQIC(2x9)OY(90x5)(62x10)(9x6)RUUFLMWQS(28x6)TAZAAAIDBGZMYXMNGHVTBRHWFHXV(8x13)JIRKEMEB(15x5)ORKLKISZMYECJBE(178x12)(59x5)(5x9)QLOCV(6x5)XETXIX(11x15)USNLPYJLBOW(13x15)ZYMFNBNVKKQFT(11x3)PISAKCRXTWT(90x7)(52x2)(1x3)F(21x6)QFIQOUEYORICJDZVHMIOW(13x6)ONYWAVOHAIQXE(9x5)TKBIAQVJC(7x5)SUEYTHE(1x4)H(46x13)(33x3)(26x15)(1x3)Q(14x3)OHRVGRUAQFTYYS(2x6)BS(960x3)(544x15)(160x14)(15x2)(1x11)D(3x9)PXR(52x4)(9x13)ZVIVIWOIO(1x5)D(1x12)Y(8x8)CKZGFGQO(6x9)DAMZNP(75x8)(13x1)VDPXRVCMGTZIY(3x13)WMF(10x12)KDJVCJQVEC(24x3)GEKGZEIIDDDJRSZBNAIDNASO(3x15)VUI(74x5)(46x8)(6x2)GSPMZV(4x2)XOOW(9x15)COLWEPZNQ(5x13)UGBDW(15x10)TTWVRPQTREJDSJS(137x14)(65x10)(8x13)OMBDNQBZ(44x13)RVXFBIJOFAQJCLTKYBXVWALEONUACICLGJIWATGHHCZK(22x14)ZSGSVEEFHRWHXBLGCDJKZV(30x2)(2x12)GG(9x12)HJQCPKGNY(1x14)H(134x15)(5x4)YGCHW(5x10)EROTH(26x10)(7x1)OXPTTDP(8x10)OJJSDGCL(74x8)BDTYNXCCPDQCMYZJTAJOYCGMWJLOMLEQYBCYAZOLTCYNDAPXMXCHVSKJCYXZWBKGVELGTLNCEB(54x14)(14x13)(2x9)SM(1x10)U(27x3)XFJSNXIJPTSFDKVNGBDNRLQYJKQ(16x11)(10x9)BAPIHODLEG(317x8)(112x11)(30x4)(6x15)UTROFQ(11x11)UYHDNMPLNBH(28x5)ZMZKTXRTUNMVSQTUGNYDWUOFAFBA(2x4)OT(21x15)(9x3)VRSRVOEDX(1x10)W(1x12)H(86x12)(1x6)Y(25x9)ZYIPXGLABDQQRIQOWYNSVRDDS(35x5)NJIVDKLQTESWZNBIFFPADGWBQGVWPNOZKOB(3x8)JZK(98x8)(45x10)(6x5)LYJQMR(10x7)EFMGJRIYHN(1x12)W(5x11)CXUHP(40x1)(33x14)BIXNELLRAWDEQWDLFXASPCFKGYXNPZRLP(102x3)(35x15)(29x2)(1x1)P(8x2)OGCHVTFM(5x2)CVQRK(54x3)(48x4)(10x3)(5x6)IUXTW(26x7)(7x3)MCAIFSI(9x6)THFFYJGAO(1522x10)(25x12)(18x13)(12x1)(7x4)HVDYPIO(1159x6)(211x8)(154x11)(21x6)VCPDOYQRGXIJVQGRJTVWP(12x10)CEOZLAMGANTR(16x14)HRTTJOTOJYRMGUDK(79x5)(4x11)JHCB(4x15)FHRU(9x12)TVDNDJPQW(2x5)WH(30x14)LUFKTGXZTAORPRJMZESFFDVVWPVYTB(42x14)(35x14)(29x2)SAGPXWQEGTZAIADCQFBLWRLZIQGCN(135x7)(15x14)UQJYCTIFFWSUWWM(65x2)(9x9)(3x12)JUN(18x5)(12x8)RDYSFFHOCMTA(2x7)QY(14x3)(9x7)FERWVDDHQ(36x2)(11x7)ILSHNBRIBMC(13x8)SRXBXAPPTJPLF(101x14)(2x10)VE(86x10)(29x8)(23x8)KAMCCHDVKOOJCGDQJPZZMPJ(32x9)UEYJFLAOACKYLFDJWQUXGIZYWMHDKYLK(8x6)(3x3)LKI(682x13)(208x6)(76x14)(8x10)AYLZDXBI(3x9)BRC(25x10)IEATCRHBHGIKZBQTRCTXULAMN(15x12)ZHRTNMVERVGZZCG(32x3)(4x14)ERHO(7x7)NNNSCSF(5x4)TTUFM(4x7)XYWL(72x4)(3x7)SDF(29x13)OQXOWQELFOXUFEEBUPLNHMAOGLLPV(14x5)SZJGEXPPXSUXCB(3x8)KND(95x1)(28x5)(7x3)LVLVSVN(10x8)TGDBTKXVLI(10x11)WRFPBLNECA(29x1)XFGOLCPIYTKNJTXBAEATURQVVXGFP(3x14)YBZ(205x1)(16x14)(10x8)IFQMAAEMOP(32x9)(16x14)VBFTUPKSNIUAEBHA(3x14)EMW(23x11)(2x7)XS(3x7)QWS(2x12)TE(107x2)(21x12)XKLOCAHJZFYLQZMQDZUJP(28x15)VFRNAEWVNJVUZDURVOCUEISKGWWN(20x6)NXCCPUPQKGXTOWWRANDP(12x9)WRJVTTEYFJBE(146x12)(1x12)M(46x3)(12x15)ELAIIEJMLHRV(1x8)I(1x14)K(2x9)RN(1x14)E(81x6)(14x4)SHLOZXCBQTBEZF(40x2)YMEOXRNZXDIEEFLRQQDPWXILUOJQHDSUEKNXNQSP(3x2)TGQ(1x10)X(315x14)(307x10)(3x11)ZDV(260x4)(97x8)(20x11)YRELCFEJXQZADZSOJION(14x14)BGCJIBHVHEGFOD(3x14)PVA(33x13)KHUWKRRNHTHJCROVFAOIWGGOTIPKDMPRC(36x5)(2x8)HZ(22x14)YZSUXCHXDEPXIGCWUOKUXZ(62x10)(15x7)JZUDNJCWXTQAMOM(4x10)BJDT(24x14)ETEADJJYZZDODVKPPXTBTUPC(40x1)(5x9)UZDRJ(24x2)VPGSGVADLRBFODBZBMWBRJFC(24x14)(10x10)NJQVLSVHKJ(1x15)B(1402x12)(1381x11)(690x9)(163x6)(76x1)(16x11)TTKEOWZUHJMAOJVI(4x15)LGFT(3x6)MYP(17x7)CHKQJJMHHGHDXWBSO(7x7)UJLDJLX(11x12)LGBIGRGMTBV(21x6)RISOUTKGCNPQLLDWNLYEA(5x14)IZRZO(19x8)(13x7)ZYNNYQLEROHNK(23x9)(3x13)KRN(9x5)(4x5)OXVO(185x5)(52x6)(6x4)QOSUZS(18x6)GUQOGCRNSAKDCOCTSE(10x14)KGZBUGVIIH(40x10)(6x12)CMZQRR(1x5)Q(15x11)WEKZHYYCTPIPOZJ(58x8)(1x4)A(6x8)ABJIRX(11x15)EQFJHQOVGLY(6x3)YYQMKZ(7x7)LKJYEWV(5x4)BPTKB(1x4)J(284x5)(63x10)(1x8)W(11x13)MPTRNQPSBXM(15x3)VHDTUWNDEGLNCSQ(2x1)CQ(6x2)OCFRSJ(63x9)(15x12)AEYDUUWROCUABMX(12x4)RPGECWZRBHLK(1x11)O(10x4)JCBDSFSXDE(13x11)(8x4)BEHBONOK(83x2)(4x6)ANAD(3x15)LOP(20x15)TJLFCNGAYSBMWACNIOME(14x14)OLVVHGNWUVNXMR(10x12)DAHIOTLOCP(30x9)(2x12)TR(16x3)DYWYHJLMIYAHQIIE(3x8)SNV(112x15)(19x8)PBXORKYLISLHVCJVBJP(74x10)(2x8)FP(24x13)ZXILHYHYDGDNGHIPFHLMRLQS(2x11)WN(21x13)RDQDPNVEOLOSPLAHQHHMY(1x9)R(14x6)LIIRDEBBHSKXZT(372x10)(164x2)(40x7)RMPKUSRDBXNZLGDXZIAUAZNQBJEMSBUJOJNPHHHI(12x15)IAFPAWBOSBOS(76x6)(5x6)UYNUU(25x15)XPXFOEMDDICGRJONJBWMOZCIW(8x5)KJJIEDUG(15x2)IEUTKVCMTTXZNTC(11x9)IKWCZMUNCOP(61x12)(54x13)(13x12)NIOHBMYALHOUO(7x10)KFDUHJL(2x3)NM(9x9)OSVPKOFSM(5x5)VAMMP(9x3)EZLMGESLP(102x5)(26x5)(7x9)NHCIGIE(3x3)IVY(1x2)L(12x7)UXAUQLEXZGXN(46x6)(1x14)R(11x9)QTBPNKUFZOA(16x9)DLXKSEJJVMWIIHPB(157x8)(30x4)(13x15)TNSMJZJMNEUQM(4x12)HRAW(113x15)(17x4)(3x13)VQG(2x11)YK(4x9)GMIK(15x12)YGMZABAZZNHPRHP(23x4)(5x13)ZBQGH(7x3)SPNLPWT(24x1)HVEWGOENETTTKKBJHMBEFJSJ(6x14)WGBSYS(2694x1)(873x13)(591x15)(1x2)H(14x12)(9x8)(4x7)PHPZ(59x10)(10x7)EQJUHLQDSB(11x6)MHGNANYAWWK(3x8)FEN(11x12)RCPCNTVKIXQ(491x7)(78x14)(40x11)YVRYFJZMQREHNXZZPWXKNPHSUTVUGVEOPFQQBLOJ(25x1)(13x1)HQFQJIYOMZFGW(1x8)F(182x6)(86x14)(12x9)WODINQMTBDAX(6x7)JFCXXM(6x1)FKJPPD(40x2)IDAKJRAQIDKLPCCATMTFTOWNPLHKNJBTAVVHUWWN(53x8)(4x1)FXRX(9x1)DCBBRHJVU(2x2)RA(10x14)IWJGLMPMBS(1x5)H(14x2)WXKMITJBMZACIB(5x2)WLBVL(5x1)XNGOL(193x3)(6x8)ANFCUH(11x13)ZVGWPGYGIAR(72x4)(9x10)LUYDGWJLX(8x1)WUXTMRZR(2x3)FK(21x8)AGZIOWSLPHAKSUPECVOHV(4x12)FDXE(6x12)(1x8)M(68x7)(3x4)EOK(28x13)JXAMSHCQOBIUKUHUFYOOZJRMMNCW(19x4)YBUXDOFHTQVATUPANAF(1x15)H(110x13)(93x7)(87x2)(4x12)GMOE(50x11)(13x3)VHUHCBUNINBAH(9x14)ABWUPTZJB(10x1)ULUUYHAWHR(14x7)RSQMESIUXRZOVL(6x4)FBTNDA(5x7)ADGJH(139x5)(131x10)(123x14)(88x6)(1x11)A(17x13)XCWUXQVXMMRLURVHL(9x12)NBLNMYWQH(23x14)IOMVENQGFGYSOQNKKMXALXR(7x6)OWEXJQO(23x1)BGMPXSGMVQUXQJNAGUDPASW(168x14)(149x3)(17x1)(11x1)PPOPWWURQYN(119x7)(63x1)(4x14)CIWA(9x5)(4x3)YHDL(32x10)THARHNYWOIICGXLNEHOTTIEJXOLESVFO(44x2)(30x2)FMAVRVLKELMJLGHIPGCRCHJFVTBSUP(3x3)SIW(7x8)BIFVNRC(706x15)(699x8)(6x6)(1x1)B(284x11)(154x1)(26x12)BCUDXLZNEUYZIEKRPJNGEFKMNE(49x5)JNLLBDIRMRINXOUMGKJXTVCKAMZCEPVXFRIUUQXUQAHXXWERV(41x4)(5x15)JUNET(9x14)LAEKWBIYU(1x1)O(4x4)JFAB(13x4)KARCNJKHMFJFW(94x7)(64x7)(7x14)VRRWPHM(16x2)RYATIQNKHUXCZEGS(8x13)WZSZNRIH(3x7)TBE(2x4)DA(10x10)TJBORFEVFS(2x4)VE(8x15)YTADJOMR(4x2)XQAO(389x2)(171x3)(52x4)(1x6)C(14x1)QUCOESZSLGRLIJ(7x13)UVHYAWH(1x8)A(1x14)R(16x2)HOCCGBBDBBAJPVFU(52x8)(2x3)IV(20x3)BADNVTFDYEOJOSTOURIR(6x12)UAKYYR(1x12)D(3x8)RDJ(18x15)GDBLXRBQGDVOGYNIDB(7x9)RVLXMQP(146x2)(45x15)(3x3)NNY(10x14)EUROHLVNXH(4x12)JYRH(5x3)GJZII(2x1)IN(6x6)GPYYHE(70x5)(22x3)JSUZJGHKJQSJZHNHSBYXRX(11x4)CKNLLPRJDJB(11x9)EYWLHDJWYMZ(3x4)EOQ(39x11)(19x11)(12x15)ZSNCSSNGFNWK(7x11)QKRQMES(915x15)(657x4)(121x15)(21x4)(6x9)PBLEYF(5x3)JYILW(88x7)(48x6)(18x11)LHFNPRFKADOZQRHQVE(5x9)JSXCT(8x2)QOQRTIAA(7x3)NKKNWLS(16x4)URODMQWUOAUZDVTW(203x11)(196x3)(72x2)(1x12)L(2x3)AO(8x3)XROVOMDL(9x8)YZAEPPLFP(25x5)TJCBFMVSXVPIIOUHRJCUZAFPK(35x9)(22x5)BSQZOCOFMKGAVXARGGFCYV(2x1)BR(46x10)(3x1)MNZ(13x4)EBBUVWXRIWLMZ(13x8)EXOJUNPCWPYQE(9x14)(3x15)NYG(4x3)XNAD(6x3)OAGYDW(299x3)(130x5)(5x5)ZIVTZ(4x8)WRBW(73x12)(5x13)TCVNI(25x12)TLVHEMSRDZWQRIYKHDGLZVLEQ(24x3)PIOJWVRBAOPTXHUJAGHCRGNK(24x14)VCVZEHKJWAPXJDMALSUKRZAW(30x4)DMROHLLFJEFQZPAEVOYCSESESVCDPT(107x1)(19x11)XYGUSLMMCMUYFOZZCSG(9x13)(4x5)TMYS(2x1)BK(1x3)L(46x13)(40x7)JGIWCASPBLNAZSSBXMFLCZNHCLRYKJTSKTRIYXZD(7x7)SIMRJYC(243x12)(219x7)(4x8)XKYN(202x11)(26x11)(4x11)JIBP(3x12)TUQ(1x12)U(78x11)(10x12)PYKJEJKLOP(7x12)MGGQRIM(6x3)WDBTTC(10x6)EFUZOEPGTG(15x8)ULWOSKACKQHHDTH(2x5)OX(24x4)(1x13)Q(3x10)PLC(2x11)AZ(40x14)(4x3)IOIG(7x15)QQTGOCG(4x1)TTYK(4x1)KMKT(11x2)DUFCFLWJKDO(4988x11)(514x13)(184x10)(176x15)(168x14)(49x8)(11x13)NGQSRMSYVIT(5x13)LIGXA(13x13)QLVGLJOXJZEMA(14x3)BHSJULNXUJNMLB(21x13)QWVNZXHEHTXEDXQKZCKZH(59x3)(23x14)IZNXJWCWIXNWKNQDTNQUAEO(23x6)GDBWPQKJXRWQSZJUZRGBNNF(14x4)(9x7)RQPHPKUPM(7x9)QVUICMY(269x12)(34x4)(11x1)IODKMJLLLKQ(10x15)KDIWUXJCVN(221x12)(47x9)(12x12)RCNHOSXDVYYI(21x11)(3x4)IJG(8x4)XBPLQPKV(150x6)(75x15)(2x6)DH(23x10)WKXGJRDSEZTLPKCMMUZZMXF(7x7)WURAPMO(3x4)RIC(12x6)MFVQJUULXSZX(9x7)LSYQTUAPN(47x14)(3x10)YZI(7x6)YHUFAXO(1x4)M(14x4)LANLTXIEINNYBW(6x3)(1x1)W(8x9)FNIRZGYT(3676x12)(585x11)(242x2)(19x8)(12x15)OWCUIMOZCPJU(210x4)(107x13)(10x14)BTVYEADZIL(39x12)UMDJKKZWWGKFLEFWKVTRGZMWUTEWWFYSVMIVJQF(3x10)NEL(28x11)MLIMLBMEATHPEVTQRQTHBUOCFZMW(65x2)(23x12)SGEKZUXQNIGZURVKPNAISOY(21x2)UGJLXKWJVUFGJURKHTETM(2x11)XQ(17x13)CTOVPHTPJVNUSQZLY(329x9)(27x4)(20x15)(6x7)SWYPVM(3x10)ICH(105x3)(7x2)(2x1)QZ(11x11)(5x14)XUSZN(69x8)(7x12)VCQYFSA(24x7)EFVFKBFLRAJTGXEQGICZSOSE(10x7)CNXAKLLDBZ(4x13)XFXW(20x5)(13x15)SQZPVKWYCGMLX(96x12)(9x10)QNJNUKACF(14x3)WBKWFXIFFTAGKJ(2x11)TM(47x7)(9x4)WKFDSSPUO(12x2)TNCXEWMSFUPL(3x7)BCH(1x10)W(49x5)(23x10)(17x8)LMJYTUJGSCJDSMNZI(1x14)A(7x3)DYODODD(735x4)(2x13)CT(147x12)(140x1)(10x14)(5x6)KBFDG(74x11)(3x7)ASG(6x1)BAMUUR(11x1)HYWHOBKJIPH(22x14)ROJWCVIRBUVOXMHEBMHRBD(4x6)IHCB(36x9)(2x12)KI(1x1)I(16x4)TYYWOESVEYUUSCSQ(272x12)(6x13)YBZCAF(2x12)XV(12x10)(7x5)EOKMUXF(91x8)(4x3)CYOY(76x4)(2x6)QT(29x5)NMTVCDRMTLDIVOECJLYHZUBPYGOFD(4x5)IAJR(11x10)YPFPNDBONFO(2x3)WI(129x6)(77x2)(10x14)PAQKAHBQAX(2x4)YV(19x1)KXUKEJINNRYFXQJKRSM(10x2)YJAIIRZOWD(7x4)MDVMTGB(19x6)(4x9)MMQC(5x6)VZZVQ(2x7)XE(2x3)EQ(2x1)MA(202x9)(183x5)(13x5)YGYLMWENWKOEP(8x15)MIAMCHRA(67x15)(2x14)RP(10x5)NVJOFHUZFU(19x13)ELUOKNLHOOIAYZOCIMD(10x13)DQTLOMUCCQ(70x4)(11x1)KZALNOFLDHG(15x13)WLWZWHTUHWOZLES(9x10)FMITUKLQU(3x14)WCL(2x6)CK(6x10)(1x2)W(76x10)(2x8)ML(62x11)(48x11)(4x12)IRUH(4x3)DBQU(22x15)DYDBCSWMYSBLRNSNGRWCEU(1x15)Z(745x3)(23x1)(6x8)OKKJKF(7x1)(2x1)UU(709x5)(217x7)(116x3)(41x11)OAOMKCXJMJKKPSYWLNBFUDEVLICRKCGHRTGCIUAXZ(17x12)SKMYSNPPLDSOKIKXI(10x2)AYWGQTPNPX(12x14)GQFNEYXBYAAN(4x2)DWAS(12x13)MGXEWSKMSNTH(69x8)(7x6)LEFUMOK(19x4)UREDJOQURHFQCDSOZKZ(8x13)QPNYHWBW(12x2)JVUTOZHSWMXS(143x9)(79x6)(5x6)ZLLEG(4x13)ZAKG(2x6)QM(32x5)ADNXICFDFEOECVZHIVQKALYWLJGUSOSI(9x9)AWIAWSRJZ(52x5)(5x6)QSJGP(10x1)KDADHYYLCR(4x9)BQEP(1x1)Z(6x9)OMYNHU(103x7)(86x5)(2x13)AB(45x6)PQHXQFEMSNVRLACWAKQOYTZVLYPGBLAVMANXZHEMATRCF(14x4)YEVRVCORQWAJYG(2x3)AC(6x4)(1x4)W(135x15)(4x9)NULK(79x7)(7x10)RVBBWHN(3x12)MEL(33x9)FQIMGFZZTZBDCAYWARBLFRRQTJROKZXOJ(6x8)PWSZAR(2x5)ZR(13x8)RGRLYMPEYXDYF(15x15)EKZSLEASGQCSSAQ(76x5)(3x1)GDV(14x4)BYSPLEVMSPGXHS(4x2)LIDY(33x9)(27x4)ZWOLHCSTTPJZTODWETGHTNMAPAF(1215x14)(142x4)(14x1)ODRTZPGCANTMRQ(11x12)FFJIYPJJDPY(18x13)(12x7)PHABYHRKCIBS(72x12)TLUCYATALAFMLBSLTDHFNEGCVYKQFKPHVAMBSCYPSYMMGFGEPKMZRVXAZLGQQGCAQVIDKQCZ(119x10)(100x8)(6x6)ZKHOPF(37x8)JZJYXJTGQWXJKOWCEGRYFWORONDPKWDHGQFWR(9x10)JZTDQPVOV(7x11)MNMFBYO(12x9)(6x12)TEOCNK(6x11)(1x9)U(413x10)(1x12)W(357x6)(81x1)(20x13)AXMPRMJPLLNQTKNAKAKL(15x11)NCYQCFJRFVEBMBE(10x15)IDMWCCMJMT(9x15)KDITVSFLX(8x13)LWDZHEIH(85x4)(9x8)DNTHBQVEK(3x12)RCQ(17x5)IONTLMAHANUFDOIZZ(3x1)IKC(24x10)YQLVKHSGEHGXGFYSVJGHUHUA(109x4)(4x12)XZEO(12x5)HEZUPCXXEENI(12x12)OMJTLBITZWOB(13x13)YWOEGEYKAOZJS(36x8)VUZJQCVRHXSSCZNTEFKDZLVHDVCJSREVEVCB(43x6)(2x4)RT(4x12)CIZV(20x6)HHICUGNPVNOEZZGDLIZY(36x6)WRYFVILIDECKLNDCCWDEBAAPNRQVLQTWUQRC(260x7)(81x9)(5x1)XTIWO(7x2)(2x7)HZ(47x3)(6x5)EJMXOK(10x14)CVISHTXMOH(6x12)QCQAWT(1x12)V(1x3)Y(165x10)(21x10)PSYSIOEUPVJSLHBRVCOJD(39x12)(12x14)UBTGKOQEIYFM(5x4)CLHJC(5x4)FWNYB(9x13)ZHUPCPRPR(39x13)(10x15)YKYHEZRRDL(3x9)TRX(8x15)STWMOZDH(23x10)(2x9)ZM(2x7)MV(3x13)OQK(243x11)(210x8)(42x14)(17x12)JIOXSDZFXPPALZIKA(12x5)VJLEWBRVXMCD(23x2)VNXQYVPIRTMBGPKVZNTOFOG(61x6)(7x4)NSPFDMJ(9x14)TVHJEJSSJ(2x13)IJ(13x9)QTFHJIOJOQAOA(1x11)C(59x3)(6x11)MSQZOU(31x14)VLYOENWNIUSCUPMSOZEFABALZGGUXSZ(3x12)MIA(13x5)XZEMQZEXZTHJP(1x14)O(358x8)(162x14)(39x11)(13x5)(7x10)ZEJGPTO(1x12)V(8x7)PFNFRIMK(8x12)(2x13)LL(47x1)(41x8)(1x6)W(16x10)KZDYKHCTWZXEKCNJ(6x11)BKPJMJ(42x15)MMVAWYBRUXHRRXCVQBRTDORBFQQBOOHMVEKUQKJQTP(58x11)(28x5)NMWGTZUQBNENKBJWXUSTOSCMPLCZ(18x7)XIOSACAMZDWOJMBKQD(105x2)(72x12)(48x12)(5x10)XABVT(4x1)FENC(3x3)FPK(3x2)BMX(7x2)CTTSNTO(11x2)(5x14)XLVEE(2x1)PI(6x10)XMZISE(2x6)AK(6x1)ZPYKXO(774x3)(10x4)QTZHPYSXNC(720x15)(226x14)(40x9)(2x10)BT(17x14)(2x15)SO(4x2)ECYN(2x10)JM(7x4)XOBYLTV(120x3)(1x3)N(19x12)PEGBFGRTJFJSVIQZTNS(2x5)JD(41x13)(3x13)YTK(6x4)FUJASF(5x10)NHCVS(5x7)EBSJH(27x3)MMLCNRRAUAKKAGPBUHZQKMJVRLY(35x8)(12x5)EUFDLSCJNJIW(1x11)F(5x8)OICJN(178x3)(1x5)O(164x12)(69x5)(1x3)Y(13x7)NJGIFSDNRZGUN(20x2)CHUHUOZQHKOBNBNITRCT(3x13)XHS(4x4)HCZB(47x10)(13x13)HKZXATQZXPKJC(3x6)LFO(5x2)ZUTAK(4x8)JGZZ(13x1)BPKJSEMKXVWPD(10x8)CFBDPLWXUF(4x11)DYMH(283x14)(100x12)(9x14)LWMYUMEGI(79x7)(73x7)FBVHIBPTQYOPEWFQTFYYLGGOYUBRWFHKOXUWAZPIAVVVOWQGVUUKSSIGQWGTGTVMFEUSTYTQV(55x2)(10x14)IKRUCTQUXX(32x5)(20x2)JNEGAYZJAEFMMZNDQAYI(1x5)N(36x10)(12x10)PFTBHPEYKBFW(11x7)YRKUEULAVQO(65x9)(13x12)NKUIAGSIXWKEW(38x10)(4x8)IVPO(12x2)ENSUUWUGMFDE(6x5)GBZVEV(1x4)H(18x4)(12x6)(6x15)(1x6)C(1798x6)(725x7)(718x4)(128x9)(72x4)(41x6)XHDCTSCOLQXDITGBJPZCFXWLCBVNRWZKIHXOYRZQE(2x11)AL(10x11)CKPZHZXSEL(44x2)(38x2)(24x12)KQQVZKDYTAXJIECUHRNEEHIE(2x5)MR(2x14)EX(525x9)(135x3)(24x1)(6x4)AJAHVA(8x4)FCQQTUCX(42x9)(16x1)YJXDRMKLAJWGHRSL(9x8)CYVVQKOEQ(1x8)S(11x7)CGKRJUPVKDK(28x3)HQMZNCYOAIJBKRAGXYWTWOMEDSBE(1x4)U(16x13)UWNXBMZLSDWJWXRY(13x14)VALDTDWVJQQYY(48x4)(8x5)(3x2)HCC(28x13)(10x14)UFDCSYFEPI(5x11)NPDJR(279x1)(72x15)(15x11)CZESSYYLTNHNNEL(4x12)SCJE(2x4)IK(2x13)UO(19x8)AXUVJUCVOZYXECUHXTP(101x2)(7x3)MUNLZOM(5x7)GYXMB(13x2)UGNTFKQKQNSBU(27x9)IVJLAPCSRKKUBGNZXYELDTFXXDJ(20x12)KHMCDFDXECBLOWYPQFYZ(13x2)VDLMHMTQWHSIS(66x11)(6x14)RHRBCF(12x12)QBPGBNHZPQMS(28x11)BMIFCPCTBLKBIXCWFNLFSAOGHDWA(36x10)(30x1)KQYVYKBALRKIFSCOPWNQPYGRSSDAFY(1057x14)(320x8)(131x14)(124x3)(6x1)(1x8)Y(11x11)RYCMRYHAPAM(12x4)(7x2)LMPRCHR(65x7)(20x12)FBGHCCVXKKFXNJJWLKIU(16x10)KIYAZDBPNWXQXAKQ(9x11)EEQGTCDVB(1x3)I(132x2)(125x1)(20x12)HBEZQGFLJSFHGOYMLHSG(19x7)(3x5)THM(6x4)XKBKJV(7x12)(2x8)DF(14x12)(8x14)AXZPIRCT(33x9)(20x11)JCTTWVAOXNBCDBCUVNCX(1x9)J(36x9)(30x9)GCKYVYDUIBAWHSKBTTAHOYQWUQJHIV(699x2)(400x2)(45x10)(2x12)DY(31x7)(2x13)CP(6x11)TCMIXN(5x13)GBDVM(3x11)JAD(136x14)(11x1)ABIOQIJMVTI(6x10)NNTWTD(29x6)(1x14)Q(16x9)NNLMOVNFVJLXXLJJ(66x6)(4x3)RAZW(11x3)EQUJQECMCRI(10x14)DWLVSFXKGZ(5x15)RGJPT(7x1)RDFSOXE(74x8)(5x8)NEBHU(7x15)UEWKNIH(45x7)(19x3)TLAIFAYOOOCZMBIKVOU(4x6)OZBT(5x14)JEPAV(108x8)(2x15)LU(21x7)(3x6)JAV(2x3)LL(1x6)J(2x12)DX(59x6)(12x4)QXLWMASKAATM(10x7)OWRCRLMNRR(1x6)X(5x8)FBCAK(3x13)SIC(211x15)(2x6)IG(196x10)(54x8)(10x6)ZVIJHGXDTL(4x6)WCBN(2x12)IP(7x4)YLCWERN(4x1)LVRK(59x7)(5x5)JSDEV(4x14)FJFZ(17x7)KGBZBEJEIMCGUMSPZ(3x8)TAF(3x7)JTW(64x12)(2x11)BL(7x8)EQAGDIV(1x4)X(13x12)WDLMTJDUILHTJ(11x13)CBRRLLSHSWI(1x1)G(61x3)(3x7)CVG(27x9)(3x5)WIL(13x1)KFMXZGHEODGKB(2x1)QU(7x11)(1x13)S(18x5)VCSBJGLOOVXYTVMKOJ(143x10)(74x5)(25x12)IRMWONJTNGIJCGCTHVQOPQPIB(2x13)EY(6x8)NWOYXV(17x1)VBWAHETINYXRWMUVH(14x6)XEWNDODPNFJNFR(36x10)(5x1)XVRMW(3x15)PEE(4x9)RIJF(3x3)SYV(19x8)(12x13)(1x4)P(1x2)H(13x7)UKWAWHHQFYDWF(96x11)(5x12)PRKUK(13x14)RDQYSCYBCMONV(36x9)(3x15)ZOZ(8x15)PSPDGSWF(8x6)BMEGXZMZ(17x7)RQNGEXECJCUYFXPMB(163x14)(75x12)(9x9)YKFJTBRHE(44x15)DDSGHUAIXMRFTUHJZKDCTCLFREDDDHFAFQXALBIGIEMS(5x3)ZFRYZ(66x4)(7x8)KMXIZSU(34x15)ETTRETRSNLYOQZNWUXCNGPPUJPQNFYYEEC(7x12)RFTTNRF(3x12)HVO(97x15)(9x13)EASXOBURZ(14x14)EPODGHCXUDADRA(7x10)ECBRZCQ(22x13)SCAQGLZJTRSFEBTFFDTDRZ(13x7)RHQRORLJVNLWN(6x2)INZFFT\";\n\nint compression_list[10000][2];\nint compression_list_index = 0;\n\nint main(void){\n    long total_len = 0;\n    int count = 0, multiplier_len = 0;\n    int chars = 0, times = 0;\n\n    while(input[count] != '\\0'){\n        \n        if(input[count] == '('){\n            count++;\n            \n            \n            while(input[count] != 'x'){\n                chars = chars * 10 + (input[count] - '0'); \n                multiplier_len++;\n                count++;\n            }\n                count++;\n\n            \n            while(input[count] != ')'){\n                times = times * 10 + (input[count] - '0'); \n                multiplier_len++;\n                count++;\n            }\n\n            multiplier_len += 3;\n\n            for(int i = 0; i < compression_list_index; i++){\n                if(compression_list[i][0] != 0){\n                    compression_list[i][0] -= multiplier_len;\n                }\n            }\n\n            compression_list[compression_list_index][0] = chars;\n            compression_list[compression_list_index][1] = times;\n            compression_list_index++;\n\n            chars = 0; \n            times = 0;\n            multiplier_len = 0;\n        }\n        else{\n            int total_multiplier = 1;\n            for(int i = 0; i < compression_list_index; i++){\n                if(compression_list[i][0] != 0){\n                    total_multiplier *= compression_list[i][1];\n                    compression_list[i][0] -= 1;\n                }\n            }\n            total_len += total_multiplier;\n        }\n\n        count++;\n    }\n\n    printf(\"answer=%ld\\n\", total_len);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid parse_instructions(void);\n\nint regs[4] = {0};\nint curr_instr = 0, max_instr = 0;\n\nstruct instructions_s {\n    enum instructions {cpy_reg, cpy_val, inc, dec, jnz_reg, jnz_val} cmd;\n    int x;\n    int y;\n} instr[1000];\n\n\nint main(void){\n    parse_instructions();\n    max_instr = curr_instr;\n    curr_instr = 0;\n\n    regs[2] = 1;\n\n    while(curr_instr < max_instr){\n        switch(instr[curr_instr].cmd){\n            case 0 :\n                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];\n                curr_instr++;\n                break;\n\n            case 1 :\n                regs[instr[curr_instr].y] = instr[curr_instr].x;\n                curr_instr++;\n                break;\n\n            case 2 :\n                regs[instr[curr_instr].x]++;\n                curr_instr++;\n                break;\n\n            case 3 :\n                regs[instr[curr_instr].x]--;\n                curr_instr++;\n                break;\n\n            case 4 :\n                if(regs[instr[curr_instr].x] != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n\n            case 5:\n                if(instr[curr_instr].x != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n    }\n\n    printf(\"ans=%d\\n\", regs[0]);\n    return EXIT_SUCCESS;\n}\n\nvoid parse_instructions(void){\n    FILE *fp;\n    char * data_read = NULL;\n    size_t len; ssize_t read;\n\n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        switch(data_read[0]){\n            case 'c' :\n                if(isalpha(data_read[4]) != 0){         \n                    instr[curr_instr].cmd = cpy_reg;\n                    instr[curr_instr].x = data_read[4] - 97;\n                    instr[curr_instr].y = data_read[6] - 97;\n                }\n                else{                                               \n                    instr[curr_instr].cmd = cpy_val;\n                    instr[curr_instr].x = atoi(data_read + 4);\n                    instr[curr_instr].y = data_read[strlen(data_read) - 1] - 97;\n                }\n                break;\n\n            case 'i' :\n                instr[curr_instr].cmd = inc;\n                instr[curr_instr].x = data_read[4] - 97;\n                break;\n\n            case 'd' :\n                instr[curr_instr].cmd = dec;\n                instr[curr_instr].x = data_read[4] - 97;\n                break;\n\n            case 'j' :\n                if(isalpha(data_read[4]) != 0){\n                    instr[curr_instr].cmd = jnz_reg;\n                    instr[curr_instr].x = data_read[4] - 97;\n                    instr[curr_instr].y = atoi(data_read + 6);\n                }\n                else{\n                    instr[curr_instr].cmd = jnz_reg;\n                    instr[curr_instr].x = atoi(data_read + 4);\n                    instr[curr_instr].y = atoi(data_read + 6);\n                }\n                break;\n\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n\n        curr_instr++;\n    }\n\n    \n    fclose(fp);\n    free(data_read);\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NR_DISCS 7\n\nint input[NR_DISCS][3] = {\n   { 5, 0,  2}, \n   {13, 0,  7},\n   {17, 0, 10},\n   { 3, 0,  2},\n   {19, 0,  9},\n   { 7, 0,  0},\n   {11, 0,  0}\n};\n\nbool not_zero = false;\nint time = 1;\n\nint main(){\n   \n   for(int i = 0; i < NR_DISCS; i++){\n      for(int j = 0; j < i + 1; j++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n   }\n\n   \n   while(1){\n      for(int i = 0; i < NR_DISCS; i++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n            not_zero = true;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n\n      \n      if(!not_zero){\n         printf(\"answer=%d\\n\", time);\n         break;\n      }\n      else{\n         not_zero = false;\n      }\n      time++;\n   }\n\n   return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DATA_TO_FILL 35651584\n\nchar input[60000000] = \"11110010111001001\";\nchar dummy[60000000], checksum[60000000];\n\n\nint main(void){\n    \n    while(strlen(input) < DATA_TO_FILL){\n        int len = strlen(input);\n\n        \n        input[len - 1] = '0';\n\n        \n        for(int i = len, j = len; i >= 0; i--, j++){\n            if(input[i] == '0'){\n                input[j] = '1';\n            }\n            else{\n                input[j] = '0';\n            }\n\n        }\n    }\n\n    \n    input[DATA_TO_FILL] = '\\0';\n    strcpy(checksum, input);\n    \n    \n    while((strlen(checksum))%2 == 0){\n        memset(dummy, 0, sizeof(dummy));\n\n        int len = strlen(checksum);\n        for(int i = 0, j = 0; i < len; i += 2, j++){\n            if(checksum[i] == checksum[i + 1]){\n                dummy[j] = '1';\n            }\n            else{\n                dummy[j] = '0';\n            }\n        }\n        strcpy(checksum, dummy);\n    }\n\n    printf(\"checksum=%s (len=%ld)\\n\", checksum, strlen(checksum));\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdbool.h>\n\nchar line_nodash[100];\nchar line_brackets[20];\nlong char_counter = 0, total_sector = 0;\nchar c = 'a';\nint line_counter = 0, sector_ID = 0, processed = 0;\n\nint main() {\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t size = 0;\n\n   fseek(fp_data, 0, SEEK_END);\n   size = ftell(fp_data);\n   rewind(fp_data);\n   data_read = malloc((size + 1) * sizeof(* data_read));\n\n   fread(data_read, size, 1, fp_data);\n   data_read[size] = '\\0';\n\n\n   while(1){\n      c = data_read[char_counter];\n      if(c == '\\0'){\n         printf(\"TOTAL=%ld (processed=%d)\\n\", total_sector, processed);\n         return 0;\n      }\n\n      while(c != '\\n'){\n         if(c == '['){\n            char_counter++; size = 0;\n\n            while(data_read[char_counter] != ']'){\n               line_brackets[size] = data_read[char_counter];\n               char_counter++; size++;\n            }\n            line_brackets[size] = '\\0';\n         }\n         else{\n            if(isalpha(c)){ \n               line_nodash[line_counter] = c;\n               line_counter++;\n            }\n            if(isdigit(c)){\n               sector_ID = sector_ID * 10 + (c - '0');\n            }\n            char_counter++;\n         }\n\n         c = data_read[char_counter];\n      }\n\n      line_nodash[line_counter] = '\\0';\n      line_counter = 0;\n      char_counter++;\n      #ifdef DEBUG\n         printf(\"line=%s\\tbrackets=%s\\tID=%d\\n\", line_nodash, line_brackets, sector_ID);\n      #endif\n\n      int count[26] = {0}, parse_count = 0;\n\n      while(line_nodash[parse_count] != '\\0'){\n         count[line_nodash[parse_count] - 'a']++;\n         parse_count++;\n      }\n\n      #ifdef DEBUG\n         for(int j = 0; j < 26; j++){\n            if(count[j] != 0){\n\n                  printf(\"%c => %d\\n\", j + 'a', count[j]);\n\n            }\n         }\n      #endif\n\n      parse_count = 0;\n      int ok_counter = 0;\n      bool is_ok = true;\n      while(line_brackets[parse_count] != '\\0'){\n            if( (count[line_brackets[parse_count] - 'a']) < (count[line_brackets[parse_count + 1] - 'a']) ){ \n               is_ok = false;\n               #ifdef DEBUG\n                  printf(\"smaller\\n\");\n               #endif\n               break;\n            }\n\n            if( (count[line_brackets[parse_count] - 'a']) > (count[line_brackets[parse_count + 1] - 'a']) ){\n               #ifdef DEBUG\n                  printf(\"bigger\\n\");\n               #endif\n               ok_counter++;\n            }\n\n            if( (count[line_brackets[parse_count] - 'a']) == (count[line_brackets[parse_count + 1] - 'a']) ){\n               if( (line_brackets[parse_count]) < (line_brackets[parse_count + 1]) ){ \n                  #ifdef DEBUG\n                     printf(\"same ok\\n\");\n                  #endif\n                  ok_counter++;\n               }\n               else{\n                  is_ok = false;\n                  #ifdef DEBUG\n                     printf(\"same not ok\\n\");\n                  #endif\n                  break;\n               }\n            }\n\n         #ifdef DEBUG\n            printf(\"%c is %d\\n\", line_brackets[parse_count], count[line_brackets[parse_count] - 'a']);\n         #endif\n         parse_count++;\n      }\n\n      if(is_ok){\n         #ifdef DEBUG\n            printf(\"string is ok\\n\");\n         #endif\n         total_sector += sector_ID;\n      }\n      #ifdef DEBUG\n         else{\n            printf(\"string is not ok\\n\");\n         }\n      #endif\n\n      sector_ID = 0;\n      processed++;\n   }\n   printf(\"TOTAL=%ld (processed=%d)\\n\", total_sector, processed);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"md5.c\"\n\nint main(){\n   char * msg = \"abbhdwsy\", * dummy = NULL;\n   char code[9]; int code_counter = 0;\n\n   long index = 0;\n   size_t len = 0;\n   uint8_t * md5_result;\n\n   clock_t start = clock(), diff;\n   while(1){\n      asprintf(&dummy,\"%s%ld\" , msg, index);\n      len = strlen(dummy);\n      md5(dummy, len);\n\n      md5_result = (uint8_t *) &h0;\n\n      char str[10];\n      sprintf(str, \"%2.2X%2.2X%2.2X%2.2X\", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);\n\n      if(strncmp(str, \"00000\", 5) == 0){\n         printf(\"hash found - input=%s - MD5=%s - index=%ld\\n\", dummy, str, index);\n         code[code_counter] = str[5];\n         code_counter++;\n         code[code_counter] = '\\0';\n\n         if(code_counter >= 8){\n            printf(\"done! code=%s\\n\", code);\n            diff = clock() - start;\n            int msec = diff * 1000 \/ CLOCKS_PER_SEC;\n            printf(\"time: %ds %dms\", msec\/1000, msec%1000);\n            break;\n         }\n         else{\n            printf(\"current code = %s\\n\\n\", code);\n         }\n      }\n      index++;\n   }\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint data_array[8][26] = {0};\nchar output[8];\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      for(int i = 0; i < 8; i++){\n         data_array[i][(int)(data_read[i] - 'a')]++;\n      }\n   }\n\n   int max = 0;\n   for(int i = 0; i < 8; i++){\n      for(int j = 0; j < 26; j++){\n         if(data_array[i][j] > max){\n            output[i] = j + 'a';\n            max = data_array[i][j];\n         }\n\n      }\n      max = 0;\n   }\n\n   printf(\"answer=%s\\n\", output);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nchar string[4];\nbool in_brackets = false, approved_IP[2] = {false, true};\nint ip_counter = 0;\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      for(int current_char = 0; current_char < (strlen(data_read) - 5); current_char++){\n         for(int i = 0; i < 4; i++){\n            string[i] = data_read[current_char + i];\n         }\n   \n\n         if(strstr(string, \"[\") != NULL){\n            in_brackets = true;\n         }\n         else if(strstr(string, \"]\") != NULL){\n            in_brackets = false;\n         }\n         else{\n            if((string[0] == string[3]) && (string[1] == string[2]) && (string[0] != string[1])){\n               if(in_brackets) approved_IP[1] = false;\n               if(!in_brackets) approved_IP[0] = true;\n            }\n         }\n      }\n      if(approved_IP[0] && approved_IP[1]){\n         ip_counter++;\n      }\n      approved_IP[0] = false;\n      approved_IP[1] = true;\n      in_brackets = false;\n   }\n\n   printf(\"answer=%d\\n\", ip_counter);\n   return 0;\n}\n"}
{"target":"theuwis","func":"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define ROWS 6\n#define COLS 50\n\nbool screen[ROWS][COLS] = {false};\nint x = 0, y = 0, char_index;\nchar * loc;\n\nint main(){\n   FILE * fp_data;\n   fp_data = fopen(\"data\", \"r\");\n\n   char * data_read = NULL;\n   size_t len = 0;\n   ssize_t read;\n\n   while((read = getline(&data_read, &len, fp_data)) != -1){\n      if(strstr(data_read, \"rect\") != NULL){\n         loc = strstr(data_read, \"rect \");\n         char_index = (int)(loc - data_read) + 5;\n         while(isdigit(data_read[char_index]) != 0){\n            x = x * 10 + (data_read[char_index] - '0');\n            char_index++;\n         }\n         char_index++;\n         while(isdigit(data_read[char_index]) != 0){\n            y = y * 10 + (data_read[char_index] - '0');\n            char_index++;\n         }\n\n         for(int row = 0; row < y; row++){\n            for(int col = 0; col < x; col++){\n               screen[row][col] = true;\n            }\n         }\n      }\n\n      else{\n         loc = strstr(data_read, \"=\");\n         char_index = (int)(loc - data_read);\n         while(isdigit(data_read[char_index + 1]) != 0){\n            x = x * 10 + data_read[char_index + 1] - '0';\n            char_index++;\n         }\n\n         loc = strstr(data_read, \"by \");\n         char_index = (int)(loc - data_read);\n         while(isdigit(data_read[char_index + 3]) != 0){\n            y = y * 10 + data_read[char_index + 3] - '0';\n            char_index++;\n         }\n\n         if(strstr(data_read, \"column\") != NULL){\n            for(int pixels_down = 0; pixels_down < y; pixels_down++){\n               bool temp = screen[ROWS - 1][x];\n               for(int i = (ROWS - 1); i > 0; i--){\n                  screen[i][x] = screen[i - 1][x];\n               }\n               screen[0][x] = temp;\n            }\n         }\n         else if(strstr(data_read, \"row\") != NULL){\n            x ^= y; \n            y ^= x;\n            x ^= y;\n\n            for(int pixels_right = 0; pixels_right < x; pixels_right++){\n               bool temp = screen[y][COLS - 1];\n               for(int i = (COLS - 1); i > 0; i--){\n                  screen[y][i] = screen[y][i - 1];\n               }\n               screen[y][0] = temp;\n            }\n         }\n      }\n      x = 0; y = 0;\n   }\n\n   int lit_pixels = 0;\n   for(int row = 0; row < ROWS; row++){\n      for(int col = 0; col < COLS; col++){\n         if(screen[row][col] == true){\n            printf(\"#\");\n            lit_pixels++;\n         }\n         else{\n            printf(\".\");\n         }\n      }\n      printf(\"\\n\");\n   }\n\n   printf(\"\\nanswer=%d\\n\", lit_pixels);\n   return 0;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\nchar input[1000000] = \"(172x1)(3x7)XPJ(70x4)(40x7)WKQANMDILIQOOWQZDNGORPHFNHBKKKVQEJNUVNAQ(3x2)VFV(10x1)XUNNCAFYMV(9x13)OUIKISEPR(66x13)(10x6)JHDDURBDQC(3x11)SNT(2x11)EW(16x6)WMJFKTNQEACIZXLH(5x12)KPVAD(13x8)(8x2)ELNIDSSO(11x7)RFITQIJYVQB(6x5)HTVSFUVZ(89x12)(44x5)(7x1)VHEWGTT(5x11)GLDZO(14x13)DZVEJXGSGUDJKV(24x14)(18x3)AWXPFDVHVRRUAIELQO(2x13)UW(120x7)(62x7)(21x10)JFUYPPCABHPYTIJUUIEVK(5x5)UNAMQ(17x14)TFQKSOALOJYMSMLMK(17x2)NBDXRSHFDREHZPWMM(23x5)(1x11)O(10x6)QVOCIXBIQW(5x10)FOLCQ(6635x5)(3576x2)(456x13)(449x3)(1x2)M(1x11)I(215x14)(28x2)(1x14)R(9x7)OSMSWTRTV(2x3)RP(87x2)(14x9)QACULEYKFWPHFQ(41x15)LTBJBTBTFQLLEAWJTICLZBHGAYERVARMDLCBZXYPY(4x6)CEOP(4x13)JQJI(62x5)(15x6)YQPFVDNREIYOUKL(15x15)PUSBXTHCMLGOCNT(8x4)YAUHTKIM(1x1)E(14x2)(9x1)YHUAWBSED(37x12)(14x9)(8x11)SVYXKPGZ(10x13)WTQVTWIWGP(162x9)(68x1)(1x4)I(21x14)WTBNFSPQKDFYITBOFYYQN(3x8)UOY(13x14)KCDKDKYFQNNPX(1x6)K(20x9)PMGWXQWRLRWRETULVFPW(1x3)T(20x13)(7x7)YYHNWZC(2x10)HH(22x10)XDUOOOIDYYXQKQDBLGCPSR(1297x7)(359x13)(62x9)(7x15)LRERGOG(25x15)KYQSSJBREHLNZXSLSYGIIADSC(10x15)WMFZAHRNRU(283x14)(68x12)(16x10)QGQDCKCPTECIPTOW(19x6)WMPAPTDDUABBOLYMMBR(14x1)XRZVQKCBBBMCNI(29x5)HSGAQWQRLOILWCRJOCRDFZSOTPLBH(82x1)(12x1)RENHWOTHWXPZ(39x10)BIKLBTNHOLVUWVGTPRPXXROUGEJRHRADHASJDMJ(4x13)VRRP(3x1)BFC(79x9)(39x4)OINGYXONKTSXJBCNNYZMWSYGIUMFATXEUDZQZVL(9x13)OIMKIRFAT(5x1)MIUXM(3x13)EPG(496x13)(37x4)(31x9)(2x5)MF(18x2)MEVRXNGVBHEGENHJTL(11x13)TTCEWIFBGGJ(150x4)(68x13)(9x10)KJJRCHTUM(11x10)SVUDYGHJWKF(6x12)LNWLUN(8x11)LUVPHPZC(4x8)VFUZ(32x9)(2x3)RH(5x5)OOAGL(1x15)W(2x11)WM(3x4)GFG(22x13)(8x6)ZVCSHQXP(4x8)KOXS(193x3)(25x7)PXQFECGPYZOYUWTMOTBFZGGAO(28x12)(7x4)XHUHXEN(10x4)DTXYSILNLW(1x2)Q(101x13)(16x11)MZVPYIEPSLDSIEAF(27x11)NFACRSGETEPHFJQKPTXUQNNSPWT(6x13)UADYIT(2x8)LB(19x7)QYBDEBFMFAWOTYACZQM(6x13)YEABPA(72x6)(58x13)(3x15)UOO(43x6)GRXJNNQQXQVANDHYVVQTTWIKVLPHBJMCSEOPBELMGHG(1x10)G(178x10)(12x1)(6x15)JWYUKS(93x13)(5x11)CQCXM(56x7)(9x5)FIARQLQTK(11x3)NSXGBEOBVXI(9x15)QIBUNRTPC(5x8)GBIYV(13x10)(2x6)RC(1x5)T(33x14)(3x4)END(19x6)MYZTTHSNYAYANBPGVHZ(2x14)YD(6x12)(1x5)N(3x13)TFG(224x8)(11x15)XNMAIBBNTMC(199x8)(2x10)VG(23x11)(5x11)KOKXL(7x9)MIMRNXM(121x10)(10x9)OGYRDPVNEI(27x5)XUBNCPGOKJIXZNAHHLLDRUUTPRM(25x2)FVEEUXQTUBDUDSMIRLBFQYULY(13x5)JTJASJBCCKFHV(16x6)TVTTDIFACKNORYBR(4x2)LIFO(17x2)RZGYMXWONVKWJMSVW(833x6)(586x12)(230x10)(2x13)EL(41x15)(34x11)KPHSFJQJWTINMWYVNSVVZBABFYEBZCLNMQ(17x14)CRLPIZUEIBCKNKRJJ(62x15)(9x4)XTGHEGPMK(11x12)NCNNMDWDNMI(8x2)PKWGUNYT(10x15)DVAFJQIPSK(74x10)(5x15)ZLKKA(17x11)GIERLJRIDYLPWZCKG(33x2)OASXACZZRSCLVDVNLNGQHLRLMZCTMBCYP(153x7)(2x14)UX(49x8)(11x14)GEHZYBKESFQ(2x6)TE(6x3)THQOAO(8x6)FSPDZODL(42x11)(2x12)XO(10x7)IZTTYUPKBT(11x13)PVRXUXHBKQI(35x6)(5x5)UDRJC(1x9)B(13x9)YHHERZVEFSCFX(78x11)(36x3)(1x6)X(23x14)DHLGIIMPJGKDUOPFEBPKJZB(7x12)TMWJAJD(16x12)YVALDPNTHINYQQIC(2x9)OY(90x5)(62x10)(9x6)RUUFLMWQS(28x6)TAZAAAIDBGZMYXMNGHVTBRHWFHXV(8x13)JIRKEMEB(15x5)ORKLKISZMYECJBE(178x12)(59x5)(5x9)QLOCV(6x5)XETXIX(11x15)USNLPYJLBOW(13x15)ZYMFNBNVKKQFT(11x3)PISAKCRXTWT(90x7)(52x2)(1x3)F(21x6)QFIQOUEYORICJDZVHMIOW(13x6)ONYWAVOHAIQXE(9x5)TKBIAQVJC(7x5)SUEYTHE(1x4)H(46x13)(33x3)(26x15)(1x3)Q(14x3)OHRVGRUAQFTYYS(2x6)BS(960x3)(544x15)(160x14)(15x2)(1x11)D(3x9)PXR(52x4)(9x13)ZVIVIWOIO(1x5)D(1x12)Y(8x8)CKZGFGQO(6x9)DAMZNP(75x8)(13x1)VDPXRVCMGTZIY(3x13)WMF(10x12)KDJVCJQVEC(24x3)GEKGZEIIDDDJRSZBNAIDNASO(3x15)VUI(74x5)(46x8)(6x2)GSPMZV(4x2)XOOW(9x15)COLWEPZNQ(5x13)UGBDW(15x10)TTWVRPQTREJDSJS(137x14)(65x10)(8x13)OMBDNQBZ(44x13)RVXFBIJOFAQJCLTKYBXVWALEONUACICLGJIWATGHHCZK(22x14)ZSGSVEEFHRWHXBLGCDJKZV(30x2)(2x12)GG(9x12)HJQCPKGNY(1x14)H(134x15)(5x4)YGCHW(5x10)EROTH(26x10)(7x1)OXPTTDP(8x10)OJJSDGCL(74x8)BDTYNXCCPDQCMYZJTAJOYCGMWJLOMLEQYBCYAZOLTCYNDAPXMXCHVSKJCYXZWBKGVELGTLNCEB(54x14)(14x13)(2x9)SM(1x10)U(27x3)XFJSNXIJPTSFDKVNGBDNRLQYJKQ(16x11)(10x9)BAPIHODLEG(317x8)(112x11)(30x4)(6x15)UTROFQ(11x11)UYHDNMPLNBH(28x5)ZMZKTXRTUNMVSQTUGNYDWUOFAFBA(2x4)OT(21x15)(9x3)VRSRVOEDX(1x10)W(1x12)H(86x12)(1x6)Y(25x9)ZYIPXGLABDQQRIQOWYNSVRDDS(35x5)NJIVDKLQTESWZNBIFFPADGWBQGVWPNOZKOB(3x8)JZK(98x8)(45x10)(6x5)LYJQMR(10x7)EFMGJRIYHN(1x12)W(5x11)CXUHP(40x1)(33x14)BIXNELLRAWDEQWDLFXASPCFKGYXNPZRLP(102x3)(35x15)(29x2)(1x1)P(8x2)OGCHVTFM(5x2)CVQRK(54x3)(48x4)(10x3)(5x6)IUXTW(26x7)(7x3)MCAIFSI(9x6)THFFYJGAO(1522x10)(25x12)(18x13)(12x1)(7x4)HVDYPIO(1159x6)(211x8)(154x11)(21x6)VCPDOYQRGXIJVQGRJTVWP(12x10)CEOZLAMGANTR(16x14)HRTTJOTOJYRMGUDK(79x5)(4x11)JHCB(4x15)FHRU(9x12)TVDNDJPQW(2x5)WH(30x14)LUFKTGXZTAORPRJMZESFFDVVWPVYTB(42x14)(35x14)(29x2)SAGPXWQEGTZAIADCQFBLWRLZIQGCN(135x7)(15x14)UQJYCTIFFWSUWWM(65x2)(9x9)(3x12)JUN(18x5)(12x8)RDYSFFHOCMTA(2x7)QY(14x3)(9x7)FERWVDDHQ(36x2)(11x7)ILSHNBRIBMC(13x8)SRXBXAPPTJPLF(101x14)(2x10)VE(86x10)(29x8)(23x8)KAMCCHDVKOOJCGDQJPZZMPJ(32x9)UEYJFLAOACKYLFDJWQUXGIZYWMHDKYLK(8x6)(3x3)LKI(682x13)(208x6)(76x14)(8x10)AYLZDXBI(3x9)BRC(25x10)IEATCRHBHGIKZBQTRCTXULAMN(15x12)ZHRTNMVERVGZZCG(32x3)(4x14)ERHO(7x7)NNNSCSF(5x4)TTUFM(4x7)XYWL(72x4)(3x7)SDF(29x13)OQXOWQELFOXUFEEBUPLNHMAOGLLPV(14x5)SZJGEXPPXSUXCB(3x8)KND(95x1)(28x5)(7x3)LVLVSVN(10x8)TGDBTKXVLI(10x11)WRFPBLNECA(29x1)XFGOLCPIYTKNJTXBAEATURQVVXGFP(3x14)YBZ(205x1)(16x14)(10x8)IFQMAAEMOP(32x9)(16x14)VBFTUPKSNIUAEBHA(3x14)EMW(23x11)(2x7)XS(3x7)QWS(2x12)TE(107x2)(21x12)XKLOCAHJZFYLQZMQDZUJP(28x15)VFRNAEWVNJVUZDURVOCUEISKGWWN(20x6)NXCCPUPQKGXTOWWRANDP(12x9)WRJVTTEYFJBE(146x12)(1x12)M(46x3)(12x15)ELAIIEJMLHRV(1x8)I(1x14)K(2x9)RN(1x14)E(81x6)(14x4)SHLOZXCBQTBEZF(40x2)YMEOXRNZXDIEEFLRQQDPWXILUOJQHDSUEKNXNQSP(3x2)TGQ(1x10)X(315x14)(307x10)(3x11)ZDV(260x4)(97x8)(20x11)YRELCFEJXQZADZSOJION(14x14)BGCJIBHVHEGFOD(3x14)PVA(33x13)KHUWKRRNHTHJCROVFAOIWGGOTIPKDMPRC(36x5)(2x8)HZ(22x14)YZSUXCHXDEPXIGCWUOKUXZ(62x10)(15x7)JZUDNJCWXTQAMOM(4x10)BJDT(24x14)ETEADJJYZZDODVKPPXTBTUPC(40x1)(5x9)UZDRJ(24x2)VPGSGVADLRBFODBZBMWBRJFC(24x14)(10x10)NJQVLSVHKJ(1x15)B(1402x12)(1381x11)(690x9)(163x6)(76x1)(16x11)TTKEOWZUHJMAOJVI(4x15)LGFT(3x6)MYP(17x7)CHKQJJMHHGHDXWBSO(7x7)UJLDJLX(11x12)LGBIGRGMTBV(21x6)RISOUTKGCNPQLLDWNLYEA(5x14)IZRZO(19x8)(13x7)ZYNNYQLEROHNK(23x9)(3x13)KRN(9x5)(4x5)OXVO(185x5)(52x6)(6x4)QOSUZS(18x6)GUQOGCRNSAKDCOCTSE(10x14)KGZBUGVIIH(40x10)(6x12)CMZQRR(1x5)Q(15x11)WEKZHYYCTPIPOZJ(58x8)(1x4)A(6x8)ABJIRX(11x15)EQFJHQOVGLY(6x3)YYQMKZ(7x7)LKJYEWV(5x4)BPTKB(1x4)J(284x5)(63x10)(1x8)W(11x13)MPTRNQPSBXM(15x3)VHDTUWNDEGLNCSQ(2x1)CQ(6x2)OCFRSJ(63x9)(15x12)AEYDUUWROCUABMX(12x4)RPGECWZRBHLK(1x11)O(10x4)JCBDSFSXDE(13x11)(8x4)BEHBONOK(83x2)(4x6)ANAD(3x15)LOP(20x15)TJLFCNGAYSBMWACNIOME(14x14)OLVVHGNWUVNXMR(10x12)DAHIOTLOCP(30x9)(2x12)TR(16x3)DYWYHJLMIYAHQIIE(3x8)SNV(112x15)(19x8)PBXORKYLISLHVCJVBJP(74x10)(2x8)FP(24x13)ZXILHYHYDGDNGHIPFHLMRLQS(2x11)WN(21x13)RDQDPNVEOLOSPLAHQHHMY(1x9)R(14x6)LIIRDEBBHSKXZT(372x10)(164x2)(40x7)RMPKUSRDBXNZLGDXZIAUAZNQBJEMSBUJOJNPHHHI(12x15)IAFPAWBOSBOS(76x6)(5x6)UYNUU(25x15)XPXFOEMDDICGRJONJBWMOZCIW(8x5)KJJIEDUG(15x2)IEUTKVCMTTXZNTC(11x9)IKWCZMUNCOP(61x12)(54x13)(13x12)NIOHBMYALHOUO(7x10)KFDUHJL(2x3)NM(9x9)OSVPKOFSM(5x5)VAMMP(9x3)EZLMGESLP(102x5)(26x5)(7x9)NHCIGIE(3x3)IVY(1x2)L(12x7)UXAUQLEXZGXN(46x6)(1x14)R(11x9)QTBPNKUFZOA(16x9)DLXKSEJJVMWIIHPB(157x8)(30x4)(13x15)TNSMJZJMNEUQM(4x12)HRAW(113x15)(17x4)(3x13)VQG(2x11)YK(4x9)GMIK(15x12)YGMZABAZZNHPRHP(23x4)(5x13)ZBQGH(7x3)SPNLPWT(24x1)HVEWGOENETTTKKBJHMBEFJSJ(6x14)WGBSYS(2694x1)(873x13)(591x15)(1x2)H(14x12)(9x8)(4x7)PHPZ(59x10)(10x7)EQJUHLQDSB(11x6)MHGNANYAWWK(3x8)FEN(11x12)RCPCNTVKIXQ(491x7)(78x14)(40x11)YVRYFJZMQREHNXZZPWXKNPHSUTVUGVEOPFQQBLOJ(25x1)(13x1)HQFQJIYOMZFGW(1x8)F(182x6)(86x14)(12x9)WODINQMTBDAX(6x7)JFCXXM(6x1)FKJPPD(40x2)IDAKJRAQIDKLPCCATMTFTOWNPLHKNJBTAVVHUWWN(53x8)(4x1)FXRX(9x1)DCBBRHJVU(2x2)RA(10x14)IWJGLMPMBS(1x5)H(14x2)WXKMITJBMZACIB(5x2)WLBVL(5x1)XNGOL(193x3)(6x8)ANFCUH(11x13)ZVGWPGYGIAR(72x4)(9x10)LUYDGWJLX(8x1)WUXTMRZR(2x3)FK(21x8)AGZIOWSLPHAKSUPECVOHV(4x12)FDXE(6x12)(1x8)M(68x7)(3x4)EOK(28x13)JXAMSHCQOBIUKUHUFYOOZJRMMNCW(19x4)YBUXDOFHTQVATUPANAF(1x15)H(110x13)(93x7)(87x2)(4x12)GMOE(50x11)(13x3)VHUHCBUNINBAH(9x14)ABWUPTZJB(10x1)ULUUYHAWHR(14x7)RSQMESIUXRZOVL(6x4)FBTNDA(5x7)ADGJH(139x5)(131x10)(123x14)(88x6)(1x11)A(17x13)XCWUXQVXMMRLURVHL(9x12)NBLNMYWQH(23x14)IOMVENQGFGYSOQNKKMXALXR(7x6)OWEXJQO(23x1)BGMPXSGMVQUXQJNAGUDPASW(168x14)(149x3)(17x1)(11x1)PPOPWWURQYN(119x7)(63x1)(4x14)CIWA(9x5)(4x3)YHDL(32x10)THARHNYWOIICGXLNEHOTTIEJXOLESVFO(44x2)(30x2)FMAVRVLKELMJLGHIPGCRCHJFVTBSUP(3x3)SIW(7x8)BIFVNRC(706x15)(699x8)(6x6)(1x1)B(284x11)(154x1)(26x12)BCUDXLZNEUYZIEKRPJNGEFKMNE(49x5)JNLLBDIRMRINXOUMGKJXTVCKAMZCEPVXFRIUUQXUQAHXXWERV(41x4)(5x15)JUNET(9x14)LAEKWBIYU(1x1)O(4x4)JFAB(13x4)KARCNJKHMFJFW(94x7)(64x7)(7x14)VRRWPHM(16x2)RYATIQNKHUXCZEGS(8x13)WZSZNRIH(3x7)TBE(2x4)DA(10x10)TJBORFEVFS(2x4)VE(8x15)YTADJOMR(4x2)XQAO(389x2)(171x3)(52x4)(1x6)C(14x1)QUCOESZSLGRLIJ(7x13)UVHYAWH(1x8)A(1x14)R(16x2)HOCCGBBDBBAJPVFU(52x8)(2x3)IV(20x3)BADNVTFDYEOJOSTOURIR(6x12)UAKYYR(1x12)D(3x8)RDJ(18x15)GDBLXRBQGDVOGYNIDB(7x9)RVLXMQP(146x2)(45x15)(3x3)NNY(10x14)EUROHLVNXH(4x12)JYRH(5x3)GJZII(2x1)IN(6x6)GPYYHE(70x5)(22x3)JSUZJGHKJQSJZHNHSBYXRX(11x4)CKNLLPRJDJB(11x9)EYWLHDJWYMZ(3x4)EOQ(39x11)(19x11)(12x15)ZSNCSSNGFNWK(7x11)QKRQMES(915x15)(657x4)(121x15)(21x4)(6x9)PBLEYF(5x3)JYILW(88x7)(48x6)(18x11)LHFNPRFKADOZQRHQVE(5x9)JSXCT(8x2)QOQRTIAA(7x3)NKKNWLS(16x4)URODMQWUOAUZDVTW(203x11)(196x3)(72x2)(1x12)L(2x3)AO(8x3)XROVOMDL(9x8)YZAEPPLFP(25x5)TJCBFMVSXVPIIOUHRJCUZAFPK(35x9)(22x5)BSQZOCOFMKGAVXARGGFCYV(2x1)BR(46x10)(3x1)MNZ(13x4)EBBUVWXRIWLMZ(13x8)EXOJUNPCWPYQE(9x14)(3x15)NYG(4x3)XNAD(6x3)OAGYDW(299x3)(130x5)(5x5)ZIVTZ(4x8)WRBW(73x12)(5x13)TCVNI(25x12)TLVHEMSRDZWQRIYKHDGLZVLEQ(24x3)PIOJWVRBAOPTXHUJAGHCRGNK(24x14)VCVZEHKJWAPXJDMALSUKRZAW(30x4)DMROHLLFJEFQZPAEVOYCSESESVCDPT(107x1)(19x11)XYGUSLMMCMUYFOZZCSG(9x13)(4x5)TMYS(2x1)BK(1x3)L(46x13)(40x7)JGIWCASPBLNAZSSBXMFLCZNHCLRYKJTSKTRIYXZD(7x7)SIMRJYC(243x12)(219x7)(4x8)XKYN(202x11)(26x11)(4x11)JIBP(3x12)TUQ(1x12)U(78x11)(10x12)PYKJEJKLOP(7x12)MGGQRIM(6x3)WDBTTC(10x6)EFUZOEPGTG(15x8)ULWOSKACKQHHDTH(2x5)OX(24x4)(1x13)Q(3x10)PLC(2x11)AZ(40x14)(4x3)IOIG(7x15)QQTGOCG(4x1)TTYK(4x1)KMKT(11x2)DUFCFLWJKDO(4988x11)(514x13)(184x10)(176x15)(168x14)(49x8)(11x13)NGQSRMSYVIT(5x13)LIGXA(13x13)QLVGLJOXJZEMA(14x3)BHSJULNXUJNMLB(21x13)QWVNZXHEHTXEDXQKZCKZH(59x3)(23x14)IZNXJWCWIXNWKNQDTNQUAEO(23x6)GDBWPQKJXRWQSZJUZRGBNNF(14x4)(9x7)RQPHPKUPM(7x9)QVUICMY(269x12)(34x4)(11x1)IODKMJLLLKQ(10x15)KDIWUXJCVN(221x12)(47x9)(12x12)RCNHOSXDVYYI(21x11)(3x4)IJG(8x4)XBPLQPKV(150x6)(75x15)(2x6)DH(23x10)WKXGJRDSEZTLPKCMMUZZMXF(7x7)WURAPMO(3x4)RIC(12x6)MFVQJUULXSZX(9x7)LSYQTUAPN(47x14)(3x10)YZI(7x6)YHUFAXO(1x4)M(14x4)LANLTXIEINNYBW(6x3)(1x1)W(8x9)FNIRZGYT(3676x12)(585x11)(242x2)(19x8)(12x15)OWCUIMOZCPJU(210x4)(107x13)(10x14)BTVYEADZIL(39x12)UMDJKKZWWGKFLEFWKVTRGZMWUTEWWFYSVMIVJQF(3x10)NEL(28x11)MLIMLBMEATHPEVTQRQTHBUOCFZMW(65x2)(23x12)SGEKZUXQNIGZURVKPNAISOY(21x2)UGJLXKWJVUFGJURKHTETM(2x11)XQ(17x13)CTOVPHTPJVNUSQZLY(329x9)(27x4)(20x15)(6x7)SWYPVM(3x10)ICH(105x3)(7x2)(2x1)QZ(11x11)(5x14)XUSZN(69x8)(7x12)VCQYFSA(24x7)EFVFKBFLRAJTGXEQGICZSOSE(10x7)CNXAKLLDBZ(4x13)XFXW(20x5)(13x15)SQZPVKWYCGMLX(96x12)(9x10)QNJNUKACF(14x3)WBKWFXIFFTAGKJ(2x11)TM(47x7)(9x4)WKFDSSPUO(12x2)TNCXEWMSFUPL(3x7)BCH(1x10)W(49x5)(23x10)(17x8)LMJYTUJGSCJDSMNZI(1x14)A(7x3)DYODODD(735x4)(2x13)CT(147x12)(140x1)(10x14)(5x6)KBFDG(74x11)(3x7)ASG(6x1)BAMUUR(11x1)HYWHOBKJIPH(22x14)ROJWCVIRBUVOXMHEBMHRBD(4x6)IHCB(36x9)(2x12)KI(1x1)I(16x4)TYYWOESVEYUUSCSQ(272x12)(6x13)YBZCAF(2x12)XV(12x10)(7x5)EOKMUXF(91x8)(4x3)CYOY(76x4)(2x6)QT(29x5)NMTVCDRMTLDIVOECJLYHZUBPYGOFD(4x5)IAJR(11x10)YPFPNDBONFO(2x3)WI(129x6)(77x2)(10x14)PAQKAHBQAX(2x4)YV(19x1)KXUKEJINNRYFXQJKRSM(10x2)YJAIIRZOWD(7x4)MDVMTGB(19x6)(4x9)MMQC(5x6)VZZVQ(2x7)XE(2x3)EQ(2x1)MA(202x9)(183x5)(13x5)YGYLMWENWKOEP(8x15)MIAMCHRA(67x15)(2x14)RP(10x5)NVJOFHUZFU(19x13)ELUOKNLHOOIAYZOCIMD(10x13)DQTLOMUCCQ(70x4)(11x1)KZALNOFLDHG(15x13)WLWZWHTUHWOZLES(9x10)FMITUKLQU(3x14)WCL(2x6)CK(6x10)(1x2)W(76x10)(2x8)ML(62x11)(48x11)(4x12)IRUH(4x3)DBQU(22x15)DYDBCSWMYSBLRNSNGRWCEU(1x15)Z(745x3)(23x1)(6x8)OKKJKF(7x1)(2x1)UU(709x5)(217x7)(116x3)(41x11)OAOMKCXJMJKKPSYWLNBFUDEVLICRKCGHRTGCIUAXZ(17x12)SKMYSNPPLDSOKIKXI(10x2)AYWGQTPNPX(12x14)GQFNEYXBYAAN(4x2)DWAS(12x13)MGXEWSKMSNTH(69x8)(7x6)LEFUMOK(19x4)UREDJOQURHFQCDSOZKZ(8x13)QPNYHWBW(12x2)JVUTOZHSWMXS(143x9)(79x6)(5x6)ZLLEG(4x13)ZAKG(2x6)QM(32x5)ADNXICFDFEOECVZHIVQKALYWLJGUSOSI(9x9)AWIAWSRJZ(52x5)(5x6)QSJGP(10x1)KDADHYYLCR(4x9)BQEP(1x1)Z(6x9)OMYNHU(103x7)(86x5)(2x13)AB(45x6)PQHXQFEMSNVRLACWAKQOYTZVLYPGBLAVMANXZHEMATRCF(14x4)YEVRVCORQWAJYG(2x3)AC(6x4)(1x4)W(135x15)(4x9)NULK(79x7)(7x10)RVBBWHN(3x12)MEL(33x9)FQIMGFZZTZBDCAYWARBLFRRQTJROKZXOJ(6x8)PWSZAR(2x5)ZR(13x8)RGRLYMPEYXDYF(15x15)EKZSLEASGQCSSAQ(76x5)(3x1)GDV(14x4)BYSPLEVMSPGXHS(4x2)LIDY(33x9)(27x4)ZWOLHCSTTPJZTODWETGHTNMAPAF(1215x14)(142x4)(14x1)ODRTZPGCANTMRQ(11x12)FFJIYPJJDPY(18x13)(12x7)PHABYHRKCIBS(72x12)TLUCYATALAFMLBSLTDHFNEGCVYKQFKPHVAMBSCYPSYMMGFGEPKMZRVXAZLGQQGCAQVIDKQCZ(119x10)(100x8)(6x6)ZKHOPF(37x8)JZJYXJTGQWXJKOWCEGRYFWORONDPKWDHGQFWR(9x10)JZTDQPVOV(7x11)MNMFBYO(12x9)(6x12)TEOCNK(6x11)(1x9)U(413x10)(1x12)W(357x6)(81x1)(20x13)AXMPRMJPLLNQTKNAKAKL(15x11)NCYQCFJRFVEBMBE(10x15)IDMWCCMJMT(9x15)KDITVSFLX(8x13)LWDZHEIH(85x4)(9x8)DNTHBQVEK(3x12)RCQ(17x5)IONTLMAHANUFDOIZZ(3x1)IKC(24x10)YQLVKHSGEHGXGFYSVJGHUHUA(109x4)(4x12)XZEO(12x5)HEZUPCXXEENI(12x12)OMJTLBITZWOB(13x13)YWOEGEYKAOZJS(36x8)VUZJQCVRHXSSCZNTEFKDZLVHDVCJSREVEVCB(43x6)(2x4)RT(4x12)CIZV(20x6)HHICUGNPVNOEZZGDLIZY(36x6)WRYFVILIDECKLNDCCWDEBAAPNRQVLQTWUQRC(260x7)(81x9)(5x1)XTIWO(7x2)(2x7)HZ(47x3)(6x5)EJMXOK(10x14)CVISHTXMOH(6x12)QCQAWT(1x12)V(1x3)Y(165x10)(21x10)PSYSIOEUPVJSLHBRVCOJD(39x12)(12x14)UBTGKOQEIYFM(5x4)CLHJC(5x4)FWNYB(9x13)ZHUPCPRPR(39x13)(10x15)YKYHEZRRDL(3x9)TRX(8x15)STWMOZDH(23x10)(2x9)ZM(2x7)MV(3x13)OQK(243x11)(210x8)(42x14)(17x12)JIOXSDZFXPPALZIKA(12x5)VJLEWBRVXMCD(23x2)VNXQYVPIRTMBGPKVZNTOFOG(61x6)(7x4)NSPFDMJ(9x14)TVHJEJSSJ(2x13)IJ(13x9)QTFHJIOJOQAOA(1x11)C(59x3)(6x11)MSQZOU(31x14)VLYOENWNIUSCUPMSOZEFABALZGGUXSZ(3x12)MIA(13x5)XZEMQZEXZTHJP(1x14)O(358x8)(162x14)(39x11)(13x5)(7x10)ZEJGPTO(1x12)V(8x7)PFNFRIMK(8x12)(2x13)LL(47x1)(41x8)(1x6)W(16x10)KZDYKHCTWZXEKCNJ(6x11)BKPJMJ(42x15)MMVAWYBRUXHRRXCVQBRTDORBFQQBOOHMVEKUQKJQTP(58x11)(28x5)NMWGTZUQBNENKBJWXUSTOSCMPLCZ(18x7)XIOSACAMZDWOJMBKQD(105x2)(72x12)(48x12)(5x10)XABVT(4x1)FENC(3x3)FPK(3x2)BMX(7x2)CTTSNTO(11x2)(5x14)XLVEE(2x1)PI(6x10)XMZISE(2x6)AK(6x1)ZPYKXO(774x3)(10x4)QTZHPYSXNC(720x15)(226x14)(40x9)(2x10)BT(17x14)(2x15)SO(4x2)ECYN(2x10)JM(7x4)XOBYLTV(120x3)(1x3)N(19x12)PEGBFGRTJFJSVIQZTNS(2x5)JD(41x13)(3x13)YTK(6x4)FUJASF(5x10)NHCVS(5x7)EBSJH(27x3)MMLCNRRAUAKKAGPBUHZQKMJVRLY(35x8)(12x5)EUFDLSCJNJIW(1x11)F(5x8)OICJN(178x3)(1x5)O(164x12)(69x5)(1x3)Y(13x7)NJGIFSDNRZGUN(20x2)CHUHUOZQHKOBNBNITRCT(3x13)XHS(4x4)HCZB(47x10)(13x13)HKZXATQZXPKJC(3x6)LFO(5x2)ZUTAK(4x8)JGZZ(13x1)BPKJSEMKXVWPD(10x8)CFBDPLWXUF(4x11)DYMH(283x14)(100x12)(9x14)LWMYUMEGI(79x7)(73x7)FBVHIBPTQYOPEWFQTFYYLGGOYUBRWFHKOXUWAZPIAVVVOWQGVUUKSSIGQWGTGTVMFEUSTYTQV(55x2)(10x14)IKRUCTQUXX(32x5)(20x2)JNEGAYZJAEFMMZNDQAYI(1x5)N(36x10)(12x10)PFTBHPEYKBFW(11x7)YRKUEULAVQO(65x9)(13x12)NKUIAGSIXWKEW(38x10)(4x8)IVPO(12x2)ENSUUWUGMFDE(6x5)GBZVEV(1x4)H(18x4)(12x6)(6x15)(1x6)C(1798x6)(725x7)(718x4)(128x9)(72x4)(41x6)XHDCTSCOLQXDITGBJPZCFXWLCBVNRWZKIHXOYRZQE(2x11)AL(10x11)CKPZHZXSEL(44x2)(38x2)(24x12)KQQVZKDYTAXJIECUHRNEEHIE(2x5)MR(2x14)EX(525x9)(135x3)(24x1)(6x4)AJAHVA(8x4)FCQQTUCX(42x9)(16x1)YJXDRMKLAJWGHRSL(9x8)CYVVQKOEQ(1x8)S(11x7)CGKRJUPVKDK(28x3)HQMZNCYOAIJBKRAGXYWTWOMEDSBE(1x4)U(16x13)UWNXBMZLSDWJWXRY(13x14)VALDTDWVJQQYY(48x4)(8x5)(3x2)HCC(28x13)(10x14)UFDCSYFEPI(5x11)NPDJR(279x1)(72x15)(15x11)CZESSYYLTNHNNEL(4x12)SCJE(2x4)IK(2x13)UO(19x8)AXUVJUCVOZYXECUHXTP(101x2)(7x3)MUNLZOM(5x7)GYXMB(13x2)UGNTFKQKQNSBU(27x9)IVJLAPCSRKKUBGNZXYELDTFXXDJ(20x12)KHMCDFDXECBLOWYPQFYZ(13x2)VDLMHMTQWHSIS(66x11)(6x14)RHRBCF(12x12)QBPGBNHZPQMS(28x11)BMIFCPCTBLKBIXCWFNLFSAOGHDWA(36x10)(30x1)KQYVYKBALRKIFSCOPWNQPYGRSSDAFY(1057x14)(320x8)(131x14)(124x3)(6x1)(1x8)Y(11x11)RYCMRYHAPAM(12x4)(7x2)LMPRCHR(65x7)(20x12)FBGHCCVXKKFXNJJWLKIU(16x10)KIYAZDBPNWXQXAKQ(9x11)EEQGTCDVB(1x3)I(132x2)(125x1)(20x12)HBEZQGFLJSFHGOYMLHSG(19x7)(3x5)THM(6x4)XKBKJV(7x12)(2x8)DF(14x12)(8x14)AXZPIRCT(33x9)(20x11)JCTTWVAOXNBCDBCUVNCX(1x9)J(36x9)(30x9)GCKYVYDUIBAWHSKBTTAHOYQWUQJHIV(699x2)(400x2)(45x10)(2x12)DY(31x7)(2x13)CP(6x11)TCMIXN(5x13)GBDVM(3x11)JAD(136x14)(11x1)ABIOQIJMVTI(6x10)NNTWTD(29x6)(1x14)Q(16x9)NNLMOVNFVJLXXLJJ(66x6)(4x3)RAZW(11x3)EQUJQECMCRI(10x14)DWLVSFXKGZ(5x15)RGJPT(7x1)RDFSOXE(74x8)(5x8)NEBHU(7x15)UEWKNIH(45x7)(19x3)TLAIFAYOOOCZMBIKVOU(4x6)OZBT(5x14)JEPAV(108x8)(2x15)LU(21x7)(3x6)JAV(2x3)LL(1x6)J(2x12)DX(59x6)(12x4)QXLWMASKAATM(10x7)OWRCRLMNRR(1x6)X(5x8)FBCAK(3x13)SIC(211x15)(2x6)IG(196x10)(54x8)(10x6)ZVIJHGXDTL(4x6)WCBN(2x12)IP(7x4)YLCWERN(4x1)LVRK(59x7)(5x5)JSDEV(4x14)FJFZ(17x7)KGBZBEJEIMCGUMSPZ(3x8)TAF(3x7)JTW(64x12)(2x11)BL(7x8)EQAGDIV(1x4)X(13x12)WDLMTJDUILHTJ(11x13)CBRRLLSHSWI(1x1)G(61x3)(3x7)CVG(27x9)(3x5)WIL(13x1)KFMXZGHEODGKB(2x1)QU(7x11)(1x13)S(18x5)VCSBJGLOOVXYTVMKOJ(143x10)(74x5)(25x12)IRMWONJTNGIJCGCTHVQOPQPIB(2x13)EY(6x8)NWOYXV(17x1)VBWAHETINYXRWMUVH(14x6)XEWNDODPNFJNFR(36x10)(5x1)XVRMW(3x15)PEE(4x9)RIJF(3x3)SYV(19x8)(12x13)(1x4)P(1x2)H(13x7)UKWAWHHQFYDWF(96x11)(5x12)PRKUK(13x14)RDQYSCYBCMONV(36x9)(3x15)ZOZ(8x15)PSPDGSWF(8x6)BMEGXZMZ(17x7)RQNGEXECJCUYFXPMB(163x14)(75x12)(9x9)YKFJTBRHE(44x15)DDSGHUAIXMRFTUHJZKDCTCLFREDDDHFAFQXALBIGIEMS(5x3)ZFRYZ(66x4)(7x8)KMXIZSU(34x15)ETTRETRSNLYOQZNWUXCNGPPUJPQNFYYEEC(7x12)RFTTNRF(3x12)HVO(97x15)(9x13)EASXOBURZ(14x14)EPODGHCXUDADRA(7x10)ECBRZCQ(22x13)SCAQGLZJTRSFEBTFFDTDRZ(13x7)RHQRORLJVNLWN(6x2)INZFFT\";\n\nint main(void){\n    int count = 0, total_len = 0;\n    int chars = 0, times = 0;\n\n    while(input[count] != '\\0'){\n        \n        if(input[count] == '('){\n            count++;\n            \n            \n            while(input[count] != 'x'){\n                chars = chars * 10 + (input[count] - '0'); \n                count++;\n            }\n                count++;\n\n            \n            while(input[count] != ')'){\n                times = times * 10 + (input[count] - '0'); \n                count++;\n            }\n\n            total_len = total_len + (chars * times); \n            count = count + chars;  \n\n            chars = 0; \n            times = 0;\n        }\n        else{\n            total_len++;\n        }\n\n        count++;\n    }\n\n    printf(\"answer=%d\\n\", total_len);\n\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid parse_instructions(void);\n\nint regs[4] = {0};\nint curr_instr = 0, max_instr = 0;\n\nstruct instructions_s {\n    enum instructions {cpy_reg, cpy_val, inc, dec, jnz_reg, jnz_val} cmd;\n    int x;\n    int y;\n} instr[1000];\n\n\nint main(void){\n    parse_instructions();\n    max_instr = curr_instr;\n    curr_instr = 0;\n\n    while(curr_instr < max_instr){\n        switch(instr[curr_instr].cmd){\n            case 0 :\n                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];\n                curr_instr++;\n                break;\n\n            case 1 :\n                regs[instr[curr_instr].y] = instr[curr_instr].x;\n                curr_instr++;\n                break;\n\n            case 2 :\n                regs[instr[curr_instr].x]++;\n                curr_instr++;\n                break;\n\n            case 3 :\n                regs[instr[curr_instr].x]--;\n                curr_instr++;\n                break;\n\n            case 4 :\n                if(regs[instr[curr_instr].x] != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n\n            case 5:\n                if(instr[curr_instr].x != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n    }\n\n    printf(\"ans=%d\\n\", regs[0]);\n    return EXIT_SUCCESS;\n}\n\nvoid parse_instructions(void){\n    FILE *fp;\n    char * data_read = NULL;\n    size_t len; ssize_t read;\n\n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        switch(data_read[0]){\n            case 'c' :\n                if(isalpha(data_read[4]) != 0){         \n                    instr[curr_instr].cmd = cpy_reg;\n                    instr[curr_instr].x = data_read[4] - 97;\n                    instr[curr_instr].y = data_read[6] - 97;\n                }\n                else{                                               \n                    instr[curr_instr].cmd = cpy_val;\n                    instr[curr_instr].x = atoi(data_read + 4);\n                    instr[curr_instr].y = data_read[strlen(data_read) - 1] - 97;\n                }\n                break;\n\n            case 'i' :\n                instr[curr_instr].cmd = inc;\n                instr[curr_instr].x = data_read[4] - 97;\n                break;\n\n            case 'd' :\n                instr[curr_instr].cmd = dec;\n                instr[curr_instr].x = data_read[4] - 97;\n                break;\n\n            case 'j' :\n                if(isalpha(data_read[4]) != 0){\n                    instr[curr_instr].cmd = jnz_reg;\n                    instr[curr_instr].x = data_read[4] - 97;\n                    instr[curr_instr].y = atoi(data_read + 6);\n                }\n                else{\n                    instr[curr_instr].cmd = jnz_reg;\n                    instr[curr_instr].x = atoi(data_read + 4);\n                    instr[curr_instr].y = atoi(data_read + 6);\n                }\n                break;\n\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n\n        curr_instr++;\n    }\n\n    \n    fclose(fp);\n    free(data_read);\n}"}
{"target":"theuwis","func":"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n\n#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))\n\n\nuint32_t h0, h1, h2, h3;\n\n\nvoid md5(char *initial_msg, size_t initial_len) {\n\n    \n    uint8_t *msg = NULL;\n\n    \n\n    \n\n    uint32_t r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                    5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};\n\n    \n    uint32_t k[] = {\n        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,\n        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,\n        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,\n        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,\n        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};\n\n    h0 = 0x67452301;\n    h1 = 0xefcdab89;\n    h2 = 0x98badcfe;\n    h3 = 0x10325476;\n\n    \n    \n    \n\n    \n    \n    \n\n    int new_len;\n    for(new_len = initial_len*8 + 1; new_len%512!=448; new_len++);\n    new_len \/= 8;\n\n    msg = calloc(new_len + 64, 1); \n                                   \n    memcpy(msg, initial_msg, initial_len);\n    msg[initial_len] = 128; \n\n    uint32_t bits_len = 8*initial_len; \n    memcpy(msg + new_len, &bits_len, 4);           \n\n    \n    \n    int offset;\n    for(offset=0; offset<new_len; offset += (512\/8)) {\n\n        \n        uint32_t *w = (uint32_t *) (msg + offset);\n\n#ifdef DEBUG\n\/        printf(\"offset: %d %x\\n\", offset, offset);\n\n        int j;\n        for(j =0; j < 64; j++) printf(\"%x \", ((uint8_t *) w)[j]);\n        puts(\"\");\n#endif\n\n        \n        uint32_t a = h0;\n        uint32_t b = h1;\n        uint32_t c = h2;\n        uint32_t d = h3;\n\n        \n        uint32_t i;\n        for(i = 0; i<64; i++) {\n\n#ifdef ROUNDS\n            uint8_t *p;\n            printf(\"%i: \", i);\n            p=(uint8_t *)&a;\n            printf(\"%2.2x%2.2x%2.2x%2.2x \", p[0], p[1], p[2], p[3], a);\n\n            p=(uint8_t *)&b;\n            printf(\"%2.2x%2.2x%2.2x%2.2x \", p[0], p[1], p[2], p[3], b);\n\n            p=(uint8_t *)&c;\n            printf(\"%2.2x%2.2x%2.2x%2.2x \", p[0], p[1], p[2], p[3], c);\n\n            p=(uint8_t *)&d;\n            printf(\"%2.2x%2.2x%2.2x%2.2x\", p[0], p[1], p[2], p[3], d);\n            puts(\"\");\n#endif\n\n\n            uint32_t f, g;\n\n             if (i < 16) {\n                f = (b & c) | ((~b) & d);\n                g = i;\n            } else if (i < 32) {\n                f = (d & b) | ((~d) & c);\n                g = (5*i + 1) % 16;\n            } else if (i < 48) {\n                f = b ^ c ^ d;\n                g = (3*i + 5) % 16;\n            } else {\n                f = c ^ (b | (~d));\n                g = (7*i) % 16;\n            }\n\n#ifdef ROUNDS\n            printf(\"f=%x g=%d w[g]=%x\\n\", f, g, w[g]);\n#endif\n            uint32_t temp = d;\n            d = c;\n            c = b;\n\n            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);\n            a = temp;\n\n\n\n        }\n\n        \n\n        h0 += a;\n        h1 += b;\n        h2 += c;\n        h3 += d;\n\n    }\n\n    \n    free(msg);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void){\n    FILE *fp;\n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    char current_char, next_char;       \n    long answer = 0;                        \n\n    \n    while((next_char = fgetc(fp)) != EOF) {\n        if(current_char == next_char){\n            answer += (current_char - '0'); \n        }\n\n        current_char = next_char;\n    }\n\n    \n    \n    fseek(fp, 0, SEEK_SET);\n    current_char = fgetc(fp);\n    fseek(fp, -1, SEEK_END);\n    next_char = fgetc(fp);\n\n    if(current_char == next_char){\n        answer += (current_char - '0');\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    fclose(fp);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void){\n    long answer = 0;\n    int small_nr = 99999, large_nr = 0, curr_number_int = 0;\n\n    FILE * fp_data;\n    if(!(fp_data = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    char * data_read = NULL, * curr_number;\n    size_t len = 0;\n    ssize_t read;\n\n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        \n        curr_number = strtok(data_read, \"\\t\");\n        while(curr_number != NULL){\n            curr_number_int = atoi(curr_number);\n            \n            \n            if(curr_number_int < small_nr){\n                small_nr = curr_number_int;\n            }\n            if(curr_number_int > large_nr){\n                large_nr = curr_number_int;\n            }\n            curr_number = strtok(NULL, \"\\t\");\n        }\n\n        answer += (large_nr - small_nr);\n        small_nr = 99999;\n        large_nr = 0;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    free(curr_number);\n    fclose(fp_data);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint input = 347991;\n\nvoid check_end(int * i, int * col, int * row){\n    if(*i == input){\n        printf(\"answer=%d (%d, %d)\\n\", (abs(*col) + abs(*row)), *col, *row);\n        exit(EXIT_SUCCESS);\n    }\n}\n\nint main(void){\n    int current_ring_multiplier = 1;\n    int col = 1, row = 0;\n    int i = 2;\n\n    while(1){\n        \n        for(int j = 0; j < current_ring_multiplier; j++){\n            row++; i++;\n            check_end(&i, &col, &row);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--; i++;\n            check_end(&i, &col, &row);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row--; i++;\n            check_end(&i, &col, &row);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++; i++;\n            check_end(&i, &col, &row);\n        }\n\n        \n        current_ring_multiplier += 2;\n        col++; i++;\n        check_end(&i, &col, &row);\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define STEP_SIZE 301\n#define TOTAL_LEN 2018\nint array[TOTAL_LEN];\n\nint main(void){\n    int curr_nr = 0, curr_pos = 0;\n\n    while(curr_nr < TOTAL_LEN - 1){\n        for(int i = 0; i < STEP_SIZE; i++){\n            if(curr_pos < curr_nr){\n                curr_pos++;\n            }\n            else{\n                curr_pos = 0;\n            }\n        }\n        curr_pos++;\n\n        \n        for(int i = curr_nr; i > curr_pos; i--){\n            array[i] = array[i - 1];\n        }\n\n        curr_nr++;\n        array[curr_pos] = curr_nr;\n    }\n\n    printf(\"answer=%d\\n\", array[curr_pos + 1]);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define GRID_SIZE 1000\n\nint grid[GRID_SIZE][GRID_SIZE]; \n\nint parse_data(void); \n\n\nvoid print_square(void){\n    for(int i = 0; i < GRID_SIZE; i++){\n        for(int j = 0; j < GRID_SIZE; j++){\n            (grid[i][j] == 0) ? printf(\". \") : printf(\"# \");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main(void){\n    int true_grid_size = parse_data();\n\n    int row = GRID_SIZE\/2 - 1 + true_grid_size\/2, col = GRID_SIZE\/2 - 1 + true_grid_size\/2;\n    int direction = 0; \n    int nr_infected = 0;\n\n    for(int steps = 0; steps < 10000; steps++){\n        if(grid[row][col] == 0){ \n            \n            (direction > 0) ? (direction--) : (direction = 3);\n\n            \n            nr_infected++;\n            grid[row][col] = 1;\n        }\n        else{ \n            \n            (direction < 3) ? (direction++) : (direction = 0);\n\n            \n            grid[row][col] = 0;\n        }\n\n        \n        switch(direction){\n            case 0 : \n                row--;\n                break;\n            case 1 : \n                col++;\n                break;\n            case 2 : \n                row++;\n                break;\n            case 3 : \n                col--;\n                break;\n        }\n    }\n\n    printf(\"answer=%d\\n\", nr_infected);\n    return EXIT_SUCCESS;\n}\n\nint parse_data(void){\n    FILE *fp;\n\n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    int curr_x = GRID_SIZE\/2 - 1, curr_y = GRID_SIZE\/2 - 1;\n    char c;\n    while( (c = fgetc(fp)) != EOF ){\n        switch(c){\n            case '.' :\n                grid[curr_y][curr_x] = 0;\n                curr_x++;\n                break;\n            case '#' :\n                grid[curr_y][curr_x] = 1;\n                curr_x++;\n                break;\n            case '\\n' :\n                curr_y++;\n                curr_x = GRID_SIZE\/2 - 1;\n                break;\n        }\n    }\n\n    \n    fclose(fp);\n\n    return (curr_y - GRID_SIZE\/2 + 1);\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define NR_OF_COLS 16\n\nint main(void){\n    long answer = 0;\n    int numbers[NR_OF_COLS], numbers_index = 0;\n\n    FILE * fp_data;\n    if(!(fp_data = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    char * data_read = NULL, * curr_number;\n    size_t len = 0;\n    ssize_t read;\n\n    while((read = getline(&data_read, &len, fp_data)) != -1){\n        \n        \n        curr_number = strtok(data_read, \"\\t\");\n        while(curr_number != NULL){\n            numbers[numbers_index] = atoi(curr_number);\n            numbers_index++;\n            curr_number = strtok(NULL, \"\\t\");\n        }\n\n        numbers_index = 0;\n\n        \n        for(int i = 0; i < NR_OF_COLS; i++){\n            for(int j = i + 1; j < NR_OF_COLS; j++){\n                if(numbers[i] % numbers[j] == 0){\n                    answer += (numbers[i] \/ numbers[j]);\n                    break;\n                }\n                else if(numbers[j] % numbers[i] == 0){\n                    answer += (numbers[j] \/ numbers[i]);\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    free(curr_number);\n    fclose(fp_data);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 1001\n\nint input = 347991;\nint grid[SIZE][SIZE];\n\n\nint get_value(int * row, int * col){\n    int value = 0;\n\n    \n    for(int i = *row - 1; i <= *row + 1; i++){\n        for(int j = *col - 1; j <= *col + 1; j++){\n            value += grid[i][j];\n        }\n    }\n\n    \n    if(value > input){\n        printf(\"answer=%d\\n\", value);\n        exit(EXIT_SUCCESS);\n    }\n\n    return value;\n}\n\n\nint main(void){\n    \n    for(int i = 0; i < SIZE; i++){\n        for(int j = 0; j < SIZE; j++){\n            grid[i][j] = 0;\n        }\n    }\n\n    int col = (SIZE - 1) \/ 2, row = (SIZE - 1) \/ 2;\n    int current_ring_multiplier = 1;\n    grid[row][col] = 1;\n\n    while(1){\n        \n        col++;\n        grid[row][col] = get_value(&row, &col);\n\n        \n        for(int j = 0; j < current_ring_multiplier; j++){\n            row--;\n            grid[row][col] = get_value(&row, &col);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--;\n            grid[row][col] = get_value(&row, &col);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row++;\n            grid[row][col] = get_value(&row, &col);\n        }\n\n        \n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++;\n            grid[row][col] = get_value(&row, &col);\n        }\n\n        \n        current_ring_multiplier += 2;\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nlong answer = 0;\nchar * data_read = NULL;\nsize_t len; ssize_t read;\nFILE *fp;\n\nchar *pass[50];\n\nint is_anagram(char *first_string, char *second_string){\n    int first_char_counter[256] = {0}, second_char_counter[256] = {0};\n    int counter;\n\n    \n    if(strlen(first_string) != strlen(second_string)){\n        return 0;\n    }\n\n    \n    for(counter = 0; first_string[counter] != '\\0'; counter++){\n      first_char_counter[first_string[counter]]++;\n    }\n\n    \n    for(counter = 0; second_string[counter] != '\\0'; counter++){\n      second_char_counter[second_string[counter]]++;\n    }\n\n    \n    for(counter = 0; counter < 256; counter++){\n        if(first_char_counter[counter] != second_char_counter[counter])\n            return 0;\n    }\n    return 1;\n}\n\nint main(void){\n    int i = 0, j = 0;\n    int not_valid_flag = 0;\n\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        pass[i] = strtok(data_read, \" \");\n        while(data_read != NULL){\n            data_read = strtok(NULL, \" \");\n            i++;\n            pass[i] = data_read;\n        }\n\n        i = 0;\n        while(pass[i] != NULL){\n            j = i + 1;\n\n            while(pass[j] != NULL){             \n                if(is_anagram(pass[i], pass[j]) == 1){\n                    not_valid_flag = 1;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        if(not_valid_flag == 0){\n            answer++;\n        }\n\n        not_valid_flag = 0;\n        i = 0;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    fclose(fp);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nlong answer = 0;\nint input[1001];\nchar * data_read = NULL;\nsize_t len; ssize_t read;\nFILE *fp;\n\nint main(void){\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    \n    int current_line = 0;\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n        input[current_line] = atoi(data_read);\n        current_line++;\n    }\n\n    int next_pos = 0;\n    int input_len = current_line;\n    int current_pos = 0;\n\n    while(next_pos < input_len){\n        next_pos += input[current_pos];\n        input[current_pos] < 3 ? input[current_pos]++ : input[current_pos]--;\n        answer++;\n        current_pos = next_pos;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    fclose(fp);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n    long a = 722, b = 354;\n    char a_hex[100], b_hex[100];\n    int answer = 0;\n\n    for(int i = 0; i < 5000000; i++){\n        do{\n            a *= 16807;\n            a = a % 2147483647;\n        }while(a % 4 != 0);\n\n        do{\n            b *= 48271;\n            b = b % 2147483647;\n        }while(b % 8 != 0);\n\n        sprintf(a_hex, \"%020X\", (int) a);\n        sprintf(b_hex, \"%020X\", (int) b);\n\n        int diff_flag = 0;\n        for(int i = 16; i < 20; i++){\n            if(a_hex[i] != b_hex[i]){\n                diff_flag = 1;\n            }\n        }\n\n        (diff_flag == 0) ? (answer++) : (diff_flag = 0);\n    }\n\n    printf(\"answer=%d\\n\", answer);\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define GRID_SIZE 1000\n#define NR_OF_BURSTS 10000000\n\nint grid[GRID_SIZE][GRID_SIZE]; \n\nint parse_data(void); \nvoid print_square(void);\n\nint main(void){\n    int true_grid_size = parse_data();\n\n    int row = GRID_SIZE\/2 - 1 + true_grid_size\/2, col = GRID_SIZE\/2 - 1 + true_grid_size\/2;\n    int direction = 0; \n    int nr_infected = 0;\n\n    for(int steps = 0; steps < NR_OF_BURSTS; steps++){\n        \n        switch(grid[row][col]){\n            case 0 : \n                (direction > 0) ? (direction--) : (direction = 3);\n                break;\n            case 1 : \n                break;\n            case 2 : \n                (direction < 3) ? (direction++) : (direction = 0);\n                break;\n            case 3 : \n                switch(direction){\n                    case 0 :\n                        direction = 2;\n                        break;\n                    case 1 :\n                        direction = 3;\n                        break;\n                    case 2 :\n                        direction = 0;\n                        break;\n                    case 3 :\n                        direction = 1;\n                        break;\n                }\n                break;\n        }\n\n        \n        switch(grid[row][col]){\n            case 0 : \n                grid[row][col]++;\n                break;\n            case 1 : \n                grid[row][col]++;\n                nr_infected++;\n                break;\n            case 2 : \n                grid[row][col]++;\n                break;\n            case 3 : \n                grid[row][col] = 0;\n                break;\n        }\n\n        \n        switch(direction){\n            case 0 : \n                row--;\n                break;\n            case 1 : \n                col++;\n                break;\n            case 2 : \n                row++;\n                break;\n            case 3 : \n                col--;\n                break;\n        }\n    }\n\n    printf(\"answer=%d\\n\", nr_infected);\n    return EXIT_SUCCESS;\n}\n\nvoid print_square(void){\n    for(int i = 0; i < GRID_SIZE; i++){\n        for(int j = 0; j < GRID_SIZE; j++){\n            switch(grid[i][j]){\n                case 0 : \n                    printf(\". \");\n                    break;\n                case 1 : \n                    printf(\"W \");\n                    break;\n                case 2 : \n                    printf(\"# \");\n                    break;\n                case 3 : \n                    printf(\"F \");\n                    break;\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint parse_data(void){\n    FILE *fp;\n\n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    int curr_x = GRID_SIZE\/2 - 1, curr_y = GRID_SIZE\/2 - 1;\n    char c;\n    while( (c = fgetc(fp)) != EOF ){\n        switch(c){\n            case '.' :\n                grid[curr_y][curr_x] = 0;\n                curr_x++;\n                break;\n            case '#' :\n                grid[curr_y][curr_x] = 2;\n                curr_x++;\n                break;\n            case '\\n' :\n                curr_y++;\n                curr_x = GRID_SIZE\/2 - 1;\n                break;\n        }\n    }\n\n    \n    fclose(fp);\n\n    return (curr_y - GRID_SIZE\/2 + 1);\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nlong answer = 0;\nchar * data_read = NULL;\nsize_t len; ssize_t read;\nFILE *fp;\n\nchar *pass[50];\n\nint main(void){\n    int i = 0, j = 0;\n    int not_valid_flag = 0;\n\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        pass[i] = strtok(data_read, \" \");\n        while(data_read != NULL){\n            data_read = strtok(NULL, \" \");\n            i++;\n            pass[i] = data_read;\n        }\n\n        i = 0;\n        while(pass[i] != NULL){\n            j = i + 1;\n            \n            while(pass[j] != NULL){\n                if(strcmp(pass[i], pass[j]) == 0){\n                    not_valid_flag = 1;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        if(not_valid_flag == 0){\n            answer++;\n        }\n\n        not_valid_flag = 0;\n        i = 0;\n    }\n\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    fclose(fp);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nlong answer = 0;\nint input[1001];\nchar * data_read = NULL;\nsize_t len; ssize_t read;\nFILE *fp;\n\nint main(void){\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    \n    \n    int current_line = 0;\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n        input[current_line] = atoi(data_read);\n        current_line++;\n    }\n\n    int next_pos = 0;\n    int input_len = current_line;\n    int current_pos = 0;\n\n    while(next_pos < input_len){\n        next_pos += input[current_pos];\n        input[current_pos]++;\n        answer++;\n        current_pos = next_pos;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n\n    free(data_read);\n    fclose(fp);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NR 10000\n#define NR_OF_BANKS 16\nint input[NR_OF_BANKS] = {4, 1, 15, 12, 0, 9, 9, 5, 5, 8, 7, 3, 14, 5, 12, 3};\n\nint answers[MAX_NR][NR_OF_BANKS];\n\nint main(void){\n    int redistr_index, highest_nr_of_blocks = 0;\n\n    \n    for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){\n        answers[0][bank_index] = input[bank_index];\n    }\n\n    \n    for(int step = 1; step < MAX_NR; step++){\n        \n        for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){\n            if(input[bank_index] > highest_nr_of_blocks){\n                redistr_index = bank_index;\n                highest_nr_of_blocks = input[bank_index];\n            }\n        }\n\n        \n        input[redistr_index] = 0;\n\n        \n        for(int i = 0; i < highest_nr_of_blocks; i++){\n            redistr_index < NR_OF_BANKS - 1 ? (redistr_index++) : (redistr_index = 0);\n            input[redistr_index]++;\n        }\n        highest_nr_of_blocks = 0;\n\n        \n        for(int bank_index = 0; bank_index < NR_OF_BANKS; bank_index++){\n            answers[step][bank_index] = input[bank_index];\n        }\n    }\n\n    \n    int duplicate_found = 0;\n    int occurence_found = 0;\n    int occurence_found_index = 0;\n    int q = 0;\n\n    while(occurence_found == 0 && q < MAX_NR){\n        for(int j = q + 1; j < MAX_NR; j++){\n            for(int k = 0; k < NR_OF_BANKS; k++){\n                if(answers[q][k] != answers[j][k]){\n                    duplicate_found = 1;\n                    break;\n                }\n            }\n\n            if(duplicate_found == 0){\n                printf(\"answer pt1=%d\\n\", j);\n                occurence_found = 1;\n                occurence_found_index = j;\n                break;\n            }\n\n            duplicate_found = 0;\n        }\n\n        q++;\n    }\n\n    for(int q = occurence_found_index + 1; q < MAX_NR; q++){\n        for(int k = 0; k < NR_OF_BANKS; k++){\n            if(answers[occurence_found_index][k] != answers[q][k]){\n                duplicate_found = 1;\n                break;\n            }\n        }\n\n        if(duplicate_found == 0){\n            printf(\"answer pt2=%d\\n\", q - occurence_found_index);\n            exit(EXIT_SUCCESS);\n        }\n        duplicate_found = 0;\n    }\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define NR_OF_INPUT 1000\n\nchar * data_read = NULL;\nsize_t len; ssize_t read;\nFILE *fp;\n\nstruct data{\n    char name[100];\n    int value;\n    int highest_value;\n};\n\nstruct data registers[NR_OF_INPUT];\nint nr_of_reg = 0;\n\nvoid parse_data(void);\n\nint main(void){\n    parse_data();\n\n    rewind(fp);\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        char * pch, reg_to_manipulate[100], reg_with_condition[100];\n        int inc_or_dec; \n        int inc_dec_nr;\n        int condition; \n        int condition_nr;\n\n        \n        pch = strtok(data_read, \" \");\n        strcpy(reg_to_manipulate, pch);\n\n        \n        pch = strtok(NULL, \" \");\n        (strncmp(pch, \"inc\", 3) == 0) ? (inc_or_dec = 0) : (inc_or_dec = 1);\n\n        \n        pch = strtok(NULL, \" \");\n        inc_dec_nr = atoi(pch);\n\n        \n        pch = strtok(NULL, \" \");\n\n        \n        pch = strtok(NULL, \" \");\n        strcpy(reg_with_condition, pch);\n\n        \n        pch = strtok(NULL, \" \");\n        if(strcmp(pch, \"==\") == 0)      condition = 0;\n        else if(strcmp(pch, \"!=\") == 0) condition = 1;\n        else if(strcmp(pch, \"<\")  == 0) condition = 2;\n        else if(strcmp(pch, \"<=\") == 0) condition = 3;\n        else if(strcmp(pch, \">\")  == 0) condition = 4;\n        else if(strcmp(pch, \">=\") == 0) condition = 5;\n\n        \n        pch = strtok(NULL, \" \");\n        condition_nr = atoi(pch);\n\n        \n        int reg_with_condition_index;\n        for(int i = 0; i < nr_of_reg; i++){\n            if(strcmp(registers[i].name, reg_with_condition) == 0){\n                reg_with_condition_index = i;\n                break;\n            }\n        }\n\n        \n        int condition_met_flag = 0;\n        switch(condition){\n            case 0 :\n                if(registers[reg_with_condition_index].value == condition_nr) condition_met_flag = 1;\n                break;\n            case 1 :\n                if(registers[reg_with_condition_index].value != condition_nr) condition_met_flag = 1;\n                break;\n            case 2 :\n                if(registers[reg_with_condition_index].value < condition_nr) condition_met_flag = 1;\n                break;\n            case 3 :\n                if(registers[reg_with_condition_index].value <= condition_nr) condition_met_flag = 1;\n                break;\n            case 4 :\n                if(registers[reg_with_condition_index].value > condition_nr) condition_met_flag = 1;\n                break;\n            case 5 :\n                if(registers[reg_with_condition_index].value >= condition_nr) condition_met_flag = 1;\n                break;\n            default :\n                condition_met_flag = 0;\n                break;\n        }\n\n        \n        if(condition_met_flag == 1){\n            int reg_to_manipulate_index;\n            for(int i = 0; i < nr_of_reg; i++){\n                if(strcmp(registers[i].name, reg_to_manipulate) == 0){\n                    reg_to_manipulate_index = i;\n                    break;\n                }\n            }\n\n            if(inc_or_dec == 0){ \n                registers[reg_to_manipulate_index].value += (inc_dec_nr);\n            }\n            else{ \n                registers[reg_to_manipulate_index].value -= (inc_dec_nr);\n            }\n\n            if(registers[reg_to_manipulate_index].value > registers[reg_to_manipulate_index].highest_value){\n                registers[reg_to_manipulate_index].highest_value = registers[reg_to_manipulate_index].value;\n            }\n        }\n    }\n\n    \n    int answer1 = 0, answer2 = 0;\n    for(int i = 0; i < nr_of_reg; i++){\n        if(registers[i].value > answer1) answer1 = registers[i].value;\n        if(registers[i].highest_value > answer2) answer2 = registers[i].highest_value;\n    }\n\n    printf(\"answer1=%d, answer2=%d\\n\", answer1, answer2);\n\n    free(data_read);\n    fclose(fp);\n    return EXIT_SUCCESS;\n}\n\n\nvoid parse_data(void){\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    \n    \n    int curr_line = 0;\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n\n        \n        char * pch = NULL;\n        pch = strchr(data_read, ' ');\n\n        char dummy[100];\n        strncpy(dummy, data_read, pch - data_read);\n        dummy[pch - data_read] = '\\0';\n\n        int duplicate_flag = 0;\n        for(int i = 0; i < nr_of_reg; i++){\n            if(strcmp(registers[i].name, dummy) == 0){\n                duplicate_flag = 1;\n            }\n        }\n        if(duplicate_flag != 1){\n            strcpy(registers[nr_of_reg].name, dummy);\n            nr_of_reg++;\n        }\n\n        curr_line++;\n    }\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n    int answer1 = 0, answer2 = 0, curr_level = 1;\n    FILE *fp;\n\n    int garbage_flag = 0;\n\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    char c;\n    while((c = fgetc(fp)) != EOF){\n        if(garbage_flag == 0){\n            switch(c){\n                case '{' :\n                    answer1 += curr_level;\n                    curr_level++;\n                    break;\n                case '}' :\n                    curr_level--;\n                    break;\n                case '<' :\n                    garbage_flag = 1;\n                    break;\n                case '!' :\n                    fgetc(fp); \n                    break;\n            }\n        }\n        else{\n            switch(c){\n                case '>' :\n                    garbage_flag = 0;\n                    break;\n                case '!' :\n                    fgetc(fp); \n                    break;\n                default :\n                    answer2++;\n            }\n        }\n    }\n\n    printf(\"answer1=%d\\nanswer2=%d\\n\", answer1, answer2);\n\n    fclose(fp);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint distance(int, int, int);\nvoid move(char *);\nvoid parse_data(void);\n\n\nint x = 0, y = 0, z = 0;\nint max_distance = 0;\n\n\nint main(void){\n    parse_data();\n    printf(\"d=%d, max_d=%d\\n\", distance(x, y, z), max_distance);\n\n    return EXIT_SUCCESS;\n}\n\nint distance(int x, int y, int z){\n    return (abs(x) + abs(y) + abs(z))\/2;\n}\n\nvoid move(char * command){\n    if(strncmp(command, \"n\\0\", 2) == 0){\n        y++;\n        z--;\n    }\n    else if(strncmp(command, \"ne\", 2) == 0){\n        x++;\n        z--;\n    }\n    else if(strncmp(command, \"se\", 2) == 0){\n        x++;\n        y--;\n\n    }\n    else if(strncmp(command, \"s\\0\", 2) == 0){\n        y--;\n        z++;\n    }\n    else if(strncmp(command, \"sw\", 2) == 0){\n        x--;\n        z++;\n    }\n    else if(strncmp(command, \"nw\", 2) == 0){\n        x--;\n        y++;\n    }\n}\n\nvoid parse_data(void){\n    FILE *fp;\n\n    \n    if(!(fp = fopen(\"data\", \"r\"))){\n        fprintf(stderr, \"Error opening file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char * data_read = NULL;\n    size_t len; ssize_t read;\n    while((read = getline(&data_read, &len, fp)) != -1){\n        data_read[strcspn(data_read, \"\\r\\n\")] = 0;  \n        char * pch;\n        pch = data_read;\n\n        pch = strtok(pch, \",\");\n        while(pch != NULL){\n            move(pch);\n            if(distance(x, y, z) > max_distance) max_distance = distance(x, y, z);\n            pch = strtok(NULL, \",\");\n        }\n    }\n\n    free(data_read);\n    fclose(fp);\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n    long a = 722, b = 354;\n    char a_hex[100], b_hex[100];\n    int answer = 0;\n\n    for(int i = 0; i < 40000000; i++){\n        a *= 16807;\n        b *= 48271;\n\n        a = a % 2147483647;\n        b = b % 2147483647;\n\n        sprintf(a_hex, \"%020X\", (int) a);\n        sprintf(b_hex, \"%020X\", (int) b);\n\n        int diff_flag = 0;\n        for(int i = 16; i < 20; i++){\n            if(a_hex[i] != b_hex[i]){\n                diff_flag = 1;\n            }\n        }\n\n        (diff_flag == 0) ? (answer++) : (diff_flag = 0);\n    }\n\n    printf(\"answer=%d\\n\", answer);\n\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h> \n\n\n\nint main(void){\n    long input = 600851475143;\n    int i;\n\n\n    \n    while(input%2 == 0){\n        printf(\"%d \", 2);\n        input = input\/2;\n    }\n\n    \n    for(i = 3; i <= sqrt(input); i += 2){\n        while(input%i == 0){\n            printf(\"%d \", i);\n            input = input\/i;\n        }\n    }\n\n    \n    if (input > 2) printf (\"%ld \", input);\n    printf(\"\\n\");\n    \n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(void){\n    int i = 1, j, sum = 0, nr_of_divisors = 0;\n\n    while(1){\n        \n        for(j = 1; j <= i; j++){\n            sum += j;\n        }\n\n        \n        for(j = 1; j <= sum; j++){\n            if(sum % j == 0) nr_of_divisors++;\n        }\n\n        \n        if(nr_of_divisors > 500){\n            printf(\"answer=%d (nr=%d, nr_div=%d)\\n\", sum, i, nr_of_divisors);\n            break;\n        }\n\n        printf(\"(%10d) %d\\n\", i, nr_of_divisors);\n\n        i++;\n        sum = 0;\n        nr_of_divisors = 0;\n    }\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\nint main(void){\n    unsigned long long answer = 0;\n    unsigned long long input[100] = {\n        37107287533902,\n        46376937677490,\n        74324986199524,\n        91942213363574,\n        23067588207539,\n        89261670696623,\n        28112879812849,\n        44274228917432,\n        47451445736001,\n        70386486105843,\n        62176457141856,\n        64906352462741,\n        92575867718337,\n        58203565325359,\n        80181199384826,\n        35398664372827,\n        86515506006295,\n        71693888707715,\n        54370070576826,\n        53282654108756,\n        36123272525000,\n        45876576172410,\n        17423706905851,\n        81142660418086,\n        51934325451728,\n        62467221648435,\n        15732444386908,\n        55037687525678,\n        18336384825330,\n        80386287592878,\n        78182833757993,\n        16726320100436,\n        48403098129077,\n        87086987551392,\n        59959406895756,\n        69793950679652,\n        41052684708299,\n        65378607361501,\n        35829035317434,\n        94953759765105,\n        88902802571733,\n        25267680276078,\n        36270218540497,\n        24074486908231,\n        91430288197103,\n        34413065578016,\n        23053081172816,\n        11487696932154,\n        63783299490636,\n        67720186971698,\n        95548255300263,\n        76085327132285,\n        37774242535411,\n        23701913275725,\n        29798860272258,\n        18495701454879,\n        38298203783031,\n        34829543829199,\n        40957953066405,\n        29746152185502,\n        41698116222072,\n        62467957194401,\n        23189706772547,\n        86188088225875,\n        11306739708304,\n        82959174767140,\n        97623331044818,\n        42846280183517,\n        55121603546981,\n        32238195734329,\n        75506164965184,\n        62177842752192,\n        32924185707147,\n        99518671430235,\n        73267460800591,\n        76841822524674,\n        97142617910342,\n        87783646182799,\n        10848802521674,\n        71329612474782,\n        62184073572399,\n        66627891981488,\n        60661826293682,\n        85786944089552,\n        66024396409905,\n        64913982680032,\n        16730939319872,\n        94809377245048,\n        78639167021187,\n        15368713711936,\n        40789923115535,\n        44889911501440,\n        41503128880339,\n        81234880673210,\n        82616570773948,\n        22918802058777,\n        77158542502016,\n        72107838435069,\n        20849603980134,\n        53503534226472\n    };\n\n    int i;\n    for(i = 0; i < 100; i++){\n        answer += input[i];\n    }\n    printf(\"answer=%lld\\n\", answer);\n\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h> \n#include <stdbool.h>\n\n\nint main(void){\n    int num1, num2, product, i, str_len, answer;\n    char numb_str[18];\n    bool palindromic = true;\n\n    for(num1 = 0; num1 < 1000; num1++){\n        for(num2 = 0; num2 < 1000; num2++){\n            product = num1 * num2;\n\n            \n            sprintf(numb_str, \"%d\", product);\n            str_len = strlen(numb_str);\n\n            \n            for(i = 0; i < str_len \/ 2; i++){\n                if(numb_str[i] != numb_str[str_len - 1 - i]){\n                    palindromic = false;\n                    break;\n                }\n            }\n\n            \n            \n            if(palindromic && product > answer){\n                answer = product;\n            }\n\n            palindromic = true;\n        }\n    }\n    \n    printf(\"answer=%d\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main(void){\n    long answer = 1;\n    int div_nr;\n    bool div_by_nr = true;\n\n    while(1){\n        \n        for(div_nr = 1; div_nr <= 20; div_nr++){\n            if(answer % div_nr != 0){\n                div_by_nr = false;\n                break;\n            }\n        }\n\n        \n        if(div_by_nr){\n            break;\n        }\n\n        div_by_nr = true;\n        answer++;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define NR_PRIME 10001\n\n\nint main(void){\n    long answer = 1;\n    int nr_of_primes_found = 0, i;\n    bool is_prime = true;\n\n    while(1){\n\n        \n        for(i = 2; i <= answer\/2; i++){\n            if(answer % i == 0){\n                is_prime = false;\n                break;\n            }\n        }\n\n        \n        if(is_prime){\n            nr_of_primes_found++;\n\n            \n            if(nr_of_primes_found == NR_PRIME - 1){\n                break;\n            }           \n        }\n\n        is_prime = true;\n        answer++;\n    }\n\n\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n#define nr_of_adjecent 13\n\nint main(void){\n    long answer = 0, product = 1;\n    char input[1001] =  \"73167176531330624919225119674426574742355349194934\"\n                        \"96983520312774506326239578318016984801869478851843\"\n                        \"85861560789112949495459501737958331952853208805511\"\n                        \"12540698747158523863050715693290963295227443043557\"\n                        \"66896648950445244523161731856403098711121722383113\"\n                        \"62229893423380308135336276614282806444486645238749\"\n                        \"30358907296290491560440772390713810515859307960866\"\n                        \"70172427121883998797908792274921901699720888093776\"\n                        \"65727333001053367881220235421809751254540594752243\"\n                        \"52584907711670556013604839586446706324415722155397\"\n                        \"53697817977846174064955149290862569321978468622482\"\n                        \"83972241375657056057490261407972968652414535100474\"\n                        \"82166370484403199890008895243450658541227588666881\"\n                        \"16427171479924442928230863465674813919123162824586\"\n                        \"17866458359124566529476545682848912883142607690042\"\n                        \"24219022671055626321111109370544217506941658960408\"\n                        \"07198403850962455444362981230987879927244284909188\"\n                        \"84580156166097919133875499200524063689912560717606\"\n                        \"05886116467109405077541002256983155200055935729725\"\n                        \"71636269561882670428252483600823257530420752963450\";\n    char solution[nr_of_adjecent + 1] = \"\";\n    int i, j;\n\n\n    for(i = nr_of_adjecent - 1; i < 1000; i++){\n        \n        for(j = nr_of_adjecent - 1; j >= 0; j--){\n            product = (input[i - j] - '0') * product;\n        }\n\n        \n        if(product > answer){\n            answer = product;\n\n            \n            for(j = 0; j < nr_of_adjecent; j++){\n                solution[j] = input[i - nr_of_adjecent + 1 + j];\n            }\n        }\n\n        product = 1;\n    }\n\n    printf(\"answer=%ld (%s)\\n\", answer, solution);\n    return EXIT_SUCCESS;\n}"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n\nint main(void){\n    int i, j;\n    long answer = 0;\n    bool is_prime = true;\n\n\n    for(i = 2; i < 2000000; i++){\n        \n        for(j = 2; j <= i\/2; j++){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n\n        if(is_prime){\n            answer += i;\n        }\n\n        is_prime = true;\n    }\n\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}\n"}
{"target":"theuwis","func":"#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(void){\n    int answer = 0, i, j;\n    int product = 1;\n\n    int input[20][20] = {\n        { 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8},\n        {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0},\n        {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65},\n        {52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91},\n        {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},\n        {24, 47, 32, 60, 99, 03, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},\n        {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},\n        {67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21},\n        {24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},\n        {21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95},\n        {78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92},\n        {16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57},\n        {86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},\n        {19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40},\n        { 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},\n        {88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},\n        { 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36},\n        {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16},\n        {20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54},\n        { 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48}\n    };\n\n    \n    for(i = 0; i < 20; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j] * input[i][j + 1] * input[i][j + 2] * input[i][j + 3];\n            if(product > answer) answer = product;\n        }\n    }\n\n    \n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 20; j++){\n            product = input[i][j] * input[i + 1][j] * input[i + 2][j] * input[i + 3][j];\n            if(product > answer) answer = product;\n        }\n    }\n\n    \n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j] * input[i + 1][j + 1] * input[i + 2][j + 2] * input[i + 3][j + 3];\n            if(product > answer) answer = product;  \n        }\n    }\n\n    \n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j + 3] * input[i + 1][j + 2] * input[i + 2][j + 1] * input[i + 3][j];\n            if(product > answer) answer = product;  \n        }\n    }\n\n    printf(\"answer=%d\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"target":"TSN-SHINGENN","func":"#if defined(WIN32) || 1\n\n#define _CRT_SECURE_NO_WARNINGS\n#if _MSC_VER >= 1400            \n#pragma warning ( disable:4996 )\n#pragma warning ( disable:4819 )\n#endif\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"mddl_printf.h\"\n\nstatic int putch(int code)\n{\n    return fputc(code, stdout);\n}\n\n\nint\nmain(int ac, char **av)\n{\n    int a = 12345, b = 987654;\n    int len;\n    char C = 'C';\n    const char *txt=\"chat put acbde\";\n    size_t n;\n    char buf[128];\n\n    double d[] = {\n        0.0,\n        42.0,\n        1234567.89012345,\n        0.000000000000018,\n        555555.55555555555555555,\n        -888888888888888.8888888,\n        111111111111111111111111.2222222222\n    };\n\n    mddl_printf_init(putch);\n\n    for(n=0;n<100;n++) {\n        len = sprintf(buf, \"%% %d %c %d %s %d buf=%p\\n\", a, (int)n, b, txt, a, buf);\n    printf(\"sprintf=%s\",buf);\n    printf(\"len=%llu\\n\", (unsigned long long)len);\n\n        len = mddl_printf(\"%% %d %c %d %s %d buf=%p\\n\", a, (int)n, b, txt, a, buf);\n    mddl_printf(\"len=%llu\\n\", (unsigned long long)len);\n\n    len = sprintf(buf, \"%f %f %f\\n\", d[0], d[1], d[2]);\n    printf(\"float sprintf=%s\",buf);\n    printf(\"len=%d\\n\", len);\n\n        len = mddl_printf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n    printf(\"len=%d\\n\", len);\n    }\n\n    return 0;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include \"mddl_mallocater.h\"\n#include \"mddl_malloc.h\"\n\n#ifdef DEBUG\nstatic int debuglevel = 2;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#define EOL_CRLF \"\\n\\r\"\n\n\nint mddl_malloc_align(void **memptr, const size_t alignment,\n             const size_t size)\n{\n    int result;\n    const size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;\n    void *mem = NULL;\n    uint8_t *aligned_mem = NULL;\n\n    DBMS5(\"%s : execute\" EOL_CRLF, __func__);\n    if ((a % 2) || (size == 0) || (NULL == memptr)) {\n    result = errno = EINVAL;\n    } else {\n    const size_t total = size + sizeof(void *) + (a - 1);\n    mem = malloc(total);\n    if (NULL == mem) {\n        result = errno;\n    } else {\n        uintptr_t offs;\n\n        IFDBG5THEN {\n        DBMS5(\"%s : malloc = 0x%p total=%llu  alignment=%llu size=%llu\" EOL_CRLF,\n            __func__, mem, (unsigned long long)total,(unsigned long long)alignment, (unsigned long long)size);\n        }\n\n        \n        aligned_mem = ((uint8_t *) mem + sizeof(void *));\n        offs = (uintptr_t) a - ((uintptr_t) aligned_mem & (a - 1));\n\n        IFDBG5THEN {\n        DBMS5(\n          \"%s : a-1=0x%llx offs=0x%llu\" EOL_CRLF,\n            __func__, (uintptr_t)a-1, offs);\n        }\n\n        aligned_mem += offs;\n\n        IFDBG5THEN {\n        DBMS5( \"%s : aligned_mem = 0x%p\" EOL_CRLF, __func__, aligned_mem);\n        }\n\n        \n        ((void **) aligned_mem)[-1] = mem;\n\n        *memptr = aligned_mem;\n        result = 0;\n    }\n    }\n\n    return result;\n}\n\n\nvoid *mddl_realloc_align(void *memblk, const size_t alignment,\n                const size_t size)\n{\n    int result;\n    void *mem;\n    result = mddl_malloc_align(&mem, alignment, size);\n    if (result) {\n    return NULL;\n    }\n    memcpy(mem, memblk, size);\n    mddl_mfree(memblk);\n    return mem;\n}\n\n\nint mddl_mfree(void *memptr)\n{\n    \n    mddl_free(((void **) memptr)[-1]);\n    return 0;\n}\n\n\nvoid *mddl_mrealloc_align(void *memblock, const size_t alignment,\n                 const size_t size)\n{\n    size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;\n    int result;\n    void *mem = NULL;\n    uint8_t *aligned_mem = NULL;\n\n    DBMS5( \"%s : execute\" EOL_CRLF, __func__);\n    if (NULL == memblock) {\n    void *memptr = NULL;\n    result = mddl_malloc_align(&memptr, a, size);\n    return (result == 0) ? memptr : NULL;\n    } else if ((a % 2) || (size == 0)) {\n    errno = EINVAL;\n    return NULL;\n    } else {\n    mem =\n        mddl_realloc(((void **) memblock)[-1],\n            size + (a - 1) + sizeof(void *));\n    if (NULL == mem) {\n        return NULL;\n    } else {\n        aligned_mem = ((uint8_t *) mem + sizeof(void *));\n        aligned_mem += ((uintptr_t) aligned_mem & (a - 1));\n        ((void **) aligned_mem)[-1] = mem;\n    }\n    }\n\n    return aligned_mem;\n}\n\n\nmddl_mem_alignment_partition_t mddl_mem_alignment_partition(int\n                                  *const\n                                  result_p,\n                                  const\n                                  void\n                                  *const p,\n                                  size_t\n                                  size,\n                                  size_t\n                                  alignment)\n{\n    mddl_mem_alignment_partition_t part;\n    uintptr_t a = (uintptr_t) p;\n    const size_t align_mask = (alignment - 1);\n\n    memset(&part, 0x0, sizeof(mddl_mem_alignment_partition_t));\n    part.total_sz = size;\n    part.alignment_sz = alignment;\n\n    if (size < alignment) {\n    part.foward_sz = size;\n    } else {\n    part.ext.f.size_is_multiple_alignment =\n        (size & align_mask) ? 0 : 1;\n    part.foward_sz = (a & align_mask);\n    if (!part.foward_sz) {\n        part.ext.f.is_aligned = 1;\n    } else {\n        part.foward_sz = alignment - part.foward_sz;\n        size -= part.foward_sz;\n        part.ext.f.is_aligned = 0;\n    }\n\n    if (size != 0) {\n        part.bottom_sz = (size & align_mask);\n        part.middle_sz = size - part.bottom_sz;\n    }\n    }\n\n    if (NULL != result_p) {\n    *result_p = 0;\n    }\n\n    return part;\n}\n\n\nvoid *mddl_malloc(const size_t size)\n{\n    return mddl_mallocater_alloc(size);\n}\n\n\nvoid mddl_free( void *const ptr)\n{\n    mddl_mallocater_free(ptr);\n}\n\n\n\nvoid *mddl_realloc( void *const ptr, const size_t size)\n{\n    return mddl_mallocater_realloc(ptr, size);\n}\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include \"mddl_mallocater.h\"\n#include \"mddl_malloc.h\"\n\n#ifdef DEBUG\nstatic int debuglevel = 2;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#define EOL_CRLF \"\\n\\r\"\n\n\nint mddl_malloc_align(void **memptr, const size_t alignment,\n             const size_t size)\n{\n    int result;\n    const size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;\n    void *mem = NULL;\n    uint8_t *aligned_mem = NULL;\n\n    DBMS5(\"%s : execute\" EOL_CRLF, __func__);\n    if ((a % 2) || (size == 0) || (NULL == memptr)) {\n    result = errno = EINVAL;\n    } else {\n    const size_t total = size + sizeof(void *) + (a - 1);\n    mem = mddl_malloc(total);\n    if (NULL == mem) {\n        result = errno;\n    } else {\n        uintptr_t offs;\n\n        IFDBG5THEN {\n        DBMS5(\"%s : mddl_malloc = 0x%p total=%llu  alignment=%llu size=%llu\" EOL_CRLF,\n            __func__, mem, (unsigned long long)total,(unsigned long long)alignment, (unsigned long long)size);\n        }\n\n        \n        aligned_mem = ((uint8_t *) mem + sizeof(void *));\n        offs = (uintptr_t) a - ((uintptr_t) aligned_mem & (a - 1));\n\n        IFDBG5THEN {\n        DBMS5(\n          \"%s : a-1=0x%llx offs=0x%llu\" EOL_CRLF,\n            __func__, (uintptr_t)a-1, offs);\n        }\n\n        aligned_mem += offs;\n\n        IFDBG5THEN {\n        DBMS5( \"%s : aligned_mem = 0x%p\" EOL_CRLF, __func__, aligned_mem);\n        }\n\n        \n        ((void **) aligned_mem)[-1] = mem;\n\n        *memptr = aligned_mem;\n        result = 0;\n    }\n    }\n\n    return result;\n}\n\n\nvoid *mddl_realloc_align(void *memblk, const size_t alignment,\n                const size_t size)\n{\n    int result;\n    void *mem;\n    result = mddl_malloc_align(&mem, alignment, size);\n    if (result) {\n    return NULL;\n    }\n    memcpy(mem, memblk, size);\n    mddl_mfree(memblk);\n    return mem;\n}\n\n\nint mddl_mfree(void *memptr)\n{\n    \n    mddl_free(((void **) memptr)[-1]);\n    return 0;\n}\n\n\nvoid *mddl_mrealloc_align(void *memblock, const size_t alignment,\n                 const size_t size)\n{\n    size_t a = (alignment == 0) ? sizeof(uint64_t) : alignment;\n    int result;\n    void *mem = NULL;\n    uint8_t *aligned_mem = NULL;\n\n    DBMS5( \"%s : execute\" EOL_CRLF, __func__);\n    if (NULL == memblock) {\n    void *memptr = NULL;\n    result = mddl_malloc_align(&memptr, a, size);\n    return (result == 0) ? memptr : NULL;\n    } else if ((a % 2) || (size == 0)) {\n    errno = EINVAL;\n    return NULL;\n    } else {\n    mem =\n        mddl_realloc(((void **) memblock)[-1],\n            size + (a - 1) + sizeof(void *));\n    if (NULL == mem) {\n        return NULL;\n    } else {\n        aligned_mem = ((uint8_t *) mem + sizeof(void *));\n        aligned_mem += ((uintptr_t) aligned_mem & (a - 1));\n        ((void **) aligned_mem)[-1] = mem;\n    }\n    }\n\n    return aligned_mem;\n}\n\n\nmddl_mem_alignment_partition_t mddl_mem_alignment_partition(int\n                                  *const\n                                  result_p,\n                                  const\n                                  void\n                                  *const p,\n                                  size_t\n                                  size,\n                                  size_t\n                                  alignment)\n{\n    mddl_mem_alignment_partition_t part;\n    uintptr_t a = (uintptr_t) p;\n    const size_t align_mask = (alignment - 1);\n\n    memset(&part, 0x0, sizeof(mddl_mem_alignment_partition_t));\n    part.total_sz = size;\n    part.alignment_sz = alignment;\n\n    if (size < alignment) {\n    part.foward_sz = size;\n    } else {\n    part.ext.f.size_is_multiple_alignment =\n        (size & align_mask) ? 0 : 1;\n    part.foward_sz = (a & align_mask);\n    if (!part.foward_sz) {\n        part.ext.f.is_aligned = 1;\n    } else {\n        part.foward_sz = alignment - part.foward_sz;\n        size -= part.foward_sz;\n        part.ext.f.is_aligned = 0;\n    }\n\n    if (size != 0) {\n        part.bottom_sz = (size & align_mask);\n        part.middle_sz = size - part.bottom_sz;\n    }\n    }\n\n    if (NULL != result_p) {\n    *result_p = 0;\n    }\n\n    return part;\n}\n\n\nvoid *mddl_malloc(const size_t size)\n{\n    return mddl_mallocater_alloc(size);\n}\n\n\nvoid mddl_free( void *const ptr)\n{\n    mddl_mallocater_free(ptr);\n}\n\n\n\nvoid *mddl_realloc( void *const ptr, const size_t size)\n{\n    return mddl_mallocater_realloc(ptr, size);\n}\n\n\nvoid mddl_malloc_init(void *const buf, const size_t bufsize)\n{\n    mddl_mallocater_init_obj(&_mddl_mallocater_heap_obj, buf, bufsize);\n}\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"mddl_vsprintf.h\"\n#include \"mddl_printf.h\"\n\nstatic int (*_this_out_method_cb)(int) = NULL;\n\nvoid mddl_printf_init( int (*putchar_cb)(int))\n{\n    _this_out_method_cb = putchar_cb;\n}\n\n\nint mddl_printf(const char *const fmt, ...)\n{\n    int retval;\n    va_list ap;    \n\n    if( _this_out_method_cb == NULL ) {\n    return -1;\n    }\n\n    va_start(ap, fmt); \n    retval = mddl_vsprintf_putchar( _this_out_method_cb, fmt, ap);\n    va_end(ap);\n\n    return retval;\n}\n\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n\n\n#include \"mddl_stl_deque.h\"\n#include \"mddl_stl_list.h\"\n#include \"mddl_stl_slist.h\"\n\n#include \"mddl_stl_queue.h\"\n\n\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#define EOL_CRLF \"\\n\\r\"\n\n\nvoid __attribute__((weak)) *mddl_malloc(const size_t size)\n{\n    return malloc(size);\n}\n\nvoid __attribute__((weak)) mddl_free( void *const ptr )\n{\n    free(ptr);\n}\n\n\ntypedef int(*front_func_t)( void *self_p, void *el_p, const size_t sizof_el);\ntypedef int(*back_func_t)( void *self_p, void *el_p, const size_t sizof_el);\ntypedef int(*push_func_t)(void *self_p, const void *el_p, const size_t sizof_el);\ntypedef int(*pop_func_t)( void *self_p);\ntypedef size_t(*get_pool_cnt_func_t)(void *self_p);\ntypedef int(*is_empty_func_t)(void *self_p);\ntypedef int(*clear_func_t)(void *self_p);\ntypedef int(*get_element_at_func_t)(void *self_p, size_t num, void *el_p, const size_t sizof_el);\n\ntypedef struct _mddl_stl_queue_ext {\n    enum_mddl_stl_queue_implement_type_t implement_type;\n    union {\n    mddl_stl_deque_t deque;\n    mddl_stl_slist_t slist;\n    mddl_stl_list_t list;\n    uint8_t ptr[1];\n    } instance;\n\n    size_t sizof_element;\n    front_func_t front_func;\n    back_func_t back_func;\n    push_func_t push_func;\n    pop_func_t pop_func;\n    get_pool_cnt_func_t get_pool_cnt_func;\n    is_empty_func_t is_empty_func;\n    clear_func_t clear_func;\n    get_element_at_func_t get_element_at_func;\n\n    union {\n    unsigned int flags;\n    struct {\n        unsigned int deque:1;\n        unsigned int slist:1;\n        unsigned int list:1;\n    } f;\n    } init;\n} mddl_stl_queue_ext_t;\n\n#define get_stl_deque_ext(s) (mddl_stl_queue_ext_t*)((s)->ext)\n#define get_stl_const_deque_ext(s) (const mddl_stl_queue_ext_t*)((s)->ext)\n\n\nint mddl_stl_queue_init(mddl_stl_queue_t *const self_p,\n               const size_t sizof_element)\n{\n    return mddl_stl_queue_init_ex( self_p, sizof_element, MDDL_STL_QUEUE_TYPE_IS_DEFAULT, NULL);\n}\n\n\nint mddl_stl_queue_init_ex( mddl_stl_queue_t *const self_p, const size_t sizof_element, const enum_mddl_stl_queue_implement_type_t type, void *const attr_p)\n{\n    int result, status;\n    mddl_stl_queue_ext_t * __restrict e = NULL;\n    const enum_mddl_stl_queue_implement_type_t implement_type = ( type == MDDL_STL_QUEUE_TYPE_IS_DEFAULT ) ? MDDL_STL_QUEUE_TYPE_IS_SLIST : type;\n\n    (void)attr_p;\n    memset( self_p, 0x0, sizeof(mddl_stl_queue_t));\n\n    if(!(sizof_element > 0 )) {\n    return EINVAL;\n    }\n\n    if((implement_type >= MDDL_STL_QUEUE_TYPE_IS_OTHERS) || ( implement_type < MDDL_STL_QUEUE_TYPE_IS_DEFAULT )) {\n    return EINVAL;\n    }\n\n    e = (mddl_stl_queue_ext_t*)mddl_malloc(sizeof(mddl_stl_queue_ext_t));\n    if( NULL == e ) {\n    return EAGAIN;\n    }\n    memset( e, 0x0, sizeof(mddl_stl_queue_ext_t));\n    self_p->ext = e;\n\n    self_p->sizof_element = e->sizof_element = sizof_element;\n\n    switch(implement_type) {\n    case MDDL_STL_QUEUE_TYPE_IS_SLIST:\n    \n    result = mddl_stl_slist_init( &e->instance.slist, sizof_element);\n    if(result) {\n        DBMS1( \"%s : mddl_stl_slist_init fail, streror:%s\" EOL_CRLF, __func__, strerror(result));\n        status = result;\n        goto out;\n    }\n\n    e->front_func = (front_func_t)mddl_stl_slist_front;\n    e->push_func = (push_func_t)mddl_stl_slist_push;\n        e->pop_func = (pop_func_t)mddl_stl_slist_pop;\n        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_slist_get_pool_cnt;\n    e->is_empty_func = (is_empty_func_t)mddl_stl_slist_is_empty;\n    e->clear_func = (clear_func_t)mddl_stl_slist_clear;\n    e->get_element_at_func = (get_element_at_func_t)mddl_stl_slist_get_element_at;\n\n    e->init.f.slist = 1;\n    break;\n    case MDDL_STL_QUEUE_TYPE_IS_DEQUE:\n    \n    result = mddl_stl_deque_init( &e->instance.deque, sizof_element);\n    if(result) {\n        DBMS1( \"%s : mddl_stl_deque_init fail, streror:%s\" EOL_CRLF, __func__, strerror(result));\n        status = result;\n        goto out;\n    }\n\n    e->front_func = (front_func_t)mddl_stl_deque_front;\n    e->push_func = (push_func_t)mddl_stl_deque_push_back;\n        e->pop_func = (pop_func_t)mddl_stl_deque_pop_front;\n        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_deque_get_pool_cnt;\n    e->is_empty_func = (is_empty_func_t)mddl_stl_deque_is_empty;\n    e->clear_func = (clear_func_t)mddl_stl_deque_clear;\n    e->get_element_at_func = (get_element_at_func_t)mddl_stl_deque_get_element_at;\n    \n    e->init.f.deque = 1;\n    break;\n    case MDDL_STL_QUEUE_TYPE_IS_LIST:\n    \n    result = mddl_stl_list_init( &e->instance.list, sizof_element);\n    if(result) {\n        DBMS1( \"%s : mddl_stl_list_init fail, strerror:%s\" EOL_CRLF, __func__, strerror(result));\n        status = result;\n        goto out;\n    }\n\n    e->front_func = (front_func_t)mddl_stl_list_front;\n    e->push_func = (push_func_t)mddl_stl_list_push_back;\n        e->pop_func = (pop_func_t)mddl_stl_list_pop_front;\n        e->get_pool_cnt_func = (get_pool_cnt_func_t)mddl_stl_list_get_pool_cnt;\n    e->is_empty_func = (is_empty_func_t)mddl_stl_list_is_empty;\n    e->clear_func = (clear_func_t)mddl_stl_list_clear;\n    e->get_element_at_func = (get_element_at_func_t)mddl_stl_list_get_element_at;\n    \n    e->init.f.list = 1;\n    break;\n    default:\n    status = ENOSYS;\n    goto out;\n    }\n\n    status = 0;\n\nout:    \n    if(status) {\n        mddl_stl_queue_destroy(self_p);\n    } \n    return status;\n}\n\n\nint mddl_stl_queue_destroy(mddl_stl_queue_t *const self_p)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n    int status, result;\n\n    if( NULL == e ) {\n    return 0;\n    }\n\n    if( e->init.f.deque ) {\n    \n    result = mddl_stl_deque_destroy( &e->instance.deque);\n    if(result) {\n        DBMS1(\"%s : mddl_stl_deque_destroy fail, retval=0x%s\" EOL_CRLF, __func__, result);\n        status = result;\n        goto out;\n    }\n    e->init.f.deque = 0;\n    }\n\n    if( e->init.f.slist ) {\n    \n    result = mddl_stl_slist_destroy( &e->instance.slist);\n    if(result) {\n        DBMS1(\"%s : mddl_stl_slist_destroy fail, retval=0x%s\" EOL_CRLF, __func__, result);\n        status = result;\n        goto out;\n    }\n    e->init.f.slist = 0;\n    }\n\n    if( e->init.f.list ) {\n    \n    result = mddl_stl_list_destroy( &e->instance.list);\n    if(result) {\n        DBMS1(\"%s : mddl_stl_list_destroy fail, retval=0x%s\" EOL_CRLF, __func__, result);\n        status = result;\n        goto out;\n    }\n    e->init.f.list = 0;\n    }\n    \n    status = e->init.flags;\n\nout:\n    if(!status) {\n    mddl_free(e);\n    self_p->ext = NULL;\n    }\n    return status;\n}\n    \n\nint mddl_stl_queue_push(mddl_stl_queue_t *const self_p, const void *const el_p,\n               const size_t sizof_element)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->push_func(e->instance.ptr, el_p, sizof_element);\n}\n\n\nint mddl_stl_queue_pop(mddl_stl_queue_t *const self_p)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->pop_func(e->instance.ptr);\n}\n\n\nint mddl_stl_queue_front(mddl_stl_queue_t *const self_p, void *const el_p,\n                const size_t sizof_element)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->front_func(e->instance.ptr, el_p, sizof_element);\n}\n\n\nint mddl_stl_queue_clear(mddl_stl_queue_t *const self_p)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->clear_func(e->instance.ptr);\n}\n\n\nsize_t mddl_stl_queue_get_pool_cnt(mddl_stl_queue_t *const self_p)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->get_pool_cnt_func(e->instance.ptr);\n}\n\n\nint mddl_stl_queue_is_empty(mddl_stl_queue_t *const self_p)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->is_empty_func(e->instance.ptr);\n}\n\n\nint mddl_stl_queue_get_element_at(mddl_stl_queue_t *const self_p,\n                       const size_t num, void *const el_p,\n                       const size_t sizof_element)\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->get_element_at_func(e->instance.ptr, num, el_p, sizof_element);\n}\n\n\n\nint mddl_stl_queue_back( mddl_stl_queue_t *const self_p, void *const el_p, const size_t sizof_element )\n{\n    mddl_stl_queue_ext_t *const e =\n    (mddl_stl_queue_ext_t *) self_p->ext;\n\n    return e->back_func(e->instance.ptr, el_p, sizof_element);\n}\n\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mddl_stl_slist.h\"\n\n\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n#define EOL_CRLF \"\\n\\r\"\n\nvoid __attribute__((weak)) *mddl_malloc(const size_t size)\n{\n    return malloc(size);\n}\n\nvoid __attribute__((weak)) mddl_free( void *const ptr )\n{\n    free(ptr);\n}\n\ntypedef struct _fifoitem {\n    struct _fifoitem *next;\n    unsigned char data[];\n} fifoitem_t;\n\ntypedef struct _mddl_stl_slist_ext {\n    fifoitem_t *r_p, *w_p;  \n    size_t sizof_element;\n    size_t cnt;\n    fifoitem_t base;        \n} mddl_stl_slist_ext_t;\n\n#define get_stl_slist_ext(s) (mddl_stl_slist_ext_t*)((s)->ext)\n#define get_const_stl_slist_ext(s) (const mddl_stl_slist_ext_t*)((s)->ext)\n\nstatic fifoitem_t *slist_get_foward_element_ptr( const mddl_stl_slist_ext_t *const e, void * const element_ptr);\n\n\nstatic fifoitem_t *slist_get_foward_element_ptr( const mddl_stl_slist_ext_t *const e, void * const element_ptr)\n{\n    fifoitem_t *cur;\n\n    if( (e->cnt == 0) || (e->w_p == &e->base) ) {\n    return NULL;\n    }\n\n    for( cur=e->w_p; cur->next != NULL; cur=cur->next) {\n    if( cur->next == element_ptr ) {\n        return cur;\n    }\n    }\n\n    return NULL;\n}\n\n\n\nint mddl_stl_slist_init(mddl_stl_slist_t *const self_p,\n               const size_t sizof_element)\n{\n    mddl_stl_slist_ext_t *e = NULL;\n    memset(self_p, 0x0, sizeof(mddl_stl_slist_t));\n\n    e = (mddl_stl_slist_ext_t *)\n    mddl_malloc(sizeof(mddl_stl_slist_ext_t));\n    if (NULL == e) {\n    DBMS1(\"%s : mddl_malloc(ext) fail\" EOL_CRLF, __func__);\n    return EAGAIN;\n    }\n    memset(e, 0x0, sizeof(mddl_stl_slist_ext_t));\n\n    self_p->ext = e;\n    self_p->sizof_element = e->sizof_element = sizof_element;\n\n    e->r_p = e->w_p = &e->base;\n\n    return 0;\n}\n\n\nint mddl_stl_slist_destroy(mddl_stl_slist_t *const self_p)\n{\n    int result;\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n\n    result = mddl_stl_slist_clear(self_p);\n    if (result) {\n    DBMS1(\"%s : que_clear fail\" EOL_CRLF, __func__);\n    return EBUSY;\n    }\n\n    \n    if (e->r_p != &e->base) {\n    mddl_free(e->r_p);\n    e->r_p = NULL;\n    }\n\n    mddl_free(self_p->ext);\n    self_p->ext = NULL;\n\n    return 0;\n}\n\n\nint mddl_stl_slist_push(mddl_stl_slist_t *const self_p, const void *const el_p,\n               const size_t sizof_element)\n{\n    int status;\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict f = NULL;\n\n    if (e->sizof_element != sizof_element) {\n    return EINVAL;\n    }\n\n    f = (fifoitem_t *)mddl_malloc(sizeof(fifoitem_t) + e->sizof_element);\n    if (NULL == f) {\n    DBMS1(\n          \"%s : mddl_malloc(fifoitem_t) fail\" EOL_CRLF, __func__);\n    status = EAGAIN;\n    goto out;\n    }\n\n    memset(f, 0x0, sizeof(fifoitem_t));\n    memcpy(f->data, el_p, e->sizof_element);\n    f->next = NULL;\n\n    \n    e->w_p->next = f;\n    e->w_p = f;\n    ++(e->cnt);\n\n    status = 0;\n\n  out:\n    if (status) {\n    if (NULL != f) {\n        mddl_free(f);\n    }\n    }\n    return status;\n}\n\n\nint mddl_stl_slist_pop(mddl_stl_slist_t *const self_p)\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict tmp = NULL;\n\n    \n    if (e->cnt == 0 ) {\n    return ENOENT;\n    }\n\n    if((e->r_p == &e->base) && ( e->r_p->next == NULL)) { \n    return -1;\n    }\n\n    tmp = e->r_p;\n    e->r_p = e->r_p->next;\n    --(e->cnt);\n\n    if (tmp != &e->base) {\n    mddl_free(tmp);\n    }\n\n    if (e->cnt == 0) {\n    if (e->r_p != &e->base) {\n        mddl_free(e->r_p);\n    }\n    e->r_p = e->w_p = &e->base;\n    }\n\n    return 0;\n}\n\n\nint mddl_stl_slist_front(mddl_stl_slist_t *const self_p, void *const el_p,\n                const size_t sizof_element)\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict f;\n\n    if (e->sizof_element != sizof_element) {\n    return EINVAL;\n    }\n\n    if (e->cnt == 0) {\n    \n    return ENOENT;\n    }\n    f = e->r_p->next;\n\n    memcpy(el_p, f->data, e->sizof_element);\n\n    return 0;\n}\n\n\nint mddl_stl_slist_clear(mddl_stl_slist_t *const self_p)\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    size_t n;\n    int result;\n\n    if (e->cnt == 0) {\n    return 0;\n    }\n\n    for (n = e->cnt; n != 0; --n) {\n    result = mddl_stl_slist_pop(self_p);\n    if (result) {\n        DBMS1(\n          \"%s : mddl_stl_slist_pop[%llu] fail\" EOL_CRLF, __func__, n);\n        return -1;\n    }\n    }\n\n    return 0;\n}\n\n\nsize_t mddl_stl_slist_get_pool_cnt(mddl_stl_slist_t *const self_p)\n{\n    const mddl_stl_slist_ext_t * const e = get_const_stl_slist_ext(self_p);\n\n    return e->cnt;\n}\n\n\nint mddl_stl_slist_is_empty(mddl_stl_slist_t *const self_p)\n{\n    const mddl_stl_slist_ext_t * const e = get_const_stl_slist_ext(self_p);\n\n    return (e->cnt == 0) ? 1 : 0;\n}\n\n\nint mddl_stl_slist_get_element_at(mddl_stl_slist_t *const self_p,\n                       const size_t num, void *const el_p,\n                       const size_t sizof_element)\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict item_p = &e->base;\n    size_t n;\n\n    if (mddl_stl_slist_is_empty(self_p)) {\n    return EACCES;\n    }\n\n    if (NULL == el_p) {\n    return EFAULT;\n    }\n\n    if (sizof_element < e->sizof_element) {\n    return EINVAL;\n    }\n\n    if (!(num < e->cnt)) {\n    return ENOENT;\n    }\n\n    for (n = 0; n < num; ++n) {\n    item_p = item_p->next;\n    }\n\n    memcpy(el_p, item_p->next->data, e->sizof_element);\n\n    return 0;\n}\n\n\n\nint mddl_stl_slist_back( mddl_stl_slist_t *const self_p, void *const el_p, const size_t  sizof_element )\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict tmp = NULL;\n\n    \n    if (e->cnt == 0) {\n    return ENOENT;\n    } else if( e->sizof_element != sizof_element ) {\n    return EINVAL;\n    }\n\n    if (e->w_p == NULL) {\n    return -1;\n    }\n\n    tmp = e->w_p;\n    memcpy( el_p, tmp->data, e->sizof_element);\n\n    return 0;\n}\n\n\nint mddl_stl_slist_insert_at( mddl_stl_slist_t *const self_p, const size_t no, void *const el_p, const size_t  sizof_element )\n{\n    size_t n;\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict cur_ticket_p = &e->base;\n    fifoitem_t *__restrict fwd_ticket_p;\n    fifoitem_t *__restrict f;\n\n    if (mddl_stl_slist_is_empty(self_p)) {\n    return ENOENT;\n    }\n\n    if (NULL == el_p) {\n    return EFAULT;\n    }\n\n    if ((e->sizof_element != sizof_element) || ( no < e->cnt) ) {\n    return EINVAL;\n    }\n\n    for (n = 0; n <= no; ++n) {\n    cur_ticket_p = cur_ticket_p->next;\n    }\n\n    fwd_ticket_p = slist_get_foward_element_ptr( e, cur_ticket_p);\n    if( NULL == fwd_ticket_p ) {\n    return EFAULT;\n    }\n\n    f = (fifoitem_t *) mddl_malloc(sizeof(fifoitem_t) + e->sizof_element);\n    if (NULL == f) {\n    DBMS1(\n          \"%s : mddl_malloc(fifoitem_t) fail\" EOL_CRLF, __func__);\n    return EAGAIN;\n    }\n\n    memset(f, 0x0, sizeof(fifoitem_t));\n    memcpy(f->data, el_p, e->sizof_element);\n    f->next = NULL;\n\n    \n    f->next = cur_ticket_p;\n    fwd_ticket_p->next = f;\n    ++(e->cnt);\n\n    return 0;\n}\n\n\nint mddl_stl_slist_erase_at( mddl_stl_slist_t *const self_p, const size_t no)\n{\n    mddl_stl_slist_ext_t * const e = get_stl_slist_ext(self_p);\n    fifoitem_t *__restrict tmp = NULL;\n    fifoitem_t *__restrict fwd_ticket_p;\n\n    \n    if (e->cnt == 0 || !(no < e->cnt) ) {\n    return ENOENT;\n    }\n\n    if((e->r_p == &e->base) || ( e->r_p->next == NULL)) {\n    return ENOENT;\n    }\n\n    if( no == 0 ) {\n    tmp = e->r_p;\n    e->r_p = e->r_p->next;\n    --(e->cnt);\n    } else {\n    size_t n;\n    fifoitem_t *__restrict cur_ticket_p = &e->base;\n\n    for (n = 0; n <= no; ++n) {\n            cur_ticket_p = cur_ticket_p->next;\n    }\n\n        fwd_ticket_p = slist_get_foward_element_ptr( e, cur_ticket_p);\n        if( NULL == fwd_ticket_p ) {\n        return EFAULT;\n        }\n    }\n\n\n    if (tmp != &e->base) {\n    mddl_free(tmp);\n    }\n\n    if (e->cnt == 0) {\n    if (e->r_p != &e->base) {\n        mddl_free(e->r_p);\n    }\n    e->r_p = e->w_p = &e->base;\n    }\n\n    return 0;\n\n}\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include \"multios_endian.h\"\n\n\n#include \"libmbmcs_revision.h\"\n#include \"libmbmcs.h\"\n\n#if defined(__GNUC__)\nextern const char *mbmcs_get_lib_revision(void)\n    __attribute__ ((optimize(\"Os\")));\nextern const char *mbmcs_get_lib_name(void)\n    __attribute__ ((optimize(\"Os\")));\n#endif\n\n\n\nconst char *mbmcs_get_lib_revision(void)\n{\n    return LIB_MBMCS_REVISION;\n}\n\n\nconst char *mbmcs_get_lib_name(void)\n{\n    return LIB_MBMCS_NAME;\n}\n\nconst char *const _libmbmcs_idkeyword =\n    \"@(#)libmultios_idkeyword : \" LIB_MBMCS_NAME \" revision\"\n    LIB_MBMCS_REVISION\n    \" CopyRight TSN.SHINGENN All Rights Reserved.\";\n\n\nconst char *mbmcs_get_idkeyword(void)\n{\n    return _libmbmcs_idkeyword;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n\n\n\n#include \"mbmcs_stdio.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000\n#define MBMCS_MEMALIGN 4\n\n\n\n#include \"mbmcs_ALPSEC12_ROTARYENCODER.h\"\n\n#define ENCODER_CTRL_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))\n\n#define ENCODER_RIGHT_SHIFT (0)\n#define ENCODER_RIGHT_MASK (((uint32_t)0xff) << ENCODER_RIGHT_SHIFT)\n#define ENCODER_LEFT_SHIFT (8)\n#define ENCODER_LEFT_MASK (((uint32_t)0xff) << ENCODER_LEFT_SHIFT)\n#define ENCODER_FUNCTION_ENABLE ((uint32_t)(0x1) << 31)\n#define ENCODER_FUNCTION_IRQ_OUTPUT ((uint32_t)(0x1) << 30)\n\n\nextern int mbmcs_alpsec12_rotaryencoder_init(mbmcs_alpsec12_rotaryencoder_t *const, const uintptr_t)\n    __attribute__ ((optimize(\"Os\")));\nextern void mbmcs_alpsec12_rotaryencoder_get_count(const mbmcs_alpsec12_rotaryencoder_t *const, uint8_t *const, uint8_t *const)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_alpsec12_rotaryencoder_set_module_enable(const mbmcs_alpsec12_rotaryencoder_t *const, const uint8_t)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_alpsec12_rotaryencoder_set_module_irq_enable(const mbmcs_alpsec12_rotaryencoder_t *const, const uint8_t)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_alpsec12_rotaryencoder_clear_counter(const mbmcs_alpsec12_rotaryencoder_t *)\n    __attribute__ ((optimize(\"O2\")));\n\n\nint mbmcs_alpsec12_rotaryencoder_init(mbmcs_alpsec12_rotaryencoder_t *const self_p, const uintptr_t base_addr)\n{\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n    self_p->base_addr = base_addr;\n \n    return 0;\n}\n\n\nvoid mbmcs_alpsec12_rotaryencoder_get_count(const mbmcs_alpsec12_rotaryencoder_t *const self_p, uint8_t *const left_p, uint8_t *const right_p)\n{\n    const uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);\n\n    if(0) {\n    volatile uint8_t left = (uint8_t)(( ENCODER_LEFT_MASK & reg ) >> ENCODER_LEFT_SHIFT);\n    volatile uint8_t right= (uint8_t)(( ENCODER_RIGHT_MASK & reg ) >> ENCODER_RIGHT_SHIFT);\n    \n    \n    mbmcs_printf(\"ENCODER reg = 0x%08x\" EOL_CRLF, reg);\n    mbmcs_printf(\"ENCODER_LEFT_MASK=0x%08x ENCODER_LEFT_SHIFT=0x%08x\" EOL_CRLF,\n            ENCODER_LEFT_MASK, ENCODER_LEFT_SHIFT);\n    mbmcs_printf(\"left=%08x right=%02x\" EOL_CRLF, left, right);\n    }\n\n    if( NULL != left_p ) {\n     *left_p = 0xff & (uint8_t)(( ENCODER_LEFT_MASK & reg ) >> ENCODER_LEFT_SHIFT);\n    \n    }\n\n    if( NULL != right_p ) {\n    *right_p = 0xff & (uint8_t)(( ENCODER_RIGHT_MASK & reg ) >> ENCODER_RIGHT_SHIFT);\n    \n    }\n\n    return;\n}\n\n\nvoid mbmcs_alpsec12_rotaryencoder_set_module_enable(const mbmcs_alpsec12_rotaryencoder_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);\n\n    if(is_on) {\n    reg |= ENCODER_FUNCTION_ENABLE;\n    } else {\n    reg &= ~ENCODER_FUNCTION_ENABLE;\n    }\n\n    reg &= ~( ENCODER_LEFT_MASK | ENCODER_RIGHT_MASK );\n\n    ENCODER_CTRL_REG(self_p->base_addr) = reg;\n\n    return;\n}\n\n\nvoid mbmcs_alpsec12_rotaryencoder_set_module_irq_enable(const mbmcs_alpsec12_rotaryencoder_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);\n\n    if(is_on) {\n    reg |= ENCODER_FUNCTION_IRQ_OUTPUT;\n    } else {\n    reg &= ~ENCODER_FUNCTION_IRQ_OUTPUT;\n    }\n\n    ENCODER_CTRL_REG(self_p->base_addr) = reg;\n\n    return;\n}\n\n\nvoid mbmcs_alpsec12_rotaryencoder_clear_counter(const mbmcs_alpsec12_rotaryencoder_t *const self_p)\n{\n    uint32_t reg = ENCODER_CTRL_REG(self_p->base_addr);\n\n    reg &= ~( ENCODER_LEFT_MASK | ENCODER_RIGHT_MASK );\n\n    ENCODER_CTRL_REG(self_p->base_addr) = reg;\n\n    return;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"multios_sys_types.h\"\n#include \"multios_unistd.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n#include \"mbmcs_platform.h\"\n#include \"mbmcs_time.h\"\n#include \"mbmcs_ATMEL_93C_SPI.h\"\n\n#define STATUS_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define OP_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define ADDR_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))\n#define WRITE_DATA_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))\n#define READ_DATA_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0xC))\n\n#define STATUS_X8_ADDRBIT_BIT ((uint32_t)0x3f)\n#define STATUS_X8_ADDRBIT_SHIFT (0)\n#define STATUS_X8_ADDRBIT_MASK (STATUS_X8_ADDRBIT_BIT << STATUS_X8_ADDRBIT_SHIFT)\n\n#define STATUS_X16_ADDRBIT_BIT ((uint32_t)0x1f)\n#define STATUS_X16_ADDRBIT_SHIFT (0)\n#define STATUS_X16_ADDRBIT_MASK (STATUS_X16_ADDRBIT_MASK << STATUS_X16_ADDRBIT_SHFT)\n\n\n#define OP_START_BIT ((uint32_t)0x1)\n#define OP_START_SHIFT (0)\n#define OP_START_MASK (OP_START_BIT << OP_START_SHIFT)\n\n#define OP_OPCODE_BIT ((uint32_t)0x3)\n#define OP_OPCODE_SHIFT (30)\n#define OP_OPCODE_MASK (OP_OPCODE_BIT << OP_OPCODE_SHIFT)\n#define OP_SUBOP_CODE_BIT ((uint32_t)0x3)\n#define OP_SUBOP_CODE_SHIFT (28)\n#define OP_SUBOP_MASK (OP_SUBOP_CODE_BIT << OP_SUBOP_CODE_SHIFT)\n\n#define STAT_READY_BIT ((uint32_t)0x1)\n#define STAT_READY_SHIFT (0)\n#define STAT_READY_MASK (STAT_READY_BIT << STAT_READY_SHIFT)\n\n#define STAT_X16MODE_BIT ((uint32_t)0x1)\n#define STAT_X16MODE_SHIFT (15)\n#define STAT_X16MODE_MASK (STAT_X16MODE_BIT << STAT_X16MODE_SHIFT)\n#define STAT_BUSY_BIT ((uint32_t)0x1)\n#define STAT_BUSY_SHIFT (4)\n#define STAT_BUSY_MASK (STAT_BUSY_BIT << STAT_BUSY_SHIFT)\n#define STAT_EINVAL_BIT ((uint32_t)0x1)\n#define STAT_EINVAL_SHIFT (3)\n#define STAT_EINVAL_MASK (STAT_EINVAL_BIT << STAT_EINVAL_SHIFT)\n#define STAT_ETIMEDOUT_BIT ((uint32_t)0x1)\n#define STAT_ETIMEDOUT_SHIFT (2)\n#define STAT_ETIMEDOUT_MASK (STAT_ETIMEDOUT_BIT << STAT_ETIMEDOUT_SHIFT) \n#define STAT_EINVAL_MASK (STAT_EINVAL_BIT << STAT_EINVAL_SHIFT)\n#define STAT_DONE_BIT ((uint32_t)0x1)\n#define STAT_DONE_SHIFT (1)\n#define STAT_DONE_MASK (STAT_DONE_BIT << STAT_DONE_SHIFT)\n\n\n\n#define ATMEL93C_ADDRMASK 0x7f\n\n#define ATMEL93C_READMASK 0xffff \n\n#define ATMEL93C_WRITEMASK 0xffff \n\n\nextern int mbmcs_atmel_93c_init( mbmcs_atmel_93c_spi_t * const self_p, const intptr_t base_addr, const enum_mbmcs_atmel_93c_series_t model)\n    __attribute__ ((optimize(\"Os\")));\nextern int mbmcs_atmel_93c_set_vcc_attribute( mbmcs_atmel_93c_spi_t * const self_p, uint8_t vcc_is_exceed_4p5)\n    __attribute__ ((optimize(\"Os\")));\n\nextern int mbmcs_atmel_93c_destroy( mbmcs_atmel_93c_spi_t * const self_p)\n    __attribute__ ((optimize(\"Os\")));\n\nextern int mbmcs_atmel_93c_readx8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, uint8_t *const d8_p)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_atmel_93c_writex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, const uint8_t d8)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_atmel_93c_erasex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_atmel_93c_write_enable( const mbmcs_atmel_93c_spi_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_atmel_93c_write_disable( const mbmcs_atmel_93c_spi_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nstatic int atmel_93c_ready_wait_timeout(const uint32_t addr)\n    __attribute__ ((optimize(\"O2\")));\n\n\nint mbmcs_atmel_93c_init( mbmcs_atmel_93c_spi_t * const self_p, const intptr_t base_addr, const enum_mbmcs_atmel_93c_series_t model)\n{\n    size_t n;\n    uint32_t rd32;\n    \n    mbmcs_atmel_93c_api_attr_t attr;\n\n    self_p->base_addr = base_addr;\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_init : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n#if 1\n    for( n=0; mbmcs_atmel_93c_bit_depth_list[n].model != ATMEL_93C_EOD; ++n) {\n    if( mbmcs_atmel_93c_bit_depth_list[n].model == model) {\n        break;\n    }\n    }\n\n    if(mbmcs_atmel_93c_bit_depth_list[n].model != ATMEL_93C46) {\n    return ENOTSUP;\n    }\n\n    if(mbmcs_atmel_93c_bit_depth_list[n].model == ATMEL_93C_EOD) {\n    return ENOTSUP;\n    }\n    self_p->model = model;\n\n    \n    rd32 = mbmcs_platform_read_register32(self_p->base_addr);\n\n    \n    attr.flags = 0;\n    attr.f.datamode_is_x16 = ( rd32 & STAT_X16MODE_MASK ) ? 1 : 0;\n    self_p->attr = attr;\n#endif\n\n    return 0;\n}\n\nint mbmcs_atmel_93c_set_vcc_attribute( mbmcs_atmel_93c_spi_t * const self_p, const uint8_t vcc_is_over_4p5)\n{\n    self_p->attr.f.vcc_is_over_4p5 = (vcc_is_over_4p5) ? 1 : 0;\n\n    return 0;\n}\n\n#if 0\n\nint mbmcs_atmel_93c_set_interrupt_callback( mbmcs_atmel_93c_spi_t * const self_p, void (*func)(mbmcs_atmel_93c_intr_t*))\n{\n    if( NULL == func ) {\n    self_p->attr.f.use_interrupt = 0;\n    self_p->intr_callback_func = NULL;\n    self_p->interrupted = 0;\n    return 0;\n    } \n\n    \n\n    self_p->attr.f.use_interrupt = 1;\n    self_p->intr_callback_func = func;\n    self_p->interrupted = 0;\n\n    return ENOTSUP;\n}\n#endif\n\nint mbmcs_atmel_93c_readx8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, uint8_t *const d8_p)\n{\n    uint32_t reg32;\n\n    if( self_p->attr.f.datamode_is_x16) {\n    DBMS1( stderr, \"93c_readx8 : module invalid mode(valid x8)\" EOL_CRLF);\n    return EACCES;\n    }\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_readx8 : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n    reg32 = STATUS_REG(self_p->base_addr);\n    if(reg32 & STAT_BUSY_MASK) {\n    DBMS1( stderr, \"93c_readx8 : is BUSY\" EOL_CRLF);\n    return EBUSY;\n    }\n\n    ADDR_REG(self_p->base_addr) = addr;\n\n    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); \n    reg32 |= ((OP_OPCODE_BIT & 0x2) << OP_OPCODE_SHIFT) | OP_START_MASK;\n\n    STATUS_REG(self_p->base_addr) = reg32;\n\n    \n    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));\n\n    if(reg32 & STAT_EINVAL_MASK) {\n    DBMS1( stderr, \"93c_readx8 : STAT_EINVAL\" EOL_CRLF);\n    return EINVAL;\n    }\n    if(reg32 & STAT_ETIMEDOUT_MASK) {\n    DBMS1( stderr, \"93c_readx8 : STAT_ETIMEDOUT\" EOL_CRLF);\n    return ETIMEDOUT;\n    }\n\n    *d8_p = (0xff & READ_DATA_REG(self_p->base_addr));\n\n    return 0;    \n}\n\nint mbmcs_atmel_93c_writex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr, const uint8_t d8)\n{\n    uint32_t reg32;\n\n    if( self_p->attr.f.datamode_is_x16) {\n    DBMS1( stderr, \"93c_writex8 : x16 access denaind\" EOL_CRLF);\n    return EACCES;\n    }\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_writex8 : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n    reg32 = STATUS_REG(self_p->base_addr);\n    if(reg32 & STAT_BUSY_MASK) {\n    DBMS1( stderr, \"93c_writex8 : is BUSY\" EOL_CRLF);\n    return EBUSY;\n    }\n\n    ADDR_REG(self_p->base_addr) = addr;\n    WRITE_DATA_REG(self_p->base_addr) = 0xff & d8;\n\n    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); \n    reg32 |= ((OP_OPCODE_BIT & 0x1) << OP_OPCODE_SHIFT) | OP_START_MASK;\n\n    STATUS_REG(self_p->base_addr) = reg32;\n\n    \n    DBMS3( stderr, \"93c_writex8 : pollog wait\" EOL_CRLF);\n    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));\n\n    if(reg32 & STAT_EINVAL_MASK) {\n    DBMS1( stderr, \"93c_writex8 : STAT_EINVAL\" EOL_CRLF);\n    return EINVAL;\n    }\n    if(reg32 & STAT_ETIMEDOUT_MASK) {\n    DBMS1( stderr, \"93c_writex8 : STAT_EINVAL\" EOL_CRLF);\n    return ETIMEDOUT;\n    }\n\n    return 0;  \n}\n\nint mbmcs_atmel_93c_erasex8( const mbmcs_atmel_93c_spi_t * const self_p, const uint16_t addr)\n{\n    uint32_t reg32;\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_erasex8 : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n    reg32 = STATUS_REG(self_p->base_addr);\n    if(reg32 & STAT_BUSY_MASK) {\n    DBMS1( stderr, \"93c_erasex8 : is BUSY\" EOL_CRLF);\n    return EBUSY;\n    }\n    ADDR_REG(self_p->base_addr) = addr;\n\n    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK);\n    reg32 |= ((OP_OPCODE_BIT & 0x3) << OP_OPCODE_SHIFT); \n    reg32 |= OP_START_MASK;\n\n    STATUS_REG(self_p->base_addr) = reg32;\n\n    \n    DBMS3( stderr, \"93c_erasex8 : pollog wait\" EOL_CRLF);\n    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));\n\n    if(reg32 & STAT_EINVAL_MASK) {\n    DBMS1( stderr, \"93c_erasex8 : STAT_EINVAL\" EOL_CRLF);\n    return EINVAL;\n    }\n    if(reg32 & STAT_ETIMEDOUT_MASK) {\n    DBMS1( stderr, \"93c_erasex8 : STAT_EINVAL\" EOL_CRLF);\n    return ETIMEDOUT;\n    }\n\n    return 0;  \n}\n\nint mbmcs_atmel_93c_write_enable( const mbmcs_atmel_93c_spi_t * const self_p)\n{\n    uint32_t reg32;\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_write_enable : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n    reg32 = STATUS_REG(self_p->base_addr);\n    if(reg32 & STAT_BUSY_MASK) {\n    DBMS3( stderr, \"93c_write_enable : is BUSY\" EOL_CRLF);\n    return EBUSY;\n    }\n\n    ADDR_REG(self_p->base_addr) = 0;\n\n    \n    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); \n    reg32 |= (OP_SUBOP_MASK & (0x3 << OP_SUBOP_CODE_SHIFT)) | OP_START_MASK;\n\n    STATUS_REG(self_p->base_addr) = reg32;\n\n    \n    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));\n\n    if(reg32 & STAT_EINVAL_MASK) {\n    DBMS1( stderr, \"93c_write_enable : EINVAL\" EOL_CRLF);\n    return EINVAL;\n    }\n    if(reg32 & STAT_ETIMEDOUT_MASK) {\n    DBMS1( stderr, \"93c_write_enable : ETIMEDOUT\" EOL_CRLF);\n    return ETIMEDOUT;\n    }\n\n    return 0;\n}\n\nstatic int atmel_93c_ready_wait_timeout(const uint32_t addr)\n{\n    const unsigned int timeout_msec=10;\n    unsigned int cnt;\n    uint32_t reg32;\n\n    for(cnt=timeout_msec; cnt!=0; --cnt) {\n        if(!((reg32 = STATUS_REG(addr)) & STAT_READY_MASK)) {\n        break;\n    }\n    multios_msleep(1);\n    }\n    if( cnt==0 && !reg32 ) {\n    return -1;\n    } \n\n    return 0;\n}\n\n\nint mbmcs_atmel_93c_write_disable( const mbmcs_atmel_93c_spi_t * const self_p)\n{\n    uint32_t reg32;\n\n    if(atmel_93c_ready_wait_timeout(self_p->base_addr)) {\n    DBMS1( stderr, \"93c_write_disable : module is not ready\" EOL_CRLF);\n    return EAGAIN;\n    } \n\n    reg32 = STATUS_REG(self_p->base_addr);\n    if(reg32 & STAT_BUSY_MASK) {\n    DBMS3( stderr, \"93c_write_disable : is BUSY\" EOL_CRLF);\n    return EBUSY;\n    }\n\n    ADDR_REG(self_p->base_addr) = 0;\n\n    reg32 &= ~(OP_OPCODE_MASK | OP_SUBOP_MASK); \n    reg32 |= OP_START_MASK;\n\n    STATUS_REG(self_p->base_addr) = reg32;\n\n    \n    while(!((reg32 = STATUS_REG(self_p->base_addr)) & STAT_DONE_MASK));\n\n\n\n    if(reg32 & STAT_EINVAL_MASK) {\n    DBMS1( stderr, \"93c_write_disable : EINVAL\" EOL_CRLF);\n    return EINVAL;\n    }\n\n    if(reg32 & STAT_ETIMEDOUT_MASK) {\n    DBMS1( stderr, \"93c_write_disable : ETIMEDOUT\" EOL_CRLF);\n    return ETIMEDOUT;\n    }\n\n    return 0;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdbool.h>\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n#include \"mbmcs_LIMITED_MOTION_2STATE_SWITCH.h\"\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000\n#define MBMCS_MEMALIGN 4\n\n#define LMSW_OP_STAT_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define LMSW_THRESHOLD_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))\n\n#define LMSW_MODULE_OP_ENABLE_BIT ((uint32_t)0x1)\n#define LMSW_MODULE_OP_ENABLE_SHIFT (31)\n#define LMSW_MODULE_OP_ENABLE_MASK \\\n    (LMSW_MODULE_OP_ENABLE_BIT << LMSW_MODULE_OP_ENABLE_SHIFT)\n#define LMSW_OP_INTR_ENABLE_BIT ((uint32_t)0x1)\n#define LMSW_OP_INTR_ENABLE_SHIFT (30)\n#define LMSW_OP_INTR_ENABLE_MASK \\\n    (LMSW_OP_INTR_ENABLE_BIT << LMSW_OP_INTR_ENABLE_SHIFT)\n#define LMSW_OP_INITIALIZED_BIT ((uint32_t)0x1)\n#define LMSW_OP_INITIALIZED_SHIFT (27)\n#define LMSW_ST_INITIALIZED_MASK \\\n    (LMSW_OP_INITIALIZED_BIT << LMSW_OP_INITIALIZED_SHIFT)\n\n#define LMSW_ST_CURRENT_LEVEL_BIT ((uint32_t)0x1)\n#define LMSW_ST_CURRENT_LEVEL_SHIFT (2)\n#define LMSW_ST_CURRENT_LEVEL_MASK \\\n    (LMSW_ST_CURRENT_LEVEL_BIT << LMSW_ST_CURRENT_LEVEL_SHIFT)\n\n#define LMSW_ST_TIMEDOUT_BIT ((uint32_t)0x1)\n#define LMSW_ST_TIMEDOUT_SHIFT (1)\n#define LMSE_ST_TIMEDOUT_MASK \\\n    (LMSW_ST_TIMEDOUT_BIT << LMSW_ST_TIMEDOUT_SHIFT)\n\n#define LMSW_ST_INTIME_BIT ((uint32_t)0x1)\n#define LMSW_ST_INTIME_SHIFT (0)\n#define LMSW_ST_INTIME_MASK \\\n    (LMSW_ST_INTIME_BIT << LMSW_ST_INTIME_SHIFT)\n\n\nextern int mbmcs_limited_motion_2state_switch_init( mbmcs_limited_motion_2state_switch_t * const, const uintptr_t )\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_limited_motion_2state_switch_irq_enable(const mbmcs_limited_motion_2state_switch_t *, bool)\n    __attribute__ ((optimize(\"O2\")));\n\nvoid mbmcs_limited_motion_2state_switch_get_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const, mbmcs_limited_motion_2state_switch_status_t *)\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_limited_motion_2state_switch_clear_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const)\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_limited_motion_2state_switch_set_limited_timer(const mbmcs_limited_motion_2state_switch_t *const, const uint16_t)\n    __attribute__ ((optimize(\"O2\")));\n\n\nint mbmcs_limited_motion_2state_switch_init( mbmcs_limited_motion_2state_switch_t * const self_p, const uintptr_t base_addr)\n{\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n\n    self_p->base_addr = base_addr;\n    LMSW_OP_STAT_REG(self_p->base_addr) = (uint32_t)LMSW_MODULE_OP_ENABLE_MASK;\n\n    for(;;) {\n    uint32_t reg32;\n    reg32 = LMSW_OP_STAT_REG(self_p->base_addr);\n    if( reg32 & LMSW_ST_INITIALIZED_MASK) {\n        return 0;\n    }\n    }\n    return EPERM;\n}\n\nvoid mbmcs_limited_motion_2state_switch_get_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const self_p, mbmcs_limited_motion_2state_switch_status_t *const stat_p)\n{\n    const uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);\n    mbmcs_limited_motion_2state_switch_status_t stat;\n\n    stat.flags = 0;\n\n    if(reg32 & LMSW_ST_CURRENT_LEVEL_MASK) {\n    stat.f.cur_level = 0x1;\n    }\n\n    if(reg32 & LMSE_ST_TIMEDOUT_MASK) {\n    stat.f.timedout = 0x1;\n    }\n\n    if(reg32 & LMSW_ST_INTIME_MASK ) {\n    stat.f.intime = 0x1;\n    }\n\n    *stat_p = stat;\n\n    return;\n}\n\nvoid mbmcs_limited_motion_2state_switch_clear_interrupt_status(const mbmcs_limited_motion_2state_switch_t *const self_p)\n{\n    uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);\n\n    reg32 &= ~(LMSE_ST_TIMEDOUT_MASK | LMSW_ST_INTIME_MASK);\n\n    LMSW_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_limited_motion_2state_switch_set_limited_timer(const mbmcs_limited_motion_2state_switch_t *const self_p, const uint16_t milisec)\n{\n    const uint32_t reg32 = milisec * 10;\n\n    LMSW_THRESHOLD_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_limited_motion_2state_switch_irq_enable(const mbmcs_limited_motion_2state_switch_t *self_p, bool is_true)\n{\n    uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);\n\n    if(is_true== true ) {\n    reg32 |= LMSW_OP_INTR_ENABLE_MASK;\n    } else {\n    reg32 &= ~LMSW_OP_INTR_ENABLE_MASK;\n    }\n\n    LMSW_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_MONOTONIC_TIMER.h\"\n#include \"mbmcs_stdio.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n\n#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_BIT ((uint32_t)0x1)\n#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_SHIFT (31)\n#define MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_MASK (MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_BIT << MONOTONIC_TIMER_OP_FORCE_CLEAR_PLS_SHIFT)\n\n#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT ((uint32_t)0x1)\n#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_SHIFT (30)\n#define MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK (MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT << MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_BIT)\n\n\n#define MONOTONIC_TIMER_OP(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define MONOTONIC_TIMER_LSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))\n#define MONOTONIC_TIMER_MSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0xc))\n\n\nextern void mbmcs_monotonic_timer_init(mbmcs_monotonic_timer_t *const, const uintptr_t)\n    __attribute__ ((optimize(\"Os\")));\nextern uint64_t mbmcs_monotonic_timer_get_timer_counter( const mbmcs_monotonic_timer_t *const)\n    __attribute__ ((optimize(\"O2\")));\n\n\nvoid  mbmcs_monotonic_timer_init(mbmcs_monotonic_timer_t *const self_p, const uintptr_t base_addr)\n{\n    self_p->base_addr = base_addr;\n\n    return;\n}\n\nuint64_t mbmcs_monotonic_timer_get_timer_counter( const mbmcs_monotonic_timer_t *const self_p)\n{\n    volatile uint64_t retval64;\n    volatile uint32_t reg32;\n    reg32 = MONOTONIC_TIMER_OP(self_p->base_addr);\n    reg32 |= MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK;\n    MONOTONIC_TIMER_OP(self_p->base_addr) = reg32;\n\n    retval64 = MONOTONIC_TIMER_MSB(self_p->base_addr);\n    \n    retval64 <<= 32;\n    retval64 |= MONOTONIC_TIMER_LSB(self_p->base_addr);\n\n    reg32 = MONOTONIC_TIMER_OP(self_p->base_addr);\n    reg32 &= ~MONOTONIC_TIMER_OP_COUNTER_LATCH_MASK_MASK;\n    MONOTONIC_TIMER_OP(self_p->base_addr) = reg32;\n\n    return retval64;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n \n#include <stdint.h>\n#include <stdio.h>\n#include <errno.h>\n\n\n\n#include \"multios_stdlib.h\"\n\n\n#include \"mbmcs_def.h\"\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_stdintrc.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n\n#define MBMCS_STDINTRC_ENABLE_OUTPUT ((uint32_t)(0x1))\n#define MBMCS_STDINTRC_IRQ_MASK ((uint32_t)(0xfffffffe))\n\n\nextern int mbmcs_stdintrc_init(mbmcs_stdintrc_t *const, const uintptr_t)\n    __attribute__ ((optimize(\"Os\")));\nextern int mbmcs_stdintrc_enable_output( const mbmcs_stdintrc_t *const, const uintptr_t)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_stdintrc_disable_output( const mbmcs_stdintrc_t *const, const uintptr_t)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_stdintrc_get_irq_flag( const mbmcs_stdintrc_t * const, const uintptr_t, uint32_t *const)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_stdintrc_clear_irq_flag( const mbmcs_stdintrc_t * const, const uintptr_t, const uint32_t)\n    __attribute__ ((optimize(\"O2\")));\n\n#define INTR_REG(a, o) *((volatile unsigned int*)((intptr_t)(a) + (o)))\n\n\nint mbmcs_stdintrc_init(mbmcs_stdintrc_t * const self_p, const uintptr_t base_addr)\n{\n    char str[MULTIOS_XTOA_HEX32_BUFSZ];\n\n    DBMS5( stderr, \"%s : base_addr=0x%s\" EOL_CRLF, __func__, \n    multios_u32toahex( base_addr, str, MULTIOS_XTOA_HEX32_BUFSZ, NULL));\n    DBMS5( stderr, \"%s : MBMCS_MEMALIGN=%d\" EOL_CRLF, __func__, MBMCS_MEMALIGN);\n    DBMS5( stderr, \"%s : MBMCS_EXTTEND_MODULE_MEMMAP_ADDR=0x%s\" EOL_CRLF, __func__, \n    multios_u32toahex( MBMCS_EXTTEND_MODULE_MEMMAP_ADDR, str, MULTIOS_XTOA_HEX32_BUFSZ, NULL));\n\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) || ( base_addr & (MBMCS_MEMALIGN-1))) {\n    return EINVAL;\n    }\n\n    self_p->base_addr = base_addr;\n\n    return 0;\n}\n\n\nint mbmcs_stdintrc_enable_output( const mbmcs_stdintrc_t *const self_p, const uintptr_t addr_offs)\n{\n    const uint32_t reg32 =  (MBMCS_STDINTRC_ENABLE_OUTPUT | MBMCS_STDINTRC_IRQ_MASK);\n\n\n    if( addr_offs & (MBMCS_MEMALIGN-1) ) {\n    return EINVAL;\n    }\n\n    INTR_REG(self_p->base_addr, addr_offs) = reg32;\n\n    return 0;\n}\n\n\nint mbmcs_stdintrc_disable_output( const mbmcs_stdintrc_t *const self_p, const uintptr_t addr_offs)\n{\n    if( addr_offs & (MBMCS_MEMALIGN-1) ) {\n    return EINVAL;\n    }\n\n    INTR_REG(self_p->base_addr, addr_offs) = ~MBMCS_STDINTRC_ENABLE_OUTPUT;\n\n    return 0;\n}\n\n\nint mbmcs_stdintrc_get_irq_flag( const mbmcs_stdintrc_t * const self_p, const uintptr_t addr_offs, uint32_t *const bitflags_p)\n{\n    if( ( addr_offs & (MBMCS_MEMALIGN-1)) || ( NULL == bitflags_p ) ) {\n    return EINVAL;\n    }\n\n    *bitflags_p = INTR_REG(self_p->base_addr, addr_offs);\n\n    return 0;\n}\n\n\nint mbmcs_stdintrc_clear_irq_flag( const mbmcs_stdintrc_t * const self_p, const uintptr_t addr_offs, const uint32_t clrbitflags)\n{\n    uint32_t reg32;\n    uint32_t intr_enable;\n\n    if( addr_offs & (MBMCS_MEMALIGN-1) ) {\n    return EINVAL;\n    }\n\n    reg32 = INTR_REG(self_p->base_addr, addr_offs);\n    intr_enable = reg32 & MBMCS_STDINTRC_ENABLE_OUTPUT;\n    reg32 &=  ~clrbitflags | intr_enable;\n    INTR_REG(self_p->base_addr, addr_offs) = reg32;\n\n    IFDBG5THEN {\n    DBMS5( stderr, \"%s : clrbitflags = 0x%08s\" EOL_CRLF, __FUNCTION__, clrbitflags);\n    DBMS5( stderr, \"%s : setdata = 0x%08x\" EOL_CRLF, __FUNCTION__, reg32);\n    }\n\n    return 0;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_STD_2STATE_RELAY_CTRL.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n\n#define RELAY_OP_STAT_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define RELAY_DELAY_PERIOD_THRESH_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))\n#define RELAY_ACTIVE_PERIOD_THRESH_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0xC))\n#define RELAY_DELAY_TIMERCNT_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x10))\n#define RELAY_ACTIVE_TIMERCNT_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x14))\n#define RELAY_TEST_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x1C))\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000\n#define MBMCS_MEMALIGN 4\n\n#define RELAY_MODULE_CTL_ENABLE_BIT   ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_ENABLE_SHIFT (31)\n#define RELAY_MODULE_CTL_ENABLE_MASK \\\n    (RELAY_MODULE_CTL_ENABLE_BIT << RELAY_MODULE_CTL_ENABLE_SHIFT)\n\n#define RELAY_MODULE_CTL_ENABLE_INTR_BIT   ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_ENABLE_INTR_SHIFT (30)\n#define RELAY_MODULE_CTL_ENABLE_INTR_MASK \\\n    (RELAY_MODULE_CTL_ENABLE_INTR_BIT << RELAY_MODULE_CTL_ENABLE_INTR_SHIFT)\n\n#define RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_SHIFT (28)\n#define RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_MASK \\\n    (RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_BIT << RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_SHIFT)\n\n\n#define RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_BIT  ((uint32_t)0x1)\n#define RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_SHIFT  (7)\n#define RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_MASK  \\\n    (RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_BIT << RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_SHIFT)\n\n#define RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_BIT  ((uint32_t)0x1)\n#define RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_SHIFT  (6)\n#define RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_MASK  \\\n    (RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_BIT << RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_SHIFT)\n\n#define RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_BIT  ((uint32_t)0x1)\n#define RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_SHIFT (5)\n#define RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_MASK \\\n    (RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_BIT << RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_SHIFT)\n\n#define RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_BIT  ((uint32_t)0x1)\n#define RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_SHIFT (4)\n#define RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_MASK \\\n    (RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_BIT << RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_SHIFT)\n\n\n#define RELAY_MODULE_CTL_EXEC_CLEAR_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_EXEC_CLEAR_SHIFT (3)\n#define RELAY_MODULE_CTL_EXEC_CLEAR_MASK \\\n    (RELAY_MODULE_CTL_EXEC_CLEAR_BIT << RELAY_MODULE_CTL_EXEC_CLEAR_SHIFT)\n\n#define RELAY_MODULE_CTL_EXEC_PAUSE_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_EXEC_PAUSE_SHIFT (2)\n#define RELAY_MODULE_CTL_EXEC_PAUSE_MASK \\\n    (RELAY_MODULE_CTL_EXEC_PAUSE_BIT << RELAY_MODULE_CTL_EXEC_PAUSE_SHIFT)\n\n#define RELAY_MODULE_CTL_EXEC_CONTINUE_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_EXEC_CONTINUE_SHIFT (1)\n#define RELAY_MODULE_CTL_EXEC_CONTINUE_MASK \\\n    (RELAY_MODULE_CTL_EXEC_CONTINUE_BIT << RELAY_MODULE_CTL_EXEC_CONTINUE_SHIFT)\n\n#define RELAY_MODULE_CTL_EXEC_START_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_CTL_EXEC_START_SHIFT (0)\n#define RELAY_MODULE_CTL_EXEC_START_MASK \\\n    (RELAY_MODULE_CTL_EXEC_START_BIT << RELAY_MODULE_CTL_EXEC_START_SHIFT)\n\n#define RELAY_MODULE_STAT_BUSY_BIT ((uint32_t)0x1)\n#define RELAY_MODULE_STAT_BUSY_SHIFT (29)\n#define RELAY_MODULE_STAT_BUSY_MASK \\\n    (RELAY_MODULE_STAT_BUSY_BIT << RELAY_MODULE_STAT_BUSY_SHIFT)\n\n\n\nextern int mbmcs_std_2state_relay_ctrl_init(mbmcs_std_2state_relay_ctrl_t * const self_p, const uintptr_t base_addr)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_relay_ctrl_irq_enable(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_std_2state_relay_ctrl_delay_timer_is_active(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_std_2state_relay_ctrl_exec_pause(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_relay_ctrl_exec_clear(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_relay_ctrl_exec_continue(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_relay_ctrl_exec_start(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_std_2state_relay_ctrl_is_busy(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_std_2state_relay_ctrl_ative_timer_is_active(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_std_2state_relay_ctrl_delay_timer_is_active(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_std_2state_relay_ctrl_set_pause_at_active_thresh(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_std_2state_relay_ctrl_get_flag_pause_at_active_thresh(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern uint32_t mbmcs_std_2state_relay_ctrl_get_delay_timer_counter(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern uint32_t mbmcs_std_2state_relay_ctrl_get_active_timer_counter(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_std_2state_relay_ctrl_set_delay_timer_thresh_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint32_t msec)\n    __attribute__ ((optimize(\"O2\")));\n\nextern int mbmcs_std_2state_relay_ctrl_set_active_timer_thresh_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint32_t msec)\n    __attribute__ ((optimize(\"O2\")));\n\nextern uint32_t mbmcs_std_2state_get_delay_timer_count_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern uint32_t mbmcs_std_2state_relay_ctrl_relay_ctrl_get_active_timer_count_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\nextern void mbmcs_std_2state_relay_get_interrupt_flags(const mbmcs_std_2state_relay_ctrl_t * const self_p, mbmcs_std_2state_relay_ctrl_interrupt_status_t * const intr_stat_p)\n    __attribute__ ((optimize(\"O2\")));\n\n\n\nint mbmcs_std_2state_relay_ctrl_init(mbmcs_std_2state_relay_ctrl_t * const self_p, const uintptr_t base_addr)\n{\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n\n    self_p->base_addr = base_addr;\n\n    {\n        uint32_t reg32 = RELAY_MODULE_CTL_ENABLE_MASK;\n        RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n    }\n\n    for(;;) {\n        uint32_t reg32;\n    reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n    if(!(reg32 & RELAY_MODULE_STAT_BUSY_MASK)) {\n        return 0;\n        }\n    }\n    return EPERM;\n}\n\nvoid mbmcs_std_2state_relay_ctrl_irq_enable(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    if(is_on) {\n    reg32 |= RELAY_MODULE_CTL_ENABLE_INTR_MASK;\n    } else {\n    reg32 &= ~RELAY_MODULE_CTL_ENABLE_INTR_MASK;\n    }\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_std_2state_relay_ctrl_set_pause_at_active_thresh(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    if(is_on) {\n    reg32 |= RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_MASK;\n    } else {\n    reg32 &= ~RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_MASK;\n    }\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nint mbmcs_std_2state_relay_ctrl_get_flag_pause_at_active_thresh(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    const uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    return (reg32 & RELAY_MODULE_CTL_PAUSE_AT_ACTIVE_THRESHED_MASK) ? (~0) : 0;\n\n}\n\nvoid mbmcs_std_2state_relay_ctrl_exec_pause(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 |= RELAY_MODULE_CTL_EXEC_PAUSE_MASK;\n\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_std_2state_relay_ctrl_exec_clear(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 |= RELAY_MODULE_CTL_EXEC_CLEAR_MASK;\n\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_std_2state_relay_ctrl_exec_continue(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 |= RELAY_MODULE_CTL_EXEC_CONTINUE_MASK;\n\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_std_2state_relay_ctrl_exec_start(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 |= RELAY_MODULE_CTL_EXEC_START_MASK;\n\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n}\n\nint mbmcs_std_2state_relay_ctrl_is_busy(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 &= RELAY_MODULE_STAT_BUSY_MASK;\n\n    return (reg32) ? ~0 : 0;\n}\n\nint mbmcs_std_2state_relay_ctrl_ative_timer_is_active(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n    \n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 &= RELAY_MODULE_STAT_ACTIVE_TIMER_IS_ACTIVE_BIT;\n\n    return (reg32) ? ~0 : 0;\n}\n\nint mbmcs_std_2state_relay_ctrl_delay_timer_is_active(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    reg32 &= RELAY_MODULE_STAT_DELAY_TIMER_IS_ACTIVE_BIT;\n\n    return (reg32) ? ~0 : 0;\n}\n\nint mbmcs_std_2state_relay_ctrl_set_delay_timer_thresh_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint32_t msec)\n{\n    const uint32_t reg32 = (msec * 10);\n    uint32_t tmp32;\n\n    DBMS3(stderr, \"%s : execte addr=0x%08x reg32=0x%08x\" EOL_CRLF, __FUNCTION__,\n            self_p->base_addr, reg32);\n\n    RELAY_DELAY_PERIOD_THRESH_REG(self_p->base_addr) = reg32;\n\n    tmp32=RELAY_DELAY_PERIOD_THRESH_REG(self_p->base_addr);\n\n    DBMS3(stderr, \"%s : addr=0x%08x tmp32=0x%08x\" EOL_CRLF, __FUNCTION__,\n            self_p->base_addr, tmp32);\n \n    return !(reg32 - tmp32) ? 0 : EOVERFLOW;\n}\n\nint mbmcs_std_2state_relay_ctrl_set_active_timer_thresh_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p, const uint32_t msec)\n{\n    uint32_t reg32 = (msec * 10), tmp32;\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    RELAY_ACTIVE_PERIOD_THRESH_REG(self_p->base_addr) = reg32;\n\n    tmp32=RELAY_ACTIVE_PERIOD_THRESH_REG(self_p->base_addr);\n \n    return !(reg32 - tmp32) ? 0 : EOVERFLOW;\n}\n\nuint32_t mbmcs_std_2state_relay_ctrl_get_delay_timer_count_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    const uint32_t reg32 = RELAY_DELAY_TIMERCNT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    return (reg32 \/ 10);\n}\n\nuint32_t mbmcs_std_2state_relay_ctrl_get_active_timer_count_msec(const mbmcs_std_2state_relay_ctrl_t * const self_p)\n{\n    const uint32_t reg32 = RELAY_ACTIVE_TIMERCNT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    return (reg32 \/ 10);\n}\n\nvoid mbmcs_std_2state_relay_get_interrupt_flags(const mbmcs_std_2state_relay_ctrl_t * const self_p, mbmcs_std_2state_relay_ctrl_interrupt_status_t * const intr_stat_p)\n{\n    uint32_t reg32 = RELAY_OP_STAT_REG(self_p->base_addr);\n    mbmcs_std_2state_relay_ctrl_interrupt_status_t intr_stat;\n\n    DBMS5(stderr, \"%s : execte\" EOL_CRLF, __FUNCTION__);\n\n    intr_stat.flags = 0;\n    if(reg32 & RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_MASK) {\n        intr_stat.f.is_delay_threshed = 1;\n    }\n\n    if(reg32 & RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_MASK) {\n        intr_stat.f.is_active_threshed = 1;\n    }\n\n    reg32 &= ~(RELAY_MODULE_STAT_DELAY_THRESHED_INTERRUPT_MASK |\n    RELAY_MODULE_STAT_ACTIVE_THRESHED_INTERRUPT_MASK);\n\n    RELAY_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    *intr_stat_p = intr_stat;\n\n    return;\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_STD_2STATE_SWITCH.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000\n#define MBMCS_MEMALIGN 4\n\n#define SW_IF_OP_STAT_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))\n#define SW_IF_MONOTONIC_TIMER64_LSB32_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x8))\n#define SW_IF_MONOTONIC_TIMER64_MSB32_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0xC))\n\n#define SW_NEGATIVE_EGDE_DETECTIVE_BIT ((uint32_t)0x1)\n#define SW_NEGATIVE_EGDE_DETECTIVE_SHIFT  (16)\n#define SW_NEGATIVE_EGDE_DETECTIVE_MASK (uint32_t)(SW_NEGATIVE_EGDE_DETECTIVE_BIT << SW_NEGATIVE_EGDE_DETECTIVE_SHIFT)\n\n#define SW_POSITIVE_EGDE_DETECTIVE_BIT ((uint32_t)0x1)\n#define SW_POSITIVE_EGDE_DETECTIVE_SHIFT (17)\n#define SW_POSITIVE_EDGE_DETECTIVE_MASK (uint32_t)(SW_POSITIVE_EGDE_DETECTIVE_BIT << SW_POSITIVE_EGDE_DETECTIVE_SHIFT)\n\n#define SW_EDGE_DETECTIVE_MASK (uint32_t)(SW_NEGATIVE_EGDE_DETECTIVE_MASK | SW_POSITIVE_EDGE_DETECTIVE_MASK )\n\n#define SW_EDGE_COUNTER_CLEAR_BIT ((uint32_t)0x1)\n#define SW_EDGE_COUNTER_CLEAR_SHIFT (25)\n#define SW_EDGE_COUNTER_CLEAR_MASK (uint32_t)(SW_EDGE_COUNTER_CLEAR_BIT << SW_EDGE_COUNTER_CLEAR_SHIFT)\n\n#define SW_EDGE_COUNTER_ENABLE_BIT ((uint32_t)0x1)\n#define SW_EDGE_COUNTER_ENABLE_SHIFT (24)\n#define SW_EDGE_COUNTER_ENABLE_MASK (uint32_t)(SW_EDGE_COUNTER_ENABLE_BIT << SW_EDGE_COUNTER_ENABLE_SHIFT)\n\n#define SW_EDGE_COUNTER_VALUE_BIT ((uint32_t)0xffff)\n#define SW_EDGE_COUNTER_VALUE_SHIFT (0)\n#define SW_EDGE_COUNTER_VALUE_MASK (uint32_t)(SW_EDGE_COUNTER_VALUE_BIT << SW_EDGE_COUNTER_VALUE_SHIFT)\n\n#define SW_CURRENT_LEVEL_BIT ((uint32_t)0x1)\n#define SW_CURRENT_LEVEL_SHIFT (27)\n#define SW_CURRENT_LEVEL_MASK (uint32_t)(SW_CURRENT_LEVEL_BIT << SW_CURRENT_LEVEL_SHIFT)\n\n#define SW_INITALIZED_BIT ((uint32_t)0x1)\n#define SW_INITALIZED_SHIFT (26)\n#define SW_INITALIZED_MASK (uint32_t)(SW_INITALIZED_BIT << SW_INITALIZED_SHIFT)\n\n#define SW_SENS_ENABLE_NEGATIVE_EDGE_BIT ((uint32_t)0x1)\n#define SW_SENS_ENABLE_NEGATIVE_EDGE_SHIFT (28)\n#define SW_SENS_ENABLE_NEGATIVE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_NEGATIVE_EDGE_BIT << SW_SENS_ENABLE_NEGATIVE_EDGE_SHIFT)\n\n#define SW_SENS_ENABLE_POSITIVE_EDGE_BIT ((uint32_t)0x1)\n#define SW_SENS_ENABLE_POSITIVE_EDGE_SHIFT (29)\n#define SW_SENS_ENABLE_POSITIVE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_POSITIVE_EDGE_BIT << SW_SENS_ENABLE_POSITIVE_EDGE_SHIFT)\n\n#define SW_SENS_ENABLE_EDGE_MASK (uint32_t)(SW_SENS_ENABLE_NEGATIVE_EDGE_MASK | SW_SENS_ENABLE_POSITIVE_EDGE_MASK)\n\n#define SW_IF_IRQ_ENABLE_BIT ((uint32_t)0x1)\n#define SW_IF_IRQ_ENABLE_SHIFT (30)\n#define SW_IF_IRQ_ENABLE_MASK (uint32_t)(SW_IF_IRQ_ENABLE_BIT << SW_IF_IRQ_ENABLE_SHIFT)\n\n#define SW_IF_MODULE_ENABLE_BIT ((uint32_t)0x1)\n#define SW_IF_MODULE_ENABLE_SHIFT (31)\n#define SW_IF_MODULE_ENABLE_MASK (uint32_t)(SW_IF_MODULE_ENABLE_BIT << SW_IF_MODULE_ENABLE_SHIFT)\n\n#define SW_IF_MASK (uint32_t)( SW_IF_MODULE_ENABLE_MASK | SW_IF_IRQ_ENABLE_MASK | \\\n      SW_EDGE_SENS_MASK | SW_EDGE_DETECTIVE_MASK )\n\n\n\nextern int mbmcs_std_2state_switch_init(mbmcs_std_2state_switch_t * const self_p, const uintptr_t base_addr)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_sens_negative_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_sens_positive_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_irq_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_std_2state_switch_get_flags(const mbmcs_std_2state_switch_t * const self_p, mbmcs_std_2state_switch_status_t * const stat_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_clear_detective_egde_flags(const mbmcs_std_2state_switch_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern uint32_t _mbmcs_std_2state_switch_get_registers(const mbmcs_std_2state_switch_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_edge_counter_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_2state_switch_edge_counter_clear(const mbmcs_std_2state_switch_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern uint16_t mbmcs_std_2state_switch_get_edge_counter_value(const mbmcs_std_2state_switch_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern uint64_t mbmcs_std_2state_switch_get_monotonic_timer(const mbmcs_std_2state_switch_t * const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\n\n\n\nint mbmcs_std_2state_switch_init(mbmcs_std_2state_switch_t * const self_p, const uintptr_t base_addr)\n{\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n    self_p->base_addr = base_addr;\n\n    {\n        uint32_t reg32 = SW_IF_MODULE_ENABLE_MASK;\n        SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n#define SW_CURRENT_LEVEL_MASK (uint32_t)(SW_CURRENT_LEVEL_BIT << SW_CURRENT_LEVEL_SHIFT)\n    }\n    for(;;) {\n        uint32_t reg32;\n    reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n        if( reg32 & SW_INITALIZED_MASK) {\n            mbmcs_std_2state_switch_edge_counter_clear(self_p);\n            return 0;\n    }\n    } \n\n    return EPERM;\n}\n\n \nvoid mbmcs_std_2state_switch_sens_negative_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 = (is_true) ? (uint32_t)(reg32 | SW_SENS_ENABLE_NEGATIVE_EDGE_MASK) : (uint32_t)( reg32 & ~SW_SENS_ENABLE_NEGATIVE_EDGE_MASK );\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n \nvoid mbmcs_std_2state_switch_sens_positive_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 = (is_true) ? (uint32_t)(reg32 | SW_SENS_ENABLE_POSITIVE_EDGE_MASK) : (uint32_t)( reg32 & ~SW_SENS_ENABLE_POSITIVE_EDGE_MASK);\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nvoid mbmcs_std_2state_switch_irq_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 = (is_true) ? (reg32 | SW_IF_IRQ_ENABLE_MASK) : ( reg32 & ~SW_IF_IRQ_ENABLE_MASK);\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nint mbmcs_std_2state_switch_get_flags(const mbmcs_std_2state_switch_t * const self_p, mbmcs_std_2state_switch_status_t * const stat_p)\n{\n    if( NULL == stat_p ) {\n    return EINVAL;  \n    } else {    \n    mbmcs_std_2state_switch_status_t stat = { 0 };\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    DBMS5(stderr, \"mbmcs_std_2state_switch_get_flags : reg32=%08x\" EOL_CRLF, reg32);\n    \n    \n#if 0\n    stat.f.current_signal = (reg32 & SW_CURRENT_LEVEL_MASK) ? ~0 : 0;\n#else\n    if(reg32 & SW_CURRENT_LEVEL_MASK) {\n        stat.f.current_signal = ~0;\n    } else {\n        stat.f.current_signal = 0;\n    }\n#endif\n#if 0\n    stat.f.positive_edge  = (reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK) ? 0x1 : 0;\n    stat.f.negative_edge  = (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK) ? 0x1 : 0;\n#else\n    if((reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK)!=0) {\n        stat.f.positive_edge =~0;\n    } else {\n        stat.f.positive_edge = 0;\n    }\n    if((reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK)!=0) {\n        stat.f.negative_edge = ~0;\n    } else {\n        stat.f.negative_edge = 0;\n    }\n#endif\n    DBMS3( stderr, \"stat.f.current_signal=%d\" EOL_CRLF, stat.f.current_signal);\n    DBMS3( stderr, \"stat.f.positive_edge=%d\" EOL_CRLF, stat.f.positive_edge);\n    DBMS3( stderr, \"stat.f.negative_edge=%d\" EOL_CRLF, stat.f.negative_edge);\n\n    *stat_p = stat;\n    }\n\n    return 0;\n}\n\n \nvoid mbmcs_std_2state_switch_clear_detective_egde_flags(const mbmcs_std_2state_switch_t * const self_p)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 &= ~SW_EDGE_DETECTIVE_MASK;\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nuint32_t _mbmcs_std_2state_switch_get_registers(const mbmcs_std_2state_switch_t * const self_p)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    return reg32;\n}\n\n\nvoid _mbmcs_std_2state_switch_dump_registers(const mbmcs_std_2state_switch_t * const self_p)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    DMSG( stderr, \"module enable:%x\" EOL_CRLF, (reg32 & SW_IF_MODULE_ENABLE_MASK ? 0x1 : 0));\n    DMSG( stderr, \"irq_enable: %x\" EOL_CRLF, (reg32 & SW_IF_IRQ_ENABLE_MASK ? 0x1 : 0));\n    DMSG( stderr, \"detective positive edge:%x\" EOL_CRLF, (reg32 & SW_POSITIVE_EDGE_DETECTIVE_MASK ? 0x1 : 0));\n    DMSG( stderr, \"detective negative edge:%x\" EOL_CRLF, (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK ? 0x1 : 0));\n    DMSG( stderr, \"current level:%x\" EOL_CRLF, (reg32 & SW_NEGATIVE_EGDE_DETECTIVE_MASK ? 0x1 : 0));\n    DMSG( stderr, \"sensitive positive edge enable:%x\" EOL_CRLF,\n      (reg32 & SW_SENS_ENABLE_POSITIVE_EDGE_MASK) ? 0x1 : 0);\n    DMSG( stderr, \"sensitive negative edge enable:%x\" EOL_CRLF,\n      (reg32 & SW_SENS_ENABLE_NEGATIVE_EDGE_MASK) ? 0x1 : 0);\n    DMSG( stderr, \"edge counter enable:%x\" EOL_CRLF,\n      (reg32 & SW_EDGE_COUNTER_ENABLE_MASK) ? 0x1 : 0);\n    DMSG( stderr, \"egde counter value:%04x\" EOL_CRLF,\n        (reg32 & (SW_EDGE_COUNTER_VALUE_MASK >> SW_EDGE_COUNTER_VALUE_SHIFT)));\n\n    return;\n}\n\nvoid mbmcs_std_2state_switch_edge_counter_enable(const mbmcs_std_2state_switch_t * const self_p, const uint8_t is_true) {\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 = (is_true) ? (reg32 | SW_EDGE_COUNTER_ENABLE_MASK) : ( reg32 & ~SW_EDGE_COUNTER_ENABLE_MASK);\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_std_2state_switch_edge_counter_clear(const mbmcs_std_2state_switch_t * const self_p)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 |=  SW_EDGE_COUNTER_CLEAR_MASK;\n\n    SW_IF_OP_STAT_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nuint16_t mbmcs_std_2state_switch_get_edge_counter_value(const mbmcs_std_2state_switch_t * const self_p)\n{\n    uint32_t reg32 = SW_IF_OP_STAT_REG(self_p->base_addr);\n\n    reg32 >>= SW_EDGE_COUNTER_VALUE_SHIFT;\n\n    return (reg32 & SW_EDGE_COUNTER_VALUE_BIT);\n}\n\nuint64_t mbmcs_std_2state_switch_get_monotonic_timer(const mbmcs_std_2state_switch_t * const self_p)\n{\n    const uint64_t lsb32 = SW_IF_MONOTONIC_TIMER64_LSB32_REG(self_p->base_addr);\n    const uint64_t msb32 = SW_IF_MONOTONIC_TIMER64_MSB32_REG(self_p->base_addr);\n\n    return ((msb32 << 32) | lsb32);\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_STD_TIMER.h\"\n#include \"mbmcs_stdio.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n#define STD_TIMER_OP_FORCE_CLEAR_BIT ((uint32_t)0x1)\n#define STD_TIMER_OP_FORCE_CLEAR_SHIFT (31)\n#define STD_TIMER_OP_FORCE_CLEAR_MASK (STD_TIMER_OP_FORCE_CLEAR_BIT << STD_TIMER_OP_FORCE_CLEAR_SHIFT)\n\n#define STD_TIMER_OP_PAUSE_BIT ((uint32_t)0x1)\n#define STD_TIMER_OP_PAUSE_SHIFT (30)\n#define STD_TIMER_OP_PAUSE_MASK (STD_TIMER_OP_PAUSE_BIT << STD_TIMER_OP_PAUSE_SHIFT)\n\n#define STD_TIMER_OP_COUNTER_LATCH_MASK_BIT ((uint32_t)0x1)\n#define STD_TIMER_OP_COUNTER_LATCH_MASK_SHIFT (29)\n#define STD_TIMER_OP_COUNTER_LATCH_MASK_MASK (STD_TIMER_OP_COUNTER_LATCH_MASK_BIT << STD_TIMER_OP_COUNTER_LATCH_MASK_SHIFT)\n\n#define STD_TIMER_OP(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define STD_TIMER_LSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0x8))\n#define STD_TIMER_MSB(a) *((volatile unsigned int*)((intptr_t)(a) + 0xc))\n\n\nextern void mbmcs_std_timer_init(mbmcs_std_timer_t *const self_p, const uintptr_t base_addr)\n    __attribute__ ((optimize(\"Os\")));\nextern uint64_t mbmcs_std_timer_get_timer_counter( mbmcs_std_timer_t *const self_p)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_std_timer_force_reset(mbmcs_std_timer_t *const self_p)\n    __attribute__ ((optimize(\"Os\")));\nextern void mbmcs_std_timer_pause(mbmcs_std_timer_t *const self_p)\n    __attribute__ ((optimize(\"Os\")));\nextern void mbmcs_std_timer_unpause(mbmcs_std_timer_t *const self_p)\n    __attribute__ ((optimize(\"Os\")));\nextern int mbmcs_std_timer_set_timer_counter( mbmcs_std_timer_t *const self_p, const uint64_t msec64)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_std_timer_set_timer_counter_and_unpause( mbmcs_std_timer_t *const self_p, const uint64_t msec64)\n    __attribute__ ((optimize(\"Os\")));\n\n\nvoid  mbmcs_std_timer_init(mbmcs_std_timer_t *const self_p, const uintptr_t base_addr)\n{\n    self_p->base_addr = base_addr;\n\n    return;\n}\n\n\nuint64_t mbmcs_std_timer_get_timer_counter( mbmcs_std_timer_t *const self_p)\n{\n    volatile uint64_t retval64;\n    volatile uint32_t reg32;\n    reg32 = STD_TIMER_OP(self_p->base_addr);\n    reg32 |= STD_TIMER_OP_COUNTER_LATCH_MASK_MASK;\n    STD_TIMER_OP(self_p->base_addr) = reg32;\n\n    retval64 = STD_TIMER_MSB(self_p->base_addr);\n    \n    retval64 <<= 32;\n    retval64 |= STD_TIMER_LSB(self_p->base_addr);\n\n    reg32 = STD_TIMER_OP(self_p->base_addr);\n    reg32 &= ~STD_TIMER_OP_COUNTER_LATCH_MASK_MASK;\n    STD_TIMER_OP(self_p->base_addr) = reg32;\n\n    return retval64;\n}\n\n\nvoid mbmcs_std_timer_force_reset(mbmcs_std_timer_t *const self_p)\n{\n    uint32_t d32;\n\n    d32 = STD_TIMER_OP(self_p->base_addr);\n    d32 |= STD_TIMER_OP_FORCE_CLEAR_MASK;\n    STD_TIMER_OP(self_p->base_addr) = d32;\n\n    return;\n}\n\n\nvoid mbmcs_std_timer_pause(mbmcs_std_timer_t *const self_p)\n{\n    uint32_t d32;\n\n    d32 = STD_TIMER_OP(self_p->base_addr);\n    d32 |= STD_TIMER_OP_PAUSE_MASK;\n    STD_TIMER_OP(self_p->base_addr) = d32;\n\n    return;\n}\n\n\nvoid mbmcs_std_timer_unpause(mbmcs_std_timer_t *const self_p)\n{\n    uint32_t d32;\n\n    d32 = STD_TIMER_OP(self_p->base_addr);\n    d32 &= ~STD_TIMER_OP_PAUSE_MASK;\n    STD_TIMER_OP(self_p->base_addr) = d32;\n\n    return;\n}\n\n\nint mbmcs_std_timer_set_timer_counter( mbmcs_std_timer_t *const self_p, const uint64_t msec64)\n{\n    uint64_t d64 = msec64;\n\n    STD_TIMER_LSB(self_p->base_addr) = (uint32_t)(0xffffffff & d64);\n    d64 >>= 32; \n    STD_TIMER_MSB(self_p->base_addr) = (uint32_t)d64;\n\n    \n    d64 = STD_TIMER_MSB(self_p->base_addr);\n    d64 <<= 32;\n    d64 |= (uint64_t)STD_TIMER_LSB(self_p->base_addr);\n\n    return (msec64 == d64) ? 0 : EPERM;\n\n}\n\n\nint mbmcs_std_timer_set_timer_counter_and_unpause( mbmcs_std_timer_t *const self_p, const uint64_t msec64)\n{\n    int result;\n\n    result = mbmcs_std_timer_set_timer_counter( self_p, msec64);\n    if(result) {\n    return result;\n    }\n\n    mbmcs_std_timer_unpause(self_p);\n\n    return 0;\n}\n\n\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"libmbmcs_libmultios_bridge.h\"\n\n\n#include \"mbmcs_platform.h\"\n#include \"mbmcs_unistd.h\"\n#include \"mbmcs_time.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 1;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n#if defined(__GNUC__)\n\nextern void mbmcs_msleep( const unsigned int)\n    __attribute__ ((optimize(\"Os\")));\nextern unsigned int mbmcs_sleep( const unsigned int)\n    __attribute__ ((optimize(\"Os\")));\nextern int mbmcs_clock_gettime_clock_monotonic(mbmcs_timespec_t *const)\n    __attribute__ ((optimize(\"Os\")));\n\n#endif \n\n\nvoid mbmcs_msleep( const unsigned int milisec )\n{\n#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER\n    DMSG(stderr,\"mbmcs_msleep : FIT1_JIFFIES_COUNTER function is not enabled\" EOL_CRLF);\n    abort();\n#else\n    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;\n    uint64_t endtime = mbmcs_jiffies + milisec;\n\n    while ( endtime > *mbmcs_jiffies_p );\n\n    return;\n#endif\n}\n\n\nunsigned int mbmcs_sleep( const unsigned int seconds)\n{\n#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER\n    DMSG(stderr,\"mbmcs_sleep : FIT1_JIFFIES_COUNTER function is not enabled\" EOL_CRLF);\n    abort();\n#else\n\n    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;\n    uint64_t endtime = mbmcs_jiffies + ((uint64_t)seconds * 1000);\n\n    while ( endtime > *mbmcs_jiffies_p );\n\n    return 0;\n#endif\n}\n\n\nint mbmcs_clock_gettime_clock_monotonic(mbmcs_timespec_t * const mts_p)\n{\n#ifndef MBMCS_ENABLE_FIT1_JIFFIES_COUNTER\n    DBMS1(stderr,\"mbmcs_clock_gettime_clock_monotonic : FIT1_JIFFIES_COUNTER function is not enabled\" EOL_CRLF);\n    return EINVAL;\n#else\n    const uint64_t mbmcs_jiffies = *mbmcs_jiffies_p;\n    mbmcs_timespec_t ts;\n\n    if( NULL == mts_p ) {\n    return  EFAULT;\n    }\n\n    ts.tv_sec = mbmcs_jiffies \/ HZ;\n    ts.tv_nsec = (mbmcs_jiffies % HZ) * 1000 * 1000;\n\n    *mts_p = ts;\n\n    return 0;\n#endif\n}\n\n\n\n"}
{"target":"TSN-SHINGENN","func":"\n\n#include <sys\/types.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\n\n#include <xparameters.h>\n\n\n#include \"multios_lite_mallocater.h\"\n\n\n#include \"libmbmcs_libmultios_bridge.h\"\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_platform.h\"\n#include \"mbmcs_unistd.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\nint64_t mbmcs_sysconf_pagesize(void)\n{\n    return XPAR_CPU_MICROBLAZE_I_DATA_SIZE;\n}\n\n\nint64_t mbmcs_sysconf_nprocessor_conf(void)\n{\n    return 1; \n}\n\n\nint64_t mbmcs_sysconf_nprocessor_onln(void)\n{\n    return 1; \n}\n\n\nint64_t mbmcs_sysconf_phys_pages(void)\n{\n    return 2 * 0xffff \/ XPAR_CPU_MICROBLAZE_I_DATA_SIZE;\n}\n\n\nint64_t mbmcs_sysconf_avphys_pages(void)\n{\n    return multios_lite_mallocater_avphys_with_obj(&_multios_lite_mallocater_heap_emulate_obj) \/ XPAR_CPU_MICROBLAZE_I_DATA_SIZE;\n\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_WATCHDOG_TIMER.h\"\n\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n\n\n#define WDT_OP_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x0))\n#define WDT_OUNTER_REG(a) *((volatile unsigned int*)((intptr_t)(a) + 0x4))\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR 0xC0000000\n#define MBMCS_MEMALIGN 4\n\n\n#define WDT_MODULE_ENABLE_BIT ((uint32_t)0x1)\n#define WDT_MODULE_ENABLE_SHIFT (31)\n#define WDT_MODULE_ENABLE_MASK \\\n    ( WDT_MODULE_ENABLE_BIT << WDT_MODULE_ENABLE_SHIFT)\n#define WDT_IRQ_ENABLE_BIT ((uint32_t)0x1)\n#define WDT_IRQ_ENABLE_SHIFT (30)\n#define WDT_IRQ_ENABLE_MASK \\\n    ( WDT_IRQ_ENABLE_BIT << WDT_IRQ_ENABLE_SHIFT)\n#define WDT_TIMEDOUT_BIT ((uint32_t)0x1)\n#define WDT_TIMEDOUT_SHIFT (29)\n#define WDT_TIMEDOUT_MASK \\\n    ( WDT_TIMEDOUT_BIT << WDT_TIMEDOUT_SHIFT)\n#define WDT_TIMER_THRESHED_BIT   ((uint32_t)0xffff)\n#define WDT_TIMER_THRESHED_SHIFT (0)\n#define WDT_TIMER_THRESHED_MASK \\\n    ( WDT_TIMER_THRESHED_BIT << WDT_TIMER_THRESHED_SHIFT)\n#define WDT_IRQ_TIMER_THRESH_BIT ((uint32_t)0xfff)\n#define WDT_IRQ_TIMER_THRESH_SHIFT (16)\n#define WDT_IRQ_TIMER_THRESH_MASK \\\n    ( WDT_IRQ_TIMER_THRESH_BIT << WDT_IRQ_TIMER_THRESH_SHIFT)\n#define WDT_IRQ_TIMER_LSB_MASK ((uint32_t)0xf)\n#define WDT_IRQ_TIMER_LSB_SHIFT (4)\n\n\n\nextern int mbmcs_watchdog_timer_init(mbmcs_watchdog_timer_t *const, uintptr_t)\n    __attribute__ ((optimize(\"Os\")));\nextern void mbmcs_watchdog_timer_set_thresh(mbmcs_watchdog_timer_t const *const, const uint16_t)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_watchdog_timer_set_irq_thresh(mbmcs_watchdog_timer_t const *const, uint16_t)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_watchdog_timer_enable(mbmcs_watchdog_timer_t const *const,bool)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_watchdog_timer_irq_enable(mbmcs_watchdog_timer_t const *const, bool)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_watchdog_timer_interval_reset(mbmcs_watchdog_timer_t const *const)\n    __attribute__ ((optimize(\"O2\")));\nextern void _mbmcs_watchdog_timer_dump_ctrl_reg(mbmcs_watchdog_timer_t const *const)\n    __attribute__ ((optimize(\"O2\")));\n\nint mbmcs_watchdog_timer_init(mbmcs_watchdog_timer_t *const self_p, uintptr_t base_addr)\n{\n    DBMS5(stderr, \"%s : execute\" EOL_CRLF, __FUNCTION__);\n\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n\n    self_p->base_addr = base_addr;\n\n    \n    WDT_OP_REG(self_p->base_addr) = 0x0;\n\n    \n    while(WDT_TIMEDOUT_MASK & WDT_OP_REG(self_p->base_addr));\n\n    return 0;\n}\n\nvoid mbmcs_watchdog_timer_set_thresh(mbmcs_watchdog_timer_t const *const self_p, const uint16_t thresh)\n{\n    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);\n\n    reg32 &= ~WDT_TIMER_THRESHED_MASK;\n    reg32 |= (WDT_TIMER_THRESHED_BIT & thresh);\n\n    WDT_OP_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_watchdog_timer_set_irq_thresh(mbmcs_watchdog_timer_t const *const self_p, uint16_t thresh)\n{\n    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);\n    const uint32_t irq_thresh =  (WDT_IRQ_TIMER_THRESH_BIT & ((uint32_t)thresh >> WDT_IRQ_TIMER_LSB_SHIFT));\n\n    reg32 &= ~WDT_IRQ_TIMER_THRESH_MASK;\n    reg32 |= (irq_thresh << WDT_IRQ_TIMER_THRESH_SHIFT);\n\n    WDT_OP_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_watchdog_timer_enable(mbmcs_watchdog_timer_t const *const self_p, const bool is_true)\n{\n    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);\n\n    reg32 &= ~WDT_MODULE_ENABLE_MASK;\n    if(is_true==true) {\n    reg32 |= WDT_MODULE_ENABLE_MASK;\n    }\n\n    WDT_OP_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_watchdog_timer_irq_enable(mbmcs_watchdog_timer_t const *const self_p, const bool is_true)\n{\n    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);\n\n    reg32 &= ~WDT_IRQ_ENABLE_MASK;\n    if(is_true==true) {\n    reg32 |= WDT_IRQ_ENABLE_MASK;\n    } \n    WDT_OP_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\nvoid mbmcs_watchdog_timer_interval_reset(mbmcs_watchdog_timer_t const *const self_p)\n{\n    WDT_OUNTER_REG(self_p->base_addr) = 0;\n\n    return;\n}\n\nvoid _mbmcs_watchdog_timer_dump_ctrl_reg(mbmcs_watchdog_timer_t const *const self_p)\n{\n    uint32_t reg32 = WDT_OP_REG(self_p->base_addr);\n\n    xil_printf(\"watchdog 0x%08x : 0x%08x\" EOL_CRLF, self_p->base_addr, reg32);\n}\n"}
{"target":"TSN-SHINGENN","func":"\n\n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n\n#include \"mbmcs_stdio.h\"\n#include \"mbmcs_YSM-430AXXA_35_7SEGLED.h\"\n\n\n#ifdef __GNUC__\n__attribute__ ((unused))\n#endif\n#ifdef DEBUG\nstatic int debuglevel = 4;\n#else\nstatic const int debuglevel = 0;\n#endif\n\n#include \"dbms.h\"\n\n#if defined(_MULTIOS_DMSG_IS_UART)\n#define EOL_CRLF \"\\n\\r\"\n#else\n#define EOL_CRLF \"\\n\"\n#endif\n\n#define MBMCS_EXTTEND_MODULE_MEMMAP_ADDR (0xC0000000)\n#define MBMCS_MEMALIGN (4)\n\n\n#define SEGLED_OP_AND_HEX_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x0))\n#define SEGLED_ASCII_REG(a) *((volatile uint32_t*)((uintptr_t)(a) + 0x4))\n\n#define SEG7X4DIGIT_MASK (0x0000ffff)\n#define SEG7X4DOT_SHIFT  (16)\n#define SEG7X4DOT_MASK   (((uint32_t)0xf) << SEG7X4DOT_SHIFT)\n#define SEG7X4COLON_SHIFT (20)\n#define SEG7X4COLON_MASK (((uint32_t)0x1) << SEG7X4COLON_SHIFT)\n#define SEG7X4APOS_SHIFT (21)\n#define SEG7X4APOS_MASK  (((uint32_t)0x1) << SEG7X4APOS_SHIFT)\n#define SEG7X4TEST_SHIFT (30)\n#define SEG7X4TEST_MASK  (((uint32_t)0x1) << SEG7X4TEST_SHIFT )\n#define SEG7X4OFF_SHIFT (31)\n#define SEG7X4OFF_MASK   (((uint32_t)0x1) << SEG7X4OFF_SHIFT )\n#define SEG7X4SELASCII_SHIFT (29)\n#define SEG7X4SELASCII_MASK (((uint32_t)0x1) << SEG7X4SELASCII_SHIFT )\n#define SEG7X4ASCII_MASK (0xffffffff)\n\n\nextern int mbmcs_ysm_430axxa_35_7seg4led_init(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uintptr_t base_addr)\n    __attribute__ ((optimize(\"Os\")));\nextern void mbmcs_ysm_430axxa_35_7seg4led_write_hex_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint16_t data16)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_ysm_430axxa_35_7seg4led_write_dot(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t dots_bit)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_ysm_430axxa_35_7segled_write_colon(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_ysm_430axxa_35_7seg4led_write_apos(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_ysm_430axxa_35_7seg4led_test(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_ysm_430axxa_35_7seg4led_on(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern void mbmcs_ysm_430axxa_35_7seg4led_ascii_mode(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_ysm_430axxa_35_7seg4led_write_ascii_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const char * const str)\n    __attribute__ ((optimize(\"O2\")));\nextern int mbmcs_ysm_430axxa_35_7seg4led_destroy(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p)\n    __attribute__ ((optimize(\"O2\")));\n\n\n\n\nint mbmcs_ysm_430axxa_35_7seg4led_init(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uintptr_t base_addr)\n{\n    if((base_addr < MBMCS_EXTTEND_MODULE_MEMMAP_ADDR) ||  ( base_addr % MBMCS_MEMALIGN )) {\n    return EINVAL;\n    }\n    self_p->base_addr = base_addr;\n \n     return 0;\n}\n\n\nvoid mbmcs_ysm_430axxa_35_7seg4led_write_hex_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint16_t data16)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4DIGIT_MASK;\n    reg32 |= SEG7X4DIGIT_MASK & data16;\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return ;\n}\n\n\nvoid mbmcs_ysm_430axxa_35_7seg4led_write_dot(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t dots_bit)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4DOT_MASK;\n    reg32 |= (SEG7X4DOT_MASK & ((uint32_t)(dots_bit) << SEG7X4DOT_SHIFT));\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nvoid mbmcs_ysm_430axxa_35_7segled_write_colon(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4COLON_MASK;\n    reg32 |= (is_on) ? SEG7X4COLON_MASK : 0x0;\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nvoid mbmcs_ysm_430axxa_35_7seg4led_write_apos(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4APOS_MASK;\n    reg32 |= (is_on) ? SEG7X4APOS_MASK : 0x0;\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nint mbmcs_ysm_430axxa_35_7seg4led_test(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4TEST_MASK;\n    reg32 |= (is_on) ? SEG7X4TEST_MASK : 0x0;\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return 0;\n}\n\n\nint mbmcs_ysm_430axxa_35_7seg4led_on(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4OFF_MASK;\n    reg32 |= (is_on) ? 0x0 : SEG7X4OFF_MASK;\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return 0;\n}\n\n\nvoid mbmcs_ysm_430axxa_35_7seg4led_ascii_mode(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const uint8_t is_on)\n{\n    uint32_t reg32 = SEGLED_OP_AND_HEX_REG(self_p->base_addr);\n    \n    reg32 &= ~SEG7X4SELASCII_MASK;\n    reg32 |= (is_on) ? SEG7X4SELASCII_MASK : 0x0;\n    DBMS3( stderr, \"ASCII_MODE=0x%08x\" EOL_CRLF, reg32);\n\n    SEGLED_OP_AND_HEX_REG(self_p->base_addr) = reg32;\n\n    return;\n}\n\n\nint mbmcs_ysm_430axxa_35_7seg4led_write_ascii_digit(const mbmcs_ysm_430axxa_35_7seg4led_t *const self_p, const char * const str)\n{\n    uint32_t reg32 = 0;\n    const size_t length = strlen(str);\n    size_t n;\n\n    if( !(length <= 4) ) {\n    return EINVAL;\n    }\n\n    for( n=0; n<length; ++n) {\n        reg32 <<= 8;\n    reg32 |= 0xff & str[n];\n    }\n\n    SEGLED_ASCII_REG(self_p->base_addr) = reg32;\n\n    return 0;\n}\n\n\nint mbmcs_ysm_430axxa_35_7seg4led_destroy(mbmcs_ysm_430axxa_35_7seg4led_t *const self_p)\n{\n    (void)self_p;\n\n    return 0;\n}\n\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n\nint strcmp(char *, char *);\n\nint main(){\n char *str[] = {\"aoki\", \"aoki\"};\n int x;\n\n printf(\"%s\u3068%s\u306e\u8f9e\u66f8\u9806\u3092\u8abf\u3079\u308b\u3068\\n\", str[0], str[1]);\n\n x = strcmp(str[0], str[1]);\n\n printf(\"%d\\n\", x);\n\n return 0;\n}\n\nint strcmp(char *str1, char *str2){\n int r, i, a, b, c;\n char *ptr;\n\n for(ptr = str1; *ptr != '\\0'; ptr++){\n  a +=1;\n }\n for(ptr = str2; *ptr != '\\0'; ptr++){\n  b +=1;\n }\n if(a>b){\n  c=a;\n }else{\n  c=b;\n }\n\n for(i=0; i<=c; i++){\n  if(str1[i] != str2[i]){\n   if(str1[i] < str2[i]){\n    r = -1;\n    break;\n   }\n   else{\n    r = 1;\n    break;\n   }\n  }\n r = 0;\n }\n return r;\n}\n"}
{"target":"zjzj-zz","func":"#include <drawlib.h>\n#include <math.h>\n\nvoid dl_hexagon(int x, int y ,int z){\n\ndl_line(15+x , 8+y , 25+x , 8+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(25+x , 8+y , 35+x , 16+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(35+x , 16+y , 25+x , 25+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(25+x , 25+y , 15+x, 25+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(15+x , 25+y , 5+x , 16+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(5+x , 16+y , 15+x , 8+y ,DL_RGB(100-z,125,20+z),3);\n\n}\n\nint main(void) {\n    int i , q;\n\n    dl_initialize(1.0);\n  \n    for (i = 0; i < 13; i++) {\n                dl_hexagon(-i*i+400 , i*13 , i*30);\n                dl_hexagon(i*i+150 , i*13 , i*30);\n                dl_hexagon(-i*i+500 , i*13 , i*17);\n                dl_hexagon(i*i+50 , i*13 , i*17);\n                dl_circle(13*cos(M_PI\/6*i)+150, 13*sin(M_PI\/6*i)+300, 7, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(29*cos(M_PI\/6*i)+150, 29*sin(M_PI\/6*i)+300, 10, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(56*cos(M_PI\/6*i)+150, 56*sin(M_PI\/6*i)+300, 18, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(100*cos(M_PI\/6*i)+150, 100*sin(M_PI\/6*i)+300, 27, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n  }\n        for (q = 0; q < 51; q++) {\n                dl_circle(50*cos(M_PI*q\/25)+500, 50*sin(M_PI*q\/25)+300, 50, DL_RGB(50 , 250-q*q , 10), 3 , 0);\n  }\n    while (1) {\n        dl_wait(1.0);\n  } \n\n    return 0;\n}\n\n"}
{"target":"zjzj-zz","func":"#include <drawlib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <unistd.h>\n\nvoid reflect (float *vx, float *vy, int y, int bary, int barh) {\n  float hity = fabs((float)(y - bary) \/ (barh \/ 2));\n  float weight = 0.75 * hity + 0.75;\n  \n  *vx *= -1.0 * weight;\n  *vy *= weight;\n}\n\nint main(void) {\n  float wait_time = 0.01;\n\n  int barw = 20, barh = 150;\n  int bardy = 50;\n  int bardx = 200;\n  int bar1ix = 70, bar2ix = DL_WIDTH - 70;\n  int bar1x = bar1ix, bar1y = DL_HEIGHT \/ 2;\n  int bar1kup = 'w', bar1kdown = 's', bar1ka = 'e';\n  int bar2x = bar2ix, bar2y = DL_HEIGHT \/ 2;\n  int bar2kup = 'i', bar2kdown = 'k', bar2ka = 'u';\n\n  int br = 15;\n  float bvx = 4.0, bvy = 2.0;\n  int bx = DL_WIDTH \/ 2, by = DL_HEIGHT \/ 2;\n\n  int score1 = 0, score2 = 0;\n  int score1changed = 0;\n  int score2changed = 0;\n  int sx = DL_WIDTH \/ 2 - 120, sy = 50;\n  char sscore[] = \"   :   \";\n\n  int t, k, x, y;\n  \n  dl_initialize(1.0);\n  \n  while (1) {\n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n        if (k == bar1kup)\n          bar1y -= bardy;\n        else if (k == bar1kdown)\n          bar1y += bardy;\n        else if (k == bar1ka) {\n          if (bar1x > bar1ix) \n            bar1x = bar1ix;\n          else\n            bar1x += bardx;\n        } else if (k == bar2kup)\n          bar2y -= bardy;\n        else if (k == bar2kdown)\n          bar2y += bardy;\n        else if (k == bar2ka) {\n          if (bar2x < bar2ix) \n            bar2x = bar2ix;\n          else\n            bar2x -= bardx;\n        }\n      }\n    }\n    if (bar1y - barh \/ 2 < 0)\n      bar1y = barh \/ 2;\n    if (bar1y + barh \/ 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh \/ 2;\n    if (bar2y - barh \/ 2 < 0)\n      bar2y = barh \/ 2;\n    if (bar2y + barh \/ 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh \/ 2;\n\n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n      by += bvy;\n    if (by - br <= 0) {\n      by = br + 1;\n      bvy *= -1;\n    } else if (by + br >= DL_HEIGHT) {\n      by = DL_HEIGHT - br - 1;\n      bvy *= -1;\n    }\n\n    if (by > bar1y - barh \/ 2 && by < bar1y + barh \/ 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw \/ 2 && bx - br >= bar1x - barw \/ 2\n            || bvx > 0 && bx + br >= bar1x - barw \/ 2 && bx + br <= bar1x + barw \/ 2) {\n        reflect (&bvx, &bvy, by, bar1y, barh);\n      }\n    }\n    if (by > bar2y - barh \/ 2 && by < bar2y + barh \/ 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw \/ 2 && bx - br >= bar2x - barw \/ 2\n        || bvx > 0 && bx + br >= bar2x - barw \/ 2 && bx + br <= bar2x + barw \/ 2) {\n        reflect (&bvx, &bvy, by, bar2y, barh);\n      }\n    }\n\n        score1changed = 0;\n        score2changed = 0;\n\n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = 4.0;\n      bvy = 2.0;\n      score2changed = 1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -4.0;\n      bvy = 2.0;\n      score1changed = 1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n      \n    \n    if (score1changed) {\ndl_text(\"+1POINT\",100,50,1.0,DL_C(\"red\"),2);\nsleep(1);\nif (score1>=7){\n dl_text(sscore,sx,sy,2.0,DL_C(\"white\"),2);\n dl_text(\"RED WINNER!\",0,300,2.5,DL_C(\"red\"),2);\n dl_resume();\n sleep(3);\n exit(0);\n}\n            \n    }\n    if (score2changed) {\ndl_text(\"+1POINT\",450,50,1.0,DL_C(\"green\"),2);\nsleep(1);\nif (score2>=7){\n dl_text(sscore,sx,sy,2.0,DL_C(\"white\"),2);\n dl_text(\"GREEN WINNER!\",0,300,2.0,DL_C(\"green\"),2);\n dl_resume();\n sleep(3);\n exit(0);\n}\n            \n        }  \n          \n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    dl_rectangle(bar1x - barw \/ 2, bar1y - barh \/ 2,\n         bar1x + barw \/ 2, bar1y + barh \/ 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw \/ 2, bar2y - barh \/ 2,\n         bar2x + barw \/ 2, bar2y + barh \/ 2, DL_C(\"green\"), 1, 1);\n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    sprintf(sscore, \"%3d:%d\", score1, score2);\n    dl_text(sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    dl_resume();\n\n    dl_wait(wait_time);\n  }\n\n  return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <math.h>\n\ndouble dist(double x1, double y1, double x2, double y2);\n\n\nint main(){\n double a, b, c, d, e, f;\n double z[3], k, o, p, q;\n int i, j;\n printf(\"3\u70b9\u306e\u5ea7\u6a19\u3092\u5165\u529b\u3057\u3066\u4e0b\u3055\u3044\\n\");\n printf(\"1\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &a, &b);\n printf(\"2\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &c, &d);\n printf(\"3\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &e, &f);\n \n\n z[0]=dist(a, b, c, d);\n z[1]=dist(c, d, e, f);\n z[2]=dist(e, f, a, b);\n\n for(i=0; i<3; i++){\n  for(j=0; j<3; j++){\n   if(z[i]<z[j]){\n    k=z[i];\n    z[i]=z[j];\n    z[j]=k;\n   }\n  }\n }\n\n if(z[0]+z[1]>z[2] && z[1]+z[2]>z[0] && z[2]+z[0]>z[1]){\n  printf(\"3\u3064\u306e\u8fba\u306e\u9577\u3055\u306f\\n\");\n  o=z[0];\n  p=z[1];\n  q=z[2];\n\n  printf(\"a=%.2f\\nb=%.2f\\nc=%.2f\\n\", o, p, q);\n  printf(\"\u3053\u306e3\u8fba\u3067\u7d50\u3070\u308c\u305f\u56f3\u5f62\u306f\");\n\n  if(o == p && o == q\/sqrt(2)){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\"); \n   return 0; \n  }else if(sqrt(o*o+p*p) == q){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\"); \n   return 0; \n  }\n   o*=o;\n   p*=p;\n   q*=q;\n  \n  if(q==o+p){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }else if(q < o+p){\n   printf(\"\u92ed\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }else if(q > o+p){\n   printf(\"\u920d\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }\n }\n else{\n  printf(\"\u4e09\u89d2\u5f62\u3067\u306f\u306a\u3044\\n\");\n }\n\n return 0;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n double r;\n r=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n return r;\n}\n"}
{"target":"zjzj-zz","func":"\n#include <drawlib.h>\n#include <stdio.h>\n\nint main(void) {\n  \n  float wait_time = 0.01;\n\n  \n  \n  int barw = 20, barh = 150;\n  \n  int bardy = 50;\n  \n  int bar1x = 70, bar1y = DL_HEIGHT \/ 2;\n  \n  int bar1kup = 'w', bar1kdown = 's';\n  \n  int bar2x = DL_WIDTH - 70, bar2y = DL_HEIGHT \/ 2;\n  \n  int bar2kup = 'i', bar2kdown = 'k';\n\n  \n  \n  int br = 15;\n  \n  int bvx = 5.0, bvy = 5.0;\n  \n  int bx = DL_WIDTH \/ 2, by = DL_HEIGHT \/ 2;\n\n  \n  int score1 = 0, score2 = 0;\n  \n  int sx = DL_WIDTH \/ 2 - 120, sy = 50;\n  \n  char sscore[] = \"   :   \";\n\n  \n  \n  int t, k, x, y;\n  \n  dl_initialize(1.0);\n  \n  while (1) {\n    \n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n    if (k == bar1kup)\n      bar1y -= bardy;\n    else if (k == bar1kdown)\n      bar1y += bardy;\n    else if (k == bar2kup)\n      bar2y -= bardy;\n    else if (k == bar2kdown)\n      bar2y += bardy;\n      }\n    }\n    if (bar1y - barh \/ 2 < 0)\n      bar1y = barh \/ 2;\n    if (bar1y + barh \/ 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh \/ 2;\n    if (bar2y - barh \/ 2 < 0)\n      bar2y = barh \/ 2;\n    if (bar2y + barh \/ 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh \/ 2;\n\n    \n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n    by += bvy;\n    if (by - br <= 0 || by + br >= DL_HEIGHT)\n      bvy *= -1;\n\n    \n    if (by > bar1y - barh \/ 2 && by < bar1y + barh \/ 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw \/ 2 && bx - br >= bar1x - barw \/ 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar1x - barw \/ 2 && bx + br <= bar1x + barw \/ 2)\n    bvx *= -1;\n    }\n    if (by > bar2y - barh \/ 2 && by < bar2y + barh \/ 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw \/ 2 && bx - br >= bar2x - barw \/ 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar2x - barw \/ 2 && bx + br <= bar2x + barw \/ 2)\n    bvx *= -1;\n    }\n\n    \n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = abs(bvx) + 0.1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -abs(bvx) - 0.1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n    \n    \n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    \n    dl_rectangle(bar1x - barw \/ 2, bar1y - barh \/ 2,\n         bar1x + barw \/ 2, bar1y + barh \/ 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw \/ 2, bar2y - barh \/ 2,\n         bar2x + barw \/ 2, bar2y + barh \/ 2, DL_C(\"green\"), 1, 1);\n    \n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    \n    sprintf (sscore, \"%3d:%d\", score1, score2);\n    dl_text (sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    \n    dl_resume();\n\n    dl_wait(wait_time);\n  }\n\n  return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid Count(){\n    FILE *rf, *wf;\n    int i, a;\n    double count[28], total = .0, total2 = .0;\n    for(i = 0; i < 28; i++) count[i] = .0;\n    if((rf = fopen(\"outtext.txt\", \"r\")) != NULL){\n        while((a = fgetc(rf)) != EOF){\n            if('A' <= a && a <= 'Z') count[a-'A']++;\n            else if(a == 0x20) count[26]++;\n            else if(a == 0x0A) count[27]++;\n            if(a != 0x0A) total++;\n        }\n        fclose(rf);\n    }else{\n        printf(\"File open error!\\n\");\n    }\n    wf = fopen(\"probability.txt\", \"w\");\n    for(i = 0; i < 26; i++) printf(\"%c  : %g\\n\", i+65, count[i]);\n    printf(\"SPC: %g\\n\", count[26]);\n    printf(\"LF : %g\\n\", count[27]);\n    printf(\"total : %g\\n\", total);\n    for(i = 0; i < 27; i++) total2 += count[i];\n    printf(\"total : %g\\n\", total2);\n    for(i = 0; i < 27; i++) fprintf(wf, \"%.6lf\\n\", count[i]\/total);\n}\nint main(){\n    Count();\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ndouble f(double x){ \n    return x+cos(x);\n}\n\nvoid initial_value(double x[2] ){ \n    while( (f(x[0])>0 || f(x[1])<0) && (f(x[0])<0 || f(x[1])>0) ){\n        x[0] += 100;\n        x[1] -= 100;\n    }\n}\n\nvoid dichotomy(double x[2] ){ \n    double c;\n    while(1){\n        c = (x[0] + x[1]) \/ 2;\n        if(f(c)*f(x[0]) < 0) x[1] = c;\n        else x[0] = c;\n        if(fabs(x[0]-x[1])<0.0000000001){\n            printf(\"x = %.10lf\\n\",c);\n            exit(1);\n        }\n    }\n}\n\nint main(){ \n    double x[2] = { 0, 0};\n    initial_value(x);\n    dichotomy(x);\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"\n#include <stdio.h>\n#include <math.h>\n#define error 0.0000000001 \n#define N 2 \n\nint main(){\n    double a[N][N] = { { 4.0, 2.0 }, { 4.0, 5.0 } };\n    double b[N] = { 2.0, -7.0 };\n    double x[N], y[N];\n    int i, j, k;\n\n    for( i = 0; i < N; i++ ) x[i]=1.0;\n    for( i = 0; i < 30; i++ ){\n        for( j = 0; j < N; j++ ){\n            for( k = 0; k < N; k++ ) y[k] = x[k];\n            x[j] = ( (a[j][j] * y[j]) + b[j] );\n            for( k = 0; k < N; k++ ){\n                x[j] -= ( a[j][k] * y[k] );\n            }\n            x[j] \/= a[j][j];\n        }\n        printf(\"[i=%2d]\", i+1 );\n        for( j = 0; j < N; j++ ){\n            printf(\" x%d = %.10f \", j+1, x[j]);\n        } \n        printf(\"\\n\");\n    }\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <math.h>\n#define error 0.0000000001 \n#define N 3 \n\nint i, j, k;\n\nvoid initial_value( double x[N] ){ \n    for( i = 0; i < N; i++ ) x[i] = 1.0;\n}\n\nvoid Seidel( double x[N], double  y[N], double a[N][N], double b[N]){ \n    for( j = 0; j < N; j++ ){\n        for( k = 0; k < N; k++ ) y[k] = x[k];\n        x[j] = ( (a[j][j] * y[j]) + b[j] );\n        for( k = 0; k < N; k++ ) x[j] -= ( a[j][k] * y[k] );\n        x[j] \/= a[j][j];\n    }\n}\n\nint Convergence_test( double x[N], double y[N] ){ \n    for( j = 0; j < N; j++ ){\n        if( error < fabs( x[j] - y[j] ))return (1);\n    }\n    return (0);\n}\n\nint main(){ \n    double a[N][N] = { { 5.0, 1.0, 1.0 }, { 1.0, 4.0, 1.0 }, { 2.0, 1.0, 3.0 } }; \n    double b[N] = { 10.0, 12.0, 13.0 };\n    double x[N], y[N];\n    int c = 0;\n\n    initial_value( x );\n\n    while( Convergence_test( x, y) ){ \n        Seidel( x, y, a, b );\n        c++; \n    }\n    printf(\"[%3d\u9031\u76ee] \", c ); \n    for( i = 0; i < N; i++) printf(\" x%d = %.10f \", i+1, x[i] );\n    printf(\"\\n\");\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nFILE *rf, *wf;\nint a , i = 0, n;\ndouble count[28], kakuritu[27];\ndouble r, sum, total = .0;\n\nvoid Conversion(){\n    if((rf = fopen(\"intext.txt\", \"r\")) != NULL){\n        wf = fopen(\"outtext.txt\", \"w\");\n        while((a = fgetc(rf)) != EOF){\n            if('A' <= a && a <= 'Z') a = a;\n            else if('a' <= a && a <= 'z') a = a-0X20;\n            else if(a == 0X0A) a = a;\n            else a = 0X20;\n            fputc(a, wf);\n        }\n        fclose(rf);\n        fclose(wf);\n    }else printf(\"File not open\\n\");\n}\n\nvoid Count(){\n    for(i = 0; i < 28; i++) count[i] = .0;\n    if((rf = fopen(\"outtext.txt\", \"r\")) != NULL){\n        while((a = fgetc(rf)) != EOF){\n            if('A' <= a && a <= 'Z') count[a-'A']++;\n            else if(a == 0X20) count[26]++;\n            else if(a == 0X0A) count[27]++;\n            if(a != 0X0A) total++;\n        }\n        fclose(rf);\n    }else printf(\"File not open\\n\");\n    wf = fopen(\"probability.txt\", \"w\");\n    for(i = 0; i < 27; i++) fprintf(wf, \"%.6lf\\n\", count[i]\/total);\n    fclose(wf);\n}\n\nvoid Create(){\n    srand(time(NULL));\n    i = 0;\n    rf = fopen(\"probability.txt\", \"r\");\n    while(! feof(rf)){\n        fscanf(rf, \"%lf\\n\", &kakuritu[i]);\n        i++;\n    }\n    for(i = 0; i < 100; i++){\n        r = (rand() % 1000000 + 1);\n        r \/= 1000000;\n        for(sum = n = 0; sum < 1; n++){\n            sum += kakuritu[n];\n            if(r < sum){\n                if(n == 26){\n                    printf(\"%c\", 0X20);\n                    break;\n                }else{\n                    printf(\"%c\", n+65);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"\\n\");\n    fclose(rf);\n}\n\nint main(){\n    Conversion();\n    Count();\n    Create();\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define eps (1.0e-11)\n#define f(x) (x*x*2-8)\n#define df(x) (x*4)\n\nint main(){\n    FILE *gp;\n    double xn, xo;\n    int i=0, max=100;\n\n    gp = popen(\"gnuplot -persist\", \"w\");\n    fprintf(gp, \"set yrange [-100: 1000]\\n\");\n    fprintf(gp, \"set xrange [-10: 60]\\n\");\n    fprintf(gp, \"plot x*x*2-8, 0\\n\");\n    xo = (xn = 20) + 1;\n    while(fabs(xn - xo) > eps && i < max){\n        xo = xn;\n        xn = xo - f(xo)\/df(xo);\n        fprintf(gp, \"replot (%lf*4)*(x-%lf) + (%lf*%lf*2-8)\\n\", xo, xo, xo, xo);\n        i++;\n        printf(\"[round:%2d], x = %.10lf\\n\", i, xo);\n    }\n    pclose(gp);\n    if(i == max) printf(\"Not found answer.\\n\");\n    else printf(\"%.10lf\\n\", xo);\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define eps (1.0e-11)\n#define f(x) (log(x)-1)\n#define df(x) (1\/x)\n\nint main(){\n    FILE *gp;\n    double xn, xo;\n    int i=0, max=100;\n\n    gp = popen(\"gnuplot -persist\", \"w\");\n    fprintf(gp, \"set yrange [-2: 2]\\n\");\n    fprintf(gp, \"set xrange [0.5: 5]\\n\");\n    fprintf(gp, \"plot log(x)-1, 0\\n\");\n    xo = (xn = 1) + 1;\n    while(fabs(xn - xo) > eps && i < max){\n        xo = xn;\n        xn = xo - f(xo)\/df(xo);\n        fprintf(gp, \"replot (1\/%lf)*(x-%lf) + (log(%lf)-1)\\n\", xo, xo, xo);\n        i++;\n        printf(\"[round:%2d], x = %.10lf\\n\", i, xo);\n    }\n    pclose(gp);\n    if(i == max) printf(\"Not found answer.\\n\");\n    else if(i == 1) printf(\"Not found answer.\\n\");\n    else printf(\"%.10lf\\n\", xo);\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\nvoid Create(){\n    FILE *rf;\n    double sum, a, kakuritu[27];\n    int i = 0, n;\n\n    srand(time(NULL));\n    rf = fopen(\"probability.txt\", \"r\");\n    while( ! feof(rf)){\n        fscanf(rf, \"%lf\\n\", &kakuritu[i]);\n        i++;\n    }\n    for(i = 0; i < 100; i++){\n        a = (rand() % 1000000 + 1);\n        a \/= 1000000;\n        for(sum = n = 0; sum < 1; n++){\n            sum += kakuritu[n];\n            if(a < sum){\n                if(n == 26){\n                    printf(\"%c\", 0x20);\n                    break;\n                }else{\n                    printf(\"%c\", n+65);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    Create();\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid Count(){\n    FILE *rf, *wf;\n    int i, n, a, b;\n    double count[27][27], total = .0;\n    for(i = 0; i < 27; i++) {\n        for(n = 0; n < 27; n++) count[i][n] = .0;\n    }\n    if((rf = fopen(\"outtext.txt\", \"r\")) != NULL){\n        b = fgetc(rf);\n        while( ! feof(rf)){\n            a = b;\n            b = fgetc(rf);\n            if('A' <= a && a <= 'Z'){\n                if('A' <= b && b <= 'Z') count[a-'A'][b-'A']++;\n                else if(b == 0X20) count[a-'A'][26]++;\n            }else if(a == 0X20){\n                if('A' <= b && b <= 'Z') count[26][b-'A']++;\n                else if(b == 0X20) count[26][26]++;\n            }\n            total++;\n        }\n        fclose(rf);\n    }else{\n        printf(\"File not open\\n\");\n    }\n    wf = fopen(\"probability2.txt\", \"w\");\n    for(i = 0; i < 27; i++){\n        for(n = 0; n < 27; n++){\n            printf(\"%c%c : %g\\n\", i+65, n+65, count[i][n]);\n            fprintf(wf, \"%.6lf\\n\", count[i][n]\/total);\n        }\n    }\n}\n\nint main(){\n    Count();\n    return 0;\n}\n"}
{"target":"zjzj-zz","func":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid Count(){\n    FILE *rf, *wf;\n    int i, j, k, a, b, c;\n    double count[27][27][27], total = .0;\n    for(i = 0; i < 27; i++){\n        for(j = 0; j < 27; j++){\n            for(k = 0; k < 27; k++) count[i][j][k] = .0;\n        }\n    }\n    if((rf = fopen(\"outtext.txt\", \"r\")) != NULL){\n        b = fgetc(rf);\n        c = fgetc(rf);\n        while( ! feof(rf)){\n            a = b;\n            b = c;\n            c = fgetc(rf);\n            if('A' <= a && a <= 'Z'){\n                if('A' <= b && b <= 'Z'){\n                    if('A' <= c && c <= 'Z') count[a-'A'][b-'A'][c-'A']++;\n                    else if(c == 0X20) count[a-'A'][b-'A'][26]++;\n                }else if(b == 0X20){\n                    if('A' <= c && c <= 'Z') count[a-'A'][26][c-'A']++;\n                    else if(c == 0X20) count[a-'A'][26][26]++;\n                }\n            }else if(a = 0X20){\n                if('A' <= b && b <= 'Z'){\n                    if('A' <= c && c <= 'Z') count[26][b-'A'][c-'A']++;\n                    else if(c == 0X20) count[26][b-'A'][26]++;\n                }else if(b == 0X20){\n                    if('A' <= c && c <= 'Z') count[26][26][c-'A']++;\n                    else if(c == 0X20) count[26][26][26]++;\n                }\n            }\n            total++;\n        }\n        fclose(rf);\n    }else printf(\"File not open\\n\");\n    wf = fopen(\"probability3.txt\", \"w\");\n    for(i = 0; i < 27; i++){\n        for(j = 0; j < 27; j++){\n            for(k = 0; k < 27; k++){\n                printf(\"%c%c%c : %g\\n\", i+65, j+65, k+65, count[i][j][k]);\n                fprintf(wf, \"%.6lf\\n\", count[i][j][k]\/total);\n            }\n        }\n    }\n}\n\nint main(){\n    Count();\n    return 0;\n}\n \n"}
