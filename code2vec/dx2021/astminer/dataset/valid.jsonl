{"project": "qemu", "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e", "target": 1, "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);", "idx": 8}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n", "idx": 10}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 15}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n", "idx": 22}
{"project": "qemu", "commit_id": "c39ce112b60ffafbaf700853e32bea74cbb2c148", "target": 0, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 51}
{"project": "qemu", "commit_id": "d4a63ac8b19eb208465f27fde63f3cff7018fdfd", "target": 0, "func": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Fins sPAPRPHBState */\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Releasing MSIs */\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    /* Enabling MSI */\n\n\n\n    /* Check if the device supports as many IRQs as requested */\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); /* Hardware error */\n\n        return;\n\n    }\n\n    /* Correct the number if the guest asked for too many */\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; /* to avoid misleading trace */\n\n        goto out;\n\n    }\n\n\n\n    /* Allocate MSIs */\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    /* Add MSI device to cache */\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n", "idx": 62}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n", "idx": 71}
{"project": "qemu", "commit_id": "df1561e22df42643d769aacdcc7d6d239f243366", "target": 0, "func": "static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd)\n\n{\n\n    const char *opn = \"ldst\";\n\n\n\n    switch (opc) {\n\n    case OPC_MFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_mfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"mfc0\";\n\n        break;\n\n    case OPC_MTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_mtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"mtc0\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case OPC_DMFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_dmfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"dmfc0\";\n\n        break;\n\n    case OPC_DMTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_dmtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"dmtc0\";\n\n        break;\n\n#endif\n\n    case OPC_TLBWI:\n\n        opn = \"tlbwi\";\n\n        if (!env->do_tlbwi)\n\n            goto die;\n\n        gen_op_tlbwi();\n\n        break;\n\n    case OPC_TLBWR:\n\n        opn = \"tlbwr\";\n\n        if (!env->do_tlbwr)\n\n            goto die;\n\n        gen_op_tlbwr();\n\n        break;\n\n    case OPC_TLBP:\n\n        opn = \"tlbp\";\n\n        if (!env->do_tlbp)\n\n            goto die;\n\n        gen_op_tlbp();\n\n        break;\n\n    case OPC_TLBR:\n\n        opn = \"tlbr\";\n\n        if (!env->do_tlbr)\n\n            goto die;\n\n        gen_op_tlbr();\n\n        break;\n\n    case OPC_ERET:\n\n        opn = \"eret\";\n\n        save_cpu_state(ctx, 0);\n\n        gen_op_eret();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    case OPC_DERET:\n\n        opn = \"deret\";\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            MIPS_INVAL(opn);\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            save_cpu_state(ctx, 0);\n\n            gen_op_deret();\n\n            ctx->bstate = BS_EXCP;\n\n        }\n\n        break;\n\n    case OPC_WAIT:\n\n        opn = \"wait\";\n\n        /* If we get an exception, we want to restart at next instruction */\n\n        ctx->pc += 4;\n\n        save_cpu_state(ctx, 1);\n\n        ctx->pc -= 4;\n\n        gen_op_wait();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    default:\n\n die:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s %d\", opn, regnames[rt], rd);\n\n}\n", "idx": 75}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n", "idx": 88}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)\n\n{\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = get_be32(pb);\n\n        if (mxf->packages_count >= UINT_MAX / sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */\n\n        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 125}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX / size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}\n", "idx": 127}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_16w_msa(src - 2,\n\n                            src - (stride * 2) +\n\n                            sizeof(uint8_t), stride, dst, stride, 16);\n\n}\n", "idx": 137}
{"project": "qemu", "commit_id": "35f754620615138aaae0ef72602f84c88fd8de0f", "target": 1, "func": "struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}", "idx": 143}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,\n\n                    ptrdiff_t stride, int h)\n\n{\n\n    const uint8_t *scantable = s->intra_scantable.permutated;\n\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    int i, last, run, bits, level, start_i;\n\n    const int esc_length = s->ac_esc_length;\n\n    uint8_t *length, *last_length;\n\n\n\n    av_assert2(h == 8);\n\n\n\n    s->pdsp.diff_pixels(temp, src1, src2, stride);\n\n\n\n    s->block_last_index[0 /* FIXME */] =\n\n    last                               =\n\n        s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i);\n\n\n\n    bits = 0;\n\n\n\n    if (s->mb_intra) {\n\n        start_i     = 1;\n\n        length      = s->intra_ac_vlc_length;\n\n        last_length = s->intra_ac_vlc_last_length;\n\n        bits       += s->luma_dc_vlc_length[temp[0] + 256]; // FIXME: chroma\n\n    } else {\n\n        start_i     = 0;\n\n        length      = s->inter_ac_vlc_length;\n\n        last_length = s->inter_ac_vlc_last_length;\n\n    }\n\n\n\n    if (last >= start_i) {\n\n        run = 0;\n\n        for (i = start_i; i < last; i++) {\n\n            int j = scantable[i];\n\n            level = temp[j];\n\n\n\n            if (level) {\n\n                level += 64;\n\n                if ((level & (~127)) == 0)\n\n                    bits += length[UNI_AC_ENC_INDEX(run, level)];\n\n                else\n\n                    bits += esc_length;\n\n                run = 0;\n\n            } else\n\n                run++;\n\n        }\n\n        i = scantable[last];\n\n\n\n        level = temp[i] + 64;\n\n\n\n        av_assert2(level - 64);\n\n\n\n        if ((level & (~127)) == 0)\n\n            bits += last_length[UNI_AC_ENC_INDEX(run, level)];\n\n        else\n\n            bits += esc_length;\n\n    }\n\n\n\n    return bits;\n\n}\n", "idx": 146}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n", "idx": 155}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}", "idx": 161}
{"project": "qemu", "commit_id": "1fa795a853255fcc93e5d3e2a92d161a2ed96eb8", "target": 1, "func": "static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n", "idx": 162}
{"project": "qemu", "commit_id": "2662a059aa2affddfbe42e78b11c802cf30a970f", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n#if defined(PPC_DUMP_CPU)\n\n    printf(\"* PowerPC instructions for PVR %08x: %s flags %016\" PRIx64\n\n           \" %08x\\n\",\n\n           def->pvr, def->name, def->insns_flags, def->flags);\n\n#endif\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n#if defined(PPC_DUMP_CPU)\n\n            if (opc1 != 0x00) {\n\n                if (opc->opc3 == 0xFF) {\n\n                    if (opc->opc2 == 0xFF) {\n\n                        printf(\" %02x -- -- (%2d ----) : %s\\n\",\n\n                               opc->opc1, opc->opc1, opc->oname);\n\n                    } else {\n\n                        printf(\" %02x %02x -- (%2d %4d) : %s\\n\",\n\n                               opc->opc1, opc->opc2, opc->opc1, opc->opc2,\n\n                               opc->oname);\n\n                    }\n\n                } else {\n\n                    printf(\" %02x %02x %02x (%2d %4d) : %s\\n\",\n\n                           opc->opc1, opc->opc2, opc->opc3,\n\n                           opc->opc1, (opc->opc3 << 5) | opc->opc2,\n\n                           opc->oname);\n\n                }\n\n            }\n\n#endif\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 166}
{"project": "qemu", "commit_id": "12b7f57e2cfcd665cf5a21b4ae3c23b9361c5c05", "target": 0, "func": "static void smp_parse(const char *optarg)\n\n{\n\n    int smp, sockets = 0, threads = 0, cores = 0;\n\n    char *endptr;\n\n    char option[128];\n\n\n\n    smp = strtoul(optarg, &endptr, 10);\n\n    if (endptr != optarg) {\n\n        if (*endptr == ',') {\n\n            endptr++;\n\n        }\n\n    }\n\n    if (get_param_value(option, 128, \"sockets\", endptr) != 0)\n\n        sockets = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"cores\", endptr) != 0)\n\n        cores = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"threads\", endptr) != 0)\n\n        threads = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"maxcpus\", endptr) != 0)\n\n        max_cpus = strtoull(option, NULL, 10);\n\n\n\n    /* compute missing values, prefer sockets over cores over threads */\n\n    if (smp == 0 || sockets == 0) {\n\n        sockets = sockets > 0 ? sockets : 1;\n\n        cores = cores > 0 ? cores : 1;\n\n        threads = threads > 0 ? threads : 1;\n\n        if (smp == 0) {\n\n            smp = cores * threads * sockets;\n\n        }\n\n    } else {\n\n        if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = smp / (sockets * threads);\n\n        } else {\n\n            threads = smp / (cores * sockets);\n\n        }\n\n    }\n\n    smp_cpus = smp;\n\n    smp_cores = cores > 0 ? cores : 1;\n\n    smp_threads = threads > 0 ? threads : 1;\n\n    if (max_cpus == 0)\n\n        max_cpus = smp_cpus;\n\n}\n", "idx": 174}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}\n", "idx": 183}
{"project": "FFmpeg", "commit_id": "d2a2b08cfe2ab382a4ad756c0a08ff78eb284ef9", "target": 0, "func": "static int config_props(AVFilterLink *outlink)\n\n{\n\n    AVFilterContext *ctx = outlink->src;\n\n    AVFilterLink *inlink = outlink->src->inputs[0];\n\n    ScaleContext *scale = ctx->priv;\n\n    int64_t w, h;\n\n\n\n    if (!(w = scale->w))\n\n        w = inlink->w;\n\n    if (!(h = scale->h))\n\n        h = inlink->h;\n\n    if (w == -1)\n\n        w = av_rescale(h, inlink->w, inlink->h);\n\n    if (h == -1)\n\n        h = av_rescale(w, inlink->h, inlink->w);\n\n\n\n    if (w > INT_MAX || h > INT_MAX ||\n\n        (h * inlink->w) > INT_MAX  ||\n\n        (w * inlink->h) > INT_MAX)\n\n        av_log(ctx, AV_LOG_ERROR, \"Rescaled value for width or height is too big.\\n\");\n\n\n\n    outlink->w = w;\n\n    outlink->h = h;\n\n\n\n    /* TODO: make algorithm configurable */\n\n    scale->sws = sws_getContext(inlink ->w, inlink ->h, inlink ->format,\n\n                                outlink->w, outlink->h, outlink->format,\n\n                                SWS_BILINEAR, NULL, NULL, NULL);\n\n\n\n    av_log(ctx, AV_LOG_INFO, \"w:%d h:%d fmt:%s\\n\",\n\n           outlink->w, outlink->h, av_pix_fmt_descriptors[outlink->format].name);\n\n\n\n    scale->input_is_pal = inlink->format == PIX_FMT_PAL8      ||\n\n                          inlink->format == PIX_FMT_BGR4_BYTE ||\n\n                          inlink->format == PIX_FMT_RGB4_BYTE ||\n\n                          inlink->format == PIX_FMT_BGR8      ||\n\n                          inlink->format == PIX_FMT_RGB8;\n\n\n\n    return !scale->sws;\n\n}\n", "idx": 188}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        return s->frc;\n\n    case 0x04:\t/* VCR */\n\n        return s->vrc;\n\n    case 0x08:\t/* GCR */\n\n        return s->gcr;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 227}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 235}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int find_stream_index(AVFormatContext *s)\n\n{\n\n    int i;\n\n    AVStream *st;\n\n\n\n    if (s->nb_streams <= 0)\n\n        return -1;\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n            return i;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 253}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb,\n\n                               bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUMIPSState *env = &cpu->env;\n\n    DisasContext ctx;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int num_insns;\n\n    int max_insns;\n\n    int insn_bytes;\n\n    int is_branch;\n\n\n\n    if (search_pc)\n\n        qemu_log(\"search pc %d\\n\", search_pc);\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.saved_pc = -1;\n\n    ctx.singlestep_enabled = cs->singlestep_enabled;\n\n    ctx.insn_flags = env->insn_flags;\n\n    ctx.tb = tb;\n\n    ctx.bstate = BS_NONE;\n\n    /* Restore delay slot state from the tb context.  */\n\n    ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */\n\n    restore_cpu_state(env, &ctx);\n\n#ifdef CONFIG_USER_ONLY\n\n        ctx.mem_idx = MIPS_HFLAG_UM;\n\n#else\n\n        ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n    LOG_DISAS(\"\\ntb %p idx %d hflags %04x\\n\", tb, ctx.mem_idx, ctx.hflags);\n\n    gen_tb_start();\n\n    while (ctx.bstate == BS_NONE) {\n\n        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    save_cpu_state(&ctx, 1);\n\n                    ctx.bstate = BS_BRANCH;\n\n                    gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n                    /* Include the breakpoint location or the tb won't\n\n                     * be flushed when it must be.  */\n\n                    ctx.pc += 4;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = ctx.pc;\n\n            gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK;\n\n            gen_opc_btarget[lj] = ctx.btarget;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        is_branch = 0;\n\n        if (!(ctx.hflags & MIPS_HFLAG_M16)) {\n\n            ctx.opcode = cpu_ldl_code(env, ctx.pc);\n\n            insn_bytes = 4;\n\n            decode_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MICROMIPS) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_micromips_opc(env, &ctx, &is_branch);\n\n        } else if (ctx.insn_flags & ASE_MIPS16) {\n\n            ctx.opcode = cpu_lduw_code(env, ctx.pc);\n\n            insn_bytes = decode_mips16_opc(env, &ctx, &is_branch);\n\n        } else {\n\n            generate_exception(&ctx, EXCP_RI);\n\n            ctx.bstate = BS_STOP;\n\n            break;\n\n        }\n\n        if (!is_branch) {\n\n            handle_delay_slot(&ctx, insn_bytes);\n\n        }\n\n        ctx.pc += insn_bytes;\n\n\n\n        num_insns++;\n\n\n\n        /* Execute a branch and its delay slot as a single instruction.\n\n           This is what GDB expects and is consistent with what the\n\n           hardware does (e.g. if a delay slot instruction faults, the\n\n           reported PC is the PC of the branch).  */\n\n        if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) {\n\n            break;\n\n        }\n\n\n\n        if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0)\n\n            break;\n\n\n\n        if (tcg_ctx.gen_opc_ptr >= gen_opc_end) {\n\n            break;\n\n        }\n\n\n\n        if (num_insns >= max_insns)\n\n            break;\n\n\n\n        if (singlestep)\n\n            break;\n\n    }\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) {\n\n        save_cpu_state(&ctx, ctx.bstate == BS_NONE);\n\n        gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n    } else {\n\n        switch (ctx.bstate) {\n\n        case BS_STOP:\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_NONE:\n\n            save_cpu_state(&ctx, 0);\n\n            gen_goto_tb(&ctx, 0, ctx.pc);\n\n            break;\n\n        case BS_EXCP:\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case BS_BRANCH:\n\n        default:\n\n            break;\n\n        }\n\n    }\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    LOG_DISAS(\"\\n\");\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(env, pc_start, ctx.pc - pc_start, 0);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 255}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n", "idx": 257}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    url_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    url_fclose(rtpctx->pb);\n\n                }\n\n                av_metadata_free(&rtpctx->streams[0]->metadata);\n\n                av_metadata_free(&rtpctx->metadata);\n\n\n                av_free(rtpctx->streams[0]);\n\n                av_free(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (CONFIG_RTPDEC)\n\n                rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            url_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}", "idx": 268}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void musb_rx_req(MUSBState *s, int epnum)\n\n{\n\n    MUSBEndPoint *ep = s->ep + epnum;\n\n    int total;\n\n\n\n    /* If we already have a packet, which didn't fit into the\n\n     * 64 bytes of the FIFO, only move the FIFO start and return. (Obsolete) */\n\n    if (ep->packey[1].p.pid == USB_TOKEN_IN && ep->status[1] >= 0 &&\n\n                    (ep->fifostart[1]) + ep->rxcount <\n\n                    ep->packey[1].p.len) {\n\n        TRACE(\"0x%08x, %d\",  ep->fifostart[1], ep->rxcount );\n\n        ep->fifostart[1] += ep->rxcount;\n\n        ep->fifolen[1] = 0;\n\n\n\n        ep->rxcount = MIN(ep->packey[0].p.len - (ep->fifostart[1]),\n\n                        ep->maxp[1]);\n\n\n\n        ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT;\n\n        if (!epnum)\n\n            ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT;\n\n\n\n        /* Clear all of the error bits first */\n\n        ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL |\n\n                        MGC_M_RXCSR_DATAERROR);\n\n        if (!epnum)\n\n            ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL |\n\n                            MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_NO_PING);\n\n\n\n        ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY;\n\n        if (!epnum)\n\n            ep->csr[0] |= MGC_M_CSR0_RXPKTRDY;\n\n        musb_rx_intr_set(s, epnum, 1);\n\n        return;\n\n    }\n\n\n\n    /* The driver sets maxp[1] to 64 or less because it knows the hardware\n\n     * FIFO is this deep.  Bigger packets get split in\n\n     * usb_generic_handle_packet but we can also do the splitting locally\n\n     * for performance.  It turns out we can also have a bigger FIFO and\n\n     * ignore the limit set in ep->maxp[1].  The Linux MUSB driver deals\n\n     * OK with single packets of even 32KB and we avoid splitting, however\n\n     * usb_msd.c sometimes sends a packet bigger than what Linux expects\n\n     * (e.g. 8192 bytes instead of 4096) and we get an OVERRUN.  Splitting\n\n     * hides this overrun from Linux.  Up to 4096 everything is fine\n\n     * though.  Currently this is disabled.\n\n     *\n\n     * XXX: mind ep->fifosize.  */\n\n    total = MIN(ep->maxp[1] & 0x3ff, sizeof(s->buf));\n\n\n\n#ifdef SETUPLEN_HACK\n\n    /* Why should *we* do that instead of Linux?  */\n\n    if (!epnum) {\n\n        if (ep->packey[0].p.devaddr == 2) {\n\n            total = MIN(s->setup_len, 8);\n\n        } else {\n\n            total = MIN(s->setup_len, 64);\n\n        }\n\n        s->setup_len -= total;\n\n    }\n\n#endif\n\n\n\n    return musb_packet(s, ep, epnum, USB_TOKEN_IN,\n\n                    total, musb_rx_packet_complete, 1);\n\n}\n", "idx": 274}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    /* TimerPeriphID */\n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    /* Integration Test control registers, which we won't support */\n\n    case 0xf00: /* TimerITCR */\n\n    case 0xf04: /* TimerITOP (strictly write only but..) */\n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}\n", "idx": 292}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    /* Interrupt execution to force deadline recalculation.  */\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n", "idx": 298}
{"project": "qemu", "commit_id": "c21bbcfa3ff4f6dc49fb01080ef598851aa424dd", "target": 0, "func": "CharDriverState *text_console_init(DisplayState *ds, const char *p)\n\n{\n\n    CharDriverState *chr;\n\n    TextConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n    static int color_inited;\n\n\n\n    chr = qemu_mallocz(sizeof(CharDriverState));\n\n    if (!chr)\n\n        return NULL;\n\n    s = new_console(ds, TEXT_CONSOLE);\n\n    if (!s) {\n\n        free(chr);\n\n        return NULL;\n\n    }\n\n    if (!p)\n\n        p = DEFAULT_MONITOR_SIZE;\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = console_puts;\n\n    chr->chr_send_event = console_send_event;\n\n\n\n    s->chr = chr;\n\n    s->out_fifo.buf = s->out_fifo_buf;\n\n    s->out_fifo.buf_size = sizeof(s->out_fifo_buf);\n\n    s->kbd_timer = qemu_new_timer(rt_clock, kbd_send_chars, s);\n\n\n\n    if (!color_inited) {\n\n        color_inited = 1;\n\n        console_color_init(s->ds);\n\n    }\n\n    s->y_displayed = 0;\n\n    s->y_base = 0;\n\n    s->total_height = DEFAULT_BACKSCROLL;\n\n    s->x = 0;\n\n    s->y = 0;\n\n    width = s->ds->width;\n\n    height = s->ds->height;\n\n    if (p != 0) {\n\n        width = strtoul(p, (char **)&p, 10);\n\n        if (*p == 'C') {\n\n            p++;\n\n            width *= FONT_WIDTH;\n\n        }\n\n        if (*p == 'x') {\n\n            p++;\n\n            height = strtoul(p, (char **)&p, 10);\n\n            if (*p == 'C') {\n\n                p++;\n\n                height *= FONT_HEIGHT;\n\n            }\n\n        }\n\n    }\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n\n\n    s->hw_invalidate = text_console_invalidate;\n\n    s->hw_text_update = text_console_update;\n\n    s->hw = s;\n\n\n\n    /* Set text attribute defaults */\n\n    s->t_attrib_default.bold = 0;\n\n    s->t_attrib_default.uline = 0;\n\n    s->t_attrib_default.blink = 0;\n\n    s->t_attrib_default.invers = 0;\n\n    s->t_attrib_default.unvisible = 0;\n\n    s->t_attrib_default.fgcol = COLOR_WHITE;\n\n    s->t_attrib_default.bgcol = COLOR_BLACK;\n\n\n\n    /* set current text attributes to default */\n\n    s->t_attrib = s->t_attrib_default;\n\n    text_console_resize(s);\n\n\n\n    qemu_chr_reset(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 300}
{"project": "qemu", "commit_id": "c19f47bf5e8fe3dbd10206a52d0e6e348f803933", "target": 0, "func": "static void tcg_liveness_analysis(TCGContext *s)\n\n{\n\n    uint8_t *dead_temps, *mem_temps;\n\n    int oi, oi_prev, nb_ops;\n\n\n\n    nb_ops = s->gen_next_op_idx;\n\n    s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t));\n\n    s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t));\n\n    \n\n    dead_temps = tcg_malloc(s->nb_temps);\n\n    mem_temps = tcg_malloc(s->nb_temps);\n\n    tcg_la_func_end(s, dead_temps, mem_temps);\n\n\n\n    for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) {\n\n        int i, nb_iargs, nb_oargs;\n\n        TCGOpcode opc_new, opc_new2;\n\n        bool have_opc_new2;\n\n        uint16_t dead_args;\n\n        uint8_t sync_args;\n\n        TCGArg arg;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_prev = op->prev;\n\n\n\n        switch (opc) {\n\n        case INDEX_op_call:\n\n            {\n\n                int call_flags;\n\n\n\n                nb_oargs = op->callo;\n\n                nb_iargs = op->calli;\n\n                call_flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n                /* pure functions can be removed if their result is unused */\n\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (!dead_temps[arg] || mem_temps[arg]) {\n\n                            goto do_not_remove_call;\n\n                        }\n\n                    }\n\n                    goto do_remove;\n\n                } else {\n\n                do_not_remove_call:\n\n\n\n                    /* output args are dead */\n\n                    dead_args = 0;\n\n                    sync_args = 0;\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (dead_temps[arg]) {\n\n                            dead_args |= (1 << i);\n\n                        }\n\n                        if (mem_temps[arg]) {\n\n                            sync_args |= (1 << i);\n\n                        }\n\n                        dead_temps[arg] = 1;\n\n                        mem_temps[arg] = 0;\n\n                    }\n\n\n\n                    if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n\n                        /* globals should be synced to memory */\n\n                        memset(mem_temps, 1, s->nb_globals);\n\n                    }\n\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n\n                        /* globals should go back to memory */\n\n                        memset(dead_temps, 1, s->nb_globals);\n\n                    }\n\n\n\n                    /* input args are live */\n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (arg != TCG_CALL_DUMMY_ARG) {\n\n                            if (dead_temps[arg]) {\n\n                                dead_args |= (1 << i);\n\n                            }\n\n                            dead_temps[arg] = 0;\n\n                        }\n\n                    }\n\n                    s->op_dead_args[oi] = dead_args;\n\n                    s->op_sync_args[oi] = sync_args;\n\n                }\n\n            }\n\n            break;\n\n        case INDEX_op_debug_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            /* mark the temporary as dead */\n\n            dead_temps[args[0]] = 1;\n\n            mem_temps[args[0]] = 0;\n\n            break;\n\n\n\n        case INDEX_op_add2_i32:\n\n            opc_new = INDEX_op_add_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i32:\n\n            opc_new = INDEX_op_sub_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_add2_i64:\n\n            opc_new = INDEX_op_add_i64;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i64:\n\n            opc_new = INDEX_op_sub_i64;\n\n        do_addsub2:\n\n            nb_iargs = 4;\n\n            nb_oargs = 2;\n\n            /* Test if the high part of the operation is dead, but not\n\n               the low part.  The result can be optimized to a simple\n\n               add or sub.  This happens often for x86_64 guest when the\n\n               cpu mode is set to 32 bit.  */\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    goto do_remove;\n\n                }\n\n                /* Replace the opcode and adjust the args in place,\n\n                   leaving 3 unused args at the end.  */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                /* Fall through and mark the single-word operation live.  */\n\n                nb_iargs = 2;\n\n                nb_oargs = 1;\n\n            }\n\n            goto do_not_remove;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_muluh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_mulsh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_mulu2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_muluh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i64;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_mulsh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i64;\n\n            goto do_mul2;\n\n        do_mul2:\n\n            nb_iargs = 2;\n\n            nb_oargs = 2;\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    /* Both parts of the operation are dead.  */\n\n                    goto do_remove;\n\n                }\n\n                /* The high part of the operation is dead; generate the low. */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else if (have_opc_new2 && dead_temps[args[0]]\n\n                       && !mem_temps[args[0]]) {\n\n                /* The low part of the operation is dead; generate the high. */\n\n                op->opc = opc = opc_new2;\n\n                args[0] = args[1];\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else {\n\n                goto do_not_remove;\n\n            }\n\n            /* Mark the single-word operation live.  */\n\n            nb_oargs = 1;\n\n            goto do_not_remove;\n\n\n\n        default:\n\n            /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */\n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            /* Test if the operation can be removed because all\n\n               its outputs are dead. We assume that nb_oargs == 0\n\n               implies side effects */\n\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (!dead_temps[arg] || mem_temps[arg]) {\n\n                        goto do_not_remove;\n\n                    }\n\n                }\n\n            do_remove:\n\n                tcg_op_remove(s, op);\n\n            } else {\n\n            do_not_remove:\n\n                /* output args are dead */\n\n                dead_args = 0;\n\n                sync_args = 0;\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    if (mem_temps[arg]) {\n\n                        sync_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 1;\n\n                    mem_temps[arg] = 0;\n\n                }\n\n\n\n                /* if end of basic block, update */\n\n                if (def->flags & TCG_OPF_BB_END) {\n\n                    tcg_la_bb_end(s, dead_temps, mem_temps);\n\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                    /* globals should be synced to memory */\n\n                    memset(mem_temps, 1, s->nb_globals);\n\n                }\n\n\n\n                /* input args are live */\n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 0;\n\n                }\n\n                s->op_dead_args[oi] = dead_args;\n\n                s->op_sync_args[oi] = sync_args;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 301}
{"project": "qemu", "commit_id": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2", "target": 0, "func": "bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}\n", "idx": 311}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n", "idx": 319}
{"project": "FFmpeg", "commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "target": 1, "func": "static void generate_offset_lut(DiracGolombLUT *lut, int off)\n\n{\n\n    int idx;\n\n    for (idx = 0; idx < LUT_SIZE; idx++) {\n\n        DiracGolombLUT *l = &lut[idx];\n\n\n\n        INIT_RESIDUE(res);\n\n        SET_RESIDUE(res, idx, LUT_BITS);\n\n\n\n        l->preamble      = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off);\n\n        l->preamble_bits = off;\n\n        l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1;\n\n\n\n        search_for_golomb(l, res << off, LUT_BITS - off);\n\n    }\n\n}\n", "idx": 342}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        /* Only read after generation field verification */\n\n        smp_rmb();\n\n        /* Re-read to be sure we got the latest version */\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 345}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_BookE (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFE0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 346}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n", "idx": 354}
{"project": "FFmpeg", "commit_id": "1e4eb387d4768089cfe8db0141ccc23089694fce", "target": 1, "func": "static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int depth,\n\n                                    const uint8_t *data, int srcsize)\n\n{\n\n    uint8_t *output, *output_end;\n\n    const uint8_t* src = data;\n\n    int p1, p2, line=avctx->height, pos=0, i;\n\n    uint16_t pix16;\n\n    uint32_t pix32;\n\n\n\n    output = pic->data[0] + (avctx->height - 1) * pic->linesize[0];\n\n    output_end = pic->data[0] + (avctx->height) * pic->linesize[0];\n\n    while(src < data + srcsize) {\n\n        p1 = *src++;\n\n        if(p1 == 0) { //Escape code\n\n            p2 = *src++;\n\n            if(p2 == 0) { //End-of-line\n\n                output = pic->data[0] + (--line) * pic->linesize[0];\n\n                if (line < 0){\n\n                    av_log(avctx, AV_LOG_ERROR, \"Next line is beyond picture bounds\\n\");\n\n                    return -1;\n\n                }\n\n                pos = 0;\n\n                continue;\n\n            } else if(p2 == 1) { //End-of-picture\n\n                return 0;\n\n            } else if(p2 == 2) { //Skip\n\n                p1 = *src++;\n\n                p2 = *src++;\n\n                line -= p2;\n\n                if (line < 0){\n\n                    av_log(avctx, AV_LOG_ERROR, \"Skip beyond picture bounds\\n\");\n\n                    return -1;\n\n                }\n\n                pos += p1;\n\n                output = pic->data[0] + line * pic->linesize[0] + pos * (depth >> 3);\n\n                continue;\n\n            }\n\n            // Copy data\n\n            if (output + p2 * (depth >> 3) > output_end) {\n\n                src += p2 * (depth >> 3);\n\n                continue;\n\n            }\n\n            if ((depth == 8) || (depth == 24)) {\n\n                for(i = 0; i < p2 * (depth >> 3); i++) {\n\n                    *output++ = *src++;\n\n                }\n\n                // RLE8 copy is actually padded - and runs are not!\n\n                if(depth == 8 && (p2 & 1)) {\n\n                    src++;\n\n                }\n\n            } else if (depth == 16) {\n\n                for(i = 0; i < p2; i++) {\n\n                    pix16 = AV_RL16(src);\n\n                    src += 2;\n\n                    *(uint16_t*)output = pix16;\n\n                    output += 2;\n\n                }\n\n            } else if (depth == 32) {\n\n                for(i = 0; i < p2; i++) {\n\n                    pix32 = AV_RL32(src);\n\n                    src += 4;\n\n                    *(uint32_t*)output = pix32;\n\n                    output += 4;\n\n                }\n\n            }\n\n            pos += p2;\n\n        } else { //Run of pixels\n\n            uint8_t pix[3]; //original pixel\n\n            switch(depth){\n\n            case  8: pix[0] = *src++;\n\n                     break;\n\n            case 16: pix16 = AV_RL16(src);\n\n                     src += 2;\n\n                     break;\n\n            case 24: pix[0] = *src++;\n\n                     pix[1] = *src++;\n\n                     pix[2] = *src++;\n\n                     break;\n\n            case 32: pix32 = AV_RL32(src);\n\n                     src += 4;\n\n                     break;\n\n            }\n\n            if (output + p1 * (depth >> 3) > output_end)\n\n                continue;\n\n            for(i = 0; i < p1; i++) {\n\n                switch(depth){\n\n                case  8: *output++ = pix[0];\n\n                         break;\n\n                case 16: *(uint16_t*)output = pix16;\n\n                         output += 2;\n\n                         break;\n\n                case 24: *output++ = pix[0];\n\n                         *output++ = pix[1];\n\n                         *output++ = pix[2];\n\n                         break;\n\n                case 32: *(uint32_t*)output = pix32;\n\n                         output += 4;\n\n                         break;\n\n                }\n\n            }\n\n            pos += p1;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_WARNING, \"MS RLE warning: no End-of-picture code\\n\");\n\n    return 0;\n\n}\n", "idx": 355}
{"project": "FFmpeg", "commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "target": 1, "func": "static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2,\n\n                                          int width)\n\n{\n\n    int i;\n\n    TYPE *b0 = (TYPE *)_b0;\n\n    TYPE *b1 = (TYPE *)_b1;\n\n    TYPE *b2 = (TYPE *)_b2;\n\n    for (i = 0; i < width; i++)\n\n        b1[i] -= (b0[i] + b2[i] + 2) >> 2;\n\n}\n", "idx": 368}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static void handle_user_command(Monitor *mon, const char *cmdline)\n\n{\n\n    QDict *qdict;\n\n    const mon_cmd_t *cmd;\n\n\n\n    qdict = qdict_new();\n\n\n\n    cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict);\n\n    if (!cmd)\n\n        goto out;\n\n\n\n    if (handler_is_async(cmd)) {\n\n        user_async_cmd_handler(mon, cmd, qdict);\n\n    } else if (handler_is_qobject(cmd)) {\n\n        QObject *data = NULL;\n\n\n\n        /* XXX: ignores the error code */\n\n        cmd->mhandler.cmd_new(mon, qdict, &data);\n\n        assert(!monitor_has_error(mon));\n\n        if (data) {\n\n            cmd->user_print(mon, data);\n\n            qobject_decref(data);\n\n        }\n\n    } else {\n\n        cmd->mhandler.cmd(mon, qdict);\n\n    }\n\n\n\nout:\n\n    QDECREF(qdict);\n\n}\n", "idx": 378}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv pc)\n\n{\n\n    TCGv tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, 0xffffffff);\n\n    dead_tmp(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 390}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int fourxm_read_packet(AVFormatContext *s,\n\n                              AVPacket *pkt)\n\n{\n\n    FourxmDemuxContext *fourxm = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    unsigned int fourcc_tag;\n\n    unsigned int size, out_size;\n\n    int ret = 0;\n\n    int track_number;\n\n    int packet_read = 0;\n\n    unsigned char header[8];\n\n    int64_t pts_inc;\n\n    int audio_frame_count;\n\n\n\n    while (!packet_read) {\n\n\n\n        if ((ret = get_buffer(&s->pb, header, 8)) < 0)\n\n            return ret;\n\n        fourcc_tag = LE_32(&header[0]);\n\n        size = LE_32(&header[4]);\n\n        if (url_feof(pb))\n\n            return AVERROR_IO;\n\n        switch (fourcc_tag) {\n\n\n\n        case LIST_TAG:\n\n            /* this is a good time to bump the video pts */\n\n            fourxm->video_pts += fourxm->video_pts_inc;\n\n\n\n            /* skip the LIST-* tag and move on to the next fourcc */\n\n            get_le32(pb);\n\n            break;\n\n\n\n        case ifrm_TAG:\n\n        case pfrm_TAG:\n\n        case cfrm_TAG:{\n\n\n\n            /* allocate 8 more bytes than 'size' to account for fourcc\n\n             * and size */\n\n            if (av_new_packet(pkt, size + 8))\n\n                return AVERROR_IO;\n\n            pkt->stream_index = fourxm->video_stream_index;\n\n            pkt->pts = fourxm->video_pts;\n\n            memcpy(pkt->data, header, 8);\n\n            ret = get_buffer(&s->pb, &pkt->data[8], size);\n\n\n\n            if (ret < 0)\n\n                av_free_packet(pkt);\n\n            else\n\n                packet_read = 1;\n\n            break;\n\n        }\n\n\n\n        case snd__TAG:\n\n            track_number = get_le32(pb);\n\n            out_size= get_le32(pb);\n\n            size-=8;\n\n\n\n            if (track_number == fourxm->selected_track) {\n\n                if (av_new_packet(pkt, size))\n\n                    return AVERROR_IO;\n\n                pkt->stream_index = \n\n                    fourxm->tracks[fourxm->selected_track].stream_index;\n\n                pkt->pts = fourxm->audio_pts;\n\n                ret = get_buffer(&s->pb, pkt->data, size);\n\n                if (ret < 0)\n\n                    av_free_packet(pkt);\n\n                else\n\n                    packet_read = 1;\n\n\n\n                /* pts accounting */\n\n                audio_frame_count = size;\n\n                if (fourxm->tracks[fourxm->selected_track].adpcm)\n\n                    audio_frame_count -= \n\n                        2 * (fourxm->tracks[fourxm->selected_track].channels);\n\n                audio_frame_count /=\n\n                      fourxm->tracks[fourxm->selected_track].channels;\n\n                if (fourxm->tracks[fourxm->selected_track].adpcm)\n\n                    audio_frame_count *= 2;\n\n                else \n\n                    audio_frame_count /=\n\n                    (fourxm->tracks[fourxm->selected_track].bits / 8);\n\n                pts_inc = audio_frame_count;\n\n                pts_inc *= 90000;\n\n                pts_inc /= fourxm->tracks[fourxm->selected_track].sample_rate;\n\n                fourxm->audio_pts += pts_inc;\n\n\n\n            } else {\n\n                url_fseek(pb, size, SEEK_CUR);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            url_fseek(pb, size, SEEK_CUR);\n\n            break;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 395}
{"project": "qemu", "commit_id": "db0289b9b26cb653d5662f5d6a2a52d70243cd56", "target": 1, "func": "static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)\n\n{\n\n    BdrvChild *child, *tmp;\n\n    bool waited;\n\n\n\n    /* Ensure any pending metadata writes are submitted to bs->file.  */\n\n    bdrv_drain_invoke(bs, begin);\n\n\n\n    /* Wait for drained requests to finish */\n\n    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);\n\n\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {\n\n        BlockDriverState *bs = child->bs;\n\n        bool in_main_loop =\n\n            qemu_get_current_aio_context() == qemu_get_aio_context();\n\n        assert(bs->refcnt > 0);\n\n        if (in_main_loop) {\n\n            /* In case the recursive bdrv_drain_recurse processes a\n\n             * block_job_defer_to_main_loop BH and modifies the graph,\n\n             * let's hold a reference to bs until we are done.\n\n             *\n\n             * IOThread doesn't have such a BH, and it is not safe to call\n\n             * bdrv_unref without BQL, so skip doing it there.\n\n             */\n\n            bdrv_ref(bs);\n\n        }\n\n        waited |= bdrv_drain_recurse(bs, begin);\n\n        if (in_main_loop) {\n\n            bdrv_unref(bs);\n\n        }\n\n    }\n\n\n\n    return waited;\n\n}\n", "idx": 396}
{"project": "FFmpeg", "commit_id": "a8d67efa53dae1d14614e3a7bd4e77e4eab066ab", "target": 0, "func": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {\n\n    int num_pos_channels = 0;\n\n    int first_cpe = 0;\n\n    int sce_parity = 0;\n\n    int i;\n\n    for (i = *current; i < tags; i++) {\n\n        if (layout_map[i][2] != pos)\n\n            break;\n\n        if (layout_map[i][0] == TYPE_CPE) {\n\n            if (sce_parity) {\n\n                if (pos == AAC_CHANNEL_FRONT || !first_cpe) {\n\n                    sce_parity = 0;\n\n                } else {\n\n                    return -1;\n\n                }\n\n            }\n\n            num_pos_channels += 2;\n\n            first_cpe = 1;\n\n        } else {\n\n            num_pos_channels++;\n\n            sce_parity ^= 1;\n\n        }\n\n    }\n\n    if (sce_parity &&\n\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n\n            return -1;\n\n    *current = i;\n\n    return num_pos_channels;\n\n}\n", "idx": 420}
{"project": "qemu", "commit_id": "ecbb5ea1041d2894f5efb9317acd519c4fd81ad5", "target": 1, "func": "uint64_t helper_sublv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 - op2);\n\n    if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) {\n\n        helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW);\n\n    }\n\n    return op1;\n\n}\n", "idx": 427}
{"project": "FFmpeg", "commit_id": "bbe26eff2235dc2d1c79a5a1e25b46d8d7f0fe08", "target": 1, "func": "static int decode_slice(struct AVCodecContext *avctx, void *arg)\n\n{\n\n    H264Context *h = *(void **)arg;\n\n    int lf_x_start = h->mb_x;\n\n\n\n    h->mb_skip_run = -1;\n\n\n\n    av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3));\n\n\n\n    h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n\n                    avctx->codec_id != AV_CODEC_ID_H264 ||\n\n                    (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY));\n\n\n\n    if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME) {\n\n        const int start_i  = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1);\n\n        if (start_i) {\n\n            int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]];\n\n            prev_status &= ~ VP_START;\n\n            if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END))\n\n                h->er.error_occurred = 1;\n\n        }\n\n    }\n\n\n\n    if (h->pps.cabac) {\n\n        /* realign */\n\n        align_get_bits(&h->gb);\n\n\n\n        /* init cabac */\n\n        ff_init_cabac_decoder(&h->cabac,\n\n                              h->gb.buffer + get_bits_count(&h->gb) / 8,\n\n                              (get_bits_left(&h->gb) + 7) / 8);\n\n\n\n        ff_h264_init_cabac_states(h);\n\n\n\n        for (;;) {\n\n            // START_TIMER\n\n            int ret = ff_h264_decode_mb_cabac(h);\n\n            int eos;\n\n            // STOP_TIMER(\"decode_mb_cabac\")\n\n\n\n            if (ret >= 0)\n\n                ff_h264_hl_decode_mb(h);\n\n\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n\n                h->mb_y++;\n\n\n\n                ret = ff_h264_decode_mb_cabac(h);\n\n\n\n                if (ret >= 0)\n\n                    ff_h264_hl_decode_mb(h);\n\n                h->mb_y--;\n\n            }\n\n            eos = get_cabac_terminate(&h->cabac);\n\n\n\n            if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n\n                h->cabac.bytestream > h->cabac.bytestream_end + 2) {\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n\n                                h->mb_y, ER_MB_END);\n\n                if (h->mb_x >= lf_x_start)\n\n                    loop_filter(h, lf_x_start, h->mb_x + 1);\n\n                return 0;\n\n            }\n\n            if (h->cabac.bytestream > h->cabac.bytestream_end + 2 )\n\n                av_log(h->avctx, AV_LOG_DEBUG, \"bytestream overread %td\\n\", h->cabac.bytestream_end - h->cabac.bytestream);\n\n            if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"error while decoding MB %d %d, bytestream (%td)\\n\",\n\n                       h->mb_x, h->mb_y,\n\n                       h->cabac.bytestream_end - h->cabac.bytestream);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                h->mb_y, ER_MB_ERROR);\n\n                return -1;\n\n            }\n\n\n\n            if (++h->mb_x >= h->mb_width) {\n\n                loop_filter(h, lf_x_start, h->mb_x);\n\n                h->mb_x = lf_x_start = 0;\n\n                decode_finish_row(h);\n\n                ++h->mb_y;\n\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n\n                    ++h->mb_y;\n\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n\n                        predict_field_decoding_flag(h);\n\n                }\n\n            }\n\n\n\n            if (eos || h->mb_y >= h->mb_height) {\n\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n\n                                h->mb_y, ER_MB_END);\n\n                if (h->mb_x > lf_x_start)\n\n                    loop_filter(h, lf_x_start, h->mb_x);\n\n                return 0;\n\n            }\n\n        }\n\n    } else {\n\n        for (;;) {\n\n            int ret = ff_h264_decode_mb_cavlc(h);\n\n\n\n            if (ret >= 0)\n\n                ff_h264_hl_decode_mb(h);\n\n\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n\n                h->mb_y++;\n\n                ret = ff_h264_decode_mb_cavlc(h);\n\n\n\n                if (ret >= 0)\n\n                    ff_h264_hl_decode_mb(h);\n\n                h->mb_y--;\n\n            }\n\n\n\n            if (ret < 0) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"error while decoding MB %d %d\\n\", h->mb_x, h->mb_y);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                h->mb_y, ER_MB_ERROR);\n\n                return -1;\n\n            }\n\n\n\n            if (++h->mb_x >= h->mb_width) {\n\n                loop_filter(h, lf_x_start, h->mb_x);\n\n                h->mb_x = lf_x_start = 0;\n\n                decode_finish_row(h);\n\n                ++h->mb_y;\n\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n\n                    ++h->mb_y;\n\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n\n                        predict_field_decoding_flag(h);\n\n                }\n\n                if (h->mb_y >= h->mb_height) {\n\n                    tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                            get_bits_count(&h->gb), h->gb.size_in_bits);\n\n\n\n                    if (   get_bits_left(&h->gb) == 0\n\n                        || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                        h->mb_x - 1, h->mb_y,\n\n                                        ER_MB_END);\n\n\n\n                        return 0;\n\n                    } else {\n\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                        h->mb_x, h->mb_y,\n\n                                        ER_MB_END);\n\n\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) {\n\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                if (get_bits_left(&h->gb) == 0) {\n\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                    h->mb_x - 1, h->mb_y,\n\n                                    ER_MB_END);\n\n                    if (h->mb_x > lf_x_start)\n\n                        loop_filter(h, lf_x_start, h->mb_x);\n\n\n\n                    return 0;\n\n                } else {\n\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                    h->mb_y, ER_MB_ERROR);\n\n\n\n                    return -1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 443}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoData *s = s1->priv_data;\n\n    char filename[1024];\n\n    int ret;\n\n    ByteIOContext f1, *f;\n\n\n\n    if (get_frame_filename(filename, sizeof(filename),\n\n                           s->path, s->img_number) < 0)\n\n        return -EIO;\n\n    \n\n    if (!s->is_pipe) {\n\n        f = &f1;\n\n        if (url_fopen(f, filename, URL_RDONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        f = &s1->pb;\n\n        if (url_feof(f))\n\n            return -EIO;\n\n    }\n\n\n\n    av_new_packet(pkt, s->img_size);\n\n    pkt->stream_index = 0;\n\n\n\n    switch(s->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_read(s, filename, pkt->data, pkt->size);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_read(s, f, pkt->data, pkt->size);\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (!s->is_pipe) {\n\n        url_fclose(f);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        av_free_packet(pkt);\n\n        return -EIO; /* signal EOF */\n\n    } else {\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 446}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "void configure_alarms(char const *opt)\n\n{\n\n    int i;\n\n    int cur = 0;\n\n    int count = ARRAY_SIZE(alarm_timers) - 1;\n\n    char *arg;\n\n    char *name;\n\n    struct qemu_alarm_timer tmp;\n\n\n\n    if (!strcmp(opt, \"?\")) {\n\n        show_available_alarms();\n\n        exit(0);\n\n    }\n\n\n\n    arg = g_strdup(opt);\n\n\n\n    /* Reorder the array */\n\n    name = strtok(arg, \",\");\n\n    while (name) {\n\n        for (i = 0; i < count && alarm_timers[i].name; i++) {\n\n            if (!strcmp(alarm_timers[i].name, name))\n\n                break;\n\n        }\n\n\n\n        if (i == count) {\n\n            fprintf(stderr, \"Unknown clock %s\\n\", name);\n\n            goto next;\n\n        }\n\n\n\n        if (i < cur)\n\n            /* Ignore */\n\n            goto next;\n\n\n\n\t/* Swap */\n\n        tmp = alarm_timers[i];\n\n        alarm_timers[i] = alarm_timers[cur];\n\n        alarm_timers[cur] = tmp;\n\n\n\n        cur++;\n\nnext:\n\n        name = strtok(NULL, \",\");\n\n    }\n\n\n\n    g_free(arg);\n\n\n\n    if (cur) {\n\n        /* Disable remaining timers */\n\n        for (i = cur; i < count; i++)\n\n            alarm_timers[i].name = NULL;\n\n    } else {\n\n        show_available_alarms();\n\n        exit(1);\n\n    }\n\n}\n", "idx": 449}
{"project": "FFmpeg", "commit_id": "82dd7d0dec29ee59af91ce18c29eb151b363ff37", "target": 0, "func": "static int motion_inter_4v_block (bit_buffer_t *bitbuf,\n\n\t\t\t\t  uint8_t *current, uint8_t *previous, int pitch,\n\n\t\t\t\t  svq1_pmv_t *motion,int x, int y) {\n\n  uint8_t    *src;\n\n  uint8_t    *dst;\n\n  svq1_pmv_t  mv;\n\n  svq1_pmv_t *pmv[4];\n\n  int\t      i, result;\n\n\n\n  /* predict and decode motion vector (0) */\n\n  pmv[0] = &motion[0];\n\n  pmv[1] = &motion[(x / 8) + 2];\n\n  pmv[2] = &motion[(x / 8) + 4];\n\n\n\n  if (y == 0) {\n\n    pmv[1] = pmv[0];\n\n    pmv[2] = pmv[0];\n\n  }\n\n\n\n  result = decode_motion_vector (bitbuf, &mv, pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  /* predict and decode motion vector (1) */\n\n  pmv[0] = &mv;\n\n  pmv[1] = &motion[(x / 8) + 3];\n\n\n\n  if (y == 0) {\n\n    pmv[1] = pmv[0];\n\n    pmv[2] = pmv[0];\n\n  }\n\n\n\n  result = decode_motion_vector (bitbuf, &motion[0], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  /* predict and decode motion vector (2) */\n\n  pmv[1] = &motion[0];\n\n  pmv[2] = &motion[(x / 8) + 1];\n\n\n\n  result = decode_motion_vector (bitbuf, &motion[(x / 8) + 2], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  /* predict and decode motion vector (3) */\n\n  pmv[2] = &motion[(x / 8) + 2];\n\n  pmv[3] = &motion[(x / 8) + 3];\n\n\n\n  result = decode_motion_vector (bitbuf, pmv[3], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  /* form predictions */\n\n  for (i=0; i < 4; i++) {\n\n    src = &previous[(x + (pmv[i]->x >> 1)) + (y + (pmv[i]->y >> 1))*pitch];\n\n    dst = current;\n\n\n\n    put_pixels_tab[((pmv[i]->y & 1) << 1) | (pmv[i]->x & 1)](dst,src,pitch,8);\n\n\n\n    /* select next block */\n\n    if (i & 1) {\n\n      current  += 8*(pitch - 1);\n\n      previous += 8*(pitch - 1);\n\n    } else {\n\n      current  += 8;\n\n      previous += 8;\n\n    }\n\n  }\n\n\n\n  return 0;\n\n}\n", "idx": 452}
{"project": "qemu", "commit_id": "bef0fd5958120542f126f2dedbfce65d8839a94d", "target": 0, "func": "void ide_sector_read(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    s->error = 0; /* not needed by IDE spec, but needed by Windows */\n\n    sector_num = ide_get_sector(s);\n\n    n = s->nsector;\n\n    if (n == 0) {\n\n        /* no more sector to read from disk */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n#if defined(DEBUG_IDE)\n\n        printf(\"read sector=%\" PRId64 \"\\n\", sector_num);\n\n#endif\n\n        if (n > s->req_nb_sectors)\n\n            n = s->req_nb_sectors;\n\n\n\n        bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n\n        ret = bdrv_read(s->bs, sector_num, s->io_buffer, n);\n\n        bdrv_acct_done(s->bs, &s->acct);\n\n        if (ret != 0) {\n\n            if (ide_handle_rw_error(s, -ret,\n\n                BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ))\n\n            {\n\n                return;\n\n            }\n\n        }\n\n        ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read);\n\n        ide_set_irq(s->bus);\n\n        ide_set_sector(s, sector_num + n);\n\n        s->nsector -= n;\n\n    }\n\n}\n", "idx": 497}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                write_phys_req_item(req->data, req, i, &tmp);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                read_phys_req_item(req->data, req, i, &tmp);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 498}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_display_character(sPAPREnvironment *spapr,\n\n                                   uint32_t token, uint32_t nargs,\n\n                                   target_ulong args,\n\n                                   uint32_t nret, target_ulong rets)\n\n{\n\n    uint8_t c = rtas_ld(args, 0);\n\n    VIOsPAPRDevice *sdev = vty_lookup(spapr, 0);\n\n\n\n    if (!sdev) {\n\n        rtas_st(rets, 0, -1);\n\n    } else {\n\n        vty_putchars(sdev, &c, sizeof(c));\n\n        rtas_st(rets, 0, 0);\n\n    }\n\n}\n", "idx": 512}
{"project": "FFmpeg", "commit_id": "34aeb5dbc4fe7267df5f0ebe2ec84c5a8d36a896", "target": 0, "func": "static int xmv_read_header(AVFormatContext *s)\n\n{\n\n    XMVDemuxContext *xmv = s->priv_data;\n\n    AVIOContext     *pb  = s->pb;\n\n\n\n    uint32_t file_version;\n\n    uint32_t this_packet_size;\n\n    uint16_t audio_track;\n\n    int ret;\n\n\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n\n\n    avio_skip(pb, 4); /* Next packet size */\n\n\n\n    this_packet_size = avio_rl32(pb);\n\n\n\n    avio_skip(pb, 4); /* Max packet size */\n\n    avio_skip(pb, 4); /* \"xobX\" */\n\n\n\n    file_version = avio_rl32(pb);\n\n    if ((file_version != 4) && (file_version != 2))\n\n        avpriv_request_sample(s, \"Uncommon version %\"PRIu32\"\", file_version);\n\n\n\n    /* Video tracks */\n\n\n\n    xmv->video_width    = avio_rl32(pb);\n\n    xmv->video_height   = avio_rl32(pb);\n\n    xmv->video_duration = avio_rl32(pb);\n\n\n\n    /* Audio tracks */\n\n\n\n    xmv->audio_track_count = avio_rl16(pb);\n\n\n\n    avio_skip(pb, 2); /* Unknown (padding?) */\n\n\n\n    xmv->audio = av_mallocz_array(xmv->audio_track_count, sizeof(XMVAudioPacket));\n\n    if (!xmv->audio) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) {\n\n        XMVAudioPacket *packet = &xmv->audio[audio_track];\n\n\n\n        packet->compression     = avio_rl16(pb);\n\n        packet->channels        = avio_rl16(pb);\n\n        packet->sample_rate     = avio_rl32(pb);\n\n        packet->bits_per_sample = avio_rl16(pb);\n\n        packet->flags           = avio_rl16(pb);\n\n\n\n        packet->bit_rate      = packet->bits_per_sample *\n\n                                packet->sample_rate *\n\n                                packet->channels;\n\n        packet->block_align   = XMV_BLOCK_ALIGN_SIZE * packet->channels;\n\n        packet->block_samples = 64;\n\n        packet->codec_id      = ff_wav_codec_get_id(packet->compression,\n\n                                                    packet->bits_per_sample);\n\n\n\n        packet->stream_index = -1;\n\n\n\n        packet->frame_size  = 0;\n\n        packet->block_count = 0;\n\n\n\n        /* TODO: ADPCM'd 5.1 sound is encoded in three separate streams.\n\n         *       Those need to be interleaved to a proper 5.1 stream. */\n\n        if (packet->flags & XMV_AUDIO_ADPCM51)\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported 5.1 ADPCM audio stream \"\n\n                                      \"(0x%04X)\\n\", packet->flags);\n\n\n\n        if (!packet->channels || !packet->sample_rate ||\n\n             packet->channels >= UINT16_MAX / XMV_BLOCK_ALIGN_SIZE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid parameters for audio track %\"PRIu16\".\\n\",\n\n                   audio_track);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n\n\n    /* Initialize the packet context */\n\n\n\n    xmv->next_packet_offset = avio_tell(pb);\n\n    xmv->next_packet_size   = this_packet_size - xmv->next_packet_offset;\n\n    xmv->stream_count       = xmv->audio_track_count + 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    xmv_read_close(s);\n\n    return ret;\n\n}\n", "idx": 514}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    return\n\n        nb_sectors < 0 ||\n\n        sector_num < 0 ||\n\n        nb_sectors > bs->total_sectors ||\n\n        sector_num > bs->total_sectors - nb_sectors;\n\n}\n", "idx": 521}
{"project": "qemu", "commit_id": "2d40564aaab3a99fe6ce00fc0fc893c02e9443ec", "target": 1, "func": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n\n{\n\n    int fd, ret;\n\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = fchmod(fd, credp->fc_mode & 07777);\n\n    if (ret < 0) {\n\n        goto err_out;\n\n    }\n\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n\nerr_out:\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 526}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int ffv1_encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    ffv1_common_init(avctx);\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level == 3) {\n\n        s->version = 3;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if (s->version >= 2 &&\n\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Version %d requested, please set -strict experimental in \"\n\n               \"order to enable it\\n\",\n\n               s->version);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->ac = avctx->coder_type > 0 ? 2 : 0;\n\n\n\n    s->plane_count = 3;\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (!s->ac && avctx->coder_type == -1) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                   \"bits_per_raw_sample > 8, forcing coder 1\\n\");\n\n            s->ac = 2;\n\n        }\n\n        if (!s->ac) {\n\n            av_log(\n\n                avctx, AV_LOG_ERROR,\n\n                \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace    = 0;\n\n        break;\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = 1;\n\n        s->colorspace    = 0;\n\n        s->transparency  = 1;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace   = 1;\n\n        s->transparency = 1;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace    = 1;\n\n        s->chroma_planes = 1;\n\n        s->version       = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (s->transparency) {\n\n        av_log(\n\n            avctx, AV_LOG_WARNING,\n\n            \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Invalid context model %d, valid values are 0 and 1\\n\",\n\n               avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->ac > 1)\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ffv1_ver2_state[i];\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i] = ffv1_quant11[i];\n\n            s->quant_tables[0][1][i] = ffv1_quant11[i] * 11;\n\n            s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11;\n\n            s->quant_tables[1][0][i] = ffv1_quant11[i];\n\n            s->quant_tables[1][1][i] = ffv1_quant11[i] * 11;\n\n            s->quant_tables[1][2][i] = ffv1_quant5[i]  * 11 * 11;\n\n            s->quant_tables[1][3][i] = ffv1_quant5[i]  *  5 * 11 * 11;\n\n            s->quant_tables[1][4][i] = ffv1_quant5[i]  *  5 *  5 * 11 * 11;\n\n        } else {\n\n            s->quant_tables[0][0][i] = ffv1_quant9_10bit[i];\n\n            s->quant_tables[0][1][i] = ffv1_quant9_10bit[i] * 11;\n\n            s->quant_tables[0][2][i] = ffv1_quant9_10bit[i] * 11 * 11;\n\n            s->quant_tables[1][0][i] = ffv1_quant9_10bit[i];\n\n            s->quant_tables[1][1][i] = ffv1_quant9_10bit[i] * 11;\n\n            s->quant_tables[1][2][i] = ffv1_quant5_10bit[i] * 11 * 11;\n\n            s->quant_tables[1][3][i] = ffv1_quant5_10bit[i] *  5 * 11 * 11;\n\n            s->quant_tables[1][4][i] = ffv1_quant5_10bit[i] *  5 *  5 * 11 * 11;\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[avctx->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = avctx->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n\n\n    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,\n\n                                     &s->chroma_v_shift);\n\n\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t best_state[256][256];\n\n        int gob_count = 0;\n\n        char *next;\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;; ) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (j = 0; j < s->context_count[i]; j++)\n\n                for (k = 0; k < 32; k++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {\n\n                        p = 256.0 * s->rc_stat2[i][j][k][1] /\n\n                            (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +\n\n                                                                       s->rc_stat2[i][j][k][1]) /\n\n                                                                      gob_count, 0, 255)];\n\n                }\n\n        }\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++)\n\n            for (s->num_h_slices = s->num_v_slices;\n\n                 s->num_h_slices < 2 * s->num_v_slices; s->num_h_slices++)\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices &&\n\n                    avctx->slices <= 64 || !avctx->slices)\n\n                    goto slices_ok;\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        write_extradata(s);\n\n    }\n\n\n\n    if ((ret = ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    if ((ret = init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 534}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop(void *fdt, const char *node_path,\n\n                         const char *property, void *val_array, int size)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop(fdt, offset, property, val_array, size);\n\n}\n", "idx": 536}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3lame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                                const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    LAMEContext *s = avctx->priv_data;\n\n    MPADecodeHeader hdr;\n\n    int len, ret, ch;\n\n    int lame_result;\n\n    uint32_t h;\n\n\n\n    if (frame) {\n\n        switch (avctx->sample_fmt) {\n\n        case AV_SAMPLE_FMT_S16P:\n\n            ENCODE_BUFFER(lame_encode_buffer, int16_t, frame->data);\n\n            break;\n\n        case AV_SAMPLE_FMT_S32P:\n\n            ENCODE_BUFFER(lame_encode_buffer_int, int32_t, frame->data);\n\n            break;\n\n        case AV_SAMPLE_FMT_FLTP:\n\n            if (frame->linesize[0] < 4 * FFALIGN(frame->nb_samples, 8)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"inadequate AVFrame plane padding\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n            for (ch = 0; ch < avctx->channels; ch++) {\n\n                s->fdsp.vector_fmul_scalar(s->samples_flt[ch],\n\n                                           (const float *)frame->data[ch],\n\n                                           32768.0f,\n\n                                           FFALIGN(frame->nb_samples, 8));\n\n            }\n\n            ENCODE_BUFFER(lame_encode_buffer_float, float, s->samples_flt);\n\n            break;\n\n        default:\n\n            return AVERROR_BUG;\n\n        }\n\n    } else {\n\n        lame_result = lame_encode_flush(s->gfp, s->buffer + s->buffer_index,\n\n                                        s->buffer_size - s->buffer_index);\n\n    }\n\n    if (lame_result < 0) {\n\n        if (lame_result == -1) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"lame: output buffer too small (buffer index: %d, free bytes: %d)\\n\",\n\n                   s->buffer_index, s->buffer_size - s->buffer_index);\n\n        }\n\n        return -1;\n\n    }\n\n    s->buffer_index += lame_result;\n\n    ret = realloc_buffer(s);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"error reallocating output buffer\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* add current frame to the queue */\n\n    if (frame) {\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    /* Move 1 frame from the LAME buffer to the output packet, if available.\n\n       We have to parse the first frame header in the output buffer to\n\n       determine the frame size. */\n\n    if (s->buffer_index < 4)\n\n        return 0;\n\n    h = AV_RB32(s->buffer);\n\n    if (ff_mpa_check_header(h) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid mp3 header at start of buffer\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n    if (avpriv_mpegaudio_decode_header(&hdr, h)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"free format output not supported\\n\");\n\n        return -1;\n\n    }\n\n    len = hdr.frame_size;\n\n    ff_dlog(avctx, \"in:%d packet-len:%d index:%d\\n\", avctx->frame_size, len,\n\n            s->buffer_index);\n\n    if (len <= s->buffer_index) {\n\n        if ((ret = ff_alloc_packet(avpkt, len))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n            return ret;\n\n        }\n\n        memcpy(avpkt->data, s->buffer, len);\n\n        s->buffer_index -= len;\n\n        memmove(s->buffer, s->buffer + len, s->buffer_index);\n\n\n\n        /* Get the next frame pts/duration */\n\n        ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                           &avpkt->duration);\n\n\n\n        avpkt->size = len;\n\n        *got_packet_ptr = 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 555}
{"project": "FFmpeg", "commit_id": "a9837b58e1b060ed31753821536de128a0deaf26", "target": 1, "func": "static int tta_decode_frame(AVCodecContext *avctx,\n\n        void *data, int *data_size,\n\n        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TTAContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n\n    {\n\n        int32_t predictors[s->channels];\n\n        TTAFilter filters[s->channels];\n\n        TTARice rices[s->channels];\n\n        int cur_chan = 0, framelen = s->frame_length;\n\n        int32_t *p;\n\n\n\n        // FIXME: seeking\n\n        s->total_frames--;\n\n        if (!s->total_frames && s->last_frame_length)\n\n            framelen = s->last_frame_length;\n\n\n\n        // init per channel states\n\n        for (i = 0; i < s->channels; i++) {\n\n            predictors[i] = 0;\n\n            ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n\n            rice_init(&(rices[i]), 10, 10);\n\n        }\n\n\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n\n            int32_t *predictor = &(predictors[cur_chan]);\n\n            TTAFilter *filter = &(filters[cur_chan]);\n\n            TTARice *rice = &(rices[cur_chan]);\n\n            uint32_t unary, depth, k;\n\n            int32_t value;\n\n\n\n            unary = tta_get_unary(&s->gb);\n\n\n\n            if (unary == 0) {\n\n                depth = 0;\n\n                k = rice->k0;\n\n            } else {\n\n                depth = 1;\n\n                k = rice->k1;\n\n                unary--;\n\n            }\n\n\n\n            if (k)\n\n                value = (unary << k) + get_bits(&s->gb, k);\n\n            else\n\n                value = unary;\n\n\n\n            // FIXME: copy paste from original\n\n            switch (depth) {\n\n            case 1:\n\n                rice->sum1 += value - (rice->sum1 >> 4);\n\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n\n                    rice->k1--;\n\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n\n                    rice->k1++;\n\n                value += shift_1[rice->k0];\n\n            default:\n\n                rice->sum0 += value - (rice->sum0 >> 4);\n\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n\n                    rice->k0--;\n\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n\n                    rice->k0++;\n\n            }\n\n\n\n            // extract coded value\n\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n\n            *p = UNFOLD(value);\n\n\n\n            // run hybrid filter\n\n            ttafilter_process(filter, p, 0);\n\n\n\n            // fixed order prediction\n\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n\n            switch (s->bps) {\n\n                case 1: *p += PRED(*predictor, 4); break;\n\n                case 2:\n\n                case 3: *p += PRED(*predictor, 5); break;\n\n                case 4: *p += *predictor; break;\n\n            }\n\n            *predictor = *p;\n\n\n\n#if 0\n\n            // extract 32bit float from last two int samples\n\n            if (s->is_float && ((p - data) & 1)) {\n\n                uint32_t neg = *p & 0x80000000;\n\n                uint32_t hi = *(p - 1);\n\n                uint32_t lo = abs(*p) - 1;\n\n\n\n                hi += (hi || lo) ? 0x3f80 : 0;\n\n                // SWAP16: swap all the 16 bits\n\n                *(p - 1) = (hi << 16) | SWAP16(lo) | neg;\n\n            }\n\n#endif\n\n\n\n            /*if ((get_bits_count(&s->gb)+7)/8 > buf_size)\n\n            {\n\n                av_log(NULL, AV_LOG_INFO, \"overread!!\\n\");\n\n                break;\n\n            }*/\n\n\n\n            // flip channels\n\n            if (cur_chan < (s->channels-1))\n\n                cur_chan++;\n\n            else {\n\n                // decorrelate in case of stereo integer\n\n                if (!s->is_float && (s->channels > 1)) {\n\n                    int32_t *r = p - 1;\n\n                    for (*p += *r / 2; r > p - s->channels; r--)\n\n                        *r = *(r + 1) - *r;\n\n                }\n\n                cur_chan = 0;\n\n            }\n\n        }\n\n\n\n        skip_bits(&s->gb, 32); // frame crc\n\n\n\n        // convert to output buffer\n\n        switch(s->bps) {\n\n            case 2: {\n\n                uint16_t *samples = data;\n\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n\n//                    *samples++ = (unsigned char)*p;\n\n//                    *samples++ = (unsigned char)(*p >> 8);\n\n                    *samples++ = *p;\n\n                }\n\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n                break;\n\n            }\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n\n        }\n\n    }\n\n\n\n//    return get_bits_count(&s->gb)+7)/8;\n\n    return buf_size;\n\n}\n", "idx": 578}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_2_c_template(SwsContext *c, const int32_t *buf[2],\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf[2], uint16_t *dest, int dstW,\n\n                       int yalpha, int uvalpha, int y,\n\n                       enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int uvalpha1 = 4096 - uvalpha;\n\n    int i;\n\n    int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n\n\n    for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha) >> 14;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha) >> 14;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha + (-128 << 23)) >> 14;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha + (-128 << 23)) >> 14;\n\n        int R, G, B;\n\n\n\n        Y1 -= c->yuv2rgb_y_offset;\n\n        Y2 -= c->yuv2rgb_y_offset;\n\n        Y1 *= c->yuv2rgb_y_coeff;\n\n        Y2 *= c->yuv2rgb_y_coeff;\n\n        Y1 += 1 << 13;\n\n        Y2 += 1 << 13;\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 1;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 1;\n\n\n\n            A1 += 1 << 13;\n\n            A2 += 1 << 13;\n\n        }\n\n\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n            output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n            output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n            output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n            output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n            dest += 8;\n\n        } else {\n\n            output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n            output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n            output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n            dest += 6;\n\n        }\n\n    }\n\n}\n", "idx": 583}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src){\n\n#define COPY(a) bak->a= src->a\n\n    COPY(allocated_edge_emu_buffer);\n\n    COPY(edge_emu_buffer);\n\n    COPY(me.scratchpad);\n\n    COPY(me.temp);\n\n    COPY(rd_scratchpad);\n\n    COPY(b_scratchpad);\n\n    COPY(obmc_scratchpad);\n\n    COPY(me.map);\n\n    COPY(me.score_map);\n\n    COPY(blocks);\n\n    COPY(block);\n\n    COPY(start_mb_y);\n\n    COPY(end_mb_y);\n\n    COPY(me.map_generation);\n\n    COPY(pb);\n\n    COPY(dct_error_sum);\n\n    COPY(dct_count[0]);\n\n    COPY(dct_count[1]);\n\n    COPY(ac_val_base);\n\n    COPY(ac_val[0]);\n\n    COPY(ac_val[1]);\n\n    COPY(ac_val[2]);\n\n#undef COPY\n\n}\n", "idx": 646}
{"project": "FFmpeg", "commit_id": "84343dd9d3b8e19c95c0f641a9f97915efec0633", "target": 0, "func": "static av_cold void free_frame_buffers(Indeo3DecodeContext *ctx)\n\n{\n\n    int p;\n\n\n\n    ctx->width=\n\n    ctx->height= 0;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        av_freep(&ctx->planes[p].buffers[0]);\n\n        av_freep(&ctx->planes[p].buffers[1]);\n\n        ctx->planes[p].pixels[0] = ctx->planes[p].pixels[1] = 0;\n\n    }\n\n}\n", "idx": 653}
{"project": "FFmpeg", "commit_id": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f", "target": 0, "func": "static AVInputFormat *probe_input_format(AVProbeData *pd, int is_opened)\n\n{\n\n    AVInputFormat *fmt1, *fmt;\n\n    int score, score_max;\n\n\n\n    fmt = NULL;\n\n    score_max = 0;\n\n    for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next) {\n\n        if (!is_opened && !(fmt1->flags & AVFMT_NOFILE))\n\n            continue;\n\n        score = 0;\n\n        if (fmt1->extensions) {\n\n            if (match_ext(pd->filename, fmt1->extensions)) {\n\n                score = 50;\n\n            }\n\n        } else if (fmt1->read_probe) {\n\n            score = fmt1->read_probe(pd);\n\n        }\n\n        if (score > score_max) {\n\n            score_max = score;\n\n            fmt = fmt1;\n\n        }\n\n    }\n\n    return fmt;\n\n}\n", "idx": 668}
{"project": "qemu", "commit_id": "c9f4b77ad5783bd84bca4ab99d4b3d6ee61de01c", "target": 1, "func": "static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 670}
{"project": "FFmpeg", "commit_id": "69fa23961ededd725c68b188493cf2653d70f4fd", "target": 1, "func": "int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n\n{\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    ff_read_frame_flush(s);\n\n\n\n    if(flags & AVSEEK_FLAG_BYTE)\n\n        return av_seek_frame_byte(s, stream_index, timestamp, flags);\n\n\n\n    if(stream_index < 0){\n\n        stream_index= av_find_default_stream_index(s);\n\n        if(stream_index < 0)\n\n            return -1;\n\n\n\n        st= s->streams[stream_index];\n\n       /* timestamp for default must be expressed in AV_TIME_BASE units */\n\n        timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num);\n\n    }\n\n\n\n    /* first, we try the format specific seek */\n\n    if (s->iformat->read_seek)\n\n        ret = s->iformat->read_seek(s, stream_index, timestamp, flags);\n\n    else\n\n        ret = -1;\n\n    if (ret >= 0) {\n\n        return 0;\n\n    }\n\n\n\n    if(s->iformat->read_timestamp)\n\n        return av_seek_frame_binary(s, stream_index, timestamp, flags);\n\n    else\n\n        return av_seek_frame_generic(s, stream_index, timestamp, flags);\n\n}\n", "idx": 682}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_end(AVFormatContext *ctx)\n\n{\n\n    StreamInfo *stream;\n\n    int i;\n\n\n\n    /* flush each packet */\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        if (stream->buffer_ptr > 0) {\n\n            if (i == (ctx->nb_streams - 1)) \n\n                flush_packet(ctx, i, 1);\n\n            else\n\n                flush_packet(ctx, i, 0);\n\n        }\n\n    }\n\n\n\n    /* write the end header */\n\n    //put_be32(&ctx->pb, ISO_11172_END_CODE);\n\n    //put_flush_packet(&ctx->pb);\n\n\n\n    for(i=0;i<ctx->nb_streams;i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 691}
{"project": "qemu", "commit_id": "83d768b5640946b7da55ce8335509df297e2c7cd", "target": 1, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n\n\n    qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);\n\n    if (s->dataplane_started && !s->dataplane_fenced) {\n\n        virtio_scsi_dataplane_notify(vdev, req);\n\n    } else {\n\n        virtio_notify(vdev, vq);\n\n    }\n\n\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n}\n", "idx": 696}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "static int inet_connect_addr(struct addrinfo *addr, bool block,\n\n                             bool *in_progress)\n\n{\n\n    int sock, rc;\n\n\n\n    if (in_progress) {\n\n        *in_progress = false;\n\n    }\n\n\n\n    sock = qemu_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"%s: socket(%s): %s\\n\", __func__,\n\n                inet_strfamily(addr->ai_family), strerror(errno));\n\n        return -1;\n\n    }\n\n    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n\n    if (!block) {\n\n        socket_set_nonblock(sock);\n\n    }\n\n    /* connect to peer */\n\n    do {\n\n        rc = 0;\n\n        if (connect(sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\n            rc = -socket_error();\n\n        }\n\n    } while (rc == -EINTR);\n\n\n\n    if (!block && QEMU_SOCKET_RC_INPROGRESS(rc)) {\n\n        if (in_progress) {\n\n            *in_progress = true;\n\n        }\n\n    } else if (rc < 0) {\n\n        closesocket(sock);\n\n        return -1;\n\n    }\n\n    return sock;\n\n}\n", "idx": 705}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 712}
{"project": "FFmpeg", "commit_id": "ca8064d2d1b293d7a8011bf0a08005c11ae8ba67", "target": 1, "func": "static int opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else av_assert0(0);\n\n    return 0;\n\n}\n", "idx": 713}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n\n{\n\n    unsigned char *end;\n\n    int filter_value;\n\n    const int nstride= -stride;\n\n\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n\n        filter_value =\n\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n\n    }\n\n}\n", "idx": 734}
{"project": "FFmpeg", "commit_id": "da55ee6ccc05efdd9006bb8c31db9012a3326857", "target": 1, "func": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[4]){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ440P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n    case PIX_FMT_YUV420P9LE:\n\n    case PIX_FMT_YUV420P9BE:\n\n    case PIX_FMT_YUV420P10LE:\n\n    case PIX_FMT_YUV420P10BE:\n\n    case PIX_FMT_YUV422P10LE:\n\n    case PIX_FMT_YUV422P10BE:\n\n\n\n\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n        if(s->codec_id == CODEC_ID_MPEG2VIDEO || s->codec_id == CODEC_ID_MJPEG || s->codec_id == CODEC_ID_AMV || s->codec_id == CODEC_ID_THP || s->codec_id == CODEC_ID_H264)\n\n            h_align= 32; // interlaced is rounded up to 2 MBs\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = FFALIGN(*width , w_align);\n\n    *height= FFALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264 || s->lowres)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n                    // which is also done in mpeg decoders with lowres > 0\n\n\n\n    linesize_align[0] =\n\n    linesize_align[1] =\n\n    linesize_align[2] =\n\n    linesize_align[3] = STRIDE_ALIGN;\n\n//STRIDE_ALIGN is 8 for SSE* but this does not work for SVQ1 chroma planes\n\n//we could change STRIDE_ALIGN to 16 for x86/sse but it would increase the\n\n//picture size unneccessarily in some cases. The solution here is not\n\n//pretty and better ideas are welcome!\n\n#if HAVE_MMX\n\n    if(s->codec_id == CODEC_ID_SVQ1 || s->codec_id == CODEC_ID_VP5 ||\n\n       s->codec_id == CODEC_ID_VP6 || s->codec_id == CODEC_ID_VP6F ||\n\n       s->codec_id == CODEC_ID_VP6A) {\n\n        linesize_align[0] =\n\n        linesize_align[1] =\n\n        linesize_align[2] = 16;\n\n    }\n\n#endif\n\n}", "idx": 747}
{"project": "FFmpeg", "commit_id": "8d36932c8d33f93ce1afdd5c1f402e7b6655d5ae", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl,\n\n                                   const H2645NAL *nal)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    sl->first_mb_addr = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->first_mb_addr == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, sl->first_mb_addr);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (nal->type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sl->pps_id = get_ue_golomb(&sl->gb);\n\n    if (sl->pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", sl->pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[sl->pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               sl->pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (h->current_slice > 0 &&\n\n        h->ps.pps != (const PPS*)h->ps.pps_list[sl->pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    pps = (const PPS*)h->ps.pps_list[sl->pps_id]->data;\n\n\n\n    if (!h->ps.sps_list[pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\", pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sps = (const SPS*)h->ps.sps_list[pps->sps_id]->data;\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    droppable = nal->ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->picture_structure      = picture_structure;\n\n    sl->mb_field_decoding_flag = picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (h->picture_structure != picture_structure ||\n\n            h->droppable         != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   h->picture_structure, picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (nal->type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    sl->explicit_ref_marking = 0;\n\n    if (nal->ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, sl, &sl->gb);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(pps, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(pps, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 754}
{"project": "FFmpeg", "commit_id": "12ba1b2b4d5592c0e27b0fcc83db929e8d6a8eee", "target": 0, "func": "static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int i, csize = 1;\n\n    void *src[3];\n\n\n\n    for (i = 1; i < 3; i++)\n\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n\n            return;\n\n        }\n\n\n\n    for (i = 0; i < 3; i++)\n\n        if (tile->codsty[0].transform == FF_DWT97)\n\n            src[i] = tile->comp[i].f_data;\n\n        else\n\n            src[i] = tile->comp[i].i_data;\n\n\n\n    for (i = 0; i < 2; i++)\n\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n\n\n\n    s->dsp.mct_decode[tile->codsty[0].transform](src[0], src[1], src[2], csize);\n\n}\n", "idx": 757}
{"project": "FFmpeg", "commit_id": "a37fd7f9578d2dfbe20a109aae91e5f0a4b58874", "target": 1, "func": "static inline void RENAME(rgb2rgb_init)(void)\n\n{\n\n#if !COMPILE_TEMPLATE_SSE2\n\n#if !COMPILE_TEMPLATE_AMD3DNOW\n\n    rgb15to16          = RENAME(rgb15to16);\n\n    rgb15tobgr24       = RENAME(rgb15tobgr24);\n\n    rgb15to32          = RENAME(rgb15to32);\n\n    rgb16tobgr24       = RENAME(rgb16tobgr24);\n\n    rgb16to32          = RENAME(rgb16to32);\n\n    rgb16to15          = RENAME(rgb16to15);\n\n    rgb24tobgr16       = RENAME(rgb24tobgr16);\n\n    rgb24tobgr15       = RENAME(rgb24tobgr15);\n\n    rgb24tobgr32       = RENAME(rgb24tobgr32);\n\n    rgb32to16          = RENAME(rgb32to16);\n\n    rgb32to15          = RENAME(rgb32to15);\n\n    rgb32tobgr24       = RENAME(rgb32tobgr24);\n\n    rgb24to15          = RENAME(rgb24to15);\n\n    rgb24to16          = RENAME(rgb24to16);\n\n    rgb24tobgr24       = RENAME(rgb24tobgr24);\n\n    shuffle_bytes_2103 = RENAME(shuffle_bytes_2103);\n\n    rgb32tobgr16       = RENAME(rgb32tobgr16);\n\n    rgb32tobgr15       = RENAME(rgb32tobgr15);\n\n    yv12toyuy2         = RENAME(yv12toyuy2);\n\n    yv12touyvy         = RENAME(yv12touyvy);\n\n    yuv422ptoyuy2      = RENAME(yuv422ptoyuy2);\n\n    yuv422ptouyvy      = RENAME(yuv422ptouyvy);\n\n    yuy2toyv12         = RENAME(yuy2toyv12);\n\n    vu9_to_vu12        = RENAME(vu9_to_vu12);\n\n    yvu9_to_yuy2       = RENAME(yvu9_to_yuy2);\n\n    uyvytoyuv422       = RENAME(uyvytoyuv422);\n\n    yuyvtoyuv422       = RENAME(yuyvtoyuv422);\n\n#endif /* !COMPILE_TEMPLATE_AMD3DNOW */\n\n\n\n#if COMPILE_TEMPLATE_MMXEXT || COMPILE_TEMPLATE_AMD3DNOW\n\n    planar2x           = RENAME(planar2x);\n\n#endif /* COMPILE_TEMPLATE_MMXEXT || COMPILE_TEMPLATE_AMD3DNOW */\n\n    rgb24toyv12        = RENAME(rgb24toyv12);\n\n\n\n    yuyvtoyuv420       = RENAME(yuyvtoyuv420);\n\n    uyvytoyuv420       = RENAME(uyvytoyuv420);\n\n#endif /* !COMPILE_TEMPLATE_SSE2 */\n\n\n\n#if !COMPILE_TEMPLATE_AMD3DNOW\n\n    interleaveBytes    = RENAME(interleaveBytes);\n\n#endif /* !COMPILE_TEMPLATE_AMD3DNOW */\n\n}\n", "idx": 768}
{"project": "FFmpeg", "commit_id": "3193b13aa1e271f6d2dd68de67d448c08aef3c00", "target": 1, "func": "static int hls_write_header(AVFormatContext *s)\n\n{\n\n    HLSContext *hls = s->priv_data;\n\n    int ret, i;\n\n    char *p;\n\n    const char *pattern = \"%d.ts\";\n\n    int basename_size = strlen(s->filename) + strlen(pattern);\n\n\n\n    hls->number      = 0;\n\n\n\n    hls->recording_time = hls->time * 1000000;\n\n    hls->start_pts      = AV_NOPTS_VALUE;\n\n\n\n    for (i = 0; i < s->nb_streams; i++)\n\n        hls->has_video +=\n\n            s->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (hls->has_video > 1)\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"More than a single video stream present, \"\n\n               \"expect issues decoding it.\\n\");\n\n\n\n    hls->oformat = av_guess_format(\"mpegts\", NULL, NULL);\n\n\n\n    if (!hls->oformat) {\n\n        ret = AVERROR_MUXER_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    hls->basename = av_malloc(basename_size);\n\n\n\n    if (!hls->basename) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    strcpy(hls->basename, s->filename);\n\n\n\n    p = strrchr(hls->basename, '.');\n\n\n\n    if (p)\n\n        *p = '\\0';\n\n\n\n    av_strlcat(hls->basename, \"%d.ts\", basename_size);\n\n\n\n    if ((ret = hls_mux_init(s)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = hls_start(s)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = avformat_write_header(hls->avf, NULL)) < 0)\n\n        return ret;\n\n\n\n\n\nfail:\n\n    if (ret) {\n\n        av_free(hls->basename);\n\n        if (hls->avf)\n\n            avformat_free_context(hls->avf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 771}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, uint8_t *src, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"mov %2, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(bgr2YCoeff)\", %%mm6\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(w1111)\", %%mm5\t\t\\n\\t\"\n\n\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\"lea (%%\"REG_a\", %%\"REG_a\", 2), %%\"REG_d\"\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 64(%0, %%\"REG_d\")\t\\n\\t\"\n\n\t\t\"movd (%0, %%\"REG_d\"), %%mm0\t\\n\\t\"\n\n\t\t\"movd 3(%0, %%\"REG_d\"), %%mm1\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd 6(%0, %%\"REG_d\"), %%mm2\t\\n\\t\"\n\n\t\t\"movd 9(%0, %%\"REG_d\"), %%mm3\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm3\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm3\t\t\\n\\t\"\n\n#ifndef FAST_BGR2YV12\n\n\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm2\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n#endif\n\n\t\t\"packssdw %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm3, %%mm2\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm2, %%mm0\t\t\\n\\t\"\n\n\t\t\"psraw $7, %%mm0\t\t\\n\\t\"\n\n\n\n\t\t\"movd 12(%0, %%\"REG_d\"), %%mm4\t\\n\\t\"\n\n\t\t\"movd 15(%0, %%\"REG_d\"), %%mm1\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd 18(%0, %%\"REG_d\"), %%mm2\t\\n\\t\"\n\n\t\t\"movd 21(%0, %%\"REG_d\"), %%mm3\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"punpcklbw %%mm7, %%mm3\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm6, %%mm3\t\t\\n\\t\"\n\n#ifndef FAST_BGR2YV12\n\n\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm2\t\t\\n\\t\"\n\n\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n#endif\n\n\t\t\"packssdw %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm3, %%mm2\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\"pmaddwd %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"add $24, %%\"REG_d\"\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\"psraw $7, %%mm4\t\t\\n\\t\"\n\n\n\n\t\t\"packuswb %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\"paddusb \"MANGLE(bgr2YOffset)\", %%mm0\t\\n\\t\"\n\n\n\n\t\t\"movq %%mm0, (%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"r\" (src+width*3), \"r\" (dst+width), \"g\" (-width)\n\n\t\t: \"%\"REG_a, \"%\"REG_d\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint b= src[i*3+0];\n\n\t\tint g= src[i*3+1];\n\n\t\tint r= src[i*3+2];\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n#endif\n\n}\n", "idx": 772}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void vvfat_close(BlockDriverState *bs)\n\n{\n\n    BDRVVVFATState *s = bs->opaque;\n\n\n\n    vvfat_close_current_file(s);\n\n    array_free(&(s->fat));\n\n    array_free(&(s->directory));\n\n    array_free(&(s->mapping));\n\n    if(s->cluster_buffer)\n\n        free(s->cluster_buffer);\n\n}\n", "idx": 782}
{"project": "FFmpeg", "commit_id": "25a6666f6c07c6ac8449a63d7fbce0dfd29c54cd", "target": 0, "func": "static int ivi_mc(ivi_mc_func mc, int16_t *buf, const int16_t *ref_buf,\n\n                  int offs, int mv_x, int mv_y, uint32_t pitch,\n\n                  int mc_type)\n\n{\n\n    int ref_offs = offs + mv_y * pitch + mv_x;\n\n\n\n    if (offs < 0 || ref_offs < 0 || !ref_buf)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    mc(buf + offs, ref_buf + ref_offs, pitch, mc_type);\n\n\n\n    return 0;\n\n}\n", "idx": 795}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr,\n\n                                       SocketAddressLegacy *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        SocketAddressLegacy *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddressLegacy(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}\n", "idx": 814}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void monitor_readline(const char *prompt, int is_password,\n\n                             char *buf, int buf_size)\n\n{\n\n    readline_start(prompt, is_password, monitor_readline_cb, NULL);\n\n    readline_show_prompt();\n\n    monitor_readline_buf = buf;\n\n    monitor_readline_buf_size = buf_size;\n\n    monitor_readline_started = 1;\n\n    while (monitor_readline_started) {\n\n        main_loop_wait(10);\n\n    }\n\n}\n", "idx": 815}
{"project": "FFmpeg", "commit_id": "cfec0d64752509f8ac798acca6225df630fa5284", "target": 1, "func": "static int cllc_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_picture_ptr, AVPacket *avpkt)\n{\n    CLLCContext *ctx = avctx->priv_data;\n    AVFrame *pic = data;\n    ThreadFrame frame = { .f = data };\n    uint8_t *src = avpkt->data;\n    uint32_t info_tag, info_offset;\n    int data_size;\n    GetBitContext gb;\n    int coding_type, ret;\n    if (avpkt->size < 4 + 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size);\n    }\n    info_offset = 0;\n    info_tag    = AV_RL32(src);\n    if (info_tag == MKTAG('I', 'N', 'F', 'O')) {\n        info_offset = AV_RL32(src + 4);\n        if (info_offset > UINT32_MAX - 8 || info_offset + 8 > avpkt->size) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid INFO header offset: 0x%08\"PRIX32\" is too large.\\n\",\n                   info_offset);\n        }\n        ff_canopus_parse_info_tag(avctx, src + 8, info_offset);\n        info_offset += 8;\n        src         += info_offset;\n    }\n    data_size = (avpkt->size - info_offset) & ~1;\n    /* Make sure our bswap16'd buffer is big enough */\n    av_fast_padded_malloc(&ctx->swapped_buf,\n                          &ctx->swapped_buf_size, data_size);\n    if (!ctx->swapped_buf) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\");\n        return AVERROR(ENOMEM);\n    }\n    /* bswap16 the buffer since CLLC's bitreader works in 16-bit words */\n    ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,\n                          data_size / 2);\n    if ((ret = init_get_bits8(&gb, ctx->swapped_buf, data_size)) < 0)\n        return ret;\n    /*\n     * Read in coding type. The types are as follows:\n     *\n     * 0 - YUY2\n     * 1 - BGR24 (Triples)\n     * 2 - BGR24 (Quads)\n     * 3 - BGRA\n     */\n    coding_type = (AV_RL32(src) >> 8) & 0xFF;\n    av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type);\n    switch (coding_type) {\n    case 0:\n        avctx->pix_fmt             = AV_PIX_FMT_YUV422P;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_yuv_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    case 1:\n    case 2:\n        avctx->pix_fmt             = AV_PIX_FMT_RGB24;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_rgb24_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    case 3:\n        avctx->pix_fmt             = AV_PIX_FMT_ARGB;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_argb_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type);\n    }\n    pic->key_frame = 1;\n    pic->pict_type = AV_PICTURE_TYPE_I;\n    *got_picture_ptr = 1;\n    return avpkt->size;\n}", "idx": 838}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static av_always_inline void decode_dc_coeffs(GetBitContext *gb, int16_t *out,\n\n                                              int blocks_per_slice)\n\n{\n\n    int16_t prev_dc;\n\n    int code, i, sign;\n\n\n\n    OPEN_READER(re, gb);\n\n\n\n    DECODE_CODEWORD(code, FIRST_DC_CB);\n\n    prev_dc = TOSIGNED(code);\n\n    out[0] = prev_dc;\n\n\n\n    out += 64; // dc coeff for the next block\n\n\n\n    code = 5;\n\n    sign = 0;\n\n    for (i = 1; i < blocks_per_slice; i++, out += 64) {\n\n        DECODE_CODEWORD(code, dc_codebook[FFMIN(code, 6U)]);\n\n        if(code) sign ^= -(code & 1);\n\n        else     sign  = 0;\n\n        prev_dc += (((code + 1) >> 1) ^ sign) - sign;\n\n        out[0] = prev_dc;\n\n    }\n\n    CLOSE_READER(re, gb);\n\n}\n", "idx": 850}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_midh_qrt_and_aver_dst_8w_msa(const uint8_t *src,\n\n                                                  int32_t src_stride,\n\n                                                  uint8_t *dst,\n\n                                                  int32_t dst_stride,\n\n                                                  int32_t height,\n\n                                                  uint8_t horiz_offset)\n\n{\n\n    uint32_t multiple8_cnt;\n\n\n\n    for (multiple8_cnt = 2; multiple8_cnt--;) {\n\n        avc_luma_midh_qrt_and_aver_dst_4w_msa(src, src_stride, dst, dst_stride,\n\n                                              height, horiz_offset);\n\n\n\n        src += 4;\n\n        dst += 4;\n\n    }\n\n}\n", "idx": 854}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_pacl_removexattr(FsContext *ctx,\n\n                               const char *path, const char *name)\n\n{\n\n    int ret;\n\n    char *buffer;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret  = lremovexattr(buffer, MAP_ACL_ACCESS);\n\n    if (ret == -1 && errno == ENODATA) {\n\n        /*\n\n         * We don't get ENODATA error when trying to remove a\n\n         * posix acl that is not present. So don't throw the error\n\n         * even in case of mapped security model\n\n         */\n\n        errno = 0;\n\n        ret = 0;\n\n    }\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 859}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)\n\n{\n\n    static const char * const libnames[] = {\n\n        \"libOMX_Core.so\",\n\n        \"libOmxCore.so\",\n\n        NULL\n\n    };\n\n    const char* const* nameptr;\n\n    int ret = AVERROR_ENCODER_NOT_FOUND;\n\n    OMXContext *omx_context;\n\n\n\n    omx_context = av_mallocz(sizeof(*omx_context));\n\n    if (!omx_context)\n\n        return NULL;\n\n    if (libname) {\n\n        ret = omx_try_load(omx_context, logctx, libname, prefix);\n\n        if (ret < 0) {\n\n            av_free(omx_context);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        for (nameptr = libnames; *nameptr; nameptr++)\n\n            if (!(ret = omx_try_load(omx_context, logctx, *nameptr, prefix)))\n\n                break;\n\n        if (!*nameptr) {\n\n            av_free(omx_context);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    omx_context->ptr_Init();\n\n    return omx_context;\n\n}\n", "idx": 863}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int av_get_channel_layout_nb_channels(int64_t channel_layout)\n\n{\n\n    int count;\n\n    uint64_t x = channel_layout;\n\n    for (count = 0; x; count++)\n\n        x &= x-1; // unset lowest set bit\n\n    return count;\n\n}\n", "idx": 867}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_get_be32s(f, &q->queue[i]);\n\n\n\n    qemu_get_sbe32s(f, &q->next);\n\n    qemu_get_sbe32s(f, &q->priority);\n\n}\n", "idx": 882}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cs_write (void *opaque, target_phys_addr_t addr,\n\n                      uint64_t val64, unsigned size)\n\n{\n\n    CSState *s = opaque;\n\n    uint32_t saddr, iaddr, val;\n\n\n\n    saddr = addr;\n\n    val = val64;\n\n\n\n    switch (saddr) {\n\n    case Index_Address:\n\n        if (!(s->regs[Index_Address] & MCE) && (val & MCE)\n\n            && (s->dregs[Interface_Configuration] & (3 << 3)))\n\n            s->aci_counter = conf.aci_counter;\n\n\n\n        s->regs[Index_Address] = val & ~(1 << 7);\n\n        break;\n\n\n\n    case Index_Data:\n\n        if (!(s->dregs[MODE_And_ID] & MODE2))\n\n            iaddr = s->regs[Index_Address] & 0x0f;\n\n        else\n\n            iaddr = s->regs[Index_Address] & 0x1f;\n\n\n\n        switch (iaddr) {\n\n        case RESERVED:\n\n        case RESERVED_2:\n\n        case RESERVED_3:\n\n            lwarn (\"attempt to write %#x to reserved indirect register %d\\n\",\n\n                   val, iaddr);\n\n            break;\n\n\n\n        case FS_And_Playback_Data_Format:\n\n            if (s->regs[Index_Address] & MCE) {\n\n                cs_reset_voices (s, val);\n\n            }\n\n            else {\n\n                if (s->dregs[Alternate_Feature_Status] & PMCE) {\n\n                    val = (val & ~0x0f) | (s->dregs[iaddr] & 0x0f);\n\n                    cs_reset_voices (s, val);\n\n                }\n\n                else {\n\n                    lwarn (\"[P]MCE(%#x, %#x) is not set, val=%#x\\n\",\n\n                           s->regs[Index_Address],\n\n                           s->dregs[Alternate_Feature_Status],\n\n                           val);\n\n                    break;\n\n                }\n\n            }\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Interface_Configuration:\n\n            val &= ~(1 << 5);   /* D5 is reserved */\n\n            s->dregs[iaddr] = val;\n\n            if (val & PPIO) {\n\n                lwarn (\"PIO is not supported (%#x)\\n\", val);\n\n                break;\n\n            }\n\n            if (val & PEN) {\n\n                if (!s->dma_running) {\n\n                    cs_reset_voices (s, s->dregs[FS_And_Playback_Data_Format]);\n\n                }\n\n            }\n\n            else {\n\n                if (s->dma_running) {\n\n                    DMA_release_DREQ (s->dma);\n\n                    AUD_set_active_out (s->voice, 0);\n\n                    s->dma_running = 0;\n\n                }\n\n            }\n\n            break;\n\n\n\n        case Error_Status_And_Initialization:\n\n            lwarn (\"attempt to write to read only register %d\\n\", iaddr);\n\n            break;\n\n\n\n        case MODE_And_ID:\n\n            dolog (\"val=%#x\\n\", val);\n\n            if (val & MODE2)\n\n                s->dregs[iaddr] |= MODE2;\n\n            else\n\n                s->dregs[iaddr] &= ~MODE2;\n\n            break;\n\n\n\n        case Alternate_Feature_Enable_I:\n\n            if (val & TE)\n\n                lerr (\"timer is not yet supported\\n\");\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Alternate_Feature_Status:\n\n            if ((s->dregs[iaddr] & PI) && !(val & PI)) {\n\n                /* XXX: TI CI */\n\n                qemu_irq_lower (s->pic);\n\n                s->regs[Status] &= ~INT;\n\n            }\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        case Version_Chip_ID:\n\n            lwarn (\"write to Version_Chip_ID register %#x\\n\", val);\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n\n\n        default:\n\n            s->dregs[iaddr] = val;\n\n            break;\n\n        }\n\n        dolog (\"written value %#x to indirect register %d\\n\", val, iaddr);\n\n        break;\n\n\n\n    case Status:\n\n        if (s->regs[Status] & INT) {\n\n            qemu_irq_lower (s->pic);\n\n        }\n\n        s->regs[Status] &= ~INT;\n\n        s->dregs[Alternate_Feature_Status] &= ~(PI | CI | TI);\n\n        break;\n\n\n\n    case PIO_Data:\n\n        lwarn (\"attempt to write value %#x to PIO register\\n\", val);\n\n        break;\n\n    }\n\n}\n", "idx": 914}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pin_cfg_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* FUNC_MUX_CTRL_0 */\n\n    case 0x04:\t/* FUNC_MUX_CTRL_1 */\n\n    case 0x08:\t/* FUNC_MUX_CTRL_2 */\n\n        return s->func_mux_ctrl[addr >> 2];\n\n\n\n    case 0x0c:\t/* COMP_MODE_CTRL_0 */\n\n        return s->comp_mode_ctrl[0];\n\n\n\n    case 0x10:\t/* FUNC_MUX_CTRL_3 */\n\n    case 0x14:\t/* FUNC_MUX_CTRL_4 */\n\n    case 0x18:\t/* FUNC_MUX_CTRL_5 */\n\n    case 0x1c:\t/* FUNC_MUX_CTRL_6 */\n\n    case 0x20:\t/* FUNC_MUX_CTRL_7 */\n\n    case 0x24:\t/* FUNC_MUX_CTRL_8 */\n\n    case 0x28:\t/* FUNC_MUX_CTRL_9 */\n\n    case 0x2c:\t/* FUNC_MUX_CTRL_A */\n\n    case 0x30:\t/* FUNC_MUX_CTRL_B */\n\n    case 0x34:\t/* FUNC_MUX_CTRL_C */\n\n    case 0x38:\t/* FUNC_MUX_CTRL_D */\n\n        return s->func_mux_ctrl[(addr >> 2) - 1];\n\n\n\n    case 0x40:\t/* PULL_DWN_CTRL_0 */\n\n    case 0x44:\t/* PULL_DWN_CTRL_1 */\n\n    case 0x48:\t/* PULL_DWN_CTRL_2 */\n\n    case 0x4c:\t/* PULL_DWN_CTRL_3 */\n\n        return s->pull_dwn_ctrl[(addr & 0xf) >> 2];\n\n\n\n    case 0x50:\t/* GATE_INH_CTRL_0 */\n\n        return s->gate_inh_ctrl[0];\n\n\n\n    case 0x60:\t/* VOLTAGE_CTRL_0 */\n\n        return s->voltage_ctrl[0];\n\n\n\n    case 0x70:\t/* TEST_DBG_CTRL_0 */\n\n        return s->test_dbg_ctrl[0];\n\n\n\n    case 0x80:\t/* MOD_CONF_CTRL_0 */\n\n        return s->mod_conf_ctrl[0];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 979}
{"project": "FFmpeg", "commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "target": 1, "func": "static int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t;\n\n\n\n    if (total_freq == 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1003}
{"project": "FFmpeg", "commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "target": 1, "func": "static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,\n\n                             AVPacket *avpkt)\n\n{\n\n    int ret;\n\n    int new_extradata_size;\n\n    uint8_t *new_extradata;\n\n    HEVCContext *s = avctx->priv_data;\n\n\n\n    if (!avpkt->size) {\n\n        ret = ff_hevc_output_frame(s, data, 1);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        *got_output = ret;\n\n        return 0;\n\n    }\n\n\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata && new_extradata_size > 0) {\n\n        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    s->ref = NULL;\n\n    ret    = decode_nal_units(s, avpkt->data, avpkt->size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->hwaccel) {\n\n        if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n            ff_hevc_unref_frame(s, s->ref, ~0);\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* verify the SEI checksum */\n\n        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&\n\n            s->sei.picture_hash.is_md5) {\n\n            ret = verify_md5(s, s->ref->frame);\n\n            if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {\n\n                ff_hevc_unref_frame(s, s->ref, ~0);\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    s->sei.picture_hash.is_md5 = 0;\n\n\n\n    if (s->is_decoded) {\n\n        av_log(avctx, AV_LOG_DEBUG, \"Decoded frame with POC %d.\\n\", s->poc);\n\n        s->is_decoded = 0;\n\n    }\n\n\n\n    if (s->output_frame->buf[0]) {\n\n        av_frame_move_ref(data, s->output_frame);\n\n        *got_output = 1;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1018}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME(yuv2bgr24_1)(SwsContext *c, const int16_t *buf0,\n\n                                const int16_t *ubuf[2], const int16_t *bguf[2],\n\n                                const int16_t *abuf0, uint8_t *dest,\n\n                                int dstW, int uvalpha, int y)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];\n\n    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            WRITEBGR24(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            WRITEBGR24(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 1021}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn)\n\n{\n\n    uint64_t mask;\n\n    uint32_t sh, mb;\n\n\n\n    sh = SH(ctx->opcode) | (shn << 5);\n\n    mb = MB(ctx->opcode) | (mbn << 5);\n\n    if (likely(sh == 0)) {\n\n        if (likely(mb == 0)) {\n\n            gen_op_load_gpr_T0(rS(ctx->opcode));\n\n            goto do_store;\n\n        } else if (likely(mb == 63)) {\n\n            gen_op_load_gpr_T0(rA(ctx->opcode));\n\n            goto do_store;\n\n        }\n\n        gen_op_load_gpr_T0(rS(ctx->opcode));\n\n        gen_op_load_gpr_T1(rA(ctx->opcode));\n\n        goto do_mask;\n\n    }\n\n    gen_op_load_gpr_T0(rS(ctx->opcode));\n\n    gen_op_load_gpr_T1(rA(ctx->opcode));\n\n    gen_op_rotli64_T0(sh);\n\n do_mask:\n\n    mask = MASK(mb, 63 - sh);\n\n    gen_andi_T0_64(ctx, mask);\n\n    gen_andi_T1_64(ctx, ~mask);\n\n    gen_op_or();\n\n do_store:\n\n    gen_op_store_T0_gpr(rA(ctx->opcode));\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx);\n\n}\n", "idx": 1033}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    LOG_INT(\"kqemu_set_notdirty: addr=%08lx\\n\", \n\n                (unsigned long)ram_addr);\n\n    /* we only track transitions to dirty state */\n\n    if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff)\n\n        return;\n\n    if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE)\n\n        nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL;\n\n    else\n\n        ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr;\n\n}\n", "idx": 1064}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_y2_mmx( UINT8  *block, const UINT8 *pixels, int line_size, int h)\n\n{\n\n  UINT8  *p;\n\n  const UINT8 *pix;\n\n  p = block;\n\n  pix = pixels;\n\n  MOVQ_ZERO(mm7);\n\n  JUMPALIGN();\n\n  do {\n\n    __asm __volatile(\n\n\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\"movq\t%2, %%mm1\\n\\t\"\n\n\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\"movq\t%%mm1, %%mm3\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm0\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm1\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm2\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm3\\n\\t\"\n\n\t\"paddusw %%mm1, %%mm0\\n\\t\"\n\n\t\"paddusw %%mm3, %%mm2\\n\\t\"\n\n\t\"psrlw\t$1, %%mm0\\n\\t\"\n\n\t\"psrlw\t$1, %%mm2\\n\\t\"\n\n\t\"packuswb  %%mm2, %%mm0\\n\\t\"\n\n\t\"movq\t%%mm0, %0\\n\\t\"\n\n\t:\"=m\"(*p)\n\n\t:\"m\"(*pix),\n\n\t \"m\"(*(pix+line_size))\n\n\t:\"memory\");\n\n   pix += line_size;\n\n   p +=   line_size;\n\n  } while(--h);\n\n}\n", "idx": 1065}
{"project": "qemu", "commit_id": "8da1e18b0cf46b6c95c88bbad1cc50d6dd1bef4b", "target": 0, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nout:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    if (ret) {\n\n        if (iscsi != NULL) {\n\n            iscsi_destroy_context(iscsi);\n\n        }\n\n        memset(iscsilun, 0, sizeof(IscsiLun));\n\n    }\n\n    return ret;\n\n}\n", "idx": 1075}
{"project": "FFmpeg", "commit_id": "b92dfb56d4582633571db18c3d904f8602eaa2a6", "target": 0, "func": "static int encode_frame(AVCodecContext * avctx, AVPacket *pkt,\n\n                        const AVFrame *pict, int *got_packet)\n\n{\n\n    TiffEncoderContext *s = avctx->priv_data;\n\n    AVFrame *const p = &s->picture;\n\n    int i;\n\n    uint8_t *ptr;\n\n    uint8_t *offset;\n\n    uint32_t strips;\n\n    uint32_t *strip_sizes = NULL;\n\n    uint32_t *strip_offsets = NULL;\n\n    int bytes_per_row;\n\n    uint32_t res[2] = { 72, 1 };        // image resolution (72/1)\n\n    uint16_t bpp_tab[] = { 8, 8, 8, 8 };\n\n    int ret;\n\n    int is_yuv = 0;\n\n    uint8_t *yuv_line = NULL;\n\n    int shift_h, shift_v;\n\n    const AVPixFmtDescriptor* pfd;\n\n\n\n    s->avctx = avctx;\n\n\n\n    *p = *pict;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    p->key_frame = 1;\n\n    avctx->coded_frame= &s->picture;\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->subsampling[0] = 1;\n\n    s->subsampling[1] = 1;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case PIX_FMT_RGB48LE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_RGB24:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_PAL8:\n\n        pfd = &av_pix_fmt_descriptors[avctx->pix_fmt];\n\n        s->bpp = av_get_bits_per_pixel(pfd);\n\n        if (pfd->flags & PIX_FMT_PAL) {\n\n            s->photometric_interpretation = 3;\n\n        } else if (pfd->flags & PIX_FMT_RGB) {\n\n            s->photometric_interpretation = 2;\n\n        } else {\n\n            s->photometric_interpretation = 1;\n\n        }\n\n        s->bpp_tab_size = pfd->nb_components;\n\n        for (i = 0; i < s->bpp_tab_size; i++) {\n\n            bpp_tab[i] = s->bpp / s->bpp_tab_size;\n\n        }\n\n        break;\n\n    case PIX_FMT_MONOBLACK:\n\n        s->bpp = 1;\n\n        s->photometric_interpretation = 1;\n\n        s->bpp_tab_size = 0;\n\n        break;\n\n    case PIX_FMT_MONOWHITE:\n\n        s->bpp = 1;\n\n        s->photometric_interpretation = 0;\n\n        s->bpp_tab_size = 0;\n\n        break;\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n        s->photometric_interpretation = 6;\n\n        avcodec_get_chroma_sub_sample(avctx->pix_fmt,\n\n                &shift_h, &shift_v);\n\n        s->bpp = 8 + (16 >> (shift_h + shift_v));\n\n        s->subsampling[0] = 1 << shift_h;\n\n        s->subsampling[1] = 1 << shift_v;\n\n        s->bpp_tab_size = 3;\n\n        is_yuv = 1;\n\n        break;\n\n    default:\n\n        av_log(s->avctx, AV_LOG_ERROR,\n\n               \"This colors format is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE || s->compr == TIFF_LZW)\n\n        //best choose for DEFLATE\n\n        s->rps = s->height;\n\n    else\n\n        s->rps = FFMAX(8192 / (((s->width * s->bpp) >> 3) + 1), 1);     // suggest size of strip\n\n    s->rps = ((s->rps - 1) / s->subsampling[1] + 1) * s->subsampling[1]; // round rps up\n\n\n\n    strips = (s->height - 1) / s->rps + 1;\n\n\n\n    if (!pkt->data &&\n\n        (ret = av_new_packet(pkt, avctx->width * avctx->height * s->bpp * 2 +\n\n                                  avctx->height * 4 + FF_MIN_BUFFER_SIZE)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n\n        return ret;\n\n    }\n\n    ptr          = pkt->data;\n\n    s->buf_start = pkt->data;\n\n    s->buf       = &ptr;\n\n    s->buf_size  = pkt->size;\n\n\n\n    if (check_size(s, 8))\n\n        goto fail;\n\n\n\n    // write header\n\n    bytestream_put_le16(&ptr, 0x4949);\n\n    bytestream_put_le16(&ptr, 42);\n\n\n\n    offset = ptr;\n\n    bytestream_put_le32(&ptr, 0);\n\n\n\n    strip_sizes = av_mallocz(sizeof(*strip_sizes) * strips);\n\n    strip_offsets = av_mallocz(sizeof(*strip_offsets) * strips);\n\n\n\n    bytes_per_row = (((s->width - 1)/s->subsampling[0] + 1) * s->bpp\n\n                    * s->subsampling[0] * s->subsampling[1] + 7) >> 3;\n\n    if (is_yuv){\n\n        yuv_line = av_malloc(bytes_per_row);\n\n        if (yuv_line == NULL){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Not enough memory\\n\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#if CONFIG_ZLIB\n\n    if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE) {\n\n        uint8_t *zbuf;\n\n        int zlen, zn;\n\n        int j;\n\n\n\n        zlen = bytes_per_row * s->rps;\n\n        zbuf = av_malloc(zlen);\n\n        strip_offsets[0] = ptr - pkt->data;\n\n        zn = 0;\n\n        for (j = 0; j < s->rps; j++) {\n\n            if (is_yuv){\n\n                pack_yuv(s, yuv_line, j);\n\n                memcpy(zbuf + zn, yuv_line, bytes_per_row);\n\n                j += s->subsampling[1] - 1;\n\n            }\n\n            else\n\n                memcpy(zbuf + j * bytes_per_row,\n\n                       p->data[0] + j * p->linesize[0], bytes_per_row);\n\n            zn += bytes_per_row;\n\n        }\n\n        ret = encode_strip(s, zbuf, ptr, zn, s->compr);\n\n        av_free(zbuf);\n\n        if (ret < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Encode strip failed\\n\");\n\n            goto fail;\n\n        }\n\n        ptr += ret;\n\n        strip_sizes[0] = ptr - pkt->data - strip_offsets[0];\n\n    } else\n\n#endif\n\n    {\n\n        if(s->compr == TIFF_LZW)\n\n            s->lzws = av_malloc(ff_lzw_encode_state_size);\n\n        for (i = 0; i < s->height; i++) {\n\n            if (strip_sizes[i / s->rps] == 0) {\n\n                if(s->compr == TIFF_LZW){\n\n                    ff_lzw_encode_init(s->lzws, ptr, s->buf_size - (*s->buf - s->buf_start),\n\n                                       12, FF_LZW_TIFF, put_bits);\n\n                }\n\n                strip_offsets[i / s->rps] = ptr - pkt->data;\n\n            }\n\n            if (is_yuv){\n\n                 pack_yuv(s, yuv_line, i);\n\n                 ret = encode_strip(s, yuv_line, ptr, bytes_per_row, s->compr);\n\n                 i += s->subsampling[1] - 1;\n\n            }\n\n            else\n\n                ret = encode_strip(s, p->data[0] + i * p->linesize[0],\n\n                        ptr, bytes_per_row, s->compr);\n\n            if (ret < 0) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"Encode strip failed\\n\");\n\n                goto fail;\n\n            }\n\n            strip_sizes[i / s->rps] += ret;\n\n            ptr += ret;\n\n            if(s->compr == TIFF_LZW && (i==s->height-1 || i%s->rps == s->rps-1)){\n\n                ret = ff_lzw_encode_flush(s->lzws, flush_put_bits);\n\n                strip_sizes[(i / s->rps )] += ret ;\n\n                ptr += ret;\n\n            }\n\n        }\n\n        if(s->compr == TIFF_LZW)\n\n            av_free(s->lzws);\n\n    }\n\n\n\n    s->num_entries = 0;\n\n\n\n    add_entry1(s,TIFF_SUBFILE,           TIFF_LONG,             0);\n\n    add_entry1(s,TIFF_WIDTH,             TIFF_LONG,             s->width);\n\n    add_entry1(s,TIFF_HEIGHT,            TIFF_LONG,             s->height);\n\n\n\n    if (s->bpp_tab_size)\n\n    add_entry(s, TIFF_BPP,               TIFF_SHORT,    s->bpp_tab_size, bpp_tab);\n\n\n\n    add_entry1(s,TIFF_COMPR,             TIFF_SHORT,            s->compr);\n\n    add_entry1(s,TIFF_INVERT,            TIFF_SHORT,            s->photometric_interpretation);\n\n    add_entry(s, TIFF_STRIP_OFFS,        TIFF_LONG,     strips, strip_offsets);\n\n\n\n    if (s->bpp_tab_size)\n\n    add_entry1(s,TIFF_SAMPLES_PER_PIXEL, TIFF_SHORT,            s->bpp_tab_size);\n\n\n\n    add_entry1(s,TIFF_ROWSPERSTRIP,      TIFF_LONG,             s->rps);\n\n    add_entry(s, TIFF_STRIP_SIZE,        TIFF_LONG,     strips, strip_sizes);\n\n    add_entry(s, TIFF_XRES,              TIFF_RATIONAL, 1,      res);\n\n    add_entry(s, TIFF_YRES,              TIFF_RATIONAL, 1,      res);\n\n    add_entry1(s,TIFF_RES_UNIT,          TIFF_SHORT,            2);\n\n\n\n    if(!(avctx->flags & CODEC_FLAG_BITEXACT))\n\n    add_entry(s, TIFF_SOFTWARE_NAME,     TIFF_STRING,\n\n              strlen(LIBAVCODEC_IDENT) + 1, LIBAVCODEC_IDENT);\n\n\n\n    if (avctx->pix_fmt == PIX_FMT_PAL8) {\n\n        uint16_t pal[256 * 3];\n\n        for (i = 0; i < 256; i++) {\n\n            uint32_t rgb = *(uint32_t *) (p->data[1] + i * 4);\n\n            pal[i]       = ((rgb >> 16) & 0xff) * 257;\n\n            pal[i + 256] = ((rgb >> 8 ) & 0xff) * 257;\n\n            pal[i + 512] = ( rgb        & 0xff) * 257;\n\n        }\n\n        add_entry(s, TIFF_PAL, TIFF_SHORT, 256 * 3, pal);\n\n    }\n\n    if (is_yuv){\n\n        /** according to CCIR Recommendation 601.1 */\n\n        uint32_t refbw[12] = {15, 1, 235, 1, 128, 1, 240, 1, 128, 1, 240, 1};\n\n        add_entry(s, TIFF_YCBCR_SUBSAMPLING, TIFF_SHORT,    2, s->subsampling);\n\n        add_entry(s, TIFF_REFERENCE_BW,      TIFF_RATIONAL, 6, refbw);\n\n    }\n\n    bytestream_put_le32(&offset, ptr - pkt->data);    // write offset to dir\n\n\n\n    if (check_size(s, 6 + s->num_entries * 12)) {\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n    bytestream_put_le16(&ptr, s->num_entries);  // write tag count\n\n    bytestream_put_buffer(&ptr, s->entries, s->num_entries * 12);\n\n    bytestream_put_le32(&ptr, 0);\n\n\n\n    pkt->size   = ptr - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nfail:\n\n    av_free(strip_sizes);\n\n    av_free(strip_offsets);\n\n    av_free(yuv_line);\n\n    return ret;\n\n}\n", "idx": 1076}
{"project": "FFmpeg", "commit_id": "682b6db706a561de0241339f6674e59581ac1330", "target": 1, "func": "static int mxf_parse_structural_metadata(MXFContext *mxf)\n\n{\n\n    MXFPackage *material_package = NULL;\n\n    MXFPackage *temp_package = NULL;\n\n    int i, j, k;\n\n\n\n    av_dlog(mxf->fc, \"metadata sets count %d\\n\", mxf->metadata_sets_count);\n\n    /* TODO: handle multiple material packages (OP3x) */\n\n    for (i = 0; i < mxf->packages_count; i++) {\n\n        material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);\n\n        if (material_package) break;\n\n    }\n\n    if (!material_package) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < material_package->tracks_count; i++) {\n\n        MXFPackage *source_package = NULL;\n\n        MXFTrack *material_track = NULL;\n\n        MXFTrack *source_track = NULL;\n\n        MXFTrack *temp_track = NULL;\n\n        MXFDescriptor *descriptor = NULL;\n\n        MXFStructuralComponent *component = NULL;\n\n        UID *essence_container_ul = NULL;\n\n        const MXFCodecUL *codec_ul = NULL;\n\n        const MXFCodecUL *container_ul = NULL;\n\n        AVStream *st;\n\n\n\n        if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {\n\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");\n\n            continue;\n\n        }\n\n\n\n        if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {\n\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");\n\n            continue;\n\n        }\n\n\n\n        /* TODO: handle multiple source clips */\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n\n            /* TODO: handle timecode component */\n\n            component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], SourceClip);\n\n            if (!component)\n\n                continue;\n\n\n\n            for (k = 0; k < mxf->packages_count; k++) {\n\n                temp_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[k], SourcePackage);\n\n                if (!temp_package)\n\n                    continue;\n\n                if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)) {\n\n                    source_package = temp_package;\n\n                    break;\n\n                }\n\n            }\n\n            if (!source_package) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source package found\\n\", material_track->track_id);\n\n                break;\n\n            }\n\n            for (k = 0; k < source_package->tracks_count; k++) {\n\n                if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {\n\n                    av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                if (temp_track->track_id == component->source_track_id) {\n\n                    source_track = temp_track;\n\n                    break;\n\n                }\n\n            }\n\n            if (!source_track) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);\n\n                break;\n\n            }\n\n        }\n\n        if (!source_track)\n\n            continue;\n\n\n\n        st = avformat_new_stream(mxf->fc, NULL);\n\n        if (!st) {\n\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        st->id = source_track->track_id;\n\n        st->priv_data = source_track;\n\n        st->duration = component->duration;\n\n        if (st->duration == -1)\n\n            st->duration = AV_NOPTS_VALUE;\n\n        st->start_time = component->start_position;\n\n        avpriv_set_pts_info(st, 64, material_track->edit_rate.num, material_track->edit_rate.den);\n\n\n\n        if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {\n\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);\n\n        codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);\n\n        st->codec->codec_type = codec_ul->id;\n\n\n\n        source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);\n\n        if (source_package->descriptor) {\n\n            if (source_package->descriptor->type == MultipleDescriptor) {\n\n                for (j = 0; j < source_package->descriptor->sub_descriptors_count; j++) {\n\n                    MXFDescriptor *sub_descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor->sub_descriptors_refs[j], Descriptor);\n\n\n\n                    if (!sub_descriptor) {\n\n                        av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve sub descriptor strong ref\\n\");\n\n                        continue;\n\n                    }\n\n                    if (sub_descriptor->linked_track_id == source_track->track_id) {\n\n                        descriptor = sub_descriptor;\n\n                        break;\n\n                    }\n\n                }\n\n            } else if (source_package->descriptor->type == Descriptor)\n\n                descriptor = source_package->descriptor;\n\n        }\n\n        if (!descriptor) {\n\n            av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);\n\n            continue;\n\n        }\n\n        PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);\n\n        PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);\n\n        essence_container_ul = &descriptor->essence_container_ul;\n\n        /* HACK: replacing the original key with mxf_encrypted_essence_container\n\n         * is not allowed according to s429-6, try to find correct information anyway */\n\n        if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {\n\n            av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");\n\n            for (k = 0; k < mxf->metadata_sets_count; k++) {\n\n                MXFMetadataSet *metadata = mxf->metadata_sets[k];\n\n                if (metadata->type == CryptoContext) {\n\n                    essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */\n\n        codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);\n\n        st->codec->codec_id = codec_ul->id;\n\n        if (descriptor->extradata) {\n\n            st->codec->extradata = descriptor->extradata;\n\n            st->codec->extradata_size = descriptor->extradata_size;\n\n        }\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            container_ul = mxf_get_codec_ul(mxf_essence_container_uls, essence_container_ul);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                st->codec->codec_id = container_ul->id;\n\n            st->codec->width = descriptor->width;\n\n            st->codec->height = descriptor->height;\n\n            if (st->codec->codec_id == CODEC_ID_RAWVIDEO)\n\n                st->codec->pix_fmt = descriptor->pix_fmt;\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            container_ul = mxf_get_codec_ul(mxf_essence_container_uls, essence_container_ul);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                st->codec->codec_id = container_ul->id;\n\n            st->codec->channels = descriptor->channels;\n\n            st->codec->bits_per_coded_sample = descriptor->bits_per_sample;\n\n            st->codec->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;\n\n            /* TODO: implement CODEC_ID_RAWAUDIO */\n\n            if (st->codec->codec_id == CODEC_ID_PCM_S16LE) {\n\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n\n                    st->codec->codec_id = CODEC_ID_PCM_S24LE;\n\n                else if (descriptor->bits_per_sample == 32)\n\n                    st->codec->codec_id = CODEC_ID_PCM_S32LE;\n\n            } else if (st->codec->codec_id == CODEC_ID_PCM_S16BE) {\n\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n\n                    st->codec->codec_id = CODEC_ID_PCM_S24BE;\n\n                else if (descriptor->bits_per_sample == 32)\n\n                    st->codec->codec_id = CODEC_ID_PCM_S32BE;\n\n            } else if (st->codec->codec_id == CODEC_ID_MP2) {\n\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            }\n\n        }\n\n        if (st->codec->codec_type != AVMEDIA_TYPE_DATA && (*essence_container_ul)[15] > 0x01) {\n\n            av_log(mxf->fc, AV_LOG_WARNING, \"only frame wrapped mappings are correctly supported\\n\");\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1088}
