{"project": "FFmpeg", "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51", "target": 0, "func": "static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    /* init pix_fmts of codec */\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    /* init vda */\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    /* changes callback functions */\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    // force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    /* init H.264 decoder */\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n", "idx": 0}
{"project": "FFmpeg", "commit_id": "321b2a9ded0468670b7678b7c098886930ae16b2", "target": 0, "func": "static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                /* Sanity check that the stream types match */\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        /* try again and reuse existing stream */\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            /* maximum video buffer size is 6-bytes per pixel, plus DPX header size */\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits/s as argument, not kbits/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            //if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            //    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE / av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    /* set meta data information from input file if required */\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy chapters according to chapter maps */\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    /* copy chapters from the first input file that has them*/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* finish if limit size exhausted */\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        /* read a frame from it and output it in the fifo */\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n//        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        //fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    /* at the end of stream, we must flush the decoder buffers */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    /* close each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    /* finished ! */\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); /* works even if fifo is not\n\n                                             initialized but set to zero */\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1}
{"project": "FFmpeg", "commit_id": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8", "target": 0, "func": "static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n", "idx": 2}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) / 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n", "idx": 5}
{"project": "FFmpeg", "commit_id": "afb4632cc30e83287338690c785ebac180436a59", "target": 1, "func": "static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { // header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); // flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    /* Since codec is based on 4x4 blocks, size is aligned to 4. */\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); // pitch\n\n    bytestream2_skip(gbc, 4); // depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    /* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. */\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height / TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* Use the decompress function on the texture, one block per thread. */\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n        uint8_t *dst = frame->data[0];\n\n        int x, y, i;\n\n\n\n        /* Use the first 64 bytes as palette, then copy the rest. */\n\n        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);\n\n        for (i = 0; i < 16; i++) {\n\n            AV_WN32(frame->data[1] + i*4,\n\n                    (frame->data[1][2+i*4]<<0)+\n\n                    (frame->data[1][1+i*4]<<8)+\n\n                    (frame->data[1][0+i*4]<<16)+\n\n                    (frame->data[1][3+i*4]<<24)\n\n            );\n\n        }\n\n        frame->palette_has_changed = 1;\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width / 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * frame->width / 2);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (y = 0; y < frame->height; y++) {\n\n            for (x = 0; x < frame->width; x += 2) {\n\n                uint8_t val = bytestream2_get_byte(gbc);\n\n                dst[x    ] = val & 0xF;\n\n                dst[x + 1] = val >> 4;\n\n            }\n\n            dst += frame->linesize[0];\n\n        }\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            /* Use the first 1024 bytes as palette, then copy the rest. */\n\n            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);\n\n            for (i = 0; i < 256; i++)\n\n                AV_WN32(frame->data[1] + i*4,\n\n                        (frame->data[1][2+i*4]<<0)+\n\n                        (frame->data[1][1+i*4]<<8)+\n\n                        (frame->data[1][0+i*4]<<16)+\n\n                        (frame->data[1][3+i*4]<<24)\n\n                );\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    /* Run any post processing here if needed. */\n\n    if (ctx->postproc != DDS_NONE)\n\n        run_postproc(avctx, frame);\n\n\n\n    /* Frame is ready to be output. */\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 6}
{"project": "FFmpeg", "commit_id": "da032427786d9db4ab21014998cb1245083d6c85", "target": 1, "func": "static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w /= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { /* simulate crop */\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n", "idx": 7}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    /* set ACPI PM I/O space base address */\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    /* enable ACPI I/O */\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    /* set Root Complex BAR */\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n", "idx": 9}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 11}
{"project": "qemu", "commit_id": "a1d4e38a8b01a6699355c31867d524f8d4cd480e", "target": 1, "func": "static void nbd_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *saddr_qdict;\n\n    Visitor *ov;\n\n    const char *host = NULL, *port = NULL, *path = NULL;\n\n\n\n    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {\n\n        const InetSocketAddress *inet = s->saddr->u.inet.data;\n\n        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {\n\n            host = inet->host;\n\n            port = inet->port;\n\n        }\n\n    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        path = s->saddr->u.q_unix.data->path;\n\n    }\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nbd\"));\n\n\n\n    if (path && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:///%s?socket=%s\", s->export, path);\n\n    } else if (path && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix://?socket=%s\", path);\n\n    } else if (host && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s/%s\", host, port, s->export);\n\n    } else if (host && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s\", host, port);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&saddr_qdict);\n\n    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);\n\n    visit_complete(ov, &saddr_qdict);\n\n\n    assert(qobject_type(saddr_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", saddr_qdict);\n\n\n\n    if (s->export) {\n\n        qdict_put(opts, \"export\", qstring_from_str(s->export));\n\n    }\n\n    if (s->tlscredsid) {\n\n        qdict_put(opts, \"tls-creds\", qstring_from_str(s->tlscredsid));\n\n    }\n\n\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}", "idx": 13}
{"project": "qemu", "commit_id": "6687b79d636cd60ed9adb1177d0d946b58fa7717", "target": 1, "func": "int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    const char *ifname;\n\n\n\n    ifname = qemu_opt_get(opts, \"ifname\");\n\n\n\n    if (!ifname) {\n\n        error_report(\"tap: no interface name\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap_win32_init(vlan, \"tap\", name, ifname) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14}
{"project": "qemu", "commit_id": "3f168b5d353fa68baab55ea0c6ba791f0df027dc", "target": 1, "func": "print_insn (bfd_vma pc, disassemble_info *info)\n\n{\n\n  const struct dis386 *dp;\n\n  int i;\n\n  char *op_txt[MAX_OPERANDS];\n\n  int needcomma;\n\n  unsigned char uses_DATA_prefix, uses_LOCK_prefix;\n\n  unsigned char uses_REPNZ_prefix, uses_REPZ_prefix;\n\n  int sizeflag;\n\n  const char *p;\n\n  struct dis_private priv;\n\n  unsigned char op;\n\n  unsigned char threebyte;\n\n\n\n  if (info->mach == bfd_mach_x86_64_intel_syntax\n\n      || info->mach == bfd_mach_x86_64)\n\n    address_mode = mode_64bit;\n\n  else\n\n    address_mode = mode_32bit;\n\n\n\n  if (intel_syntax == (char) -1)\n\n    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax\n\n\t\t    || info->mach == bfd_mach_x86_64_intel_syntax);\n\n\n\n  if (info->mach == bfd_mach_i386_i386\n\n      || info->mach == bfd_mach_x86_64\n\n      || info->mach == bfd_mach_i386_i386_intel_syntax\n\n      || info->mach == bfd_mach_x86_64_intel_syntax)\n\n    priv.orig_sizeflag = AFLAG | DFLAG;\n\n  else if (info->mach == bfd_mach_i386_i8086)\n\n    priv.orig_sizeflag = 0;\n\n  else\n\n    abort ();\n\n\n\n  for (p = info->disassembler_options; p != NULL; )\n\n    {\n\n      if (strncmp (p, \"x86-64\", 6) == 0)\n\n\t{\n\n\t  address_mode = mode_64bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i386\", 4) == 0)\n\n\t{\n\n\t  address_mode = mode_32bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i8086\", 5) == 0)\n\n\t{\n\n\t  address_mode = mode_16bit;\n\n\t  priv.orig_sizeflag = 0;\n\n\t}\n\n      else if (strncmp (p, \"intel\", 5) == 0)\n\n\t{\n\n\t  intel_syntax = 1;\n\n\t}\n\n      else if (strncmp (p, \"att\", 3) == 0)\n\n\t{\n\n\t  intel_syntax = 0;\n\n\t}\n\n      else if (strncmp (p, \"addr\", 4) == 0)\n\n\t{\n\n\t  if (address_mode == mode_64bit)\n\n\t    {\n\n\t      if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '6' && p[5] == '4')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t  else\n\n\t    {\n\n\t      if (p[4] == '1' && p[5] == '6')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t}\n\n      else if (strncmp (p, \"data\", 4) == 0)\n\n\t{\n\n\t  if (p[4] == '1' && p[5] == '6')\n\n\t    priv.orig_sizeflag &= ~DFLAG;\n\n\t  else if (p[4] == '3' && p[5] == '2')\n\n\t    priv.orig_sizeflag |= DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"suffix\", 6) == 0)\n\n\tpriv.orig_sizeflag |= SUFFIX_ALWAYS;\n\n\n\n      p = strchr (p, ',');\n\n      if (p != NULL)\n\n\tp++;\n\n    }\n\n\n\n  if (intel_syntax)\n\n    {\n\n      names64 = intel_names64;\n\n      names32 = intel_names32;\n\n      names16 = intel_names16;\n\n      names8 = intel_names8;\n\n      names8rex = intel_names8rex;\n\n      names_seg = intel_names_seg;\n\n      index16 = intel_index16;\n\n      open_char = '[';\n\n      close_char = ']';\n\n      separator_char = '+';\n\n      scale_char = '*';\n\n    }\n\n  else\n\n    {\n\n      names64 = att_names64;\n\n      names32 = att_names32;\n\n      names16 = att_names16;\n\n      names8 = att_names8;\n\n      names8rex = att_names8rex;\n\n      names_seg = att_names_seg;\n\n      index16 = att_index16;\n\n      open_char = '(';\n\n      close_char =  ')';\n\n      separator_char = ',';\n\n      scale_char = ',';\n\n    }\n\n\n\n  /* The output looks better if we put 7 bytes on a line, since that\n\n     puts most long word instructions on a single line.  */\n\n  info->bytes_per_line = 7;\n\n\n\n  info->private_data = &priv;\n\n  priv.max_fetched = priv.the_buffer;\n\n  priv.insn_start = pc;\n\n\n\n  obuf[0] = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    {\n\n      op_out[i][0] = 0;\n\n      op_index[i] = -1;\n\n    }\n\n\n\n  the_info = info;\n\n  start_pc = pc;\n\n  start_codep = priv.the_buffer;\n\n  codep = priv.the_buffer;\n\n\n\n  if (sigsetjmp(priv.bailout, 0) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      /* Getting here means we tried for data but didn't get it.  That\n\n\t means we have an incomplete instruction of some sort.  Just\n\n\t print the first byte as a prefix or a .byte pseudo-op.  */\n\n      if (codep > priv.the_buffer)\n\n\t{\n\n\t  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n\t  if (name != NULL)\n\n\t    (*info->fprintf_func) (info->stream, \"%s\", name);\n\n\t  else\n\n\t    {\n\n\t      /* Just print the first byte as a .byte instruction.  */\n\n\t      (*info->fprintf_func) (info->stream, \".byte 0x%x\",\n\n\t\t\t\t     (unsigned int) priv.the_buffer[0]);\n\n\t    }\n\n\n\n\t  return 1;\n\n\t}\n\n\n\n      return -1;\n\n    }\n\n\n\n  obufp = obuf;\n\n  ckprefix ();\n\n  ckvexprefix ();\n\n\n\n  insn_codep = codep;\n\n  sizeflag = priv.orig_sizeflag;\n\n\n\n  fetch_data(info, codep + 1);\n\n  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);\n\n\n\n  if (((prefixes & PREFIX_FWAIT)\n\n       && ((*codep < 0xd8) || (*codep > 0xdf)))\n\n      || (rex && rex_used))\n\n    {\n\n      const char *name;\n\n\n\n      /* fwait not followed by floating point instruction, or rex followed\n\n\t by other prefixes.  Print the first prefix.  */\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n\n\n  op = 0;\n\n  if (prefixes & PREFIX_VEX_0F)\n\n    {\n\n      used_prefixes |= PREFIX_VEX_0F | PREFIX_VEX_0F38 | PREFIX_VEX_0F3A;\n\n      if (prefixes & PREFIX_VEX_0F38)\n\n        threebyte = 0x38;\n\n      else if (prefixes & PREFIX_VEX_0F3A)\n\n        threebyte = 0x3a;\n\n      else\n\n        threebyte = *codep++;\n\n      goto vex_opcode;\n\n    }\n\n  if (*codep == 0x0f)\n\n    {\n\n      fetch_data(info, codep + 2);\n\n      threebyte = codep[1];\n\n      codep += 2;\n\n    vex_opcode:\n\n      dp = &dis386_twobyte[threebyte];\n\n      need_modrm = twobyte_has_modrm[threebyte];\n\n      uses_DATA_prefix = twobyte_uses_DATA_prefix[threebyte];\n\n      uses_REPNZ_prefix = twobyte_uses_REPNZ_prefix[threebyte];\n\n      uses_REPZ_prefix = twobyte_uses_REPZ_prefix[threebyte];\n\n      uses_LOCK_prefix = (threebyte & ~0x02) == 0x20;\n\n      if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n\t{\n\n          fetch_data(info, codep + 2);\n\n\t  op = *codep++;\n\n\t  switch (threebyte)\n\n\t    {\n\n\t    case 0x38:\n\n\t      uses_DATA_prefix = threebyte_0x38_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x38_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x38_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    case 0x3a:\n\n\t      uses_DATA_prefix = threebyte_0x3a_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x3a_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x3a_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    default:\n\n\t      break;\n\n\t    }\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      dp = &dis386[*codep];\n\n      need_modrm = onebyte_has_modrm[*codep];\n\n      uses_DATA_prefix = 0;\n\n      uses_REPNZ_prefix = 0;\n\n      /* pause is 0xf3 0x90.  */\n\n      uses_REPZ_prefix = *codep == 0x90;\n\n      uses_LOCK_prefix = 0;\n\n      codep++;\n\n    }\n\n\n\n  if (!uses_REPZ_prefix && (prefixes & PREFIX_REPZ))\n\n    {\n\n      oappend (\"repz \");\n\n      used_prefixes |= PREFIX_REPZ;\n\n    }\n\n  if (!uses_REPNZ_prefix && (prefixes & PREFIX_REPNZ))\n\n    {\n\n      oappend (\"repnz \");\n\n      used_prefixes |= PREFIX_REPNZ;\n\n    }\n\n\n\n  if (!uses_LOCK_prefix && (prefixes & PREFIX_LOCK))\n\n    {\n\n      oappend (\"lock \");\n\n      used_prefixes |= PREFIX_LOCK;\n\n    }\n\n\n\n  if (prefixes & PREFIX_ADDR)\n\n    {\n\n      sizeflag ^= AFLAG;\n\n      if (dp->op[2].bytemode != loop_jcxz_mode || intel_syntax)\n\n\t{\n\n\t  if ((sizeflag & AFLAG) || address_mode == mode_64bit)\n\n\t    oappend (\"addr32 \");\n\n\t  else\n\n\t    oappend (\"addr16 \");\n\n\t  used_prefixes |= PREFIX_ADDR;\n\n\t}\n\n    }\n\n\n\n  if (!uses_DATA_prefix && (prefixes & PREFIX_DATA))\n\n    {\n\n      sizeflag ^= DFLAG;\n\n      if (dp->op[2].bytemode == cond_jump_mode\n\n\t  && dp->op[0].bytemode == v_mode\n\n\t  && !intel_syntax)\n\n\t{\n\n\t  if (sizeflag & DFLAG)\n\n\t    oappend (\"data32 \");\n\n\t  else\n\n\t    oappend (\"data16 \");\n\n\t  used_prefixes |= PREFIX_DATA;\n\n\t}\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n    {\n\n      dp = &three_byte_table[dp->op[1].bytemode][op];\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n  else if (need_modrm)\n\n    {\n\n      fetch_data(info, codep + 1);\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n\n    {\n\n      dofloat (sizeflag);\n\n    }\n\n  else\n\n    {\n\n      int index;\n\n      if (dp->name == NULL)\n\n\t{\n\n\t  switch (dp->op[0].bytemode)\n\n\t    {\n\n\t    case USE_GROUPS:\n\n\t      dp = &grps[dp->op[1].bytemode][modrm.reg];\n\n\t      break;\n\n\n\n\t    case USE_PREFIX_USER_TABLE:\n\n\t      index = 0;\n\n\t      used_prefixes |= (prefixes & PREFIX_REPZ);\n\n\t      if (prefixes & PREFIX_REPZ)\n\n\t\tindex = 1;\n\n\t      else\n\n\t\t{\n\n\t\t  /* We should check PREFIX_REPNZ and PREFIX_REPZ\n\n\t\t     before PREFIX_DATA.  */\n\n\t\t  used_prefixes |= (prefixes & PREFIX_REPNZ);\n\n\t\t  if (prefixes & PREFIX_REPNZ)\n\n\t\t    index = 3;\n\n\t\t  else\n\n\t\t    {\n\n\t\t      used_prefixes |= (prefixes & PREFIX_DATA);\n\n\t\t      if (prefixes & PREFIX_DATA)\n\n\t\t\tindex = 2;\n\n\t\t    }\n\n\t\t}\n\n\t      dp = &prefix_user_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    case X86_64_SPECIAL:\n\n\t      index = address_mode == mode_64bit ? 1 : 0;\n\n\t      dp = &x86_64_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    default:\n\n\t      oappend (INTERNAL_DISASSEMBLER_ERROR);\n\n\t      break;\n\n\t    }\n\n\t}\n\n\n\n      if (putop (dp->name, sizeflag) == 0)\n\n        {\n\n\t  for (i = 0; i < MAX_OPERANDS; ++i)\n\n\t    {\n\n\t      obufp = op_out[i];\n\n\t      op_ad = MAX_OPERANDS - 1 - i;\n\n\t      if (dp->op[i].rtn)\n\n\t\t(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);\n\n\t    }\n\n\t}\n\n    }\n\n\n\n  /* See if any prefixes were not used.  If so, print the first one\n\n     separately.  If we don't do this, we'll wind up printing an\n\n     instruction stream which does not precisely correspond to the\n\n     bytes we are disassembling.  */\n\n  if ((prefixes & ~used_prefixes) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n  if (rex & ~rex_used)\n\n    {\n\n      const char *name;\n\n      name = prefix_name (rex | 0x40, priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s \", name);\n\n    }\n\n\n\n  obufp = obuf + strlen (obuf);\n\n  for (i = strlen (obuf); i < 6; i++)\n\n    oappend (\" \");\n\n  oappend (\" \");\n\n  (*info->fprintf_func) (info->stream, \"%s\", obuf);\n\n\n\n  /* The enter and bound instructions are printed with operands in the same\n\n     order as the intel book; everything else is printed in reverse order.  */\n\n  if (intel_syntax || two_source_ops)\n\n    {\n\n      bfd_vma riprel;\n\n\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[i] = op_out[i];\n\n\n\n      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)\n\n\t{\n\n          op_ad = op_index[i];\n\n          op_index[i] = op_index[MAX_OPERANDS - 1 - i];\n\n          op_index[MAX_OPERANDS - 1 - i] = op_ad;\n\n\t  riprel = op_riprel[i];\n\n\t  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];\n\n\t  op_riprel[MAX_OPERANDS - 1 - i] = riprel;\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[MAX_OPERANDS - 1 - i] = op_out[i];\n\n    }\n\n\n\n  needcomma = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    if (*op_txt[i])\n\n      {\n\n\tif (needcomma)\n\n\t  (*info->fprintf_func) (info->stream, \",\");\n\n\tif (op_index[i] != -1 && !op_riprel[i])\n\n\t  (*info->print_address_func) ((bfd_vma) op_address[op_index[i]], info);\n\n\telse\n\n\t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n\n\tneedcomma = 1;\n\n      }\n\n\n\n  for (i = 0; i < MAX_OPERANDS; i++)\n\n    if (op_index[i] != -1 && op_riprel[i])\n\n      {\n\n\t(*info->fprintf_func) (info->stream, \"        # \");\n\n\t(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep\n\n\t\t\t\t\t\t+ op_address[op_index[i]]), info);\n\n\tbreak;\n\n      }\n\n  return codep - priv.the_buffer;\n\n}\n", "idx": 16}
{"project": "FFmpeg", "commit_id": "2a6eb06254df79e96b3d791b6b89b2534ced3119", "target": 1, "func": "static void vp6_parse_coeff_huffman(VP56Context *s)\n\n{\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->scantable.permutated;\n\n    VLC *vlc_coeff;\n\n    int coeff, sign, coeff_idx;\n\n    int b, cg, idx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 0;    /* code type */\n\n        if (b > 3) pt = 1;\n\n        vlc_coeff = &s->dccv_vlc[pt];\n\n\n\n        for (coeff_idx=0; coeff_idx<64; ) {\n\n            int run = 1;\n\n            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {\n\n                s->nb_null[coeff_idx][pt]--;\n\n                if (coeff_idx)\n\n                    break;\n\n            } else {\n\n                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)\n\n                    return;\n\n                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);\n\n                if (coeff == 0) {\n\n                    if (coeff_idx) {\n\n                        int pt = (coeff_idx >= 6);\n\n                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);\n\n                        if (run >= 9)\n\n                            run += get_bits(&s->gb, 6);\n\n                    } else\n\n                        s->nb_null[0][pt] = vp6_get_nb_null(s);\n\n                    ct = 0;\n\n                } else if (coeff == 11) {  /* end of block */\n\n                    if (coeff_idx == 1)    /* first AC coeff ? */\n\n                        s->nb_null[1][pt] = vp6_get_nb_null(s);\n\n                    break;\n\n                } else {\n\n                    int coeff2 = vp56_coeff_bias[coeff];\n\n                    if (coeff > 4)\n\n                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);\n\n                    ct = 1 + (coeff2 > 1);\n\n                    sign = get_bits1(&s->gb);\n\n                    coeff2 = (coeff2 ^ -sign) + sign;\n\n                    if (coeff_idx)\n\n                        coeff2 *= s->dequant_ac;\n\n                    idx = model->coeff_index_to_pos[coeff_idx];\n\n                    s->block_coeff[b][permute[idx]] = coeff2;\n\n                }\n\n            }\n\n            coeff_idx+=run;\n\n            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);\n\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n\n        }\n\n    }\n\n}\n", "idx": 17}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static int vncws_start_tls_handshake(VncState *vs)\n\n{\n\n    int ret = gnutls_handshake(vs->tls.session);\n\n\n\n    if (ret < 0) {\n\n        if (!gnutls_error_is_fatal(ret)) {\n\n            VNC_DEBUG(\"Handshake interrupted (blocking)\\n\");\n\n            if (!gnutls_record_get_direction(vs->tls.session)) {\n\n                qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io,\n\n                                    NULL, vs);\n\n            } else {\n\n                qemu_set_fd_handler(vs->csock, NULL, vncws_tls_handshake_io,\n\n                                    vs);\n\n            }\n\n            return 0;\n\n        }\n\n        VNC_DEBUG(\"Handshake failed %s\\n\", gnutls_strerror(ret));\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (vs->vd->tls.x509verify) {\n\n        if (vnc_tls_validate_certificate(vs) < 0) {\n\n            VNC_DEBUG(\"Client verification failed\\n\");\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        } else {\n\n            VNC_DEBUG(\"Client verification passed\\n\");\n\n        }\n\n    }\n\n\n\n    VNC_DEBUG(\"Handshake done, switching to TLS data mode\\n\");\n\n    qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n\n\n    return 0;\n\n}\n", "idx": 18}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 19}
{"project": "qemu", "commit_id": "0696ae2c9236a3589f5eaf5b00c12868b6f30a17", "target": 1, "func": "static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version;\n\n    uint64_t refcount_bits;\n\n    int refcount_order;\n\n    const char *encryptfmt = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /* Read out options */\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    encryptfmt = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);\n\n    if (encryptfmt) {\n\n        if (qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT)) {\n\n            error_setg(errp, \"Options \" BLOCK_OPT_ENCRYPT \" and \"\n\n                       BLOCK_OPT_ENCRYPT_FORMAT \" are mutually exclusive\");\n\n            ret = -EINVAL;\n\n            goto finish;\n\n        }\n\n    } else if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        encryptfmt = \"aes\";\n\n    }\n\n    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    version = qcow2_opt_get_version_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        encryptfmt, &local_err);\n\n    error_propagate(errp, local_err);\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 20}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void quantize_mantissas(AC3EncodeContext *s)\n\n{\n\n    int blk, ch;\n\n\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;\n\n        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;\n\n\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],\n\n                                      block->exp[ch], block->bap[ch],\n\n                                      block->qmant[ch], s->nb_coefs[ch]);\n\n        }\n\n    }\n\n}\n", "idx": 21}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void dma_blk_cb(void *opaque, int ret)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    dma_addr_t cur_addr, cur_len;\n\n    void *mem;\n\n\n\n    trace_dma_blk_cb(dbs, ret);\n\n\n\n    dbs->acb = NULL;\n\n    dbs->sector_num += dbs->iov.size / 512;\n\n\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n\n        dma_complete(dbs, ret);\n\n        return;\n\n    }\n\n    dma_blk_unmap(dbs);\n\n\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n\n        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);\n\n        if (!mem)\n\n            break;\n\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n\n        dbs->sg_cur_byte += cur_len;\n\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n\n            dbs->sg_cur_byte = 0;\n\n            ++dbs->sg_cur_index;\n\n        }\n\n    }\n\n\n\n    if (dbs->iov.size == 0) {\n\n        trace_dma_map_wait(dbs);\n\n        cpu_register_map_client(dbs, continue_after_map_failure);\n\n        return;\n\n    }\n\n\n\n    if (dbs->iov.size & ~BDRV_SECTOR_MASK) {\n\n        qemu_iovec_discard_back(&dbs->iov, dbs->iov.size & ~BDRV_SECTOR_MASK);\n\n    }\n\n\n\n    dbs->acb = dbs->io_func(dbs->blk, dbs->sector_num, &dbs->iov,\n\n                            dbs->iov.size / 512, dma_blk_cb, dbs);\n\n    assert(dbs->acb);\n\n}\n", "idx": 23}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_sigreturn(CPUPPCState *env)\n\n{\n\n    struct target_sigcontext *sc = NULL;\n\n    struct target_mcontext *sr = NULL;\n\n    target_ulong sr_addr = 0, sc_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t set;\n\n\n\n    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1))\n\n        goto sigsegv;\n\n\n\n#if defined(TARGET_PPC64)\n\n    set.sig[0] = sc->oldmask + ((uint64_t)(sc->_unused[3]) << 32);\n\n#else\n\n    __get_user(set.sig[0], &sc->oldmask);\n\n    __get_user(set.sig[1], &sc->_unused[3]);\n\n#endif\n\n    target_to_host_sigset_internal(&blocked, &set);\n\n    set_sigmask(&blocked);\n\n\n\n    __get_user(sr_addr, &sc->regs);\n\n    if (!lock_user_struct(VERIFY_READ, sr, sr_addr, 1))\n\n        goto sigsegv;\n\n    restore_user_regs(env, sr, 1);\n\n\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nsigsegv:\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 24}
{"project": "qemu", "commit_id": "c84f0f25db2eaab101665ddb60c1ddf1decce76a", "target": 1, "func": "static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    VirtIOGPU *g = opaque;\n\n    struct virtio_gpu_simple_resource *res;\n\n    struct virtio_gpu_scanout *scanout;\n\n    uint32_t resource_id, pformat;\n\n    int i;\n\n\n\n    g->hostmem = 0;\n\n\n\n    resource_id = qemu_get_be32(f);\n\n    while (resource_id != 0) {\n\n        res = g_new0(struct virtio_gpu_simple_resource, 1);\n\n        res->resource_id = resource_id;\n\n        res->width = qemu_get_be32(f);\n\n        res->height = qemu_get_be32(f);\n\n        res->format = qemu_get_be32(f);\n\n        res->iov_cnt = qemu_get_be32(f);\n\n\n\n        /* allocate */\n\n        pformat = get_pixman_format(res->format);\n\n        if (!pformat) {\n\n\n            return -EINVAL;\n\n\n        res->image = pixman_image_create_bits(pformat,\n\n                                              res->width, res->height,\n\n                                              NULL, 0);\n\n        if (!res->image) {\n\n\n            return -EINVAL;\n\n\n\n\n        res->hostmem = PIXMAN_FORMAT_BPP(pformat) * res->width * res->height;\n\n\n\n        res->addrs = g_new(uint64_t, res->iov_cnt);\n\n        res->iov = g_new(struct iovec, res->iov_cnt);\n\n\n\n        /* read data */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            res->addrs[i] = qemu_get_be64(f);\n\n            res->iov[i].iov_len = qemu_get_be32(f);\n\n\n        qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),\n\n                        pixman_image_get_stride(res->image) * res->height);\n\n\n\n        /* restore mapping */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            hwaddr len = res->iov[i].iov_len;\n\n            res->iov[i].iov_base =\n\n                cpu_physical_memory_map(res->addrs[i], &len, 1);\n\n            if (!res->iov[i].iov_base || len != res->iov[i].iov_len) {\n\n\n\n\n\n\n\n\n\n\n\n                return -EINVAL;\n\n\n\n\n\n        QTAILQ_INSERT_HEAD(&g->reslist, res, next);\n\n        g->hostmem += res->hostmem;\n\n\n\n        resource_id = qemu_get_be32(f);\n\n\n\n\n    /* load & apply scanout state */\n\n    vmstate_load_state(f, &vmstate_virtio_gpu_scanouts, g, 1);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n        scanout = &g->scanout[i];\n\n        if (!scanout->resource_id) {\n\n            continue;\n\n\n        res = virtio_gpu_find_resource(g, scanout->resource_id);\n\n        if (!res) {\n\n            return -EINVAL;\n\n\n        scanout->ds = qemu_create_displaysurface_pixman(res->image);\n\n        if (!scanout->ds) {\n\n            return -EINVAL;\n\n\n\n\n        dpy_gfx_replace_surface(scanout->con, scanout->ds);\n\n        dpy_gfx_update(scanout->con, 0, 0, scanout->width, scanout->height);\n\n        update_cursor(g, &scanout->cursor);\n\n        res->scanout_bitmask |= (1 << i);\n\n\n\n\n    return 0;\n", "idx": 25}
{"project": "FFmpeg", "commit_id": "16c831851384ab59e73579fdd9913fbff3c0284a", "target": 1, "func": "static av_cold int iv_alloc_frames(Indeo3DecodeContext *s)\n\n{\n\n    int luma_width    = (s->width           + 3) & ~3,\n\n        luma_height   = (s->height          + 3) & ~3,\n\n        chroma_width  = ((luma_width  >> 2) + 3) & ~3,\n\n        chroma_height = ((luma_height >> 2) + 3) & ~3,\n\n        luma_pixels   = luma_width   * luma_height,\n\n        chroma_pixels = chroma_width * chroma_height,\n\n        i;\n\n    unsigned int bufsize = luma_pixels * 2 + luma_width * 3 +\n\n                          (chroma_pixels   + chroma_width) * 4;\n\n\n\n\n    if(!(s->buf = av_malloc(bufsize)))\n\n        return AVERROR(ENOMEM);\n\n    s->iv_frame[0].y_w = s->iv_frame[1].y_w = luma_width;\n\n    s->iv_frame[0].y_h = s->iv_frame[1].y_h = luma_height;\n\n    s->iv_frame[0].uv_w = s->iv_frame[1].uv_w = chroma_width;\n\n    s->iv_frame[0].uv_h = s->iv_frame[1].uv_h = chroma_height;\n\n\n\n    s->iv_frame[0].Ybuf = s->buf + luma_width;\n\n    i = luma_pixels + luma_width * 2;\n\n    s->iv_frame[1].Ybuf = s->buf + i;\n\n    i += (luma_pixels + luma_width);\n\n    s->iv_frame[0].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[0].Vbuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Vbuf = s->buf + i;\n\n\n\n    for(i = 1; i <= luma_width; i++)\n\n        s->iv_frame[0].Ybuf[-i] = s->iv_frame[1].Ybuf[-i] =\n\n            s->iv_frame[0].Ubuf[-i] = 0x80;\n\n\n\n    for(i = 1; i <= chroma_width; i++) {\n\n        s->iv_frame[1].Ubuf[-i] = 0x80;\n\n        s->iv_frame[0].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[chroma_pixels+i-1] = 0x80;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 26}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n", "idx": 27}
{"project": "FFmpeg", "commit_id": "fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc", "target": 0, "func": "int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n", "idx": 28}
{"project": "FFmpeg", "commit_id": "f61bece684d9685b07895508e6c1c733b5564ccf", "target": 0, "func": "av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n", "idx": 29}
{"project": "FFmpeg", "commit_id": "38477e1981a7729b02d9a2f45142c53dc78625fe", "target": 0, "func": "static int config_props(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    LutContext *lut = ctx->priv;\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];\n\n    int min[4], max[4];\n\n    int val, comp, ret;\n\n\n\n    lut->hsub = desc->log2_chroma_w;\n\n    lut->vsub = desc->log2_chroma_h;\n\n\n\n    lut->var_values[VAR_W] = inlink->w;\n\n    lut->var_values[VAR_H] = inlink->h;\n\n\n\n    switch (inlink->format) {\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUVA420P:\n\n        min[Y] = min[U] = min[V] = 16;\n\n        max[Y] = 235;\n\n        max[U] = max[V] = 240;\n\n        min[A] = 0; max[A] = 255;\n\n        break;\n\n    default:\n\n        min[0] = min[1] = min[2] = min[3] = 0;\n\n        max[0] = max[1] = max[2] = max[3] = 255;\n\n    }\n\n\n\n    lut->is_yuv = lut->is_rgb = 0;\n\n    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;\n\n    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;\n\n\n\n    if (lut->is_rgb) {\n\n        switch (inlink->format) {\n\n        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;\n\n        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;\n\n        case PIX_FMT_RGBA:\n\n        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;\n\n        case PIX_FMT_BGRA:\n\n        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;\n\n        }\n\n        lut->step = av_get_bits_per_pixel(desc) >> 3;\n\n    }\n\n\n\n    for (comp = 0; comp < desc->nb_components; comp++) {\n\n        double res;\n\n\n\n        /* create the parsed expression */\n\n        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],\n\n                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);\n\n        if (ret < 0) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Error when parsing the expression '%s' for the component %d.\\n\",\n\n                   lut->comp_expr_str[comp], comp);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        /* compute the lut */\n\n        lut->var_values[VAR_MAXVAL] = max[comp];\n\n        lut->var_values[VAR_MINVAL] = min[comp];\n\n\n\n        for (val = 0; val < 256; val++) {\n\n            lut->var_values[VAR_VAL] = val;\n\n            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);\n\n            lut->var_values[VAR_NEGVAL] =\n\n                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],\n\n                        min[comp], max[comp]);\n\n\n\n            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);\n\n            if (isnan(res)) {\n\n                av_log(ctx, AV_LOG_ERROR,\n\n                       \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",\n\n                       lut->comp_expr_str[comp], val, comp);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);\n\n            av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 30}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 31}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static int huffman_decode(MPADecodeContext *s, GranuleDef *g,\n\n                          int16_t *exponents, int end_pos2)\n\n{\n\n    int s_index;\n\n    int i;\n\n    int last_pos, bits_left;\n\n    VLC *vlc;\n\n    int end_pos = FFMIN(end_pos2, s->gb.size_in_bits);\n\n\n\n    /* low frequencies (called big values) */\n\n    s_index = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        int j, k, l, linbits;\n\n        j = g->region_size[i];\n\n        if (j == 0)\n\n            continue;\n\n        /* select vlc table */\n\n        k       = g->table_select[i];\n\n        l       = mpa_huff_data[k][0];\n\n        linbits = mpa_huff_data[k][1];\n\n        vlc     = &huff_vlc[l];\n\n\n\n        if (!l) {\n\n            memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * 2 * j);\n\n            s_index += 2 * j;\n\n            continue;\n\n        }\n\n\n\n        /* read huffcode and compute each couple */\n\n        for (; j > 0; j--) {\n\n            int exponent, x, y;\n\n            int v;\n\n            int pos = get_bits_count(&s->gb);\n\n\n\n            if (pos >= end_pos){\n\n                switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n                if (pos >= end_pos)\n\n                    break;\n\n            }\n\n            y = get_vlc2(&s->gb, vlc->table, 7, 3);\n\n\n\n            if (!y) {\n\n                g->sb_hybrid[s_index  ] =\n\n                g->sb_hybrid[s_index+1] = 0;\n\n                s_index += 2;\n\n                continue;\n\n            }\n\n\n\n            exponent= exponents[s_index];\n\n\n\n            ff_dlog(s->avctx, \"region=%d n=%d x=%d y=%d exp=%d\\n\",\n\n                    i, g->region_size[i] - j, x, y, exponent);\n\n            if (y & 16) {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index] = v;\n\n                }\n\n                if (y < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + 1, RENAME(expval_table)[exponent] + y)\n\n                } else {\n\n                    y += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(y, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+1] = v;\n\n                }\n\n            } else {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                x += y;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + !!y, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+!!y] = v;\n\n                }\n\n                g->sb_hybrid[s_index + !y] = 0;\n\n            }\n\n            s_index += 2;\n\n        }\n\n    }\n\n\n\n    /* high frequencies */\n\n    vlc = &huff_quad_vlc[g->count1table_select];\n\n    last_pos = 0;\n\n    while (s_index <= 572) {\n\n        int pos, code;\n\n        pos = get_bits_count(&s->gb);\n\n        if (pos >= end_pos) {\n\n            if (pos > end_pos2 && last_pos) {\n\n                /* some encoders generate an incorrect size for this\n\n                   part. We must go back into the data */\n\n                s_index -= 4;\n\n                skip_bits_long(&s->gb, last_pos - pos);\n\n                av_log(s->avctx, AV_LOG_INFO, \"overread, skip %d enddists: %d %d\\n\", last_pos - pos, end_pos-pos, end_pos2-pos);\n\n                if(s->err_recognition & AV_EF_BITSTREAM)\n\n                    s_index=0;\n\n                break;\n\n            }\n\n            switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n            if (pos >= end_pos)\n\n                break;\n\n        }\n\n        last_pos = pos;\n\n\n\n        code = get_vlc2(&s->gb, vlc->table, vlc->bits, 1);\n\n        ff_dlog(s->avctx, \"t=%d code=%d\\n\", g->count1table_select, code);\n\n        g->sb_hybrid[s_index+0] =\n\n        g->sb_hybrid[s_index+1] =\n\n        g->sb_hybrid[s_index+2] =\n\n        g->sb_hybrid[s_index+3] = 0;\n\n        while (code) {\n\n            static const int idxtab[16] = { 3,3,2,2,1,1,1,1,0,0,0,0,0,0,0,0 };\n\n            int v;\n\n            int pos = s_index + idxtab[code];\n\n            code   ^= 8 >> idxtab[code];\n\n            READ_FLIP_SIGN(g->sb_hybrid + pos, RENAME(exp_table)+exponents[pos])\n\n        }\n\n        s_index += 4;\n\n    }\n\n    /* skip extension bits */\n\n    bits_left = end_pos2 - get_bits_count(&s->gb);\n\n    if (bits_left < 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index=0;\n\n    } else if (bits_left > 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index = 0;\n\n    }\n\n    memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * (576 - s_index));\n\n    skip_bits_long(&s->gb, bits_left);\n\n\n\n    i = get_bits_count(&s->gb);\n\n    switch_buffer(s, &i, &end_pos, &end_pos2);\n\n\n\n    return 0;\n\n}\n", "idx": 32}
{"project": "qemu", "commit_id": "cd0c6f473532bfaf20a095bc90a18e45162981b5", "target": 1, "func": "void helper_slbie(CPUPPCState *env, target_ulong addr)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    ppc_slb_t *slb;\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return;\n\n    }\n\n\n\n    if (slb->esid & SLB_ESID_V) {\n\n        slb->esid &= ~SLB_ESID_V;\n\n\n\n        /* XXX: given the fact that segment size is 256 MB or 1TB,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n         *      in QEMU, we just invalidate all TLBs\n\n         */\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n}\n", "idx": 33}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)\n\n{\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n\n\n    /* MSR:POW cannot be set by any form of rfi */\n\n    msr &= ~(1ULL << MSR_POW);\n\n\n\n#if defined(TARGET_PPC64)\n\n    /* Switching to 32-bit ? Crop the nip */\n\n    if (!msr_is_64bit(env, msr)) {\n\n        nip = (uint32_t)nip;\n\n    }\n\n#else\n\n    nip = (uint32_t)nip;\n\n#endif\n\n    /* XXX: beware: this is false if VLE is supported */\n\n    env->nip = nip & ~((target_ulong)0x00000003);\n\n    hreg_store_msr(env, msr, 1);\n\n#if defined(DEBUG_OP)\n\n    cpu_dump_rfi(env->nip, env->msr);\n\n#endif\n\n    /* No need to raise an exception here,\n\n     * as rfi is always the last insn of a TB\n\n     */\n\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n\n\n    /* Context synchronizing: check if TCG TLB needs flush */\n\n    check_tlb_flush(env);\n\n}\n", "idx": 34}
{"project": "FFmpeg", "commit_id": "f6d49a0dc84aade2adf150c25afb66cbda1d5528", "target": 1, "func": "static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)\n\n{\n\n    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;\n\n\n\n    if (device_hwctx->device)\n\n        ID3D11Device_Release(device_hwctx->device);\n\n\n\n    if (device_hwctx->device_context)\n\n        ID3D11DeviceContext_Release(device_hwctx->device_context);\n\n\n\n    if (device_hwctx->video_device)\n\n        ID3D11VideoDevice_Release(device_hwctx->video_device);\n\n\n\n    if (device_hwctx->video_context)\n\n        ID3D11VideoContext_Release(device_hwctx->video_context);\n\n\n\n    if (device_hwctx->lock == d3d11va_default_lock)\n\n        CloseHandle(device_hwctx->lock_ctx);\n\n}\n", "idx": 36}
{"project": "FFmpeg", "commit_id": "839d6bc192f7ef94343872ff039799501af38855", "target": 1, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        codec->channels    = avio_rl16(pb);\n\n        codec->sample_rate = avio_rl32(pb);\n\n        bitrate            = avio_rl32(pb) * 8;\n\n        codec->block_align = avio_rl16(pb);\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 37}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static void test_acpi_asl(test_data *data)\n\n{\n\n    int i;\n\n    AcpiSdtTable *sdt, *exp_sdt;\n\n    test_data exp_data;\n\n    gboolean exp_err, err;\n\n\n\n    memset(&exp_data, 0, sizeof(exp_data));\n\n    exp_data.tables = load_expected_aml(data);\n\n    dump_aml_files(data, false);\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        GString *asl, *exp_asl;\n\n\n\n        sdt = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        exp_sdt = &g_array_index(exp_data.tables, AcpiSdtTable, i);\n\n\n\n        err = load_asl(data->tables, sdt);\n\n        asl = normalize_asl(sdt->asl);\n\n\n\n        exp_err = load_asl(exp_data.tables, exp_sdt);\n\n        exp_asl = normalize_asl(exp_sdt->asl);\n\n\n\n        /* TODO: check for warnings */\n\n        g_assert(!err || exp_err);\n\n\n\n        if (g_strcmp0(asl->str, exp_asl->str)) {\n\n            uint32_t signature = cpu_to_le32(exp_sdt->header.signature);\n\n            sdt->tmp_files_retain = true;\n\n            exp_sdt->tmp_files_retain = true;\n\n            fprintf(stderr,\n\n                    \"acpi-test: Warning! %.4s mismatch. \"\n\n                    \"Actual [asl:%s, aml:%s], Expected [asl:%s, aml:%s].\\n\",\n\n                    (gchar *)&signature,\n\n                    sdt->asl_file, sdt->aml_file,\n\n                    exp_sdt->asl_file, exp_sdt->aml_file);\n\n        }\n\n        g_string_free(asl, true);\n\n        g_string_free(exp_asl, true);\n\n    }\n\n\n\n    free_test_data(&exp_data);\n\n}\n", "idx": 38}
{"project": "FFmpeg", "commit_id": "87b017a298c12b9a2451276649f3932358b943fc", "target": 1, "func": "static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,\n\n                                int size, int type,\n\n                                uint32_t **lace_buf, int *laces)\n\n{\n\n    int res = 0, n;\n\n    uint8_t *data = *buf;\n\n    uint32_t *lace_size;\n\n\n\n    if (!type) {\n\n        *laces = 1;\n\n        *lace_buf = av_mallocz(sizeof(int));\n\n        if (!*lace_buf)\n\n            return AVERROR(ENOMEM);\n\n\n\n        *lace_buf[0] = size;\n\n        return 0;\n\n    }\n\n\n\n    assert(size > 0);\n\n    *laces = *data + 1;\n\n    data += 1;\n\n    size -= 1;\n\n    lace_size = av_mallocz(*laces * sizeof(int));\n\n    if (!lace_size)\n\n        return AVERROR(ENOMEM);\n\n\n\n    switch (type) {\n\n    case 0x1: /* Xiph lacing */ {\n\n        uint8_t temp;\n\n        uint32_t total = 0;\n\n        for (n = 0; res == 0 && n < *laces - 1; n++) {\n\n            while (1) {\n\n                if (size == 0) {\n\n                    res = AVERROR_EOF;\n\n                    break;\n\n                }\n\n                temp = *data;\n\n                lace_size[n] += temp;\n\n                data += 1;\n\n                size -= 1;\n\n                if (temp != 0xff)\n\n                    break;\n\n            }\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        lace_size[n] = size - total;\n\n        break;\n\n    }\n\n\n\n    case 0x2: /* fixed-size lacing */\n\n        if (size != (size / *laces) * size) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        for (n = 0; n < *laces; n++)\n\n            lace_size[n] = size / *laces;\n\n        break;\n\n\n\n    case 0x3: /* EBML lacing */ {\n\n        uint64_t num;\n\n        uint32_t total;\n\n        n = matroska_ebmlnum_uint(matroska, data, size, &num);\n\n        if (n < 0) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"EBML block data error\\n\");\n\n            res = n;\n\n            break;\n\n        }\n\n        data += n;\n\n        size -= n;\n\n        total = lace_size[0] = num;\n\n        for (n = 1; res == 0 && n < *laces - 1; n++) {\n\n            int64_t snum;\n\n            int r;\n\n            r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n\n            if (r < 0) {\n\n                av_log(matroska->ctx, AV_LOG_INFO,\n\n                       \"EBML block data error\\n\");\n\n                res = r;\n\n                break;\n\n            }\n\n            data += r;\n\n            size -= r;\n\n            lace_size[n] = lace_size[n - 1] + snum;\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        lace_size[*laces - 1] = size - total;\n\n        break;\n\n    }\n\n    }\n\n\n\n    *buf      = data;\n\n    *lace_buf = lace_size;\n\n\n\n    return res;\n\n}\n", "idx": 39}
{"project": "FFmpeg", "commit_id": "d150a147dac67faeaf6b1f25a523ae330168ee1e", "target": 0, "func": "static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    /* skip 3 unknown bytes: Object ID (2 bytes), Version Number */\n\n    buf += 3;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "idx": 40}
{"project": "qemu", "commit_id": "456d97d364e34adc4e68cbd51c2ad6ecd548492d", "target": 1, "func": "void hmp_info_io_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_ioapic_dump_state(mon, qdict);\n\n    } else {\n\n        ioapic_dump_state(mon, qdict);\n\n    }\n\n}\n", "idx": 41}
{"project": "FFmpeg", "commit_id": "5e706a2afb09009bad49c4b12aaa997acf4491b1", "target": 1, "func": "static av_cold int split_init(AVFilterContext *ctx)\n\n{\n\n    SplitContext *s = ctx->priv;\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_outputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"output%d\", i);\n\n        pad.type = ctx->filter->inputs[0].type;\n\n        pad.name = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ff_insert_outpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 42}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; /* clear head */\n\n    /* put signature */\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n", "idx": 44}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n", "idx": 45}
{"project": "qemu", "commit_id": "d9b789745b88df367674e45c55df29e9c7de8d8a", "target": 0, "func": "static int find_allocation(BlockDriverState *bs, off_t start,\n\n                           off_t *data, off_t *hole)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    off_t offs;\n\n\n\n    if (!s->supports_seek_data) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /*\n\n     * SEEK_DATA cases:\n\n     * D1. offs == start: start is in data\n\n     * D2. offs > start: start is in a hole, next data at offs\n\n     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole\n\n     *                              or start is beyond EOF\n\n     *     If the latter happens, the file has been truncated behind\n\n     *     our back since we opened it.  All bets are off then.\n\n     *     Treating like a trailing hole is simplest.\n\n     * D4. offs < 0, errno != ENXIO: we learned nothing\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_DATA);\n\n    if (offs < 0) {\n\n        return -errno;          /* D3 or D4 */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /* D2: in hole, next data at offs */\n\n        *hole = start;\n\n        *data = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1: in data, end not yet known */\n\n\n\n    /*\n\n     * SEEK_HOLE cases:\n\n     * H1. offs == start: start is in a hole\n\n     *     If this happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H2. offs > start: either start is in data, next hole at offs,\n\n     *                   or start is in trailing hole, EOF at offs\n\n     *     Linux treats trailing holes like any other hole: offs ==\n\n     *     start.  Solaris seeks to EOF instead: offs > start (blech).\n\n     *     If that happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H3. offs < 0, errno = ENXIO: start is beyond EOF\n\n     *     If this happens, the file has been truncated behind our\n\n     *     back since we opened it.  Treat it like a trailing hole.\n\n     * H4. offs < 0, errno != ENXIO: we learned nothing\n\n     *     Pretend we know nothing at all, i.e. \"forget\" about D1.\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_HOLE);\n\n    if (offs < 0) {\n\n        return -errno;          /* D1 and (H3 or H4) */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /*\n\n         * D1 and H2: either in data, next hole at offs, or it was in\n\n         * data but is now in a trailing hole.  In the latter case,\n\n         * all bets are off.  Treating it as if it there was data all\n\n         * the way to EOF is safe, so simply do that.\n\n         */\n\n        *data = start;\n\n        *hole = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1 and H1 */\n\n    return -EBUSY;\n\n}\n", "idx": 46}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 47}
{"project": "qemu", "commit_id": "4774718e5c194026ba5ee7a28d9be49be3080e42", "target": 0, "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n", "idx": 48}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n", "idx": 49}
{"project": "qemu", "commit_id": "08b277ac46da8b02e50cec455eca7cb2d12ffcf0", "target": 0, "func": "static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n", "idx": 50}
{"project": "qemu", "commit_id": "b097cc52fc9126bd1a71dae8302b8536d28104dd", "target": 0, "func": "void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n", "idx": 52}
{"project": "qemu", "commit_id": "86a6a9bf551ffa183880480b37c5836d3916687a", "target": 0, "func": "uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    /* test_bit_size is always a multiple of XC_PAGE_SIZE */\n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    /* size is always a multiple of MCACHE_BUCKET_SIZE */\n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}\n", "idx": 53}
{"project": "qemu", "commit_id": "38931fa8cfb074a08ce65fd1982bd4a5bef9d6fb", "target": 0, "func": "static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n", "idx": 54}
{"project": "qemu", "commit_id": "8b34a9dbc3f2c0afe3450cb20b94cc30f450e77b", "target": 0, "func": "static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        /* fallthrough */\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n", "idx": 55}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n", "idx": 56}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n", "idx": 57}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n", "idx": 58}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n", "idx": 59}
{"project": "FFmpeg", "commit_id": "595cf1a1aa09f6214eed57bd9eb6493456918efe", "target": 0, "func": "static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size / 32, *data_size / 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        /* finally output decoded frame */\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n", "idx": 61}
{"project": "qemu", "commit_id": "5858dd1801883309bdd208d72ddb81c4e9fee30c", "target": 0, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "idx": 63}
{"project": "qemu", "commit_id": "88ddffae8fc1e30cc907c2dbb989b7eba9e62319", "target": 0, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 int flags, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (offset > end_offset || ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n            s->image_backing_format = g_strdup(bs->backing_format);\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {\n\n            unsigned int cflags = 0;\n\n            if (s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n                error_setg(errp, \"CRYPTO header extension only \"\n\n                           \"expected with LUKS encryption method\");\n\n                return -EINVAL;\n\n            }\n\n            if (ext.len != sizeof(Qcow2CryptoHeaderExtension)) {\n\n                error_setg(errp, \"CRYPTO header extension size %u, \"\n\n                           \"but expected size %zu\", ext.len,\n\n                           sizeof(Qcow2CryptoHeaderExtension));\n\n                return -EINVAL;\n\n            }\n\n\n\n            ret = bdrv_pread(bs->file, offset, &s->crypto_header, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret,\n\n                                 \"Unable to read CRYPTO header extension\");\n\n                return ret;\n\n            }\n\n            be64_to_cpus(&s->crypto_header.offset);\n\n            be64_to_cpus(&s->crypto_header.length);\n\n\n\n            if ((s->crypto_header.offset % s->cluster_size) != 0) {\n\n                error_setg(errp, \"Encryption header offset '%\" PRIu64 \"' is \"\n\n                           \"not a multiple of cluster size '%u'\",\n\n                           s->crypto_header.offset, s->cluster_size);\n\n                return -EINVAL;\n\n            }\n\n\n\n            if (flags & BDRV_O_NO_IO) {\n\n                cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;\n\n            }\n\n            s->crypto = qcrypto_block_open(s->crypto_opts, \"encrypt.\",\n\n                                           qcow2_crypto_hdr_read_func,\n\n                                           bs, cflags, errp);\n\n            if (!s->crypto) {\n\n                return -EINVAL;\n\n            }\n\n        }   break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 64}
{"project": "qemu", "commit_id": "856d72454f03aea26fd61c728762ef9cd1d71512", "target": 0, "func": "static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n", "idx": 65}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* set blocked signals */\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    /* restore registers */\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 66}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_cmpi(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        /* The COMPARE IMMEDIATE instruction is available.  */\n\n        if (type == TCG_TYPE_I32) {\n\n            /* We have a 32-bit immediate and can compare against anything.  */\n\n            return 1;\n\n        } else {\n\n            /* ??? We have no insight here into whether the comparison is\n\n               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n               a 32-bit unsigned immediate.  If we were to use the (semi)\n\n               obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n               comparisons vs very large numbers.  The only solution is to\n\n               take the intersection of the ranges.  */\n\n            /* ??? Another possible solution is to simply lie and allow all\n\n               constants here and force the out-of-range values into a temp\n\n               register in tgen_cmp when we have knowledge of the actual\n\n               comparison code in use.  */\n\n            return val >= 0 && val <= 0x7fffffff;\n\n        }\n\n    } else {\n\n        /* Only the LOAD AND TEST instruction is available.  */\n\n        return val == 0;\n\n    }\n\n}\n", "idx": 67}
{"project": "qemu", "commit_id": "46f70ff148ae01e2dc96e64c393e295a0092555d", "target": 0, "func": "static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n", "idx": 68}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 69}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y, *src[4];\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkx, cblky, cblkno=0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        int i, j;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        /* Manage band offsets */\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        ff_dwt_decode(&comp->dwt, comp->data);\n\n        src[compno] = comp->data;\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * s->ncomponents + compno;\n\n\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {\n\n                    int val = *src[compno]++ << (8 - s->cbps[compno]);\n\n                    val += 1 << 7;\n\n                    val = av_clip(val, 0, (1 << 8) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = (uint16_t *)(line + (x * s->ncomponents + compno) * 2);\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s-> cdx[compno]) {\n\n                    int32_t val;\n\n\n\n                    val = *src[compno]++ << (16 - s->cbps[compno]);\n\n                    val += 1 << 15;\n\n                    val = av_clip(val, 0, (1 << 16) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 72}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n", "idx": 73}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 74}
{"project": "qemu", "commit_id": "9121d02cb33c96b444a3973579f5edc119597e81", "target": 0, "func": "static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n", "idx": 76}
{"project": "qemu", "commit_id": "fe3c546c5ff2a6210f9a4d8561cc64051ca8603e", "target": 1, "func": "static int rndis_set_response(USBNetState *s,\n\n                rndis_set_msg_type *buf, unsigned int length)\n\n{\n\n    rndis_set_cmplt_type *resp =\n\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n\n    uint32_t bufoffs, buflen;\n\n    int ret;\n\n\n\n    if (!resp)\n\n        return USB_RET_STALL;\n\n\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n\n    if (bufoffs + buflen > length)\n\n        return USB_RET_STALL;\n\n\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n\n                    bufoffs + (uint8_t *) buf, buflen);\n\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n\n    if (ret < 0) {\n\n        /* OID not supported */\n\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\n        return 0;\n\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\n\n    return 0;\n\n}\n", "idx": 77}
{"project": "FFmpeg", "commit_id": "f73f76fd202b310e8e1d0215b2e0cf038cd18c4a", "target": 1, "func": "SwsContext *sws_alloc_context(void)\n\n{\n\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n\n\n    c->av_class = &sws_context_class;\n\n    av_opt_set_defaults(c);\n\n\n\n    return c;\n\n}\n", "idx": 78}
{"project": "qemu", "commit_id": "0d9acba8fddbf970c7353083e6a60b47017ce3e4", "target": 1, "func": "static i2c_interface *musicpal_audio_init(qemu_irq irq)\n\n{\n\n    AudioState *audio;\n\n    musicpal_audio_state *s;\n\n    i2c_interface *i2c;\n\n    int iomemtype;\n\n\n\n    audio = AUD_init();\n\n    if (!audio) {\n\n        AUD_log(audio_name, \"No audio state\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(musicpal_audio_state));\n\n    s->irq = irq;\n\n\n\n    i2c = qemu_mallocz(sizeof(i2c_interface));\n\n    i2c->bus = i2c_init_bus();\n\n    i2c->current_addr = -1;\n\n\n\n    s->wm = wm8750_init(i2c->bus, audio);\n\n    if (!s->wm)\n\n        return NULL;\n\n    i2c_set_slave_address(s->wm, MP_WM_ADDR);\n\n    wm8750_data_req_set(s->wm, audio_callback, s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,\n\n                       musicpal_audio_writefn, s);\n\n    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);\n\n\n\n    qemu_register_reset(musicpal_audio_reset, s);\n\n\n\n    return i2c;\n\n}\n", "idx": 79}
{"project": "qemu", "commit_id": "2bd3bce8efebe86b031beab5c0e3b9bbaec0b502", "target": 1, "func": "void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n", "idx": 80}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n\n                     uint64_t max_mem)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 81}
{"project": "qemu", "commit_id": "a005b3ef50439b5bc6b2eb0b5bda8e8c7c2368bf", "target": 1, "func": "int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)\n\n{\n\n    int i, first = -1;\n\n    ICSState *ics = &icp->ics[src];\n\n\n\n    assert(src == 0);\n\n    /*\n\n     * MSIMesage::data is used for storing VIRQ so\n\n     * it has to be aligned to num to support multiple\n\n     * MSI vectors. MSI-X is not affected by this.\n\n     * The hint is used for the first IRQ, the rest should\n\n     * be allocated continuously.\n\n     */\n\n    if (align) {\n\n        assert((num == 1) || (num == 2) || (num == 4) ||\n\n               (num == 8) || (num == 16) || (num == 32));\n\n        first = ics_find_free_block(ics, num, num);\n\n    } else {\n\n        first = ics_find_free_block(ics, num, 1);\n\n    }\n\n\n\n    if (first >= 0) {\n\n        for (i = first; i < first + num; ++i) {\n\n            ics_set_irq_type(ics, i, lsi);\n\n        }\n\n    }\n\n    first += ics->offset;\n\n\n\n    trace_xics_alloc_block(src, first, num, lsi, align);\n\n\n\n    return first;\n\n}\n", "idx": 82}
{"project": "qemu", "commit_id": "976620ac4018db142d82cd42bb7774f40290ce7e", "target": 1, "func": "void object_property_get_uint16List(Object *obj, const char *name,\n\n                                    uint16List **list, Error **errp)\n\n{\n\n    StringOutputVisitor *ov;\n\n    StringInputVisitor *iv;\n\n\n\n    ov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(ov),\n\n                        name, errp);\n\n    iv = string_input_visitor_new(string_output_get_string(ov));\n\n    visit_type_uint16List(string_input_get_visitor(iv),\n\n                          list, NULL, errp);\n\n    string_output_visitor_cleanup(ov);\n\n    string_input_visitor_cleanup(iv);\n\n}\n", "idx": 85}
{"project": "qemu", "commit_id": "1e37d05904e300a0bfc8e3240e24ecc83d54c2e3", "target": 1, "func": "static int raw_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int64_t total_size = 0;\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n / 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\n              0644);\n\n    if (fd < 0)\n\n        return -EIO;\n\n    ftruncate(fd, total_size * 512);\n\n    close(fd);\n\n    return 0;\n\n}\n", "idx": 86}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    assert(src1==src2);\n\n    for (i=0; i<width; i++) {\n\n        int r= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n}\n", "idx": 87}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    QLIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 89}
{"project": "FFmpeg", "commit_id": "967d2ae616a1fc6ffc2c00810e09c232dfdb7911", "target": 1, "func": "void ff_xvmc_init_block(MpegEncContext *s)\n\n{\n\n    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];\n\n    assert(render);\n\n    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {\n\n        assert(0);\n\n        return; // make sure that this is a render packet\n\n    }\n\n    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);\n\n}\n", "idx": 90}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 91}
{"project": "qemu", "commit_id": "8f2ad0a3fc5e3569183d44bf1c7fcb95294be4c0", "target": 1, "func": "static uint32_t ecc_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = 0;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        ret = s->regs[0];\n\n        DPRINTF(\"Read memory enable %08x\\n\", ret);\n\n        break;\n\n    case ECC_MDR:\n\n        ret = s->regs[1];\n\n        DPRINTF(\"Read memory delay %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFSR:\n\n        ret = s->regs[2];\n\n        DPRINTF(\"Read memory fault status %08x\\n\", ret);\n\n        break;\n\n    case ECC_VCR:\n\n        ret = s->regs[3];\n\n        DPRINTF(\"Read slot configuration %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR0:\n\n        ret = s->regs[4];\n\n        DPRINTF(\"Read memory fault address 0 %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR1:\n\n        ret = s->regs[5];\n\n        DPRINTF(\"Read memory fault address 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_DR:\n\n        ret = s->regs[6];\n\n        DPRINTF(\"Read diagnostic %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR0:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR1:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 2 %08x\\n\", ret);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 92}
{"project": "FFmpeg", "commit_id": "01923bab98506b1e98b4cbf08419364ce6ffea6d", "target": 1, "func": "int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,\n                             int *got_sub_ptr,\n                             AVPacket *avpkt)\n{\n    int i, ret = 0;\n    if (!avpkt->data && avpkt->size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid packet: NULL data, size != 0\\n\");\n        return AVERROR(EINVAL);\n    if (!avctx->codec)\n        return AVERROR(EINVAL);\n    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid media type for subtitles\\n\");\n        return AVERROR(EINVAL);\n    *got_sub_ptr = 0;\n    avcodec_get_subtitle_defaults(sub);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size) {\n        AVPacket pkt_recoded;\n        AVPacket tmp = *avpkt;\n        int did_split = av_packet_split_side_data(&tmp);\n        //apply_param_change(avctx, &tmp);\n        pkt_recoded = tmp;\n        ret = recode_subtitle(avctx, &pkt_recoded, &tmp);\n        if (ret < 0) {\n            *got_sub_ptr = 0;\n        } else {\n            avctx->internal->pkt = &pkt_recoded;\n            if (avctx->pkt_timebase.den && avpkt->pts != AV_NOPTS_VALUE)\n                sub->pts = av_rescale_q(avpkt->pts,\n                                        avctx->pkt_timebase, AV_TIME_BASE_Q);\n            ret = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);\n            av_assert1((ret >= 0) >= !!*got_sub_ptr &&\n                       !!*got_sub_ptr >= !!sub->num_rects);\n            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&\n                avctx->pkt_timebase.num) {\n                AVRational ms = { 1, 1000 };\n                sub->end_display_time = av_rescale_q(avpkt->duration,\n                                                     avctx->pkt_timebase, ms);\n            for (i = 0; i < sub->num_rects; i++) {\n                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Invalid UTF-8 in decoded subtitles text; \"\n                           \"maybe missing -sub_charenc option\\n\");\n                    avsubtitle_free(sub);\n                    return AVERROR_INVALIDDATA;\n            if (tmp.data != pkt_recoded.data) { // did we recode?\n                /* prevent from destroying side data from original packet */\n                pkt_recoded.side_data = NULL;\n                pkt_recoded.side_data_elems = 0;\n                av_free_packet(&pkt_recoded);\n            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)\n                sub->format = 0;\n            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)\n                sub->format = 1;\n            avctx->internal->pkt = NULL;\n            av_packet_free_side_data(&tmp);\n            if(ret == tmp.size)\n                ret = avpkt->size;\n        if (*got_sub_ptr)\n            avctx->frame_number++;\n    return ret;", "idx": 93}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mp_decode_frame(MPADecodeContext *s, \n\n                           short *samples)\n\n{\n\n    int i, nb_frames, ch;\n\n    short *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, \n\n                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n\n    \n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        get_bits(&s->gb, 16);\n\n\n\n    dprintf(\"frame %d:\\n\", s->frame_count);\n\n    switch(s->layer) {\n\n    case 1:\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n        break;\n\n    }\n\n#if defined(DEBUG)\n\n    for(i=0;i<nb_frames;i++) {\n\n        for(ch=0;ch<s->nb_channels;ch++) {\n\n            int j;\n\n            printf(\"%d-%d:\", i, ch);\n\n            for(j=0;j<SBLIMIT;j++)\n\n                printf(\" %0.6f\", (double)s->sb_samples[ch][i][j] / FRAC_ONE);\n\n            printf(\"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    /* apply the synthesis filter */\n\n    for(ch=0;ch<s->nb_channels;ch++) {\n\n        samples_ptr = samples + ch;\n\n        for(i=0;i<nb_frames;i++) {\n\n            synth_filter(s, ch, samples_ptr, s->nb_channels,\n\n                         s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * s->nb_channels;\n\n        }\n\n    }\n\n#ifdef DEBUG\n\n    s->frame_count++;        \n\n#endif\n\n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n\n}\n", "idx": 94}
{"project": "FFmpeg", "commit_id": "469f5f251dc3acbb4c4fd12c597d57768119af4a", "target": 0, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            const uint8_t *buf, int buf_size)\n\n{\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n;\n\n    short *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    uint8_t *dstu8;\n\n    int16_t *dst_int16_t;\n\n    int32_t *dst_int32_t;\n\n    int64_t *dst_int64_t;\n\n    uint16_t *dst_uint16_t;\n\n    uint32_t *dst_uint32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n    *data_size=0;\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          *samples++ = ff_reverse[(v >> 8) & 0xff] +\n\n                       (ff_reverse[v & 0xff] << 8);\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++)\n\n                *samples++ = bytestream_get_le16(&src2[c]);\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        dstu8= (uint8_t*)samples;\n\n        for(;n>0;n--) {\n\n            *dstu8++ = *src++ + 128;\n\n        }\n\n        samples= (short*)dstu8;\n\n        break;\n\n#if WORDS_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* WORDS_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples = (short*)((uint8_t*)data + n*sample_size);\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            *samples++ = x << 8;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            *samples++ = s->table[*src++];\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n            break;\n\n        }\n\n        samples = (short *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 95}
{"project": "FFmpeg", "commit_id": "269fc8e04906ffd965aa19425ca90980b23c6508", "target": 0, "func": "static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 96}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    /* virtio-1 compliant devices cannot change the alignment */\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    /* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     */\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n", "idx": 97}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuvPlanartouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                           long width, long height,\n\n                                           long lumStride, long chromStride, long dstStride, long vertLumPerChroma)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y++) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        //FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)\n\n        __asm__ volatile(\n\n            \"xor                %%\"REG_a\", %%\"REG_a\"    \\n\\t\"\n\n            \".p2align                   4               \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\"   32(%1, %%\"REG_a\", 2)            \\n\\t\"\n\n            PREFETCH\"   32(%2, %%\"REG_a\")               \\n\\t\"\n\n            PREFETCH\"   32(%3, %%\"REG_a\")               \\n\\t\"\n\n            \"movq         (%2, %%\"REG_a\"), %%mm0        \\n\\t\" // U(0)\n\n            \"movq                   %%mm0, %%mm2        \\n\\t\" // U(0)\n\n            \"movq         (%3, %%\"REG_a\"), %%mm1        \\n\\t\" // V(0)\n\n            \"punpcklbw              %%mm1, %%mm0        \\n\\t\" // UVUV UVUV(0)\n\n            \"punpckhbw              %%mm1, %%mm2        \\n\\t\" // UVUV UVUV(8)\n\n\n\n            \"movq       (%1, %%\"REG_a\",2), %%mm3        \\n\\t\" // Y(0)\n\n            \"movq      8(%1, %%\"REG_a\",2), %%mm5        \\n\\t\" // Y(8)\n\n            \"movq                   %%mm0, %%mm4        \\n\\t\" // Y(0)\n\n            \"movq                   %%mm2, %%mm6        \\n\\t\" // Y(8)\n\n            \"punpcklbw              %%mm3, %%mm0        \\n\\t\" // YUYV YUYV(0)\n\n            \"punpckhbw              %%mm3, %%mm4        \\n\\t\" // YUYV YUYV(4)\n\n            \"punpcklbw              %%mm5, %%mm2        \\n\\t\" // YUYV YUYV(8)\n\n            \"punpckhbw              %%mm5, %%mm6        \\n\\t\" // YUYV YUYV(12)\n\n\n\n            MOVNTQ\"                 %%mm0,   (%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm4,  8(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm2, 16(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm6, 24(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n\n\n            \"add                       $8, %%\"REG_a\"    \\n\\t\"\n\n            \"cmp                       %4, %%\"REG_a\"    \\n\\t\"\n\n            \" jb                       1b               \\n\\t\"\n\n            ::\"r\"(dst), \"r\"(ysrc), \"r\"(usrc), \"r\"(vsrc), \"g\" (chromWidth)\n\n            : \"%\"REG_a\n\n        );\n\n#else\n\n//FIXME adapt the Alpha ASM code from yv12->yuy2\n\n\n\n#if HAVE_FAST_64BIT\n\n        int i;\n\n        uint64_t *ldst = (uint64_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i += 2) {\n\n            uint64_t k, l;\n\n            k = uc[0] + (yc[0] << 8) +\n\n                (vc[0] << 16) + (yc[1] << 24);\n\n            l = uc[1] + (yc[2] << 8) +\n\n                (vc[1] << 16) + (yc[3] << 24);\n\n            *ldst++ = k + (l << 32);\n\n            yc += 4;\n\n            uc += 2;\n\n            vc += 2;\n\n        }\n\n\n\n#else\n\n        int i, *idst = (int32_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i++) {\n\n#if HAVE_BIGENDIAN\n\n            *idst++ = (uc[0] << 24)+ (yc[0] << 16) +\n\n                (vc[0] << 8) + (yc[1] << 0);\n\n#else\n\n            *idst++ = uc[0] + (yc[0] << 8) +\n\n               (vc[0] << 16) + (yc[1] << 24);\n\n#endif\n\n            yc += 2;\n\n            uc++;\n\n            vc++;\n\n        }\n\n#endif\n\n#endif\n\n        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {\n\n            usrc += chromStride;\n\n            vsrc += chromStride;\n\n        }\n\n        ysrc += lumStride;\n\n        dst += dstStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            :::\"memory\");\n\n#endif\n\n}\n", "idx": 98}
{"project": "qemu", "commit_id": "91bfcdb01d4869aa8f4cb67007827de63b8c2217", "target": 0, "func": "int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif /* QCRYPTO_INIT_GCRYPT_THREADS */\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 99}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 100}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n", "idx": 101}
{"project": "qemu", "commit_id": "7df953bd456da45f761064974820ab5c3fd7b2aa", "target": 0, "func": "static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    IntelIOMMUState *s = opaque;\n\n    VTDAddressSpace **pvtd_as;\n\n    int bus_num = pci_bus_num(bus);\n\n\n\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n\n\n\n    pvtd_as = s->address_spaces[bus_num];\n\n    if (!pvtd_as) {\n\n        /* No corresponding free() */\n\n        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);\n\n        s->address_spaces[bus_num] = pvtd_as;\n\n    }\n\n    if (!pvtd_as[devfn]) {\n\n        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));\n\n\n\n        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;\n\n        pvtd_as[devfn]->devfn = (uint8_t)devfn;\n\n        pvtd_as[devfn]->iommu_state = s;\n\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;\n\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),\n\n                                 &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n\n        address_space_init(&pvtd_as[devfn]->as,\n\n                           &pvtd_as[devfn]->iommu, \"intel_iommu\");\n\n    }\n\n    return &pvtd_as[devfn]->as;\n\n}\n", "idx": 102}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n", "idx": 103}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_pr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"move $p%u, $r%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tif (dc->op2 == PR_CCS)\n\n\t\tcris_evaluate_flags(dc);\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(t0, dc->op2);\n\n\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 104}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_balloon_init_pci;\n\n    k->exit = virtio_balloon_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_MEMORY_RAM;\n\n    dc->alias = \"virtio-balloon\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_balloon_properties;\n\n}\n", "idx": 105}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static int fetch_active_ports_list(QEMUFile *f,\n\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n\n{\n\n    uint32_t i;\n\n\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n\n    s->post_load->nr_active_ports = nr_active_ports;\n\n    s->post_load->connected =\n\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                            virtio_serial_post_load_timer_cb,\n\n                                            s);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        VirtIOSerialPort *port;\n\n        uint32_t elem_popped;\n\n        uint32_t id;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        s->post_load->connected[i].port = port;\n\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n\n\n        qemu_get_be32s(f, &elem_popped);\n\n        if (elem_popped) {\n\n            qemu_get_be32s(f, &port->iov_idx);\n\n            qemu_get_be64s(f, &port->iov_offset);\n\n\n\n            port->elem =\n\n                qemu_get_virtqueue_element(f, sizeof(VirtQueueElement));\n\n\n\n            /*\n\n             *  Port was throttled on source machine.  Let's\n\n             *  unthrottle it here so data starts flowing again.\n\n             */\n\n            virtio_serial_throttle_port(port, false);\n\n        }\n\n    }\n\n    timer_mod(s->post_load->timer, 1);\n\n    return 0;\n\n}\n", "idx": 106}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c, CPUUniCore32State *env)\n\n{\n\n    int flag;\n\n    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);\n\n    env->CF = 0;\n\n    switch (c & 0x7) {\n\n    case 0: /* F */\n\n        break;\n\n    case 1: /* UN */\n\n        if (flag == 2) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 2: /* EQ */\n\n        if (flag == 0) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 3: /* UEQ */\n\n        if ((flag == 0) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 4: /* OLT */\n\n        if (flag == -1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 5: /* ULT */\n\n        if ((flag == -1) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 6: /* OLE */\n\n        if ((flag == -1) || (flag == 0)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 7: /* ULE */\n\n        if (flag != 1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    }\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)\n\n                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);\n\n}\n", "idx": 107}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,\n\n                                  const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                  const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                  const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                  const uint16_t *abuf1, uint8_t *dest,\n\n                                  int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov %4, %%\"REG_b\"                        \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2PACKED(%%REGBP, %5)\n\n        WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither)\n\n    );\n\n}\n", "idx": 109}
{"project": "qemu", "commit_id": "b456a71c4a1eb5704d135fd08da9a0de8fd81231", "target": 0, "func": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    bool start = req->cmd.buf[4] & 1;\n\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n\n        if (!start && !s->tray_open && s->tray_locked) {\n\n            scsi_check_condition(r,\n\n                                 bdrv_is_inserted(s->qdev.conf.bs)\n\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n\n            return -1;\n\n        }\n\n\n\n        if (s->tray_open != !start) {\n\n            bdrv_eject(s->qdev.conf.bs, !start);\n\n            s->tray_open = !start;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 110}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void ecc_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %04x\\n\",\n\n           addr, val & 0xffff);\n\n}\n", "idx": 111}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info)\n\n{\n\n    int handle = 0;\n\n    int n;\n\n\n\n    if (arch_info->exception == 1) {\n\n        if (arch_info->dr6 & (1 << 14)) {\n\n            if (cpu_single_env->singlestep_enabled)\n\n                handle = 1;\n\n        } else {\n\n            for (n = 0; n < 4; n++)\n\n                if (arch_info->dr6 & (1 << n))\n\n                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {\n\n                    case 0x0:\n\n                        handle = 1;\n\n                        break;\n\n                    case 0x1:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_WRITE;\n\n                        break;\n\n                    case 0x3:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_ACCESS;\n\n                        break;\n\n                    }\n\n        }\n\n    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))\n\n        handle = 1;\n\n\n\n    if (!handle) {\n\n        cpu_synchronize_state(cpu_single_env);\n\n        assert(cpu_single_env->exception_injected == -1);\n\n\n\n        cpu_single_env->exception_injected = arch_info->exception;\n\n        cpu_single_env->has_error_code = 0;\n\n    }\n\n\n\n    return handle;\n\n}\n", "idx": 112}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,\n\n                                 Error **errp)\n\n{\n\n    ChardevStdio *stdio;\n\n\n\n    stdio = backend->u.stdio = g_new0(ChardevStdio, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));\n\n    stdio->has_signal = true;\n\n    stdio->signal = qemu_opt_get_bool(opts, \"signal\", true);\n\n}\n", "idx": 113}
{"project": "qemu", "commit_id": "e12f3784097a26a1ba51be420f41038b4c0ae5d1", "target": 0, "func": "static void mirror_complete(BlockJob *job, Error **errp)\n\n{\n\n    MirrorBlockJob *s = container_of(job, MirrorBlockJob, common);\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    ret = bdrv_open_backing_file(s->target, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (!s->synced) {\n\n        error_setg(errp, QERR_BLOCK_JOB_NOT_READY,\n\n                   bdrv_get_device_name(job->bs));\n\n        return;\n\n    }\n\n\n\n    /* check the target bs is not blocked and block all operations on it */\n\n    if (s->replaces) {\n\n        AioContext *replace_aio_context;\n\n\n\n        s->to_replace = check_to_replace_node(s->replaces, &local_err);\n\n        if (!s->to_replace) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n\n\n        replace_aio_context = bdrv_get_aio_context(s->to_replace);\n\n        aio_context_acquire(replace_aio_context);\n\n\n\n        error_setg(&s->replace_blocker,\n\n                   \"block device is in use by block-job-complete\");\n\n        bdrv_op_block_all(s->to_replace, s->replace_blocker);\n\n        bdrv_ref(s->to_replace);\n\n\n\n        aio_context_release(replace_aio_context);\n\n    }\n\n\n\n    s->should_complete = true;\n\n    block_job_enter(&s->common);\n\n}\n", "idx": 114}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n\n\n    scsi_target_alloc_buf(&r->req, SCSI_INQUIRY_LEN);\n\n\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < r->buf_len);\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, SCSI_INQUIRY_LEN);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 115}
{"project": "qemu", "commit_id": "d2889a3efc3851e62de69cb9d88fb784c28e0ed8", "target": 0, "func": "void OPPROTO op_movl_npc_T0(void)\n\n{\n\n    env->npc = T0;\n\n}\n", "idx": 116}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)\n\n{\n\n    TemporalNoiseShaping *tns = &sce->tns;\n\n    int w, g, order, sfb_start, sfb_len, coef_start, shift[MAX_LPC_ORDER], count = 0;\n\n    const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;\n\n    const int tns_max_order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;\n\n    const float freq_mult = mpeg4audio_sample_rates[s->samplerate_index]/(1024.0f/sce->ics.num_windows)/2.0f;\n\n    float max_coef = 0.0f;\n\n\n\n    sce->tns.present = 0;\n\n    return;\n\n\n\n    for (coef_start = 0; coef_start < 1024; coef_start++)\n\n        max_coef = FFMAX(max_coef, sce->pcoeffs[coef_start]);\n\n\n\n    for (w = 0; w < sce->ics.num_windows; w++) {\n\n        int filters = 1, start = 0, coef_len = 0;\n\n        int32_t conv_coeff[1024] = {0};\n\n        int32_t coefs_t[MAX_LPC_ORDER][MAX_LPC_ORDER] = {{0}};\n\n\n\n        /* Determine start sfb + coef - excludes anything below threshold */\n\n        for (g = 0;  g < sce->ics.num_swb; g++) {\n\n            if (start*freq_mult > TNS_LOW_LIMIT) {\n\n                sfb_start = w*16+g;\n\n                sfb_len   = (w+1)*16 + g - sfb_start;\n\n                coef_start = sce->ics.swb_offset[sfb_start];\n\n                coef_len  = sce->ics.swb_offset[sfb_start + sfb_len] - coef_start;\n\n                break;\n\n            }\n\n            start += sce->ics.swb_sizes[g];\n\n        }\n\n\n\n        if (coef_len <= 0)\n\n            continue;\n\n\n\n        conv_to_int32(conv_coeff, &sce->pcoeffs[coef_start], coef_len, max_coef);\n\n\n\n        /* LPC */\n\n        order = ff_lpc_calc_coefs(&s->lpc, conv_coeff, coef_len,\n\n                                  TNS_MIN_PRED_ORDER, tns_max_order,\n\n                                  32, coefs_t, shift,\n\n                                  FF_LPC_TYPE_LEVINSON, 10,\n\n                                  ORDER_METHOD_EST, MAX_LPC_SHIFT, 0) - 1;\n\n\n\n        /* Works surprisingly well, remember to tweak MAX_LPC_SHIFT if you want to play around with this */\n\n        if (shift[order] > 3) {\n\n            int direction = 0;\n\n            float tns_coefs_raw[TNS_MAX_ORDER];\n\n            tns->n_filt[w] = filters++;\n\n            conv_to_float(tns_coefs_raw, coefs_t[order], order);\n\n            for (g = 0; g < tns->n_filt[w]; g++) {\n\n                process_tns_coeffs(tns, tns_coefs_raw, order, w, g);\n\n                apply_tns_filter(&sce->coeffs[coef_start], sce->pcoeffs, order, direction, tns->coef[w][g],\n\n                                 sce->ics.ltp.present, w, g, coef_start, coef_len);\n\n                tns->order[w][g]     = order;\n\n                tns->length[w][g]    = sfb_len;\n\n                tns->direction[w][g] = direction;\n\n            }\n\n            count++;\n\n        }\n\n    }\n\n\n\n    sce->tns.present = !!count;\n\n}\n", "idx": 117}
{"project": "FFmpeg", "commit_id": "fd542b6f2026f1aa163882ee0283958598a97c31", "target": 0, "func": "int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n\n{\n\n    _Bool exp = 0;\n\n    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)\n\n        return 0;\n\n\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n\n\n    if (atomic_fetch_add(&entangled_thread_counter, 1)) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Insufficient thread locking. At least %d threads are \"\n\n               \"calling avcodec_open2() at the same time right now.\\n\",\n\n               atomic_load(&entangled_thread_counter));\n\n        if (!lockmgr_cb)\n\n            av_log(log_ctx, AV_LOG_ERROR, \"No lock manager is set, please see av_lockmgr_register()\\n\");\n\n        atomic_store(&ff_avcodec_locked, 1);\n\n        ff_unlock_avcodec(codec);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_assert0(atomic_compare_exchange_strong(&ff_avcodec_locked, &exp, 1));\n\n    return 0;\n\n}\n", "idx": 118}
{"project": "FFmpeg", "commit_id": "4ea7744859dc3d214ef13e920f5d07b070920e3f", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n\n\n    memset(block, 0, 16 * sizeof(dctcoef));\n\n}\n", "idx": 119}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,\n\n                                         uint64_t flags)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        DDDPRINTF(\"Waiting for next request %\" PRIu64 \"...\\n\", flags);\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            fprintf(stderr, \"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\\n\", head.repeat);\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            DDPRINTF(\"Zapping zero chunk: %\" PRId64\n\n                    \" bytes, index %d, offset %\" PRId64 \"\\n\",\n\n                    comp->length, comp->block_idx, comp->offset);\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n            break;\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            DDDPRINTF(\"Current registrations complete.\\n\");\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            DPRINTF(\"Initial setup info requested.\\n\");\n\n\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    fprintf(stderr, \"rdma migration: error dest \"\n\n                                    \"registering ram blocks!\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->block[i].remote_host_addr =\n\n                    (uint64_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->block[i].remote_rkey = local->block[i].mr->rkey;\n\n                }\n\n\n\n                rdma->block[i].offset = local->block[i].offset;\n\n                rdma->block[i].length = local->block[i].length;\n\n\n\n                remote_block_to_network(&rdma->block[i]);\n\n            }\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMARemoteBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->block, &blocks);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma migration: error sending remote info!\\n\");\n\n                goto out;\n\n            }\n\n\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d registration requests\\n\", head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                DDPRINTF(\"Registration request (%d): index %d, current_addr %\"\n\n                         PRIu64 \" chunks: %\" PRIu64 \"\\n\", count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n                }\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uint8_t *)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    fprintf(stderr, \"cannot get rkey!\\n\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n                }\n\n\n\n                reg_result->host_addr = (uint64_t) block->local_host_addr;\n\n\n\n                DDPRINTF(\"Registered rkey for this request: %x\\n\",\n\n                                reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d unregistration requests\\n\", head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                DDPRINTF(\"Unregistration request (%d): \"\n\n                         \" index %d, chunk %\" PRIu64 \"\\n\",\n\n                         count, reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n                }\n\n\n\n                rdma->total_registrations--;\n\n\n\n                DDPRINTF(\"Unregistered chunk %\" PRIu64 \" successfully.\\n\",\n\n                            reg->key.chunk);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            fprintf(stderr, \"Invalid RESULT message at dest.\\n\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            fprintf(stderr, \"Unknown control message %s\\n\",\n\n                                control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n        }\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 120}
{"project": "FFmpeg", "commit_id": "7ec414892ddcad88313848494b6fc5f437c9ca4a", "target": 1, "func": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n\n{\n\n    struct playlist *v = opaque;\n\n    HLSContext *c = v->parent->priv_data;\n\n    int ret, i;\n\n    int just_opened = 0;\n\n\n\n\nrestart:\n\n    if (!v->needed)\n\n        return AVERROR_EOF;\n\n\n\n    if (!v->input) {\n\n        int64_t reload_interval;\n\n        struct segment *seg;\n\n\n\n        /* Check that the playlist is still needed before opening a new\n\n         * segment. */\n\n        if (v->ctx && v->ctx->nb_streams) {\n\n            v->needed = 0;\n\n            for (i = 0; i < v->n_main_streams; i++) {\n\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n\n                    v->needed = 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (!v->needed) {\n\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n\n                v->index);\n\n            return AVERROR_EOF;\n\n        }\n\n\n\n        /* If this is a live stream and the reload interval has elapsed since\n\n         * the last playlist reload, reload the playlists now. */\n\n        reload_interval = default_reload_interval(v);\n\n\n\nreload:\n\n        reload_count++;\n\n        if (reload_count > c->max_reload)\n\n            return AVERROR_EOF;\n\n        if (!v->finished &&\n\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n\n                       v->index);\n\n                return ret;\n\n            }\n\n            /* If we need to reload the playlist again below (if\n\n             * there's still no more segments), switch to a reload\n\n             * interval of half the target duration. */\n\n            reload_interval = v->target_duration / 2;\n\n        }\n\n        if (v->cur_seq_no < v->start_seq_no) {\n\n            av_log(NULL, AV_LOG_WARNING,\n\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n\n                   v->start_seq_no - v->cur_seq_no);\n\n            v->cur_seq_no = v->start_seq_no;\n\n        }\n\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n\n            if (v->finished)\n\n                return AVERROR_EOF;\n\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n\n                if (ff_check_interrupt(c->interrupt_callback))\n\n                    return AVERROR_EXIT;\n\n                av_usleep(100*1000);\n\n            }\n\n            /* Enough time has elapsed since the last reload */\n\n            goto reload;\n\n        }\n\n\n\n        seg = current_segment(v);\n\n\n\n        /* load/update Media Initialization Section, if any */\n\n        ret = update_init_section(v, seg);\n\n        if (ret)\n\n            return ret;\n\n\n\n        ret = open_input(c, v, seg);\n\n        if (ret < 0) {\n\n            if (ff_check_interrupt(c->interrupt_callback))\n\n                return AVERROR_EXIT;\n\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n\n                   v->index);\n\n            v->cur_seq_no += 1;\n\n            goto reload;\n\n        }\n\n        just_opened = 1;\n\n    }\n\n\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n\n        /* Push init section out first before first actual segment */\n\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n\n        memcpy(buf, v->init_sec_buf, copy_size);\n\n        v->init_sec_buf_read_offset += copy_size;\n\n        return copy_size;\n\n    }\n\n\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n\n    if (ret > 0) {\n\n        if (just_opened && v->is_id3_timestamped != 0) {\n\n            /* Intercept ID3 tags here, elementary audio streams are required\n\n             * to convey timestamps using them in the beginning of each segment. */\n\n            intercept_id3(v, buf, buf_size, &ret);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n    ff_format_io_close(v->parent, &v->input);\n\n    v->cur_seq_no++;\n\n\n\n    c->cur_seq_no = v->cur_seq_no;\n\n\n\n    goto restart;\n\n}", "idx": 123}
{"project": "FFmpeg", "commit_id": "747a0554ea8ad09404c1f5b80239ebd8d71b291e", "target": 1, "func": "static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); /* a, d present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); /* b, c present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n", "idx": 124}
{"project": "FFmpeg", "commit_id": "8bcf5840ea2a6a92c75ab3219f89fe0b8a53cf50", "target": 0, "func": "int ff_nvdec_start_frame(AVCodecContext *avctx, AVFrame *frame)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    FrameDecodeData *fdd = (FrameDecodeData*)frame->private_ref->data;\n\n    NVDECFrame *cf = NULL;\n\n    int ret;\n\n\n\n    ctx->bitstream_len = 0;\n\n    ctx->nb_slices     = 0;\n\n\n\n    if (fdd->hwaccel_priv)\n\n        return 0;\n\n\n\n    cf = av_mallocz(sizeof(*cf));\n\n    if (!cf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);\n\n    if (!cf->decoder_ref)\n\n        goto fail;\n\n\n\n    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);\n\n    if (!cf->idx_ref) {\n\n        av_log(avctx, AV_LOG_ERROR, \"No decoder surfaces left\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    cf->idx = *(unsigned int*)cf->idx_ref->data;\n\n\n\n    fdd->hwaccel_priv      = cf;\n\n    fdd->hwaccel_priv_free = nvdec_fdd_priv_free;\n\n    fdd->post_process      = nvdec_retrieve_data;\n\n\n\n    return 0;\n\nfail:\n\n    nvdec_fdd_priv_free(cf);\n\n    return ret;\n\n\n\n}\n", "idx": 126}
{"project": "FFmpeg", "commit_id": "44e43aab036595a8f6d78c9306864d00f35ebbb1", "target": 0, "func": "static int mov_read_trun(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    MOVFragment *frag = &c->fragment;\n\n    AVStream *st = c->fc->streams[frag->track_id-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    uint64_t offset;\n\n    int64_t dts;\n\n    int data_offset = 0;\n\n    unsigned entries, first_sample_flags = frag->flags;\n\n    int flags, distance, i;\n\n\n\n    if (sc->pseudo_stream_id+1 != frag->stsd_id)\n\n        return 0;\n\n    if (!st->nb_index_entries)\n\n        return -1;\n\n    get_byte(pb); /* version */\n\n    flags = get_be24(pb);\n\n    entries = get_be32(pb);\n\n    dprintf(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    if (flags & 0x001) data_offset        = get_be32(pb);\n\n    if (flags & 0x004) first_sample_flags = get_be32(pb);\n\n    if (flags & 0x800) {\n\n        if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n\n            return -1;\n\n        sc->ctts_data = av_realloc(sc->ctts_data,\n\n                                   (entries+sc->ctts_count)*sizeof(*sc->ctts_data));\n\n        if (!sc->ctts_data)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    dts = st->duration;\n\n    offset = frag->base_data_offset + data_offset;\n\n    distance = 0;\n\n    dprintf(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n\n    for (i = 0; i < entries; i++) {\n\n        unsigned sample_size = frag->size;\n\n        int sample_flags = i ? frag->flags : first_sample_flags;\n\n        unsigned sample_duration = frag->duration;\n\n        int keyframe;\n\n\n\n        if (flags & 0x100) sample_duration = get_be32(pb);\n\n        if (flags & 0x200) sample_size     = get_be32(pb);\n\n        if (flags & 0x400) sample_flags    = get_be32(pb);\n\n        if (flags & 0x800) {\n\n            sc->ctts_data[sc->ctts_count].count = 1;\n\n            sc->ctts_data[sc->ctts_count].duration = get_be32(pb);\n\n            sc->ctts_count++;\n\n        }\n\n        if ((keyframe = st->codec->codec_type == CODEC_TYPE_AUDIO ||\n\n             (flags & 0x004 && !i && !sample_flags) || sample_flags & 0x2000000))\n\n            distance = 0;\n\n        av_add_index_entry(st, offset, dts, sample_size, distance,\n\n                           keyframe ? AVINDEX_KEYFRAME : 0);\n\n        dprintf(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n\n                offset, dts, sample_size, distance, keyframe);\n\n        distance++;\n\n        assert(sample_duration % sc->time_rate == 0);\n\n        dts += sample_duration / sc->time_rate;\n\n        offset += sample_size;\n\n    }\n\n    frag->moof_offset = offset;\n\n    sc->sample_count = st->nb_index_entries;\n\n    st->duration = dts;\n\n    return 0;\n\n}\n", "idx": 128}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void mpv_decode_mb_internal(MpegEncContext *s, int16_t block[12][64],\n\n                            int is_mpeg12)\n\n{\n\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration){\n\n        ff_xvmc_decode_mb(s);//xvmc uses pblocks\n\n        return;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n       /* print DCT coefficients */\n\n       int i,j;\n\n       av_log(s->avctx, AV_LOG_DEBUG, \"DCT coeffs of MB at %dx%d:\\n\", s->mb_x, s->mb_y);\n\n       for(i=0; i<6; i++){\n\n           for(j=0; j<64; j++){\n\n               av_log(s->avctx, AV_LOG_DEBUG, \"%5d\",\n\n                      block[i][s->idsp.idct_permutation[j]]);\n\n           }\n\n           av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n       }\n\n    }\n\n\n\n    s->current_picture.qscale_table[mb_xy] = s->qscale;\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {\n\n            if(s->mbintra_table[mb_xy])\n\n                ff_clean_intra_table_entries(s);\n\n        } else {\n\n            s->last_dc[0] =\n\n            s->last_dc[1] =\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))\n\n        s->mbintra_table[mb_xy]=1;\n\n\n\n    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) ||\n\n        !(s->encoding && (s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&\n\n          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc\n\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n\n        int dct_linesize, dct_offset;\n\n        op_pixels_func (*op_pix)[4];\n\n        qpel_mc_func (*op_qpix)[16];\n\n        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n\n        const int uvlinesize = s->current_picture.f->linesize[1];\n\n        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band;\n\n        const int block_size = 8;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too */\n\n        /* skip only during decoding as we might trash the buffers during encoding a bit */\n\n        if(!s->encoding){\n\n            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];\n\n\n\n            if (s->mb_skipped) {\n\n                s->mb_skipped= 0;\n\n                assert(s->pict_type!=AV_PICTURE_TYPE_I);\n\n                *mbskip_ptr = 1;\n\n            } else if(!s->current_picture.reference) {\n\n                *mbskip_ptr = 1;\n\n            } else{\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dct_linesize = linesize << s->interlaced_dct;\n\n        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;\n\n\n\n        if(readable){\n\n            dest_y=  s->dest[0];\n\n            dest_cb= s->dest[1];\n\n            dest_cr= s->dest[2];\n\n        }else{\n\n            dest_y = s->sc.b_scratchpad;\n\n            dest_cb= s->sc.b_scratchpad+16*linesize;\n\n            dest_cr= s->sc.b_scratchpad+32*linesize;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            /* decoding or more than one mb_type (MC was already done otherwise) */\n\n            if(!s->encoding){\n\n\n\n                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {\n\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n\n                        ff_thread_await_progress(&s->last_picture_ptr->tf,\n\n                                                 lowest_referenced_row(s, 0),\n\n                                                 0);\n\n                    }\n\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                        ff_thread_await_progress(&s->next_picture_ptr->tf,\n\n                                                 lowest_referenced_row(s, 1),\n\n                                                 0);\n\n                    }\n\n                }\n\n\n\n                op_qpix= s->me.qpel_put;\n\n                if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){\n\n                    op_pix = s->hdsp.put_pixels_tab;\n\n                }else{\n\n                    op_pix = s->hdsp.put_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);\n\n                    op_pix = s->hdsp.avg_pixels_tab;\n\n                    op_qpix= s->me.qpel_avg;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* skip dequant / idct if we are really late ;) */\n\n            if(s->avctx->skip_idct){\n\n                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)\n\n                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)\n\n                   || s->avctx->skip_idct >= AVDISCARD_ALL)\n\n                    goto skip_idct;\n\n            }\n\n\n\n            /* add dct residue */\n\n            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO\n\n                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){\n\n                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if (s->chroma_y_shift){\n\n                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n\n                    }else{\n\n                        dct_linesize >>= 1;\n\n                        dct_offset >>=1;\n\n                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n\n                    }\n\n                }\n\n            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){\n\n                add_dct(s, block[0], 0, dest_y                          , dct_linesize);\n\n                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);\n\n                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);\n\n                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){//Chroma420\n\n                        add_dct(s, block[4], 4, dest_cb, uvlinesize);\n\n                        add_dct(s, block[5], 5, dest_cr, uvlinesize);\n\n                    }else{\n\n                        //chroma422\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n\n\n                        add_dct(s, block[4], 4, dest_cb, dct_linesize);\n\n                        add_dct(s, block[5], 5, dest_cr, dct_linesize);\n\n                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);\n\n                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);\n\n                        if(!s->chroma_x_shift){//Chroma444\n\n                            add_dct(s, block[8], 8, dest_cb+8, dct_linesize);\n\n                            add_dct(s, block[9], 9, dest_cr+8, dct_linesize);\n\n                            add_dct(s, block[10], 10, dest_cb+8+dct_offset, dct_linesize);\n\n                            add_dct(s, block[11], 11, dest_cr+8+dct_offset, dct_linesize);\n\n                        }\n\n                    }\n\n                }//fi gray\n\n            }\n\n            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {\n\n                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);\n\n            }\n\n        } else {\n\n            /* dct only in intra block */\n\n            if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){\n\n                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n\n                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n\n                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n\n                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){\n\n                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n\n                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n\n                    }else{\n\n                        dct_offset >>=1;\n\n                        dct_linesize >>=1;\n\n                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n\n                    }\n\n                }\n\n            }else{\n\n                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);\n\n                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);\n\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);\n\n                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){\n\n                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);\n\n                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);\n\n                    }else{\n\n\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n\n\n                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);\n\n                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);\n\n                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);\n\n                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);\n\n                        if(!s->chroma_x_shift){//Chroma444\n\n                            s->idsp.idct_put(dest_cb + 8,              dct_linesize, block[8]);\n\n                            s->idsp.idct_put(dest_cr + 8,              dct_linesize, block[9]);\n\n                            s->idsp.idct_put(dest_cb + 8 + dct_offset, dct_linesize, block[10]);\n\n                            s->idsp.idct_put(dest_cr + 8 + dct_offset, dct_linesize, block[11]);\n\n                        }\n\n                    }\n\n                }//gray\n\n            }\n\n        }\n\nskip_idct:\n\n        if(!readable){\n\n            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);\n\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);\n\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);\n\n        }\n\n    }\n\n}\n", "idx": 129}
{"project": "FFmpeg", "commit_id": "4e4ae2f82caacd03fe936e5553c2e8f70ee109e9", "target": 0, "func": "static void sha256_transform(uint32_t *state, const uint8_t buffer[64])\n\n{\n\n    unsigned int i, a, b, c, d, e, f, g, h;\n\n    uint32_t block[64];\n\n    uint32_t T1;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n    f = state[5];\n\n    g = state[6];\n\n    h = state[7];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 64; i++) {\n\n        uint32_t T2;\n\n        if (i < 16)\n\n            T1 = blk0(i);\n\n        else\n\n            T1 = blk(i);\n\n        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];\n\n        T2 = Sigma0_256(a) + Maj(a, b, c);\n\n        h = g;\n\n        g = f;\n\n        f = e;\n\n        e = d + T1;\n\n        d = c;\n\n        c = b;\n\n        b = a;\n\n        a = T1 + T2;\n\n    }\n\n#else\n\n    for (i = 0; i < 16;) {\n\n        ROUND256_0_TO_15(a, b, c, d, e, f, g, h);\n\n        ROUND256_0_TO_15(h, a, b, c, d, e, f, g);\n\n        ROUND256_0_TO_15(g, h, a, b, c, d, e, f);\n\n        ROUND256_0_TO_15(f, g, h, a, b, c, d, e);\n\n        ROUND256_0_TO_15(e, f, g, h, a, b, c, d);\n\n        ROUND256_0_TO_15(d, e, f, g, h, a, b, c);\n\n        ROUND256_0_TO_15(c, d, e, f, g, h, a, b);\n\n        ROUND256_0_TO_15(b, c, d, e, f, g, h, a);\n\n    }\n\n\n\n    for (; i < 64;) {\n\n        ROUND256_16_TO_63(a, b, c, d, e, f, g, h);\n\n        ROUND256_16_TO_63(h, a, b, c, d, e, f, g);\n\n        ROUND256_16_TO_63(g, h, a, b, c, d, e, f);\n\n        ROUND256_16_TO_63(f, g, h, a, b, c, d, e);\n\n        ROUND256_16_TO_63(e, f, g, h, a, b, c, d);\n\n        ROUND256_16_TO_63(d, e, f, g, h, a, b, c);\n\n        ROUND256_16_TO_63(c, d, e, f, g, h, a, b);\n\n        ROUND256_16_TO_63(b, c, d, e, f, g, h, a);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n    state[5] += f;\n\n    state[6] += g;\n\n    state[7] += h;\n\n}\n", "idx": 130}
{"project": "qemu", "commit_id": "abed886ec60cf239a03515cf0b30fb11fa964c44", "target": 1, "func": "static void device_finalize(Object *obj)\n\n{\n\n    NamedGPIOList *ngl, *next;\n\n\n\n    DeviceState *dev = DEVICE(obj);\n\n    qemu_opts_del(dev->opts);\n\n\n\n    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {\n\n        QLIST_REMOVE(ngl, node);\n\n        qemu_free_irqs(ngl->in, ngl->num_in);\n\n        g_free(ngl->name);\n\n        g_free(ngl);\n\n        /* ngl->out irqs are owned by the other end and should not be freed\n\n         * here\n\n         */\n\n    }\n\n}\n", "idx": 131}
{"project": "qemu", "commit_id": "63fa06dc978f3669dbfd9443b33cde9e2a7f4b41", "target": 1, "func": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        error_setg(errp, \"Image not in VDI format (bad signature %08x)\", header.signature);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        error_setg(errp, \"unsupported VDI image (version %u.%u)\",\n\n                   header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned block map offset \"\n\n                   \"0x%x)\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned data offset 0x%x)\",\n\n                   header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.sector_size, SECTOR_SIZE);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.block_size, 1 * MiB);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        error_setg(errp, \"unsupported VDI image (disk size %\" PRIu64 \", \"\n\n                   \"image bitmap has room for %\" PRIu64 \")\",\n\n                   header.disk_size,\n\n                   (uint64_t)header.blocks_in_image * header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL link UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL parent UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 132}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void i440fx_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = i440fx_initfn;\n\n    k->config_write = i440fx_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82441;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_i440fx;\n\n}\n", "idx": 133}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "int yuv2rgb_c_init_tables (SwsContext *c, const int inv_table[4], int fullRange, int brightness, int contrast, int saturation)\n\n{\n\n    const int isRgb = isBGR(c->dstFormat);\n\n    const int bpp = fmt_depth(c->dstFormat);\n\n    int i;\n\n    uint8_t table_Y[1024];\n\n    uint32_t *table_32 = 0;\n\n    uint16_t *table_16 = 0;\n\n    uint8_t *table_8 = 0;\n\n    uint8_t *table_332 = 0;\n\n    uint8_t *table_121 = 0;\n\n    uint8_t *table_1 = 0;\n\n    int entry_size = 0;\n\n    void *table_r = 0, *table_g = 0, *table_b = 0;\n\n    void *table_start;\n\n\n\n    int64_t crv =  inv_table[0];\n\n    int64_t cbu =  inv_table[1];\n\n    int64_t cgu = -inv_table[2];\n\n    int64_t cgv = -inv_table[3];\n\n    int64_t cy  = 1<<16;\n\n    int64_t oy  = 0;\n\n\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    if(!fullRange){\n\n\tcy= (cy*255) / 219;\n\n\toy= 16<<16;\n\n    }else{\n\n        crv= (crv*224) / 255;\n\n        cbu= (cbu*224) / 255;\n\n        cgu= (cgu*224) / 255;\n\n        cgv= (cgv*224) / 255;\n\n    }\n\n\n\n    cy = (cy *contrast             )>>16;\n\n    crv= (crv*contrast * saturation)>>32;\n\n    cbu= (cbu*contrast * saturation)>>32;\n\n    cgu= (cgu*contrast * saturation)>>32;\n\n    cgv= (cgv*contrast * saturation)>>32;\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    oy -= 256*brightness;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n\tint j;\n\n\n\n\tj= (cy*(((i - 384)<<16) - oy) + (1<<31))>>32;\n\n\tj = (j < 0) ? 0 : ((j > 255) ? 255 : j);\n\n\ttable_Y[i] = j;\n\n    }\n\n\n\n    switch (bpp) {\n\n    case 32:\n\n\ttable_start= table_32 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint32_t));\n\n\n\n\tentry_size = sizeof (uint32_t);\n\n\ttable_r = table_32 + 197;\n\n\ttable_b = table_32 + 197 + 685;\n\n\ttable_g = table_32 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++)\n\n\t    ((uint32_t *)table_r)[i] = table_Y[i+384] << (isRgb ? 16 : 0);\n\n\tfor (i = -132; i < 256+132; i++)\n\n\t    ((uint32_t *)table_g)[i] = table_Y[i+384] << 8;\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint32_t *)table_b)[i] = table_Y[i+384] << (isRgb ? 0 : 16);\n\n\tbreak;\n\n\n\n    case 24:\n\n\ttable_start= table_8 = av_malloc ((256 + 2*232) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_g = table_b = table_8 + 232;\n\n\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint8_t * )table_b)[i] = table_Y[i+384];\n\n\tbreak;\n\n\n\n    case 15:\n\n    case 16:\n\n\ttable_start= table_16 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint16_t));\n\n\n\n\tentry_size = sizeof (uint16_t);\n\n\ttable_r = table_16 + 197;\n\n\ttable_b = table_16 + 197 + 685;\n\n\ttable_g = table_16 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);\n\n\n\n\t    ((uint16_t *)table_g)[i] = j << 5;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 8:\n\n\ttable_start= table_332 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_332 + 197;\n\n\ttable_b = table_332 + 197 + 685;\n\n\ttable_g = table_332 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 5;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 1;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 2;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = (table_Y[i+384 - 37] + 43)/85;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 6;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n    case 4:\n\n    case 4|128:\n\n\ttable_start= table_121 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_121 + 197;\n\n\ttable_b = table_121 + 197 + 685;\n\n\ttable_g = table_121 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 37]+ 43)/85;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 1;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j =table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 1:\n\n\ttable_start= table_1 = av_malloc (256*2 * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_g = table_1;\n\n\ttable_r = table_b = NULL;\n\n\n\n\tfor (i = 0; i < 256+256; i++) {\n\n\t    int j = table_Y[i + 384 - 110]>>7;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    default:\n\n\ttable_start= NULL;\n\n\tav_log(c, AV_LOG_ERROR, \"%ibpp not supported by yuv2rgb\\n\", bpp);\n\n\t//free mem?\n\n\treturn -1;\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n\tc->table_rV[i] = (uint8_t *)table_r + entry_size * div_round (crv * (i-128), 76309);\n\n\tc->table_gU[i] = (uint8_t *)table_g + entry_size * div_round (cgu * (i-128), 76309);\n\n\tc->table_gV[i] = entry_size * div_round (cgv * (i-128), 76309);\n\n\tc->table_bU[i] = (uint8_t *)table_b + entry_size * div_round (cbu * (i-128), 76309);\n\n    }\n\n\n\n    av_free(c->yuvTable);\n\n    c->yuvTable= table_start;\n\n    return 0;\n\n}\n", "idx": 134}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_udiv(target_ulong a, target_ulong b)\n\n{\n\n    uint64_t x0;\n\n    uint32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if (x0 > 0xffffffff) {\n\n        env->cc_src2 = 1;\n\n        return 0xffffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 135}
{"project": "qemu", "commit_id": "7c8730d45f63b76588da5ea0d4eff73a0bcae188", "target": 1, "func": "static direntry_t *create_short_filename(BDRVVVFATState *s,\n\n                                         const char *filename,\n\n                                         unsigned int directory_start)\n\n{\n\n    int i, j = 0;\n\n    direntry_t *entry = array_get_next(&(s->directory));\n\n    const gchar *p, *last_dot = NULL;\n\n    gunichar c;\n\n    bool lossy_conversion = false;\n\n    char tail[11];\n\n\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n    memset(entry->name, 0x20, sizeof(entry->name));\n\n\n\n    /* copy filename and search last dot */\n\n    for (p = filename; ; p = g_utf8_next_char(p)) {\n\n        c = g_utf8_get_char(p);\n\n        if (c == '\\0') {\n\n            break;\n\n        } else if (c == '.') {\n\n            if (j == 0) {\n\n                /* '.' at start of filename */\n\n                lossy_conversion = true;\n\n            } else {\n\n                if (last_dot) {\n\n                    lossy_conversion = true;\n\n                }\n\n                last_dot = p;\n\n            }\n\n        } else if (!last_dot) {\n\n            /* first part of the name; copy it */\n\n            uint8_t v = to_valid_short_char(c);\n\n            if (j < 8 && v) {\n\n                entry->name[j++] = v;\n\n            } else {\n\n                lossy_conversion = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* copy extension (if any) */\n\n    if (last_dot) {\n\n        j = 0;\n\n        for (p = g_utf8_next_char(last_dot); ; p = g_utf8_next_char(p)) {\n\n            c = g_utf8_get_char(p);\n\n            if (c == '\\0') {\n\n                break;\n\n            } else {\n\n                /* extension; copy it */\n\n                uint8_t v = to_valid_short_char(c);\n\n                if (j < 3 && v) {\n\n                    entry->name[8 + (j++)] = v;\n\n                } else {\n\n                    lossy_conversion = true;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (entry->name[0] == DIR_KANJI) {\n\n        entry->name[0] = DIR_KANJI_FAKE;\n\n    }\n\n\n\n    /* numeric-tail generation */\n\n    for (j = 0; j < 8; j++) {\n\n        if (entry->name[j] == ' ') {\n\n            break;\n\n        }\n\n    }\n\n    for (i = lossy_conversion ? 1 : 0; i < 999999; i++) {\n\n        direntry_t *entry1;\n\n        if (i > 0) {\n\n            int len = sprintf(tail, \"~%d\", i);\n\n            memcpy(entry->name + MIN(j, 8 - len), tail, len);\n\n        }\n\n        for (entry1 = array_get(&(s->directory), directory_start);\n\n             entry1 < entry; entry1++) {\n\n            if (!is_long_name(entry1) &&\n\n                !memcmp(entry1->name, entry->name, 11)) {\n\n                break; /* found dupe */\n\n            }\n\n        }\n\n        if (entry1 == entry) {\n\n            /* no dupe found */\n\n            return entry;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 136}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_print_debug_info(MpegEncContext *s, Picture *p)\n\n{\n\n    AVFrame *pict;\n\n    if (s->avctx->hwaccel || !p || !p->mb_type)\n\n        return;\n\n    pict = &p->f;\n\n\n\n    if (s->avctx->debug & (FF_DEBUG_SKIP | FF_DEBUG_QP | FF_DEBUG_MB_TYPE)) {\n\n        int x,y;\n\n\n\n        av_log(s->avctx,AV_LOG_DEBUG,\"New frame, type: \");\n\n        switch (pict->pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"I\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"P\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"B\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_S:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"S\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SI:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SI\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SP:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SP\\n\");\n\n            break;\n\n        }\n\n        for (y = 0; y < s->mb_height; y++) {\n\n            for (x = 0; x < s->mb_width; x++) {\n\n                if (s->avctx->debug & FF_DEBUG_SKIP) {\n\n                    int count = s->mbskip_table[x + y * s->mb_stride];\n\n                    if (count > 9)\n\n                        count = 9;\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%1d\", count);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_QP) {\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%2d\",\n\n                           p->qscale_table[x + y * s->mb_stride]);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_MB_TYPE) {\n\n                    int mb_type = p->mb_type[x + y * s->mb_stride];\n\n                    // Type & MV direction\n\n                    if (IS_PCM(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"P\");\n\n                    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"A\");\n\n                    else if (IS_INTRA4x4(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"i\");\n\n                    else if (IS_INTRA16x16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"I\");\n\n                    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"d\");\n\n                    else if (IS_DIRECT(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"D\");\n\n                    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"g\");\n\n                    else if (IS_GMC(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"G\");\n\n                    else if (IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"S\");\n\n                    else if (!USES_LIST(mb_type, 1))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \">\");\n\n                    else if (!USES_LIST(mb_type, 0))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"<\");\n\n                    else {\n\n                        assert(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"X\");\n\n                    }\n\n\n\n                    // segmentation\n\n                    if (IS_8X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"+\");\n\n                    else if (IS_16X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"-\");\n\n                    else if (IS_8X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"|\");\n\n                    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"?\");\n\n\n\n\n\n                    if (IS_INTERLACED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"=\");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                }\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n        }\n\n    }\n\n}\n", "idx": 138}
{"project": "FFmpeg", "commit_id": "b1e309865f6b4f67841c811faa5022e492095906", "target": 1, "func": "static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,\n\n    int dest_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    init_get_bits(&gb, ptr, 0); // FIXME: no src size available\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest + 1 > dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 139}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_log_stop(CPUPhysMemoryClient *client,\n\n                        target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, false);\n\n}\n", "idx": 140}
{"project": "FFmpeg", "commit_id": "01dbbd0a9af53237cf7aac210370892208bfb957", "target": 1, "func": "void MPV_common_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n\n\n    if (s->motion_val)\n\n        free(s->motion_val);\n\n    if (s->h263_pred) {\n\n        free(s->dc_val[0]);\n\n        free(s->ac_val[0]);\n\n        free(s->coded_block);\n\n        free(s->mbintra_table);\n\n    }\n\n    if (s->mbskip_table)\n\n        free(s->mbskip_table);\n\n    for(i=0;i<3;i++) {\n\n        free(s->last_picture_base[i]);\n\n        free(s->next_picture_base[i]);\n\n        if (s->has_b_frames)\n\n            free(s->aux_picture_base[i]);\n\n    }\n\n    s->context_initialized = 0;\n\n}\n", "idx": 141}
{"project": "qemu", "commit_id": "de81d72d3d13a19edf4d461be3b0f5a877be0234", "target": 1, "func": "static void blkdebug_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QDict *opts;\n\n    const QDictEntry *e;\n\n    bool force_json = false;\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"config\") &&\n\n            strcmp(qdict_entry_key(e), \"x-image\"))\n\n        {\n\n            force_json = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (force_json && !bs->file->bs->full_open_options) {\n\n        /* The config file cannot be recreated, so creating a plain filename\n\n         * is impossible */\n\n        return;\n\n    }\n\n\n\n    if (!force_json && bs->file->bs->exact_filename[0]) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"blkdebug:%s:%s\", s->config_file ?: \"\",\n\n                 bs->file->bs->exact_filename);\n\n    }\n\n\n\n    opts = qdict_new();\n\n    qdict_put_str(opts, \"driver\", \"blkdebug\");\n\n\n\n    QINCREF(bs->file->bs->full_open_options);\n\n    qdict_put(opts, \"image\", bs->file->bs->full_open_options);\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"x-image\")) {\n\n            qobject_incref(qdict_entry_value(e));\n\n            qdict_put_obj(opts, qdict_entry_key(e), qdict_entry_value(e));\n\n        }\n\n    }\n\n\n\n    bs->full_open_options = opts;\n\n}\n", "idx": 142}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n\n                USBPacket *p)\n\n{\n\n    int len;\n\n\n\n    if (likely(!fifo->len))\n\n        return USB_RET_STALL;\n\n\n\n    len = MIN(p->len, fifo->fifo[fifo->start].len);\n\n    memcpy(p->data, fifo->fifo[fifo->start].data, len);\n\n    if (len == p->len) {\n\n        fifo->fifo[fifo->start].len -= len;\n\n        fifo->fifo[fifo->start].data += len;\n\n    } else {\n\n        fifo->start ++;\n\n        fifo->start &= CFIFO_LEN_MASK;\n\n        fifo->len --;\n\n    }\n\n\n\n    fifo->dstart += len;\n\n    fifo->dlen -= len;\n\n    if (fifo->dstart >= fifo->dsize) {\n\n        fifo->dstart = 0;\n\n        fifo->dsize = DFIFO_LEN_MASK + 1;\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 144}
{"project": "qemu", "commit_id": "77358b59f6f3ef571fb2262f5f6216e179d07ecb", "target": 1, "func": "static int block_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    static int banner_printed;\n\n    int len, flags;\n\n    char device_name[256];\n\n    int64_t addr;\n\n    BlockDriverState *bs;\n\n    uint8_t *buf;\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~BDRV_SECTOR_MASK;\n\n        addr >>= BDRV_SECTOR_BITS;\n\n\n\n        if (flags & BLK_MIG_FLAG_DEVICE_BLOCK) {\n\n            int ret;\n\n            /* get device name */\n\n            len = qemu_get_byte(f);\n\n            qemu_get_buffer(f, (uint8_t *)device_name, len);\n\n            device_name[len] = '\\0';\n\n\n\n            bs = bdrv_find(device_name);\n\n            if (!bs) {\n\n                fprintf(stderr, \"Error unknown block device %s\\n\",\n\n                        device_name);\n\n                return -EINVAL;\n\n            }\n\n\n\n            buf = qemu_malloc(BLOCK_SIZE);\n\n\n\n            qemu_get_buffer(f, buf, BLOCK_SIZE);\n\n            ret = bdrv_write(bs, addr, buf, BDRV_SECTORS_PER_DIRTY_CHUNK);\n\n\n\n            qemu_free(buf);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        } else if (flags & BLK_MIG_FLAG_PROGRESS) {\n\n            if (!banner_printed) {\n\n                printf(\"Receiving block device images\\n\");\n\n                banner_printed = 1;\n\n            }\n\n            printf(\"Completed %d %%%c\", (int)addr,\n\n                   (addr == 100) ? '\\n' : '\\r');\n\n            fflush(stdout);\n\n        } else if (!(flags & BLK_MIG_FLAG_EOS)) {\n\n            fprintf(stderr, \"Unknown flags\\n\");\n\n            return -EINVAL;\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & BLK_MIG_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 145}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceIn *alsa = (ALSAVoiceIn *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_in;\n\n    req.buffer_size = conf.buffer_size_in;\n\n    req.size_in_usec = conf.size_in_usec_in;\n\n    req.override_mask =\n\n        (conf.period_size_in_overridden ? 1 : 0) |\n\n        (conf.buffer_size_in_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (1, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate ADC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 147}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    if (m5206_mbar_width[offset >> 2] > 1) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readw(opaque, offset & ~1);\n\n        if ((offset & 1) == 0) {\n\n            val >>= 8;\n\n        }\n\n        return val & 0xff;\n\n    }\n\n    return m5206_mbar_read(s, offset, 1);\n\n}\n", "idx": 148}
{"project": "qemu", "commit_id": "6c098407ef2c56cf6b42d6e3b545b26eaaff2edf", "target": 1, "func": "static int vnc_zlib_stop(VncState *vs, int stream_id)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream[stream_id];\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream %d\\n\", stream_id);\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = Z_NULL;\n\n        zstream->zfree = Z_NULL;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    // XXX what to do if tight_compression changed in between?\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 150}
{"project": "FFmpeg", "commit_id": "2475858889cde6221677473b663df6f985add33d", "target": 1, "func": "static int flac_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    FLACParseContext *fpc = s->priv_data;\n\n    FLACHeaderMarker *curr;\n\n    int nb_headers;\n\n    const uint8_t *read_end   = buf;\n\n    const uint8_t *read_start = buf;\n\n\n\n    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {\n\n        FLACFrameInfo fi;\n\n        if (frame_header_is_valid(avctx, buf, &fi)) {\n\n            s->duration = fi.blocksize;\n\n            if (!avctx->sample_rate)\n\n                avctx->sample_rate = fi.samplerate;\n\n            if (fpc->pc->flags & PARSER_FLAG_USE_CODEC_TS){\n\n                fpc->pc->pts = fi.frame_or_sample_num;\n\n                if (!fi.is_var_size)\n\n                  fpc->pc->pts *= fi.blocksize;\n\n            }\n\n        }\n\n        *poutbuf      = buf;\n\n        *poutbuf_size = buf_size;\n\n        return buf_size;\n\n    }\n\n\n\n    fpc->avctx = avctx;\n\n    if (fpc->best_header_valid)\n\n        return get_best_header(fpc, poutbuf, poutbuf_size);\n\n\n\n    /* If a best_header was found last call remove it with the buffer data. */\n\n    if (fpc->best_header && fpc->best_header->best_child) {\n\n        FLACHeaderMarker *temp;\n\n        FLACHeaderMarker *best_child = fpc->best_header->best_child;\n\n\n\n        /* Remove headers in list until the end of the best_header. */\n\n        for (curr = fpc->headers; curr != best_child; curr = temp) {\n\n            if (curr != fpc->best_header) {\n\n                av_log(avctx, AV_LOG_DEBUG,\n\n                       \"dropping low score %i frame header from offset %i to %i\\n\",\n\n                       curr->max_score, curr->offset, curr->next->offset);\n\n            }\n\n            temp = curr->next;\n\n            av_freep(&curr->link_penalty);\n\n            av_free(curr);\n\n\n        }\n\n        /* Release returned data from ring buffer. */\n\n        av_fifo_drain(fpc->fifo_buf, best_child->offset);\n\n\n\n        /* Fix the offset for the headers remaining to match the new buffer. */\n\n        for (curr = best_child->next; curr; curr = curr->next)\n\n            curr->offset -= best_child->offset;\n\n\n\n\n        best_child->offset = 0;\n\n        fpc->headers       = best_child;\n\n        if (fpc->nb_headers_buffered >= FLAC_MIN_HEADERS) {\n\n            fpc->best_header = best_child;\n\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n\n        }\n\n        fpc->best_header   = NULL;\n\n    } else if (fpc->best_header) {\n\n        /* No end frame no need to delete the buffer; probably eof */\n\n        FLACHeaderMarker *temp;\n\n\n\n        for (curr = fpc->headers; curr != fpc->best_header; curr = temp) {\n\n            temp = curr->next;\n\n            av_freep(&curr->link_penalty);\n\n            av_free(curr);\n\n\n        }\n\n        fpc->headers = fpc->best_header->next;\n\n        av_freep(&fpc->best_header->link_penalty);\n\n        av_freep(&fpc->best_header);\n\n\n    }\n\n\n\n    /* Find and score new headers.                                     */\n\n    /* buf_size is to zero when padding, so check for this since we do */\n\n    /* not want to try to read more input once we have found the end.  */\n\n    /* Note that as (non-modified) parameters, buf can be non-NULL,    */\n\n    /* while buf_size is 0.                                            */\n\n    while ((buf && buf_size && read_end < buf + buf_size &&\n\n            fpc->nb_headers_buffered < FLAC_MIN_HEADERS)\n\n           || ((!buf || !buf_size) && !fpc->end_padded)) {\n\n        int start_offset;\n\n\n\n        /* Pad the end once if EOF, to check the final region for headers. */\n\n        if (!buf || !buf_size) {\n\n            fpc->end_padded      = 1;\n\n            buf_size = MAX_FRAME_HEADER_SIZE;\n\n            read_end = read_start + MAX_FRAME_HEADER_SIZE;\n\n        } else {\n\n            /* The maximum read size is the upper-bound of what the parser\n\n               needs to have the required number of frames buffered */\n\n            int nb_desired = FLAC_MIN_HEADERS - fpc->nb_headers_buffered + 1;\n\n            read_end       = read_end + FFMIN(buf + buf_size - read_end,\n\n                                              nb_desired * FLAC_AVG_FRAME_SIZE);\n\n        }\n\n\n\n        if (!av_fifo_space(fpc->fifo_buf) &&\n\n            av_fifo_size(fpc->fifo_buf) / FLAC_AVG_FRAME_SIZE >\n\n            fpc->nb_headers_buffered * 20) {\n\n            /* There is less than one valid flac header buffered for 20 headers\n\n             * buffered. Therefore the fifo is most likely filled with invalid\n\n             * data and the input is not a flac file. */\n\n            goto handle_error;\n\n        }\n\n\n\n        /* Fill the buffer. */\n\n        if (   av_fifo_space(fpc->fifo_buf) < read_end - read_start\n\n            && av_fifo_realloc2(fpc->fifo_buf, (read_end - read_start) + 2*av_fifo_size(fpc->fifo_buf)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't reallocate buffer of size %\"PTRDIFF_SPECIFIER\"\\n\",\n\n                   (read_end - read_start) + av_fifo_size(fpc->fifo_buf));\n\n            goto handle_error;\n\n        }\n\n\n\n        if (buf && buf_size) {\n\n            av_fifo_generic_write(fpc->fifo_buf, (void*) read_start,\n\n                                  read_end - read_start, NULL);\n\n        } else {\n\n            int8_t pad[MAX_FRAME_HEADER_SIZE] = { 0 };\n\n            av_fifo_generic_write(fpc->fifo_buf, (void*) pad, sizeof(pad), NULL);\n\n        }\n\n\n\n        /* Tag headers and update sequences. */\n\n        start_offset = av_fifo_size(fpc->fifo_buf) -\n\n                       ((read_end - read_start) + (MAX_FRAME_HEADER_SIZE - 1));\n\n        start_offset = FFMAX(0, start_offset);\n\n        nb_headers   = find_new_headers(fpc, start_offset);\n\n\n\n        if (nb_headers < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"find_new_headers couldn't allocate FLAC header\\n\");\n\n            goto handle_error;\n\n        }\n\n\n\n        fpc->nb_headers_buffered = nb_headers;\n\n        /* Wait till FLAC_MIN_HEADERS to output a valid frame. */\n\n        if (!fpc->end_padded && fpc->nb_headers_buffered < FLAC_MIN_HEADERS) {\n\n            if (buf && read_end < buf + buf_size) {\n\n                read_start = read_end;\n\n                continue;\n\n            } else {\n\n                goto handle_error;\n\n            }\n\n        }\n\n\n\n        /* If headers found, update the scores since we have longer chains. */\n\n        if (fpc->end_padded || fpc->nb_headers_found)\n\n            score_sequences(fpc);\n\n\n\n        /* restore the state pre-padding */\n\n        if (fpc->end_padded) {\n\n            int warp = fpc->fifo_buf->wptr - fpc->fifo_buf->buffer < MAX_FRAME_HEADER_SIZE;\n\n            /* HACK: drain the tail of the fifo */\n\n            fpc->fifo_buf->wptr -= MAX_FRAME_HEADER_SIZE;\n\n            fpc->fifo_buf->wndx -= MAX_FRAME_HEADER_SIZE;\n\n            if (warp) {\n\n                fpc->fifo_buf->wptr += fpc->fifo_buf->end -\n\n                    fpc->fifo_buf->buffer;\n\n            }\n\n            buf_size = 0;\n\n            read_start = read_end = NULL;\n\n        }\n\n    }\n\n\n\n    for (curr = fpc->headers; curr; curr = curr->next) {\n\n        if (curr->max_score > 0 &&\n\n            (!fpc->best_header || curr->max_score > fpc->best_header->max_score)) {\n\n            fpc->best_header = curr;\n\n        }\n\n    }\n\n\n\n    if (fpc->best_header) {\n\n        fpc->best_header_valid = 1;\n\n        if (fpc->best_header->offset > 0) {\n\n            /* Output a junk frame. */\n\n            av_log(avctx, AV_LOG_DEBUG, \"Junk frame till offset %i\\n\",\n\n                   fpc->best_header->offset);\n\n\n\n            /* Set duration to 0. It is unknown or invalid in a junk frame. */\n\n            s->duration = 0;\n\n            *poutbuf_size     = fpc->best_header->offset;\n\n            *poutbuf          = flac_fifo_read_wrap(fpc, 0, *poutbuf_size,\n\n                                                    &fpc->wrap_buf,\n\n                                                    &fpc->wrap_buf_allocated_size);\n\n            return buf_size ? (read_end - buf) : (fpc->best_header->offset -\n\n                                           av_fifo_size(fpc->fifo_buf));\n\n        }\n\n        if (!buf_size)\n\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n\n    }\n\n\n\nhandle_error:\n\n    *poutbuf      = NULL;\n\n    *poutbuf_size = 0;\n\n    return buf_size ? read_end - buf : 0;\n\n}", "idx": 151}
{"project": "FFmpeg", "commit_id": "83330cf5fae65423c24c5a0fb3705675236d88ed", "target": 1, "func": "int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,\n\n             const void *bits, int bits_wrap, int bits_size,\n\n             const void *codes, int codes_wrap, int codes_size,\n\n             const void *symbols, int symbols_wrap, int symbols_size,\n\n             int flags)\n\n{\n\n    VLCcode *buf;\n\n    int i, j, ret;\n\n\n\n    vlc->bits = nb_bits;\n\n    if(flags & INIT_VLC_USE_NEW_STATIC){\n\n        VLC dyn_vlc = *vlc;\n\n\n\n        if (vlc->table_size)\n\n            return 0;\n\n\n\n        ret = ff_init_vlc_sparse(&dyn_vlc, nb_bits, nb_codes,\n\n                                 bits, bits_wrap, bits_size,\n\n                                 codes, codes_wrap, codes_size,\n\n                                 symbols, symbols_wrap, symbols_size,\n\n                                 flags & ~INIT_VLC_USE_NEW_STATIC);\n\n        av_assert0(ret >= 0);\n\n        av_assert0(dyn_vlc.table_size <= vlc->table_allocated);\n\n        if(dyn_vlc.table_size < vlc->table_allocated)\n\n            av_log(NULL, AV_LOG_ERROR, \"needed %d had %d\\n\", dyn_vlc.table_size, vlc->table_allocated);\n\n        memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));\n\n        vlc->table_size = dyn_vlc.table_size;\n\n        ff_free_vlc(&dyn_vlc);\n\n        return 0;\n\n    }else {\n\n        vlc->table = NULL;\n\n        vlc->table_allocated = 0;\n\n        vlc->table_size = 0;\n\n    }\n\n\n\n    av_dlog(NULL, \"build table nb_codes=%d\\n\", nb_codes);\n\n\n\n    buf = av_malloc((nb_codes+1)*sizeof(VLCcode));\n\n\n\n    av_assert0(symbols_size <= 2 || !symbols);\n\n    j = 0;\n\n#define COPY(condition)\\\n\n    for (i = 0; i < nb_codes; i++) {\\\n\n        GET_DATA(buf[j].bits, bits, i, bits_wrap, bits_size);\\\n\n        if (!(condition))\\\n\n            continue;\\\n\n        if (buf[j].bits > 3*nb_bits || buf[j].bits>32) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Too long VLC in init_vlc\\n\");\\\n\n\n            return -1;\\\n\n        }\\\n\n        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);\\\n\n        if (buf[j].code >= (1LL<<buf[j].bits)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid code in init_vlc\\n\");\\\n\n\n            return -1;\\\n\n        }\\\n\n        if (flags & INIT_VLC_LE)\\\n\n            buf[j].code = bitswap_32(buf[j].code);\\\n\n        else\\\n\n            buf[j].code <<= 32 - buf[j].bits;\\\n\n        if (symbols)\\\n\n            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size)\\\n\n        else\\\n\n            buf[j].symbol = i;\\\n\n        j++;\\\n\n    }\n\n    COPY(buf[j].bits > nb_bits);\n\n    // qsort is the slowest part of init_vlc, and could probably be improved or avoided\n\n    qsort(buf, j, sizeof(VLCcode), compare_vlcspec);\n\n    COPY(buf[j].bits && buf[j].bits <= nb_bits);\n\n    nb_codes = j;\n\n\n\n    ret = build_table(vlc, nb_bits, nb_codes, buf, flags);\n\n\n\n    av_free(buf);\n\n    if (ret < 0) {\n\n        av_freep(&vlc->table);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}", "idx": 152}
{"project": "FFmpeg", "commit_id": "babf4fe01a808327d53977ba319c113a930180b1", "target": 1, "func": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= 0;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb=\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "idx": 153}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void cg3_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    CG3State *s = CG3(obj);\n\n\n\n    memory_region_init_ram(&s->rom, NULL, \"cg3.prom\", FCODE_MAX_ROM_SIZE,\n\n                           &error_abort);\n\n    memory_region_set_readonly(&s->rom, true);\n\n    sysbus_init_mmio(sbd, &s->rom);\n\n\n\n    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, \"cg3.reg\",\n\n                          CG3_REG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->reg);\n\n}\n", "idx": 154}
{"project": "FFmpeg", "commit_id": "8ea5df4fac57acf8a6e8cf575502ccd3dd776f57", "target": 1, "func": "int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n\n{\n\n    int id, sr, ch, ba, tag, bps;\n\n\n\n    id  = avctx->codec_id;\n\n    sr  = avctx->sample_rate;\n\n    ch  = avctx->channels;\n\n    ba  = avctx->block_align;\n\n    tag = avctx->codec_tag;\n\n    bps = av_get_exact_bits_per_sample(avctx->codec_id);\n\n\n\n    /* codecs with an exact constant bits per sample */\n\n    if (bps > 0 && ch > 0 && frame_bytes > 0)\n\n        return (frame_bytes * 8) / (bps * ch);\n\n    bps = avctx->bits_per_coded_sample;\n\n\n\n    /* codecs with a fixed packet duration */\n\n    switch (id) {\n\n    case CODEC_ID_ADPCM_ADX:    return   32;\n\n    case CODEC_ID_ADPCM_IMA_QT: return   64;\n\n    case CODEC_ID_ADPCM_EA_XAS: return  128;\n\n    case CODEC_ID_AMR_NB:\n\n    case CODEC_ID_GSM:\n\n    case CODEC_ID_QCELP:\n\n    case CODEC_ID_RA_144:\n\n    case CODEC_ID_RA_288:       return  160;\n\n    case CODEC_ID_IMC:          return  256;\n\n    case CODEC_ID_AMR_WB:\n\n    case CODEC_ID_GSM_MS:       return  320;\n\n    case CODEC_ID_MP1:          return  384;\n\n    case CODEC_ID_ATRAC1:       return  512;\n\n    case CODEC_ID_ATRAC3:       return 1024;\n\n    case CODEC_ID_MP2:\n\n    case CODEC_ID_MUSEPACK7:    return 1152;\n\n    case CODEC_ID_AC3:          return 1536;\n\n    }\n\n\n\n    if (sr > 0) {\n\n        /* calc from sample rate */\n\n        if (id == CODEC_ID_TTA)\n\n            return 256 * sr / 245;\n\n\n\n        if (ch > 0) {\n\n            /* calc from sample rate and channels */\n\n            if (id == CODEC_ID_BINKAUDIO_DCT)\n\n                return (480 << (sr / 22050)) / ch;\n\n        }\n\n    }\n\n\n\n    if (ba > 0) {\n\n        /* calc from block_align */\n\n        if (id == CODEC_ID_SIPR) {\n\n            switch (ba) {\n\n            case 20: return 160;\n\n            case 19: return 144;\n\n            case 29: return 288;\n\n            case 37: return 480;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (frame_bytes > 0) {\n\n        /* calc from frame_bytes only */\n\n        if (id == CODEC_ID_TRUESPEECH)\n\n            return 240 * (frame_bytes / 32);\n\n        if (id == CODEC_ID_NELLYMOSER)\n\n            return 256 * (frame_bytes / 64);\n\n\n\n        if (bps > 0) {\n\n            /* calc from frame_bytes and bits_per_coded_sample */\n\n            if (id == CODEC_ID_ADPCM_G726)\n\n                return frame_bytes * 8 / bps;\n\n        }\n\n\n\n        if (ch > 0) {\n\n            /* calc from frame_bytes and channels */\n\n            switch (id) {\n\n            case CODEC_ID_ADPCM_4XM:\n\n            case CODEC_ID_ADPCM_IMA_ISS:\n\n                return (frame_bytes - 4 * ch) * 2 / ch;\n\n            case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n                return (frame_bytes - 4) * 2 / ch;\n\n            case CODEC_ID_ADPCM_IMA_AMV:\n\n                return (frame_bytes - 8) * 2 / ch;\n\n            case CODEC_ID_ADPCM_XA:\n\n                return (frame_bytes / 128) * 224 / ch;\n\n            case CODEC_ID_INTERPLAY_DPCM:\n\n                return (frame_bytes - 6 - ch) / ch;\n\n            case CODEC_ID_ROQ_DPCM:\n\n                return (frame_bytes - 8) / ch;\n\n            case CODEC_ID_XAN_DPCM:\n\n                return (frame_bytes - 2 * ch) / ch;\n\n            case CODEC_ID_MACE3:\n\n                return 3 * frame_bytes / ch;\n\n            case CODEC_ID_MACE6:\n\n                return 6 * frame_bytes / ch;\n\n            case CODEC_ID_PCM_LXF:\n\n                return 2 * (frame_bytes / (5 * ch));\n\n            }\n\n\n\n            if (tag) {\n\n                /* calc from frame_bytes, channels, and codec_tag */\n\n                if (id == CODEC_ID_SOL_DPCM) {\n\n                    if (tag == 3)\n\n                        return frame_bytes / ch;\n\n                    else\n\n                        return frame_bytes * 2 / ch;\n\n                }\n\n            }\n\n\n\n            if (ba > 0) {\n\n                /* calc from frame_bytes, channels, and block_align */\n\n                int blocks = frame_bytes / ba;\n\n                switch (avctx->codec_id) {\n\n                case CODEC_ID_ADPCM_IMA_WAV:\n\n                    return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\n\n                case CODEC_ID_ADPCM_IMA_DK3:\n\n                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);\n\n                case CODEC_ID_ADPCM_IMA_DK4:\n\n                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);\n\n                case CODEC_ID_ADPCM_MS:\n\n                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);\n\n                }\n\n            }\n\n\n\n            if (bps > 0) {\n\n                /* calc from frame_bytes, channels, and bits_per_coded_sample */\n\n                switch (avctx->codec_id) {\n\n                case CODEC_ID_PCM_DVD:\n\n                    return 2 * (frame_bytes / ((bps * 2 / 8) * ch));\n\n                case CODEC_ID_PCM_BLURAY:\n\n                    return frame_bytes / ((FFALIGN(ch, 2) * bps) / 8);\n\n                case CODEC_ID_S302M:\n\n                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 156}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void parse_context_init(SchroParseUnitContext *parse_ctx,\n\n                               const uint8_t *buf, int buf_size)\n\n{\n\n    parse_ctx->buf           = buf;\n\n    parse_ctx->buf_size      = buf_size;\n\n}\n", "idx": 157}
{"project": "FFmpeg", "commit_id": "e1c7892013d2832df85dfef6368bd64e82547418", "target": 1, "func": "static int update_size(AVCodecContext *ctx, int w, int h)\n\n{\n\n    VP9Context *s = ctx->priv_data;\n\n    uint8_t *p;\n\n\n\n    if (s->above_partition_ctx && w == ctx->width && h == ctx->height)\n\n        return 0;\n\n\n\n    ctx->width  = w;\n\n    ctx->height = h;\n\n    s->sb_cols  = (w + 63) >> 6;\n\n    s->sb_rows  = (h + 63) >> 6;\n\n    s->cols     = (w + 7) >> 3;\n\n    s->rows     = (h + 7) >> 3;\n\n\n\n#define assign(var, type, n) var = (type) p; p += s->sb_cols * n * sizeof(*var)\n\n    av_free(s->above_partition_ctx);\n\n    p = av_malloc(s->sb_cols * (240 + sizeof(*s->lflvl) + 16 * sizeof(*s->above_mv_ctx) +\n\n                                64 * s->sb_rows * (1 + sizeof(*s->mv[0]) * 2)));\n\n    if (!p)\n\n        return AVERROR(ENOMEM);\n\n    assign(s->above_partition_ctx, uint8_t *,              8);\n\n    assign(s->above_skip_ctx,      uint8_t *,              8);\n\n    assign(s->above_txfm_ctx,      uint8_t *,              8);\n\n    assign(s->above_mode_ctx,      uint8_t *,             16);\n\n    assign(s->above_y_nnz_ctx,     uint8_t *,             16);\n\n    assign(s->above_uv_nnz_ctx[0], uint8_t *,              8);\n\n    assign(s->above_uv_nnz_ctx[1], uint8_t *,              8);\n\n    assign(s->intra_pred_data[0],  uint8_t *,             64);\n\n    assign(s->intra_pred_data[1],  uint8_t *,             32);\n\n    assign(s->intra_pred_data[2],  uint8_t *,             32);\n\n    assign(s->above_segpred_ctx,   uint8_t *,              8);\n\n    assign(s->above_intra_ctx,     uint8_t *,              8);\n\n    assign(s->above_comp_ctx,      uint8_t *,              8);\n\n    assign(s->above_ref_ctx,       uint8_t *,              8);\n\n    assign(s->above_filter_ctx,    uint8_t *,              8);\n\n    assign(s->lflvl,               struct VP9Filter *,     1);\n\n    assign(s->above_mv_ctx,        VP56mv(*)[2],          16);\n\n    assign(s->segmentation_map,    uint8_t *,             64 * s->sb_rows);\n\n    assign(s->mv[0],               struct VP9mvrefPair *, 64 * s->sb_rows);\n\n    assign(s->mv[1],               struct VP9mvrefPair *, 64 * s->sb_rows);\n\n#undef assign\n\n\n\n    return 0;\n\n}\n", "idx": 158}
{"project": "FFmpeg", "commit_id": "710b0e27025948b7511821c2f888ff2d74a59e14", "target": 1, "func": "static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    SmackerContext *smk = s->priv_data;\n\n    int flags;\n\n    int ret;\n\n    int i;\n\n    int frame_size = 0;\n\n    int palchange = 0;\n\n\n\n    if (s->pb->eof_reached || smk->cur_frame >= smk->frames)\n\n        return AVERROR_EOF;\n\n\n\n    /* if we demuxed all streams, pass another frame */\n\n    if(smk->curstream < 0) {\n\n        avio_seek(s->pb, smk->nextpos, 0);\n\n        frame_size = smk->frm_size[smk->cur_frame] & (~3);\n\n        flags = smk->frm_flags[smk->cur_frame];\n\n        /* handle palette change event */\n\n        if(flags & SMACKER_PAL){\n\n            int size, sz, t, off, j, pos;\n\n            uint8_t *pal = smk->pal;\n\n            uint8_t oldpal[768];\n\n\n\n            memcpy(oldpal, pal, 768);\n\n            size = avio_r8(s->pb);\n\n            size = size * 4 - 1;\n\n            frame_size -= size;\n\n            frame_size--;\n\n            sz = 0;\n\n            pos = avio_tell(s->pb) + size;\n\n            while(sz < 256){\n\n                t = avio_r8(s->pb);\n\n                if(t & 0x80){ /* skip palette entries */\n\n                    sz += (t & 0x7F) + 1;\n\n                    pal += ((t & 0x7F) + 1) * 3;\n\n                } else if(t & 0x40){ /* copy with offset */\n\n                    off = avio_r8(s->pb);\n\n                    j = (t & 0x3F) + 1;\n\n                    if (off + j > 0x100) {\n\n                        av_log(s, AV_LOG_ERROR,\n\n                               \"Invalid palette update, offset=%d length=%d extends beyond palette size\\n\",\n\n                               off, j);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    off *= 3;\n\n                    while(j-- && sz < 256) {\n\n                        *pal++ = oldpal[off + 0];\n\n                        *pal++ = oldpal[off + 1];\n\n                        *pal++ = oldpal[off + 2];\n\n                        sz++;\n\n                        off += 3;\n\n                    }\n\n                } else { /* new entries */\n\n                    *pal++ = smk_pal[t];\n\n                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n\n                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n\n                    sz++;\n\n                }\n\n            }\n\n            avio_seek(s->pb, pos, 0);\n\n            palchange |= 1;\n\n        }\n\n        flags >>= 1;\n\n        smk->curstream = -1;\n\n        /* if audio chunks are present, put them to stack and retrieve later */\n\n        for(i = 0; i < 7; i++) {\n\n            if(flags & 1) {\n\n                uint32_t size;\n\n                uint8_t *tmpbuf;\n\n\n\n                size = avio_rl32(s->pb) - 4;\n\n                if (!size || size > frame_size) {\n\n                    av_log(s, AV_LOG_ERROR, \"Invalid audio part size\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                frame_size -= size;\n\n                frame_size -= 4;\n\n                smk->curstream++;\n\n                tmpbuf = av_realloc(smk->bufs[smk->curstream], size);\n\n                if (!tmpbuf)\n\n                    return AVERROR(ENOMEM);\n\n                smk->bufs[smk->curstream] = tmpbuf;\n\n                smk->buf_sizes[smk->curstream] = size;\n\n                ret = avio_read(s->pb, smk->bufs[smk->curstream], size);\n\n                if(ret != size)\n\n                    return AVERROR(EIO);\n\n                smk->stream_id[smk->curstream] = smk->indexes[i];\n\n            }\n\n            flags >>= 1;\n\n        }\n\n        if (frame_size < 0)\n\n            return AVERROR_INVALIDDATA;\n\n        if (av_new_packet(pkt, frame_size + 769))\n\n            return AVERROR(ENOMEM);\n\n        if(smk->frm_size[smk->cur_frame] & 1)\n\n            palchange |= 2;\n\n        pkt->data[0] = palchange;\n\n        memcpy(pkt->data + 1, smk->pal, 768);\n\n        ret = avio_read(s->pb, pkt->data + 769, frame_size);\n\n        if(ret != frame_size)\n\n            return AVERROR(EIO);\n\n        pkt->stream_index = smk->videoindex;\n\n        pkt->pts          = smk->cur_frame;\n\n        pkt->size = ret + 769;\n\n        smk->cur_frame++;\n\n        smk->nextpos = avio_tell(s->pb);\n\n    } else {\n\n        if (smk->stream_id[smk->curstream] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n        if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))\n\n            return AVERROR(ENOMEM);\n\n        memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);\n\n        pkt->size = smk->buf_sizes[smk->curstream];\n\n        pkt->stream_index = smk->stream_id[smk->curstream];\n\n        pkt->pts = smk->aud_pts[smk->curstream];\n\n        smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);\n\n        smk->curstream--;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 159}
{"project": "qemu", "commit_id": "eb69b50ad9806c4a3b5900392a5acc9837cffd18", "target": 1, "func": "static void wm8750_audio_out_cb(void *opaque, int free_b)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n    wm8750_out_flush(s);\n\n\n\n    s->req_out = free_b;\n\n    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);\n\n}\n", "idx": 160}
{"project": "qemu", "commit_id": "9b938c7262e403f5467110609cb20ef1ae6e9df2", "target": 1, "func": "static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)\n{\n    TCPCharDriver *s = chr->opaque;\n    struct cmsghdr *cmsg;\n    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n        int fd;\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS)\n            continue;\n        fd = *((int *)CMSG_DATA(cmsg));\n        if (fd < 0)\n            continue;\n#ifndef MSG_CMSG_CLOEXEC\n        qemu_set_cloexec(fd);\n#endif\n        if (s->msgfd != -1)\n            close(s->msgfd);\n        s->msgfd = fd;\n    }\n}", "idx": 163}
{"project": "qemu", "commit_id": "f06b2031a31cdd3acf6f61a977e505b8c6b58f73", "target": 0, "func": "void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n", "idx": 165}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n\n                                   MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    ram_addr_t addr;\n\n    Error *local_err = NULL;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    addr = ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return -1;\n\n    }\n\n    return addr;\n\n}\n", "idx": 167}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,\n\n                           uint16_t subchannel_nr, uint32_t io_int_parm,\n\n                           uint32_t io_int_word)\n\n{\n\n    uint32_t type;\n\n\n\n    if (io_int_word & IO_INT_WORD_AI) {\n\n        type = KVM_S390_INT_IO(1, 0, 0, 0);\n\n    } else {\n\n        type = ((subchannel_id & 0xff00) << 24) |\n\n            ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);\n\n    }\n\n    kvm_s390_interrupt_internal(cpu, type,\n\n                                ((uint32_t)subchannel_id << 16) | subchannel_nr,\n\n                                ((uint64_t)io_int_parm << 32) | io_int_word, 1);\n\n}\n", "idx": 168}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    s->elcr = val & s->elcr_mask;\n\n}\n", "idx": 169}
{"project": "qemu", "commit_id": "7a6ab45e19b615b9285b9cfa2bbc1fee012bc8d7", "target": 0, "func": "void nonono(const char* file, int line, const char* msg) {\n\n    fprintf(stderr, \"Nonono! %s:%d %s\\n\", file, line, msg);\n\n    exit(-5);\n\n}\n", "idx": 170}
{"project": "qemu", "commit_id": "738012bec4c67e697e766edadab3f522c552a04d", "target": 0, "func": "static void spitz_i2c_setup(PXA2xxState *cpu)\n\n{\n\n    /* Attach the CPU on one end of our I2C bus.  */\n\n    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);\n\n\n\n#ifdef HAS_AUDIO\n\n    DeviceState *wm;\n\n\n\n    /* Attach a WM8750 to the bus */\n\n    wm = i2c_create_slave(bus, \"wm8750\", 0);\n\n\n\n    spitz_wm8750_addr(wm, 0, 0);\n\n    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,\n\n                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);\n\n    /* .. and to the sound interface.  */\n\n    cpu->i2s->opaque = wm;\n\n    cpu->i2s->codec_out = wm8750_dac_dat;\n\n    cpu->i2s->codec_in = wm8750_adc_dat;\n\n    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);\n\n#endif\n\n}\n", "idx": 171}
{"project": "FFmpeg", "commit_id": "d7cb5a8daf73825d4ffa623be4c2b798c81f41a5", "target": 0, "func": "static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out)\n\n{\n\n    OutputStream *ost = ofilter->ost;\n\n    AVCodecContext *codec  = ost->st->codec;\n\n    AVFilterContext *last_filter = out->filter_ctx;\n\n    int pad_idx = out->pad_idx;\n\n    char *sample_fmts, *sample_rates, *channel_layouts;\n\n    char name[255];\n\n    int ret;\n\n\n\n\n\n    snprintf(name, sizeof(name), \"output stream %d:%d\", ost->file_index, ost->index);\n\n    ret = avfilter_graph_create_filter(&ofilter->filter,\n\n                                       avfilter_get_by_name(\"ffabuffersink\"),\n\n                                       name, NULL, NULL, fg->graph);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define AUTO_INSERT_FILTER(opt_name, filter_name, arg) do {                 \\\n\n    AVFilterContext *filt_ctx;                                              \\\n\n                                                                            \\\n\n    av_log(NULL, AV_LOG_INFO, opt_name \" is forwarded to lavfi \"            \\\n\n           \"similarly to -af \" filter_name \"=%s.\\n\", arg);                  \\\n\n                                                                            \\\n\n    ret = avfilter_graph_create_filter(&filt_ctx,                           \\\n\n                                       avfilter_get_by_name(filter_name),   \\\n\n                                       filter_name, arg, NULL, fg->graph);  \\\n\n    if (ret < 0)                                                            \\\n\n        return ret;                                                         \\\n\n                                                                            \\\n\n    ret = avfilter_link(last_filter, pad_idx, filt_ctx, 0);                 \\\n\n    if (ret < 0)                                                            \\\n\n        return ret;                                                         \\\n\n                                                                            \\\n\n    last_filter = filt_ctx;                                                 \\\n\n    pad_idx = 0;                                                            \\\n\n} while (0)\n\n    if (ost->audio_channels_mapped) {\n\n        int i;\n\n        AVBPrint pan_buf;\n\n        av_bprint_init(&pan_buf, 256, 8192);\n\n        av_bprintf(&pan_buf, \"0x%\"PRIx64,\n\n                   av_get_default_channel_layout(ost->audio_channels_mapped));\n\n        for (i = 0; i < ost->audio_channels_mapped; i++)\n\n            if (ost->audio_channels_map[i] != -1)\n\n                av_bprintf(&pan_buf, \":c%d=c%d\", i, ost->audio_channels_map[i]);\n\n\n\n        AUTO_INSERT_FILTER(\"-map_channel\", \"pan\", pan_buf.str);\n\n        av_bprint_finalize(&pan_buf, NULL);\n\n    }\n\n\n\n    if (codec->channels && !codec->channel_layout)\n\n        codec->channel_layout = av_get_default_channel_layout(codec->channels);\n\n\n\n    sample_fmts     = choose_sample_fmts(ost);\n\n    sample_rates    = choose_sample_rates(ost);\n\n    channel_layouts = choose_channel_layouts(ost);\n\n    if (sample_fmts || sample_rates || channel_layouts) {\n\n        AVFilterContext *format;\n\n        char args[256];\n\n        int len = 0;\n\n\n\n        if (sample_fmts)\n\n            len += snprintf(args + len, sizeof(args) - len, \"sample_fmts=%s:\",\n\n                            sample_fmts);\n\n        if (sample_rates)\n\n            len += snprintf(args + len, sizeof(args) - len, \"sample_rates=%s:\",\n\n                            sample_rates);\n\n        if (channel_layouts)\n\n            len += snprintf(args + len, sizeof(args) - len, \"channel_layouts=%s:\",\n\n                            channel_layouts);\n\n        args[len - 1] = 0;\n\n\n\n        av_freep(&sample_fmts);\n\n        av_freep(&sample_rates);\n\n        av_freep(&channel_layouts);\n\n\n\n        snprintf(name, sizeof(name), \"audio format for output stream %d:%d\",\n\n                 ost->file_index, ost->index);\n\n        ret = avfilter_graph_create_filter(&format,\n\n                                           avfilter_get_by_name(\"aformat\"),\n\n                                           name, args, NULL, fg->graph);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        ret = avfilter_link(last_filter, pad_idx, format, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        last_filter = format;\n\n        pad_idx = 0;\n\n    }\n\n\n\n    if (audio_volume != 256 && 0) {\n\n        char args[256];\n\n\n\n        snprintf(args, sizeof(args), \"%f\", audio_volume / 256.);\n\n        AUTO_INSERT_FILTER(\"-vol\", \"volume\", args);\n\n    }\n\n\n\n    if ((ret = avfilter_link(last_filter, pad_idx, ofilter->filter, 0)) < 0)\n\n        return ret;\n\n\n\n    return 0;\n\n}\n", "idx": 172}
{"project": "qemu", "commit_id": "f1839938b090b28537d9be2c1b255b834f3cfbb8", "target": 0, "func": "void restore_boot_order(void *opaque)\n\n{\n\n    char *normal_boot_order = opaque;\n\n    static int first = 1;\n\n\n\n    /* Restore boot order and remove ourselves after the first boot */\n\n    if (first) {\n\n        first = 0;\n\n        return;\n\n    }\n\n\n\n    qemu_boot_set(normal_boot_order);\n\n\n\n    qemu_unregister_reset(restore_boot_order, normal_boot_order);\n\n    g_free(normal_boot_order);\n\n}\n", "idx": 173}
{"project": "qemu", "commit_id": "2a3d57ce4278dfd898d8b5639ace21fa4a4fb9bd", "target": 0, "func": "static int virtser_port_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);\n\n    VirtIOSerialPortInfo *info = DO_UPCAST(VirtIOSerialPortInfo, qdev, base);\n\n    VirtIOSerialBus *bus = DO_UPCAST(VirtIOSerialBus, qbus, qdev->parent_bus);\n\n    int ret, max_nr_ports;\n\n    bool plugging_port0;\n\n\n\n    port->vser = bus->vser;\n\n    port->bh = qemu_bh_new(flush_queued_data_bh, port);\n\n\n\n    /*\n\n     * Is the first console port we're seeing? If so, put it up at\n\n     * location 0. This is done for backward compatibility (old\n\n     * kernel, new qemu).\n\n     */\n\n    plugging_port0 = port->is_console && !find_port_by_id(port->vser, 0);\n\n\n\n    if (find_port_by_id(port->vser, port->id)) {\n\n        error_report(\"virtio-serial-bus: A port already exists at id %u\\n\",\n\n                     port->id);\n\n        return -1;\n\n    }\n\n\n\n    if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n        if (plugging_port0) {\n\n            port->id = 0;\n\n        } else {\n\n            port->id = find_free_port_id(port->vser);\n\n            if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n                error_report(\"virtio-serial-bus: Maximum port limit for this device reached\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    max_nr_ports = tswap32(port->vser->config.max_nr_ports);\n\n    if (port->id >= max_nr_ports) {\n\n        error_report(\"virtio-serial-bus: Out-of-range port id specified, max. allowed: %u\\n\",\n\n                     max_nr_ports - 1);\n\n        return -1;\n\n    }\n\n\n\n    port->info = info;\n\n    ret = info->init(port);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (!use_multiport(port->vser)) {\n\n        /*\n\n         * Allow writes to guest in this case; we have no way of\n\n         * knowing if a guest port is connected.\n\n         */\n\n        port->guest_connected = true;\n\n    }\n\n\n\n    port->elem.out_num = 0;\n\n\n\n    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);\n\n    port->ivq = port->vser->ivqs[port->id];\n\n    port->ovq = port->vser->ovqs[port->id];\n\n\n\n    add_port(port->vser, port->id);\n\n\n\n    /* Send an update to the guest about this new port added */\n\n    virtio_notify_config(&port->vser->vdev);\n\n\n\n    return ret;\n\n}\n", "idx": 175}
{"project": "qemu", "commit_id": "751ebd76e654bd1e65da08ecf694325282b4cfcc", "target": 0, "func": "void block_job_pause(BlockJob *job)\n\n{\n\n    job->paused = true;\n\n}\n", "idx": 177}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void prop_get_fdt(Object *obj, Visitor *v, const char *name,\n\n                         void *opaque, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(obj);\n\n    Error *err = NULL;\n\n    int fdt_offset_next, fdt_offset, fdt_depth;\n\n    void *fdt;\n\n\n\n    if (!drc->fdt) {\n\n        visit_type_null(v, NULL, errp);\n\n        return;\n\n    }\n\n\n\n    fdt = drc->fdt;\n\n    fdt_offset = drc->fdt_start_offset;\n\n    fdt_depth = 0;\n\n\n\n    do {\n\n        const char *name = NULL;\n\n        const struct fdt_property *prop = NULL;\n\n        int prop_len = 0, name_len = 0;\n\n        uint32_t tag;\n\n\n\n        tag = fdt_next_tag(fdt, fdt_offset, &fdt_offset_next);\n\n        switch (tag) {\n\n        case FDT_BEGIN_NODE:\n\n            fdt_depth++;\n\n            name = fdt_get_name(fdt, fdt_offset, &name_len);\n\n            visit_start_struct(v, name, NULL, 0, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            break;\n\n        case FDT_END_NODE:\n\n            /* shouldn't ever see an FDT_END_NODE before FDT_BEGIN_NODE */\n\n            g_assert(fdt_depth > 0);\n\n            visit_check_struct(v, &err);\n\n            visit_end_struct(v);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            fdt_depth--;\n\n            break;\n\n        case FDT_PROP: {\n\n            int i;\n\n            prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);\n\n            name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));\n\n            visit_start_list(v, name, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            for (i = 0; i < prop_len; i++) {\n\n                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);\n\n                if (err) {\n\n                    error_propagate(errp, err);\n\n                    return;\n\n                }\n\n            }\n\n            visit_end_list(v);\n\n            break;\n\n        }\n\n        default:\n\n            error_setg(&error_abort, \"device FDT in unexpected state: %d\", tag);\n\n        }\n\n        fdt_offset = fdt_offset_next;\n\n    } while (fdt_depth != 0);\n\n}\n", "idx": 180}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf, int bytes)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = bytes,\n\n    };\n\n\n\n    if (bytes < 0) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_pwritev(bs, offset, &qiov);\n\n}\n", "idx": 181}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "static int ppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    /* TCG doesn't (yet) emulate some groups of instructions that\n\n     * are implemented on some otherwise supported CPUs (e.g. VSX\n\n     * and decimal floating point instructions on POWER7).  We\n\n     * remove unsupported instruction groups from the cpu state's\n\n     * instruction masks and hope the guest can cope.  For at\n\n     * least the pseries machine, the unavailability of these\n\n     * instructions can be advertised to the guest via the device\n\n     * tree. */\n\n    if ((env->insns_flags & ~PPC_TCG_INSNS)\n\n        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {\n\n        fprintf(stderr, \"Warning: Disabling some instructions which are not \"\n\n                \"emulated by TCG (0x%\" PRIx64 \", 0x%\" PRIx64 \")\\n\",\n\n                env->insns_flags & ~PPC_TCG_INSNS,\n\n                env->insns_flags2 & ~PPC_TCG_INSNS2);\n\n    }\n\n    env->insns_flags &= PPC_TCG_INSNS;\n\n    env->insns_flags2 &= PPC_TCG_INSNS2;\n\n    return 0;\n\n}\n", "idx": 182}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "void main_loop_wait(int timeout)\n\n{\n\n    IOHandlerRecord *ioh;\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n\n\n    qemu_bh_update_timeout(&timeout);\n\n\n\n    host_main_loop_wait(&timeout);\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n        if (ioh->deleted)\n\n            continue;\n\n        if (ioh->fd_read &&\n\n            (!ioh->fd_read_poll ||\n\n             ioh->fd_read_poll(ioh->opaque) != 0)) {\n\n            FD_SET(ioh->fd, &rfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n        if (ioh->fd_write) {\n\n            FD_SET(ioh->fd, &wfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n    }\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n    if (ret > 0) {\n\n        IOHandlerRecord **pioh;\n\n\n\n        for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {\n\n                ioh->fd_read(ioh->opaque);\n\n            }\n\n            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {\n\n                ioh->fd_write(ioh->opaque);\n\n            }\n\n        }\n\n\n\n\t/* remove deleted IO handlers */\n\n\tpioh = &first_io_handler;\n\n\twhile (*pioh) {\n\n            ioh = *pioh;\n\n            if (ioh->deleted) {\n\n                *pioh = ioh->next;\n\n                qemu_free(ioh);\n\n            } else\n\n                pioh = &ioh->next;\n\n        }\n\n    }\n\n\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->flags & ALARM_FLAG_EXPIRED) {\n\n        alarm_timer->flags &= ~ALARM_FLAG_EXPIRED;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    if (vm_running) {\n\n        if (!cur_cpu || likely(!(cur_cpu->singlestep_enabled & SSTEP_NOTIMER)))\n\n            qemu_run_timers(&active_timers[QEMU_TIMER_VIRTUAL],\n\n                qemu_get_clock(vm_clock));\n\n    }\n\n\n\n    /* real time timers */\n\n    qemu_run_timers(&active_timers[QEMU_TIMER_REALTIME],\n\n                    qemu_get_clock(rt_clock));\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 184}
{"project": "FFmpeg", "commit_id": "42df71d9bbb1a5b4bce0bb34417692565c72d390", "target": 0, "func": "av_cold int ff_rate_control_init(MpegEncContext *s)\n\n{\n\n    RateControlContext *rcc = &s->rc_context;\n\n    int i, res;\n\n    static const char * const const_names[] = {\n\n        \"PI\",\n\n        \"E\",\n\n        \"iTex\",\n\n        \"pTex\",\n\n        \"tex\",\n\n        \"mv\",\n\n        \"fCode\",\n\n        \"iCount\",\n\n        \"mcVar\",\n\n        \"var\",\n\n        \"isI\",\n\n        \"isP\",\n\n        \"isB\",\n\n        \"avgQP\",\n\n        \"qComp\",\n\n#if 0\n\n        \"lastIQP\",\n\n        \"lastPQP\",\n\n        \"lastBQP\",\n\n        \"nextNonBQP\",\n\n#endif\n\n        \"avgIITex\",\n\n        \"avgPITex\",\n\n        \"avgPPTex\",\n\n        \"avgBPTex\",\n\n        \"avgTex\",\n\n        NULL\n\n    };\n\n    static double (* const func1[])(void *, double) = {\n\n        (void *)bits2qp,\n\n        (void *)qp2bits,\n\n        NULL\n\n    };\n\n    static const char * const func1_names[] = {\n\n        \"bits2qp\",\n\n        \"qp2bits\",\n\n        NULL\n\n    };\n\n    emms_c();\n\n\n\n    res = av_expr_parse(&rcc->rc_eq_eval,\n\n                        s->rc_eq ? s->rc_eq : \"tex^qComp\",\n\n                        const_names, func1_names, func1,\n\n                        NULL, NULL, 0, s->avctx);\n\n    if (res < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error parsing rc_eq \\\"%s\\\"\\n\", s->rc_eq);\n\n        return res;\n\n    }\n\n\n\n    for (i = 0; i < 5; i++) {\n\n        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;\n\n        rcc->pred[i].count = 1.0;\n\n        rcc->pred[i].decay = 0.4;\n\n\n\n        rcc->i_cplx_sum [i] =\n\n        rcc->p_cplx_sum [i] =\n\n        rcc->mv_bits_sum[i] =\n\n        rcc->qscale_sum [i] =\n\n        rcc->frame_count[i] = 1; // 1 is better because of 1/0 and such\n\n\n\n        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;\n\n    }\n\n    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;\n\n\n\n    if (s->avctx->flags & CODEC_FLAG_PASS2) {\n\n        int i;\n\n        char *p;\n\n\n\n        /* find number of pics */\n\n        p = s->avctx->stats_in;\n\n        for (i = -1; p; i++)\n\n            p = strchr(p + 1, ';');\n\n        i += s->max_b_frames;\n\n        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))\n\n            return -1;\n\n        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));\n\n        rcc->num_entries = i;\n\n\n\n        /* init all to skipped p frames\n\n         * (with b frames we might have a not encoded frame at the end FIXME) */\n\n        for (i = 0; i < rcc->num_entries; i++) {\n\n            RateControlEntry *rce = &rcc->entry[i];\n\n\n\n            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n\n            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n\n            rce->misc_bits  = s->mb_num + 10;\n\n            rce->mb_var_sum = s->mb_num * 100;\n\n        }\n\n\n\n        /* read stats */\n\n        p = s->avctx->stats_in;\n\n        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n\n            RateControlEntry *rce;\n\n            int picture_number;\n\n            int e;\n\n            char *next;\n\n\n\n            next = strchr(p, ';');\n\n            if (next) {\n\n                (*next) = 0; // sscanf in unbelievably slow on looong strings // FIXME copy / do not write\n\n                next++;\n\n            }\n\n            e = sscanf(p, \" in:%d \", &picture_number);\n\n\n\n            assert(picture_number >= 0);\n\n            assert(picture_number < rcc->num_entries);\n\n            rce = &rcc->entry[picture_number];\n\n\n\n            e += sscanf(p, \" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d\",\n\n                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,\n\n                        &rce->mv_bits, &rce->misc_bits,\n\n                        &rce->f_code, &rce->b_code,\n\n                        &rce->mc_mb_var_sum, &rce->mb_var_sum,\n\n                        &rce->i_count, &rce->skip_count, &rce->header_bits);\n\n            if (e != 14) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"statistics are damaged at line %d, parser out=%d\\n\",\n\n                       i, e);\n\n                return -1;\n\n            }\n\n\n\n            p = next;\n\n        }\n\n\n\n        if (init_pass2(s) < 0)\n\n            return -1;\n\n\n\n        // FIXME maybe move to end\n\n        if ((s->avctx->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n\n#if CONFIG_LIBXVID\n\n            return ff_xvid_rate_control_init(s);\n\n#else\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Xvid ratecontrol requires libavcodec compiled with Xvid support.\\n\");\n\n            return -1;\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (!(s->avctx->flags & CODEC_FLAG_PASS2)) {\n\n        rcc->short_term_qsum   = 0.001;\n\n        rcc->short_term_qcount = 0.001;\n\n\n\n        rcc->pass1_rc_eq_output_sum = 0.001;\n\n        rcc->pass1_wanted_bits      = 0.001;\n\n\n\n        if (s->avctx->qblur > 1.0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"qblur too large\\n\");\n\n            return -1;\n\n        }\n\n        /* init stuff with the user specified complexity */\n\n        if (s->rc_initial_cplx) {\n\n            for (i = 0; i < 60 * 30; i++) {\n\n                double bits = s->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;\n\n                RateControlEntry rce;\n\n\n\n                if (i % ((s->gop_size + 3) / 4) == 0)\n\n                    rce.pict_type = AV_PICTURE_TYPE_I;\n\n                else if (i % (s->max_b_frames + 1))\n\n                    rce.pict_type = AV_PICTURE_TYPE_B;\n\n                else\n\n                    rce.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n                rce.new_pict_type = rce.pict_type;\n\n                rce.mc_mb_var_sum = bits * s->mb_num / 100000;\n\n                rce.mb_var_sum    = s->mb_num;\n\n\n\n                rce.qscale    = FF_QP2LAMBDA * 2;\n\n                rce.f_code    = 2;\n\n                rce.b_code    = 1;\n\n                rce.misc_bits = 1;\n\n\n\n                if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n                    rce.i_count    = s->mb_num;\n\n                    rce.i_tex_bits = bits;\n\n                    rce.p_tex_bits = 0;\n\n                    rce.mv_bits    = 0;\n\n                } else {\n\n                    rce.i_count    = 0; // FIXME we do know this approx\n\n                    rce.i_tex_bits = 0;\n\n                    rce.p_tex_bits = bits * 0.9;\n\n                    rce.mv_bits    = bits * 0.1;\n\n                }\n\n                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n\n                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n\n                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n\n                rcc->frame_count[rce.pict_type]++;\n\n\n\n                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);\n\n\n\n                // FIXME misbehaves a little for variable fps\n\n                rcc->pass1_wanted_bits += s->bit_rate / (1 / av_q2d(s->avctx->time_base));\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 186}
{"project": "FFmpeg", "commit_id": "e87a501e7d03ac68b58520108fe24ad9d0b36765", "target": 0, "func": "av_cold void ff_sws_init_swscale_x86(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_MMX_INLINE\n\n    if (INLINE_MMX(cpu_flags))\n\n        sws_init_swscale_mmx(c);\n\n#endif\n\n#if HAVE_MMXEXT_INLINE\n\n    if (INLINE_MMXEXT(cpu_flags))\n\n        sws_init_swscale_mmxext(c);\n\n#endif\n\n\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case AV_PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmxext, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YA8:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmxext, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YA8:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 187}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static void libopus_write_header(AVCodecContext *avctx, int stream_count,\n\n                                 int coupled_stream_count,\n\n                                 const uint8_t *channel_mapping)\n\n{\n\n    uint8_t *p   = avctx->extradata;\n\n    int channels = avctx->channels;\n\n\n\n    bytestream_put_buffer(&p, \"OpusHead\", 8);\n\n    bytestream_put_byte(&p, 1); /* Version */\n\n    bytestream_put_byte(&p, channels);\n\n    bytestream_put_le16(&p, avctx->delay); /* Lookahead samples at 48kHz */\n\n    bytestream_put_le32(&p, avctx->sample_rate); /* Original sample rate */\n\n    bytestream_put_le16(&p, 0); /* Gain of 0dB is recommended. */\n\n\n\n    /* Channel mapping */\n\n    if (channels > 2) {\n\n        bytestream_put_byte(&p, channels <= 8 ? 1 : 255);\n\n        bytestream_put_byte(&p, stream_count);\n\n        bytestream_put_byte(&p, coupled_stream_count);\n\n        bytestream_put_buffer(&p, channel_mapping, channels);\n\n    } else {\n\n        bytestream_put_byte(&p, 0);\n\n    }\n\n}\n", "idx": 189}
{"project": "FFmpeg", "commit_id": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea", "target": 0, "func": "static int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n#if 1\n\n    int frame_duration = av_rescale(track->timescale, track->enc->time_base.num, track->enc->time_base.den);\n\n    int nb_frames = ROUNDED_DIV(track->enc->time_base.den, track->enc->time_base.num);\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    if (nb_frames > 255) {\n\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n\n    avio_wb32(pb, 0);                       /* Reserved */\n\n    avio_wb32(pb, 1);                       /* Data reference index */\n\n    avio_wb32(pb, 0);                       /* Flags */\n\n    avio_wb32(pb, track->timecode_flags);   /* Flags (timecode) */\n\n    avio_wb32(pb, track->timescale);        /* Timescale */\n\n    avio_wb32(pb, frame_duration);          /* Frame duration */\n\n    avio_w8(pb, nb_frames);                 /* Number of frames */\n\n    avio_w8(pb, 0);                         /* Reserved */\n\n\n\n    if (track->st)\n\n        t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n\n\n\n    if (t && utf8len(t->value))\n\n        mov_write_source_reference_tag(pb, track, t->value);\n\n    else\n\n        avio_wb16(pb, 0); /* zero size */\n\n#else\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n\n    avio_wb32(pb, 0);                       /* Reserved */\n\n    avio_wb32(pb, 1);                       /* Data reference index */\n\n    if (track->enc->extradata_size)\n\n        avio_write(pb, track->enc->extradata, track->enc->extradata_size);\n\n#endif\n\n    return update_size(pb, pos);\n\n}\n", "idx": 190}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static void dv_decode_ac(DVVideoDecodeContext *s, \n\n                         BlockInfo *mb, DCTELEM *block, int last_index)\n\n{\n\n    int last_re_index;\n\n    int shift_offset = mb->shift_offset;\n\n    const UINT8 *scan_table = mb->scan_table;\n\n    const UINT8 *shift_table = mb->shift_table;\n\n    int pos = mb->pos;\n\n    int level, pos1, sign, run;\n\n    int partial_bit_count;\n\n\n\n    OPEN_READER(re, &s->gb);\n\n    \n\n#ifdef VLC_DEBUG\n\n    printf(\"start\\n\");\n\n#endif\n\n\n\n    /* if we must parse a partial vlc, we do it here */\n\n    partial_bit_count = mb->partial_bit_count;\n\n    if (partial_bit_count > 0) {\n\n        UINT8 buf[4];\n\n        UINT32 v;\n\n        int l, l1;\n\n        GetBitContext gb1;\n\n\n\n        /* build the dummy bit buffer */\n\n        l = 16 - partial_bit_count;\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"show=%04x\\n\", SHOW_UBITS(re, &s->gb, 16));\n\n#endif\n\n        v = (mb->partial_bit_buffer << l) | SHOW_UBITS(re, &s->gb, l);\n\n        buf[0] = v >> 8;\n\n        buf[1] = v;\n\n#ifdef VLC_DEBUG\n\n        printf(\"v=%04x cnt=%d %04x\\n\", \n\n               v, partial_bit_count, (mb->partial_bit_buffer << l));\n\n#endif\n\n        /* try to read the codeword */\n\n        init_get_bits(&gb1, buf, 4);\n\n        {\n\n            OPEN_READER(re1, &gb1);\n\n            UPDATE_CACHE(re1, &gb1);\n\n            GET_RL_VLC(level, run, re1, &gb1, dv_rl_vlc[0], \n\n                       TEX_VLC_BITS, 2);\n\n            l = re1_index;\n\n            CLOSE_READER(re1, &gb1);\n\n        }\n\n#ifdef VLC_DEBUG\n\n        printf(\"****run=%d level=%d size=%d\\n\", run, level, l);\n\n#endif\n\n        /* compute codeword length */\n\n        l1 = (level != 256 && level != 0);\n\n        /* if too long, we cannot parse */\n\n        l -= partial_bit_count;\n\n        if ((re_index + l + l1) > last_index)\n\n            return;\n\n        /* skip read bits */\n\n        last_re_index = 0; /* avoid warning */\n\n        re_index += l;\n\n        /* by definition, if we can read the vlc, all partial bits\n\n           will be read (otherwise we could have read the vlc before) */\n\n        mb->partial_bit_count = 0;\n\n        UPDATE_CACHE(re, &s->gb);\n\n        goto handle_vlc;\n\n    }\n\n\n\n    /* get the AC coefficients until last_index is reached */\n\n    for(;;) {\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"%2d: bits=%04x index=%d\\n\", \n\n               pos, SHOW_UBITS(re, &s->gb, 16), re_index);\n\n#endif\n\n        last_re_index = re_index;\n\n        GET_RL_VLC(level, run, re, &s->gb, dv_rl_vlc[0], \n\n                   TEX_VLC_BITS, 2);\n\n    handle_vlc:\n\n#ifdef VLC_DEBUG\n\n        printf(\"run=%d level=%d\\n\", run, level);\n\n#endif\n\n        if (level == 256) {\n\n            if (re_index > last_index) {\n\n            cannot_read:\n\n                /* put position before read code */\n\n                re_index = last_re_index;\n\n                mb->eob_reached = 0;\n\n                break;\n\n            }\n\n            /* EOB */\n\n            mb->eob_reached = 1;\n\n            break;\n\n        } else if (level != 0) {\n\n            if ((re_index + 1) > last_index)\n\n                goto cannot_read;\n\n            sign = SHOW_SBITS(re, &s->gb, 1);\n\n            level = (level ^ sign) - sign;\n\n            LAST_SKIP_BITS(re, &s->gb, 1);\n\n            pos += run;\n\n            /* error */\n\n            if (pos >= 64) {\n\n                goto read_error;\n\n            }\n\n            pos1 = scan_table[pos];\n\n            level = level << (shift_table[pos1] + shift_offset);\n\n            block[pos1] = level;\n\n            //            printf(\"run=%d level=%d shift=%d\\n\", run, level, shift_table[pos1]);\n\n        } else {\n\n            if (re_index > last_index)\n\n                goto cannot_read;\n\n            /* level is zero: means run without coding. No\n\n               sign is coded */\n\n            pos += run;\n\n            /* error */\n\n            if (pos >= 64) {\n\n            read_error:\n\n#if defined(VLC_DEBUG) || 1\n\n                printf(\"error pos=%d\\n\", pos);\n\n#endif\n\n                /* for errors, we consider the eob is reached */\n\n                mb->eob_reached = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n    mb->pos = pos;\n\n}\n", "idx": 191}
{"project": "FFmpeg", "commit_id": "a050cf0c451bdf1c1bd512c4fce6b6f8a5e85102", "target": 0, "func": "static int expand_rle_row16(SgiState *s, uint16_t *out_buf,\n\n                            int len, int pixelstride)\n\n{\n\n    unsigned short pixel;\n\n    unsigned char count;\n\n    unsigned short *orig = out_buf;\n\n    uint16_t *out_end = out_buf + len;\n\n\n\n    while (out_buf < out_end) {\n\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n\n            return AVERROR_INVALIDDATA;\n\n        pixel = bytestream2_get_be16u(&s->g);\n\n        if (!(count = (pixel & 0x7f)))\n\n            break;\n\n\n\n        /* Check for buffer overflow. */\n\n        if (pixelstride * (count - 1) >= len) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid pixel count.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (pixel & 0x80) {\n\n            while (count--) {\n\n                pixel = bytestream2_get_ne16(&s->g);\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        } else {\n\n            pixel = bytestream2_get_ne16(&s->g);\n\n\n\n            while (count--) {\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        }\n\n    }\n\n    return (out_buf - orig) / pixelstride;\n\n}\n", "idx": 192}
{"project": "qemu", "commit_id": "6e19a1379d3d12c2d8f934aa8154037a609f4507", "target": 1, "func": "void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,\n\n              void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    saved_env = env;\n\n\n    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc);\n\n            }\n\n        }\n\n        raise_exception(env->exception_index);\n\n    }\n\n    env = saved_env;\n\n}", "idx": 193}
{"project": "FFmpeg", "commit_id": "b0517467c0b60b9e9e1a660859727e1f512c70d0", "target": 1, "func": "static int webvtt_read_header(AVFormatContext *s)\n\n{\n\n    WebVTTContext *webvtt = s->priv_data;\n\n    AVBPrint header, cue;\n\n    int res = 0;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    st->codec->codec_id   = AV_CODEC_ID_WEBVTT;\n\n    st->disposition |= webvtt->kind;\n\n\n\n    av_bprint_init(&header, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    av_bprint_init(&cue,    0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    for (;;) {\n\n        int i;\n\n        int64_t pos;\n\n        AVPacket *sub;\n\n        const char *p, *identifier, *settings;\n\n        int identifier_len, settings_len;\n\n        int64_t ts_start, ts_end;\n\n\n\n        ff_subtitles_read_chunk(s->pb, &cue);\n\n\n\n        if (!cue.len)\n\n            break;\n\n\n\n        p = identifier = cue.str;\n\n        pos = avio_tell(s->pb);\n\n\n\n        /* ignore header chunk */\n\n        if (!strncmp(p, \"\\xEF\\xBB\\xBFWEBVTT\", 9) ||\n\n            !strncmp(p, \"WEBVTT\", 6))\n\n            continue;\n\n\n\n        /* optional cue identifier (can be a number like in SRT or some kind of\n\n         * chaptering id) */\n\n        for (i = 0; p[i] && p[i] != '\\n' && p[i] != '\\r'; i++) {\n\n            if (!strncmp(p + i, \"-->\", 3)) {\n\n                identifier = NULL;\n\n                break;\n\n            }\n\n        }\n\n        if (!identifier)\n\n            identifier_len = 0;\n\n        else {\n\n            identifier_len = strcspn(p, \"\\r\\n\");\n\n            p += identifier_len;\n\n            if (*p == '\\r')\n\n                p++;\n\n            if (*p == '\\n')\n\n                p++;\n\n        }\n\n\n\n        /* cue timestamps */\n\n        if ((ts_start = read_ts(p)) == AV_NOPTS_VALUE)\n\n            break;\n\n        if (!(p = strstr(p, \"-->\")))\n\n            break;\n\n        p += 3;\n\n        do p++; while (*p == ' ' || *p == '\\t');\n\n        if ((ts_end = read_ts(p)) == AV_NOPTS_VALUE)\n\n            break;\n\n\n\n        /* optional cue settings */\n\n        p += strcspn(p, \"\\n\\t \");\n\n        while (*p == '\\t' || *p == ' ')\n\n            p++;\n\n        settings = p;\n\n        settings_len = strcspn(p, \"\\r\\n\");\n\n        p += settings_len;\n\n        if (*p == '\\r')\n\n            p++;\n\n        if (*p == '\\n')\n\n            p++;\n\n\n\n        /* create packet */\n\n        sub = ff_subtitles_queue_insert(&webvtt->q, p, strlen(p), 0);\n\n        if (!sub) {\n\n            res = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        sub->pos = pos;\n\n        sub->pts = ts_start;\n\n        sub->duration = ts_end - ts_start;\n\n\n\n#define SET_SIDE_DATA(name, type) do {                                  \\\n\n    if (name##_len) {                                                   \\\n\n        uint8_t *buf = av_packet_new_side_data(sub, type, name##_len);  \\\n\n        if (!buf) {                                                     \\\n\n            res = AVERROR(ENOMEM);                                      \\\n\n            goto end;                                                   \\\n\n        }                                                               \\\n\n        memcpy(buf, name, name##_len);                                  \\\n\n    }                                                                   \\\n\n} while (0)\n\n\n\n        SET_SIDE_DATA(identifier, AV_PKT_DATA_WEBVTT_IDENTIFIER);\n\n        SET_SIDE_DATA(settings,   AV_PKT_DATA_WEBVTT_SETTINGS);\n\n    }\n\n\n\n    ff_subtitles_queue_finalize(&webvtt->q);\n\n\n\nend:\n\n    av_bprint_finalize(&cue,    NULL);\n\n    av_bprint_finalize(&header, NULL);\n\n    return res;\n\n}\n", "idx": 194}
{"project": "FFmpeg", "commit_id": "a7cfef2994d3ceeafb056050533addcd45c32b6a", "target": 0, "func": "int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){\n\n    MpegEncContext * const s = &h->s;\n\n    unsigned int pps_id= get_ue_golomb(&s->gb);\n\n    PPS *pps;\n\n    const int qp_bd_offset = 6*(h->sps.bit_depth_luma-8);\n\n    int bits_left;\n\n\n\n    if(pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"pps_id (%d) out of range\\n\", pps_id);\n\n        return -1;\n\n    }\n\n\n\n    pps= av_mallocz(sizeof(PPS));\n\n    if(pps == NULL)\n\n        return -1;\n\n    pps->sps_id= get_ue_golomb_31(&s->gb);\n\n    if((unsigned)pps->sps_id>=MAX_SPS_COUNT || h->sps_buffers[pps->sps_id] == NULL){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"sps_id out of range\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    pps->cabac= get_bits1(&s->gb);\n\n    pps->pic_order_present= get_bits1(&s->gb);\n\n    pps->slice_group_count= get_ue_golomb(&s->gb) + 1;\n\n    if(pps->slice_group_count > 1 ){\n\n        pps->mb_slice_group_map_type= get_ue_golomb(&s->gb);\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n\n        switch(pps->mb_slice_group_map_type){\n\n        case 0:\n\n#if 0\n\n|   for( i = 0; i <= num_slice_groups_minus1; i++ ) |   |        |\n\n|    run_length[ i ]                                |1  |ue(v)   |\n\n#endif\n\n            break;\n\n        case 2:\n\n#if 0\n\n|   for( i = 0; i < num_slice_groups_minus1; i++ )  |   |        |\n\n|{                                                  |   |        |\n\n|    top_left_mb[ i ]                               |1  |ue(v)   |\n\n|    bottom_right_mb[ i ]                           |1  |ue(v)   |\n\n|   }                                               |   |        |\n\n#endif\n\n            break;\n\n        case 3:\n\n        case 4:\n\n        case 5:\n\n#if 0\n\n|   slice_group_change_direction_flag               |1  |u(1)    |\n\n|   slice_group_change_rate_minus1                  |1  |ue(v)   |\n\n#endif\n\n            break;\n\n        case 6:\n\n#if 0\n\n|   slice_group_id_cnt_minus1                       |1  |ue(v)   |\n\n|   for( i = 0; i <= slice_group_id_cnt_minus1; i++ |   |        |\n\n|)                                                  |   |        |\n\n|    slice_group_id[ i ]                            |1  |u(v)    |\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n    pps->ref_count[0]= get_ue_golomb(&s->gb) + 1;\n\n    pps->ref_count[1]= get_ue_golomb(&s->gb) + 1;\n\n    if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    pps->weighted_pred= get_bits1(&s->gb);\n\n    pps->weighted_bipred_idc= get_bits(&s->gb, 2);\n\n    pps->init_qp= get_se_golomb(&s->gb) + 26 + qp_bd_offset;\n\n    pps->init_qs= get_se_golomb(&s->gb) + 26 + qp_bd_offset;\n\n    pps->chroma_qp_index_offset[0]= get_se_golomb(&s->gb);\n\n    pps->deblocking_filter_parameters_present= get_bits1(&s->gb);\n\n    pps->constrained_intra_pred= get_bits1(&s->gb);\n\n    pps->redundant_pic_cnt_present = get_bits1(&s->gb);\n\n\n\n    pps->transform_8x8_mode= 0;\n\n    h->dequant_coeff_pps= -1; //contents of sps/pps can change even if id doesn't, so reinit\n\n    memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n\n    memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n\n\n\n    bits_left = bit_length - get_bits_count(&s->gb);\n\n    if(bits_left > 0){\n\n        pps->transform_8x8_mode= get_bits1(&s->gb);\n\n        decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n\n        pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset\n\n    } else {\n\n        pps->chroma_qp_index_offset[1]= pps->chroma_qp_index_offset[0];\n\n    }\n\n\n\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], h->sps.bit_depth_luma);\n\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], h->sps.bit_depth_luma);\n\n    if(pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n\n        pps->chroma_qp_diff= 1;\n\n\n\n    if(s->avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"pps:%u sps:%u %s slice_groups:%d ref:%d/%d %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n\n               pps_id, pps->sps_id,\n\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n\n               pps->slice_group_count,\n\n               pps->ref_count[0], pps->ref_count[1],\n\n               pps->weighted_pred ? \"weighted\" : \"\",\n\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\"\n\n               );\n\n    }\n\n\n\n    av_free(h->pps_buffers[pps_id]);\n\n    h->pps_buffers[pps_id]= pps;\n\n    return 0;\n\nfail:\n\n    av_free(pps);\n\n    return -1;\n\n}\n", "idx": 195}
{"project": "FFmpeg", "commit_id": "6571e41dcdee4655237bca0a3277df8976167aee", "target": 1, "func": "static int load_input_picture(MpegEncContext *s, AVFrame *pic_arg){\n\n    AVFrame *pic=NULL;\n\n    int i;\n\n    const int encoding_delay= s->max_b_frames;\n\n    int direct=1;\n\n    \n\n  if(pic_arg){\n\n    if(encoding_delay && !(s->flags&CODEC_FLAG_INPUT_PRESERVED)) direct=0;\n\n    if(pic_arg->linesize[0] != s->linesize) direct=0;\n\n    if(pic_arg->linesize[1] != s->uvlinesize) direct=0;\n\n    if(pic_arg->linesize[2] != s->uvlinesize) direct=0;\n\n  \n\n//    printf(\"%d %d %d %d\\n\",pic_arg->linesize[0], pic_arg->linesize[1], s->linesize, s->uvlinesize);\n\n    \n\n    if(direct){\n\n        i= find_unused_picture(s, 1);\n\n\n\n        pic= (AVFrame*)&s->picture[i];\n\n        pic->reference= 3;\n\n    \n\n        for(i=0; i<4; i++){\n\n            pic->data[i]= pic_arg->data[i];\n\n            pic->linesize[i]= pic_arg->linesize[i];\n\n        }\n\n        alloc_picture(s, (Picture*)pic, 1);\n\n    }else{\n\n        i= find_unused_picture(s, 0);\n\n\n\n        pic= (AVFrame*)&s->picture[i];\n\n        pic->reference= 3;\n\n\n\n        alloc_picture(s, (Picture*)pic, 0);\n\n        for(i=0; i<4; i++){\n\n            /* the input will be 16 pixels to the right relative to the actual buffer start\n\n             * and the current_pic, so the buffer can be reused, yes its not beatifull \n\n             */\n\n            pic->data[i]+= 16; \n\n        }\n\n\n\n        if(   pic->data[0] == pic_arg->data[0] \n\n           && pic->data[1] == pic_arg->data[1]\n\n           && pic->data[2] == pic_arg->data[2]){\n\n       // empty\n\n        }else{\n\n            int h_chroma_shift, v_chroma_shift;\n\n            avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &h_chroma_shift, &v_chroma_shift);\n\n        \n\n            for(i=0; i<3; i++){\n\n                int src_stride= pic_arg->linesize[i];\n\n                int dst_stride= i ? s->uvlinesize : s->linesize;\n\n                int h_shift= i ? h_chroma_shift : 0;\n\n                int v_shift= i ? v_chroma_shift : 0;\n\n                int w= s->width >>h_shift;\n\n                int h= s->height>>v_shift;\n\n                uint8_t *src= pic_arg->data[i];\n\n                uint8_t *dst= pic->data[i];\n\n            \n\n                if(src_stride==dst_stride)\n\n                    memcpy(dst, src, src_stride*h);\n\n                else{\n\n                    while(h--){\n\n                        memcpy(dst, src, w);\n\n                        dst += dst_stride;\n\n                        src += src_stride;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pic->quality= pic_arg->quality;\n\n    pic->pict_type= pic_arg->pict_type;\n\n    pic->pts = pic_arg->pts;\n\n    \n\n    if(s->input_picture[encoding_delay])\n\n        pic->display_picture_number= s->input_picture[encoding_delay]->display_picture_number + 1;\n\n    \n\n  }\n\n\n\n    /* shift buffer entries */\n\n    for(i=1; i<MAX_PICTURE_COUNT /*s->encoding_delay+1*/; i++)\n\n        s->input_picture[i-1]= s->input_picture[i];\n\n        \n\n    s->input_picture[encoding_delay]= (Picture*)pic;\n\n\n\n    return 0;\n\n}\n", "idx": 196}
{"project": "FFmpeg", "commit_id": "20c86571ccc71412781d4a4813e4693e0c42aec6", "target": 1, "func": "int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)\n\n{\n\n    BufferSinkContext *s    = ctx->priv;\n\n    AVFilterLink      *link = ctx->inputs[0];\n\n    int ret;\n\n\n\n    if ((ret = ff_request_frame(link)) < 0)\n\n        return ret;\n\n\n\n    if (!s->cur_frame)\n\n        return AVERROR(EINVAL);\n\n\n\n    av_frame_move_ref(frame, s->cur_frame);\n\n    av_frame_free(&s->cur_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 197}
{"project": "qemu", "commit_id": "cf5f7937b05c84d5565134f058c00cd48304a117", "target": 1, "func": "static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value,\n\n                        MemTxAttrs attrs)\n\n{\n\n    ARMCPU *cpu = s->cpu;\n\n\n\n    switch (offset) {\n\n    case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */\n\n    {\n\n        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ;\n\n        int i;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            break;\n\n        }\n\n        for (i = 0; i < 32 && startvec + i < s->num_irq; i++) {\n\n            s->itns[startvec + i] = (value >> i) & 1;\n\n        }\n\n        nvic_irq_update(s);\n\n        break;\n\n    }\n\n    case 0xd04: /* Interrupt Control State (ICSR) */\n\n        if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n            if (value & (1 << 31)) {\n\n                armv7m_nvic_set_pending(s, ARMV7M_EXCP_NMI, false);\n\n            } else if (value & (1 << 30) &&\n\n                       arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* PENDNMICLR didn't exist in v7M */\n\n                armv7m_nvic_clear_pending(s, ARMV7M_EXCP_NMI, false);\n\n            }\n\n        }\n\n        if (value & (1 << 28)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        } else if (value & (1 << 27)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        }\n\n        if (value & (1 << 26)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        } else if (value & (1 << 25)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        }\n\n        break;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu->env.v7m.vecbase[attrs.secure] = value & 0xffffff80;\n\n        break;\n\n    case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */\n\n        if ((value >> R_V7M_AIRCR_VECTKEY_SHIFT) == 0x05fa) {\n\n            if (value & R_V7M_AIRCR_SYSRESETREQ_MASK) {\n\n                if (attrs.secure ||\n\n                    !(cpu->env.v7m.aircr & R_V7M_AIRCR_SYSRESETREQS_MASK)) {\n\n                    qemu_irq_pulse(s->sysresetreq);\n\n                }\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTCLRACTIVE_MASK) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTCLRACTIVE when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTRESET_MASK) {\n\n                /* NB: this bit is RES0 in v8M */\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTRESET when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            s->prigroup[attrs.secure] = extract32(value,\n\n                                                  R_V7M_AIRCR_PRIGROUP_SHIFT,\n\n                                                  R_V7M_AIRCR_PRIGROUP_LENGTH);\n\n            if (attrs.secure) {\n\n                /* These bits are only writable by secure */\n\n                cpu->env.v7m.aircr = value &\n\n                    (R_V7M_AIRCR_SYSRESETREQS_MASK |\n\n                     R_V7M_AIRCR_BFHFNMINS_MASK |\n\n                     R_V7M_AIRCR_PRIS_MASK);\n\n                /* BFHFNMINS changes the priority of Secure HardFault, and\n\n                 * allows a pending Non-secure HardFault to preempt (which\n\n                 * we implement by marking it enabled).\n\n                 */\n\n                if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -3;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 1;\n\n                } else {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -1;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 0;\n\n                }\n\n            }\n\n            nvic_irq_update(s);\n\n        }\n\n        break;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement control registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"NVIC: SCR unimplemented\\n\");\n\n        break;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* Enforce RAZ/WI on reserved and must-RAZ/WI bits */\n\n        value &= (R_V7M_CCR_STKALIGN_MASK |\n\n                  R_V7M_CCR_BFHFNMIGN_MASK |\n\n                  R_V7M_CCR_DIV_0_TRP_MASK |\n\n                  R_V7M_CCR_UNALIGN_TRP_MASK |\n\n                  R_V7M_CCR_USERSETMPEND_MASK |\n\n                  R_V7M_CCR_NONBASETHRDENA_MASK);\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* v8M makes NONBASETHRDENA and STKALIGN be RES1 */\n\n            value |= R_V7M_CCR_NONBASETHRDENA_MASK\n\n                | R_V7M_CCR_STKALIGN_MASK;\n\n        }\n\n        if (attrs.secure) {\n\n            /* the BFHFNMIGN bit is not banked; keep that in the NS copy */\n\n            cpu->env.v7m.ccr[M_REG_NS] =\n\n                (cpu->env.v7m.ccr[M_REG_NS] & ~R_V7M_CCR_BFHFNMIGN_MASK)\n\n                | (value & R_V7M_CCR_BFHFNMIGN_MASK);\n\n            value &= ~R_V7M_CCR_BFHFNMIGN_MASK;\n\n        }\n\n\n\n        cpu->env.v7m.ccr[attrs.secure] = value;\n\n        break;\n\n    case 0xd24: /* System Handler Control and State (SHCSR) */\n\n        if (attrs.secure) {\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            /* Secure HardFault active bit cannot be written */\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_PENDSV].active =\n\n                (value & (1 << 10)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SYSTICK].active =\n\n                (value & (1 << 11)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].pending =\n\n                (value & (1 << 12)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].enabled =\n\n                (value & (1 << 18)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            /* SecureFault not banked, but RAZ/WI to NS */\n\n            s->vectors[ARMV7M_EXCP_SECURE].active = (value & (1 << 4)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].enabled = (value & (1 << 19)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].pending = (value & (1 << 20)) != 0;\n\n        } else {\n\n            s->vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* HARDFAULTPENDED is not present in v7M */\n\n                s->vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            }\n\n            s->vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->vectors[ARMV7M_EXCP_PENDSV].active = (value & (1 << 10)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SYSTICK].active = (value & (1 << 11)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].pending = (value & (1 << 12)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].enabled = (value & (1 << 18)) != 0;\n\n        }\n\n        if (attrs.secure || (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK)) {\n\n            s->vectors[ARMV7M_EXCP_BUS].active = (value & (1 << 1)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].pending = (value & (1 << 14)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n        }\n\n        /* NMIACT can only be written if the write is of a zero, with\n\n         * BFHFNMINS 1, and by the CPU in secure state via the NS alias.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 5)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_NMI].active = 0;\n\n        }\n\n        /* HARDFAULTACT can only be written if the write is of a zero\n\n         * to the non-secure HardFault state by the CPU in secure state.\n\n         * The only case where we can be targeting the non-secure HF state\n\n         * when in secure state is if this is a write via the NS alias\n\n         * and BFHFNMINS is 1.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 2)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_HARD].active = 0;\n\n        }\n\n\n\n        /* TODO: this is RAZ/WI from NS if DEMCR.SDME is set */\n\n        s->vectors[ARMV7M_EXCP_DEBUG].active = (value & (1 << 8)) != 0;\n\n        nvic_irq_update(s);\n\n        break;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        cpu->env.v7m.cfsr[attrs.secure] &= ~value; /* W1C */\n\n        if (attrs.secure) {\n\n            /* The BFSR bits [15:8] are shared between security states\n\n             * and we store them in the NS copy.\n\n             */\n\n            cpu->env.v7m.cfsr[M_REG_NS] &= ~(value & R_V7M_CFSR_BFSR_MASK);\n\n        }\n\n        break;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n        cpu->env.v7m.hfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd30: /* Debug Fault Status.  */\n\n        cpu->env.v7m.dfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd34: /* Mem Manage Address.  */\n\n        cpu->env.v7m.mmfar[attrs.secure] = value;\n\n        return;\n\n    case 0xd38: /* Bus Fault Address.  */\n\n        cpu->env.v7m.bfar = value;\n\n        return;\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"NVIC: Aux fault status registers unimplemented\\n\");\n\n        break;\n\n    case 0xd90: /* MPU_TYPE */\n\n        return; /* RO */\n\n    case 0xd94: /* MPU_CTRL */\n\n        if ((value &\n\n             (R_V7M_MPU_CTRL_HFNMIENA_MASK | R_V7M_MPU_CTRL_ENABLE_MASK))\n\n            == R_V7M_MPU_CTRL_HFNMIENA_MASK) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU_CTRL: HFNMIENA and !ENABLE is \"\n\n                          \"UNPREDICTABLE\\n\");\n\n        }\n\n        cpu->env.v7m.mpu_ctrl[attrs.secure]\n\n            = value & (R_V7M_MPU_CTRL_ENABLE_MASK |\n\n                       R_V7M_MPU_CTRL_HFNMIENA_MASK |\n\n                       R_V7M_MPU_CTRL_PRIVDEFENA_MASK);\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    case 0xd98: /* MPU_RNR */\n\n        if (value >= cpu->pmsav7_dregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->pmsav7_dregion);\n\n        } else {\n\n            cpu->env.pmsav7.rnr[attrs.secure] = value;\n\n        }\n\n        break;\n\n    case 0xd9c: /* MPU_RBAR */\n\n    case 0xda4: /* MPU_RBAR_A1 */\n\n    case 0xdac: /* MPU_RBAR_A2 */\n\n    case 0xdb4: /* MPU_RBAR_A3 */\n\n    {\n\n        int region;\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR, and there is no 'region' field in the\n\n             * RBAR register.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rbar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (value & (1 << 4)) {\n\n            /* VALID bit means use the region number specified in this\n\n             * value and also update MPU_RNR.REGION with that value.\n\n             */\n\n            region = extract32(value, 0, 4);\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"MPU region out of range %u/%\" PRIu32 \"\\n\",\n\n                              region, cpu->pmsav7_dregion);\n\n                return;\n\n            }\n\n            cpu->env.pmsav7.rnr[attrs.secure] = region;\n\n        } else {\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xda0: /* MPU_RASR (v7M), MPU_RLAR (v8M) */\n\n    case 0xda8: /* MPU_RASR_A1 (v7M), MPU_RLAR_A1 (v8M) */\n\n    case 0xdb0: /* MPU_RASR_A2 (v7M), MPU_RLAR_A2 (v8M) */\n\n    case 0xdb8: /* MPU_RASR_A3 (v7M), MPU_RLAR_A3 (v8M) */\n\n    {\n\n        int region = cpu->env.pmsav7.rnr[attrs.secure];\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rlar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drsr[region] = value & 0xff3f;\n\n        cpu->env.pmsav7.dracr[region] = (value >> 16) & 0x173f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xdc0: /* MPU_MAIR0 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair0[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdc4: /* MPU_MAIR1 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair1[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdd0: /* SAU_CTRL */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.sau.ctrl = value & 3;\n\n        break;\n\n    case 0xdd4: /* SAU_TYPE */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        break;\n\n    case 0xdd8: /* SAU_RNR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (value >= cpu->sau_sregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"SAU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->sau_sregion);\n\n        } else {\n\n            cpu->env.sau.rnr = value;\n\n        }\n\n        break;\n\n    case 0xddc: /* SAU_RBAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde0: /* SAU_RLAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rlar[region] = value & ~0x1c;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde4: /* SFSR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xde8: /* SFAR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr = value;\n\n        break;\n\n    case 0xf00: /* Software Triggered Interrupt Register */\n\n    {\n\n        int excnum = (value & 0x1ff) + NVIC_FIRST_IRQ;\n\n        if (excnum < s->num_irq) {\n\n            armv7m_nvic_set_pending(s, excnum, false);\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n    bad_offset:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"NVIC: Bad write offset 0x%x\\n\", offset);\n\n    }\n\n}\n", "idx": 198}
{"project": "qemu", "commit_id": "b55519a0f29fca0ef7ebc5d87ee4bfa7304dc219", "target": 1, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    sPAPRTCE *tcep;\n\n\n\n    if (ioba >= tcet->window_size) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-boards IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcep = tcet->table + (ioba >> SPAPR_TCE_PAGE_SHIFT);\n\n    tcep->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 199}
{"project": "qemu", "commit_id": "e0498daab50d42f3948fc5607683c971fe9416fd", "target": 1, "func": "static void gen_lq(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    int ra, rd;\n\n    TCGv EA;\n\n\n\n    /* Restore CPU state */\n\n    if (unlikely(ctx->mem_idx == 0)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    ra = rA(ctx->opcode);\n\n    rd = rD(ctx->opcode);\n\n    if (unlikely((rd & 1) || rd == ra)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        return;\n\n    }\n\n    if (unlikely(ctx->le_mode)) {\n\n        /* Little-endian mode is not handled */\n\n        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    EA = tcg_temp_new();\n\n    gen_addr_imm_index(ctx, EA, 0x0F);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);\n\n    gen_addr_add(ctx, EA, EA, 8);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n", "idx": 201}
{"project": "qemu", "commit_id": "8dea1dd406189dae6108104faf27f397835ae871", "target": 1, "func": "static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ESPState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);\n\n    DPRINTF(\"read reg[%d]: 0x%2.2x\\n\", saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                /* Data in/out.  */\n\n                fprintf(stderr, \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        // Clear interrupt/error status bits\n\n        s->rregs[ESP_RSTAT] &= ~(STAT_GE | STAT_PE);\n\n        esp_lower_irq(s);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n", "idx": 202}
{"project": "FFmpeg", "commit_id": "ad0193bf9cb258695a7f929954edd6e2e51de4d9", "target": 1, "func": "int av_vsrc_buffer_add_frame2(AVFilterContext *buffer_filter, AVFrame *frame,\n\n                              int64_t pts, AVRational pixel_aspect, int width,\n\n                              int height, enum PixelFormat  pix_fmt,\n\n                              const char *sws_param)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    int ret;\n\n\n\n    if (c->has_frame) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if(width != c->w || height != c->h || pix_fmt != c->pix_fmt){\n\n        AVFilterContext *scale= buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO, \"Changing filter graph input to accept %dx%d %d (%d %d)\\n\",\n\n               width,height,pix_fmt, c->pix_fmt, scale->outputs[0]->format);\n\n\n\n        if(!scale || strcmp(scale->filter->name,\"scale\")){\n\n            AVFilter *f= avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if(avfilter_open(&scale, f, \"Input equalizer\") < 0)\n\n                return -1;\n\n\n\n            if((ret=avfilter_init_filter(scale, sws_param, NULL))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if((ret=avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        }\n\n\n\n        c->pix_fmt= scale->inputs[0]->format= pix_fmt;\n\n        c->w= scale->inputs[0]->w= width;\n\n        c->h= scale->inputs[0]->h= height;\n\n\n\n        link= scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    memcpy(c->frame.data    , frame->data    , sizeof(frame->data));\n\n    memcpy(c->frame.linesize, frame->linesize, sizeof(frame->linesize));\n\n    c->frame.interlaced_frame= frame->interlaced_frame;\n\n    c->frame.top_field_first = frame->top_field_first;\n\n    c->frame.key_frame = frame->key_frame;\n\n    c->frame.pict_type = frame->pict_type;\n\n    c->pts = pts;\n\n    c->pixel_aspect = pixel_aspect;\n\n    c->has_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 203}
{"project": "qemu", "commit_id": "6c150fbd341ac10b8559abcfd5915cfff17b70c6", "target": 1, "func": "static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,\n\n                                         DeviceState *dev,\n\n                                         uint8_t **exp_cap, Error **errp)\n\n{\n\n    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;\n\n    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);\n\n\n\n    PCIE_DEV_PRINTF(PCI_DEVICE(dev), \"hotplug state: 0x%x\\n\", sltsta);\n\n    if (sltsta & PCI_EXP_SLTSTA_EIS) {\n\n        /* the slot is electromechanically locked.\n\n         * This error is propagated up to qdev and then to HMP/QMP.\n\n         */\n\n        error_setg_errno(errp, -EBUSY, \"slot is electromechanically locked\");\n\n    }\n\n}\n", "idx": 204}
{"project": "qemu", "commit_id": "0b9f0e2fd7c5070fa06cd6bd5ec69055e3a7d2b1", "target": 1, "func": "void qmp_getfd(const char *fdname, Error **errp)\n\n{\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_FD_NOT_SUPPLIED);\n\n        return;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                  \"a name not starting with a digit\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return;\n\n    }\n\n\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n\n    monfd->name = g_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n\n}", "idx": 205}
{"project": "qemu", "commit_id": "ad7f375df681503baa6ebef065818868e1216976", "target": 1, "func": "static void qmp_deserialize(void **native_out, void *datap,\n\n                            VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));\n\n    QObject *obj = qobject_from_json(qstring_get_str(output_json));\n\n\n\n    QDECREF(output_json);\n\n    d->qiv = qmp_input_visitor_new(obj);\n\n    qobject_decref(obj);\n\n    visit(qmp_input_get_visitor(d->qiv), native_out, errp);\n\n}\n", "idx": 206}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static bool coroutine_fn yield_and_check(BackupBlockJob *job)\n\n{\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    /* we need to yield so that bdrv_drain_all() returns.\n\n     * (without, VM does not reboot)\n\n     */\n\n    if (job->common.speed) {\n\n        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,\n\n                                                      job->sectors_read);\n\n        job->sectors_read = 0;\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n    } else {\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n    }\n\n\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 207}
{"project": "qemu", "commit_id": "3e32e8a96e6995cde3d8a13d68e31226ee83f290", "target": 1, "func": "static int virtio_scsi_do_tmf(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIDevice *d = virtio_scsi_device_find(s, req->req.tmf.lun);\n\n    SCSIRequest *r, *next;\n\n    BusChild *kid;\n\n    int target;\n\n    int ret = 0;\n\n\n\n    if (s->dataplane_started) {\n\n        assert(blk_get_aio_context(d->conf.blk) == s->ctx);\n\n    }\n\n    /* Here VIRTIO_SCSI_S_OK means \"FUNCTION COMPLETE\".  */\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_OK;\n\n\n\n    virtio_tswap32s(VIRTIO_DEVICE(s), &req->req.tmf.subtype);\n\n    switch (req->req.tmf.subtype) {\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            VirtIOSCSIReq *cmd_req = r->hba_private;\n\n            if (cmd_req && cmd_req->req.cmd.tag == req->req.tmf.tag) {\n\n                break;\n\n            }\n\n        }\n\n        if (r) {\n\n            /*\n\n             * Assert that the request has not been completed yet, we\n\n             * check for it in the loop above.\n\n             */\n\n            assert(r->hba_private);\n\n            if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK) {\n\n                /* \"If the specified command is present in the task set, then\n\n                 * return a service response set to FUNCTION SUCCEEDED\".\n\n                 */\n\n                req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n            } else {\n\n                VirtIOSCSICancelNotifier *notifier;\n\n\n\n                req->remaining = 1;\n\n                notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                notifier->tmf_req = req;\n\n                notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                scsi_req_cancel_async(r, &notifier->notifier);\n\n                ret = -EINPROGRESS;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        s->resetting++;\n\n        qdev_reset_all(&d->qdev);\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK_SET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n\n\n        /* Add 1 to \"remaining\" until virtio_scsi_do_tmf returns.\n\n         * This way, if the bus starts calling back to the notifiers\n\n         * even before we finish the loop, virtio_scsi_cancel_notify\n\n         * will not complete the TMF too early.\n\n         */\n\n        req->remaining = 1;\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            if (r->hba_private) {\n\n                if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK_SET) {\n\n                    /* \"If there is any command present in the task set, then\n\n                     * return a service response set to FUNCTION SUCCEEDED\".\n\n                     */\n\n                    req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n                    break;\n\n                } else {\n\n                    VirtIOSCSICancelNotifier *notifier;\n\n\n\n                    req->remaining++;\n\n                    notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                    notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                    notifier->tmf_req = req;\n\n                    scsi_req_cancel_async(r, &notifier->notifier);\n\n                }\n\n            }\n\n        }\n\n        if (--req->remaining > 0) {\n\n            ret = -EINPROGRESS;\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET:\n\n        target = req->req.tmf.lun[1];\n\n        s->resetting++;\n\n        QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n             d = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n             if (d->channel == 0 && d->id == target) {\n\n                qdev_reset_all(&d->qdev);\n\n             }\n\n        }\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_ACA:\n\n    default:\n\n        req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_REJECTED;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n\n\nincorrect_lun:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_INCORRECT_LUN;\n\n    return ret;\n\n\n\nfail:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_BAD_TARGET;\n\n    return ret;\n\n}\n", "idx": 208}
{"project": "FFmpeg", "commit_id": "26f6b8c571bcff7b325c7d6cc226c625dd465f8e", "target": 1, "func": "int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n", "idx": 209}
{"project": "qemu", "commit_id": "9bff5d8135fc3f37932d4177727d293aa93ce79b", "target": 1, "func": "int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,\n\n                            uint8_t bar_nr)\n\n{\n\n    int ret;\n\n    char *name;\n\n    uint32_t bar_size = 4096;\n\n    uint32_t bar_pba_offset = bar_size / 2;\n\n    uint32_t bar_pba_size = (nentries / 8 + 1) * 8;\n\n\n\n    /*\n\n     * Migration compatibility dictates that this remains a 4k\n\n     * BAR with the vector table in the lower half and PBA in\n\n     * the upper half for nentries which is lower or equal to 128.\n\n     * No need to care about using more than 65 entries for legacy\n\n     * machine types who has at most 64 queues.\n\n     */\n\n    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {\n\n        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;\n\n    }\n\n\n\n    if (bar_pba_offset + bar_pba_size > 4096) {\n\n        bar_size = bar_pba_offset + bar_pba_size;\n\n    }\n\n\n\n    if (bar_size & (bar_size - 1)) {\n\n        bar_size = 1 << qemu_fls(bar_size);\n\n    }\n\n\n\n    name = g_strdup_printf(\"%s-msix\", dev->name);\n\n    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);\n\n    g_free(name);\n\n\n\n    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,\n\n                    0, &dev->msix_exclusive_bar,\n\n                    bar_nr, bar_pba_offset,\n\n                    0);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &dev->msix_exclusive_bar);\n\n\n\n    return 0;\n\n}\n", "idx": 210}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}\n", "idx": 211}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void restore_native_fp_frstor(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    fp->fpuc = env->fpuc;\n\n    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    fptag = 0;\n\n    for (i=7; i>=0; i--) {\n\n\tfptag <<= 2;\n\n\tif (env->fptags[i]) {\n\n            fptag |= 3;\n\n        } else {\n\n            /* the FPU automatically computes it */\n\n        }\n\n    }\n\n    fp->fptag = fptag;\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    asm volatile (\"frstor %0\" : \"=m\" (*fp));\n\n}\n", "idx": 212}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    /* Should never happen.\n\n       We only end up here when an existing TB is too long.  */\n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    /* execute the generated code */\n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        /* Restore PC.  This may happen if async event occurs before\n\n           the TB starts executing.  */\n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}\n", "idx": 213}
{"project": "qemu", "commit_id": "41cbc23c5ca37a8b841915d7d252a02106d58b1e", "target": 0, "func": "static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr / 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}\n", "idx": 214}
{"project": "qemu", "commit_id": "8c6afa6ab158467d1938cc92022135bc7a872006", "target": 0, "func": "static void handle_2misc_fcmp_zero(DisasContext *s, int opcode,\n\n                                   bool is_scalar, bool is_u, bool is_q,\n\n                                   int size, int rn, int rd)\n\n{\n\n    bool is_double = (size == 3);\n\n    TCGv_ptr fpst = get_fpstatus_ptr();\n\n\n\n    if (is_double) {\n\n        TCGv_i64 tcg_op = tcg_temp_new_i64();\n\n        TCGv_i64 tcg_zero = tcg_const_i64(0);\n\n        TCGv_i64 tcg_res = tcg_temp_new_i64();\n\n        NeonGenTwoDoubleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fallthrough */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f64;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f64;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f64;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        for (pass = 0; pass < (is_scalar ? 1 : 2); pass++) {\n\n            read_vec_element(s, tcg_op, rn, pass, MO_64);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            write_vec_element(s, tcg_res, rd, pass, MO_64);\n\n        }\n\n        if (is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n\n\n        tcg_temp_free_i64(tcg_res);\n\n        tcg_temp_free_i64(tcg_zero);\n\n        tcg_temp_free_i64(tcg_op);\n\n    } else {\n\n        TCGv_i32 tcg_op = tcg_temp_new_i32();\n\n        TCGv_i32 tcg_zero = tcg_const_i32(0);\n\n        TCGv_i32 tcg_res = tcg_temp_new_i32();\n\n        NeonGenTwoSingleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass, maxpasses;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f32;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f32;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f32;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        if (is_scalar) {\n\n            maxpasses = 1;\n\n        } else {\n\n            maxpasses = is_q ? 4 : 2;\n\n        }\n\n\n\n        for (pass = 0; pass < maxpasses; pass++) {\n\n            read_vec_element_i32(s, tcg_op, rn, pass, MO_32);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            if (is_scalar) {\n\n                write_fp_sreg(s, rd, tcg_res);\n\n            } else {\n\n                write_vec_element_i32(s, tcg_res, rd, pass, MO_32);\n\n            }\n\n        }\n\n        tcg_temp_free_i32(tcg_res);\n\n        tcg_temp_free_i32(tcg_zero);\n\n        tcg_temp_free_i32(tcg_op);\n\n        if (!is_q && !is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n    }\n\n\n\n    tcg_temp_free_ptr(fpst);\n\n}\n", "idx": 215}
{"project": "FFmpeg", "commit_id": "2fa6d21124bd2fc0b186290f5313179263bfcfb7", "target": 0, "func": "static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)\n\n{\n\n    int w, w2, b, scale, first = 1;\n\n    int band_off = 0;\n\n\n\n    for (w = 0; w < c->num_windows; w++) {\n\n        if (!c->grouping[w]) {\n\n            memcpy(c->band_scales + band_off,\n\n                   c->band_scales + band_off - c->num_bands,\n\n                   c->num_bands * sizeof(*c->band_scales));\n\n            band_off += c->num_bands;\n\n            continue;\n\n        }\n\n        for (b = 0; b < c->num_bands; b++) {\n\n            if (!c->band_type[band_off]) {\n\n                int all_zero = 1;\n\n                for (w2 = w + 1; w2 < c->num_windows; w2++) {\n\n                    if (c->grouping[w2])\n\n                        break;\n\n                    if (c->band_type[w2 * c->num_bands + b]) {\n\n                        all_zero = 0;\n\n                        break;\n\n                    }\n\n                }\n\n                if (all_zero) {\n\n                    c->band_scales[band_off++] = 0;\n\n                    continue;\n\n                }\n\n            }\n\n            if (first) {\n\n                scale = get_bits(gb, 7);\n\n                first = 0;\n\n            } else {\n\n                scale += get_vlc2(gb, c->scale_diff.table, 9, 3) - 60;\n\n            }\n\n            if (scale < 0 || scale > 128) {\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Invalid scale value %d\\n\",\n\n                       scale);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            c->band_scales[band_off++] = c->scale_tab[scale];\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 216}
{"project": "FFmpeg", "commit_id": "4b370d6126ab74c6112e2c1edfad3f48ebcf08ad", "target": 0, "func": "static inline void writer_print_rational(WriterContext *wctx,\n\n                                         const char *key, AVRational q, char sep)\n\n{\n\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n\n    wctx->writer->print_string(wctx, key, buf.str);\n\n    wctx->nb_item++;\n\n}\n", "idx": 217}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,\n\n                          int flags, CPUWatchpoint **watchpoint)\n\n{\n\n    target_ulong len_mask = ~(len - 1);\n\n    CPUWatchpoint *wp;\n\n\n\n    /* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints */\n\n    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {\n\n        fprintf(stderr, \"qemu: tried to set invalid watchpoint at \"\n\n                TARGET_FMT_lx \", len=\" TARGET_FMT_lu \"\\n\", addr, len);\n\n        return -EINVAL;\n\n    }\n\n    wp = qemu_malloc(sizeof(*wp));\n\n\n\n    wp->vaddr = addr;\n\n    wp->len_mask = len_mask;\n\n    wp->flags = flags;\n\n\n\n    /* keep all GDB-injected watchpoints in front */\n\n    if (flags & BP_GDB)\n\n        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);\n\n    else\n\n        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);\n\n\n\n    tlb_flush_page(env, addr);\n\n\n\n    if (watchpoint)\n\n        *watchpoint = wp;\n\n    return 0;\n\n}\n", "idx": 219}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static off_t read_off(int fd, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (pread(fd, &buffer, 8, offset) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}\n", "idx": 220}
{"project": "qemu", "commit_id": "1a26f46692320f1981c95967e0d5af4443b5f0b1", "target": 0, "func": "void pc_machine_done(Notifier *notifier, void *data)\n\n{\n\n    PCMachineState *pcms = container_of(notifier,\n\n                                        PCMachineState, machine_done);\n\n    PCIBus *bus = pcms->bus;\n\n\n\n    /* set the number of CPUs */\n\n    rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);\n\n\n\n    if (bus) {\n\n        int extra_hosts = 0;\n\n\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            /* look for expander root buses */\n\n            if (pci_bus_is_root(bus)) {\n\n                extra_hosts++;\n\n            }\n\n        }\n\n        if (extra_hosts && pcms->fw_cfg) {\n\n            uint64_t *val = g_malloc(sizeof(*val));\n\n            *val = cpu_to_le64(extra_hosts);\n\n            fw_cfg_add_file(pcms->fw_cfg,\n\n                    \"etc/extra-pci-roots\", val, sizeof(*val));\n\n        }\n\n    }\n\n\n\n    acpi_setup();\n\n    if (pcms->fw_cfg) {\n\n        pc_build_smbios(pcms);\n\n        pc_build_feature_control_file(pcms);\n\n        /* update FW_CFG_NB_CPUS to account for -device added CPUs */\n\n        fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);\n\n    }\n\n\n\n    if (pcms->apic_id_limit > 255) {\n\n        IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());\n\n\n\n        if (!iommu || !iommu->x86_iommu.intr_supported ||\n\n            iommu->intr_eim != ON_OFF_AUTO_ON) {\n\n            error_report(\"current -smp configuration requires \"\n\n                         \"Extended Interrupt Mode enabled. \"\n\n                         \"You can add an IOMMU using: \"\n\n                         \"-device intel-iommu,intremap=on,eim=on\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n}\n", "idx": 221}
{"project": "qemu", "commit_id": "9012a53f067a78022947e18050b145c34a3dc599", "target": 0, "func": "static void spapr_machine_reset(void)\n\n{\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    PowerPCCPU *first_ppc_cpu;\n\n    uint32_t rtas_limit;\n\n    hwaddr rtas_addr, fdt_addr;\n\n    void *fdt;\n\n    int rc;\n\n\n\n    /* Check for unknown sysbus devices */\n\n    foreach_dynamic_sysbus_device(find_unknown_sysbus_device, NULL);\n\n\n\n    spapr_caps_reset(spapr);\n\n\n\n    first_ppc_cpu = POWERPC_CPU(first_cpu);\n\n    if (kvm_enabled() && kvmppc_has_cap_mmu_radix() &&\n\n        ppc_check_compat(first_ppc_cpu, CPU_POWERPC_LOGICAL_3_00, 0,\n\n                         spapr->max_compat_pvr)) {\n\n        /* If using KVM with radix mode available, VCPUs can be started\n\n         * without a HPT because KVM will start them in radix mode.\n\n         * Set the GR bit in PATB so that we know there is no HPT. */\n\n        spapr->patb_entry = PATBE1_GR;\n\n    } else {\n\n        spapr_setup_hpt_and_vrma(spapr);\n\n    }\n\n\n\n    qemu_devices_reset();\n\n\n\n    /* DRC reset may cause a device to be unplugged. This will cause troubles\n\n     * if this device is used by another device (eg, a running vhost backend\n\n     * will crash QEMU if the DIMM holding the vring goes away). To avoid such\n\n     * situations, we reset DRCs after all devices have been reset.\n\n     */\n\n    object_child_foreach_recursive(object_get_root(), spapr_reset_drcs, NULL);\n\n\n\n    spapr_clear_pending_events(spapr);\n\n\n\n    /*\n\n     * We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary\n\n     */\n\n    rtas_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR);\n\n    rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    fdt_addr = rtas_addr - FDT_MAX_SIZE;\n\n\n\n    /* if this reset wasn't generated by CAS, we should reset our\n\n     * negotiated options and start from scratch */\n\n    if (!spapr->cas_reboot) {\n\n        spapr_ovec_cleanup(spapr->ov5_cas);\n\n        spapr->ov5_cas = spapr_ovec_new();\n\n\n\n        ppc_set_compat(first_ppc_cpu, spapr->max_compat_pvr, &error_fatal);\n\n    }\n\n\n\n    fdt = spapr_build_fdt(spapr, rtas_addr, spapr->rtas_size);\n\n\n\n    spapr_load_rtas(spapr, fdt, rtas_addr);\n\n\n\n    rc = fdt_pack(fdt);\n\n\n\n    /* Should only fail if we've built a corrupted tree */\n\n    assert(rc == 0);\n\n\n\n    if (fdt_totalsize(fdt) > FDT_MAX_SIZE) {\n\n        error_report(\"FDT too big ! 0x%x bytes (max is 0x%x)\",\n\n                     fdt_totalsize(fdt), FDT_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n\n\n    /* Load the fdt */\n\n    qemu_fdt_dumpdtb(fdt, fdt_totalsize(fdt));\n\n    cpu_physical_memory_write(fdt_addr, fdt, fdt_totalsize(fdt));\n\n    g_free(fdt);\n\n\n\n    /* Set up the entry state */\n\n    first_ppc_cpu->env.gpr[3] = fdt_addr;\n\n    first_ppc_cpu->env.gpr[5] = 0;\n\n    first_cpu->halted = 0;\n\n    first_ppc_cpu->env.nip = SPAPR_ENTRY_POINT;\n\n\n\n    spapr->cas_reboot = false;\n\n}\n", "idx": 222}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_next_event_is(int event)\n\n{\n\n    bool res = false;\n\n\n\n    /* nothing to skip - not all instructions used */\n\n    if (replay_state.instructions_count != 0) {\n\n        assert(replay_data_kind == EVENT_INSTRUCTION);\n\n        return event == EVENT_INSTRUCTION;\n\n    }\n\n\n\n    while (true) {\n\n        if (event == replay_data_kind) {\n\n            res = true;\n\n        }\n\n        switch (replay_data_kind) {\n\n        case EVENT_SHUTDOWN:\n\n            replay_finish_event();\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        default:\n\n            /* clock, time_t, checkpoint and other events */\n\n            return res;\n\n        }\n\n    }\n\n    return res;\n\n}\n", "idx": 223}
{"project": "qemu", "commit_id": "00008418aa22700f6c49e794e79f53aeb157d10f", "target": 0, "func": "void kvm_init_irq_routing(KVMState *s)\n\n{\n\n    int gsi_count, i;\n\n\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);\n\n    if (gsi_count > 0) {\n\n        unsigned int gsi_bits, i;\n\n\n\n        /* Round up so we can search ints using ffs */\n\n        gsi_bits = ALIGN(gsi_count, 32);\n\n        s->used_gsi_bitmap = g_malloc0(gsi_bits / 8);\n\n        s->gsi_count = gsi_count;\n\n\n\n        /* Mark any over-allocated bits as already in use */\n\n        for (i = gsi_count; i < gsi_bits; i++) {\n\n            set_gsi(s, i);\n\n        }\n\n    }\n\n\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n\n    s->nr_allocated_irq_routes = 0;\n\n\n\n    if (!s->direct_msi) {\n\n        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {\n\n            QTAILQ_INIT(&s->msi_hashtab[i]);\n\n        }\n\n    }\n\n\n\n    kvm_arch_init_irq_routing(s);\n\n}\n", "idx": 224}
{"project": "qemu", "commit_id": "d6f2ea22a05b429ba83248b80a625b6fe1d927f3", "target": 0, "func": "static uint16_t *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    PhysPageEntry *lp, *p;\n\n    int i, j;\n\n\n\n    lp = &phys_map;\n\n\n\n    /* Level 1..N.  */\n\n    for (i = P_L2_LEVELS - 1; i >= 0; i--) {\n\n        if (lp->u.node == NULL) {\n\n            if (!alloc) {\n\n                return NULL;\n\n            }\n\n            lp->u.node = p = g_malloc0(sizeof(PhysPageEntry) * L2_SIZE);\n\n            if (i == 0) {\n\n                for (j = 0; j < L2_SIZE; j++) {\n\n                    p[j].u.leaf = phys_section_unassigned;\n\n                }\n\n            }\n\n        }\n\n        lp = &lp->u.node[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    return &lp->u.leaf;\n\n}\n", "idx": 225}
{"project": "qemu", "commit_id": "eae74cf906942999bf70e94f034f95c7f831ec63", "target": 0, "func": "void qemu_cpu_kick(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n\n\n    qemu_cond_broadcast(env->halt_cond);\n\n    if (!env->thread_kicked) {\n\n        qemu_cpu_kick_thread(env);\n\n        env->thread_kicked = true;\n\n    }\n\n}\n", "idx": 226}
{"project": "FFmpeg", "commit_id": "dd1e6b2a139a9eea61aefe24fc3295499e70d04b", "target": 0, "func": "static int http_proxy_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    char hostname[1024], hoststr[1024];\n\n    char auth[1024], pathbuf[1024], *path;\n\n    char lower_url[100];\n\n    int port, ret = 0, attempts = 0;\n\n    HTTPAuthType cur_auth_type;\n\n    char *authstr;\n\n    int new_loc;\n\n\n\n    h->is_streamed = 1;\n\n\n\n    av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,\n\n                 pathbuf, sizeof(pathbuf), uri);\n\n    ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);\n\n    path = pathbuf;\n\n    if (*path == '/')\n\n        path++;\n\n\n\n    ff_url_join(lower_url, sizeof(lower_url), \"tcp\", NULL, hostname, port,\n\n                NULL);\n\nredo:\n\n    ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,\n\n                     &h->interrupt_callback, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,\n\n                                           path, \"CONNECT\");\n\n    snprintf(s->buffer, sizeof(s->buffer),\n\n             \"CONNECT %s HTTP/1.1\\r\\n\"\n\n             \"Host: %s\\r\\n\"\n\n             \"Connection: close\\r\\n\"\n\n             \"%s%s\"\n\n             \"\\r\\n\",\n\n             path,\n\n             hoststr,\n\n             authstr ? \"Proxy-\" : \"\", authstr ? authstr : \"\");\n\n    av_freep(&authstr);\n\n\n\n    if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n\n        goto fail;\n\n\n\n    s->buf_ptr = s->buffer;\n\n    s->buf_end = s->buffer;\n\n    s->line_count = 0;\n\n    s->filesize = -1;\n\n    cur_auth_type = s->proxy_auth_state.auth_type;\n\n\n\n    /* Note: This uses buffering, potentially reading more than the\n\n     * HTTP header. If tunneling a protocol where the server starts\n\n     * the conversation, we might buffer part of that here, too.\n\n     * Reading that requires using the proper ffurl_read() function\n\n     * on this URLContext, not using the fd directly (as the tls\n\n     * protocol does). This shouldn't be an issue for tls though,\n\n     * since the client starts the conversation there, so there\n\n     * is no extra data that we might buffer up here.\n\n     */\n\n    ret = http_read_header(h, &new_loc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    attempts++;\n\n    if (s->http_code == 407 &&\n\n        (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&\n\n        s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {\n\n        ffurl_closep(&s->hd);\n\n        goto redo;\n\n    }\n\n\n\n    if (s->http_code < 400)\n\n        return 0;\n\n    ret = AVERROR(EIO);\n\n\n\nfail:\n\n    http_proxy_close(h);\n\n    return ret;\n\n}\n", "idx": 228}
{"project": "qemu", "commit_id": "e8807b14cc8c12c0e14c08fa396d9da043b48209", "target": 0, "func": "static int get_physical_address_data(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int rw, int is_user)\n\n{\n\n    target_ulong mask;\n\n    unsigned int i;\n\n\n\n    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */\n\n        *physical = address;\n\n        *prot = PAGE_READ | PAGE_WRITE;\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        switch ((env->dtlb_tte[i] >> 61) & 3) {\n\n        default:\n\n        case 0x0: // 8k\n\n            mask = 0xffffffffffffe000ULL;\n\n            break;\n\n        case 0x1: // 64k\n\n            mask = 0xffffffffffff0000ULL;\n\n            break;\n\n        case 0x2: // 512k\n\n            mask = 0xfffffffffff80000ULL;\n\n            break;\n\n        case 0x3: // 4M\n\n            mask = 0xffffffffffc00000ULL;\n\n            break;\n\n        }\n\n        // ctx match, vaddr match, valid?\n\n        if (env->dmmuregs[1] == (env->dtlb_tag[i] & 0x1fff) &&\n\n            (address & mask) == (env->dtlb_tag[i] & mask) &&\n\n            (env->dtlb_tte[i] & 0x8000000000000000ULL)) {\n\n            // access ok?\n\n            if (((env->dtlb_tte[i] & 0x4) && is_user) ||\n\n                (!(env->dtlb_tte[i] & 0x2) && (rw == 1))) {\n\n                if (env->dmmuregs[3]) /* Fault status register */\n\n                    env->dmmuregs[3] = 2; /* overflow (not read before\n\n                                             another fault) */\n\n                env->dmmuregs[3] |= (is_user << 3) | ((rw == 1) << 2) | 1;\n\n                env->dmmuregs[4] = address; /* Fault address register */\n\n                env->exception_index = TT_DFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"DFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *physical = ((env->dtlb_tte[i] & mask) | (address & ~mask)) &\n\n                        0x1ffffffe000ULL;\n\n            *prot = PAGE_READ;\n\n            if (env->dtlb_tte[i] & 0x2)\n\n                *prot |= PAGE_WRITE;\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"DMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    env->dmmuregs[6] = (address & ~0x1fffULL) | (env->dmmuregs[1] & 0x1fff);\n\n    env->exception_index = TT_DMISS;\n\n    return 1;\n\n}\n", "idx": 229}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = g_strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s/%s/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    g_free(tmp_path);\n\n    return err;\n\n}\n", "idx": 230}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "static inline void sync_jmpstate(DisasContext *dc)\n\n{\n\n    if (dc->jmp == JMP_DIRECT) {\n\n            dc->jmp = JMP_INDIRECT;\n\n            tcg_gen_movi_tl(env_btaken, 1);\n\n            tcg_gen_movi_tl(env_btarget, dc->jmp_pc);\n\n    }\n\n}\n", "idx": 231}
{"project": "qemu", "commit_id": "38e0735eb76a1479917ef3501a208d4f70998494", "target": 0, "func": "void register_device_unmigratable(DeviceState *dev, const char *idstr,\n\n                                                            void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n    char id[256] = \"\";\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *path = dev->parent_bus->info->get_dev_path(dev);\n\n        if (path) {\n\n            pstrcpy(id, sizeof(id), path);\n\n            pstrcat(id, sizeof(id), \"/\");\n\n            g_free(path);\n\n        }\n\n    }\n\n    pstrcat(id, sizeof(id), idstr);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n\n            se->no_migrate = 1;\n\n        }\n\n    }\n\n}\n", "idx": 232}
{"project": "qemu", "commit_id": "c679e74d2e29fa08ede9121d59aee4e9675611d7", "target": 0, "func": "int css_do_rsch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||\n\n        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||\n\n        (!(s->ctrl & SCSW_ACTL_SUSP))) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* If monitoring is active, update counter. */\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n\n\n    s->ctrl |= SCSW_ACTL_RESUME_PEND;\n\n    do_subchannel_work(sch, NULL);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n", "idx": 233}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "CPUState *cpu_copy(CPUState *env)\n\n{\n\n    CPUState *new_env = cpu_init(env->cpu_model_str);\n\n    CPUState *next_cpu = new_env->next_cpu;\n\n    int cpu_index = new_env->cpu_index;\n\n#if defined(TARGET_HAS_ICE)\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n#endif\n\n\n\n    memcpy(new_env, env, sizeof(CPUState));\n\n\n\n    /* Preserve chaining and index. */\n\n    new_env->next_cpu = next_cpu;\n\n    new_env->cpu_index = cpu_index;\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    TAILQ_INIT(&env->breakpoints);\n\n    TAILQ_INIT(&env->watchpoints);\n\n#if defined(TARGET_HAS_ICE)\n\n    TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_env, bp->pc, bp->flags, NULL);\n\n    }\n\n    TAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_env, wp->vaddr, (~wp->len_mask) + 1,\n\n                              wp->flags, NULL);\n\n    }\n\n#endif\n\n\n\n    return new_env;\n\n}\n", "idx": 234}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,\n\n                               uint32_t *app)\n\n{\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);\n\n    struct Stream *s = &ds->dma->streams[1];\n\n    size_t ret;\n\n\n\n    if (!app) {\n\n        hw_error(\"No stream app data!\\n\");\n\n    }\n\n    ret = stream_process_s2mem(s, buf, len, app);\n\n    stream_update_irq(s);\n\n    return ret;\n\n}\n", "idx": 236}
{"project": "FFmpeg", "commit_id": "a9493601638b048c44751956d2360f215918800c", "target": 0, "func": "void *av_realloc(void *ptr, unsigned int size)\n\n{\n\n#ifdef MEMALIGN_HACK\n\n    int diff;\n\n#endif\n\n\n\n    /* let's disallow possible ambiguous cases */\n\n    if(size > INT_MAX)\n\n        return NULL;\n\n\n\n#ifdef MEMALIGN_HACK\n\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n\n    if(!ptr) return av_malloc(size);\n\n    diff= ((char*)ptr)[-1];\n\n    return realloc(ptr - diff, size + diff) + diff;\n\n#else\n\n    return realloc(ptr, size);\n\n#endif\n\n}\n", "idx": 237}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int mmf_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 32)\n\n        return 0;\n\n    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&\n\n        p->buf[2] == 'M' && p->buf[3] == 'D' &&\n\n        p->buf[8] == 'C' && p->buf[9] == 'N' &&\n\n        p->buf[10] == 'T' && p->buf[11] == 'I')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 238}
{"project": "qemu", "commit_id": "34f2af3d3edf9d57c27811d3780cbc0ece319625", "target": 1, "func": "static XICSState *try_create_xics(const char *type, int nr_servers,\n\n                                  int nr_irqs)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(NULL, type);\n\n    qdev_prop_set_uint32(dev, \"nr_servers\", nr_servers);\n\n    qdev_prop_set_uint32(dev, \"nr_irqs\", nr_irqs);\n\n    if (qdev_init(dev) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    return XICS_COMMON(dev);\n\n}\n", "idx": 239}
{"project": "qemu", "commit_id": "3e7f136d8b4383d99f1b034a045b73f9b12a4eae", "target": 1, "func": "static VncServerInfo *vnc_server_info_get(VncDisplay *vd)\n\n{\n\n    VncServerInfo *info;\n\n    Error *err = NULL;\n\n\n\n    info = g_malloc(sizeof(*info));\n\n    vnc_init_basic_info_from_server_addr(vd->lsock,\n\n                                         qapi_VncServerInfo_base(info), &err);\n\n    info->has_auth = true;\n\n    info->auth = g_strdup(vnc_auth_name(vd));\n\n    if (err) {\n\n        qapi_free_VncServerInfo(info);\n\n        info = NULL;\n\n        error_free(err);\n\n    }\n\n    return info;\n\n}\n", "idx": 240}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static int vm_request_pending(void)\n\n{\n\n    return powerdown_requested ||\n\n           reset_requested ||\n\n           shutdown_requested ||\n\n           debug_requested ||\n\n           vmstop_requested;\n\n}\n", "idx": 241}
{"project": "FFmpeg", "commit_id": "3d79d0c93e5b37a35b1b22d6c18699c233aad1ba", "target": 1, "func": "static int adpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                              const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    int n, i, ch, st, pkt_size, ret;\n\n    const int16_t *samples;\n\n    int16_t **samples_p;\n\n    uint8_t *dst;\n\n    ADPCMEncodeContext *c = avctx->priv_data;\n\n    uint8_t *buf;\n\n\n\n    samples = (const int16_t *)frame->data[0];\n\n    samples_p = (int16_t **)frame->extended_data;\n\n    st = avctx->channels == 2;\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_ADPCM_SWF)\n\n        pkt_size = (2 + avctx->channels * (22 + 4 * (frame->nb_samples - 1)) + 7) / 8;\n\n    else\n\n        pkt_size = avctx->block_align;\n\n    if ((ret = ff_alloc_packet(avpkt, pkt_size))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    dst = avpkt->data;\n\n\n\n    switch(avctx->codec->id) {\n\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n\n    {\n\n        int blocks, j;\n\n\n\n        blocks = (frame->nb_samples - 1) / 8;\n\n\n\n        for (ch = 0; ch < avctx->channels; ch++) {\n\n            ADPCMChannelStatus *status = &c->status[ch];\n\n            status->prev_sample = samples_p[ch][0];\n\n            /* status->step_index = 0;\n\n               XXX: not sure how to init the state machine */\n\n            bytestream_put_le16(&dst, status->prev_sample);\n\n            *dst++ = status->step_index;\n\n            *dst++ = 0; /* unknown */\n\n        }\n\n\n\n        /* stereo: 4 bytes (8 samples) for left, 4 bytes for right */\n\n        if (avctx->trellis > 0) {\n\n            FF_ALLOC_OR_GOTO(avctx, buf, avctx->channels * blocks * 8, error);\n\n            for (ch = 0; ch < avctx->channels; ch++) {\n\n                adpcm_compress_trellis(avctx, &samples_p[ch][1],\n\n                                       buf + ch * blocks * 8, &c->status[ch],\n\n                                       blocks * 8, 1);\n\n            }\n\n            for (i = 0; i < blocks; i++) {\n\n                for (ch = 0; ch < avctx->channels; ch++) {\n\n                    uint8_t *buf1 = buf + ch * blocks * 8 + i * 8;\n\n                    for (j = 0; j < 8; j += 2)\n\n                        *dst++ = buf1[j] | (buf1[j + 1] << 4);\n\n                }\n\n            }\n\n            av_free(buf);\n\n        } else {\n\n            for (i = 0; i < blocks; i++) {\n\n                for (ch = 0; ch < avctx->channels; ch++) {\n\n                    ADPCMChannelStatus *status = &c->status[ch];\n\n                    const int16_t *smp = &samples_p[ch][1 + i * 8];\n\n                    for (j = 0; j < 8; j += 2) {\n\n                        uint8_t v = adpcm_ima_compress_sample(status, smp[j    ]);\n\n                        v        |= adpcm_ima_compress_sample(status, smp[j + 1]) << 4;\n\n                        *dst++ = v;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n\n    {\n\n        PutBitContext pb;\n\n        init_put_bits(&pb, dst, pkt_size * 8);\n\n\n\n        for (ch = 0; ch < avctx->channels; ch++) {\n\n            ADPCMChannelStatus *status = &c->status[ch];\n\n            put_bits(&pb, 9, (status->prev_sample & 0xFFFF) >> 7);\n\n            put_bits(&pb, 7,  status->step_index);\n\n            if (avctx->trellis > 0) {\n\n                uint8_t buf[64];\n\n                adpcm_compress_trellis(avctx, &samples_p[ch][1], buf, status,\n\n                                       64, 1);\n\n                for (i = 0; i < 64; i++)\n\n                    put_bits(&pb, 4, buf[i ^ 1]);\n\n            } else {\n\n                for (i = 0; i < 64; i += 2) {\n\n                    int t1, t2;\n\n                    t1 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i    ]);\n\n                    t2 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i + 1]);\n\n                    put_bits(&pb, 4, t2);\n\n                    put_bits(&pb, 4, t1);\n\n                }\n\n            }\n\n        }\n\n\n\n        flush_put_bits(&pb);\n\n        break;\n\n    }\n\n    case AV_CODEC_ID_ADPCM_SWF:\n\n    {\n\n        PutBitContext pb;\n\n        init_put_bits(&pb, dst, pkt_size * 8);\n\n\n\n        n = frame->nb_samples - 1;\n\n\n\n        // store AdpcmCodeSize\n\n        put_bits(&pb, 2, 2);    // set 4-bit flash adpcm format\n\n\n\n        // init the encoder state\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            // clip step so it fits 6 bits\n\n            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 63);\n\n            put_sbits(&pb, 16, samples[i]);\n\n            put_bits(&pb, 6, c->status[i].step_index);\n\n            c->status[i].prev_sample = samples[i];\n\n        }\n\n\n\n        if (avctx->trellis > 0) {\n\n            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);\n\n            adpcm_compress_trellis(avctx, samples + avctx->channels, buf,\n\n                                   &c->status[0], n, avctx->channels);\n\n            if (avctx->channels == 2)\n\n                adpcm_compress_trellis(avctx, samples + avctx->channels + 1,\n\n                                       buf + n, &c->status[1], n,\n\n                                       avctx->channels);\n\n            for (i = 0; i < n; i++) {\n\n                put_bits(&pb, 4, buf[i]);\n\n                if (avctx->channels == 2)\n\n                    put_bits(&pb, 4, buf[n + i]);\n\n            }\n\n            av_free(buf);\n\n        } else {\n\n            for (i = 1; i < frame->nb_samples; i++) {\n\n                put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[0],\n\n                         samples[avctx->channels * i]));\n\n                if (avctx->channels == 2)\n\n                    put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[1],\n\n                             samples[2 * i + 1]));\n\n            }\n\n        }\n\n        flush_put_bits(&pb);\n\n        break;\n\n    }\n\n    case AV_CODEC_ID_ADPCM_MS:\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            int predictor = 0;\n\n            *dst++ = predictor;\n\n            c->status[i].coeff1 = ff_adpcm_AdaptCoeff1[predictor];\n\n            c->status[i].coeff2 = ff_adpcm_AdaptCoeff2[predictor];\n\n        }\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            if (c->status[i].idelta < 16)\n\n                c->status[i].idelta = 16;\n\n            bytestream_put_le16(&dst, c->status[i].idelta);\n\n        }\n\n        for (i = 0; i < avctx->channels; i++)\n\n            c->status[i].sample2= *samples++;\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            c->status[i].sample1 = *samples++;\n\n            bytestream_put_le16(&dst, c->status[i].sample1);\n\n        }\n\n        for (i = 0; i < avctx->channels; i++)\n\n            bytestream_put_le16(&dst, c->status[i].sample2);\n\n\n\n        if (avctx->trellis > 0) {\n\n            n = avctx->block_align - 7 * avctx->channels;\n\n            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);\n\n            if (avctx->channels == 1) {\n\n                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,\n\n                                       avctx->channels);\n\n                for (i = 0; i < n; i += 2)\n\n                    *dst++ = (buf[i] << 4) | buf[i + 1];\n\n            } else {\n\n                adpcm_compress_trellis(avctx, samples,     buf,\n\n                                       &c->status[0], n, avctx->channels);\n\n                adpcm_compress_trellis(avctx, samples + 1, buf + n,\n\n                                       &c->status[1], n, avctx->channels);\n\n                for (i = 0; i < n; i++)\n\n                    *dst++ = (buf[i] << 4) | buf[n + i];\n\n            }\n\n            av_free(buf);\n\n        } else {\n\n            for (i = 7 * avctx->channels; i < avctx->block_align; i++) {\n\n                int nibble;\n\n                nibble  = adpcm_ms_compress_sample(&c->status[ 0], *samples++) << 4;\n\n                nibble |= adpcm_ms_compress_sample(&c->status[st], *samples++);\n\n                *dst++  = nibble;\n\n            }\n\n        }\n\n        break;\n\n    case AV_CODEC_ID_ADPCM_YAMAHA:\n\n        n = frame->nb_samples / 2;\n\n        if (avctx->trellis > 0) {\n\n            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n * 2, error);\n\n            n *= 2;\n\n            if (avctx->channels == 1) {\n\n                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,\n\n                                       avctx->channels);\n\n                for (i = 0; i < n; i += 2)\n\n                    *dst++ = buf[i] | (buf[i + 1] << 4);\n\n            } else {\n\n                adpcm_compress_trellis(avctx, samples,     buf,\n\n                                       &c->status[0], n, avctx->channels);\n\n                adpcm_compress_trellis(avctx, samples + 1, buf + n,\n\n                                       &c->status[1], n, avctx->channels);\n\n                for (i = 0; i < n; i++)\n\n                    *dst++ = buf[i] | (buf[n + i] << 4);\n\n            }\n\n            av_free(buf);\n\n        } else\n\n            for (n *= avctx->channels; n > 0; n--) {\n\n                int nibble;\n\n                nibble  = adpcm_yamaha_compress_sample(&c->status[ 0], *samples++);\n\n                nibble |= adpcm_yamaha_compress_sample(&c->status[st], *samples++) << 4;\n\n                *dst++  = nibble;\n\n            }\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avpkt->size = pkt_size;\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\nerror:\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 242}
{"project": "FFmpeg", "commit_id": "8ef453ff830b40f635b94099d1debad3d809847f", "target": 1, "func": "yuv2rgb_full_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum AVPixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int uvalpha1 = 4096 - uvalpha;\n\n    int i;\n\n    int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4;\n\n    int err[4] = {0};\n\n\n\n    if(   target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE\n\n       || target == AV_PIX_FMT_BGR8      || target == AV_PIX_FMT_RGB8)\n\n        step = 1;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = ( buf0[i] * yalpha1  +  buf1[i] * yalpha             ) >> 10; //FIXME rounding\n\n        int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha-(128 << 19)) >> 10;\n\n        int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha-(128 << 19)) >> 10;\n\n        int A;\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i] * yalpha1 + abuf1[i] * yalpha + (1<<18)) >> 19;\n\n            if (A & 0x100)\n\n                A = av_clip_uint8(A);\n\n        }\n\n\n\n        yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err);\n\n        dest += step;\n\n    }\n\n    c->dither_error[0][i] = err[0];\n\n    c->dither_error[1][i] = err[1];\n\n    c->dither_error[2][i] = err[2];\n\n}\n", "idx": 243}
{"project": "FFmpeg", "commit_id": "f1d8763a02b5fce9a7d9789e049d74a45b15e1e8", "target": 1, "func": "static void clone_slice(H264Context *dst, H264Context *src)\n\n{\n\n    memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));\n\n    dst->s.current_picture_ptr = src->s.current_picture_ptr;\n\n    dst->s.current_picture     = src->s.current_picture;\n\n    dst->s.linesize            = src->s.linesize;\n\n    dst->s.uvlinesize          = src->s.uvlinesize;\n\n    dst->s.first_field         = src->s.first_field;\n\n\n\n    dst->prev_poc_msb          = src->prev_poc_msb;\n\n    dst->prev_poc_lsb          = src->prev_poc_lsb;\n\n    dst->prev_frame_num_offset = src->prev_frame_num_offset;\n\n    dst->prev_frame_num        = src->prev_frame_num;\n\n    dst->short_ref_count       = src->short_ref_count;\n\n\n\n    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));\n\n    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));\n\n    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));\n\n    memcpy(dst->ref_list,         src->ref_list,         sizeof(dst->ref_list));\n\n\n\n    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));\n\n    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));\n\n}\n", "idx": 247}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_subf(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                     TCGv arg2, int add_ca, int compute_ca,\n\n                                     int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret, arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    if (add_ca) {\n\n        tcg_gen_not_tl(t0, arg1);\n\n        tcg_gen_add_tl(t0, t0, arg2);\n\n        gen_op_arith_compute_ca(ctx, t0, arg2, 0);\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    } else {\n\n        tcg_gen_sub_tl(t0, arg2, arg1);\n\n        if (compute_ca) {\n\n            gen_op_arith_compute_ca(ctx, t0, arg2, 1);\n\n        }\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 1);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 249}
{"project": "FFmpeg", "commit_id": "9123950be0dbbfceacb38c0a9b09fdb01ae5b111", "target": 1, "func": "static void mxf_packet_timestamps(MXFContext *mxf, AVPacket *pkt)\n\n{\n\n    int64_t last_ofs = -1, next_ofs;\n\n    MXFIndexTable *t = &mxf->index_tables[0];\n\n\n\n    /* this is called from the OP1a demuxing logic, which means there\n\n     * may be no index tables */\n\n    if (mxf->nb_index_tables <= 0)\n\n        return;\n\n\n\n    /* find mxf->current_edit_unit so that the next edit unit starts ahead of pkt->pos */\n\n    for (;;) {\n\n        if (mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + 1, NULL, &next_ofs, 0) < 0)\n\n            break;\n\n\n\n        if (next_ofs <= last_ofs) {\n\n            /* large next_ofs didn't change or current_edit_unit wrapped\n\n             * around this fixes the infinite loop on zzuf3.mxf */\n\n            av_log(mxf->fc, AV_LOG_ERROR,\n\n                   \"next_ofs didn't change. not deriving packet timestamps\\n\");\n\n            return;\n\n        }\n\n\n\n        if (next_ofs > pkt->pos)\n\n            break;\n\n\n\n        last_ofs = next_ofs;\n\n        mxf->current_edit_unit++;\n\n    }\n\n\n\n    if (mxf->current_edit_unit >= t->nb_ptses)\n\n        return;\n\n\n\n    pkt->dts = mxf->current_edit_unit + t->first_dts;\n\n    pkt->pts = t->ptses[mxf->current_edit_unit];\n\n}\n", "idx": 250}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16intra_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){\n\n    int i;\n\n    for(i=0; i<16; i++){\n\n        if(nnzc[ scan8[i] ] || block[i*16])\n\n            ff_h264_idct_add_mmx(dst + block_offset[i], block + i*16, stride);\n\n    }\n\n}\n", "idx": 251}
{"project": "FFmpeg", "commit_id": "cece491daa9f4c7c908e016f4e285a49d37cb17c", "target": 0, "func": "static void process_subpacket_9 (QDM2Context *q, QDM2SubPNode *node)\n\n{\n\n    GetBitContext gb;\n\n    int i, j, k, n, ch, run, level, diff;\n\n\n\n    init_get_bits(&gb, node->packet->data, node->packet->size*8);\n\n\n\n    n = coeff_per_sb_for_avg[q->coeff_per_sb_select][QDM2_SB_USED(q->sub_sampling) - 1] + 1; // same as averagesomething function\n\n\n\n    for (i = 1; i < n; i++)\n\n        for (ch=0; ch < q->nb_channels; ch++) {\n\n            level = qdm2_get_vlc(&gb, &vlc_tab_level, 0, 2);\n\n            q->quantized_coeffs[ch][i][0] = level;\n\n\n\n            for (j = 0; j < (8 - 1); ) {\n\n                run = qdm2_get_vlc(&gb, &vlc_tab_run, 0, 1) + 1;\n\n                diff = qdm2_get_se_vlc(&vlc_tab_diff, &gb, 2);\n\n\n\n                for (k = 1; k <= run; k++)\n\n                    q->quantized_coeffs[ch][i][j + k] = (level + ((k*diff) / run));\n\n\n\n                level += diff;\n\n                j += run;\n\n            }\n\n        }\n\n\n\n    for (ch = 0; ch < q->nb_channels; ch++)\n\n        for (i = 0; i < 8; i++)\n\n            q->quantized_coeffs[ch][0][i] = 0;\n\n}\n", "idx": 252}
{"project": "FFmpeg", "commit_id": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378", "target": 0, "func": "static inline void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n", "idx": 254}
{"project": "FFmpeg", "commit_id": "100a54da5264436202daeedd68ed5e4a8be41459", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n                                    const uint8_t *src, const uint8_t *src_end,\n                                    int width, int esc_count)\n{\n    int i = 0;\n    int count;\n    uint8_t zero_run = 0;\n    const uint8_t *src_start = src;\n    uint8_t mask1 = -(esc_count < 2);\n    uint8_t mask2 = -(esc_count < 3);\n    uint8_t *end = dst + (width - 2);\noutput_zeros:\n    if (l->zeros_rem) {\n        count = FFMIN(l->zeros_rem, width - i);\n        if (end - dst < count) {\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        memset(dst, 0, count);\n        l->zeros_rem -= count;\n        dst += count;\n    }\n    while (dst < end) {\n        i = 0;\n        while (!zero_run && dst + i < end) {\n            i++;\n            if (i+2 >= src_end - src)\n                return AVERROR_INVALIDDATA;\n            zero_run =\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n        }\n        if (zero_run) {\n            zero_run = 0;\n            i += esc_count;\n            memcpy(dst, src, i);\n            dst += i;\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n            src += i + 1;\n            goto output_zeros;\n        } else {\n            memcpy(dst, src, i);\n            src += i;\n            dst += i;\n        }\n    }\n    return  src - src_start;\n}", "idx": 256}
{"project": "FFmpeg", "commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "target": 1, "func": "static int ffmmal_read_frame(AVCodecContext *avctx, AVFrame *frame, int *got_frame)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    MMAL_BUFFER_HEADER_T *buffer = NULL;\n\n    MMAL_STATUS_T status = 0;\n\n    int ret = 0;\n\n\n\n    if (ctx->eos_received)\n\n        goto done;\n\n\n\n    while (1) {\n\n        // To ensure decoding in lockstep with a constant delay between fed packets\n\n        // and output frames, we always wait until an output buffer is available.\n\n        // Except during start we don't know after how many input packets the decoder\n\n        // is going to return the first buffer, and we can't distinguish decoder\n\n        // being busy from decoder waiting for input. So just poll at the start and\n\n        // keep feeding new data to the buffer.\n\n        // We are pretty sure the decoder will produce output if we sent more input\n\n        // frames than what a h264 decoder could logically delay. This avoids too\n\n        // excessive buffering.\n\n        // We also wait if we sent eos, but didn't receive it yet (think of decoding\n\n        // stream with a very low number of frames).\n\n        if (ctx->frames_output || ctx->packets_sent > MAX_DELAYED_FRAMES ||\n\n            (ctx->packets_sent && ctx->eos_sent)) {\n\n            // MMAL will ignore broken input packets, which means the frame we\n\n            // expect here may never arrive. Dealing with this correctly is\n\n            // complicated, so here's a hack to avoid that it freezes forever\n\n            // in this unlikely situation.\n\n            buffer = mmal_queue_timedwait(ctx->queue_decoded_frames, 100);\n\n            if (!buffer) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Did not get output frame from MMAL.\\n\");\n\n                ret = AVERROR_UNKNOWN;\n\n                goto done;\n\n            }\n\n        } else {\n\n            buffer = mmal_queue_get(ctx->queue_decoded_frames);\n\n            if (!buffer)\n\n                goto done;\n\n        }\n\n\n\n        ctx->eos_received |= !!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS);\n\n        if (ctx->eos_received)\n\n            goto done;\n\n\n\n        if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {\n\n            MMAL_COMPONENT_T *decoder = ctx->decoder;\n\n            MMAL_EVENT_FORMAT_CHANGED_T *ev = mmal_event_format_changed_get(buffer);\n\n            MMAL_BUFFER_HEADER_T *stale_buffer;\n\n\n\n            av_log(avctx, AV_LOG_INFO, \"Changing output format.\\n\");\n\n\n\n            if ((status = mmal_port_disable(decoder->output[0])))\n\n                goto done;\n\n\n\n            while ((stale_buffer = mmal_queue_get(ctx->queue_decoded_frames)))\n\n                mmal_buffer_header_release(stale_buffer);\n\n\n\n            mmal_format_copy(decoder->output[0]->format, ev->format);\n\n\n\n            if ((ret = ffmal_update_format(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_output_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_input_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        } else if (buffer->cmd) {\n\n            char s[20];\n\n            av_get_codec_tag_string(s, sizeof(s), buffer->cmd);\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown MMAL event %s on output port\\n\", s);\n\n            goto done;\n\n        } else if (buffer->length == 0) {\n\n            // Unused output buffer that got drained after format change.\n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        }\n\n\n\n        ctx->frames_output++;\n\n\n\n        if ((ret = ffmal_copy_frame(avctx, frame, buffer)) < 0)\n\n            goto done;\n\n\n\n        *got_frame = 1;\n\n        break;\n\n    }\n\n\n\ndone:\n\n    if (buffer)\n\n        mmal_buffer_header_release(buffer);\n\n    if (status && ret >= 0)\n\n        ret = AVERROR_UNKNOWN;\n\n    return ret;\n\n}\n", "idx": 258}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static int send_dma_request(int cmd, uint64_t sector, int nb_sectors,\n\n                            PrdtEntry *prdt, int prdt_entries,\n\n                            void(*post_exec)(QPCIDevice *dev, void *ide_base,\n\n                                             uint64_t sector, int nb_sectors))\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base;\n\n    void *ide_base;\n\n    uintptr_t guest_prdt;\n\n    size_t len;\n\n    bool from_dev;\n\n    uint8_t status;\n\n    int flags;\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    flags = cmd & ~0xff;\n\n    cmd &= 0xff;\n\n\n\n    switch (cmd) {\n\n    case CMD_READ_DMA:\n\n    case CMD_PACKET:\n\n        /* Assuming we only test data reads w/ ATAPI, otherwise we need to know\n\n         * the SCSI command being sent in the packet, too. */\n\n        from_dev = true;\n\n        break;\n\n    case CMD_WRITE_DMA:\n\n        from_dev = false;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    if (flags & CMDF_NO_BM) {\n\n        qpci_config_writew(dev, PCI_COMMAND,\n\n                           PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n    }\n\n\n\n    /* Select device 0 */\n\n    qpci_io_writeb(dev, ide_base + reg_device, 0 | LBA);\n\n\n\n    /* Stop any running transfer, clear any pending interrupt */\n\n    qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);\n\n    qpci_io_writeb(dev, bmdma_base + bmreg_status, BM_STS_INTR);\n\n\n\n    /* Setup PRDT */\n\n    len = sizeof(*prdt) * prdt_entries;\n\n    guest_prdt = guest_alloc(guest_malloc, len);\n\n    memwrite(guest_prdt, prdt, len);\n\n    qpci_io_writel(dev, bmdma_base + bmreg_prdt, guest_prdt);\n\n\n\n    /* ATA DMA command */\n\n    if (cmd == CMD_PACKET) {\n\n        /* Enables ATAPI DMA; otherwise PIO is attempted */\n\n        qpci_io_writeb(dev, ide_base + reg_feature, 0x01);\n\n    } else {\n\n        qpci_io_writeb(dev, ide_base + reg_nsectors, nb_sectors);\n\n        qpci_io_writeb(dev, ide_base + reg_lba_low,    sector & 0xff);\n\n        qpci_io_writeb(dev, ide_base + reg_lba_middle, (sector >> 8) & 0xff);\n\n        qpci_io_writeb(dev, ide_base + reg_lba_high,   (sector >> 16) & 0xff);\n\n    }\n\n\n\n    qpci_io_writeb(dev, ide_base + reg_command, cmd);\n\n\n\n    if (post_exec) {\n\n        post_exec(dev, ide_base, sector, nb_sectors);\n\n    }\n\n\n\n    /* Start DMA transfer */\n\n    qpci_io_writeb(dev, bmdma_base + bmreg_cmd,\n\n                   BM_CMD_START | (from_dev ? BM_CMD_WRITE : 0));\n\n\n\n    if (flags & CMDF_ABORT) {\n\n        qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);\n\n    }\n\n\n\n    /* Wait for the DMA transfer to complete */\n\n    do {\n\n        status = qpci_io_readb(dev, bmdma_base + bmreg_status);\n\n    } while ((status & (BM_STS_ACTIVE | BM_STS_INTR)) == BM_STS_ACTIVE);\n\n\n\n    g_assert_cmpint(get_irq(IDE_PRIMARY_IRQ), ==, !!(status & BM_STS_INTR));\n\n\n\n    /* Check IDE status code */\n\n    assert_bit_set(qpci_io_readb(dev, ide_base + reg_status), DRDY);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), BSY | DRQ);\n\n\n\n    /* Reading the status register clears the IRQ */\n\n    g_assert(!get_irq(IDE_PRIMARY_IRQ));\n\n\n\n    /* Stop DMA transfer if still active */\n\n    if (status & BM_STS_ACTIVE) {\n\n        qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);\n\n    }\n\n\n\n    free_pci_device(dev);\n\n\n\n    return status;\n\n}\n", "idx": 259}
{"project": "FFmpeg", "commit_id": "873049e6d854a69292934eb882731dd2ad7438b9", "target": 1, "func": "static int mxf_read_close(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    MXFIndexTableSegment *seg;\n\n    int i;\n\n\n\n    av_freep(&mxf->packages_refs);\n\n\n\n    for (i = 0; i < s->nb_streams; i++)\n\n        s->streams[i]->priv_data = NULL;\n\n\n\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n\n        switch (mxf->metadata_sets[i]->type) {\n\n        case MultipleDescriptor:\n\n            av_freep(&((MXFDescriptor *)mxf->metadata_sets[i])->sub_descriptors_refs);\n\n            break;\n\n        case Sequence:\n\n            av_freep(&((MXFSequence *)mxf->metadata_sets[i])->structural_components_refs);\n\n            break;\n\n        case SourcePackage:\n\n        case MaterialPackage:\n\n            av_freep(&((MXFPackage *)mxf->metadata_sets[i])->tracks_refs);\n\n            break;\n\n        case IndexTableSegment:\n\n            seg = (MXFIndexTableSegment *)mxf->metadata_sets[i];\n\n            av_freep(&seg->temporal_offset_entries);\n\n            av_freep(&seg->flag_entries);\n\n            av_freep(&seg->stream_offset_entries);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        av_freep(&mxf->metadata_sets[i]);\n\n    }\n\n    av_freep(&mxf->partitions);\n\n    av_freep(&mxf->metadata_sets);\n\n    av_freep(&mxf->aesc);\n\n    av_freep(&mxf->local_tags);\n\n\n\n    for (i = 0; i < mxf->nb_index_tables; i++) {\n\n        av_freep(&mxf->index_tables[i].segments);\n\n        av_freep(&mxf->index_tables[i].ptses);\n\n        av_freep(&mxf->index_tables[i].fake_index);\n\n    }\n\n    av_freep(&mxf->index_tables);\n\n\n\n    return 0;\n\n}\n", "idx": 260}
{"project": "FFmpeg", "commit_id": "2779d33ed99898675e0b3884fabe1ce6839f36d1", "target": 1, "func": "static int adts_aac_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    int ret, fsize;\n\n\n\n    ret = av_get_packet(s->pb, pkt, ADTS_HEADER_SIZE);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (ret < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if ((AV_RB16(pkt->data) >> 4) != 0xfff) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    fsize = (AV_RB32(pkt->data + 3) >> 13) & 0x1FFF;\n\n    if (fsize < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return av_append_packet(s->pb, pkt, fsize - ADTS_HEADER_SIZE);\n\n}\n", "idx": 261}
{"project": "FFmpeg", "commit_id": "a37fd7f9578d2dfbe20a109aae91e5f0a4b58874", "target": 1, "func": "static int bgr24ToYv12Wrapper(SwsContext *c, const uint8_t *src[],\n\n                              int srcStride[], int srcSliceY, int srcSliceH,\n\n                              uint8_t *dst[], int dstStride[])\n\n{\n\n    rgb24toyv12(\n\n        src[0],\n\n        dst[0] +  srcSliceY       * dstStride[0],\n\n        dst[1] + (srcSliceY >> 1) * dstStride[1],\n\n        dst[2] + (srcSliceY >> 1) * dstStride[2],\n\n        c->srcW, srcSliceH,\n\n        dstStride[0], dstStride[1], srcStride[0]);\n\n    if (dst[3])\n\n        fillPlane(dst[3], dstStride[3], c->srcW, srcSliceH, srcSliceY, 255);\n\n    return srcSliceH;\n\n}\n", "idx": 263}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (const uint16_t *)src;\n\n\tend = s + src_size/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0x7C00)>>7;\n\n\t\t*d++ = (bgr&0x3E0)>>2;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t*d++ = 0;\n\n\t}\n\n}\n", "idx": 264}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    int rows, cols;\n\n\n\n    ff_vp56_init_range_decoder(&s->c, buf, buf_size);\n\n    s->frames[VP56_FRAME_CURRENT]->key_frame = !vp56_rac_get(c);\n\n    vp56_rac_get(c);\n\n    ff_vp56_init_dequant(s, vp56_rac_gets(c, 6));\n\n    if (s->frames[VP56_FRAME_CURRENT]->key_frame)\n\n    {\n\n        vp56_rac_gets(c, 8);\n\n        if(vp56_rac_gets(c, 5) > 5)\n\n            return AVERROR_INVALIDDATA;\n\n        vp56_rac_gets(c, 2);\n\n        if (vp56_rac_get(c)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"interlacing not supported\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        rows = vp56_rac_gets(c, 8);  /* number of stored macroblock rows */\n\n        cols = vp56_rac_gets(c, 8);  /* number of stored macroblock cols */\n\n        if (!rows || !cols) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid size %dx%d\\n\",\n\n                   cols << 4, rows << 4);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        vp56_rac_gets(c, 8);  /* number of displayed macroblock rows */\n\n        vp56_rac_gets(c, 8);  /* number of displayed macroblock cols */\n\n        vp56_rac_gets(c, 2);\n\n        if (!s->macroblocks || /* first frame */\n\n            16*cols != s->avctx->coded_width ||\n\n            16*rows != s->avctx->coded_height) {\n\n            int ret = ff_set_dimensions(s->avctx, 16 * cols, 16 * rows);\n\n            if (ret < 0)\n\n                return ret;\n\n            return VP56_SIZE_CHANGE;\n\n        }\n\n    } else if (!s->macroblocks)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n", "idx": 266}
{"project": "FFmpeg", "commit_id": "92da23093c784b1d9f0db4db51d28ea80a59e759", "target": 1, "func": "static inline int coeff_unpack_golomb(GetBitContext *gb, int qfactor, int qoffset)\n\n{\n\n    int coeff = dirac_get_se_golomb(gb);\n\n    const int sign = FFSIGN(coeff);\n\n    if (coeff)\n\n        coeff = sign*((sign * coeff * qfactor + qoffset) >> 2);\n\n    return coeff;\n\n}\n", "idx": 267}
{"project": "FFmpeg", "commit_id": "259603b9176701410d6edeedbcbde565c767f27b", "target": 1, "func": "int ff_h264_frame_start(H264Context *h)\n\n{\n\n    Picture *pic;\n\n    int i, ret;\n\n    const int pixel_shift = h->pixel_shift;\n\n    int c[4] = {\n\n        1<<(h->sps.bit_depth_luma-1),\n\n        1<<(h->sps.bit_depth_chroma-1),\n\n        1<<(h->sps.bit_depth_chroma-1),\n\n        -1\n\n    };\n\n\n\n    if (!ff_thread_can_start_frame(h->avctx)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    release_unused_pictures(h, 1);\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    i = find_unused_picture(h);\n\n    if (i < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n        return i;\n\n    }\n\n    pic = &h->DPB[i];\n\n\n\n    pic->f.reference            = h->droppable ? 0 : h->picture_structure;\n\n    pic->f.coded_picture_number = h->coded_picture_number++;\n\n    pic->field_picture          = h->picture_structure != PICT_FRAME;\n\n\n\n    /*\n\n     * Zero key_frame here; IDR markings per slice in frame or fields are ORed\n\n     * in later.\n\n     * See decode_nal_units().\n\n     */\n\n    pic->f.key_frame = 0;\n\n    pic->sync        = 0;\n\n    pic->mmco_reset  = 0;\n\n\n\n    if ((ret = alloc_picture(h, pic)) < 0)\n\n        return ret;\n\n    if(!h->sync && !h->avctx->hwaccel)\n\n        avpriv_color_frame(&pic->f, c);\n\n\n\n    h->cur_pic_ptr = pic;\n\n    h->cur_pic     = *h->cur_pic_ptr;\n\n    h->cur_pic.f.extended_data = h->cur_pic.f.data;\n\n\n\n    ff_er_frame_start(&h->er);\n\n\n\n    assert(h->linesize && h->uvlinesize);\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n\n        h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->linesize * ((scan8[i] - scan8[0]) >> 3);\n\n    }\n\n    for (i = 0; i < 16; i++) {\n\n        h->block_offset[16 + i]      =\n\n        h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n\n        h->block_offset[48 + 16 + i] =\n\n        h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    for (i = 0; i < h->slice_context_count; i++)\n\n        if (h->thread_context[i]) {\n\n            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n    /* Some macroblocks can be accessed before they're available in case\n\n     * of lost slices, MBAFF or threading. */\n\n    memset(h->slice_table, -1,\n\n           (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n\n\n\n    // s->decode = (h->flags & CODEC_FLAG_PSNR) || !s->encoding ||\n\n    //             h->cur_pic.f.reference /* || h->contains_intra */ || 1;\n\n\n\n    /* We mark the current picture as non-reference after allocating it, so\n\n     * that if we break out due to an error it can be released automatically\n\n     * in the next ff_MPV_frame_start().\n\n     * SVQ3 as well as most other codecs have only last/next/current and thus\n\n     * get released even with set reference, besides SVQ3 and others do not\n\n     * mark frames as reference later \"naturally\". */\n\n    if (h->avctx->codec_id != AV_CODEC_ID_SVQ3)\n\n        h->cur_pic_ptr->f.reference = 0;\n\n\n\n    h->cur_pic_ptr->field_poc[0] = h->cur_pic_ptr->field_poc[1] = INT_MAX;\n\n\n\n    h->next_output_pic = NULL;\n\n\n\n    assert(h->cur_pic_ptr->long_ref == 0);\n\n\n\n    return 0;\n\n}\n", "idx": 269}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_rfe(DisasContext *s, TCGv_i32 pc, TCGv_i32 cpsr)\n\n{\n\n    gen_set_cpsr(cpsr, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(cpsr);\n\n    store_reg(s, 15, pc);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 270}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static void gen_mfc0(DisasContext *ctx, TCGv arg, int reg, int sel)\n\n{\n\n    const char *rn = \"invalid\";\n\n\n\n    if (sel != 0)\n\n        check_insn(ctx, ISA_MIPS32);\n\n\n\n    switch (reg) {\n\n    case 0:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Index));\n\n            rn = \"Index\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_mvpcontrol(arg, cpu_env);\n\n            rn = \"MVPControl\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_mvpconf0(arg, cpu_env);\n\n            rn = \"MVPConf0\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_mvpconf1(arg, cpu_env);\n\n            rn = \"MVPConf1\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->vp);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPControl));\n\n            rn = \"VPControl\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 1:\n\n        switch (sel) {\n\n        case 0:\n\n            CP0_CHECK(!(ctx->insn_flags & ISA_MIPS32R6));\n\n            gen_helper_mfc0_random(arg, cpu_env);\n\n            rn = \"Random\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEControl));\n\n            rn = \"VPEControl\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEConf0));\n\n            rn = \"VPEConf0\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEConf1));\n\n            rn = \"VPEConf1\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_YQMask));\n\n            rn = \"YQMask\";\n\n            break;\n\n        case 5:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_VPESchedule));\n\n            rn = \"VPESchedule\";\n\n            break;\n\n        case 6:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_VPEScheFBack));\n\n            rn = \"VPEScheFBack\";\n\n            break;\n\n        case 7:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEOpt));\n\n            rn = \"VPEOpt\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (sel) {\n\n        case 0:\n\n            {\n\n                TCGv_i64 tmp = tcg_temp_new_i64();\n\n                tcg_gen_ld_i64(tmp, cpu_env,\n\n                               offsetof(CPUMIPSState, CP0_EntryLo0));\n\n#if defined(TARGET_MIPS64)\n\n                if (ctx->rxi) {\n\n                    /* Move RI/XI fields to bits 31:30 */\n\n                    tcg_gen_shri_tl(arg, tmp, CP0EnLo_XI);\n\n                    tcg_gen_deposit_tl(tmp, tmp, arg, 30, 2);\n\n                }\n\n#endif\n\n                gen_move_low32(arg, tmp);\n\n                tcg_temp_free_i64(tmp);\n\n            }\n\n            rn = \"EntryLo0\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tcstatus(arg, cpu_env);\n\n            rn = \"TCStatus\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tcbind(arg, cpu_env);\n\n            rn = \"TCBind\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tcrestart(arg, cpu_env);\n\n            rn = \"TCRestart\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tchalt(arg, cpu_env);\n\n            rn = \"TCHalt\";\n\n            break;\n\n        case 5:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tccontext(arg, cpu_env);\n\n            rn = \"TCContext\";\n\n            break;\n\n        case 6:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tcschedule(arg, cpu_env);\n\n            rn = \"TCSchedule\";\n\n            break;\n\n        case 7:\n\n            CP0_CHECK(ctx->insn_flags & ASE_MT);\n\n            gen_helper_mfc0_tcschefback(arg, cpu_env);\n\n            rn = \"TCScheFBack\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 3:\n\n        switch (sel) {\n\n        case 0:\n\n            {\n\n                TCGv_i64 tmp = tcg_temp_new_i64();\n\n                tcg_gen_ld_i64(tmp, cpu_env,\n\n                               offsetof(CPUMIPSState, CP0_EntryLo1));\n\n#if defined(TARGET_MIPS64)\n\n                if (ctx->rxi) {\n\n                    /* Move RI/XI fields to bits 31:30 */\n\n                    tcg_gen_shri_tl(arg, tmp, CP0EnLo_XI);\n\n                    tcg_gen_deposit_tl(tmp, tmp, arg, 30, 2);\n\n                }\n\n#endif\n\n                gen_move_low32(arg, tmp);\n\n                tcg_temp_free_i64(tmp);\n\n            }\n\n            rn = \"EntryLo1\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->vp);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_GlobalNumber));\n\n            rn = \"GlobalNumber\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 4:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_Context));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"Context\";\n\n            break;\n\n        case 1:\n\n//            gen_helper_mfc0_contextconfig(arg); /* SmartMIPS ASE */\n\n            rn = \"ContextConfig\";\n\n            goto cp0_unimplemented;\n\n        case 2:\n\n            CP0_CHECK(ctx->ulri);\n\n            tcg_gen_ld_tl(arg, cpu_env,\n\n                          offsetof(CPUMIPSState, active_tc.CP0_UserLocal));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"UserLocal\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 5:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PageMask));\n\n            rn = \"PageMask\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PageGrain));\n\n            rn = \"PageGrain\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->sc);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl0));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"SegCtl0\";\n\n            break;\n\n        case 3:\n\n            CP0_CHECK(ctx->sc);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl1));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"SegCtl1\";\n\n            break;\n\n        case 4:\n\n            CP0_CHECK(ctx->sc);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl2));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"SegCtl2\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 6:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Wired));\n\n            rn = \"Wired\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf0));\n\n            rn = \"SRSConf0\";\n\n            break;\n\n        case 2:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf1));\n\n            rn = \"SRSConf1\";\n\n            break;\n\n        case 3:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf2));\n\n            rn = \"SRSConf2\";\n\n            break;\n\n        case 4:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf3));\n\n            rn = \"SRSConf3\";\n\n            break;\n\n        case 5:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf4));\n\n            rn = \"SRSConf4\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 7:\n\n        switch (sel) {\n\n        case 0:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_HWREna));\n\n            rn = \"HWREna\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 8:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_BadVAddr));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"BadVAddr\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->bi);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_BadInstr));\n\n            rn = \"BadInstr\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->bp);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_BadInstrP));\n\n            rn = \"BadInstrP\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 9:\n\n        switch (sel) {\n\n        case 0:\n\n            /* Mark as an IO operation because we read the time.  */\n\n            if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n\t    }\n\n            gen_helper_mfc0_count(arg, cpu_env);\n\n            if (ctx->tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n            }\n\n            /* Break the TB to be able to take timer interrupts immediately\n\n               after reading count. BS_STOP isn't sufficient, we need to ensure\n\n               we break completely out of translated code.  */\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Count\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 10:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EntryHi));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"EntryHi\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 11:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Compare));\n\n            rn = \"Compare\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 12:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Status));\n\n            rn = \"Status\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_IntCtl));\n\n            rn = \"IntCtl\";\n\n            break;\n\n        case 2:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSCtl));\n\n            rn = \"SRSCtl\";\n\n            break;\n\n        case 3:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSMap));\n\n            rn = \"SRSMap\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n       }\n\n        break;\n\n    case 13:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Cause));\n\n            rn = \"Cause\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n       }\n\n        break;\n\n    case 14:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EPC));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"EPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 15:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PRid));\n\n            rn = \"PRid\";\n\n            break;\n\n        case 1:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EBase));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"EBase\";\n\n            break;\n\n        case 3:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            CP0_CHECK(ctx->cmgcr);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_CMGCRBase));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"CMGCRBase\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n       }\n\n        break;\n\n    case 16:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config0));\n\n            rn = \"Config\";\n\n            break;\n\n        case 1:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config1));\n\n            rn = \"Config1\";\n\n            break;\n\n        case 2:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config2));\n\n            rn = \"Config2\";\n\n            break;\n\n        case 3:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config3));\n\n            rn = \"Config3\";\n\n            break;\n\n        case 4:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config4));\n\n            rn = \"Config4\";\n\n            break;\n\n        case 5:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config5));\n\n            rn = \"Config5\";\n\n            break;\n\n        /* 6,7 are implementation dependent */\n\n        case 6:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config6));\n\n            rn = \"Config6\";\n\n            break;\n\n        case 7:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config7));\n\n            rn = \"Config7\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 17:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mfc0_lladdr(arg, cpu_env);\n\n            rn = \"LLAddr\";\n\n            break;\n\n        case 1:\n\n            CP0_CHECK(ctx->mrp);\n\n            gen_helper_mfc0_maar(arg, cpu_env);\n\n            rn = \"MAAR\";\n\n            break;\n\n        case 2:\n\n            CP0_CHECK(ctx->mrp);\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_MAARI));\n\n            rn = \"MAARI\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 18:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_helper_1e0i(mfc0_watchlo, arg, sel);\n\n            rn = \"WatchLo\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 19:\n\n        switch (sel) {\n\n        case 0 ...7:\n\n            gen_helper_1e0i(mfc0_watchhi, arg, sel);\n\n            rn = \"WatchHi\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 20:\n\n        switch (sel) {\n\n        case 0:\n\n#if defined(TARGET_MIPS64)\n\n            check_insn(ctx, ISA_MIPS3);\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_XContext));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"XContext\";\n\n            break;\n\n#endif\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 21:\n\n       /* Officially reserved, but sel 0 is used for R1x000 framemask */\n\n        CP0_CHECK(!(ctx->insn_flags & ISA_MIPS32R6));\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Framemask));\n\n            rn = \"Framemask\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 22:\n\n        tcg_gen_movi_tl(arg, 0); /* unimplemented */\n\n        rn = \"'Diagnostic\"; /* implementation dependent */\n\n        break;\n\n    case 23:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_helper_mfc0_debug(arg, cpu_env); /* EJTAG support */\n\n            rn = \"Debug\";\n\n            break;\n\n        case 1:\n\n//            gen_helper_mfc0_tracecontrol(arg); /* PDtrace support */\n\n            rn = \"TraceControl\";\n\n            goto cp0_unimplemented;\n\n        case 2:\n\n//            gen_helper_mfc0_tracecontrol2(arg); /* PDtrace support */\n\n            rn = \"TraceControl2\";\n\n            goto cp0_unimplemented;\n\n        case 3:\n\n//            gen_helper_mfc0_usertracedata(arg); /* PDtrace support */\n\n            rn = \"UserTraceData\";\n\n            goto cp0_unimplemented;\n\n        case 4:\n\n//            gen_helper_mfc0_tracebpc(arg); /* PDtrace support */\n\n            rn = \"TraceBPC\";\n\n            goto cp0_unimplemented;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 24:\n\n        switch (sel) {\n\n        case 0:\n\n            /* EJTAG support */\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_DEPC));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"DEPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 25:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Performance0));\n\n            rn = \"Performance0\";\n\n            break;\n\n        case 1:\n\n//            gen_helper_mfc0_performance1(arg);\n\n            rn = \"Performance1\";\n\n            goto cp0_unimplemented;\n\n        case 2:\n\n//            gen_helper_mfc0_performance2(arg);\n\n            rn = \"Performance2\";\n\n            goto cp0_unimplemented;\n\n        case 3:\n\n//            gen_helper_mfc0_performance3(arg);\n\n            rn = \"Performance3\";\n\n            goto cp0_unimplemented;\n\n        case 4:\n\n//            gen_helper_mfc0_performance4(arg);\n\n            rn = \"Performance4\";\n\n            goto cp0_unimplemented;\n\n        case 5:\n\n//            gen_helper_mfc0_performance5(arg);\n\n            rn = \"Performance5\";\n\n            goto cp0_unimplemented;\n\n        case 6:\n\n//            gen_helper_mfc0_performance6(arg);\n\n            rn = \"Performance6\";\n\n            goto cp0_unimplemented;\n\n        case 7:\n\n//            gen_helper_mfc0_performance7(arg);\n\n            rn = \"Performance7\";\n\n            goto cp0_unimplemented;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 26:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_ErrCtl));\n\n            rn = \"ErrCtl\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 27:\n\n        switch (sel) {\n\n        case 0 ... 3:\n\n            tcg_gen_movi_tl(arg, 0); /* unimplemented */\n\n            rn = \"CacheErr\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 28:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            {\n\n                TCGv_i64 tmp = tcg_temp_new_i64();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUMIPSState, CP0_TagLo));\n\n                gen_move_low32(arg, tmp);\n\n                tcg_temp_free_i64(tmp);\n\n            }\n\n            rn = \"TagLo\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DataLo));\n\n            rn = \"DataLo\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 29:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_TagHi));\n\n            rn = \"TagHi\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DataHi));\n\n            rn = \"DataHi\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 30:\n\n        switch (sel) {\n\n        case 0:\n\n            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_ErrorEPC));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"ErrorEPC\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    case 31:\n\n        switch (sel) {\n\n        case 0:\n\n            /* EJTAG support */\n\n            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DESAVE));\n\n            rn = \"DESAVE\";\n\n            break;\n\n        case 2 ... 7:\n\n            CP0_CHECK(ctx->kscrexist & (1 << sel));\n\n            tcg_gen_ld_tl(arg, cpu_env,\n\n                          offsetof(CPUMIPSState, CP0_KScratch[sel-2]));\n\n            tcg_gen_ext32s_tl(arg, arg);\n\n            rn = \"KScratch\";\n\n            break;\n\n        default:\n\n            goto cp0_unimplemented;\n\n        }\n\n        break;\n\n    default:\n\n       goto cp0_unimplemented;\n\n    }\n\n    trace_mips_translate_c0(\"mfc0\", rn, reg, sel);\n\n    return;\n\n\n\ncp0_unimplemented:\n\n    qemu_log_mask(LOG_UNIMP, \"mfc0 %s (reg %d sel %d)\\n\", rn, reg, sel);\n\n    gen_mfc0_unimplemented(ctx, arg);\n\n}\n", "idx": 271}
{"project": "qemu", "commit_id": "7d03f82f81e0e6c106ca0d2445a0fc49dc9ddc7b", "target": 1, "func": "static int gdb_handle_packet(GDBState *s, CPUState *env, const char *line_buf)\n\n{\n\n    const char *p;\n\n    int ch, reg_size, type;\n\n    char buf[4096];\n\n    uint8_t mem_buf[4096];\n\n    uint32_t *registers;\n\n    target_ulong addr, len;\n\n\n\n#ifdef DEBUG_GDB\n\n    printf(\"command='%s'\\n\", line_buf);\n\n#endif\n\n    p = line_buf;\n\n    ch = *p++;\n\n    switch(ch) {\n\n    case '?':\n\n        /* TODO: Make this return the correct value for user-mode.  */\n\n        snprintf(buf, sizeof(buf), \"S%02x\", SIGTRAP);\n\n        put_packet(s, buf);\n\n        /* Remove all the breakpoints when this query is issued,\n\n         * because gdb is doing and initial connect and the state\n\n         * should be cleaned up.\n\n         */\n\n\n\n\n    case 'c':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n#if defined(TARGET_I386)\n\n            env->eip = addr;\n\n#elif defined (TARGET_PPC)\n\n            env->nip = addr;\n\n#elif defined (TARGET_SPARC)\n\n            env->pc = addr;\n\n            env->npc = addr + 4;\n\n#elif defined (TARGET_ARM)\n\n            env->regs[15] = addr;\n\n#elif defined (TARGET_SH4)\n\n            env->pc = addr;\n\n#elif defined (TARGET_MIPS)\n\n            env->PC[env->current_tc] = addr;\n\n#elif defined (TARGET_CRIS)\n\n            env->pc = addr;\n\n#endif\n\n        }\n\n\n\treturn RS_IDLE;\n\n\n\n\n\n\n\n\n\n\n\n\n    case 's':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n#if defined(TARGET_I386)\n\n            env->eip = addr;\n\n#elif defined (TARGET_PPC)\n\n            env->nip = addr;\n\n#elif defined (TARGET_SPARC)\n\n            env->pc = addr;\n\n            env->npc = addr + 4;\n\n#elif defined (TARGET_ARM)\n\n            env->regs[15] = addr;\n\n#elif defined (TARGET_SH4)\n\n            env->pc = addr;\n\n#elif defined (TARGET_MIPS)\n\n            env->PC[env->current_tc] = addr;\n\n#elif defined (TARGET_CRIS)\n\n            env->pc = addr;\n\n#endif\n\n        }\n\n        cpu_single_step(env, sstep_flags);\n\n\n\treturn RS_IDLE;\n\n    case 'F':\n\n        {\n\n            target_ulong ret;\n\n            target_ulong err;\n\n\n\n            ret = strtoull(p, (char **)&p, 16);\n\n            if (*p == ',') {\n\n                p++;\n\n                err = strtoull(p, (char **)&p, 16);\n\n            } else {\n\n                err = 0;\n\n            }\n\n            if (*p == ',')\n\n                p++;\n\n            type = *p;\n\n            if (gdb_current_syscall_cb)\n\n                gdb_current_syscall_cb(s->env, ret, err);\n\n            if (type == 'C') {\n\n                put_packet(s, \"T02\");\n\n            } else {\n\n\n            }\n\n        }\n\n\n    case 'g':\n\n        reg_size = cpu_gdb_read_registers(env, mem_buf);\n\n        memtohex(buf, mem_buf, reg_size);\n\n        put_packet(s, buf);\n\n\n    case 'G':\n\n        registers = (void *)mem_buf;\n\n        len = strlen(p) / 2;\n\n        hextomem((uint8_t *)registers, p, len);\n\n        cpu_gdb_write_registers(env, mem_buf, len);\n\n\n\n    case 'm':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, NULL, 16);\n\n        if (cpu_memory_rw_debug(env, addr, mem_buf, len, 0) != 0) {\n\n            put_packet (s, \"E14\");\n\n        } else {\n\n            memtohex(buf, mem_buf, len);\n\n            put_packet(s, buf);\n\n        }\n\n\n    case 'M':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (*p == ':')\n\n            p++;\n\n        hextomem(mem_buf, p, len);\n\n        if (cpu_memory_rw_debug(env, addr, mem_buf, len, 1) != 0)\n\n            put_packet(s, \"E14\");\n\n        else\n\n\n\n    case 'Z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (type == 0 || type == 1) {\n\n            if (cpu_breakpoint_insert(env, addr) < 0)\n\n                goto breakpoint_error;\n\n\n#ifndef CONFIG_USER_ONLY\n\n        } else if (type == 2) {\n\n            if (cpu_watchpoint_insert(env, addr) < 0)\n\n                goto breakpoint_error;\n\n\n#endif\n\n        } else {\n\n        breakpoint_error:\n\n            put_packet(s, \"E22\");\n\n        }\n\n\n    case 'z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (type == 0 || type == 1) {\n\n            cpu_breakpoint_remove(env, addr);\n\n\n#ifndef CONFIG_USER_ONLY\n\n        } else if (type == 2) {\n\n            cpu_watchpoint_remove(env, addr);\n\n\n#endif\n\n        } else {\n\n            goto breakpoint_error;\n\n        }\n\n\n    case 'q':\n\n    case 'Q':\n\n        /* parse any 'q' packets here */\n\n        if (!strcmp(p,\"qemu.sstepbits\")) {\n\n            /* Query Breakpoint bit definitions */\n\n            sprintf(buf,\"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n\n                    SSTEP_ENABLE,\n\n                    SSTEP_NOIRQ,\n\n                    SSTEP_NOTIMER);\n\n            put_packet(s, buf);\n\n\n        } else if (strncmp(p,\"qemu.sstep\",10) == 0) {\n\n            /* Display or change the sstep_flags */\n\n            p += 10;\n\n            if (*p != '=') {\n\n                /* Display current setting */\n\n                sprintf(buf,\"0x%x\", sstep_flags);\n\n                put_packet(s, buf);\n\n\n            }\n\n            p++;\n\n            type = strtoul(p, (char **)&p, 16);\n\n            sstep_flags = type;\n\n\n\n        }\n\n#ifdef CONFIG_LINUX_USER\n\n        else if (strncmp(p, \"Offsets\", 7) == 0) {\n\n            TaskState *ts = env->opaque;\n\n\n\n            sprintf(buf,\n\n                    \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n\n                    \";Bss=\" TARGET_ABI_FMT_lx,\n\n                    ts->info->code_offset,\n\n                    ts->info->data_offset,\n\n                    ts->info->data_offset);\n\n            put_packet(s, buf);\n\n\n        }\n\n#endif\n\n        /* Fall through.  */\n\n    default:\n\n        /* put empty packet */\n\n        buf[0] = '\\0';\n\n        put_packet(s, buf);\n\n\n    }\n\n    return RS_IDLE;\n\n}", "idx": 273}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_ac_filter(WmallDecodeCtx *s)\n\n{\n\n    int i;\n\n    s->acfilter_order = get_bits(&s->gb, 4) + 1;\n\n    s->acfilter_scaling = get_bits(&s->gb, 4);\n\n\n\n    for(i = 0; i < s->acfilter_order; i++) {\n\n\ts->acfilter_coeffs[i] = get_bits(&s->gb, s->acfilter_scaling) + 1;\n\n    }\n\n}\n", "idx": 275}
{"project": "FFmpeg", "commit_id": "54a0a52be100d36291084f92b7d6aee1a4960acb", "target": 1, "func": "static void check_loopfilter(void)\n\n{\n\n    LOCAL_ALIGNED_32(uint8_t, base0, [32 + 16 * 16 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, base1, [32 + 16 * 16 * 2]);\n\n    VP9DSPContext dsp;\n\n    int dir, wd, wd2, bit_depth;\n\n    static const char *const dir_name[2] = { \"h\", \"v\" };\n\n    static const int E[2] = { 20, 28 }, I[2] = { 10, 16 };\n\n    static const int H[2] = { 7, 11 }, F[2] = { 1, 1 };\n\n    declare_func(void, uint8_t *dst, ptrdiff_t stride, int E, int I, int H);\n\n\n\n    for (bit_depth = 8; bit_depth <= 12; bit_depth += 2) {\n\n        ff_vp9dsp_init(&dsp, bit_depth, 0);\n\n\n\n        for (dir = 0; dir < 2; dir++) {\n\n            int midoff = (dir ? 8 * 8 : 8) * SIZEOF_PIXEL;\n\n            int midoff_aligned = (dir ? 8 * 8 : 16) * SIZEOF_PIXEL;\n\n            uint8_t *buf0 = base0 + midoff_aligned;\n\n            uint8_t *buf1 = base1 + midoff_aligned;\n\n\n\n            for (wd = 0; wd < 3; wd++) {\n\n                // 4/8/16wd_8px\n\n                if (check_func(dsp.loop_filter_8[wd][dir],\n\n                               \"vp9_loop_filter_%s_%d_8_%dbpp\",\n\n                               dir_name[dir], 4 << wd, bit_depth)) {\n\n                    randomize_buffers(0, 0, 8);\n\n                    memcpy(buf1 - midoff, buf0 - midoff,\n\n                           16 * 8 * SIZEOF_PIXEL);\n\n                    call_ref(buf0, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);\n\n                    call_new(buf1, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);\n\n                    if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 8 * SIZEOF_PIXEL))\n\n                        fail();\n\n                    bench_new(buf1, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);\n\n                }\n\n            }\n\n\n\n            midoff = (dir ? 16 * 8 : 8) * SIZEOF_PIXEL;\n\n            midoff_aligned = (dir ? 16 * 8 : 16) * SIZEOF_PIXEL;\n\n\n\n            buf0 = base0 + midoff_aligned;\n\n            buf1 = base1 + midoff_aligned;\n\n\n\n            // 16wd_16px loopfilter\n\n            if (check_func(dsp.loop_filter_16[dir],\n\n                           \"vp9_loop_filter_%s_16_16_%dbpp\",\n\n                           dir_name[dir], bit_depth)) {\n\n                randomize_buffers(0, 0, 16);\n\n                randomize_buffers(0, 8, 16);\n\n                memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n\n                call_ref(buf0, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);\n\n                call_new(buf1, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);\n\n                if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n\n                    fail();\n\n                bench_new(buf1, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);\n\n            }\n\n\n\n            for (wd = 0; wd < 2; wd++) {\n\n                for (wd2 = 0; wd2 < 2; wd2++) {\n\n                    // mix2 loopfilter\n\n                    if (check_func(dsp.loop_filter_mix2[wd][wd2][dir],\n\n                                   \"vp9_loop_filter_mix2_%s_%d%d_16_%dbpp\",\n\n                                   dir_name[dir], 4 << wd, 4 << wd2, bit_depth)) {\n\n                        randomize_buffers(0, 0, 16);\n\n                        randomize_buffers(1, 8, 16);\n\n                        memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n\n#define M(a) (((a)[1] << 8) | (a)[0])\n\n                        call_ref(buf0, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));\n\n                        call_new(buf1, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));\n\n                        if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n\n                            fail();\n\n                        bench_new(buf1, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));\n\n#undef M\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    report(\"loopfilter\");\n\n}\n", "idx": 276}
{"project": "FFmpeg", "commit_id": "1bf8fa75ee148f40938d47bb9aaf53ac3c1ae126", "target": 1, "func": "av_cold void ff_dsputil_init_x86(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_7REGS && HAVE_INLINE_ASM\n\n    if (HAVE_MMX && cpu_flags & AV_CPU_FLAG_CMOV)\n\n        c->add_hfyu_median_prediction = ff_add_hfyu_median_prediction_cmov;\n\n#endif\n\n\n\n    if (X86_MMX(cpu_flags)) {\n\n#if HAVE_INLINE_ASM\n\n        const int idct_algo = avctx->idct_algo;\n\n\n\n        if (avctx->lowres == 0 && avctx->bits_per_raw_sample <= 8) {\n\n            if (idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_SIMPLEMMX) {\n\n                c->idct_put              = ff_simple_idct_put_mmx;\n\n                c->idct_add              = ff_simple_idct_add_mmx;\n\n                c->idct                  = ff_simple_idct_mmx;\n\n                c->idct_permutation_type = FF_SIMPLE_IDCT_PERM;\n\n            } else if (idct_algo == FF_IDCT_XVIDMMX) {\n\n                if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n                    c->idct_put              = ff_idct_xvid_sse2_put;\n\n                    c->idct_add              = ff_idct_xvid_sse2_add;\n\n                    c->idct                  = ff_idct_xvid_sse2;\n\n                    c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n                } else if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n                    c->idct_put              = ff_idct_xvid_mmxext_put;\n\n                    c->idct_add              = ff_idct_xvid_mmxext_add;\n\n                    c->idct                  = ff_idct_xvid_mmxext;\n\n                } else {\n\n                    c->idct_put              = ff_idct_xvid_mmx_put;\n\n                    c->idct_add              = ff_idct_xvid_mmx_add;\n\n                    c->idct                  = ff_idct_xvid_mmx;\n\n                }\n\n            }\n\n        }\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n        dsputil_init_mmx(c, avctx, cpu_flags);\n\n    }\n\n\n\n    if (X86_MMXEXT(cpu_flags))\n\n        dsputil_init_mmxext(c, avctx, cpu_flags);\n\n\n\n    if (X86_SSE(cpu_flags))\n\n        dsputil_init_sse(c, avctx, cpu_flags);\n\n\n\n    if (X86_SSE2(cpu_flags))\n\n        dsputil_init_sse2(c, avctx, cpu_flags);\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags))\n\n        dsputil_init_ssse3(c, avctx, cpu_flags);\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags))\n\n        dsputil_init_sse4(c, avctx, cpu_flags);\n\n\n\n    if (CONFIG_ENCODERS)\n\n        ff_dsputilenc_init_mmx(c, avctx);\n\n}\n", "idx": 277}
{"project": "FFmpeg", "commit_id": "7a4652dd5da0502ff21c183b5ca7d76b1cfd6c51", "target": 1, "func": "static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n\n                                       SingleChannelElement *sce,\n\n                                       const float lambda)\n\n{\n\n    int q, w, w2, g, start = 0;\n\n    int i, j;\n\n    int idx;\n\n    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];\n\n    int bandaddr[TRELLIS_STAGES];\n\n    int minq;\n\n    float mincost;\n\n    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;\n\n    int q0, q1, qcnt = 0;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        float t = fabsf(sce->coeffs[i]);\n\n        if (t > 0.0f) {\n\n            q0f = FFMIN(q0f, t);\n\n            q1f = FFMAX(q1f, t);\n\n            qnrgf += t*t;\n\n            qcnt++;\n\n        }\n\n    }\n\n\n\n    if (!qcnt) {\n\n        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n\n        memset(sce->zeroes, 1, sizeof(sce->zeroes));\n\n        return;\n\n    }\n\n\n\n    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n    q0 = coef2minsf(q0f);\n\n    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n    q1 = coef2maxsf(q1f);\n\n    if (q1 - q0 > 60) {\n\n        int q0low  = q0;\n\n        int q1high = q1;\n\n        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped\n\n        int qnrg = av_clip_uint8(log2f(sqrtf(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);\n\n        q1 = qnrg + 30;\n\n        q0 = qnrg - 30;\n\n        if (q0 < q0low) {\n\n            q1 += q0low - q0;\n\n            q0  = q0low;\n\n        } else if (q1 > q1high) {\n\n            q0 -= q1 - q1high;\n\n            q1  = q1high;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < TRELLIS_STATES; i++) {\n\n        paths[0][i].cost    = 0.0f;\n\n        paths[0][i].prev    = -1;\n\n    }\n\n    for (j = 1; j < TRELLIS_STAGES; j++) {\n\n        for (i = 0; i < TRELLIS_STATES; i++) {\n\n            paths[j][i].cost    = INFINITY;\n\n            paths[j][i].prev    = -2;\n\n        }\n\n    }\n\n    idx = 1;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {\n\n        start = w*128;\n\n        for (g = 0; g < sce->ics.num_swb; g++) {\n\n            const float *coefs = &sce->coeffs[start];\n\n            float qmin, qmax;\n\n            int nz = 0;\n\n\n\n            bandaddr[idx] = w * 16 + g;\n\n            qmin = INT_MAX;\n\n            qmax = 0.0f;\n\n            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];\n\n                if (band->energy <= band->threshold || band->threshold == 0.0f) {\n\n                    sce->zeroes[(w+w2)*16+g] = 1;\n\n                    continue;\n\n                }\n\n                sce->zeroes[(w+w2)*16+g] = 0;\n\n                nz = 1;\n\n                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {\n\n                    float t = fabsf(coefs[w2*128+i]);\n\n                    if (t > 0.0f)\n\n                        qmin = FFMIN(qmin, t);\n\n                    qmax = FFMAX(qmax, t);\n\n                }\n\n            }\n\n            if (nz) {\n\n                int minscale, maxscale;\n\n                float minrd = INFINITY;\n\n                float maxval;\n\n                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n                minscale = coef2minsf(qmin);\n\n                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n                maxscale = coef2maxsf(qmax);\n\n                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);\n\n                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);\n\n                maxval = find_max_val(sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);\n\n                for (q = minscale; q < maxscale; q++) {\n\n                    float dist = 0;\n\n                    int cb = find_min_book(maxval, sce->sf_idx[w*16+g]);\n\n                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                        FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];\n\n                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],\n\n                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, NULL, 0);\n\n                    }\n\n                    minrd = FFMIN(minrd, dist);\n\n\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        cost = paths[idx - 1][i].cost + dist\n\n                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                    paths[idx][q].prev = q;\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n", "idx": 278}
{"project": "qemu", "commit_id": "89cad9f3ec6b30d7550fb5704475fc9c3393a066", "target": 1, "func": "QDict *qdict_get_qdict(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qdict(qdict_get_obj(qdict, key, QTYPE_QDICT));\n\n}\n", "idx": 279}
{"project": "FFmpeg", "commit_id": "108957c661f9e2dc35dea8d55e5e5b1776f4a303", "target": 1, "func": "static int guess_ni_flag(AVFormatContext *s){\n\n    int i;\n\n    int64_t last_start=0;\n\n    int64_t first_end= INT64_MAX;\n\n    int64_t oldpos= avio_tell(s->pb);\n\n    int *idx;\n\n    int64_t min_pos, pos;\n\n\n\n    for(i=0; i<s->nb_streams; i++){\n\n        AVStream *st = s->streams[i];\n\n        int n= st->nb_index_entries;\n\n        unsigned int size;\n\n\n\n        if(n <= 0)\n\n            continue;\n\n\n\n        if(n >= 2){\n\n            int64_t pos= st->index_entries[0].pos;\n\n            avio_seek(s->pb, pos + 4, SEEK_SET);\n\n            size= avio_rl32(s->pb);\n\n            if(pos + size > st->index_entries[1].pos)\n\n                last_start= INT64_MAX;\n\n        }\n\n\n\n        if(st->index_entries[0].pos > last_start)\n\n            last_start= st->index_entries[0].pos;\n\n        if(st->index_entries[n-1].pos < first_end)\n\n            first_end= st->index_entries[n-1].pos;\n\n    }\n\n    avio_seek(s->pb, oldpos, SEEK_SET);\n\n    if (last_start > first_end)\n\n        return 1;\n\n    idx= av_mallocz(sizeof(*idx) * s->nb_streams);\n\n    for (min_pos=pos=0; min_pos!=INT64_MAX; pos= min_pos+1) {\n\n        int64_t max_dts = INT64_MIN/2, min_dts= INT64_MAX/2;\n\n        min_pos = INT64_MAX;\n\n\n\n        for (i=0; i<s->nb_streams; i++) {\n\n            AVStream *st = s->streams[i];\n\n            int n= st->nb_index_entries;\n\n            while (idx[i]<n && st->index_entries[idx[i]].pos < pos)\n\n                idx[i]++;\n\n            if (idx[i] < n) {\n\n                min_dts = FFMIN(min_dts, av_rescale_q(st->index_entries[idx[i]].timestamp, st->time_base, AV_TIME_BASE_Q));\n\n                min_pos = FFMIN(min_pos, st->index_entries[idx[i]].pos);\n\n            }\n\n            if (idx[i])\n\n                max_dts = FFMAX(max_dts, av_rescale_q(st->index_entries[idx[i]-1].timestamp, st->time_base, AV_TIME_BASE_Q));\n\n        }\n\n        if(max_dts - min_dts > 2*AV_TIME_BASE) {\n\n            av_free(idx);\n\n            return 1;\n\n        }\n\n    }\n\n    av_free(idx);\n\n    return 0;\n\n}\n", "idx": 281}
{"project": "FFmpeg", "commit_id": "56c182c4d716b8b72156ff57a0c8d72087db8549", "target": 1, "func": "static int nut_write_trailer(AVFormatContext *s)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    AVIOContext *bc = s->pb, *dyn_bc;\n\n    int i, ret;\n\n\n\n    while (nut->header_count < 3)\n\n        write_headers(s, bc);\n\n\n\n    ret = avio_open_dyn_buf(&dyn_bc);\n\n    if (ret >= 0 && nut->sp_count) {\n\n        av_assert1(nut->write_index);\n\n        write_index(nut, dyn_bc);\n\n        put_packet(nut, bc, dyn_bc, 1, INDEX_STARTCODE);\n\n    }\n\n\n\n    ff_nut_free_sp(nut);\n\n    for (i=0; i<s->nb_streams; i++)\n\n        av_freep(&nut->stream[i].keyframe_pts);\n\n\n\n    av_freep(&nut->stream);\n\n    av_freep(&nut->chapter);\n\n    av_freep(&nut->time_base);\n\n\n\n    return 0;\n\n}\n", "idx": 282}
{"project": "qemu", "commit_id": "3b39d734141a71296d08af3d4c32f872fafd782e", "target": 1, "func": "static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldl_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldl_le(as, addr, attrs, NULL);\n\n    }\n\n}\n", "idx": 283}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_context_acquire(AioContext *ctx)\n\n{\n\n    qemu_rec_mutex_lock(&ctx->lock);\n\n}\n", "idx": 284}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "static void qjson_finalizefn(Object *obj)\n\n{\n\n    QJSON *json = QJSON(obj);\n\n\n\n    qobject_decref(QOBJECT(json->str));\n\n}\n", "idx": 285}
{"project": "qemu", "commit_id": "678421650dc166cd6cb35bb2bc0baf1b481b40ca", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t v32, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t val, oldval, newval;\n\n\n\n    if (addr & 4) {\n\n        val = v32 << 32 | s->latch_tmp;\n\n        addr ^= 4;\n\n    } else {\n\n        s->latch_tmp = v32;\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 286}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    data->qov = qmp_output_visitor_new();\n\n    g_assert(data->qov != NULL);\n\n\n\n    data->ov = qmp_output_get_visitor(data->qov);\n\n    g_assert(data->ov != NULL);\n\n}\n", "idx": 287}
{"project": "FFmpeg", "commit_id": "4b90c35d74880b07c50b3392a338f0f00d10302f", "target": 0, "func": "static void group_exponents(AC3EncodeContext *s)\n\n{\n\n    int blk, ch, i;\n\n    int group_size, nb_groups, bit_count;\n\n    uint8_t *p;\n\n    int delta0, delta1, delta2;\n\n    int exp0, exp1;\n\n\n\n    bit_count = 0;\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            if (s->exp_strategy[ch][blk] == EXP_REUSE)\n\n                continue;\n\n            group_size = s->exp_strategy[ch][blk] + (s->exp_strategy[ch][blk] == EXP_D45);\n\n            nb_groups = exponent_group_tab[s->exp_strategy[ch][blk]-1][s->nb_coefs[ch]];\n\n            bit_count += 4 + (nb_groups * 7);\n\n            p = block->exp[ch];\n\n\n\n            /* DC exponent */\n\n            exp1 = *p++;\n\n            block->grouped_exp[ch][0] = exp1;\n\n\n\n            /* remaining exponents are delta encoded */\n\n            for (i = 1; i <= nb_groups; i++) {\n\n                /* merge three delta in one code */\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta0 = exp1 - exp0 + 2;\n\n\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta1 = exp1 - exp0 + 2;\n\n\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta2 = exp1 - exp0 + 2;\n\n\n\n                block->grouped_exp[ch][i] = ((delta0 * 5 + delta1) * 5) + delta2;\n\n            }\n\n        }\n\n    }\n\n\n\n    s->exponent_bits = bit_count;\n\n}\n", "idx": 288}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void sd_write_data(SDState *sd, uint8_t value)\n\n{\n\n    int i;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return;\n\n\n\n    if (sd->state != sd_receivingdata_state) {\n\n        fprintf(stderr, \"sd_write_data: not in Receiving-Data state\\n\");\n\n        return;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 24:\t/* CMD24:  WRITE_SINGLE_BLOCK */\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            /* TODO: Check CRC before committing */\n\n            sd->state = sd_programming_state;\n\n            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->blk_written ++;\n\n            sd->csd[14] |= 0x40;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 25:\t/* CMD25:  WRITE_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0) {\n\n            /* Start of the block - let's check the address is valid */\n\n            if (sd->data_start + sd->blk_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n            if (sd_wp_addr(sd, sd->data_start)) {\n\n                sd->card_status |= WP_VIOLATION;\n\n                break;\n\n            }\n\n        }\n\n        sd->data[sd->data_offset++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            /* TODO: Check CRC before committing */\n\n            sd->state = sd_programming_state;\n\n            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->blk_written++;\n\n            sd->data_start += sd->blk_len;\n\n            sd->data_offset = 0;\n\n            sd->csd[14] |= 0x40;\n\n\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_receivingdata_state;\n\n        }\n\n        break;\n\n\n\n    case 26:\t/* CMD26:  PROGRAM_CID */\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sizeof(sd->cid)) {\n\n            /* TODO: Check CRC before committing */\n\n            sd->state = sd_programming_state;\n\n            for (i = 0; i < sizeof(sd->cid); i ++)\n\n                if ((sd->cid[i] | 0x00) != sd->data[i])\n\n                    sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            if (!(sd->card_status & CID_CSD_OVERWRITE))\n\n                for (i = 0; i < sizeof(sd->cid); i ++) {\n\n                    sd->cid[i] |= 0x00;\n\n                    sd->cid[i] &= sd->data[i];\n\n                }\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 27:\t/* CMD27:  PROGRAM_CSD */\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sizeof(sd->csd)) {\n\n            /* TODO: Check CRC before committing */\n\n            sd->state = sd_programming_state;\n\n            for (i = 0; i < sizeof(sd->csd); i ++)\n\n                if ((sd->csd[i] | sd_csd_rw_mask[i]) !=\n\n                    (sd->data[i] | sd_csd_rw_mask[i]))\n\n                    sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            /* Copy flag (OTP) & Permanent write protect */\n\n            if (sd->csd[14] & ~sd->data[14] & 0x60)\n\n                sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            if (!(sd->card_status & CID_CSD_OVERWRITE))\n\n                for (i = 0; i < sizeof(sd->csd); i ++) {\n\n                    sd->csd[i] |= sd_csd_rw_mask[i];\n\n                    sd->csd[i] &= sd->data[i];\n\n                }\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 42:\t/* CMD42:  LOCK_UNLOCK */\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            /* TODO: Check CRC before committing */\n\n            sd->state = sd_programming_state;\n\n            sd_lock_command(sd);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            APP_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_write_data: unknown command\\n\");\n\n        break;\n\n    }\n\n}\n", "idx": 290}
{"project": "qemu", "commit_id": "d0cc2fbfa607678866475383c508be84818ceb64", "target": 0, "func": "int event_notifier_get_fd(EventNotifier *e)\n\n{\n\n    return e->fd;\n\n}\n", "idx": 291}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "opts_type_size(Visitor *v, const char *name, uint64_t *obj, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    const QemuOpt *opt;\n\n    int64_t val;\n\n\n\n    opt = lookup_scalar(ov, name, errp);\n\n    if (!opt) {\n\n        return;\n\n    }\n\n\n\n    val = qemu_strtosz(opt->str ? opt->str : \"\", NULL);\n\n    if (val < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, opt->name,\n\n                   \"a size value representible as a non-negative int64\");\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n    processed(ov, name);\n\n}\n", "idx": 293}
{"project": "qemu", "commit_id": "24952847ad50f1b120287fdc4469b78108eef33c", "target": 0, "func": "static void handle_mousemotion(SDL_Event *ev)\n\n{\n\n    int max_x, max_y;\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n\n\n    if (qemu_input_is_absolute() || absolute_enabled) {\n\n        int scr_w, scr_h;\n\n        SDL_GetWindowSize(scon->real_window, &scr_w, &scr_h);\n\n        max_x = scr_w - 1;\n\n        max_y = scr_h - 1;\n\n        if (gui_grab && (ev->motion.x == 0 || ev->motion.y == 0 ||\n\n                         ev->motion.x == max_x || ev->motion.y == max_y)) {\n\n            sdl_grab_end(scon);\n\n        }\n\n        if (!gui_grab &&\n\n            (ev->motion.x > 0 && ev->motion.x < max_x &&\n\n             ev->motion.y > 0 && ev->motion.y < max_y)) {\n\n            sdl_grab_start(scon);\n\n        }\n\n    }\n\n    if (gui_grab || qemu_input_is_absolute() || absolute_enabled) {\n\n        sdl_send_mouse_event(scon, ev->motion.xrel, ev->motion.yrel,\n\n                             ev->motion.x, ev->motion.y, ev->motion.state);\n\n    }\n\n}\n", "idx": 294}
{"project": "qemu", "commit_id": "885e8f984ea846e79a39ddc4f066f4dd3d04b264", "target": 0, "func": "static int qemu_rdma_registration_stop(QEMUFile *f, void *opaque,\n\n                                       uint64_t flags)\n\n{\n\n    Error *local_err = NULL, **errp = &local_err;\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMAControlHeader head = { .len = 0, .repeat = 1 };\n\n    int ret = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    qemu_fflush(f);\n\n    ret = qemu_rdma_drain_cq(f, rdma);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (flags == RAM_CONTROL_SETUP) {\n\n        RDMAControlHeader resp = {.type = RDMA_CONTROL_RAM_BLOCKS_RESULT };\n\n        RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n        int reg_result_idx, i, j, nb_remote_blocks;\n\n\n\n        head.type = RDMA_CONTROL_RAM_BLOCKS_REQUEST;\n\n        DPRINTF(\"Sending registration setup for ram blocks...\\n\");\n\n\n\n        /*\n\n         * Make sure that we parallelize the pinning on both sides.\n\n         * For very large guests, doing this serially takes a really\n\n         * long time, so we have to 'interleave' the pinning locally\n\n         * with the control messages by performing the pinning on this\n\n         * side before we receive the control response from the other\n\n         * side that the pinning has completed.\n\n         */\n\n        ret = qemu_rdma_exchange_send(rdma, &head, NULL, &resp,\n\n                    &reg_result_idx, rdma->pin_all ?\n\n                    qemu_rdma_reg_whole_ram_blocks : NULL);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"receiving remote info!\");\n\n            return ret;\n\n        }\n\n\n\n        qemu_rdma_move_header(rdma, reg_result_idx, &resp);\n\n        memcpy(rdma->block,\n\n            rdma->wr_data[reg_result_idx].control_curr, resp.len);\n\n\n\n        nb_remote_blocks = resp.len / sizeof(RDMARemoteBlock);\n\n\n\n        /*\n\n         * The protocol uses two different sets of rkeys (mutually exclusive):\n\n         * 1. One key to represent the virtual address of the entire ram block.\n\n         *    (dynamic chunk registration disabled - pin everything with one rkey.)\n\n         * 2. One to represent individual chunks within a ram block.\n\n         *    (dynamic chunk registration enabled - pin individual chunks.)\n\n         *\n\n         * Once the capability is successfully negotiated, the destination transmits\n\n         * the keys to use (or sends them later) including the virtual addresses\n\n         * and then propagates the remote ram block descriptions to his local copy.\n\n         */\n\n\n\n        if (local->nb_blocks != nb_remote_blocks) {\n\n            ERROR(errp, \"ram blocks mismatch #1! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        for (i = 0; i < nb_remote_blocks; i++) {\n\n            network_to_remote_block(&rdma->block[i]);\n\n\n\n            /* search local ram blocks */\n\n            for (j = 0; j < local->nb_blocks; j++) {\n\n                if (rdma->block[i].offset != local->block[j].offset) {\n\n                    continue;\n\n                }\n\n\n\n                if (rdma->block[i].length != local->block[j].length) {\n\n                    ERROR(errp, \"ram blocks mismatch #2! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n                    return -EINVAL;\n\n                }\n\n                local->block[j].remote_host_addr =\n\n                        rdma->block[i].remote_host_addr;\n\n                local->block[j].remote_rkey = rdma->block[i].remote_rkey;\n\n                break;\n\n            }\n\n\n\n            if (j >= local->nb_blocks) {\n\n                ERROR(errp, \"ram blocks mismatch #3! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n\n\n    DDDPRINTF(\"Sending registration finish %\" PRIu64 \"...\\n\", flags);\n\n\n\n    head.type = RDMA_CONTROL_REGISTER_FINISHED;\n\n    ret = qemu_rdma_exchange_send(rdma, &head, NULL, NULL, NULL, NULL);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    return 0;\n\nerr:\n\n    rdma->error_state = ret;\n\n    return ret;\n\n}\n", "idx": 295}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void xen_platform_ioport_writeb(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIXenPlatformState *s = opaque;\n\n\n\n    addr &= 0xff;\n\n    val  &= 0xff;\n\n\n\n    switch (addr) {\n\n    case 0: /* Platform flags */\n\n        platform_fixed_ioport_writeb(opaque, XEN_PLATFORM_IOPORT, val);\n\n        break;\n\n    case 8:\n\n        log_writeb(s, val);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 296}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static uint32_t nabm_readb (void *opaque, uint32_t addr)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    AC97BusMasterRegs *r = NULL;\n\n    uint32_t index = addr - s->base[1];\n\n    uint32_t val = ~0U;\n\n\n\n    switch (index) {\n\n    case CAS:\n\n        dolog (\"CAS %d\\n\", s->cas);\n\n        val = s->cas;\n\n        s->cas = 1;\n\n        break;\n\n    case PI_CIV:\n\n    case PO_CIV:\n\n    case MC_CIV:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->civ;\n\n        dolog (\"CIV[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_LVI:\n\n    case PO_LVI:\n\n    case MC_LVI:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->lvi;\n\n        dolog (\"LVI[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_PIV:\n\n    case PO_PIV:\n\n    case MC_PIV:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->piv;\n\n        dolog (\"PIV[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_CR:\n\n    case PO_CR:\n\n    case MC_CR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->cr;\n\n        dolog (\"CR[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_SR:\n\n    case PO_SR:\n\n    case MC_SR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->sr & 0xff;\n\n        dolog (\"SRb[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    default:\n\n        dolog (\"U nabm readb %#x -> %#x\\n\", addr, val);\n\n        break;\n\n    }\n\n    return val;\n\n}\n", "idx": 297}
{"project": "FFmpeg", "commit_id": "dc0bc0f84ec3ecc475182c5c2934ca8ef5a45de2", "target": 0, "func": "static int ac3_encode_frame(AVCodecContext *avctx,\n\n                            unsigned char *frame, int buf_size, void *data)\n\n{\n\n    AC3EncodeContext *s = avctx->priv_data;\n\n    const int16_t *samples = data;\n\n    int16_t planar_samples[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE+AC3_FRAME_SIZE];\n\n    int32_t mdct_coef[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t exp_strategy[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint8_t encoded_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t num_exp_groups[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint8_t grouped_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_EXP_GROUPS];\n\n    uint8_t bap[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    int8_t exp_shift[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint16_t qmant[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    int frame_bits;\n\n\n\n    if (s->bit_alloc.sr_code == 1)\n\n        adjust_frame_size(s);\n\n\n\n    deinterleave_input_samples(s, samples, planar_samples);\n\n\n\n    apply_mdct(s, planar_samples, exp_shift, mdct_coef);\n\n\n\n    frame_bits = process_exponents(s, mdct_coef, exp_shift, exp, exp_strategy,\n\n                                   encoded_exp, num_exp_groups, grouped_exp);\n\n\n\n    compute_bit_allocation(s, bap, encoded_exp, exp_strategy, frame_bits);\n\n\n\n    quantize_mantissas(s, mdct_coef, exp_shift, encoded_exp, bap, qmant);\n\n\n\n    output_frame(s, frame, exp_strategy, num_exp_groups, grouped_exp, bap, qmant);\n\n\n\n    return s->frame_size;\n\n}\n", "idx": 299}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_write_rom(target_phys_addr_t addr,\n\n                                   const uint8_t *buf, int len)\n\n{\n\n    AddressSpaceDispatch *d = address_space_memory.dispatch;\n\n    int l;\n\n    uint8_t *ptr;\n\n    target_phys_addr_t page;\n\n    MemoryRegionSection *section;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        section = phys_page_find(d, page >> TARGET_PAGE_BITS);\n\n\n\n        if (!(memory_region_is_ram(section->mr) ||\n\n              memory_region_is_romd(section->mr))) {\n\n            /* do nothing */\n\n        } else {\n\n            unsigned long addr1;\n\n            addr1 = memory_region_get_ram_addr(section->mr)\n\n                + memory_region_section_addr(section, addr);\n\n            /* ROM/RAM case */\n\n            ptr = qemu_get_ram_ptr(addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(addr1, l);\n\n            qemu_put_ram_ptr(ptr);\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 302}
{"project": "FFmpeg", "commit_id": "4b0e0f31bf0f618a634dcfdca45e72cdfb0b48b5", "target": 1, "func": "av_cold int ff_lpc_init(LPCContext *s, int blocksize, int max_order,\n\n                        enum FFLPCType lpc_type)\n\n{\n\n    s->blocksize = blocksize;\n\n    s->max_order = max_order;\n\n    s->lpc_type  = lpc_type;\n\n\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON) {\n\n        s->windowed_samples = av_mallocz((blocksize + max_order + 2) *\n\n                                         sizeof(*s->windowed_samples));\n\n        if (!s->windowed_samples)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        s->windowed_samples = NULL;\n\n    }\n\n\n\n    s->lpc_apply_welch_window = lpc_apply_welch_window_c;\n\n    s->lpc_compute_autocorr   = lpc_compute_autocorr_c;\n\n\n\n    if (HAVE_MMX)\n\n        ff_lpc_init_x86(s);\n\n\n\n    return 0;\n\n}\n", "idx": 303}
{"project": "FFmpeg", "commit_id": "4fd07b9366fb2f74b6af0dea8092d6bafa38f131", "target": 0, "func": "static int audio_decode_frame(VideoState *is, double *pts_ptr)\n\n{\n\n    AVPacket *pkt_temp = &is->audio_pkt_temp;\n\n    AVPacket *pkt = &is->audio_pkt;\n\n    AVCodecContext *dec = is->audio_st->codec;\n\n    int len1, len2, data_size, resampled_data_size;\n\n    int64_t dec_channel_layout;\n\n    int got_frame;\n\n    double pts;\n\n    int new_packet = 0;\n\n    int flush_complete = 0;\n\n    int wanted_nb_samples;\n\n\n\n    for (;;) {\n\n        /* NOTE: the audio packet can contain several frames */\n\n        while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet)) {\n\n            if (!is->frame) {\n\n                if (!(is->frame = avcodec_alloc_frame()))\n\n                    return AVERROR(ENOMEM);\n\n            } else\n\n                avcodec_get_frame_defaults(is->frame);\n\n\n\n            if (is->paused)\n\n                return -1;\n\n\n\n            if (flush_complete)\n\n                break;\n\n            new_packet = 0;\n\n            len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);\n\n            if (len1 < 0) {\n\n                /* if error, we skip the frame */\n\n                pkt_temp->size = 0;\n\n                break;\n\n            }\n\n\n\n            pkt_temp->data += len1;\n\n            pkt_temp->size -= len1;\n\n\n\n            if (!got_frame) {\n\n                /* stop sending empty packets if the decoder is finished */\n\n                if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)\n\n                    flush_complete = 1;\n\n                continue;\n\n            }\n\n            data_size = av_samples_get_buffer_size(NULL, dec->channels,\n\n                                                   is->frame->nb_samples,\n\n                                                   dec->sample_fmt, 1);\n\n\n\n            dec_channel_layout = (dec->channel_layout && dec->channels == av_get_channel_layout_nb_channels(dec->channel_layout)) ? dec->channel_layout : av_get_default_channel_layout(dec->channels);\n\n            wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);\n\n\n\n            if (dec->sample_fmt != is->audio_src.fmt ||\n\n                dec_channel_layout != is->audio_src.channel_layout ||\n\n                dec->sample_rate != is->audio_src.freq ||\n\n                (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {\n\n                if (is->swr_ctx)\n\n                    swr_free(&is->swr_ctx);\n\n                is->swr_ctx = swr_alloc_set_opts(NULL,\n\n                                                 is->audio_tgt.channel_layout, is->audio_tgt.fmt, is->audio_tgt.freq,\n\n                                                 dec_channel_layout,           dec->sample_fmt,   dec->sample_rate,\n\n                                                 0, NULL);\n\n                if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {\n\n                    fprintf(stderr, \"Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\\n\",\n\n                        dec->sample_rate,\n\n                        av_get_sample_fmt_name(dec->sample_fmt),\n\n                        dec->channels,\n\n                        is->audio_tgt.freq,\n\n                        av_get_sample_fmt_name(is->audio_tgt.fmt),\n\n                        is->audio_tgt.channels);\n\n                    break;\n\n                }\n\n                is->audio_src.channel_layout = dec_channel_layout;\n\n                is->audio_src.channels = dec->channels;\n\n                is->audio_src.freq = dec->sample_rate;\n\n                is->audio_src.fmt = dec->sample_fmt;\n\n            }\n\n\n\n            resampled_data_size = data_size;\n\n            if (is->swr_ctx) {\n\n                const uint8_t *in[] = { is->frame->data[0] };\n\n                uint8_t *out[] = {is->audio_buf2};\n\n                if (wanted_nb_samples != is->frame->nb_samples) {\n\n                    if (swr_set_compensation(is->swr_ctx, (wanted_nb_samples - is->frame->nb_samples) * is->audio_tgt.freq / dec->sample_rate,\n\n                                                wanted_nb_samples * is->audio_tgt.freq / dec->sample_rate) < 0) {\n\n                        fprintf(stderr, \"swr_set_compensation() failed\\n\");\n\n                        break;\n\n                    }\n\n                }\n\n                len2 = swr_convert(is->swr_ctx, out, sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt),\n\n                                                in, is->frame->nb_samples);\n\n                if (len2 < 0) {\n\n                    fprintf(stderr, \"swr_convert() failed\\n\");\n\n                    break;\n\n                }\n\n                if (len2 == sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt)) {\n\n                    fprintf(stderr, \"warning: audio buffer is probably too small\\n\");\n\n                    swr_init(is->swr_ctx);\n\n                }\n\n                is->audio_buf = is->audio_buf2;\n\n                resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);\n\n            } else {\n\n                is->audio_buf = is->frame->data[0];\n\n            }\n\n\n\n            /* if no pts, then compute it */\n\n            pts = is->audio_clock;\n\n            *pts_ptr = pts;\n\n            is->audio_clock += (double)data_size /\n\n                (dec->channels * dec->sample_rate * av_get_bytes_per_sample(dec->sample_fmt));\n\n#ifdef DEBUG\n\n            {\n\n                static double last_clock;\n\n                printf(\"audio: delay=%0.3f clock=%0.3f pts=%0.3f\\n\",\n\n                       is->audio_clock - last_clock,\n\n                       is->audio_clock, pts);\n\n                last_clock = is->audio_clock;\n\n            }\n\n#endif\n\n            return resampled_data_size;\n\n        }\n\n\n\n        /* free the current packet */\n\n        if (pkt->data)\n\n            av_free_packet(pkt);\n\n        memset(pkt_temp, 0, sizeof(*pkt_temp));\n\n\n\n        if (is->paused || is->audioq.abort_request) {\n\n            return -1;\n\n        }\n\n\n\n        /* read next packet */\n\n        if ((new_packet = packet_queue_get(&is->audioq, pkt, 1)) < 0)\n\n            return -1;\n\n\n\n        if (pkt->data == flush_pkt.data) {\n\n            avcodec_flush_buffers(dec);\n\n            flush_complete = 0;\n\n        }\n\n\n\n        *pkt_temp = *pkt;\n\n\n\n        /* if update the audio clock with the pts */\n\n        if (pkt->pts != AV_NOPTS_VALUE) {\n\n            is->audio_clock = av_q2d(is->audio_st->time_base)*pkt->pts;\n\n        }\n\n    }\n\n}\n", "idx": 306}
{"project": "qemu", "commit_id": "c11e80e299e57c64934c164b231fa0d4279db445", "target": 0, "func": "void YM3812UpdateOne(FM_OPL *OPL, INT16 *buffer, int length)\n\n{\n\n    int i;\n\n\tint data;\n\n\tOPLSAMPLE *buf = buffer;\n\n\tUINT32 amsCnt  = OPL->amsCnt;\n\n\tUINT32 vibCnt  = OPL->vibCnt;\n\n\tUINT8 rythm = OPL->rythm&0x20;\n\n\tOPL_CH *CH,*R_CH;\n\n\n\n\tif( (void *)OPL != cur_chip ){\n\n\t\tcur_chip = (void *)OPL;\n\n\t\t/* channel pointers */\n\n\t\tS_CH = OPL->P_CH;\n\n\t\tE_CH = &S_CH[9];\n\n\t\t/* rythm slot */\n\n\t\tSLOT7_1 = &S_CH[7].SLOT[SLOT1];\n\n\t\tSLOT7_2 = &S_CH[7].SLOT[SLOT2];\n\n\t\tSLOT8_1 = &S_CH[8].SLOT[SLOT1];\n\n\t\tSLOT8_2 = &S_CH[8].SLOT[SLOT2];\n\n\t\t/* LFO state */\n\n\t\tamsIncr = OPL->amsIncr;\n\n\t\tvibIncr = OPL->vibIncr;\n\n\t\tams_table = OPL->ams_table;\n\n\t\tvib_table = OPL->vib_table;\n\n\t}\n\n\tR_CH = rythm ? &S_CH[6] : E_CH;\n\n    for( i=0; i < length ; i++ )\n\n\t{\n\n\t\t/*            channel A         channel B         channel C      */\n\n\t\t/* LFO */\n\n\t\tams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];\n\n\t\tvib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];\n\n\t\toutd[0] = 0;\n\n\t\t/* FM part */\n\n\t\tfor(CH=S_CH ; CH < R_CH ; CH++)\n\n\t\t\tOPL_CALC_CH(CH);\n\n\t\t/* Rythn part */\n\n\t\tif(rythm)\n\n\t\t\tOPL_CALC_RH(S_CH);\n\n\t\t/* limit check */\n\n\t\tdata = Limit( outd[0] , OPL_MAXOUT, OPL_MINOUT );\n\n\t\t/* store to sound buffer */\n\n\t\tbuf[i] = data >> OPL_OUTSB;\n\n\t}\n\n\n\n\tOPL->amsCnt = amsCnt;\n\n\tOPL->vibCnt = vibCnt;\n\n#ifdef OPL_OUTPUT_LOG\n\n\tif(opl_dbg_fp)\n\n\t{\n\n\t\tfor(opl_dbg_chip=0;opl_dbg_chip<opl_dbg_maxchip;opl_dbg_chip++)\n\n\t\t\tif( opl_dbg_opl[opl_dbg_chip] == OPL) break;\n\n\t\tfprintf(opl_dbg_fp,\"%c%c%c\",0x20+opl_dbg_chip,length&0xff,length/256);\n\n\t}\n\n#endif\n\n}\n", "idx": 307}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_tipb_bridge_write(void *opaque, target_phys_addr_t addr,\n\n                                   uint64_t value, unsigned size)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *) opaque;\n\n\n\n    if (size < 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* TIPB_CNTL */\n\n        s->control = value & 0xffff;\n\n        break;\n\n\n\n    case 0x04:\t/* TIPB_BUS_ALLOC */\n\n        s->alloc = value & 0x003f;\n\n        break;\n\n\n\n    case 0x08:\t/* MPU_TIPB_CNTL */\n\n        s->buffer = value & 0x0003;\n\n        break;\n\n\n\n    case 0x0c:\t/* ENHANCED_TIPB_CNTL */\n\n        s->width_intr = !(value & 2);\n\n        s->enh_control = value & 0x000f;\n\n        break;\n\n\n\n    case 0x10:\t/* ADDRESS_DBG */\n\n    case 0x14:\t/* DATA_DEBUG_LOW */\n\n    case 0x18:\t/* DATA_DEBUG_HIGH */\n\n    case 0x1c:\t/* DEBUG_CNTR_SIG */\n\n        OMAP_RO_REG(addr);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 308}
{"project": "qemu", "commit_id": "fb23162885f7fd8cf7334bed22c25ac32c7d8b9d", "target": 0, "func": "PCIDevice *pci_register_device(PCIBus *bus, const char *name,\n\n                               int instance_size, int devfn,\n\n                               PCIConfigReadFunc *config_read,\n\n                               PCIConfigWriteFunc *config_write)\n\n{\n\n    PCIDevice *pci_dev;\n\n\n\n    pci_dev = qemu_mallocz(instance_size);\n\n    pci_dev = do_pci_register_device(pci_dev, bus, name, devfn,\n\n                                     config_read, config_write);\n\n    return pci_dev;\n\n}\n", "idx": 309}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int64 float64_to_int64_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    bits64 aSig;\n\n    int64 z;\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( aExp ) aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = aExp - 0x433;\n\n    if ( 0 <= shiftCount ) {\n\n        if ( 0x43E <= aExp ) {\n\n            if ( a != LIT64( 0xC3E0000000000000 ) ) {\n\n                float_raise( float_flag_invalid STATUS_VAR);\n\n                if (    ! aSign\n\n                     || (    ( aExp == 0x7FF )\n\n                          && ( aSig != LIT64( 0x0010000000000000 ) ) )\n\n                   ) {\n\n                    return LIT64( 0x7FFFFFFFFFFFFFFF );\n\n                }\n\n            }\n\n            return (sbits64) LIT64( 0x8000000000000000 );\n\n        }\n\n        z = aSig<<shiftCount;\n\n    }\n\n    else {\n\n        if ( aExp < 0x3FE ) {\n\n            if ( aExp | aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            return 0;\n\n        }\n\n        z = aSig>>( - shiftCount );\n\n        if ( (bits64) ( aSig<<( shiftCount & 63 ) ) ) {\n\n            STATUS(float_exception_flags) |= float_flag_inexact;\n\n        }\n\n    }\n\n    if ( aSign ) z = - z;\n\n    return z;\n\n\n\n}\n", "idx": 310}
{"project": "qemu", "commit_id": "b39e3f34c9de7ead6a11a74aa2de78baf41d81a7", "target": 0, "func": "static void icount_warp_rt(void)\n\n{\n\n    unsigned seq;\n\n    int64_t warp_start;\n\n\n\n    /* The icount_warp_timer is rescheduled soon after vm_clock_warp_start\n\n     * changes from -1 to another value, so the race here is okay.\n\n     */\n\n    do {\n\n        seq = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n\n        warp_start = vm_clock_warp_start;\n\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, seq));\n\n\n\n    if (warp_start == -1) {\n\n        return;\n\n    }\n\n\n\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n\n    if (runstate_is_running()) {\n\n        int64_t clock = REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT,\n\n                                     cpu_get_clock_locked());\n\n        int64_t warp_delta;\n\n\n\n        warp_delta = clock - vm_clock_warp_start;\n\n        if (use_icount == 2) {\n\n            /*\n\n             * In adaptive mode, do not let QEMU_CLOCK_VIRTUAL run too\n\n             * far ahead of real time.\n\n             */\n\n            int64_t cur_icount = cpu_get_icount_locked();\n\n            int64_t delta = clock - cur_icount;\n\n            warp_delta = MIN(warp_delta, delta);\n\n        }\n\n        timers_state.qemu_icount_bias += warp_delta;\n\n    }\n\n    vm_clock_warp_start = -1;\n\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n\n\n\n    if (qemu_clock_expired(QEMU_CLOCK_VIRTUAL)) {\n\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n\n    }\n\n}\n", "idx": 312}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_aio_cancel(BlockAIOCB *acb)\n\n{\n\n    qemu_aio_ref(acb);\n\n    bdrv_aio_cancel_async(acb);\n\n    while (acb->refcnt > 1) {\n\n        if (acb->aiocb_info->get_aio_context) {\n\n            aio_poll(acb->aiocb_info->get_aio_context(acb), true);\n\n        } else if (acb->bs) {\n\n            aio_poll(bdrv_get_aio_context(acb->bs), true);\n\n        } else {\n\n            abort();\n\n        }\n\n    }\n\n    qemu_aio_unref(acb);\n\n}\n", "idx": 313}
{"project": "qemu", "commit_id": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486", "target": 0, "func": "static void vnc_listen_read(void *opaque, bool websocket)\n\n{\n\n    VncDisplay *vs = opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int csock;\n\n\n\n    /* Catch-up */\n\n    graphic_hw_update(vs->dcl.con);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n\n    } else\n\n#endif /* CONFIG_VNC_WS */\n\n    {\n\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n\n    }\n\n\n\n    if (csock != -1) {\n\n        socket_set_nodelay(csock);\n\n        vnc_connect(vs, csock, false, websocket);\n\n    }\n\n}\n", "idx": 314}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_sraq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_sar_tl(t1, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_subfi_tl(t2, 32, t2);\n\n    tcg_gen_shl_tl(t2, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_or_tl(t0, t0, t2);\n\n    gen_store_spr(SPR_MQ, t0);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l1);\n\n    tcg_gen_mov_tl(t2, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_gen_sari_tl(t1, cpu_gpr[rS(ctx->opcode)], 31);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t1);\n\n    tcg_gen_movi_tl(cpu_ca, 0);\n\n    tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l2);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l2);\n\n    tcg_gen_movi_tl(cpu_ca, 1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 315}
{"project": "FFmpeg", "commit_id": "63c0b3d920fe637ec4d361f08108ca8d5ba70bbe", "target": 0, "func": "static void reverse_dc_prediction(Vp3DecodeContext *s,\n\n                                  int first_fragment,\n\n                                  int fragment_width,\n\n                                  int fragment_height)\n\n{\n\n\n\n#define PUL 8\n\n#define PU 4\n\n#define PUR 2\n\n#define PL 1\n\n\n\n    int x, y;\n\n    int i = first_fragment;\n\n\n\n    int predicted_dc;\n\n\n\n    /* DC values for the left, up-left, up, and up-right fragments */\n\n    int vl, vul, vu, vur;\n\n\n\n    /* indexes for the left, up-left, up, and up-right fragments */\n\n    int l, ul, u, ur;\n\n\n\n    /*\n\n     * The 6 fields mean:\n\n     *   0: up-left multiplier\n\n     *   1: up multiplier\n\n     *   2: up-right multiplier\n\n     *   3: left multiplier\n\n     */\n\n    static const int predictor_transform[16][4] = {\n\n        {  0,  0,  0,  0},\n\n        {  0,  0,  0,128},        // PL\n\n        {  0,  0,128,  0},        // PUR\n\n        {  0,  0, 53, 75},        // PUR|PL\n\n        {  0,128,  0,  0},        // PU\n\n        {  0, 64,  0, 64},        // PU|PL\n\n        {  0,128,  0,  0},        // PU|PUR\n\n        {  0,  0, 53, 75},        // PU|PUR|PL\n\n        {128,  0,  0,  0},        // PUL\n\n        {  0,  0,  0,128},        // PUL|PL\n\n        { 64,  0, 64,  0},        // PUL|PUR\n\n        {  0,  0, 53, 75},        // PUL|PUR|PL\n\n        {  0,128,  0,  0},        // PUL|PU\n\n       {-104,116,  0,116},        // PUL|PU|PL\n\n        { 24, 80, 24,  0},        // PUL|PU|PUR\n\n       {-104,116,  0,116}         // PUL|PU|PUR|PL\n\n    };\n\n\n\n    /* This table shows which types of blocks can use other blocks for\n\n     * prediction. For example, INTRA is the only mode in this table to\n\n     * have a frame number of 0. That means INTRA blocks can only predict\n\n     * from other INTRA blocks. There are 2 golden frame coding types;\n\n     * blocks encoding in these modes can only predict from other blocks\n\n     * that were encoded with these 1 of these 2 modes. */\n\n    static const unsigned char compatible_frame[8] = {\n\n        1,    /* MODE_INTER_NO_MV */\n\n        0,    /* MODE_INTRA */\n\n        1,    /* MODE_INTER_PLUS_MV */\n\n        1,    /* MODE_INTER_LAST_MV */\n\n        1,    /* MODE_INTER_PRIOR_MV */\n\n        2,    /* MODE_USING_GOLDEN */\n\n        2,    /* MODE_GOLDEN_MV */\n\n        1     /* MODE_INTER_FOUR_MV */\n\n    };\n\n    int current_frame_type;\n\n\n\n    /* there is a last DC predictor for each of the 3 frame types */\n\n    short last_dc[3];\n\n\n\n    int transform = 0;\n\n\n\n    vul = vu = vur = vl = 0;\n\n    last_dc[0] = last_dc[1] = last_dc[2] = 0;\n\n\n\n    /* for each fragment row... */\n\n    for (y = 0; y < fragment_height; y++) {\n\n\n\n        /* for each fragment in a row... */\n\n        for (x = 0; x < fragment_width; x++, i++) {\n\n\n\n            /* reverse prediction if this block was coded */\n\n            if (s->all_fragments[i].coding_method != MODE_COPY) {\n\n\n\n                current_frame_type =\n\n                    compatible_frame[s->all_fragments[i].coding_method];\n\n\n\n                transform= 0;\n\n                if(x){\n\n                    l= i-1;\n\n                    vl = DC_COEFF(l);\n\n                    if(FRAME_CODED(l) && COMPATIBLE_FRAME(l))\n\n                        transform |= PL;\n\n                }\n\n                if(y){\n\n                    u= i-fragment_width;\n\n                    vu = DC_COEFF(u);\n\n                    if(FRAME_CODED(u) && COMPATIBLE_FRAME(u))\n\n                        transform |= PU;\n\n                    if(x){\n\n                        ul= i-fragment_width-1;\n\n                        vul = DC_COEFF(ul);\n\n                        if(FRAME_CODED(ul) && COMPATIBLE_FRAME(ul))\n\n                            transform |= PUL;\n\n                    }\n\n                    if(x + 1 < fragment_width){\n\n                        ur= i-fragment_width+1;\n\n                        vur = DC_COEFF(ur);\n\n                        if(FRAME_CODED(ur) && COMPATIBLE_FRAME(ur))\n\n                            transform |= PUR;\n\n                    }\n\n                }\n\n\n\n                if (transform == 0) {\n\n\n\n                    /* if there were no fragments to predict from, use last\n\n                     * DC saved */\n\n                    predicted_dc = last_dc[current_frame_type];\n\n                } else {\n\n\n\n                    /* apply the appropriate predictor transform */\n\n                    predicted_dc =\n\n                        (predictor_transform[transform][0] * vul) +\n\n                        (predictor_transform[transform][1] * vu) +\n\n                        (predictor_transform[transform][2] * vur) +\n\n                        (predictor_transform[transform][3] * vl);\n\n\n\n                    predicted_dc /= 128;\n\n\n\n                    /* check for outranging on the [ul u l] and\n\n                     * [ul u ur l] predictors */\n\n                    if ((transform == 13) || (transform == 15)) {\n\n                        if (FFABS(predicted_dc - vu) > 128)\n\n                            predicted_dc = vu;\n\n                        else if (FFABS(predicted_dc - vl) > 128)\n\n                            predicted_dc = vl;\n\n                        else if (FFABS(predicted_dc - vul) > 128)\n\n                            predicted_dc = vul;\n\n                    }\n\n                }\n\n\n\n                /* at long last, apply the predictor */\n\n                if(s->coeffs[i].index){\n\n                    *s->next_coeff= s->coeffs[i];\n\n                    s->coeffs[i].index=0;\n\n                    s->coeffs[i].coeff=0;\n\n                    s->coeffs[i].next= s->next_coeff++;\n\n                }\n\n                s->coeffs[i].coeff += predicted_dc;\n\n                /* save the DC */\n\n                last_dc[current_frame_type] = DC_COEFF(i);\n\n                if(DC_COEFF(i) && !(s->coeff_counts[i]&127)){\n\n                    s->coeff_counts[i]= 129;\n\n//                    s->all_fragments[i].next_coeff= s->next_coeff;\n\n                    s->coeffs[i].next= s->next_coeff;\n\n                    (s->next_coeff++)->next=NULL;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 316}
{"project": "qemu", "commit_id": "e3f4e2a4b0df510e441badb85c9398516c27bd66", "target": 0, "func": "static PhysPageDesc *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    void **lp, **p;\n\n\n\n    p = (void **)l1_phys_map;\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > 32\n\n\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > (32 + L1_BITS)\n\n#error unsupported TARGET_PHYS_ADDR_SPACE_BITS\n\n#endif\n\n    lp = p + ((index >> (L1_BITS + L2_BITS)) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        /* allocate if not found */\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(void *) * L1_SIZE);\n\n        memset(p, 0, sizeof(void *) * L1_SIZE);\n\n        *lp = p;\n\n    }\n\n#endif\n\n    lp = p + ((index >> L2_BITS) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        /* allocate if not found */\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(PhysPageDesc) * L2_SIZE);\n\n        memset(p, 0, sizeof(PhysPageDesc) * L2_SIZE);\n\n        *lp = p;\n\n    }\n\n    return ((PhysPageDesc *)p) + (index & (L2_SIZE - 1));\n\n}\n", "idx": 317}
{"project": "qemu", "commit_id": "4898427ec88821ff94571340c397d15e0bddb3e2", "target": 0, "func": "CPUState *cpu_mb_init (const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    static int tcg_initialized = 0;\n\n    int i;\n\n\n\n    env = qemu_mallocz(sizeof(CPUState));\n\n\n\n    cpu_exec_init(env);\n\n    cpu_reset(env);\n\n\n\n    env->pvr.regs[0] = PVR0_PVR_FULL_MASK \\\n\n                       | PVR0_USE_BARREL_MASK \\\n\n                       | PVR0_USE_DIV_MASK \\\n\n                       | PVR0_USE_HW_MUL_MASK \\\n\n                       | PVR0_USE_EXC_MASK \\\n\n                       | PVR0_USE_ICACHE_MASK \\\n\n                       | PVR0_USE_DCACHE_MASK \\\n\n                       | PVR0_USE_MMU \\\n\n                       | (0xb << 8);\n\n    env->pvr.regs[2] = PVR2_D_OPB_MASK \\\n\n                        | PVR2_D_LMB_MASK \\\n\n                        | PVR2_I_OPB_MASK \\\n\n                        | PVR2_I_LMB_MASK \\\n\n                        | PVR2_USE_MSR_INSTR \\\n\n                        | PVR2_USE_PCMP_INSTR \\\n\n                        | PVR2_USE_BARREL_MASK \\\n\n                        | PVR2_USE_DIV_MASK \\\n\n                        | PVR2_USE_HW_MUL_MASK \\\n\n                        | PVR2_USE_MUL64_MASK \\\n\n                        | 0;\n\n    env->pvr.regs[10] = 0x0c000000; /* Default to spartan 3a dsp family.  */\n\n    env->pvr.regs[11] = PVR11_USE_MMU | (16 << 17);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->mmu.c_mmu = 3;\n\n    env->mmu.c_mmu_tlb_access = 3;\n\n    env->mmu.c_mmu_zones = 16;\n\n#endif\n\n\n\n    if (tcg_initialized)\n\n        return env;\n\n\n\n    tcg_initialized = 1;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    env_debug = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, debug),\n\n                    \"debug0\");\n\n    env_iflags = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, iflags),\n\n                    \"iflags\");\n\n    env_imm = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, imm),\n\n                    \"imm\");\n\n    env_btarget = tcg_global_mem_new(TCG_AREG0,\n\n                     offsetof(CPUState, btarget),\n\n                     \"btarget\");\n\n    env_btaken = tcg_global_mem_new(TCG_AREG0,\n\n                     offsetof(CPUState, btaken),\n\n                     \"btaken\");\n\n    for (i = 0; i < ARRAY_SIZE(cpu_R); i++) {\n\n        cpu_R[i] = tcg_global_mem_new(TCG_AREG0,\n\n                          offsetof(CPUState, regs[i]),\n\n                          regnames[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(cpu_SR); i++) {\n\n        cpu_SR[i] = tcg_global_mem_new(TCG_AREG0,\n\n                          offsetof(CPUState, sregs[i]),\n\n                          special_regnames[i]);\n\n    }\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    return env;\n\n}\n", "idx": 318}
{"project": "qemu", "commit_id": "e4533c7a8cdcc79ccdf695f0aaa2e23a5b926ed0", "target": 0, "func": "int cpu_x86_exec(CPUX86State *env1)\n\n{\n\n    int saved_T0, saved_T1, saved_A0;\n\n    CPUX86State *saved_env;\n\n#ifdef reg_EAX\n\n    int saved_EAX;\n\n#endif\n\n#ifdef reg_ECX\n\n    int saved_ECX;\n\n#endif\n\n#ifdef reg_EDX\n\n    int saved_EDX;\n\n#endif\n\n#ifdef reg_EBX\n\n    int saved_EBX;\n\n#endif\n\n#ifdef reg_ESP\n\n    int saved_ESP;\n\n#endif\n\n#ifdef reg_EBP\n\n    int saved_EBP;\n\n#endif\n\n#ifdef reg_ESI\n\n    int saved_ESI;\n\n#endif\n\n#ifdef reg_EDI\n\n    int saved_EDI;\n\n#endif\n\n#ifdef __sparc__\n\n    int saved_i7, tmp_T0;\n\n#endif\n\n    int code_gen_size, ret;\n\n    void (*gen_func)(void);\n\n    TranslationBlock *tb, **ptb;\n\n    uint8_t *tc_ptr, *cs_base, *pc;\n\n    unsigned int flags;\n\n\n\n    /* first we save global registers */\n\n    saved_T0 = T0;\n\n    saved_T1 = T1;\n\n    saved_A0 = A0;\n\n    saved_env = env;\n\n    env = env1;\n\n#ifdef reg_EAX\n\n    saved_EAX = EAX;\n\n    EAX = env->regs[R_EAX];\n\n#endif\n\n#ifdef reg_ECX\n\n    saved_ECX = ECX;\n\n    ECX = env->regs[R_ECX];\n\n#endif\n\n#ifdef reg_EDX\n\n    saved_EDX = EDX;\n\n    EDX = env->regs[R_EDX];\n\n#endif\n\n#ifdef reg_EBX\n\n    saved_EBX = EBX;\n\n    EBX = env->regs[R_EBX];\n\n#endif\n\n#ifdef reg_ESP\n\n    saved_ESP = ESP;\n\n    ESP = env->regs[R_ESP];\n\n#endif\n\n#ifdef reg_EBP\n\n    saved_EBP = EBP;\n\n    EBP = env->regs[R_EBP];\n\n#endif\n\n#ifdef reg_ESI\n\n    saved_ESI = ESI;\n\n    ESI = env->regs[R_ESI];\n\n#endif\n\n#ifdef reg_EDI\n\n    saved_EDI = EDI;\n\n    EDI = env->regs[R_EDI];\n\n#endif\n\n#ifdef __sparc__\n\n    /* we also save i7 because longjmp may not restore it */\n\n    asm volatile (\"mov %%i7, %0\" : \"=r\" (saved_i7));\n\n#endif\n\n    \n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    env->interrupt_request = 0;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (setjmp(env->jmp_env) == 0) {\n\n        T0 = 0; /* force lookup of first TB */\n\n        for(;;) {\n\n#ifdef __sparc__\n\n\t  /* g1 can be modified by some libc? functions */ \n\n\t    tmp_T0 = T0;\n\n#endif\t    \n\n            if (env->interrupt_request) {\n\n                env->exception_index = EXCP_INTERRUPT;\n\n                cpu_loop_exit();\n\n            }\n\n#ifdef DEBUG_EXEC\n\n            if (loglevel) {\n\n                /* XXX: save all volatile state in cpu state */\n\n                /* restore flags in standard format */\n\n                env->regs[R_EAX] = EAX;\n\n                env->regs[R_EBX] = EBX;\n\n                env->regs[R_ECX] = ECX;\n\n                env->regs[R_EDX] = EDX;\n\n                env->regs[R_ESI] = ESI;\n\n                env->regs[R_EDI] = EDI;\n\n                env->regs[R_EBP] = EBP;\n\n                env->regs[R_ESP] = ESP;\n\n                env->eflags = env->eflags | cc_table[CC_OP].compute_all() | (DF & DF_MASK);\n\n                cpu_x86_dump_state(env, logfile, 0);\n\n                env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n            }\n\n#endif\n\n            /* we compute the CPU state. We assume it will not\n\n               change during the whole generated block. */\n\n            flags = env->seg_cache[R_CS].seg_32bit << GEN_FLAG_CODE32_SHIFT;\n\n            flags |= env->seg_cache[R_SS].seg_32bit << GEN_FLAG_SS32_SHIFT;\n\n            flags |= (((unsigned long)env->seg_cache[R_DS].base | \n\n                       (unsigned long)env->seg_cache[R_ES].base |\n\n                       (unsigned long)env->seg_cache[R_SS].base) != 0) << \n\n                GEN_FLAG_ADDSEG_SHIFT;\n\n            if (!(env->eflags & VM_MASK)) {\n\n                flags |= (env->segs[R_CS] & 3) << GEN_FLAG_CPL_SHIFT;\n\n            } else {\n\n                /* NOTE: a dummy CPL is kept */\n\n                flags |= (1 << GEN_FLAG_VM_SHIFT);\n\n                flags |= (3 << GEN_FLAG_CPL_SHIFT);\n\n            }\n\n            flags |= (env->eflags & (IOPL_MASK | TF_MASK));\n\n            cs_base = env->seg_cache[R_CS].base;\n\n            pc = cs_base + env->eip;\n\n            tb = tb_find(&ptb, (unsigned long)pc, (unsigned long)cs_base, \n\n                         flags);\n\n            if (!tb) {\n\n                spin_lock(&tb_lock);\n\n                /* if no translated code available, then translate it now */\n\n                tb = tb_alloc((unsigned long)pc);\n\n                if (!tb) {\n\n                    /* flush must be done */\n\n                    tb_flush();\n\n                    /* cannot fail at this point */\n\n                    tb = tb_alloc((unsigned long)pc);\n\n                    /* don't forget to invalidate previous TB info */\n\n                    ptb = &tb_hash[tb_hash_func((unsigned long)pc)];\n\n                    T0 = 0;\n\n                }\n\n                tc_ptr = code_gen_ptr;\n\n                tb->tc_ptr = tc_ptr;\n\n                tb->cs_base = (unsigned long)cs_base;\n\n                tb->flags = flags;\n\n                ret = cpu_x86_gen_code(tb, CODE_GEN_MAX_SIZE, &code_gen_size);\n\n                /* if invalid instruction, signal it */\n\n                if (ret != 0) {\n\n                    /* NOTE: the tb is allocated but not linked, so we\n\n                       can leave it */\n\n                    spin_unlock(&tb_lock);\n\n                    raise_exception(EXCP06_ILLOP);\n\n                }\n\n                *ptb = tb;\n\n                tb->hash_next = NULL;\n\n                tb_link(tb);\n\n                code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) & ~(CODE_GEN_ALIGN - 1));\n\n                spin_unlock(&tb_lock);\n\n            }\n\n#ifdef DEBUG_EXEC\n\n\t    if (loglevel) {\n\n\t\tfprintf(logfile, \"Trace 0x%08lx [0x%08lx] %s\\n\",\n\n\t\t\t(long)tb->tc_ptr, (long)tb->pc,\n\n\t\t\tlookup_symbol((void *)tb->pc));\n\n\t    }\n\n#endif\n\n#ifdef __sparc__\n\n\t    T0 = tmp_T0;\n\n#endif\t    \n\n            /* see if we can patch the calling TB */\n\n            if (T0 != 0 && !(env->eflags & TF_MASK)) {\n\n                spin_lock(&tb_lock);\n\n                tb_add_jump((TranslationBlock *)(T0 & ~3), T0 & 3, tb);\n\n                spin_unlock(&tb_lock);\n\n            }\n\n            tc_ptr = tb->tc_ptr;\n\n\n\n            /* execute the generated code */\n\n            gen_func = (void *)tc_ptr;\n\n#if defined(__sparc__)\n\n\t    __asm__ __volatile__(\"call\t%0\\n\\t\"\n\n\t\t\t\t \"mov\t%%o7,%%i0\"\n\n\t\t\t\t : /* no outputs */\n\n\t\t\t\t : \"r\" (gen_func) \n\n\t\t\t\t : \"i0\", \"i1\", \"i2\", \"i3\", \"i4\", \"i5\");\n\n#elif defined(__arm__)\n\n            asm volatile (\"mov pc, %0\\n\\t\"\n\n                          \".global exec_loop\\n\\t\"\n\n                          \"exec_loop:\\n\\t\"\n\n                          : /* no outputs */\n\n                          : \"r\" (gen_func)\n\n                          : \"r1\", \"r2\", \"r3\", \"r8\", \"r9\", \"r10\", \"r12\", \"r14\");\n\n#else\n\n            gen_func();\n\n#endif\n\n        }\n\n    }\n\n    ret = env->exception_index;\n\n\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | cc_table[CC_OP].compute_all() | (DF & DF_MASK);\n\n\n\n    /* restore global registers */\n\n#ifdef reg_EAX\n\n    EAX = saved_EAX;\n\n#endif\n\n#ifdef reg_ECX\n\n    ECX = saved_ECX;\n\n#endif\n\n#ifdef reg_EDX\n\n    EDX = saved_EDX;\n\n#endif\n\n#ifdef reg_EBX\n\n    EBX = saved_EBX;\n\n#endif\n\n#ifdef reg_ESP\n\n    ESP = saved_ESP;\n\n#endif\n\n#ifdef reg_EBP\n\n    EBP = saved_EBP;\n\n#endif\n\n#ifdef reg_ESI\n\n    ESI = saved_ESI;\n\n#endif\n\n#ifdef reg_EDI\n\n    EDI = saved_EDI;\n\n#endif\n\n#ifdef __sparc__\n\n    asm volatile (\"mov %0, %%i7\" : : \"r\" (saved_i7));\n\n#endif\n\n    T0 = saved_T0;\n\n    T1 = saved_T1;\n\n    A0 = saved_A0;\n\n    env = saved_env;\n\n    return ret;\n\n}\n", "idx": 320}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "void s390_pci_sclp_configure(SCCB *sccb)\n\n{\n\n    PciCfgSccb *psccb = (PciCfgSccb *)sccb;\n\n    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(be32_to_cpu(psccb->aid));\n\n    uint16_t rc;\n\n\n\n    if (be16_to_cpu(sccb->h.length) < 16) {\n\n        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;\n\n        goto out;\n\n    }\n\n\n\n    if (pbdev) {\n\n        if (pbdev->configured) {\n\n            rc = SCLP_RC_NO_ACTION_REQUIRED;\n\n        } else {\n\n            pbdev->configured = true;\n\n            rc = SCLP_RC_NORMAL_COMPLETION;\n\n        }\n\n    } else {\n\n        DPRINTF(\"sclp config no dev found\\n\");\n\n        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;\n\n    }\n\nout:\n\n    psccb->header.response_code = cpu_to_be16(rc);\n\n}\n", "idx": 322}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "static BlockJob *find_block_job(const char *device)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs || !bs->job) {\n\n        return NULL;\n\n    }\n\n    return bs->job;\n\n}\n", "idx": 323}
{"project": "qemu", "commit_id": "e058fa2dd599ccc780d334558be9c1d155222b80", "target": 0, "func": "static void usb_host_realize(USBDevice *udev, Error **errp)\n\n{\n\n    USBHostDevice *s = USB_HOST_DEVICE(udev);\n\n\n\n    if (s->match.vendor_id > 0xffff) {\n\n        error_setg(errp, \"vendorid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.product_id > 0xffff) {\n\n        error_setg(errp, \"productid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.addr > 127) {\n\n        error_setg(errp, \"hostaddr out of range\");\n\n        return;\n\n    }\n\n\n\n    loglevel = s->loglevel;\n\n    udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);\n\n    udev->auto_attach = 0;\n\n    QTAILQ_INIT(&s->requests);\n\n    QTAILQ_INIT(&s->isorings);\n\n\n\n    s->exit.notify = usb_host_exit_notifier;\n\n    qemu_add_exit_notifier(&s->exit);\n\n\n\n    QTAILQ_INSERT_TAIL(&hostdevs, s, next);\n\n    usb_host_auto_check(NULL);\n\n}\n", "idx": 324}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_int_off(sPAPREnvironment *spapr, uint32_t token,\n\n                         uint32_t nargs, target_ulong args,\n\n                         uint32_t nret, target_ulong rets)\n\n{\n\n    struct ics_state *ics = spapr->icp->ics;\n\n    uint32_t nr;\n\n\n\n    if ((nargs != 1) || (nret != 1)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    nr = rtas_ld(args, 0);\n\n\n\n    if (!ics_valid_irq(ics, nr)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    ics_write_xive(ics, nr, ics->irqs[nr - ics->offset].server, 0xff,\n\n                   ics->irqs[nr - ics->offset].priority);\n\n\n\n    rtas_st(rets, 0, 0); /* Success */\n\n}\n", "idx": 326}
{"project": "FFmpeg", "commit_id": "44ca80df3445a59bc065924d8c6110fa10367d01", "target": 0, "func": "static void filter_mb_mbaff_edgecv( H264Context *h, uint8_t *pix, int stride, int16_t bS[7], int bsi, int qp ) {\n\n    int index_a = qp + h->slice_alpha_c0_offset;\n\n    int alpha = alpha_table[index_a];\n\n    int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0*bsi]] + 1;\n\n        tc[1] = tc0_table[index_a][bS[1*bsi]] + 1;\n\n        tc[2] = tc0_table[index_a][bS[2*bsi]] + 1;\n\n        tc[3] = tc0_table[index_a][bS[3*bsi]] + 1;\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 327}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            return ((s->num_irq / 32) - 1) | ((NUM_CPU(s) - 1) << 5);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Security , RAZ/WI */\n\n            return 0;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_PENDING(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 2 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    hw_error(\"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 328}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_serialize(void *native_in, void **datap,\n\n                          VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = g_malloc0(sizeof(*d));\n\n\n\n    d->qov = qmp_output_visitor_new(&d->obj);\n\n    visit(d->qov, &native_in, errp);\n\n    *datap = d;\n\n}\n", "idx": 329}
{"project": "qemu", "commit_id": "24f50d7ea5896a30b0e78f68884586bb8b40ff97", "target": 1, "func": "static void tcg_target_init(TCGContext *s)\n\n{\n\n    tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xffffffff);\n\n    tcg_regset_set32(tcg_target_call_clobber_regs, 0,\n\n                     (1 << TCG_REG_R0) |\n\n#ifdef _CALL_DARWIN\n\n                     (1 << TCG_REG_R2) |\n\n#endif\n\n                     (1 << TCG_REG_R3) |\n\n                     (1 << TCG_REG_R4) |\n\n                     (1 << TCG_REG_R5) |\n\n                     (1 << TCG_REG_R6) |\n\n                     (1 << TCG_REG_R7) |\n\n                     (1 << TCG_REG_R8) |\n\n                     (1 << TCG_REG_R9) |\n\n                     (1 << TCG_REG_R10) |\n\n                     (1 << TCG_REG_R11) |\n\n                     (1 << TCG_REG_R12)\n\n        );\n\n\n\n    tcg_regset_clear(s->reserved_regs);\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R0);\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R1);\n\n#ifndef _CALL_DARWIN\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R2);\n\n#endif\n\n#ifdef _CALL_SYSV\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R13);\n\n#endif\n\n\n\n    tcg_add_target_add_op_defs(ppc_op_defs);\n\n}\n", "idx": 330}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "static void emulate_spapr_hypercall(PPCVirtualHypervisor *vhyp,\n                                    PowerPCCPU *cpu)\n{\n    CPUPPCState *env = &cpu->env;\n    if (msr_pr) {\n        hcall_dprintf(\"Hypercall made with MSR[PR]=1\\n\");\n        env->gpr[3] = H_PRIVILEGE;\n    } else {\n        env->gpr[3] = spapr_hypercall(cpu, env->gpr[3], &env->gpr[4]);\n    }\n}", "idx": 331}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_range_unvisited(void)\n\n{\n\n    intList *list = NULL;\n\n    intList *tail;\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"ilist=0-2\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(v, NULL, NULL, 0, &error_abort);\n\n\n\n    /* Would be simpler if the visitor genuinely supported virtual walks */\n\n    visit_start_list(v, \"ilist\", (GenericList **)&list, sizeof(*list),\n\n                     &error_abort);\n\n    tail = list;\n\n    visit_type_int(v, NULL, &tail->value, &error_abort);\n\n    g_assert_cmpint(tail->value, ==, 0);\n\n    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));\n\n    g_assert(tail);\n\n    visit_type_int(v, NULL, &tail->value, &error_abort);\n\n    g_assert_cmpint(tail->value, ==, 1);\n\n    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));\n\n    g_assert(tail);\n\n    visit_check_list(v, &error_abort); /* BUG: unvisited tail not reported */\n\n    visit_end_list(v, (void **)&list);\n\n\n\n    visit_check_struct(v, &error_abort);\n\n    visit_end_struct(v, NULL);\n\n\n\n    qapi_free_intList(list);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n}\n", "idx": 332}
{"project": "FFmpeg", "commit_id": "38229362529ed1619d8ebcc81ecde85b23b45895", "target": 1, "func": "static int decode_subframe(WMAProDecodeCtx *s)\n\n{\n\n    int offset = s->samples_per_frame;\n\n    int subframe_len = s->samples_per_frame;\n\n    int i;\n\n    int total_samples   = s->samples_per_frame * s->avctx->channels;\n\n    int transmit_coeffs = 0;\n\n    int cur_subwoofer_cutoff;\n\n\n\n    s->subframe_offset = get_bits_count(&s->gb);\n\n\n\n    /** reset channel context and find the next block offset and size\n\n        == the next block of the channel with the smallest number of\n\n        decoded samples\n\n    */\n\n    for (i = 0; i < s->avctx->channels; i++) {\n\n        s->channel[i].grouped = 0;\n\n        if (offset > s->channel[i].decoded_samples) {\n\n            offset = s->channel[i].decoded_samples;\n\n            subframe_len =\n\n                s->channel[i].subframe_len[s->channel[i].cur_subframe];\n\n        }\n\n    }\n\n\n\n    av_dlog(s->avctx,\n\n            \"processing subframe with offset %i len %i\\n\", offset, subframe_len);\n\n\n\n    /** get a list of all channels that contain the estimated block */\n\n    s->channels_for_cur_subframe = 0;\n\n    for (i = 0; i < s->avctx->channels; i++) {\n\n        const int cur_subframe = s->channel[i].cur_subframe;\n\n        /** subtract already processed samples */\n\n        total_samples -= s->channel[i].decoded_samples;\n\n\n\n        /** and count if there are multiple subframes that match our profile */\n\n        if (offset == s->channel[i].decoded_samples &&\n\n            subframe_len == s->channel[i].subframe_len[cur_subframe]) {\n\n            total_samples -= s->channel[i].subframe_len[cur_subframe];\n\n            s->channel[i].decoded_samples +=\n\n                s->channel[i].subframe_len[cur_subframe];\n\n            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;\n\n            ++s->channels_for_cur_subframe;\n\n        }\n\n    }\n\n\n\n    /** check if the frame will be complete after processing the\n\n        estimated block */\n\n    if (!total_samples)\n\n        s->parsed_all_subframes = 1;\n\n\n\n\n\n    av_dlog(s->avctx, \"subframe is part of %i channels\\n\",\n\n            s->channels_for_cur_subframe);\n\n\n\n    /** calculate number of scale factor bands and their offsets */\n\n    s->table_idx         = av_log2(s->samples_per_frame/subframe_len);\n\n    s->num_bands         = s->num_sfb[s->table_idx];\n\n    s->cur_sfb_offsets   = s->sfb_offsets[s->table_idx];\n\n    cur_subwoofer_cutoff = s->subwoofer_cutoffs[s->table_idx];\n\n\n\n    /** configure the decoder for the current subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n\n\n        s->channel[c].coeffs = &s->channel[c].out[(s->samples_per_frame >> 1)\n\n                                                  + offset];\n\n    }\n\n\n\n    s->subframe_len = subframe_len;\n\n    s->esc_len = av_log2(s->subframe_len - 1) + 1;\n\n\n\n    /** skip extended header if any */\n\n    if (get_bits1(&s->gb)) {\n\n        int num_fill_bits;\n\n        if (!(num_fill_bits = get_bits(&s->gb, 2))) {\n\n            int len = get_bits(&s->gb, 4);\n\n            num_fill_bits = get_bits(&s->gb, len) + 1;\n\n        }\n\n\n\n        if (num_fill_bits >= 0) {\n\n            if (get_bits_count(&s->gb) + num_fill_bits > s->num_saved_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid number of fill bits\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            skip_bits_long(&s->gb, num_fill_bits);\n\n        }\n\n    }\n\n\n\n    /** no idea for what the following bit is used */\n\n    if (get_bits1(&s->gb)) {\n\n        avpriv_request_sample(s->avctx, \"Reserved bit\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n\n\n    if (decode_channel_transform(s) < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if ((s->channel[c].transmit_coefs = get_bits1(&s->gb)))\n\n            transmit_coeffs = 1;\n\n    }\n\n\n\n    if (transmit_coeffs) {\n\n        int step;\n\n        int quant_step = 90 * s->bits_per_sample >> 4;\n\n\n\n        /** decode number of vector coded coefficients */\n\n        if ((s->transmit_num_vec_coeffs = get_bits1(&s->gb))) {\n\n            int num_bits = av_log2((s->subframe_len + 3)/4) + 1;\n\n            for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n                int c = s->channel_indexes_for_cur_subframe[i];\n\n                int num_vec_coeffs = get_bits(&s->gb, num_bits) << 2;\n\n                if (num_vec_coeffs > WMAPRO_BLOCK_MAX_SIZE) {\n\n                    av_log(s->avctx, AV_LOG_ERROR, \"num_vec_coeffs %d is too large\\n\", num_vec_coeffs);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                s->channel[c].num_vec_coeffs = num_vec_coeffs;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n                int c = s->channel_indexes_for_cur_subframe[i];\n\n                s->channel[c].num_vec_coeffs = s->subframe_len;\n\n            }\n\n        }\n\n        /** decode quantization step */\n\n        step = get_sbits(&s->gb, 6);\n\n        quant_step += step;\n\n        if (step == -32 || step == 31) {\n\n            const int sign = (step == 31) - 1;\n\n            int quant = 0;\n\n            while (get_bits_count(&s->gb) + 5 < s->num_saved_bits &&\n\n                   (step = get_bits(&s->gb, 5)) == 31) {\n\n                quant += 31;\n\n            }\n\n            quant_step += ((quant + step) ^ sign) - sign;\n\n        }\n\n        if (quant_step < 0) {\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"negative quant step\\n\");\n\n        }\n\n\n\n        /** decode quantization step modifiers for every channel */\n\n\n\n        if (s->channels_for_cur_subframe == 1) {\n\n            s->channel[s->channel_indexes_for_cur_subframe[0]].quant_step = quant_step;\n\n        } else {\n\n            int modifier_len = get_bits(&s->gb, 3);\n\n            for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n                int c = s->channel_indexes_for_cur_subframe[i];\n\n                s->channel[c].quant_step = quant_step;\n\n                if (get_bits1(&s->gb)) {\n\n                    if (modifier_len) {\n\n                        s->channel[c].quant_step += get_bits(&s->gb, modifier_len) + 1;\n\n                    } else\n\n                        ++s->channel[c].quant_step;\n\n                }\n\n            }\n\n        }\n\n\n\n        /** decode scale factors */\n\n        if (decode_scale_factors(s) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    av_dlog(s->avctx, \"BITSTREAM: subframe header length was %i\\n\",\n\n            get_bits_count(&s->gb) - s->subframe_offset);\n\n\n\n    /** parse coefficients */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].transmit_coefs &&\n\n            get_bits_count(&s->gb) < s->num_saved_bits) {\n\n            decode_coeffs(s, c);\n\n        } else\n\n            memset(s->channel[c].coeffs, 0,\n\n                   sizeof(*s->channel[c].coeffs) * subframe_len);\n\n    }\n\n\n\n    av_dlog(s->avctx, \"BITSTREAM: subframe length was %i\\n\",\n\n            get_bits_count(&s->gb) - s->subframe_offset);\n\n\n\n    if (transmit_coeffs) {\n\n        FFTContext *mdct = &s->mdct_ctx[av_log2(subframe_len) - WMAPRO_BLOCK_MIN_BITS];\n\n        /** reconstruct the per channel data */\n\n        inverse_channel_transform(s);\n\n        for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n            int c = s->channel_indexes_for_cur_subframe[i];\n\n            const int* sf = s->channel[c].scale_factors;\n\n            int b;\n\n\n\n            if (c == s->lfe_channel)\n\n                memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *\n\n                       (subframe_len - cur_subwoofer_cutoff));\n\n\n\n            /** inverse quantization and rescaling */\n\n            for (b = 0; b < s->num_bands; b++) {\n\n                const int end = FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);\n\n                const int exp = s->channel[c].quant_step -\n\n                            (s->channel[c].max_scale_factor - *sf++) *\n\n                            s->channel[c].scale_factor_step;\n\n                const float quant = pow(10.0, exp / 20.0);\n\n                int start = s->cur_sfb_offsets[b];\n\n                s->fdsp.vector_fmul_scalar(s->tmp + start,\n\n                                           s->channel[c].coeffs + start,\n\n                                           quant, end - start);\n\n            }\n\n\n\n            /** apply imdct (imdct_half == DCTIV with reverse) */\n\n            mdct->imdct_half(mdct, s->channel[c].coeffs, s->tmp);\n\n        }\n\n    }\n\n\n\n    /** window and overlapp-add */\n\n    wmapro_window(s);\n\n\n\n    /** handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 333}
{"project": "qemu", "commit_id": "3178e2755ec5a7fb1afe583fb6ac2622c2c42184", "target": 1, "func": "static int find_vdi_name(BDRVSheepdogState *s, char *filename, uint32_t snapid,\n\n                         char *tag, uint32_t *vid, int for_snapshot)\n\n{\n\n    int ret, fd;\n\n    SheepdogVdiReq hdr;\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n    unsigned int wlen, rlen = 0;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    strncpy(buf, filename, SD_MAX_VDI_LEN);\n\n    strncpy(buf + SD_MAX_VDI_LEN, tag, SD_MAX_VDI_TAG_LEN);\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n    if (for_snapshot) {\n\n        hdr.opcode = SD_OP_GET_VDI_INFO;\n\n    } else {\n\n        hdr.opcode = SD_OP_LOCK_VDI;\n\n    }\n\n    wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN;\n\n    hdr.proto_ver = SD_PROTO_VER;\n\n    hdr.data_length = wlen;\n\n    hdr.snapid = snapid;\n\n    hdr.flags = SD_FLAG_CMD_WRITE;\n\n\n\n    ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    if (rsp->result != SD_RES_SUCCESS) {\n\n        error_report(\"cannot get vdi info, %s, %s %d %s\",\n\n                     sd_strerror(rsp->result), filename, snapid, tag);\n\n        if (rsp->result == SD_RES_NO_VDI) {\n\n            ret = -ENOENT;\n\n        } else {\n\n            ret = -EIO;\n\n        }\n\n        goto out;\n\n    }\n\n    *vid = rsp->vdi_id;\n\n\n\n    ret = 0;\n\nout:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 334}
{"project": "qemu", "commit_id": "7df2fa3623dfe8a082bba54ae87750d5030814c1", "target": 1, "func": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tabi_ulong frame_addr;\n\n\tstruct sigframe *frame;\n\n\tint i, err = 0;\n\n\n\n\tframe_addr = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\t\tgoto give_sigsegv;\n\n\n\n    __put_user(current_exec_domain_sig(sig),\n\n               &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0],\n\n                         frame_addr + offsetof(struct sigframe, fpstate));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n        for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n                goto give_sigsegv;\n\n        }\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        __put_user(ka->sa_restorer, &frame->pretcode);\n\n\t} else {\n\n                uint16_t val16;\n\n                abi_ulong retcode_addr;\n\n                retcode_addr = frame_addr + offsetof(struct sigframe, retcode);\n\n        __put_user(retcode_addr, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n                val16 = 0xb858;\n\n        __put_user(val16, (uint16_t *)(frame->retcode+0));\n\n        __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n                val16 = 0x80cd;\n\n        __put_user(val16, (uint16_t *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = frame_addr;\n\n\tenv->eip = ka->_sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->_sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 335}
{"project": "qemu", "commit_id": "9a75b0a037e3a8030992244353f17b62f6daf2ab", "target": 1, "func": "static void ahci_pci_enable(AHCIQState *ahci)\n\n{\n\n    uint8_t reg;\n\n\n\n    start_ahci_device(ahci);\n\n\n\n    switch (ahci->fingerprint) {\n\n    case AHCI_INTEL_ICH9:\n\n        /* ICH9 has a register at PCI 0x92 that\n\n         * acts as a master port enabler mask. */\n\n        reg = qpci_config_readb(ahci->dev, 0x92);\n\n        reg |= 0x3F;\n\n        qpci_config_writeb(ahci->dev, 0x92, reg);\n\n        /* 0...0111111b -- bit significant, ports 0-5 enabled. */\n\n        ASSERT_BIT_SET(qpci_config_readb(ahci->dev, 0x92), 0x3F);\n\n        break;\n\n    }\n\n\n\n}\n", "idx": 336}
{"project": "qemu", "commit_id": "69fded480e335ecfe877e2c37de0eff265fced12", "target": 1, "func": "main(\n\n    int argc,\n\n    char *argv[]\n\n) {\n\n    GMainLoop *loop;\n\n    GIOChannel *channel_stdin;\n\n    char *qemu_host;\n\n    char *qemu_port;\n\n    VSCMsgHeader mhHeader;\n\n\n\n    VCardEmulOptions *command_line_options = NULL;\n\n\n\n    char *cert_names[MAX_CERTS];\n\n    char *emul_args = NULL;\n\n    int cert_count = 0;\n\n    int c, sock;\n\n\n\n    if (socket_init() != 0)\n\n        return 1;\n\n\n\n    while ((c = getopt(argc, argv, \"c:e:pd:\")) != -1) {\n\n        switch (c) {\n\n        case 'c':\n\n            if (cert_count >= MAX_CERTS) {\n\n                printf(\"too many certificates (max = %d)\\n\", MAX_CERTS);\n\n                exit(5);\n\n            }\n\n            cert_names[cert_count++] = optarg;\n\n            break;\n\n        case 'e':\n\n            emul_args = optarg;\n\n            break;\n\n        case 'p':\n\n            print_usage();\n\n            exit(4);\n\n            break;\n\n        case 'd':\n\n            verbose = get_id_from_string(optarg, 1);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (argc - optind != 2) {\n\n        print_usage();\n\n        exit(4);\n\n    }\n\n\n\n    if (cert_count > 0) {\n\n        char *new_args;\n\n        int len, i;\n\n        /* if we've given some -c options, we clearly we want do so some\n\n         * software emulation.  add that emulation now. this is NSS Emulator\n\n         * specific */\n\n        if (emul_args == NULL) {\n\n            emul_args = (char *)\"db=\\\"/etc/pki/nssdb\\\"\";\n\n        }\n\n#define SOFT_STRING \",soft=(,Virtual Reader,CAC,,\"\n\n             /* 2 == close paren & null */\n\n        len = strlen(emul_args) + strlen(SOFT_STRING) + 2;\n\n        for (i = 0; i < cert_count; i++) {\n\n            len += strlen(cert_names[i])+1; /* 1 == comma */\n\n        }\n\n        new_args = g_malloc(len);\n\n        strcpy(new_args, emul_args);\n\n        strcat(new_args, SOFT_STRING);\n\n        for (i = 0; i < cert_count; i++) {\n\n            strcat(new_args, cert_names[i]);\n\n            strcat(new_args, \",\");\n\n        }\n\n        strcat(new_args, \")\");\n\n        emul_args = new_args;\n\n    }\n\n    if (emul_args) {\n\n        command_line_options = vcard_emul_options(emul_args);\n\n    }\n\n\n\n    qemu_host = g_strdup(argv[argc - 2]);\n\n    qemu_port = g_strdup(argv[argc - 1]);\n\n    sock = connect_to_qemu(qemu_host, qemu_port);\n\n    if (sock == -1) {\n\n        fprintf(stderr, \"error opening socket, exiting.\\n\");\n\n        exit(5);\n\n    }\n\n\n\n    socket_to_send = g_byte_array_new();\n\n    qemu_mutex_init(&socket_to_send_lock);\n\n    qemu_mutex_init(&pending_reader_lock);\n\n    qemu_cond_init(&pending_reader_condition);\n\n\n\n    vcard_emul_init(command_line_options);\n\n\n\n    loop = g_main_loop_new(NULL, true);\n\n\n\n    printf(\"> \");\n\n    fflush(stdout);\n\n\n\n#ifdef _WIN32\n\n    channel_stdin = g_io_channel_win32_new_fd(STDIN_FILENO);\n\n#else\n\n    channel_stdin = g_io_channel_unix_new(STDIN_FILENO);\n\n#endif\n\n    g_io_add_watch(channel_stdin, G_IO_IN, do_command, NULL);\n\n#ifdef _WIN32\n\n    channel_socket = g_io_channel_win32_new_socket(sock);\n\n#else\n\n    channel_socket = g_io_channel_unix_new(sock);\n\n#endif\n\n    g_io_channel_set_encoding(channel_socket, NULL, NULL);\n\n    /* we buffer ourself for thread safety reasons */\n\n    g_io_channel_set_buffered(channel_socket, FALSE);\n\n\n\n    /* Send init message, Host responds (and then we send reader attachments) */\n\n    VSCMsgInit init = {\n\n        .version = htonl(VSCARD_VERSION),\n\n        .magic = VSCARD_MAGIC,\n\n        .capabilities = {0}\n\n    };\n\n    send_msg(VSC_Init, mhHeader.reader_id, &init, sizeof(init));\n\n\n\n    g_main_loop_run(loop);\n\n    g_main_loop_unref(loop);\n\n\n\n    g_io_channel_unref(channel_stdin);\n\n    g_io_channel_unref(channel_socket);\n\n    g_byte_array_unref(socket_to_send);\n\n\n\n    closesocket(sock);\n\n    return 0;\n\n}\n", "idx": 337}
{"project": "qemu", "commit_id": "a5b39cd3f647eaaaef5b648beda5cb2f387418c0", "target": 1, "func": "static VFIOINTp *vfio_init_intp(VFIODevice *vbasedev,\n\n                                struct vfio_irq_info info)\n\n{\n\n    int ret;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n    SysBusDevice *sbdev = SYS_BUS_DEVICE(vdev);\n\n    VFIOINTp *intp;\n\n\n\n    intp = g_malloc0(sizeof(*intp));\n\n    intp->vdev = vdev;\n\n    intp->pin = info.index;\n\n    intp->flags = info.flags;\n\n    intp->state = VFIO_IRQ_INACTIVE;\n\n    intp->kvm_accel = false;\n\n\n\n    sysbus_init_irq(sbdev, &intp->qemuirq);\n\n\n\n    /* Get an eventfd for trigger */\n\n    intp->interrupt = g_malloc0(sizeof(EventNotifier));\n\n    ret = event_notifier_init(intp->interrupt, 0);\n\n    if (ret) {\n\n        g_free(intp->interrupt);\n\n        g_free(intp);\n\n        error_report(\"vfio: Error: trigger event_notifier_init failed \");\n\n        return NULL;\n\n    }\n\n    /* Get an eventfd for resample/unmask */\n\n    intp->unmask = g_malloc0(sizeof(EventNotifier));\n\n    ret = event_notifier_init(intp->unmask, 0);\n\n    if (ret) {\n\n        g_free(intp->interrupt);\n\n        g_free(intp->unmask);\n\n        g_free(intp);\n\n        error_report(\"vfio: Error: resamplefd event_notifier_init failed\");\n\n        return NULL;\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&vdev->intp_list, intp, next);\n\n    return intp;\n\n}\n", "idx": 339}
{"project": "qemu", "commit_id": "14a1120e5c8c4c29441141b4657f91e04d10fac0", "target": 1, "func": "void OPPROTO op_udivx_T1_T0(void)\n\n{\n\n\n\n\n    T0 /= T1;\n\n    FORCE_RET();\n", "idx": 340}
{"project": "qemu", "commit_id": "4c19eb721a5929f2277d33a98bb59963c58c2e3b", "target": 1, "func": "void address_space_init(AddressSpace *as, MemoryRegion *root)\n\n{\n\n    memory_region_transaction_begin();\n\n    as->root = root;\n\n    as->current_map = g_new(FlatView, 1);\n\n    flatview_init(as->current_map);\n\n\n\n    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);\n\n    as->name = NULL;\n\n    memory_region_transaction_commit();\n\n    address_space_init_dispatch(as);\n\n}", "idx": 341}
{"project": "FFmpeg", "commit_id": "ff2c222c379645cb7825b8ddc222142dcaea1677", "target": 1, "func": "ebml_read_ascii (MatroskaDemuxContext *matroska,\n\n                 uint32_t             *id,\n\n                 char                **str)\n\n{\n\n    ByteIOContext *pb = matroska->ctx->pb;\n\n    int size, res;\n\n    uint64_t rlength;\n\n\n\n    if ((res = ebml_read_element_id(matroska, id, NULL)) < 0 ||\n\n        (res = ebml_read_element_length(matroska, &rlength)) < 0)\n\n        return res;\n\n    size = rlength;\n\n\n\n    /* ebml strings are usually not 0-terminated, so we allocate one\n\n     * byte more, read the string and NULL-terminate it ourselves. */\n\n    if (size < 0 || !(*str = av_malloc(size + 1))) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR, \"Memory allocation failed\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    if (get_buffer(pb, (uint8_t *) *str, size) != size) {\n\n        offset_t pos = url_ftell(pb);\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"Read error at pos. %\"PRIu64\" (0x%\"PRIx64\")\\n\", pos, pos);\n\n\n        return AVERROR(EIO);\n\n    }\n\n    (*str)[size] = '\\0';\n\n\n\n    return 0;\n\n}", "idx": 343}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static void memory_dump(Monitor *mon, int count, int format, int wsize,\n\n                        target_phys_addr_t addr, int is_physical)\n\n{\n\n    CPUState *env;\n\n    int l, line_size, i, max_digits, len;\n\n    uint8_t buf[16];\n\n    uint64_t v;\n\n\n\n    if (format == 'i') {\n\n        int flags;\n\n        flags = 0;\n\n        env = mon_get_cpu();\n\n        if (!env && !is_physical)\n\n            return;\n\n#ifdef TARGET_I386\n\n        if (wsize == 2) {\n\n            flags = 1;\n\n        } else if (wsize == 4) {\n\n            flags = 0;\n\n        } else {\n\n            /* as default we use the current CS size */\n\n            flags = 0;\n\n            if (env) {\n\n#ifdef TARGET_X86_64\n\n                if ((env->efer & MSR_EFER_LMA) &&\n\n                    (env->segs[R_CS].flags & DESC_L_MASK))\n\n                    flags = 2;\n\n                else\n\n#endif\n\n                if (!(env->segs[R_CS].flags & DESC_B_MASK))\n\n                    flags = 1;\n\n            }\n\n        }\n\n#endif\n\n        monitor_disas(mon, env, addr, count, is_physical, flags);\n\n        return;\n\n    }\n\n\n\n    len = wsize * count;\n\n    if (wsize == 1)\n\n        line_size = 8;\n\n    else\n\n        line_size = 16;\n\n    max_digits = 0;\n\n\n\n    switch(format) {\n\n    case 'o':\n\n        max_digits = (wsize * 8 + 2) / 3;\n\n        break;\n\n    default:\n\n    case 'x':\n\n        max_digits = (wsize * 8) / 4;\n\n        break;\n\n    case 'u':\n\n    case 'd':\n\n        max_digits = (wsize * 8 * 10 + 32) / 33;\n\n        break;\n\n    case 'c':\n\n        wsize = 1;\n\n        break;\n\n    }\n\n\n\n    while (len > 0) {\n\n        if (is_physical)\n\n            monitor_printf(mon, TARGET_FMT_plx \":\", addr);\n\n        else\n\n            monitor_printf(mon, TARGET_FMT_lx \":\", (target_ulong)addr);\n\n        l = len;\n\n        if (l > line_size)\n\n            l = line_size;\n\n        if (is_physical) {\n\n            cpu_physical_memory_rw(addr, buf, l, 0);\n\n        } else {\n\n            env = mon_get_cpu();\n\n            if (!env)\n\n                break;\n\n            if (cpu_memory_rw_debug(env, addr, buf, l, 0) < 0) {\n\n                monitor_printf(mon, \" Cannot access memory\\n\");\n\n                break;\n\n            }\n\n        }\n\n        i = 0;\n\n        while (i < l) {\n\n            switch(wsize) {\n\n            default:\n\n            case 1:\n\n                v = ldub_raw(buf + i);\n\n                break;\n\n            case 2:\n\n                v = lduw_raw(buf + i);\n\n                break;\n\n            case 4:\n\n                v = (uint32_t)ldl_raw(buf + i);\n\n                break;\n\n            case 8:\n\n                v = ldq_raw(buf + i);\n\n                break;\n\n            }\n\n            monitor_printf(mon, \" \");\n\n            switch(format) {\n\n            case 'o':\n\n                monitor_printf(mon, \"%#*\" PRIo64, max_digits, v);\n\n                break;\n\n            case 'x':\n\n                monitor_printf(mon, \"0x%0*\" PRIx64, max_digits, v);\n\n                break;\n\n            case 'u':\n\n                monitor_printf(mon, \"%*\" PRIu64, max_digits, v);\n\n                break;\n\n            case 'd':\n\n                monitor_printf(mon, \"%*\" PRId64, max_digits, v);\n\n                break;\n\n            case 'c':\n\n                monitor_printc(mon, v);\n\n                break;\n\n            }\n\n            i += wsize;\n\n        }\n\n        monitor_printf(mon, \"\\n\");\n\n        addr += l;\n\n        len -= l;\n\n    }\n\n}\n", "idx": 344}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "RGB_FUNCTIONS(rgba32)\n\n\n\n#undef RGB_IN\n\n#undef RGB_OUT\n\n#undef BPP\n\n\n\n\n\nstatic void rgb24_to_rgb565(AVPicture *dst, AVPicture *src,\n\n                            int width, int height)\n\n{\n\n    const unsigned char *p;\n\n    unsigned char *q;\n\n    int r, g, b, dst_wrap, src_wrap;\n\n    int x, y;\n\n\n\n    p = src->data[0];\n\n    src_wrap = src->linesize[0] - 3 * width;\n\n\n\n    q = dst->data[0];\n\n    dst_wrap = dst->linesize[0] - 2 * width;\n\n\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            r = p[0];\n\n            g = p[1];\n\n            b = p[2];\n\n\n\n            ((unsigned short *)q)[0] = \n\n                ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);\n\n            q += 2;\n\n            p += 3;\n\n        }\n\n        p += src_wrap;\n\n        q += dst_wrap;\n\n    }\n\n}\n", "idx": 347}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_mid_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                                int32_t src_stride,\n\n                                                uint8_t *dst,\n\n                                                int32_t dst_stride)\n\n{\n\n    avc_luma_mid_and_aver_dst_8w_msa(src, src_stride, dst, dst_stride, 16);\n\n    avc_luma_mid_and_aver_dst_8w_msa(src + 8, src_stride, dst + 8, dst_stride,\n\n                                     16);\n\n}\n", "idx": 348}
{"project": "FFmpeg", "commit_id": "594026277250fecf0ba34c9e1498921936c6bfed", "target": 0, "func": "void MPV_common_init_armv4l(MpegEncContext *s)\n\n{\n\n    int i;\n\n    const int idct_algo= s->avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n    ff_add_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n\n\n    if(idct_algo==FF_IDCT_AUTO || idct_algo==FF_IDCT_ARM){\n\n        s->idct_put= arm_idct_put;\n\n        s->idct_add= arm_idct_add;\n\n        s->idct_permutation_type= FF_NO_IDCT_PERM;\n\n    }\n\n}\n", "idx": 349}
{"project": "FFmpeg", "commit_id": "c2340831b8e9032716acb0aab4893d3cc500213a", "target": 0, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.\n\n        // After this check the final number of patches can still be six which is\n\n        // illegal however the Coding Technologies decoder check stream has a final\n\n        // count of 6 patches\n\n        if (sbr->num_patches > 5) {\n\n            av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n            return -1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    return 0;\n\n}\n", "idx": 350}
{"project": "FFmpeg", "commit_id": "14db3af4f26dad8e6ddf2147e96ccc710952ad4d", "target": 0, "func": "static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)\n\n{\n\n    int channel, stereo, phase, exp;\n\n    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;\n\n    int local_int_14, stereo_exp, local_int_20, local_int_28;\n\n    int n, offset;\n\n\n\n    local_int_4 = 0;\n\n    local_int_28 = 0;\n\n    local_int_20 = 2;\n\n    local_int_8 = (4 - duration);\n\n    local_int_10 = 1 << (q->group_order - duration - 1);\n\n    offset = 1;\n\n\n\n    while (1) {\n\n        if (q->superblocktype_2_3) {\n\n            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {\n\n                offset = 1;\n\n                if (n == 0) {\n\n                    local_int_4 += local_int_10;\n\n                    local_int_28 += (1 << local_int_8);\n\n                } else {\n\n                    local_int_4 += 8*local_int_10;\n\n                    local_int_28 += (8 << local_int_8);\n\n                }\n\n            }\n\n            offset += (n - 2);\n\n        } else {\n\n            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);\n\n            while (offset >= (local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n            return;\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n        if (local_int_14 >= FF_ARRAY_ELEMS(fft_level_index_table))\n\n            return;\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}\n", "idx": 351}
{"project": "FFmpeg", "commit_id": "34056cbba55f0131e8d2698717ab9e86e2da5178", "target": 1, "func": "void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size)\n\n{\n\n    RTPMuxContext *s = s1->priv_data;\n\n    int len, max_packet_size;\n\n    uint8_t *q;\n\n\n\n    max_packet_size = s->max_payload_size;\n\n\n\n    while (size > 0) {\n\n        q = s->buf;\n\n        if ((buf1[0] == 0) && (buf1[1] == 0)) {\n\n            *q++ = 0x04;\n\n            buf1 += 2;\n\n            size -= 2;\n\n        } else {\n\n            *q++ = 0;\n\n        }\n\n        *q++ = 0;\n\n\n\n        len = FFMIN(max_packet_size - 2, size);\n\n\n\n        /* Look for a better place to split the frame into packets. */\n\n        if (len < size) {\n\n            const uint8_t *end = find_resync_marker_reverse(buf1, buf1 + len);\n\n            len = end - buf1;\n\n        }\n\n\n\n        memcpy(q, buf1, len);\n\n        q += len;\n\n\n\n        /* 90 KHz time stamp */\n\n        s->timestamp = s->cur_timestamp;\n\n        ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));\n\n\n\n        buf1 += len;\n\n        size -= len;\n\n    }\n\n}\n", "idx": 352}
{"project": "qemu", "commit_id": "15fa08f8451babc88d733bd411d4c94976f9d0f8", "target": 1, "func": "void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)\n\n{\n\n    TCGContext *s = tcg_ctx;\n\n    int i, real_args, nb_rets, pi;\n\n    unsigned sizemask, flags;\n\n    TCGHelperInfo *info;\n\n    TCGOp *op;\n\n\n\n    info = g_hash_table_lookup(helper_table, (gpointer)func);\n\n    flags = info->flags;\n\n    sizemask = info->sizemask;\n\n\n\n#if defined(__sparc__) && !defined(__arch64__) \\\n\n    && !defined(CONFIG_TCG_INTERPRETER)\n\n    /* We have 64-bit values in one register, but need to pass as two\n\n       separate parameters.  Split them.  */\n\n    int orig_sizemask = sizemask;\n\n    int orig_nargs = nargs;\n\n    TCGv_i64 retl, reth;\n\n    TCGTemp *split_args[MAX_OPC_PARAM];\n\n\n\n    retl = NULL;\n\n    reth = NULL;\n\n    if (sizemask != 0) {\n\n        for (i = real_args = 0; i < nargs; ++i) {\n\n            int is_64bit = sizemask & (1 << (i+1)*2);\n\n            if (is_64bit) {\n\n                TCGv_i64 orig = temp_tcgv_i64(args[i]);\n\n                TCGv_i32 h = tcg_temp_new_i32();\n\n                TCGv_i32 l = tcg_temp_new_i32();\n\n                tcg_gen_extr_i64_i32(l, h, orig);\n\n                split_args[real_args++] = tcgv_i32_temp(h);\n\n                split_args[real_args++] = tcgv_i32_temp(l);\n\n            } else {\n\n                split_args[real_args++] = args[i];\n\n            }\n\n        }\n\n        nargs = real_args;\n\n        args = split_args;\n\n        sizemask = 0;\n\n    }\n\n#elif defined(TCG_TARGET_EXTEND_ARGS) && TCG_TARGET_REG_BITS == 64\n\n    for (i = 0; i < nargs; ++i) {\n\n        int is_64bit = sizemask & (1 << (i+1)*2);\n\n        int is_signed = sizemask & (2 << (i+1)*2);\n\n        if (!is_64bit) {\n\n            TCGv_i64 temp = tcg_temp_new_i64();\n\n            TCGv_i64 orig = temp_tcgv_i64(args[i]);\n\n            if (is_signed) {\n\n                tcg_gen_ext32s_i64(temp, orig);\n\n            } else {\n\n                tcg_gen_ext32u_i64(temp, orig);\n\n            }\n\n            args[i] = tcgv_i64_temp(temp);\n\n        }\n\n    }\n\n#endif /* TCG_TARGET_EXTEND_ARGS */\n\n\n\n    i = s->gen_next_op_idx;\n\n    tcg_debug_assert(i < OPC_BUF_SIZE);\n\n    s->gen_op_buf[0].prev = i;\n\n    s->gen_next_op_idx = i + 1;\n\n    op = &s->gen_op_buf[i];\n\n\n\n    /* Set links for sequential allocation during translation.  */\n\n    memset(op, 0, offsetof(TCGOp, args));\n\n    op->opc = INDEX_op_call;\n\n    op->prev = i - 1;\n\n    op->next = i + 1;\n\n\n\n    pi = 0;\n\n    if (ret != NULL) {\n\n#if defined(__sparc__) && !defined(__arch64__) \\\n\n    && !defined(CONFIG_TCG_INTERPRETER)\n\n        if (orig_sizemask & 1) {\n\n            /* The 32-bit ABI is going to return the 64-bit value in\n\n               the %o0/%o1 register pair.  Prepare for this by using\n\n               two return temporaries, and reassemble below.  */\n\n            retl = tcg_temp_new_i64();\n\n            reth = tcg_temp_new_i64();\n\n            op->args[pi++] = tcgv_i64_arg(reth);\n\n            op->args[pi++] = tcgv_i64_arg(retl);\n\n            nb_rets = 2;\n\n        } else {\n\n            op->args[pi++] = temp_arg(ret);\n\n            nb_rets = 1;\n\n        }\n\n#else\n\n        if (TCG_TARGET_REG_BITS < 64 && (sizemask & 1)) {\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n            op->args[pi++] = temp_arg(ret + 1);\n\n            op->args[pi++] = temp_arg(ret);\n\n#else\n\n            op->args[pi++] = temp_arg(ret);\n\n            op->args[pi++] = temp_arg(ret + 1);\n\n#endif\n\n            nb_rets = 2;\n\n        } else {\n\n            op->args[pi++] = temp_arg(ret);\n\n            nb_rets = 1;\n\n        }\n\n#endif\n\n    } else {\n\n        nb_rets = 0;\n\n    }\n\n    op->callo = nb_rets;\n\n\n\n    real_args = 0;\n\n    for (i = 0; i < nargs; i++) {\n\n        int is_64bit = sizemask & (1 << (i+1)*2);\n\n        if (TCG_TARGET_REG_BITS < 64 && is_64bit) {\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n            /* some targets want aligned 64 bit args */\n\n            if (real_args & 1) {\n\n                op->args[pi++] = TCG_CALL_DUMMY_ARG;\n\n                real_args++;\n\n            }\n\n#endif\n\n           /* If stack grows up, then we will be placing successive\n\n              arguments at lower addresses, which means we need to\n\n              reverse the order compared to how we would normally\n\n              treat either big or little-endian.  For those arguments\n\n              that will wind up in registers, this still works for\n\n              HPPA (the only current STACK_GROWSUP target) since the\n\n              argument registers are *also* allocated in decreasing\n\n              order.  If another such target is added, this logic may\n\n              have to get more complicated to differentiate between\n\n              stack arguments and register arguments.  */\n\n#if defined(HOST_WORDS_BIGENDIAN) != defined(TCG_TARGET_STACK_GROWSUP)\n\n            op->args[pi++] = temp_arg(args[i] + 1);\n\n            op->args[pi++] = temp_arg(args[i]);\n\n#else\n\n            op->args[pi++] = temp_arg(args[i]);\n\n            op->args[pi++] = temp_arg(args[i] + 1);\n\n#endif\n\n            real_args += 2;\n\n            continue;\n\n        }\n\n\n\n        op->args[pi++] = temp_arg(args[i]);\n\n        real_args++;\n\n    }\n\n    op->args[pi++] = (uintptr_t)func;\n\n    op->args[pi++] = flags;\n\n    op->calli = real_args;\n\n\n\n    /* Make sure the fields didn't overflow.  */\n\n    tcg_debug_assert(op->calli == real_args);\n\n    tcg_debug_assert(pi <= ARRAY_SIZE(op->args));\n\n\n\n#if defined(__sparc__) && !defined(__arch64__) \\\n\n    && !defined(CONFIG_TCG_INTERPRETER)\n\n    /* Free all of the parts we allocated above.  */\n\n    for (i = real_args = 0; i < orig_nargs; ++i) {\n\n        int is_64bit = orig_sizemask & (1 << (i+1)*2);\n\n        if (is_64bit) {\n\n            tcg_temp_free_internal(args[real_args++]);\n\n            tcg_temp_free_internal(args[real_args++]);\n\n        } else {\n\n            real_args++;\n\n        }\n\n    }\n\n    if (orig_sizemask & 1) {\n\n        /* The 32-bit ABI returned two 32-bit pieces.  Re-assemble them.\n\n           Note that describing these as TCGv_i64 eliminates an unnecessary\n\n           zero-extension that tcg_gen_concat_i32_i64 would create.  */\n\n        tcg_gen_concat32_i64(temp_tcgv_i64(ret), retl, reth);\n\n        tcg_temp_free_i64(retl);\n\n        tcg_temp_free_i64(reth);\n\n    }\n\n#elif defined(TCG_TARGET_EXTEND_ARGS) && TCG_TARGET_REG_BITS == 64\n\n    for (i = 0; i < nargs; ++i) {\n\n        int is_64bit = sizemask & (1 << (i+1)*2);\n\n        if (!is_64bit) {\n\n            tcg_temp_free_internal(args[i]);\n\n        }\n\n    }\n\n#endif /* TCG_TARGET_EXTEND_ARGS */\n\n}\n", "idx": 353}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void block_job_enter(BlockJob *job)\n\n{\n\n    if (!block_job_started(job)) {\n\n        return;\n\n    }\n\n    if (job->deferred_to_main_loop) {\n\n        return;\n\n    }\n\n\n\n    if (!job->busy) {\n\n        bdrv_coroutine_enter(blk_bs(job->blk), job->co);\n\n    }\n\n}\n", "idx": 356}
{"project": "FFmpeg", "commit_id": "60aa1a358d9c1c8f891e72246d5dcd897857eca8", "target": 0, "func": "static int vorbis_decode_frame(AVCodecContext *avccontext,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    vorbis_context *vc = avccontext->priv_data ;\n\n    GetBitContext *gb = &(vc->gb);\n\n    const float *channel_ptrs[255];\n\n    int i, len;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    av_dlog(NULL, \"packet length %d \\n\", buf_size);\n\n\n\n    init_get_bits(gb, buf, buf_size*8);\n\n\n\n    len = vorbis_parse_audio_packet(vc);\n\n\n\n    if (len <= 0) {\n\n        *data_size = 0;\n\n        return buf_size;\n\n    }\n\n\n\n    if (!vc->first_frame) {\n\n        vc->first_frame = 1;\n\n        *data_size = 0;\n\n        return buf_size ;\n\n    }\n\n\n\n    av_dlog(NULL, \"parsed %d bytes %d bits, returned %d samples (*ch*bits) \\n\",\n\n            get_bits_count(gb) / 8, get_bits_count(gb) % 8, len);\n\n\n\n    if (vc->audio_channels > 8) {\n\n        for (i = 0; i < vc->audio_channels; i++)\n\n            channel_ptrs[i] = vc->channel_floors + i * len;\n\n    } else {\n\n        for (i = 0; i < vc->audio_channels; i++)\n\n            channel_ptrs[i] = vc->channel_floors +\n\n                              len * ff_vorbis_channel_layout_offsets[vc->audio_channels - 1][i];\n\n    }\n\n\n\n    if (avccontext->sample_fmt == AV_SAMPLE_FMT_FLT)\n\n        vc->fmt_conv.float_interleave(data, channel_ptrs, len, vc->audio_channels);\n\n    else\n\n        vc->fmt_conv.float_to_int16_interleave(data, channel_ptrs, len,\n\n                                               vc->audio_channels);\n\n\n\n    *data_size = len * vc->audio_channels *\n\n                 av_get_bytes_per_sample(avccontext->sample_fmt);\n\n\n\n    return buf_size ;\n\n}\n", "idx": 357}
{"project": "qemu", "commit_id": "16f4e8fa737b58b7b0461b33581e43ac06991110", "target": 1, "func": "void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)\n\n{\n\n    UINT shutdown_flag = EWX_FORCE;\n\n\n\n    slog(\"guest-shutdown called, mode: %s\", mode);\n\n\n\n    if (!has_mode || strcmp(mode, \"powerdown\") == 0) {\n\n        shutdown_flag |= EWX_POWEROFF;\n\n    } else if (strcmp(mode, \"halt\") == 0) {\n\n        shutdown_flag |= EWX_SHUTDOWN;\n\n    } else if (strcmp(mode, \"reboot\") == 0) {\n\n        shutdown_flag |= EWX_REBOOT;\n\n    } else {\n\n        error_set(err, QERR_INVALID_PARAMETER_VALUE, \"mode\",\n\n                  \"halt|powerdown|reboot\");\n\n        return;\n\n    }\n\n\n\n    /* Request a shutdown privilege, but try to shut down the system\n\n       anyway. */\n\n    acquire_privilege(SE_SHUTDOWN_NAME, err);\n\n    if (error_is_set(err)) {\n\n        return;\n\n    }\n\n\n\n    if (!ExitWindowsEx(shutdown_flag, SHTDN_REASON_FLAG_PLANNED)) {\n\n        slog(\"guest-shutdown failed: %d\", GetLastError());\n\n        error_set(err, QERR_UNDEFINED_ERROR);\n\n    }\n\n}\n", "idx": 358}
{"project": "qemu", "commit_id": "165d9b82eb8c877ee691a7b7bde5930bc2d07037", "target": 1, "func": "void helper_rdmsr(void)\n\n{\n\n    uint64_t val;\n\n\n\n    helper_svm_check_intercept_param(SVM_EXIT_MSR, 0);\n\n\n\n    switch((uint32_t)ECX) {\n\n    case MSR_IA32_SYSENTER_CS:\n\n        val = env->sysenter_cs;\n\n\n    case MSR_IA32_SYSENTER_ESP:\n\n        val = env->sysenter_esp;\n\n\n    case MSR_IA32_SYSENTER_EIP:\n\n        val = env->sysenter_eip;\n\n\n    case MSR_IA32_APICBASE:\n\n        val = cpu_get_apic_base(env);\n\n\n    case MSR_EFER:\n\n        val = env->efer;\n\n\n    case MSR_STAR:\n\n        val = env->star;\n\n\n    case MSR_PAT:\n\n        val = env->pat;\n\n\n    case MSR_VM_HSAVE_PA:\n\n        val = env->vm_hsave;\n\n\n    case MSR_IA32_PERF_STATUS:\n\n        /* tsc_increment_by_tick */\n\n        val = 1000ULL;\n\n        /* CPU multiplier */\n\n        val |= (((uint64_t)4ULL) << 40);\n\n\n#ifdef TARGET_X86_64\n\n    case MSR_LSTAR:\n\n        val = env->lstar;\n\n\n    case MSR_CSTAR:\n\n        val = env->cstar;\n\n\n    case MSR_FMASK:\n\n        val = env->fmask;\n\n\n    case MSR_FSBASE:\n\n        val = env->segs[R_FS].base;\n\n\n    case MSR_GSBASE:\n\n        val = env->segs[R_GS].base;\n\n\n    case MSR_KERNELGSBASE:\n\n        val = env->kernelgsbase;\n\n\n#endif\n\n#ifdef USE_KQEMU\n\n    case MSR_QPI_COMMBASE:\n\n        if (env->kqemu_enabled) {\n\n            val = kqemu_comm_base;\n\n        } else {\n\n            val = 0;\n\n        }\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        /* XXX: exception ? */\n\n        val = 0;\n\n\n    }\n\n    EAX = (uint32_t)(val);\n\n    EDX = (uint32_t)(val >> 32);\n\n}", "idx": 359}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "BlockJobInfoList *qmp_query_block_jobs(Error **errp)\n\n{\n\n    BlockJobInfoList *head = NULL, **p_next = &head;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n\n\n        if (bs->job) {\n\n            BlockJobInfoList *elem = g_new0(BlockJobInfoList, 1);\n\n            elem->value = block_job_query(bs->job);\n\n            *p_next = elem;\n\n            p_next = &elem->next;\n\n        }\n\n\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return head;\n\n}\n", "idx": 360}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *ssi_create_slave(SSIBus *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n", "idx": 361}
{"project": "FFmpeg", "commit_id": "2884688bd51a808ccda3c0e13367619cd79e0579", "target": 1, "func": "int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask,\n\n                        const AVFrame *reference)\n\n{\n\n    int len, nb_components, i, h, v, predictor, point_transform;\n\n    int index, id, ret;\n\n    const int block_size = s->lossless ? 1 : 8;\n\n    int ilv, prev_shift;\n\n\n\n    if (!s->got_picture) {\n\n        av_log(s->avctx, AV_LOG_WARNING,\n\n                \"Can not process SOS before SOF, skipping\\n\");\n\n        return -1;\n\n    }\n\n\n\n    av_assert0(s->picture_ptr->data[0]);\n\n    /* XXX: verify len field validity */\n\n    len = get_bits(&s->gb, 16);\n\n    nb_components = get_bits(&s->gb, 8);\n\n    if (nb_components == 0 || nb_components > MAX_COMPONENTS) {\n\n        av_log(s->avctx, AV_LOG_ERROR,\n\n               \"decode_sos: nb_components (%d) unsupported\\n\", nb_components);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    if (len != 6 + 2 * nb_components) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: invalid len (%d)\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    for (i = 0; i < nb_components; i++) {\n\n        id = get_bits(&s->gb, 8) - 1;\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"component: %d\\n\", id);\n\n        /* find component index */\n\n        for (index = 0; index < s->nb_components; index++)\n\n            if (id == s->component_id[index])\n\n                break;\n\n        if (index == s->nb_components) {\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"decode_sos: index(%d) out of components\\n\", index);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        /* Metasoft MJPEG codec has Cb and Cr swapped */\n\n        if (s->avctx->codec_tag == MKTAG('M', 'T', 'S', 'J')\n\n            && nb_components == 3 && s->nb_components == 3 && i)\n\n            index = 3 - i;\n\n\n\n        s->quant_sindex[i] = s->quant_index[index];\n\n        s->nb_blocks[i] = s->h_count[index] * s->v_count[index];\n\n        s->h_scount[i]  = s->h_count[index];\n\n        s->v_scount[i]  = s->v_count[index];\n\n\n\n        if(nb_components == 3 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)\n\n            index = (i+2)%3;\n\n        if(nb_components == 1 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)\n\n            index = (index+2)%3;\n\n\n\n        s->comp_index[i] = index;\n\n\n\n        s->dc_index[i] = get_bits(&s->gb, 4);\n\n        s->ac_index[i] = get_bits(&s->gb, 4);\n\n\n\n        if (s->dc_index[i] <  0 || s->ac_index[i] < 0 ||\n\n            s->dc_index[i] >= 4 || s->ac_index[i] >= 4)\n\n            goto out_of_range;\n\n        if (!s->vlcs[0][s->dc_index[i]].table || !(s->progressive ? s->vlcs[2][s->ac_index[0]].table : s->vlcs[1][s->ac_index[i]].table))\n\n            goto out_of_range;\n\n    }\n\n\n\n    predictor = get_bits(&s->gb, 8);       /* JPEG Ss / lossless JPEG predictor /JPEG-LS NEAR */\n\n    ilv = get_bits(&s->gb, 8);             /* JPEG Se / JPEG-LS ILV */\n\n    if(s->avctx->codec_tag != AV_RL32(\"CJPG\")){\n\n        prev_shift      = get_bits(&s->gb, 4); /* Ah */\n\n        point_transform = get_bits(&s->gb, 4); /* Al */\n\n    }else\n\n        prev_shift = point_transform = 0;\n\n\n\n    if (nb_components > 1) {\n\n        /* interleaved stream */\n\n        s->mb_width  = (s->width  + s->h_max * block_size - 1) / (s->h_max * block_size);\n\n        s->mb_height = (s->height + s->v_max * block_size - 1) / (s->v_max * block_size);\n\n    } else if (!s->ls) { /* skip this for JPEG-LS */\n\n        h = s->h_max / s->h_scount[0];\n\n        v = s->v_max / s->v_scount[0];\n\n        s->mb_width     = (s->width  + h * block_size - 1) / (h * block_size);\n\n        s->mb_height    = (s->height + v * block_size - 1) / (v * block_size);\n\n        s->nb_blocks[0] = 1;\n\n        s->h_scount[0]  = 1;\n\n        s->v_scount[0]  = 1;\n\n    }\n\n\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\\n\",\n\n               s->lossless ? \"lossless\" : \"sequential DCT\", s->rgb ? \"RGB\" : \"\",\n\n               predictor, point_transform, ilv, s->bits, s->mjpb_skiptosod,\n\n               s->pegasus_rct ? \"PRCT\" : (s->rct ? \"RCT\" : \"\"), nb_components);\n\n\n\n\n\n    /* mjpeg-b can have padding bytes between sos and image data, skip them */\n\n    for (i = s->mjpb_skiptosod; i > 0; i--)\n\n        skip_bits(&s->gb, 8);\n\n\n\nnext_field:\n\n    for (i = 0; i < nb_components; i++)\n\n        s->last_dc[i] = (4 << s->bits);\n\n\n\n    if (s->lossless) {\n\n        av_assert0(s->picture_ptr == s->picture);\n\n        if (CONFIG_JPEGLS_DECODER && s->ls) {\n\n//            for () {\n\n//            reset_ls_coding_parameters(s, 0);\n\n\n\n            if ((ret = ff_jpegls_decode_picture(s, predictor,\n\n                                                point_transform, ilv)) < 0)\n\n                return ret;\n\n        } else {\n\n            if (s->rgb) {\n\n                if ((ret = ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform)) < 0)\n\n                    return ret;\n\n            } else {\n\n                if ((ret = ljpeg_decode_yuv_scan(s, predictor,\n\n                                                 point_transform,\n\n                                                 nb_components)) < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    } else {\n\n        if (s->progressive && predictor) {\n\n            av_assert0(s->picture_ptr == s->picture);\n\n            if ((ret = mjpeg_decode_scan_progressive_ac(s, predictor,\n\n                                                        ilv, prev_shift,\n\n                                                        point_transform)) < 0)\n\n                return ret;\n\n        } else {\n\n            if ((ret = mjpeg_decode_scan(s, nb_components,\n\n                                         prev_shift, point_transform,\n\n                                         mb_bitmask, reference)) < 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (s->interlaced &&\n\n        get_bits_left(&s->gb) > 32 &&\n\n        show_bits(&s->gb, 8) == 0xFF) {\n\n        GetBitContext bak = s->gb;\n\n        align_get_bits(&bak);\n\n        if (show_bits(&bak, 16) == 0xFFD1) {\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"AVRn interlaced picture marker found\\n\");\n\n            s->gb = bak;\n\n            skip_bits(&s->gb, 16);\n\n            s->bottom_field ^= 1;\n\n\n\n            goto next_field;\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n    return 0;\n\n out_of_range:\n\n    av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: ac/dc index out of range\\n\");\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 362}
{"project": "qemu", "commit_id": "805b5d98c649d26fc44d2d7755a97f18e62b438a", "target": 1, "func": "static void v9fs_renameat(void *opaque)\n{\n    ssize_t err = 0;\n    size_t offset = 7;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t olddirfid, newdirfid;\n    V9fsString old_name, new_name;\n    v9fs_string_init(&old_name);\n    v9fs_string_init(&new_name);\n    err = pdu_unmarshal(pdu, offset, \"dsds\", &olddirfid,\n                        &old_name, &newdirfid, &new_name);\n    if (err < 0) {\n    if (name_is_illegal(old_name.data) || name_is_illegal(new_name.data)) {\n        err = -ENOENT;\n    v9fs_path_write_lock(s);\n    err = v9fs_complete_renameat(pdu, olddirfid,\n                                 &old_name, newdirfid, &new_name);\n    v9fs_path_unlock(s);\n    if (!err) {\n        err = offset;\nout_err:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&old_name);\n    v9fs_string_free(&new_name);", "idx": 363}
{"project": "qemu", "commit_id": "c9a621176e479b8106056ed992fddf34d9d0d206", "target": 1, "func": "if_start(void)\n{\n\tstruct mbuf *ifm, *ifqt;\n\tDEBUG_CALL(\"if_start\");\n\tif (if_queued == 0)\n\t   return; /* Nothing to do */\n again:\n        /* check if we can really output */\n        if (!slirp_can_output())\n            return;\n\t/*\n\t * See which queue to get next packet from\n\t * If there's something in the fastq, select it immediately\n\t */\n\tif (if_fastq.ifq_next != &if_fastq) {\n\t\tifm = if_fastq.ifq_next;\n\t} else {\n\t\t/* Nothing on fastq, see if next_m is valid */\n\t\tif (next_m != &if_batchq)\n\t\t   ifm = next_m;\n\t\telse\n\t\t   ifm = if_batchq.ifq_next;\n\t\t/* Set which packet to send on next iteration */\n\t\tnext_m = ifm->ifq_next;\n\t}\n\t/* Remove it from the queue */\n\tifqt = ifm->ifq_prev;\n\tremque(ifm);\n\t--if_queued;\n\t/* If there are more packets for this session, re-queue them */\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\t\tinsque(ifm->ifs_next, ifqt);\n\t\tifs_remque(ifm);\n\t}\n\t/* Update so_queued */\n\tif (ifm->ifq_so) {\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\t\t   /* If there's no more queued, reset nqueued */\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\t}\n\t/* Encapsulate the packet for sending */\n        if_encap(ifm->m_data, ifm->m_len);\n\tif (if_queued)\n\t   goto again;\n}", "idx": 364}
{"project": "qemu", "commit_id": "14a10fc39923b3af07c8c46d22cb20843bee3a72", "target": 1, "func": "static void mips_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(dev);\n\n    MIPSCPUClass *mcc = MIPS_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n", "idx": 365}
{"project": "FFmpeg", "commit_id": "4733a12dd17a91d606e0079ff9bb48b9f419cbef", "target": 0, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n        if (!(rt->asf_ctx = avformat_alloc_context()))\n\n            return AVERROR(ENOMEM);\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", &ff_asf_demuxer, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0)\n\n            return ret;\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 366}
{"project": "FFmpeg", "commit_id": "f73d6d2af7a2b30a647d945b590962a2ab54ff3b", "target": 0, "func": "static void alloc_picture(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int64_t bufferdiff;\n\n\n\n    vp = &is->pictq[is->pictq_windex];\n\n\n\n    if (vp->bmp)\n\n        SDL_FreeYUVOverlay(vp->bmp);\n\n\n\n    video_open(is, 0, vp);\n\n\n\n    vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height,\n\n                                   SDL_YV12_OVERLAY,\n\n                                   screen);\n\n    bufferdiff = vp->bmp ? FFMAX(vp->bmp->pixels[0], vp->bmp->pixels[1]) - FFMIN(vp->bmp->pixels[0], vp->bmp->pixels[1]) : 0;\n\n    if (!vp->bmp || vp->bmp->pitches[0] < vp->width || bufferdiff < vp->height * vp->bmp->pitches[0]) {\n\n        /* SDL allocates a buffer smaller than requested if the video\n\n         * overlay hardware is unable to support the requested size. */\n\n        av_log(NULL, AV_LOG_FATAL,\n\n               \"Error: the video system does not support an image\\n\"\n\n                        \"size of %dx%d pixels. Try using -lowres or -vf \\\"scale=w:h\\\"\\n\"\n\n                        \"to reduce the image size.\\n\", vp->width, vp->height );\n\n        do_exit(is);\n\n    }\n\n\n\n    SDL_LockMutex(is->pictq_mutex);\n\n    vp->allocated = 1;\n\n    SDL_CondSignal(is->pictq_cond);\n\n    SDL_UnlockMutex(is->pictq_mutex);\n\n}\n", "idx": 367}
{"project": "qemu", "commit_id": "58a83c61496eeb0d31571a07a51bc1947e3379ac", "target": 1, "func": "void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,\n\n                       unsigned int len)\n\n{\n\n    vq->last_avail_idx--;\n\n\n    virtqueue_unmap_sg(vq, elem, len);\n\n}", "idx": 370}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_gic_common_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->reset = arm_gic_common_reset;\n\n    dc->realize = arm_gic_common_realize;\n\n    dc->props = arm_gic_common_properties;\n\n    dc->vmsd = &vmstate_gic;\n\n    dc->no_user = 1;\n\n}\n", "idx": 371}
{"project": "qemu", "commit_id": "b181e04777da67acbc7448f87e4ae9f1518e08b2", "target": 1, "func": "static CharDriverState *qemu_chr_open_tty(QemuOpts *opts)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    TFR(fd = open(filename, O_RDWR | O_NONBLOCK));\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    tty_serial_init(fd, 115200, 'N', 8, 1);\n\n    chr = qemu_chr_open_fd(fd, fd);\n\n    if (!chr) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n    chr->chr_ioctl = tty_serial_ioctl;\n\n    chr->chr_close = qemu_chr_close_tty;\n\n    return chr;\n\n}\n", "idx": 374}
{"project": "qemu", "commit_id": "05601ed2de60df0e344d6b783a6bc0c1ff2b5d1f", "target": 1, "func": "void object_property_set_qobject(Object *obj, QObject *value,\n\n                                 const char *name, Error **errp)\n\n{\n\n    Visitor *v;\n\n    /* TODO: Should we reject, rather than ignore, excess input? */\n\n    v = qobject_input_visitor_new(value, false);\n\n    object_property_set(obj, v, name, errp);\n\n    visit_free(v);\n\n}\n", "idx": 375}
{"project": "FFmpeg", "commit_id": "a6e14edde01bafbbe54f6f451efa718a48975b47", "target": 1, "func": "static int http_receive_data(HTTPContext *c)\n\n{\n\n    int len;\n\n    HTTPContext *c1;\n\n\n\n    if (c->buffer_ptr >= c->buffer_end) {\n\n        FFStream *feed = c->stream;\n\n        /* a packet has been received : write it in the store, except\n\n           if header */\n\n        if (c->data_count > FFM_PACKET_SIZE) {\n\n            \n\n            //            printf(\"writing pos=0x%Lx size=0x%Lx\\n\", feed->feed_write_index, feed->feed_size);\n\n            /* XXX: use llseek or url_seek */\n\n            lseek(c->feed_fd, feed->feed_write_index, SEEK_SET);\n\n            write(c->feed_fd, c->buffer, FFM_PACKET_SIZE);\n\n            \n\n            feed->feed_write_index += FFM_PACKET_SIZE;\n\n            /* update file size */\n\n            if (feed->feed_write_index > c->stream->feed_size)\n\n                feed->feed_size = feed->feed_write_index;\n\n\n\n            /* handle wrap around if max file size reached */\n\n            if (feed->feed_write_index >= c->stream->feed_max_size)\n\n                feed->feed_write_index = FFM_PACKET_SIZE;\n\n\n\n            /* write index */\n\n            ffm_write_write_index(c->feed_fd, feed->feed_write_index);\n\n\n\n            /* wake up any waiting connections */\n\n            for(c1 = first_http_ctx; c1 != NULL; c1 = c1->next) {\n\n                if (c1->state == HTTPSTATE_WAIT_FEED && \n\n                    c1->stream->feed == c->stream->feed) {\n\n                    c1->state = HTTPSTATE_SEND_DATA;\n\n                }\n\n            }\n\n        } else {\n\n            /* We have a header in our hands that contains useful data */\n\n            AVFormatContext s;\n\n            ByteIOContext *pb = &s.pb;\n\n            int i;\n\n\n\n            memset(&s, 0, sizeof(s));\n\n\n\n            url_open_buf(pb, c->buffer, c->buffer_end - c->buffer, URL_RDONLY);\n\n            pb->buf_end = c->buffer_end;        /* ?? */\n\n            pb->is_streamed = 1;\n\n\n\n            if (feed->fmt->read_header(&s, 0) < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* Now we have the actual streams */\n\n            if (s.nb_streams != feed->nb_streams) {\n\n                goto fail;\n\n            }\n\n            for (i = 0; i < s.nb_streams; i++) {\n\n                memcpy(&feed->streams[i]->codec, &s.streams[i]->codec, sizeof(AVCodecContext));\n\n            } \n\n        }\n\n        c->buffer_ptr = c->buffer;\n\n    }\n\n\n\n    len = read(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr);\n\n    if (len < 0) {\n\n        if (errno != EAGAIN && errno != EINTR) {\n\n            /* error : close connection */\n\n            goto fail;\n\n        }\n\n    } else if (len == 0) {\n\n        /* end of connection : close it */\n\n        goto fail;\n\n    } else {\n\n        c->buffer_ptr += len;\n\n        c->data_count += len;\n\n    }\n\n    return 0;\n\n fail:\n\n    c->stream->feed_opened = 0;\n\n    close(c->feed_fd);\n\n    return -1;\n\n}\n", "idx": 376}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static int stellaris_sys_init(uint32_t base, qemu_irq irq,\n\n                              stellaris_board_info * board,\n\n                              uint8_t *macaddr)\n\n{\n\n    ssys_state *s;\n\n\n\n    s = (ssys_state *)g_malloc0(sizeof(ssys_state));\n\n    s->irq = irq;\n\n    s->board = board;\n\n    /* Most devices come preprogrammed with a MAC address in the user data. */\n\n    s->user0 = macaddr[0] | (macaddr[1] << 8) | (macaddr[2] << 16);\n\n    s->user1 = macaddr[3] | (macaddr[4] << 8) | (macaddr[5] << 16);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &ssys_ops, s, \"ssys\", 0x00001000);\n\n    memory_region_add_subregion(get_system_memory(), base, &s->iomem);\n\n    ssys_reset(s);\n\n    vmstate_register(NULL, -1, &vmstate_stellaris_sys, s);\n\n    return 0;\n\n}\n", "idx": 377}
{"project": "qemu", "commit_id": "11748ba72ea4fc03e975aa5f5d876b5b0902e356", "target": 1, "func": "static int kvm_recommended_vcpus(KVMState *s)\n\n{\n\n    int ret = kvm_check_extension(s, KVM_CAP_NR_VCPUS);\n\n    return (ret) ? ret : 4;\n\n}\n", "idx": 379}
{"project": "qemu", "commit_id": "c3adb5b9168a57790b5074489b6f0275ac3cc8b5", "target": 1, "func": "static void reschedule_dma(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    qemu_bh_delete(dbs->bh);\n\n    dbs->bh = NULL;\n\n    dma_bdrv_cb(opaque, 0);\n\n}\n", "idx": 380}
{"project": "FFmpeg", "commit_id": "e457023a95e449ac2c80a49256f0611d5a8fffff", "target": 1, "func": "static int adpcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            uint8_t *buf, int buf_size)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n    ADPCMChannelStatus *cs;\n\n    int n, m, channel, i;\n\n    int block_predictor[2];\n\n    short *samples;\n\n    short *samples_end;\n\n    uint8_t *src;\n\n    int st; /* stereo */\n\n\n\n    /* DK3 ADPCM accounting variables */\n\n    unsigned char last_byte = 0;\n\n    unsigned char nibble;\n\n    int decode_top_nibble_next = 0;\n\n    int diff_channel;\n\n\n\n    /* EA ADPCM state variables */\n\n    uint32_t samples_in_chunk;\n\n    int32_t previous_left_sample, previous_right_sample;\n\n    int32_t current_left_sample, current_right_sample;\n\n    int32_t next_left_sample, next_right_sample;\n\n    int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n\n    uint8_t shift_left, shift_right;\n\n    int count1, count2;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    //should protect all 4bit ADPCM variants\n\n    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels\n\n    //\n\n    if(*data_size/4 < buf_size + 8)\n\n        return -1;\n\n\n\n    samples = data;\n\n    samples_end= samples + *data_size/2;\n\n    *data_size= 0;\n\n    src = buf;\n\n\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_IMA_QT:\n\n        n = (buf_size - 2);/* >> 2*avctx->channels;*/\n\n        channel = c->channel;\n\n        cs = &(c->status[channel]);\n\n        /* (pppppp) (piiiiiii) */\n\n\n\n        /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n\n        cs->predictor = (*src++) << 8;\n\n        cs->predictor |= (*src & 0x80);\n\n        cs->predictor &= 0xFF80;\n\n\n\n        /* sign extension */\n\n        if(cs->predictor & 0x8000)\n\n            cs->predictor -= 0x10000;\n\n\n\n        CLAMP_TO_SHORT(cs->predictor);\n\n\n\n        cs->step_index = (*src++) & 0x7F;\n\n\n\n        if (cs->step_index > 88){\n\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n            cs->step_index = 88;\n\n        }\n\n\n\n        cs->step = step_table[cs->step_index];\n\n\n\n        if (st && channel)\n\n            samples++;\n\n\n\n        for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */\n\n            *samples = adpcm_ima_expand_nibble(cs, src[0] & 0x0F, 3);\n\n            samples += avctx->channels;\n\n            *samples = adpcm_ima_expand_nibble(cs, (src[0] >> 4) & 0x0F, 3);\n\n            samples += avctx->channels;\n\n            src ++;\n\n        }\n\n\n\n        if(st) { /* handle stereo interlacing */\n\n            c->channel = (channel + 1) % 2; /* we get one packet for left, then one for right data */\n\n            if(channel == 1) { /* wait for the other packet before outputing anything */\n\n                return src - buf;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WAV:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;\n\n\n\n        for(i=0; i<avctx->channels; i++){\n\n            cs = &(c->status[i]);\n\n            cs->predictor = (int16_t)(src[0] + (src[1]<<8));\n\n            src+=2;\n\n\n\n        // XXX: is this correct ??: *samples++ = cs->predictor;\n\n\n\n            cs->step_index = *src++;\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n\n        }\n\n\n\n        while(src < buf + buf_size){\n\n            for(m=0; m<4; m++){\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);\n\n                src++;\n\n            }\n\n            src += 4*st;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_4XM:\n\n        cs = &(c->status[0]);\n\n        c->status[0].predictor= (int16_t)(src[0] + (src[1]<<8)); src+=2;\n\n        if(st){\n\n            c->status[1].predictor= (int16_t)(src[0] + (src[1]<<8)); src+=2;\n\n        }\n\n        c->status[0].step_index= (int16_t)(src[0] + (src[1]<<8)); src+=2;\n\n        if(st){\n\n            c->status[1].step_index= (int16_t)(src[0] + (src[1]<<8)); src+=2;\n\n        }\n\n        if (cs->step_index < 0) cs->step_index = 0;\n\n        if (cs->step_index > 88) cs->step_index = 88;\n\n\n\n        m= (buf_size - (src - buf))>>st;\n\n        for(i=0; i<m; i++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);\n\n        }\n\n\n\n        src += m<<st;\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_MS:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n        n = buf_size - 7 * avctx->channels;\n\n        if (n < 0)\n\n            return -1;\n\n        block_predictor[0] = av_clip(*src++, 0, 7);\n\n        block_predictor[1] = 0;\n\n        if (st)\n\n            block_predictor[1] = av_clip(*src++, 0, 7);\n\n        c->status[0].idelta = (int16_t)((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n        src+=2;\n\n        if (st){\n\n            c->status[1].idelta = (int16_t)((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n            src+=2;\n\n        }\n\n        c->status[0].coeff1 = AdaptCoeff1[block_predictor[0]];\n\n        c->status[0].coeff2 = AdaptCoeff2[block_predictor[0]];\n\n        c->status[1].coeff1 = AdaptCoeff1[block_predictor[1]];\n\n        c->status[1].coeff2 = AdaptCoeff2[block_predictor[1]];\n\n\n\n        c->status[0].sample1 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n        src+=2;\n\n        if (st) c->status[1].sample1 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n        if (st) src+=2;\n\n        c->status[0].sample2 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n        src+=2;\n\n        if (st) c->status[1].sample2 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));\n\n        if (st) src+=2;\n\n\n\n        *samples++ = c->status[0].sample1;\n\n        if (st) *samples++ = c->status[1].sample1;\n\n        *samples++ = c->status[0].sample2;\n\n        if (st) *samples++ = c->status[1].sample2;\n\n        for(;n>0;n--) {\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0], (src[0] >> 4) & 0x0F);\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n\n            src ++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK4:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        c->status[0].predictor = (int16_t)(src[0] | (src[1] << 8));\n\n        c->status[0].step_index = src[2];\n\n        src += 4;\n\n        *samples++ = c->status[0].predictor;\n\n        if (st) {\n\n            c->status[1].predictor = (int16_t)(src[0] | (src[1] << 8));\n\n            c->status[1].step_index = src[2];\n\n            src += 4;\n\n            *samples++ = c->status[1].predictor;\n\n        }\n\n        while (src < buf + buf_size) {\n\n\n\n            /* take care of the top nibble (always left or mono channel) */\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                (src[0] >> 4) & 0x0F, 3);\n\n\n\n            /* take care of the bottom nibble, which is right sample for\n\n             * stereo, or another mono sample */\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1],\n\n                    src[0] & 0x0F, 3);\n\n            else\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                    src[0] & 0x0F, 3);\n\n\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK3:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        if(buf_size + 16 > (samples_end - samples)*3/8)\n\n            return -1;\n\n\n\n        c->status[0].predictor = (int16_t)(src[10] | (src[11] << 8));\n\n        c->status[1].predictor = (int16_t)(src[12] | (src[13] << 8));\n\n        c->status[0].step_index = src[14];\n\n        c->status[1].step_index = src[15];\n\n        /* sign extend the predictors */\n\n        src += 16;\n\n        diff_channel = c->status[1].predictor;\n\n\n\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n\n         * the buffer is consumed */\n\n        while (1) {\n\n\n\n            /* for this algorithm, c->status[0] is the sum channel and\n\n             * c->status[1] is the diff channel */\n\n\n\n            /* process the first predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the diff channel predictor */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n\n\n            /* process the first pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n\n\n            /* process the second predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the second pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        /* no per-block initialization; just start decoding the data */\n\n        while (src < buf + buf_size) {\n\n\n\n            if (st) {\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                    (src[0] >> 4) & 0x0F, 3);\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1],\n\n                    src[0] & 0x0F, 3);\n\n            } else {\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                    (src[0] >> 4) & 0x0F, 3);\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                    src[0] & 0x0F, 3);\n\n            }\n\n\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_XA:\n\n        c->status[0].sample1 = c->status[0].sample2 =\n\n        c->status[1].sample1 = c->status[1].sample2 = 0;\n\n        while (buf_size >= 128) {\n\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n\n                avctx->channels);\n\n            src += 128;\n\n            samples += 28 * 8;\n\n            buf_size -= 128;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA:\n\n        samples_in_chunk = AV_RL32(src);\n\n        if (samples_in_chunk >= ((buf_size - 12) * 2)) {\n\n            src += buf_size;\n\n            break;\n\n        }\n\n        src += 4;\n\n        current_left_sample = (int16_t)AV_RL16(src);\n\n        src += 2;\n\n        previous_left_sample = (int16_t)AV_RL16(src);\n\n        src += 2;\n\n        current_right_sample = (int16_t)AV_RL16(src);\n\n        src += 2;\n\n        previous_right_sample = (int16_t)AV_RL16(src);\n\n        src += 2;\n\n\n\n        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {\n\n            coeff1l = ea_adpcm_table[(*src >> 4) & 0x0F];\n\n            coeff2l = ea_adpcm_table[((*src >> 4) & 0x0F) + 4];\n\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n\n            src++;\n\n\n\n            shift_left = ((*src >> 4) & 0x0F) + 8;\n\n            shift_right = (*src & 0x0F) + 8;\n\n            src++;\n\n\n\n            for (count2 = 0; count2 < 28; count2++) {\n\n                next_left_sample = (((*src & 0xF0) << 24) >> shift_left);\n\n                next_right_sample = (((*src & 0x0F) << 28) >> shift_right);\n\n                src++;\n\n\n\n                next_left_sample = (next_left_sample +\n\n                    (current_left_sample * coeff1l) +\n\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n\n                next_right_sample = (next_right_sample +\n\n                    (current_right_sample * coeff1r) +\n\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n                CLAMP_TO_SHORT(next_left_sample);\n\n                CLAMP_TO_SHORT(next_right_sample);\n\n\n\n                previous_left_sample = current_left_sample;\n\n                current_left_sample = next_left_sample;\n\n                previous_right_sample = current_right_sample;\n\n                current_right_sample = next_right_sample;\n\n                *samples++ = (unsigned short)current_left_sample;\n\n                *samples++ = (unsigned short)current_right_sample;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n        c->status[0].predictor = *src;\n\n        src += 2;\n\n        c->status[0].step_index = *src++;\n\n        src++;  /* skip another byte before getting to the meat */\n\n        while (src < buf + buf_size) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                *src & 0x0F, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                (*src >> 4) & 0x0F, 3);\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_CT:\n\n        while (src < buf + buf_size) {\n\n            if (st) {\n\n                *samples++ = adpcm_ct_expand_nibble(&c->status[0],\n\n                    (src[0] >> 4) & 0x0F);\n\n                *samples++ = adpcm_ct_expand_nibble(&c->status[1],\n\n                    src[0] & 0x0F);\n\n            } else {\n\n                *samples++ = adpcm_ct_expand_nibble(&c->status[0],\n\n                    (src[0] >> 4) & 0x0F);\n\n                *samples++ = adpcm_ct_expand_nibble(&c->status[0],\n\n                    src[0] & 0x0F);\n\n            }\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SBPRO_4:\n\n    case CODEC_ID_ADPCM_SBPRO_3:\n\n    case CODEC_ID_ADPCM_SBPRO_2:\n\n        if (!c->status[0].step_index) {\n\n            /* the first byte is a raw sample */\n\n            *samples++ = 128 * (*src++ - 0x80);\n\n            if (st)\n\n              *samples++ = 128 * (*src++ - 0x80);\n\n            c->status[0].step_index = 1;\n\n        }\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n\n            while (src < buf + buf_size) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 4) & 0x0F, 4, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x0F, 4, 0);\n\n                src++;\n\n            }\n\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n\n            while (src < buf + buf_size && samples + 2 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 5) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] & 0x03, 2, 0);\n\n                src++;\n\n            }\n\n        } else {\n\n            while (src < buf + buf_size && samples + 3 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 6) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    (src[0] >> 4) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x03, 2, 2);\n\n                src++;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SWF:\n\n    {\n\n        GetBitContext gb;\n\n        const int *table;\n\n        int k0, signmask, nb_bits;\n\n        int size = buf_size*8;\n\n\n\n        init_get_bits(&gb, buf, size);\n\n\n\n        //read bits & inital values\n\n        nb_bits = get_bits(&gb, 2)+2;\n\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n\n        table = swf_index_tables[nb_bits-2];\n\n        k0 = 1 << (nb_bits-2);\n\n        signmask = 1 << (nb_bits-1);\n\n\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n\n            c->status[i].step_index = get_bits(&gb, 6);\n\n        }\n\n\n\n        while (get_bits_count(&gb) < size)\n\n        {\n\n            int i;\n\n\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                // similar to IMA adpcm\n\n                int delta = get_bits(&gb, nb_bits);\n\n                int step = step_table[c->status[i].step_index];\n\n                long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n\n                int k = k0;\n\n\n\n                do {\n\n                    if (delta & k)\n\n                        vpdiff += step;\n\n                    step >>= 1;\n\n                    k >>= 1;\n\n                } while(k);\n\n                vpdiff += step;\n\n\n\n                if (delta & signmask)\n\n                    c->status[i].predictor -= vpdiff;\n\n                else\n\n                    c->status[i].predictor += vpdiff;\n\n\n\n                c->status[i].step_index += table[delta & (~signmask)];\n\n\n\n                c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n\n                c->status[i].predictor = av_clip(c->status[i].predictor, -32768, 32767);\n\n\n\n                *samples++ = c->status[i].predictor;\n\n                if (samples >= samples_end) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n        }\n\n        src += buf_size;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_YAMAHA:\n\n        while (src < buf + buf_size) {\n\n            if (st) {\n\n                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],\n\n                        src[0] & 0x0F);\n\n                *samples++ = adpcm_yamaha_expand_nibble(&c->status[1],\n\n                        (src[0] >> 4) & 0x0F);\n\n            } else {\n\n                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],\n\n                        src[0] & 0x0F);\n\n                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],\n\n                        (src[0] >> 4) & 0x0F);\n\n            }\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_THP:\n\n    {\n\n        int table[2][16];\n\n        unsigned int samplecnt;\n\n        int prev[2][2];\n\n        int ch;\n\n\n\n        if (buf_size < 80) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        src+=4;\n\n        samplecnt = bytestream_get_be32(&src);\n\n\n\n        for (i = 0; i < 32; i++)\n\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    *samples = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 381}
{"project": "qemu", "commit_id": "fb0c43f34eed8b18678c6e1f481d8564b35c99ed", "target": 1, "func": "static coroutine_fn void test_multi_co_schedule_entry(void *opaque)\n\n{\n\n    g_assert(to_schedule[id] == NULL);\n\n    atomic_mb_set(&to_schedule[id], qemu_coroutine_self());\n\n\n\n    while (!atomic_mb_read(&now_stopping)) {\n\n        int n;\n\n\n\n        n = g_test_rand_int_range(0, NUM_CONTEXTS);\n\n        schedule_next(n);\n\n        qemu_coroutine_yield();\n\n\n\n        g_assert(to_schedule[id] == NULL);\n\n        atomic_mb_set(&to_schedule[id], qemu_coroutine_self());\n\n    }\n\n}\n", "idx": 382}
{"project": "qemu", "commit_id": "d66e5cee002c471b78139228a4e7012736b375f9", "target": 1, "func": "static int qcow_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, shift, ret;\n\n    QCowHeader header;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be32_to_cpus(&header.mtime);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        error_setg(errp, \"Image not in qcow format\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version != QCOW_VERSION) {\n\n        char version[64];\n\n        snprintf(version, sizeof(version), \"QCOW version %\" PRIu32,\n\n                 header.version);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                  bs->device_name, \"qcow\", version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.size <= 1) {\n\n        error_setg(errp, \"Image size is too small (must be at least 2 bytes)\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.cluster_bits < 9 || header.cluster_bits > 16) {\n\n        error_setg(errp, \"Cluster size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* l2_bits specifies number of entries; storing a uint64_t in each entry,\n\n     * so bytes = num_entries << 3. */\n\n    if (header.l2_bits < 9 - 3 || header.l2_bits > 16 - 3) {\n\n        error_setg(errp, \"L2 table size must be between 512 and 64k\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        error_setg(errp, \"invalid encryption method in qcow header\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = header.l2_bits;\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size / 512;\n\n    s->cluster_offset_mask = (1LL << (63 - s->cluster_bits)) - 1;\n\n\n\n    /* read the level 1 table */\n\n    shift = s->cluster_bits + s->l2_bits;\n\n    if (header.size > UINT64_MAX - (1LL << shift)) {\n\n        error_setg(errp, \"Image too large\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else {\n\n        uint64_t l1_size = (header.size + (1LL << shift) - 1) >> shift;\n\n        if (l1_size > INT_MAX / sizeof(uint64_t)) {\n\n            error_setg(errp, \"Image too large\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        s->l1_size = l1_size;\n\n    }\n\n\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    s->l1_table = g_malloc(s->l1_size * sizeof(uint64_t));\n\n\n\n    ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n               s->l1_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for(i = 0;i < s->l1_size; i++) {\n\n        be64_to_cpus(&s->l1_table[i]);\n\n    }\n\n    /* alloc L2 cache */\n\n    s->l2_cache = g_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    s->cluster_data = g_malloc(s->cluster_size);\n\n    s->cluster_cache_offset = -1;\n\n\n\n    /* read the backing file name */\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                   bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    /* Disable migration when qcow images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"qcow\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\n fail:\n\n    g_free(s->l1_table);\n\n    g_free(s->l2_cache);\n\n    g_free(s->cluster_cache);\n\n    g_free(s->cluster_data);\n\n    return ret;\n\n}\n", "idx": 383}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "static AVFilterBufferRef *copy_buffer_ref(AVFilterContext *ctx,\n\n                                          AVFilterBufferRef *ref)\n\n{\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *buf;\n\n    int channels, data_size, i;\n\n\n\n    switch (outlink->type) {\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        buf = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                        ref->video->w, ref->video->h);\n\n\n\n        av_image_copy(buf->data, buf->linesize,\n\n                      (void*)ref->data, ref->linesize,\n\n                      ref->format, ref->video->w, ref->video->h);\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        buf = ff_get_audio_buffer(outlink, AV_PERM_WRITE,\n\n                                        ref->audio->nb_samples);\n\n\n\n        channels = av_get_channel_layout_nb_channels(ref->audio->channel_layout);\n\n        av_samples_copy(buf->extended_data, ref->buf->extended_data,\n\n                        0, 0, ref->audio->nb_samples,\n\n                        channels,\n\n                        ref->format);\n\n        break;\n\n\n\n    default:\n\n\n    }\n\n    avfilter_copy_buffer_ref_props(buf, ref);\n\n    return buf;\n\n}", "idx": 384}
{"project": "qemu", "commit_id": "d5208c45be38ab858db6ec5a5097aa1c1a8ebbc9", "target": 1, "func": "void qmp_block_commit(const char *device,\n\n                      bool has_base, const char *base, const char *top,\n\n                      bool has_speed, int64_t speed,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs, *top_bs;\n\n    Error *local_err = NULL;\n\n    /* This will be part of the QMP command, if/when the\n\n     * BlockdevOnError change for blkmirror makes it in\n\n     */\n\n    BlockdevOnError on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n\n\n    /* drain all i/o before commits */\n\n    bdrv_drain_all();\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n    if (base && has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n    } else {\n\n        base_bs = bdrv_find_base(bs);\n\n    }\n\n\n\n    if (base_bs == NULL) {\n\n        error_set(errp, QERR_BASE_NOT_FOUND, base ? base : \"NULL\");\n\n        return;\n\n    }\n\n\n\n    /* default top_bs is the active layer */\n\n    top_bs = bs;\n\n\n\n    if (top) {\n\n        if (strcmp(bs->filename, top) != 0) {\n\n            top_bs = bdrv_find_backing_image(bs, top);\n\n        }\n\n    }\n\n\n\n    if (top_bs == NULL) {\n\n        error_setg(errp, \"Top image file %s not found\", top ? top : \"NULL\");\n\n        return;\n\n    }\n\n\n\n    commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,\n\n                &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n}\n", "idx": 385}
{"project": "FFmpeg", "commit_id": "843e72ea5542845a0a9fed743517c14a92279885", "target": 0, "func": "static int mkv_check_tag(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)))\n\n        if (av_strcasecmp(t->key, \"title\") && av_strcasecmp(t->key, \"stereo_mode\"))\n\n            return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 386}
{"project": "FFmpeg", "commit_id": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b", "target": 0, "func": "int ff_h2645_extract_rbsp(const uint8_t *src, int length,\n\n                          H2645NAL *nal)\n\n{\n\n    int i, si, di;\n\n    uint8_t *dst;\n\n\n\n    nal->skipped_bytes = 0;\n\n#define STARTCODE_TEST                                                  \\\n\n        if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \\\n\n            if (src[i + 2] != 3 && src[i + 2] != 0) {                   \\\n\n                /* startcode, so we must be past the end */             \\\n\n                length = i;                                             \\\n\n            }                                                           \\\n\n            break;                                                      \\\n\n        }\n\n#if HAVE_FAST_UNALIGNED\n\n#define FIND_FIRST_ZERO                                                 \\\n\n        if (i > 0 && !src[i])                                           \\\n\n            i--;                                                        \\\n\n        while (src[i])                                                  \\\n\n            i++\n\n#if HAVE_FAST_64BIT\n\n    for (i = 0; i + 1 < length; i += 9) {\n\n        if (!((~AV_RN64A(src + i) &\n\n               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &\n\n              0x8000800080008080ULL))\n\n            continue;\n\n        FIND_FIRST_ZERO;\n\n        STARTCODE_TEST;\n\n        i -= 7;\n\n    }\n\n#else\n\n    for (i = 0; i + 1 < length; i += 5) {\n\n        if (!((~AV_RN32A(src + i) &\n\n               (AV_RN32A(src + i) - 0x01000101U)) &\n\n              0x80008080U))\n\n            continue;\n\n        FIND_FIRST_ZERO;\n\n        STARTCODE_TEST;\n\n        i -= 3;\n\n    }\n\n#endif /* HAVE_FAST_64BIT */\n\n#else\n\n    for (i = 0; i + 1 < length; i += 2) {\n\n        if (src[i])\n\n            continue;\n\n        if (i > 0 && src[i - 1] == 0)\n\n            i--;\n\n        STARTCODE_TEST;\n\n    }\n\n#endif /* HAVE_FAST_UNALIGNED */\n\n\n\n    if (i >= length - 1) { // no escaped 0\n\n        nal->data     =\n\n        nal->raw_data = src;\n\n        nal->size     =\n\n        nal->raw_size = length;\n\n        return length;\n\n    }\n\n\n\n    av_fast_malloc(&nal->rbsp_buffer, &nal->rbsp_buffer_size,\n\n                   length + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!nal->rbsp_buffer)\n\n        return AVERROR(ENOMEM);\n\n\n\n    dst = nal->rbsp_buffer;\n\n\n\n    memcpy(dst, src, i);\n\n    si = di = i;\n\n    while (si + 2 < length) {\n\n        // remove escapes (very rare 1:2^22)\n\n        if (src[si + 2] > 3) {\n\n            dst[di++] = src[si++];\n\n            dst[di++] = src[si++];\n\n        } else if (src[si] == 0 && src[si + 1] == 0 && src[si + 2] != 0) {\n\n            if (src[si + 2] == 3) { // escape\n\n                dst[di++] = 0;\n\n                dst[di++] = 0;\n\n                si       += 3;\n\n\n\n                if (nal->skipped_bytes_pos) {\n\n                    nal->skipped_bytes++;\n\n                    if (nal->skipped_bytes_pos_size < nal->skipped_bytes) {\n\n                        nal->skipped_bytes_pos_size *= 2;\n\n                        av_assert0(nal->skipped_bytes_pos_size >= nal->skipped_bytes);\n\n                        av_reallocp_array(&nal->skipped_bytes_pos,\n\n                                nal->skipped_bytes_pos_size,\n\n                                sizeof(*nal->skipped_bytes_pos));\n\n                        if (!nal->skipped_bytes_pos) {\n\n                            nal->skipped_bytes_pos_size = 0;\n\n                            return AVERROR(ENOMEM);\n\n                        }\n\n                    }\n\n                    if (nal->skipped_bytes_pos)\n\n                        nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;\n\n                }\n\n                continue;\n\n            } else // next start code\n\n                goto nsc;\n\n        }\n\n\n\n        dst[di++] = src[si++];\n\n    }\n\n    while (si < length)\n\n        dst[di++] = src[si++];\n\n\n\nnsc:\n\n    memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    nal->data = dst;\n\n    nal->size = di;\n\n    nal->raw_data = src;\n\n    nal->raw_size = si;\n\n    return si;\n\n}\n", "idx": 387}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int encode_mode(CinepakEncContext *s, CinepakMode mode, int h, int v1_size, int v4_size, int v4, AVPicture *scratch_pict, strip_info *info, unsigned char *buf)\n\n{\n\n    int x, y, z, flags, bits, temp_size, header_ofs, ret = 0, mb_count = s->w * h / MB_AREA;\n\n    int needs_extra_bit, should_write_temp;\n\n    unsigned char temp[64]; //32/2 = 16 V4 blocks at 4 B each -> 64 B\n\n    mb_info *mb;\n\n    AVPicture sub_scratch;\n\n\n\n    //encode codebooks\n\n    if(v1_size)\n\n        ret += encode_codebook(s, info->v1_codebook, v1_size, 0x22, 0x26, buf + ret);\n\n\n\n    if(v4_size)\n\n        ret += encode_codebook(s, info->v4_codebook, v4_size, 0x20, 0x24, buf + ret);\n\n\n\n    //update scratch picture\n\n    for(z = y = 0; y < h; y += MB_SIZE) {\n\n        for(x = 0; x < s->w; x += MB_SIZE, z++) {\n\n            mb = &s->mb[z];\n\n\n\n            if(mode == MODE_MC && mb->best_encoding == ENC_SKIP)\n\n                continue;\n\n\n\n            get_sub_picture(s, x, y, scratch_pict, &sub_scratch);\n\n\n\n            if(mode == MODE_V1_ONLY || mb->best_encoding == ENC_V1)\n\n                decode_v1_vector(s, &sub_scratch, mb, info);\n\n            else if(mode != MODE_V1_ONLY && mb->best_encoding == ENC_V4)\n\n                decode_v4_vector(s, &sub_scratch, mb->v4_vector[v4], info);\n\n        }\n\n    }\n\n\n\n    switch(mode) {\n\n    case MODE_V1_ONLY:\n\n        //av_log(s->avctx, AV_LOG_INFO, \"mb_count = %i\\n\", mb_count);\n\n        ret += write_chunk_header(buf + ret, 0x32, mb_count);\n\n\n\n        for(x = 0; x < mb_count; x++)\n\n            buf[ret++] = s->mb[x].v1_vector;\n\n\n\n        break;\n\n    case MODE_V1_V4:\n\n        //remember header position\n\n        header_ofs = ret;\n\n        ret += CHUNK_HEADER_SIZE;\n\n\n\n        for(x = 0; x < mb_count; x += 32) {\n\n            flags = 0;\n\n            for(y = x; y < FFMIN(x+32, mb_count); y++)\n\n                if(s->mb[y].best_encoding == ENC_V4)\n\n                    flags |= 1 << (31 - y + x);\n\n\n\n            AV_WB32(&buf[ret], flags);\n\n            ret += 4;\n\n\n\n            for(y = x; y < FFMIN(x+32, mb_count); y++) {\n\n                mb = &s->mb[y];\n\n\n\n                if(mb->best_encoding == ENC_V1)\n\n                    buf[ret++] = mb->v1_vector;\n\n                else\n\n                    for(z = 0; z < 4; z++)\n\n                        buf[ret++] = mb->v4_vector[v4][z];\n\n            }\n\n        }\n\n\n\n        write_chunk_header(buf + header_ofs, 0x30, ret - header_ofs - CHUNK_HEADER_SIZE);\n\n\n\n        break;\n\n    case MODE_MC:\n\n        //remember header position\n\n        header_ofs = ret;\n\n        ret += CHUNK_HEADER_SIZE;\n\n        flags = bits = temp_size = 0;\n\n\n\n        for(x = 0; x < mb_count; x++) {\n\n            mb = &s->mb[x];\n\n            flags |= (mb->best_encoding != ENC_SKIP) << (31 - bits++);\n\n            needs_extra_bit = 0;\n\n            should_write_temp = 0;\n\n\n\n            if(mb->best_encoding != ENC_SKIP) {\n\n                if(bits < 32)\n\n                    flags |= (mb->best_encoding == ENC_V4) << (31 - bits++);\n\n                else\n\n                    needs_extra_bit = 1;\n\n            }\n\n\n\n            if(bits == 32) {\n\n                AV_WB32(&buf[ret], flags);\n\n                ret += 4;\n\n                flags = bits = 0;\n\n\n\n                if(mb->best_encoding == ENC_SKIP || needs_extra_bit) {\n\n                    memcpy(&buf[ret], temp, temp_size);\n\n                    ret += temp_size;\n\n                    temp_size = 0;\n\n                } else\n\n                    should_write_temp = 1;\n\n            }\n\n\n\n            if(needs_extra_bit) {\n\n                flags = (mb->best_encoding == ENC_V4) << 31;\n\n                bits = 1;\n\n            }\n\n\n\n            if(mb->best_encoding == ENC_V1)\n\n                temp[temp_size++] = mb->v1_vector;\n\n            else if(mb->best_encoding == ENC_V4)\n\n                for(z = 0; z < 4; z++)\n\n                    temp[temp_size++] = mb->v4_vector[v4][z];\n\n\n\n            if(should_write_temp) {\n\n                memcpy(&buf[ret], temp, temp_size);\n\n                ret += temp_size;\n\n                temp_size = 0;\n\n            }\n\n        }\n\n\n\n        if(bits > 0) {\n\n            AV_WB32(&buf[ret], flags);\n\n            ret += 4;\n\n            memcpy(&buf[ret], temp, temp_size);\n\n            ret += temp_size;\n\n        }\n\n\n\n        write_chunk_header(buf + header_ofs, 0x31, ret - header_ofs - CHUNK_HEADER_SIZE);\n\n\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 388}
{"project": "FFmpeg", "commit_id": "a443a2530d00b7019269202ac0f5ca8ba0a021c7", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s, AVFormatParameters *ap)\n{\n    ByteIOContext *pb = &s->pb;\n    SmackerContext *smk = (SmackerContext *)s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = get_le32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = get_le32(pb);\n    smk->height = get_le32(pb);\n    smk->frames = get_le32(pb);\n    smk->pts_inc = (int32_t)get_le32(pb);\n    smk->flags = get_le32(pb);\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = get_le32(pb);\n    smk->treesize = get_le32(pb);\n    smk->mmap_size = get_le32(pb);\n    smk->mclr_size = get_le32(pb);\n    smk->full_size = get_le32(pb);\n    smk->type_size = get_le32(pb);\n    for(i = 0; i < 7; i++)\n        smk->rates[i] = get_le32(pb);\n    smk->pad = get_le32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %i\\n\", smk->frames);\n    smk->frm_size = av_malloc(smk->frames * 4);\n    smk->frm_flags = av_malloc(smk->frames);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = get_le32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = get_byte(pb);\n    /* init video codec */\n    st = av_new_stream(s, 0);\n    if (!st)\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = PIX_FMT_PAL8;\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n    st->codec->codec_id = CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->is_ver4;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    av_set_pts_info(st, 33, smk->pts_inc, tbase);\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if((smk->rates[i] & 0xFFFFFF) && !(smk->rates[i] & SMK_AUD_BINKAUD)){\n            ast[i] = av_new_stream(s, 0);\n            smk->indexes[i] = ast[i]->index;\n            av_set_pts_info(ast[i], 33, smk->pts_inc, tbase);\n            ast[i]->codec->codec_type = CODEC_TYPE_AUDIO;\n            ast[i]->codec->codec_id = (smk->rates[i] & SMK_AUD_PACKED) ? CODEC_ID_SMACKAUDIO : CODEC_ID_PCM_U8;\n            ast[i]->codec->codec_tag = 0;\n            ast[i]->codec->channels = (smk->rates[i] & SMK_AUD_STEREO) ? 2 : 1;\n            ast[i]->codec->sample_rate = smk->rates[i] & 0xFFFFFF;\n            ast[i]->codec->bits_per_sample = (smk->rates[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_sample == 16 && ast[i]->codec->codec_id == CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = CODEC_ID_PCM_S16LE;\n    /* load trees to extradata, they will be unpacked by decoder */\n    st->codec->extradata = av_malloc(smk->treesize + 16);\n    st->codec->extradata_size = smk->treesize + 16;\n    if(!st->codec->extradata){\n        av_log(s, AV_LOG_ERROR, \"Cannot allocate %i bytes of extradata\\n\", smk->treesize + 16);\n        av_free(smk->frm_size);\n        av_free(smk->frm_flags);\n    ret = get_buffer(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_free(smk->frm_size);\n        av_free(smk->frm_flags);\n        return AVERROR_IO;\n    ((int32_t*)st->codec->extradata)[0] = le2me_32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = le2me_32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = le2me_32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = le2me_32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = url_ftell(pb);\n    return 0;", "idx": 389}
{"project": "qemu", "commit_id": "c25a67f0c3d0c86231f9653267a222c4effa706f", "target": 1, "func": "static void pci_edu_realize(PCIDevice *pdev, Error **errp)\n\n{\n\n    EduState *edu = DO_UPCAST(EduState, pdev, pdev);\n\n    uint8_t *pci_conf = pdev->config;\n\n\n\n    timer_init_ms(&edu->dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);\n\n\n\n    qemu_mutex_init(&edu->thr_mutex);\n\n    qemu_cond_init(&edu->thr_cond);\n\n    qemu_thread_create(&edu->thread, \"edu\", edu_fact_thread,\n\n                       edu, QEMU_THREAD_JOINABLE);\n\n\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    if (msi_init(pdev, 0, 1, true, false, errp)) {\n\n        return;\n\n    }\n\n\n\n    memory_region_init_io(&edu->mmio, OBJECT(edu), &edu_mmio_ops, edu,\n\n                    \"edu-mmio\", 1 << 20);\n\n    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &edu->mmio);\n\n}\n", "idx": 392}
{"project": "qemu", "commit_id": "9b79a76cdbb43b0b00aaf6e9421298842fc68841", "target": 1, "func": "uint64_t pc_dimm_get_free_addr(uint64_t address_space_start,\n\n                               uint64_t address_space_size,\n\n                               uint64_t *hint, uint64_t size,\n\n                               Error **errp)\n\n{\n\n    GSList *list = NULL, *item;\n\n    uint64_t new_addr, ret = 0;\n\n    uint64_t address_space_end = address_space_start + address_space_size;\n\n\n\n    assert(address_space_end > address_space_size);\n\n    object_child_foreach(qdev_get_machine(), pc_dimm_built_list, &list);\n\n\n\n    if (hint) {\n\n        new_addr = *hint;\n\n    } else {\n\n        new_addr = address_space_start;\n\n    }\n\n\n\n    /* find address range that will fit new DIMM */\n\n    for (item = list; item; item = g_slist_next(item)) {\n\n        PCDIMMDevice *dimm = item->data;\n\n        uint64_t dimm_size = object_property_get_int(OBJECT(dimm),\n\n                                                     PC_DIMM_SIZE_PROP,\n\n                                                     errp);\n\n        if (errp && *errp) {\n\n            goto out;\n\n        }\n\n\n\n        if (ranges_overlap(dimm->addr, dimm_size, new_addr, size)) {\n\n            if (hint) {\n\n                DeviceState *d = DEVICE(dimm);\n\n                error_setg(errp, \"address range conflicts with '%s'\", d->id);\n\n                goto out;\n\n            }\n\n            new_addr = dimm->addr + dimm_size;\n\n        }\n\n    }\n\n    ret = new_addr;\n\n\n\n    if (new_addr < address_space_start) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] at 0x%\" PRIx64, new_addr, size, address_space_start);\n\n    } else if ((new_addr + size) > address_space_end) {\n\n        error_setg(errp, \"can't add memory [0x%\" PRIx64 \":0x%\" PRIx64\n\n                   \"] beyond 0x%\" PRIx64, new_addr, size, address_space_end);\n\n    }\n\n\n\nout:\n\n    g_slist_free(list);\n\n    return ret;\n\n}\n", "idx": 393}
{"project": "FFmpeg", "commit_id": "ec8a4841f7e81040f9a2757f23e70dff5e6b33a4", "target": 1, "func": "static int wma_decode_block(WMACodecContext *s)\n\n{\n\n    int n, v, a, ch, bsize;\n\n    int coef_nb_bits, total_gain;\n\n    int nb_coefs[MAX_CHANNELS];\n\n    float mdct_norm;\n\n    FFTContext *mdct;\n\n\n\n#ifdef TRACE\n\n    tprintf(s->avctx, \"***decode_block: %d:%d\\n\", s->frame_count - 1, s->block_num);\n\n#endif\n\n\n\n    /* compute current block length */\n\n    if (s->use_variable_block_len) {\n\n        n = av_log2(s->nb_block_sizes - 1) + 1;\n\n\n\n        if (s->reset_block_lengths) {\n\n            s->reset_block_lengths = 0;\n\n            v = get_bits(&s->gb, n);\n\n            if (v >= s->nb_block_sizes){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"prev_block_len_bits %d out of range\\n\", s->frame_len_bits - v);\n\n                return -1;\n\n\n            s->prev_block_len_bits = s->frame_len_bits - v;\n\n            v = get_bits(&s->gb, n);\n\n            if (v >= s->nb_block_sizes){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"block_len_bits %d out of range\\n\", s->frame_len_bits - v);\n\n                return -1;\n\n\n            s->block_len_bits = s->frame_len_bits - v;\n\n        } else {\n\n            /* update block lengths */\n\n            s->prev_block_len_bits = s->block_len_bits;\n\n            s->block_len_bits = s->next_block_len_bits;\n\n\n        v = get_bits(&s->gb, n);\n\n        if (v >= s->nb_block_sizes){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"next_block_len_bits %d out of range\\n\", s->frame_len_bits - v);\n\n            return -1;\n\n\n        s->next_block_len_bits = s->frame_len_bits - v;\n\n    } else {\n\n        /* fixed block len */\n\n        s->next_block_len_bits = s->frame_len_bits;\n\n        s->prev_block_len_bits = s->frame_len_bits;\n\n        s->block_len_bits = s->frame_len_bits;\n\n\n\n\n    if (s->frame_len_bits - s->block_len_bits >= s->nb_block_sizes){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"block_len_bits not initialized to a valid value\\n\");\n\n        return -1;\n\n\n\n\n    /* now check if the block length is coherent with the frame length */\n\n    s->block_len = 1 << s->block_len_bits;\n\n    if ((s->block_pos + s->block_len) > s->frame_len){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"frame_len overflow\\n\");\n\n        return -1;\n\n\n\n\n    if (s->avctx->channels == 2) {\n\n        s->ms_stereo = get_bits1(&s->gb);\n\n\n    v = 0;\n\n    for(ch = 0; ch < s->avctx->channels; ch++) {\n\n        a = get_bits1(&s->gb);\n\n        s->channel_coded[ch] = a;\n\n        v |= a;\n\n\n\n\n    bsize = s->frame_len_bits - s->block_len_bits;\n\n\n\n    /* if no channel coded, no need to go further */\n\n    /* XXX: fix potential framing problems */\n\n    if (!v)\n\n        goto next;\n\n\n\n    /* read total gain and extract corresponding number of bits for\n\n       coef escape coding */\n\n    total_gain = 1;\n\n    for(;;) {\n\n\n\n\n\n        a = get_bits(&s->gb, 7);\n\n        total_gain += a;\n\n        if (a != 127)\n\n            break;\n\n\n\n\n    coef_nb_bits= ff_wma_total_gain_to_bits(total_gain);\n\n\n\n    /* compute number of coefficients */\n\n    n = s->coefs_end[bsize] - s->coefs_start;\n\n    for(ch = 0; ch < s->avctx->channels; ch++)\n\n        nb_coefs[ch] = n;\n\n\n\n    /* complex coding */\n\n    if (s->use_noise_coding) {\n\n\n\n        for(ch = 0; ch < s->avctx->channels; ch++) {\n\n            if (s->channel_coded[ch]) {\n\n                int i, n, a;\n\n                n = s->exponent_high_sizes[bsize];\n\n                for(i=0;i<n;i++) {\n\n                    a = get_bits1(&s->gb);\n\n                    s->high_band_coded[ch][i] = a;\n\n                    /* if noise coding, the coefficients are not transmitted */\n\n                    if (a)\n\n                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];\n\n\n\n\n        for(ch = 0; ch < s->avctx->channels; ch++) {\n\n            if (s->channel_coded[ch]) {\n\n                int i, n, val, code;\n\n\n\n                n = s->exponent_high_sizes[bsize];\n\n                val = (int)0x80000000;\n\n                for(i=0;i<n;i++) {\n\n                    if (s->high_band_coded[ch][i]) {\n\n                        if (val == (int)0x80000000) {\n\n                            val = get_bits(&s->gb, 7) - 19;\n\n                        } else {\n\n                            code = get_vlc2(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);\n\n                            if (code < 0){\n\n                                av_log(s->avctx, AV_LOG_ERROR, \"hgain vlc invalid\\n\");\n\n                                return -1;\n\n\n                            val += code - 18;\n\n\n                        s->high_band_values[ch][i] = val;\n\n\n\n\n\n\n\n\n    /* exponents can be reused in short blocks. */\n\n    if ((s->block_len_bits == s->frame_len_bits) ||\n\n        get_bits1(&s->gb)) {\n\n        for(ch = 0; ch < s->avctx->channels; ch++) {\n\n            if (s->channel_coded[ch]) {\n\n                if (s->use_exp_vlc) {\n\n                    if (decode_exp_vlc(s, ch) < 0)\n\n                        return -1;\n\n                } else {\n\n                    decode_exp_lsp(s, ch);\n\n\n                s->exponents_bsize[ch] = bsize;\n\n\n\n\n\n\n    /* parse spectral coefficients : just RLE encoding */\n\n    for (ch = 0; ch < s->avctx->channels; ch++) {\n\n        if (s->channel_coded[ch]) {\n\n            int tindex;\n\n            WMACoef* ptr = &s->coefs1[ch][0];\n\n\n\n            /* special VLC tables are used for ms stereo because\n\n               there is potentially less energy there */\n\n            tindex = (ch == 1 && s->ms_stereo);\n\n            memset(ptr, 0, s->block_len * sizeof(WMACoef));\n\n            ff_wma_run_level_decode(s->avctx, &s->gb, &s->coef_vlc[tindex],\n\n                  s->level_table[tindex], s->run_table[tindex],\n\n                  0, ptr, 0, nb_coefs[ch],\n\n                  s->block_len, s->frame_len_bits, coef_nb_bits);\n\n\n        if (s->version == 1 && s->avctx->channels >= 2) {\n\n            align_get_bits(&s->gb);\n\n\n\n\n\n    /* normalize */\n\n    {\n\n        int n4 = s->block_len / 2;\n\n        mdct_norm = 1.0 / (float)n4;\n\n        if (s->version == 1) {\n\n            mdct_norm *= sqrt(n4);\n\n\n\n\n\n    /* finally compute the MDCT coefficients */\n\n    for (ch = 0; ch < s->avctx->channels; ch++) {\n\n        if (s->channel_coded[ch]) {\n\n            WMACoef *coefs1;\n\n            float *coefs, *exponents, mult, mult1, noise;\n\n            int i, j, n, n1, last_high_band, esize;\n\n            float exp_power[HIGH_BAND_MAX_SIZE];\n\n\n\n            coefs1 = s->coefs1[ch];\n\n            exponents = s->exponents[ch];\n\n            esize = s->exponents_bsize[ch];\n\n            mult = pow(10, total_gain * 0.05) / s->max_exponent[ch];\n\n            mult *= mdct_norm;\n\n            coefs = s->coefs[ch];\n\n            if (s->use_noise_coding) {\n\n                mult1 = mult;\n\n                /* very low freqs : noise */\n\n                for(i = 0;i < s->coefs_start; i++) {\n\n                    *coefs++ = s->noise_table[s->noise_index] *\n\n                      exponents[i<<bsize>>esize] * mult1;\n\n                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n\n\n\n\n                n1 = s->exponent_high_sizes[bsize];\n\n\n\n                /* compute power of high bands */\n\n                exponents = s->exponents[ch] +\n\n                    (s->high_band_start[bsize]<<bsize>>esize);\n\n                last_high_band = 0; /* avoid warning */\n\n                for(j=0;j<n1;j++) {\n\n                    n = s->exponent_high_bands[s->frame_len_bits -\n\n                                              s->block_len_bits][j];\n\n                    if (s->high_band_coded[ch][j]) {\n\n                        float e2, v;\n\n                        e2 = 0;\n\n                        for(i = 0;i < n; i++) {\n\n                            v = exponents[i<<bsize>>esize];\n\n                            e2 += v * v;\n\n\n                        exp_power[j] = e2 / n;\n\n                        last_high_band = j;\n\n                        tprintf(s->avctx, \"%d: power=%f (%d)\\n\", j, exp_power[j], n);\n\n\n                    exponents += n<<bsize>>esize;\n\n\n\n\n                /* main freqs and high freqs */\n\n                exponents = s->exponents[ch] + (s->coefs_start<<bsize>>esize);\n\n                for(j=-1;j<n1;j++) {\n\n                    if (j < 0) {\n\n                        n = s->high_band_start[bsize] -\n\n                            s->coefs_start;\n\n                    } else {\n\n                        n = s->exponent_high_bands[s->frame_len_bits -\n\n                                                  s->block_len_bits][j];\n\n\n                    if (j >= 0 && s->high_band_coded[ch][j]) {\n\n                        /* use noise with specified power */\n\n                        mult1 = sqrt(exp_power[j] / exp_power[last_high_band]);\n\n                        /* XXX: use a table */\n\n                        mult1 = mult1 * pow(10, s->high_band_values[ch][j] * 0.05);\n\n                        mult1 = mult1 / (s->max_exponent[ch] * s->noise_mult);\n\n                        mult1 *= mdct_norm;\n\n                        for(i = 0;i < n; i++) {\n\n                            noise = s->noise_table[s->noise_index];\n\n                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n\n                            *coefs++ =  noise *\n\n                                exponents[i<<bsize>>esize] * mult1;\n\n\n                        exponents += n<<bsize>>esize;\n\n                    } else {\n\n                        /* coded values + small noise */\n\n                        for(i = 0;i < n; i++) {\n\n                            noise = s->noise_table[s->noise_index];\n\n                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n\n                            *coefs++ = ((*coefs1++) + noise) *\n\n                                exponents[i<<bsize>>esize] * mult;\n\n\n                        exponents += n<<bsize>>esize;\n\n\n\n\n\n                /* very high freqs : noise */\n\n                n = s->block_len - s->coefs_end[bsize];\n\n                mult1 = mult * exponents[((-1<<bsize))>>esize];\n\n                for(i = 0; i < n; i++) {\n\n                    *coefs++ = s->noise_table[s->noise_index] * mult1;\n\n                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n\n\n            } else {\n\n                /* XXX: optimize more */\n\n                for(i = 0;i < s->coefs_start; i++)\n\n                    *coefs++ = 0.0;\n\n                n = nb_coefs[ch];\n\n                for(i = 0;i < n; i++) {\n\n                    *coefs++ = coefs1[i] * exponents[i<<bsize>>esize] * mult;\n\n\n                n = s->block_len - s->coefs_end[bsize];\n\n                for(i = 0;i < n; i++)\n\n                    *coefs++ = 0.0;\n\n\n\n\n\n\n#ifdef TRACE\n\n    for (ch = 0; ch < s->avctx->channels; ch++) {\n\n        if (s->channel_coded[ch]) {\n\n            dump_floats(s, \"exponents\", 3, s->exponents[ch], s->block_len);\n\n            dump_floats(s, \"coefs\", 1, s->coefs[ch], s->block_len);\n\n\n\n#endif\n\n\n\n    if (s->ms_stereo && s->channel_coded[1]) {\n\n        /* nominal case for ms stereo: we do it before mdct */\n\n        /* no need to optimize this case because it should almost\n\n           never happen */\n\n        if (!s->channel_coded[0]) {\n\n            tprintf(s->avctx, \"rare ms-stereo case happened\\n\");\n\n            memset(s->coefs[0], 0, sizeof(float) * s->block_len);\n\n            s->channel_coded[0] = 1;\n\n\n\n\n        s->fdsp.butterflies_float(s->coefs[0], s->coefs[1], s->block_len);\n\n\n\n\nnext:\n\n    mdct = &s->mdct_ctx[bsize];\n\n\n\n    for (ch = 0; ch < s->avctx->channels; ch++) {\n\n        int n4, index;\n\n\n\n        n4 = s->block_len / 2;\n\n        if(s->channel_coded[ch]){\n\n            mdct->imdct_calc(mdct, s->output, s->coefs[ch]);\n\n        }else if(!(s->ms_stereo && ch==1))\n\n            memset(s->output, 0, sizeof(s->output));\n\n\n\n        /* multiply by the window and add in the frame */\n\n        index = (s->frame_len / 2) + s->block_pos - n4;\n\n        wma_window(s, &s->frame_out[ch][index]);\n\n\n\n\n    /* update block number */\n\n    s->block_num++;\n\n    s->block_pos += s->block_len;\n\n    if (s->block_pos >= s->frame_len)\n\n        return 1;\n\n    else\n\n        return 0;\n", "idx": 394}
{"project": "qemu", "commit_id": "e17408283562be359f16a7e12ddfee7509d6fe11", "target": 0, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL))\n\n        prio = 50;\n\n\n\n    fd = open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 397}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    TAILQ_FOREACH(xendev, &xendevs, next) {\n\n\tif (xendev->dom != dom)\n\n\t    continue;\n\n\tif (xendev->dev != dev)\n\n\t    continue;\n\n\tif (strcmp(xendev->type, type) != 0)\n\n\t    continue;\n\n\treturn xendev;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 398}
{"project": "FFmpeg", "commit_id": "f12e206b4737b84afa6071f4b464664a50b0c916", "target": 0, "func": "static void dct_unquantize_mpeg1_mmx(MpegEncContext *s,\n\n                                     DCTELEM *block, int n, int qscale)\n\n{\n\n    int i, level;\n\n    const UINT16 *quant_matrix;\n\n    if (s->mb_intra) {\n\n        if (n < 4) \n\n            block[0] = block[0] * s->y_dc_scale;\n\n        else\n\n            block[0] = block[0] * s->c_dc_scale;\n\n        if (s->out_format == FMT_H263) {\n\n            i = 1;\n\n            goto unquant_even;\n\n        }\n\n        /* XXX: only mpeg1 */\n\n        quant_matrix = s->intra_matrix;\n\n\ti=1;\n\n\t/* Align on 4 elements boundary */\n\n\twhile(i&3)\n\n\t{\n\n            level = block[i];\n\n            if (level) {\n\n                if (level < 0) level = -level;\n\n                    level = (int)(level * qscale * quant_matrix[i]) >> 3;\n\n                    level = (level - 1) | 1;\n\n                if (block[i] < 0) level = -level;\n\n                block[i] = level;\n\n            }\n\n\t    i++;\n\n\t}\n\n\t__asm __volatile(\n\n\t\"movd\t%0, %%mm6\\n\\t\"       /* mm6 = qscale | 0  */\n\n\t\"punpckldq %%mm6, %%mm6\\n\\t\" /* mm6 = qscale | qscale */\n\n\t\"movq\t%2, %%mm4\\n\\t\"\n\n\t\"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\"movq\t%1, %%mm5\\n\\t\"\n\n\t\"packssdw %%mm6, %%mm7\\n\\t\" /* mm7 = qscale | qscale | qscale | qscale */\n\n\t\"pxor\t%%mm6, %%mm6\\n\\t\"\n\n\t::\"g\"(qscale),\"m\"(mm_wone),\"m\"(mm_wabs):\"memory\");\n\n        for(;i<64;i+=4) {\n\n\t\t__asm __volatile(\n\n\t\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\t\"movq\t%%mm7, %%mm1\\n\\t\"\n\n\t\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\t\t\"movq\t%%mm0, %%mm3\\n\\t\"\n\n\t\t\t\"pcmpgtw %%mm6, %%mm2\\n\\t\"\n\n\t\t\t\"pmullw\t%2, %%mm1\\n\\t\"\n\n\t\t\t\"pandn\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\t\"por\t%%mm5, %%mm2\\n\\t\"\n\n\t\t\t\"pmullw\t%%mm2, %%mm0\\n\\t\" /* mm0 = abs(block[i]). */\n\n\n\n\t\t\t\"pcmpeqw %%mm6, %%mm3\\n\\t\"\n\n\t\t\t\"pmullw\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\t\"psraw\t$3, %%mm1\\n\\t\"\n\n\t\t\t\"psubw\t%%mm5, %%mm1\\n\\t\"   /* block[i] --; */\n\n\t\t\t\"pandn\t%%mm4, %%mm3\\n\\t\"  /* fake of pcmpneqw : mm0 != 0 then mm1 = -1 */\n\n\t\t\t\"por\t%%mm5, %%mm1\\n\\t\"   /* block[i] |= 1 */\n\n\t\t\t\"pmullw %%mm2, %%mm1\\n\\t\"   /* change signs again */\n\n\n\n\t\t\t\"pand\t%%mm3, %%mm1\\n\\t\" /* nullify if was zero */\n\n\t\t\t\"movq\t%%mm1, %0\"\n\n\t\t\t:\"=m\"(block[i])\n\n\t\t\t:\"m\"(block[i]), \"m\"(quant_matrix[i])\n\n\t\t\t:\"memory\");\n\n        }\n\n    } else {\n\n        i = 0;\n\n    unquant_even:\n\n        quant_matrix = s->non_intra_matrix;\n\n\t/* Align on 4 elements boundary */\n\n\twhile(i&7)\n\n\t{\n\n\t    level = block[i];\n\n            if (level) {\n\n                if (level < 0) level = -level;\n\n                    level = (((level << 1) + 1) * qscale *\n\n                             ((int) quant_matrix[i])) >> 4;\n\n                    level = (level - 1) | 1;\n\n                if(block[i] < 0) level = -level;\n\n                block[i] = level;\n\n\t    }\n\n\t    i++;\n\n\t}\n\n\n\nasm volatile(\n\n\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\"psrlw $15, %%mm7\t\t\\n\\t\"\n\n\t\t\"movd %2, %%mm6\t\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\"packssdw %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%0, %3), %%mm0\t\t\\n\\t\"\n\n\t\t\"movq 8(%0, %3), %%mm1\t\t\\n\\t\"\n\n\t\t\"movq (%1, %3), %%mm4\t\t\\n\\t\"\n\n\t\t\"movq 8(%1, %3), %%mm5\t\t\\n\\t\"\n\n\t\t\"pmullw %%mm6, %%mm4\t\t\\n\\t\" // q=qscale*quant_matrix[i]\n\n\t\t\"pmullw %%mm6, %%mm5\t\t\\n\\t\" // q=qscale*quant_matrix[i]\n\n\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\"\n\n\t\t\"pxor %%mm3, %%mm3\t\t\\n\\t\"\n\n\t\t\"pcmpgtw %%mm0, %%mm2\t\t\\n\\t\" // block[i] < 0 ? -1 : 0\n\n\t\t\"pcmpgtw %%mm1, %%mm3\t\t\\n\\t\" // block[i] < 0 ? -1 : 0\n\n\t\t\"pxor %%mm2, %%mm0\t\t\\n\\t\"\n\n\t\t\"pxor %%mm3, %%mm1\t\t\\n\\t\"\n\n\t\t\"psubw %%mm2, %%mm0\t\t\\n\\t\" // abs(block[i])\n\n\t\t\"psubw %%mm3, %%mm1\t\t\\n\\t\" // abs(block[i])\n\n\t\t\"paddw %%mm0, %%mm0\t\t\\n\\t\" // abs(block[i])*2\n\n\t\t\"paddw %%mm1, %%mm1\t\t\\n\\t\" // abs(block[i])*2\n\n\t\t\"paddw %%mm7, %%mm0\t\t\\n\\t\" // abs(block[i])*2 + 1\n\n\t\t\"paddw %%mm7, %%mm1\t\t\\n\\t\" // abs(block[i])*2 + 1\n\n\t\t\"pmullw %%mm4, %%mm0\t\t\\n\\t\" // (abs(block[i])*2 + 1)*q\n\n\t\t\"pmullw %%mm5, %%mm1\t\t\\n\\t\" // (abs(block[i])*2 + 1)*q\n\n\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\" // FIXME slow\n\n\t\t\"pcmpeqw (%0, %3), %%mm4\t\\n\\t\" // block[i] == 0 ? -1 : 0\n\n\t\t\"pcmpeqw 8(%0, %3), %%mm5\t\\n\\t\" // block[i] == 0 ? -1 : 0\n\n\t\t\"psraw $4, %%mm0\t\t\\n\\t\"\n\n\t\t\"psraw $4, %%mm1\t\t\\n\\t\"\n\n\t\t\"psubw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"psubw %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"por %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pxor %%mm2, %%mm0\t\t\\n\\t\"\n\n\t\t\"pxor %%mm3, %%mm1\t\t\\n\\t\"\n\n\t\t\"psubw %%mm2, %%mm0\t\t\\n\\t\"\n\n\t\t\"psubw %%mm3, %%mm1\t\t\\n\\t\"\n\n\t\t\"pandn %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\"pandn %%mm1, %%mm5\t\t\\n\\t\"\n\n\t\t\"movq %%mm4, (%0, %3)\t\t\\n\\t\"\n\n\t\t\"movq %%mm5, 8(%0, %3)\t\t\\n\\t\"\n\n\n\n\t\t\"addl $16, %3\t\t\t\\n\\t\"\n\n\t\t\"cmpl $128, %3\t\t\t\\n\\t\"\n\n\t\t\"jb 1b\t\t\t\t\\n\\t\"\n\n\t\t::\"r\" (block), \"r\"(quant_matrix), \"g\" (qscale), \"r\" (2*i)\n\n\t\t: \"memory\"\n\n\t);\n\n\n\n#if 0\n\n\t__asm __volatile(\n\n\t\"movd\t%0, %%mm6\\n\\t\"       /* mm6 = qscale | 0  */\n\n\t\"punpckldq %%mm6, %%mm6\\n\\t\" /* mm6 = qscale | qscale */\n\n\t\"movq\t%2, %%mm4\\n\\t\"\n\n\t\"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\"movq\t%1, %%mm5\\n\\t\"\n\n\t\"packssdw %%mm6, %%mm7\\n\\t\" /* mm7 = qscale | qscale | qscale | qscale */\n\n\t\"pxor\t%%mm6, %%mm6\\n\\t\"\n\n\t::\"g\"(qscale),\"m\"(mm_wone),\"m\"(mm_wabs));\n\n        for(;i<64;i+=4) {\n\n\t\t__asm __volatile(\n\n\t\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\t\"movq\t%%mm7, %%mm1\\n\\t\"\n\n\t\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\t\t\"movq\t%%mm0, %%mm3\\n\\t\"\n\n\t\t\t\"pcmpgtw %%mm6, %%mm2\\n\\t\"\n\n\t\t\t\"pmullw\t%2, %%mm1\\n\\t\"\n\n\t\t\t\"pandn\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\t\"por\t%%mm5, %%mm2\\n\\t\"\n\n\t\t\t\"pmullw\t%%mm2, %%mm0\\n\\t\" /* mm0 = abs(block[i]). */\n\n\t\t\t\"psllw\t$1, %%mm0\\n\\t\" /* block[i] <<= 1 */\n\n\t\t\t\"paddw\t%%mm5, %%mm0\\n\\t\" /* block[i] ++ */\n\n\n\n\t\t\t\"pmullw\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\t\"psraw\t$4, %%mm1\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm6, %%mm3\\n\\t\"\n\n\t\t\t\"psubw\t%%mm5, %%mm1\\n\\t\"   /* block[i] --; */\n\n\t\t\t\"pandn\t%%mm4, %%mm3\\n\\t\"  /* fake of pcmpneqw : mm0 != 0 then mm1 = -1 */\n\n\t\t\t\"por\t%%mm5, %%mm1\\n\\t\"   /* block[i] |= 1 */\n\n\t\t\t\"pmullw %%mm2, %%mm1\\n\\t\"   /* change signs again */\n\n\n\n\t\t\t\"pand\t%%mm3, %%mm1\\n\\t\" /* nullify if was zero */\n\n\t\t\t\"movq\t%%mm1, %0\"\n\n\t\t\t:\"=m\"(block[i])\n\n\t\t\t:\"m\"(block[i]), \"m\"(quant_matrix[i]));\n\n        }\n\n#endif\n\n    }\n\n}\n", "idx": 400}
{"project": "qemu", "commit_id": "b1914b824ade1706847428e64ef5637ffc0ae238", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, VqInfoBlock *info,\n\n                              VqInfoBlockLegacy *linfo)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n    uint16_t index = info ? info->index : linfo->index;\n\n    uint16_t num = info ? info->num : linfo->num;\n\n    uint64_t desc = info ? info->desc : linfo->queue;\n\n\n\n    if (index >= VIRTIO_CCW_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (linfo && desc && (linfo->align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (info) {\n\n        virtio_queue_set_rings(vdev, index, desc, info->avail, info->used);\n\n    } else {\n\n        virtio_queue_set_addr(vdev, index, desc);\n\n    }\n\n    if (!desc) {\n\n        virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);\n\n    } else {\n\n        if (info) {\n\n            /* virtio-1 allows changing the ring size. */\n\n            if (virtio_queue_get_max_num(vdev, index) < num) {\n\n                /* Fail if we exceed the maximum number. */\n\n                return -EINVAL;\n\n            }\n\n            virtio_queue_set_num(vdev, index, num);\n\n        } else if (virtio_queue_get_num(vdev, index) > num) {\n\n            /* Fail if we don't have a big enough queue. */\n\n            return -EINVAL;\n\n        }\n\n        /* We ignore possible increased num for legacy for compatibility. */\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_CCW_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 401}
{"project": "qemu", "commit_id": "83f338f73ecb88cc6f85d6e7b81ebef112ce07be", "target": 0, "func": "void qemu_system_debug_request(void)\n\n{\n\n    debug_requested = 1;\n\n    vm_stop(VMSTOP_DEBUG);\n\n}\n", "idx": 403}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,\n\n                                             int64_t offset, int count,\n\n                                             BdrvRequestFlags flags)\n\n{\n\n    return bdrv_co_pwrite_zeroes(bs->file->bs, offset, count, flags);\n\n}\n", "idx": 405}
{"project": "qemu", "commit_id": "871271615108fd58273423d98b7cefe08e6f75a0", "target": 0, "func": "void monitor_flush(Monitor *mon)\n\n{\n\n    int i;\n\n    if (term_outbuf_index > 0) {\n\n        for (i = 0; i < MAX_MON; i++)\n\n            if (monitor_hd[i] && monitor_hd[i]->focus == 0)\n\n                qemu_chr_write(monitor_hd[i], term_outbuf, term_outbuf_index);\n\n        term_outbuf_index = 0;\n\n    }\n\n}\n", "idx": 406}
{"project": "qemu", "commit_id": "28f082469650a0f4c0e37b4ccd6f9514b1a0698d", "target": 0, "func": "void qemu_co_queue_restart_all(CoQueue *queue)\n\n{\n\n    while (qemu_co_queue_next(queue)) {\n\n        /* Do nothing */\n\n    }\n\n}\n", "idx": 407}
{"project": "qemu", "commit_id": "12f86b5b3e1bdf75e0a467d771c16cc42f3a1f1a", "target": 0, "func": "static void nvdimm_dsm_func_read_fit(AcpiNVDIMMState *state, NvdimmDsmIn *in,\n\n                                     hwaddr dsm_mem_addr)\n\n{\n\n    NvdimmFitBuffer *fit_buf = &state->fit_buf;\n\n    NvdimmFuncReadFITIn *read_fit;\n\n    NvdimmFuncReadFITOut *read_fit_out;\n\n    GArray *fit;\n\n    uint32_t read_len = 0, func_ret_status;\n\n    int size;\n\n\n\n    read_fit = (NvdimmFuncReadFITIn *)in->arg3;\n\n    le32_to_cpus(&read_fit->offset);\n\n\n\n    qemu_mutex_lock(&fit_buf->lock);\n\n    fit = fit_buf->fit;\n\n\n\n    nvdimm_debug(\"Read FIT: offset %#x FIT size %#x Dirty %s.\\n\",\n\n                 read_fit->offset, fit->len, fit_buf->dirty ? \"Yes\" : \"No\");\n\n\n\n    if (read_fit->offset > fit->len) {\n\n        func_ret_status = 3 /* Invalid Input Parameters */;\n\n        goto exit;\n\n    }\n\n\n\n    /* It is the first time to read FIT. */\n\n    if (!read_fit->offset) {\n\n        fit_buf->dirty = false;\n\n    } else if (fit_buf->dirty) { /* FIT has been changed during RFIT. */\n\n        func_ret_status = 0x100 /* fit changed */;\n\n        goto exit;\n\n    }\n\n\n\n    func_ret_status = 0 /* Success */;\n\n    read_len = MIN(fit->len - read_fit->offset,\n\n                   4096 - sizeof(NvdimmFuncReadFITOut));\n\n\n\nexit:\n\n    size = sizeof(NvdimmFuncReadFITOut) + read_len;\n\n    read_fit_out = g_malloc(size);\n\n\n\n    read_fit_out->len = cpu_to_le32(size);\n\n    read_fit_out->func_ret_status = cpu_to_le32(func_ret_status);\n\n    memcpy(read_fit_out->fit, fit->data + read_fit->offset, read_len);\n\n\n\n    cpu_physical_memory_write(dsm_mem_addr, read_fit_out, size);\n\n\n\n    g_free(read_fit_out);\n\n    qemu_mutex_unlock(&fit_buf->lock);\n\n}\n", "idx": 408}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "static void tftp_send_error(struct tftp_session *spt,\n\n                            uint16_t errorcode, const char *msg,\n\n                            struct tftp_t *recv_tp)\n\n{\n\n  struct sockaddr_in saddr, daddr;\n\n  struct mbuf *m;\n\n  struct tftp_t *tp;\n\n\n\n  m = m_get(spt->slirp);\n\n\n\n  if (!m) {\n\n    goto out;\n\n  }\n\n\n\n  memset(m->m_data, 0, m->m_size);\n\n\n\n  m->m_data += IF_MAXLINKHDR;\n\n  tp = (void *)m->m_data;\n\n  m->m_data += sizeof(struct udpiphdr);\n\n\n\n  tp->tp_op = htons(TFTP_ERROR);\n\n  tp->x.tp_error.tp_error_code = htons(errorcode);\n\n  pstrcpy((char *)tp->x.tp_error.tp_msg, sizeof(tp->x.tp_error.tp_msg), msg);\n\n\n\n  saddr.sin_addr = recv_tp->ip.ip_dst;\n\n  saddr.sin_port = recv_tp->udp.uh_dport;\n\n\n\n  daddr.sin_addr = spt->client_ip;\n\n  daddr.sin_port = spt->client_port;\n\n\n\n  m->m_len = sizeof(struct tftp_t) - 514 + 3 + strlen(msg) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n\n\n  udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n\n\nout:\n\n  tftp_session_terminate(spt);\n\n}\n", "idx": 409}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void omap_rtc_alarm_update(struct omap_rtc_s *s)\n\n{\n\n    s->alarm_ti = mktimegm(&s->alarm_tm);\n\n    if (s->alarm_ti == -1)\n\n        printf(\"%s: conversion failed\\n\", __FUNCTION__);\n\n}\n", "idx": 410}
{"project": "FFmpeg", "commit_id": "33d6f90e3e0241939ea0be9ca9e1f335942081c8", "target": 0, "func": "static int http_send_data(HTTPContext *c)\n\n{\n\n    int len, ret;\n\n\n\n    for(;;) {\n\n        if (c->buffer_ptr >= c->buffer_end) {\n\n            ret = http_prepare_data(c);\n\n            if (ret < 0)\n\n                return -1;\n\n            else if (ret != 0)\n\n                /* state change requested */\n\n                break;\n\n        } else {\n\n            if (c->is_packetized) {\n\n                /* RTP data output */\n\n                len = c->buffer_end - c->buffer_ptr;\n\n                if (len < 4) {\n\n                    /* fail safe - should never happen */\n\n                fail1:\n\n                    c->buffer_ptr = c->buffer_end;\n\n                    return 0;\n\n                }\n\n                len = (c->buffer_ptr[0] << 24) |\n\n                    (c->buffer_ptr[1] << 16) |\n\n                    (c->buffer_ptr[2] << 8) |\n\n                    (c->buffer_ptr[3]);\n\n                if (len > (c->buffer_end - c->buffer_ptr))\n\n                    goto fail1;\n\n                if ((get_packet_send_clock(c) - get_server_clock(c)) > 0) {\n\n                    /* nothing to send yet: we can wait */\n\n                    return 0;\n\n                }\n\n\n\n                c->data_count += len;\n\n                update_datarate(&c->datarate, c->data_count);\n\n                if (c->stream)\n\n                    c->stream->bytes_served += len;\n\n\n\n                if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    /* RTP packets are sent inside the RTSP TCP connection */\n\n                    AVIOContext *pb;\n\n                    int interleaved_index, size;\n\n                    uint8_t header[4];\n\n                    HTTPContext *rtsp_c;\n\n\n\n                    rtsp_c = c->rtsp_c;\n\n                    /* if no RTSP connection left, error */\n\n                    if (!rtsp_c)\n\n                        return -1;\n\n                    /* if already sending something, then wait. */\n\n                    if (rtsp_c->state != RTSPSTATE_WAIT_REQUEST)\n\n                        break;\n\n                    if (avio_open_dyn_buf(&pb) < 0)\n\n                        goto fail1;\n\n                    interleaved_index = c->packet_stream_index * 2;\n\n                    /* RTCP packets are sent at odd indexes */\n\n                    if (c->buffer_ptr[1] == 200)\n\n                        interleaved_index++;\n\n                    /* write RTSP TCP header */\n\n                    header[0] = '$';\n\n                    header[1] = interleaved_index;\n\n                    header[2] = len >> 8;\n\n                    header[3] = len;\n\n                    avio_write(pb, header, 4);\n\n                    /* write RTP packet data */\n\n                    c->buffer_ptr += 4;\n\n                    avio_write(pb, c->buffer_ptr, len);\n\n                    size = avio_close_dyn_buf(pb, &c->packet_buffer);\n\n                    /* prepare asynchronous TCP sending */\n\n                    rtsp_c->packet_buffer_ptr = c->packet_buffer;\n\n                    rtsp_c->packet_buffer_end = c->packet_buffer + size;\n\n                    c->buffer_ptr += len;\n\n\n\n                    /* send everything we can NOW */\n\n                    len = send(rtsp_c->fd, rtsp_c->packet_buffer_ptr,\n\n                                rtsp_c->packet_buffer_end - rtsp_c->packet_buffer_ptr, 0);\n\n                    if (len > 0)\n\n                        rtsp_c->packet_buffer_ptr += len;\n\n                    if (rtsp_c->packet_buffer_ptr < rtsp_c->packet_buffer_end) {\n\n                        /* if we could not send all the data, we will\n\n                           send it later, so a new state is needed to\n\n                           \"lock\" the RTSP TCP connection */\n\n                        rtsp_c->state = RTSPSTATE_SEND_PACKET;\n\n                        break;\n\n                    } else\n\n                        /* all data has been sent */\n\n                        av_freep(&c->packet_buffer);\n\n                } else {\n\n                    /* send RTP packet directly in UDP */\n\n                    c->buffer_ptr += 4;\n\n                    ffurl_write(c->rtp_handles[c->packet_stream_index],\n\n                                c->buffer_ptr, len);\n\n                    c->buffer_ptr += len;\n\n                    /* here we continue as we can send several packets per 10 ms slot */\n\n                }\n\n            } else {\n\n                /* TCP data output */\n\n                len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n\n                if (len < 0) {\n\n                    if (ff_neterrno() != AVERROR(EAGAIN) &&\n\n                        ff_neterrno() != AVERROR(EINTR))\n\n                        /* error : close connection */\n\n                        return -1;\n\n                    else\n\n                        return 0;\n\n                } else\n\n                    c->buffer_ptr += len;\n\n\n\n                c->data_count += len;\n\n                update_datarate(&c->datarate, c->data_count);\n\n                if (c->stream)\n\n                    c->stream->bytes_served += len;\n\n                break;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n    return 0;\n\n}\n", "idx": 411}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static inline bool vtd_iova_range_check(uint64_t iova, VTDContextEntry *ce)\n\n{\n\n    /*\n\n     * Check if @iova is above 2^X-1, where X is the minimum of MGAW\n\n     * in CAP_REG and AW in context-entry.\n\n     */\n\n    return !(iova & ~(vtd_iova_limit(ce) - 1));\n\n}\n", "idx": 412}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *value;\n\n    BlockBackend *blk;\n\n    DriveInfo *dinfo = NULL;\n\n    QDict *bs_opts;\n\n    QemuOpts *legacy_opts;\n\n    DriveMediaType media = MEDIA_DISK;\n\n    BlockInterfaceType type;\n\n    int cyls, heads, secs, translation;\n\n    int max_devs, bus_id, unit_id, index;\n\n    const char *devaddr;\n\n    const char *werror, *rerror;\n\n    bool read_only = false;\n\n    bool copy_on_read;\n\n    const char *serial;\n\n    const char *filename;\n\n    Error *local_err = NULL;\n\n    int i;\n\n    const char *deprecated[] = {\n\n        \"serial\", \"trans\", \"secs\", \"heads\", \"cyls\", \"addr\"\n\n    };\n\n\n\n    /* Change legacy command line options into QMP ones */\n\n    static const struct {\n\n        const char *from;\n\n        const char *to;\n\n    } opt_renames[] = {\n\n        { \"iops\",           \"throttling.iops-total\" },\n\n        { \"iops_rd\",        \"throttling.iops-read\" },\n\n        { \"iops_wr\",        \"throttling.iops-write\" },\n\n\n\n        { \"bps\",            \"throttling.bps-total\" },\n\n        { \"bps_rd\",         \"throttling.bps-read\" },\n\n        { \"bps_wr\",         \"throttling.bps-write\" },\n\n\n\n        { \"iops_max\",       \"throttling.iops-total-max\" },\n\n        { \"iops_rd_max\",    \"throttling.iops-read-max\" },\n\n        { \"iops_wr_max\",    \"throttling.iops-write-max\" },\n\n\n\n        { \"bps_max\",        \"throttling.bps-total-max\" },\n\n        { \"bps_rd_max\",     \"throttling.bps-read-max\" },\n\n        { \"bps_wr_max\",     \"throttling.bps-write-max\" },\n\n\n\n        { \"iops_size\",      \"throttling.iops-size\" },\n\n\n\n        { \"group\",          \"throttling.group\" },\n\n\n\n        { \"readonly\",       BDRV_OPT_READ_ONLY },\n\n    };\n\n\n\n    for (i = 0; i < ARRAY_SIZE(opt_renames); i++) {\n\n        qemu_opt_rename(all_opts, opt_renames[i].from, opt_renames[i].to,\n\n                        &local_err);\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    value = qemu_opt_get(all_opts, \"cache\");\n\n    if (value) {\n\n        int flags = 0;\n\n        bool writethrough;\n\n\n\n        if (bdrv_parse_cache_mode(value, &flags, &writethrough) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n\n\n        /* Specific options take precedence */\n\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_WB)) {\n\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_WB,\n\n                              !writethrough, &error_abort);\n\n        }\n\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_DIRECT)) {\n\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_DIRECT,\n\n                              !!(flags & BDRV_O_NOCACHE), &error_abort);\n\n        }\n\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_NO_FLUSH)) {\n\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_NO_FLUSH,\n\n                              !!(flags & BDRV_O_NO_FLUSH), &error_abort);\n\n        }\n\n        qemu_opt_unset(all_opts, \"cache\");\n\n    }\n\n\n\n    /* Get a QDict for processing the options */\n\n    bs_opts = qdict_new();\n\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n\n                                   &error_abort);\n\n    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Deprecated option boot=[on|off] */\n\n    if (qemu_opt_get(legacy_opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    /* Other deprecated options */\n\n    if (!qtest_enabled()) {\n\n        for (i = 0; i < ARRAY_SIZE(deprecated); i++) {\n\n            if (qemu_opt_get(legacy_opts, deprecated[i]) != NULL) {\n\n                error_report(\"'%s' is deprecated, please use the corresponding \"\n\n                             \"option of '-device' instead\", deprecated[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Media type */\n\n    value = qemu_opt_get(legacy_opts, \"media\");\n\n    if (value) {\n\n        if (!strcmp(value, \"disk\")) {\n\n            media = MEDIA_DISK;\n\n        } else if (!strcmp(value, \"cdrom\")) {\n\n            media = MEDIA_CDROM;\n\n            read_only = true;\n\n        } else {\n\n            error_report(\"'%s' invalid media\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n\n    read_only |= qemu_opt_get_bool(legacy_opts, BDRV_OPT_READ_ONLY, false);\n\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n\n\n    if (read_only && copy_on_read) {\n\n        error_report(\"warning: disabling copy-on-read on read-only drive\");\n\n        copy_on_read = false;\n\n    }\n\n\n\n    qdict_put_str(bs_opts, BDRV_OPT_READ_ONLY, read_only ? \"on\" : \"off\");\n\n    qdict_put_str(bs_opts, \"copy-on-read\", copy_on_read ? \"on\" : \"off\");\n\n\n\n    /* Controller type */\n\n    value = qemu_opt_get(legacy_opts, \"if\");\n\n    if (value) {\n\n        for (type = 0;\n\n             type < IF_COUNT && strcmp(value, if_name[type]);\n\n             type++) {\n\n        }\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", value);\n\n            goto fail;\n\n        }\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    /* Geometry */\n\n    cyls  = qemu_opt_get_number(legacy_opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(legacy_opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(legacy_opts, \"secs\", 0);\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n            goto fail;\n\n        }\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n            goto fail;\n\n        }\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    value = qemu_opt_get(legacy_opts, \"trans\");\n\n    if (value != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         value);\n\n            goto fail;\n\n        }\n\n        if (!strcmp(value, \"none\")) {\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        } else if (!strcmp(value, \"lba\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        } else if (!strcmp(value, \"large\")) {\n\n            translation = BIOS_ATA_TRANSLATION_LARGE;\n\n        } else if (!strcmp(value, \"rechs\")) {\n\n            translation = BIOS_ATA_TRANSLATION_RECHS;\n\n        } else if (!strcmp(value, \"auto\")) {\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n        } else {\n\n            error_report(\"'%s' invalid translation type\", value);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        if (cyls || secs || heads) {\n\n            error_report(\"CHS can't be set with media=cdrom\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* Device address specified by bus/unit or index.\n\n     * If none was specified, try to find the first free one. */\n\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            goto fail;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n\n        goto fail;\n\n    }\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        goto fail;\n\n    }\n\n\n\n    /* Serial number */\n\n    serial = qemu_opt_get(legacy_opts, \"serial\");\n\n\n\n    /* no id supplied -> create one */\n\n    if (qemu_opts_id(all_opts) == NULL) {\n\n        char *new_id;\n\n        const char *mediastr = \"\";\n\n        if (type == IF_IDE || type == IF_SCSI) {\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        }\n\n        if (max_devs) {\n\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n\n                                     mediastr, unit_id);\n\n        } else {\n\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n\n                                     mediastr, unit_id);\n\n        }\n\n        qdict_put_str(bs_opts, \"id\", new_id);\n\n        g_free(new_id);\n\n    }\n\n\n\n    /* Add virtio block device */\n\n    devaddr = qemu_opt_get(legacy_opts, \"addr\");\n\n    if (devaddr && type != IF_VIRTIO) {\n\n        error_report(\"addr is not supported by this bus type\");\n\n        goto fail;\n\n    }\n\n\n\n    if (type == IF_VIRTIO) {\n\n        QemuOpts *devopts;\n\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n\n                                   &error_abort);\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-ccw\", &error_abort);\n\n        } else {\n\n            qemu_opt_set(devopts, \"driver\", \"virtio-blk-pci\", &error_abort);\n\n        }\n\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"),\n\n                     &error_abort);\n\n        if (devaddr) {\n\n            qemu_opt_set(devopts, \"addr\", devaddr, &error_abort);\n\n        }\n\n    }\n\n\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n\n\n    /* Check werror/rerror compatibility with if=... */\n\n    werror = qemu_opt_get(legacy_opts, \"werror\");\n\n    if (werror != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&\n\n            type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put_str(bs_opts, \"werror\", werror);\n\n    }\n\n\n\n    rerror = qemu_opt_get(legacy_opts, \"rerror\");\n\n    if (rerror != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&\n\n            type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            goto fail;\n\n        }\n\n        qdict_put_str(bs_opts, \"rerror\", rerror);\n\n    }\n\n\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n\n    blk = blockdev_init(filename, bs_opts, &local_err);\n\n    bs_opts = NULL;\n\n    if (!blk) {\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n        }\n\n        goto fail;\n\n    } else {\n\n        assert(!local_err);\n\n    }\n\n\n\n    /* Create legacy DriveInfo */\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    dinfo->opts = all_opts;\n\n\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->serial = g_strdup(serial);\n\n\n\n    blk_set_legacy_dinfo(blk, dinfo);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(legacy_opts);\n\n    QDECREF(bs_opts);\n\n    return dinfo;\n\n}\n", "idx": 413}
{"project": "qemu", "commit_id": "cde0fc7544ca590c83f349d4dcccf375d55d6042", "target": 0, "func": "void qerror_report_internal(const char *file, int linenr, const char *func,\n\n                            const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    if (cur_mon) {\n\n        monitor_set_error(cur_mon, qerror);\n\n    } else {\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n    }\n\n}\n", "idx": 414}
{"project": "qemu", "commit_id": "7a7aae21ccab06606cee9aba846d2e30cb616763", "target": 0, "func": "static void qdev_prop_set(DeviceState *dev, const char *name, void *src, enum PropertyType type)\n\n{\n\n    Property *prop;\n\n\n\n    prop = qdev_prop_find(dev, name);\n\n    if (!prop) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" not found\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    if (prop->info->type != type) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" type mismatch\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    qdev_prop_cpy(dev, prop, src);\n\n}\n", "idx": 415}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void qdev_prop_set_drive_nofail(DeviceState *dev, const char *name,\n\n                                BlockDriverState *value)\n\n{\n\n    if (qdev_prop_set_drive(dev, name, value) < 0) {\n\n        exit(1);\n\n    }\n\n}\n", "idx": 416}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static int piix3_post_load(void *opaque, int version_id)\n\n{\n\n    PIIX3State *piix3 = opaque;\n\n    int pirq;\n\n\n\n    /* Because the i8259 has not been deserialized yet, qemu_irq_raise\n\n     * might bring the system to a different state than the saved one;\n\n     * for example, the interrupt could be masked but the i8259 would\n\n     * not know that yet and would trigger an interrupt in the CPU.\n\n     *\n\n     * Here, we update irq levels without raising the interrupt.\n\n     * Interrupt state will be deserialized separately through the i8259.\n\n     */\n\n    piix3->pic_levels = 0;\n\n    for (pirq = 0; pirq < PIIX_NUM_PIRQS; pirq++) {\n\n        piix3_set_irq_level_internal(piix3, pirq,\n\n                            pci_bus_get_irq_level(piix3->dev.bus, pirq));\n\n    }\n\n    return 0;\n\n}\n", "idx": 417}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static void unset_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        aio_context_acquire(blk_get_aio_context(bmds->blk));\n\n        bdrv_release_dirty_bitmap(blk_bs(bmds->blk), bmds->dirty_bitmap);\n\n        aio_context_release(blk_get_aio_context(bmds->blk));\n\n    }\n\n}\n", "idx": 418}
{"project": "qemu", "commit_id": "eef5ad1086403d8ac8d91208a0e8dc34734b671c", "target": 0, "func": "static void cb_hmp_change_bdrv_pwd(Monitor *mon, const char *password,\n\n                                   void *opaque)\n\n{\n\n    Error *encryption_err = opaque;\n\n    Error *err = NULL;\n\n    const char *device;\n\n\n\n    device = error_get_field(encryption_err, \"device\");\n\n\n\n    qmp_block_passwd(device, password, &err);\n\n    hmp_handle_error(mon, &err);\n\n    error_free(encryption_err);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 419}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n\n{\n\n    IVI45DecContext *ctx = avctx->priv_data;\n\n\n\n    ivi_free_buffers(&ctx->planes[0]);\n\n\n\n    if (ctx->mb_vlc.cust_tab.table)\n\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n    if (ctx->is_indeo4) {\n\n    if (ctx->is_scalable)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses scalability mode!\\n\");\n\n    if (ctx->uses_tiling)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses local decoding!\\n\");\n\n    if (ctx->has_b_frames)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video contains B-frames!\\n\");\n\n    if (ctx->has_transp)\n\n        av_log(avctx, AV_LOG_ERROR, \"Transparency mode is enabled!\\n\");\n\n    if (ctx->uses_haar)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses Haar transform!\\n\");\n\n    if (ctx->uses_fullpel)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses fullpel motion vectors!\\n\");\n\n    }\n\n#endif\n\n\n\n    av_frame_free(&ctx->p_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 421}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int cinepak_decode_init(AVCodecContext *avctx)\n\n{\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width + 3) & ~3;\n\n    s->height = (avctx->height + 3) & ~3;\n\n    s->sega_film_skip_bytes = -1;  /* uninitialized state */\n\n\n\n    // check for paletted data\n\n    if (avctx->bits_per_coded_sample != 8) {\n\n        s->palette_video = 0;\n\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    } else {\n\n        s->palette_video = 1;\n\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 422}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_config_open(XenHostPCIDevice *d)\n\n{\n\n    char path[PATH_MAX];\n\n    int rc;\n\n\n\n    rc = xen_host_pci_sysfs_path(d, \"config\", path, sizeof (path));\n\n    if (rc) {\n\n        return rc;\n\n    }\n\n    d->config_fd = open(path, O_RDWR);\n\n    if (d->config_fd < 0) {\n\n        return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 423}
{"project": "qemu", "commit_id": "cba7054928b10a7fda57c64807451bbc9a31e42e", "target": 1, "func": "void cpu_exec_init(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    CPUState *some_cpu;\n\n    int cpu_index;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    cpu_list_lock();\n\n#endif\n\n    cpu_index = 0;\n\n    CPU_FOREACH(some_cpu) {\n\n        cpu_index++;\n\n    }\n\n    cpu->cpu_index = cpu_index;\n\n    cpu->numa_node = 0;\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n#ifndef CONFIG_USER_ONLY\n\n    cpu->as = &address_space_memory;\n\n    cpu->thread_id = qemu_get_thread_id();\n\n\n#endif\n\n    QTAILQ_INSERT_TAIL(&cpus, cpu, node);\n\n#if defined(CONFIG_USER_ONLY)\n\n    cpu_list_unlock();\n\n#endif\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n#if defined(CPU_SAVE_VERSION) && !defined(CONFIG_USER_ONLY)\n\n    register_savevm(NULL, \"cpu\", cpu_index, CPU_SAVE_VERSION,\n\n                    cpu_save, cpu_load, env);\n\n    assert(cc->vmsd == NULL);\n\n    assert(qdev_get_vmsd(DEVICE(cpu)) == NULL);\n\n#endif\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu_index, cc->vmsd, cpu);\n\n    }\n\n}", "idx": 424}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_set_vring_file(struct vhost_dev *dev,\n\n                                VhostUserRequest request,\n\n                                struct vhost_vring_file *file)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    size_t fd_num = 0;\n\n    VhostUserMsg msg = {\n\n        .request = request,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.u64 = file->index & VHOST_USER_VRING_IDX_MASK,\n\n        .size = sizeof(msg.payload.u64),\n\n    };\n\n\n\n    if (ioeventfd_enabled() && file->fd > 0) {\n\n        fds[fd_num++] = file->fd;\n\n    } else {\n\n        msg.payload.u64 |= VHOST_USER_VRING_NOFD_MASK;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, fds, fd_num);\n\n\n\n    return 0;\n\n}\n", "idx": 425}
{"project": "qemu", "commit_id": "11b7b07f8a15879134a54e73fade98d5e11e04f8", "target": 1, "func": "char *qdist_pr(const struct qdist *dist, size_t n_bins, uint32_t opt)\n\n{\n\n    const char *border = opt & QDIST_PR_BORDER ? \"|\" : \"\";\n\n    char *llabel, *rlabel;\n\n    char *hgram;\n\n    GString *s;\n\n\n\n    if (dist->n == 0) {\n\n        return NULL;\n\n    }\n\n\n\n    s = g_string_new(\"\");\n\n\n\n    llabel = qdist_pr_label(dist, n_bins, opt, true);\n\n    rlabel = qdist_pr_label(dist, n_bins, opt, false);\n\n    hgram = qdist_pr_plain(dist, n_bins);\n\n    g_string_append_printf(s, \"%s%s%s%s%s\",\n\n                           llabel, border, hgram, border, rlabel);\n\n    g_free(llabel);\n\n    g_free(rlabel);\n\n    g_free(hgram);\n\n\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 426}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_write_one(QEMUFile *f, RDMAContext *rdma,\n\n                               int current_index, uint64_t current_addr,\n\n                               uint64_t length)\n\n{\n\n    struct ibv_sge sge;\n\n    struct ibv_send_wr send_wr = { 0 };\n\n    struct ibv_send_wr *bad_wr;\n\n    int reg_result_idx, ret, count = 0;\n\n    uint64_t chunk, chunks;\n\n    uint8_t *chunk_start, *chunk_end;\n\n    RDMALocalBlock *block = &(rdma->local_ram_blocks.block[current_index]);\n\n    RDMARegister reg;\n\n    RDMARegisterResult *reg_result;\n\n    RDMAControlHeader resp = { .type = RDMA_CONTROL_REGISTER_RESULT };\n\n    RDMAControlHeader head = { .len = sizeof(RDMARegister),\n\n                               .type = RDMA_CONTROL_REGISTER_REQUEST,\n\n                               .repeat = 1,\n\n                             };\n\n\n\nretry:\n\n    sge.addr = (uint64_t)(block->local_host_addr +\n\n                            (current_addr - block->offset));\n\n    sge.length = length;\n\n\n\n    chunk = ram_chunk_index(block->local_host_addr, (uint8_t *) sge.addr);\n\n    chunk_start = ram_chunk_start(block, chunk);\n\n\n\n    if (block->is_ram_block) {\n\n        chunks = length / (1UL << RDMA_REG_CHUNK_SHIFT);\n\n\n\n        if (chunks && ((length % (1UL << RDMA_REG_CHUNK_SHIFT)) == 0)) {\n\n            chunks--;\n\n        }\n\n    } else {\n\n        chunks = block->length / (1UL << RDMA_REG_CHUNK_SHIFT);\n\n\n\n        if (chunks && ((block->length % (1UL << RDMA_REG_CHUNK_SHIFT)) == 0)) {\n\n            chunks--;\n\n        }\n\n    }\n\n\n\n    DDPRINTF(\"Writing %\" PRIu64 \" chunks, (%\" PRIu64 \" MB)\\n\",\n\n        chunks + 1, (chunks + 1) * (1UL << RDMA_REG_CHUNK_SHIFT) / 1024 / 1024);\n\n\n\n    chunk_end = ram_chunk_end(block, chunk + chunks);\n\n\n\n    if (!rdma->pin_all) {\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n        qemu_rdma_unregister_waiting(rdma);\n\n#endif\n\n    }\n\n\n\n    while (test_bit(chunk, block->transit_bitmap)) {\n\n        (void)count;\n\n        DDPRINTF(\"(%d) Not clobbering: block: %d chunk %\" PRIu64\n\n                \" current %\" PRIu64 \" len %\" PRIu64 \" %d %d\\n\",\n\n                count++, current_index, chunk,\n\n                sge.addr, length, rdma->nb_sent, block->nb_chunks);\n\n\n\n        ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RDMA_WRITE, NULL);\n\n\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"Failed to Wait for previous write to complete \"\n\n                    \"block %d chunk %\" PRIu64\n\n                    \" current %\" PRIu64 \" len %\" PRIu64 \" %d\\n\",\n\n                    current_index, chunk, sge.addr, length, rdma->nb_sent);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!rdma->pin_all || !block->is_ram_block) {\n\n        if (!block->remote_keys[chunk]) {\n\n            /*\n\n             * This chunk has not yet been registered, so first check to see\n\n             * if the entire chunk is zero. If so, tell the other size to\n\n             * memset() + madvise() the entire chunk without RDMA.\n\n             */\n\n\n\n            if (can_use_buffer_find_nonzero_offset((void *)sge.addr, length)\n\n                   && buffer_find_nonzero_offset((void *)sge.addr,\n\n                                                    length) == length) {\n\n                RDMACompress comp = {\n\n                                        .offset = current_addr,\n\n                                        .value = 0,\n\n                                        .block_idx = current_index,\n\n                                        .length = length,\n\n                                    };\n\n\n\n                head.len = sizeof(comp);\n\n                head.type = RDMA_CONTROL_COMPRESS;\n\n\n\n                DDPRINTF(\"Entire chunk is zero, sending compress: %\"\n\n                    PRIu64 \" for %d \"\n\n                    \"bytes, index: %d, offset: %\" PRId64 \"...\\n\",\n\n                    chunk, sge.length, current_index, current_addr);\n\n\n\n                compress_to_network(&comp);\n\n                ret = qemu_rdma_exchange_send(rdma, &head,\n\n                                (uint8_t *) &comp, NULL, NULL, NULL);\n\n\n\n                if (ret < 0) {\n\n                    return -EIO;\n\n                }\n\n\n\n                acct_update_position(f, sge.length, true);\n\n\n\n                return 1;\n\n            }\n\n\n\n            /*\n\n             * Otherwise, tell other side to register.\n\n             */\n\n            reg.current_index = current_index;\n\n            if (block->is_ram_block) {\n\n                reg.key.current_addr = current_addr;\n\n            } else {\n\n                reg.key.chunk = chunk;\n\n            }\n\n            reg.chunks = chunks;\n\n\n\n            DDPRINTF(\"Sending registration request chunk %\" PRIu64 \" for %d \"\n\n                    \"bytes, index: %d, offset: %\" PRId64 \"...\\n\",\n\n                    chunk, sge.length, current_index, current_addr);\n\n\n\n            register_to_network(&reg);\n\n            ret = qemu_rdma_exchange_send(rdma, &head, (uint8_t *) &reg,\n\n                                    &resp, &reg_result_idx, NULL);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n\n\n            /* try to overlap this single registration with the one we sent. */\n\n            if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                                                (uint8_t *) sge.addr,\n\n                                                &sge.lkey, NULL, chunk,\n\n                                                chunk_start, chunk_end)) {\n\n                fprintf(stderr, \"cannot get lkey!\\n\");\n\n                return -EINVAL;\n\n            }\n\n\n\n            reg_result = (RDMARegisterResult *)\n\n                    rdma->wr_data[reg_result_idx].control_curr;\n\n\n\n            network_to_result(reg_result);\n\n\n\n            DDPRINTF(\"Received registration result:\"\n\n                    \" my key: %x their key %x, chunk %\" PRIu64 \"\\n\",\n\n                    block->remote_keys[chunk], reg_result->rkey, chunk);\n\n\n\n            block->remote_keys[chunk] = reg_result->rkey;\n\n            block->remote_host_addr = reg_result->host_addr;\n\n        } else {\n\n            /* already registered before */\n\n            if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                                                (uint8_t *)sge.addr,\n\n                                                &sge.lkey, NULL, chunk,\n\n                                                chunk_start, chunk_end)) {\n\n                fprintf(stderr, \"cannot get lkey!\\n\");\n\n                return -EINVAL;\n\n            }\n\n        }\n\n\n\n        send_wr.wr.rdma.rkey = block->remote_keys[chunk];\n\n    } else {\n\n        send_wr.wr.rdma.rkey = block->remote_rkey;\n\n\n\n        if (qemu_rdma_register_and_get_keys(rdma, block, (uint8_t *)sge.addr,\n\n                                                     &sge.lkey, NULL, chunk,\n\n                                                     chunk_start, chunk_end)) {\n\n            fprintf(stderr, \"cannot get lkey!\\n\");\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * Encode the ram block index and chunk within this wrid.\n\n     * We will use this information at the time of completion\n\n     * to figure out which bitmap to check against and then which\n\n     * chunk in the bitmap to look for.\n\n     */\n\n    send_wr.wr_id = qemu_rdma_make_wrid(RDMA_WRID_RDMA_WRITE,\n\n                                        current_index, chunk);\n\n\n\n    send_wr.opcode = IBV_WR_RDMA_WRITE;\n\n    send_wr.send_flags = IBV_SEND_SIGNALED;\n\n    send_wr.sg_list = &sge;\n\n    send_wr.num_sge = 1;\n\n    send_wr.wr.rdma.remote_addr = block->remote_host_addr +\n\n                                (current_addr - block->offset);\n\n\n\n    DDDPRINTF(\"Posting chunk: %\" PRIu64 \", addr: %lx\"\n\n              \" remote: %lx, bytes %\" PRIu32 \"\\n\",\n\n              chunk, sge.addr, send_wr.wr.rdma.remote_addr,\n\n              sge.length);\n\n\n\n    /*\n\n     * ibv_post_send() does not return negative error numbers,\n\n     * per the specification they are positive - no idea why.\n\n     */\n\n    ret = ibv_post_send(rdma->qp, &send_wr, &bad_wr);\n\n\n\n    if (ret == ENOMEM) {\n\n        DDPRINTF(\"send queue is full. wait a little....\\n\");\n\n        ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RDMA_WRITE, NULL);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"rdma migration: failed to make \"\n\n                            \"room in full send queue! %d\\n\", ret);\n\n            return ret;\n\n        }\n\n\n\n        goto retry;\n\n\n\n    } else if (ret > 0) {\n\n        perror(\"rdma migration: post rdma write failed\");\n\n        return -ret;\n\n    }\n\n\n\n    set_bit(chunk, block->transit_bitmap);\n\n    acct_update_position(f, sge.length, false);\n\n    rdma->total_writes++;\n\n\n\n    return 0;\n\n}\n", "idx": 428}
{"project": "qemu", "commit_id": "2dedf83ef0cc3463783d6b71bf1b25476f691f3a", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n\tconst char* dirname)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=qemu_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n\tdirentry_t* entry=array_get_next(&(s->directory));\n\n\tentry->attributes=0x28; /* archive | volume label */\n\n\tsnprintf((char*)entry->name,11,\"QEMU VVFAT\");\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->faked_sectors=s->first_sectors_number+s->sectors_per_fat*2;\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n\tmapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n\t/* MS-DOS expects the FAT to be 0 for the root directory\n\n\t * (except for the media byte). */\n\n\t/* LATER TODO: still true for FAT32? */\n\n\tint fix_fat = (i != 0);\n\n\tmapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n\t    mapping->begin = cluster;\n\n\t    if(read_directory(s, i)) {\n\n\t\tfprintf(stderr, \"Could not read directory %s\\n\",\n\n\t\t\tmapping->path);\n\n\t\treturn -1;\n\n\t    }\n\n\t    mapping = array_get(&(s->mapping), i);\n\n\t} else {\n\n\t    assert(mapping->mode == MODE_UNDEFINED);\n\n\t    mapping->mode=MODE_NORMAL;\n\n\t    mapping->begin = cluster;\n\n\t    if (mapping->end > 0) {\n\n\t\tdirentry_t* direntry = array_get(&(s->directory),\n\n\t\t\tmapping->dir_index);\n\n\n\n\t\tmapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n\t\tset_begin_of_direntry(direntry, mapping->begin);\n\n\t    } else {\n\n\t\tmapping->end = cluster + 1;\n\n\t\tfix_fat = 0;\n\n\t    }\n\n\t}\n\n\n\n\tassert(mapping->begin < mapping->end);\n\n\n\n\t/* next free cluster */\n\n\tcluster = mapping->end;\n\n\n\n\tif(cluster > s->cluster_count) {\n\n\t    fprintf(stderr,\"Directory does not fit in FAT%d (capacity %s)\\n\",\n\n\t\t    s->fat_type,\n\n\t\t    s->fat_type == 12 ? s->sector_count == 2880 ? \"1.44 MB\"\n\n\t\t\t\t\t\t\t\t: \"2.88 MB\"\n\n\t\t\t\t      : \"504MB\");\n\n\t    return -EINVAL;\n\n\t}\n\n\n\n\t/* fix fat for entry */\n\n\tif (fix_fat) {\n\n\t    int j;\n\n\t    for(j = mapping->begin; j < mapping->end - 1; j++)\n\n\t\tfat_set(s, j, j+1);\n\n\t    fat_set(s, mapping->end - 1, s->max_fat_value);\n\n\t}\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector=(bootsector_t*)(s->first_sectors+(s->first_sectors_number-1)*0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    bootsector->media_type=(s->fat_type!=12?0xf8:s->sector_count==5760?0xf9:0xf8); /* media descriptor */\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track=cpu_to_le16(s->bs->secs);\n\n    bootsector->number_of_heads=cpu_to_le16(s->bs->heads);\n\n    bootsector->hidden_sectors=cpu_to_le32(s->first_sectors_number==1?0:0x3f);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    bootsector->u.fat16.drive_number=s->fat_type==12?0:0x80; /* assume this is hda (TODO) */\n\n    bootsector->u.fat16.current_head=0;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label,\"QEMU VVFAT \",11);\n\n    memcpy(bootsector->fat_type,(s->fat_type==12?\"FAT12   \":s->fat_type==16?\"FAT16   \":\"FAT32   \"),8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 429}
{"project": "FFmpeg", "commit_id": "1bbb18fe82fc77a10d45fa53bd2738d2c54de6c6", "target": 1, "func": "static int mpegts_read_header(AVFormatContext *s)\n\n{\n\n    MpegTSContext *ts = s->priv_data;\n\n    AVIOContext *pb   = s->pb;\n\n    uint8_t buf[8 * 1024] = {0};\n\n    int len;\n\n    int64_t pos, probesize = s->probesize;\n\n\n\n    if (ffio_ensure_seekback(pb, probesize) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"Failed to allocate buffers for seekback\\n\");\n\n\n\n    /* read the first 8192 bytes to get packet size */\n\n    pos = avio_tell(pb);\n\n    len = avio_read(pb, buf, sizeof(buf));\n\n    ts->raw_packet_size = get_packet_size(buf, len);\n\n    if (ts->raw_packet_size <= 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Could not detect TS packet size, defaulting to non-FEC/DVHS\\n\");\n\n        ts->raw_packet_size = TS_PACKET_SIZE;\n\n    }\n\n    ts->stream     = s;\n\n    ts->auto_guess = 0;\n\n\n\n    if (s->iformat == &ff_mpegts_demuxer) {\n\n        /* normal demux */\n\n\n\n        /* first do a scan to get all the services */\n\n        seek_back(s, pb, pos);\n\n\n\n        mpegts_open_section_filter(ts, SDT_PID, sdt_cb, ts, 1);\n\n\n\n        mpegts_open_section_filter(ts, PAT_PID, pat_cb, ts, 1);\n\n\n\n        handle_packets(ts, probesize / ts->raw_packet_size);\n\n        /* if could not find service, enable auto_guess */\n\n\n\n        ts->auto_guess = 1;\n\n\n\n        av_log(ts->stream, AV_LOG_TRACE, \"tuning done\\n\");\n\n\n\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n    } else {\n\n        AVStream *st;\n\n        int pcr_pid, pid, nb_packets, nb_pcrs, ret, pcr_l;\n\n        int64_t pcrs[2], pcr_h;\n\n        int packet_count[2];\n\n        uint8_t packet[TS_PACKET_SIZE];\n\n        const uint8_t *data;\n\n\n\n        /* only read packets */\n\n\n\n        st = avformat_new_stream(s, NULL);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        avpriv_set_pts_info(st, 60, 1, 27000000);\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n\n        st->codecpar->codec_id   = AV_CODEC_ID_MPEG2TS;\n\n\n\n        /* we iterate until we find two PCRs to estimate the bitrate */\n\n        pcr_pid    = -1;\n\n        nb_pcrs    = 0;\n\n        nb_packets = 0;\n\n        for (;;) {\n\n            ret = read_packet(s, packet, ts->raw_packet_size, &data);\n\n            if (ret < 0)\n\n                return ret;\n\n            pid = AV_RB16(data + 1) & 0x1fff;\n\n            if ((pcr_pid == -1 || pcr_pid == pid) &&\n\n                parse_pcr(&pcr_h, &pcr_l, data) == 0) {\n\n                finished_reading_packet(s, ts->raw_packet_size);\n\n                pcr_pid = pid;\n\n                packet_count[nb_pcrs] = nb_packets;\n\n                pcrs[nb_pcrs] = pcr_h * 300 + pcr_l;\n\n                nb_pcrs++;\n\n                if (nb_pcrs >= 2)\n\n                    break;\n\n            } else {\n\n                finished_reading_packet(s, ts->raw_packet_size);\n\n            }\n\n            nb_packets++;\n\n        }\n\n\n\n        /* NOTE1: the bitrate is computed without the FEC */\n\n        /* NOTE2: it is only the bitrate of the start of the stream */\n\n        ts->pcr_incr = (pcrs[1] - pcrs[0]) / (packet_count[1] - packet_count[0]);\n\n        ts->cur_pcr  = pcrs[0] - ts->pcr_incr * packet_count[0];\n\n        s->bit_rate  = TS_PACKET_SIZE * 8 * 27000000LL / ts->pcr_incr;\n\n        st->codecpar->bit_rate = s->bit_rate;\n\n        st->start_time      = ts->cur_pcr;\n\n        av_log(ts->stream, AV_LOG_TRACE, \"start=%0.3f pcr=%0.3f incr=%d\\n\",\n\n                st->start_time / 1000000.0, pcrs[0] / 27e6, ts->pcr_incr);\n\n    }\n\n\n\n    seek_back(s, pb, pos);\n\n    return 0;\n\n}\n", "idx": 430}
{"project": "qemu", "commit_id": "9a75b0a037e3a8030992244353f17b62f6daf2ab", "target": 1, "func": "static QPCIDevice *get_ahci_device(uint32_t *fingerprint)\n\n{\n\n    QPCIDevice *ahci;\n\n    uint32_t ahci_fingerprint;\n\n    QPCIBus *pcibus;\n\n\n\n    pcibus = qpci_init_pc();\n\n\n\n    /* Find the AHCI PCI device and verify it's the right one. */\n\n    ahci = qpci_device_find(pcibus, QPCI_DEVFN(0x1F, 0x02));\n\n    g_assert(ahci != NULL);\n\n\n\n    ahci_fingerprint = qpci_config_readl(ahci, PCI_VENDOR_ID);\n\n\n\n    switch (ahci_fingerprint) {\n\n    case AHCI_INTEL_ICH9:\n\n        break;\n\n    default:\n\n        /* Unknown device. */\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    if (fingerprint) {\n\n        *fingerprint = ahci_fingerprint;\n\n    }\n\n    return ahci;\n\n}\n", "idx": 431}
{"project": "qemu", "commit_id": "69dd5c9ffd5c0c6a01ad14b9c6a8d7135ccc2b9a", "target": 1, "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    int i;\n\n    uint16_t limit;\n\n\n\n    switch (data[0]) {\n\n    case 0:\n\n\tif (len == 1)\n\n\t    return 20;\n\n\n\n\tset_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n\n\t\t\t read_u8(data, 6), read_u8(data, 7),\n\n\t\t\t read_u16(data, 8), read_u16(data, 10),\n\n\t\t\t read_u16(data, 12), read_u8(data, 14),\n\n\t\t\t read_u8(data, 15), read_u8(data, 16));\n\n\tbreak;\n\n    case 2:\n\n\tif (len == 1)\n\n\t    return 4;\n\n\n\n\tif (len == 4)\n\n\t    return 4 + (read_u16(data, 2) * 4);\n\n\n\n\tlimit = read_u16(data, 2);\n\n\tfor (i = 0; i < limit; i++) {\n\n\t    int32_t val = read_s32(data, 4 + (i * 4));\n\n\t    memcpy(data + 4 + (i * 4), &val, sizeof(val));\n\n\t}\n\n\n\n\tset_encodings(vs, (int32_t *)(data + 4), limit);\n\n\tbreak;\n\n    case 3:\n\n\tif (len == 1)\n\n\t    return 10;\n\n\n\n\tframebuffer_update_request(vs,\n\n\t\t\t\t   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n\n\t\t\t\t   read_u16(data, 6), read_u16(data, 8));\n\n\tbreak;\n\n    case 4:\n\n\tif (len == 1)\n\n\t    return 8;\n\n\n\n\tkey_event(vs, read_u8(data, 1), read_u32(data, 4));\n\n\tbreak;\n\n    case 5:\n\n\tif (len == 1)\n\n\t    return 6;\n\n\n\n\tpointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n\n\tbreak;\n\n    case 6:\n\n\tif (len == 1)\n\n\t    return 8;\n\n\n\n\tif (len == 8) {\n\n            uint32_t dlen = read_u32(data, 4);\n\n            if (dlen > 0)\n\n                return 8 + dlen;\n\n        }\n\n\n\n\tclient_cut_text(vs, read_u32(data, 4), data + 8);\n\n\tbreak;\n\n    case 255:\n\n        if (len == 1)\n\n            return 2;\n\n\n\n        switch (read_u8(data, 1)) {\n\n        case 0:\n\n            if (len == 2)\n\n                return 12;\n\n\n\n            ext_key_event(vs, read_u16(data, 2),\n\n                          read_u32(data, 4), read_u32(data, 8));\n\n            break;\n\n        case 1:\n\n            if (len == 2)\n\n                return 4;\n\n\n\n            switch (read_u16 (data, 2)) {\n\n            case 0:\n\n                audio_add(vs);\n\n                break;\n\n            case 1:\n\n                audio_del(vs);\n\n                break;\n\n            case 2:\n\n                if (len == 4)\n\n                    return 10;\n\n                switch (read_u8(data, 4)) {\n\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n\n                default:\n\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n\n                    vnc_client_error(vs);\n\n                    break;\n\n                }\n\n                vs->as.nchannels = read_u8(data, 5);\n\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n\n                    printf(\"Invalid audio channel coount %d\\n\",\n\n                           read_u8(data, 5));\n\n                    vnc_client_error(vs);\n\n                    break;\n\n                }\n\n                vs->as.freq = read_u32(data, 6);\n\n                break;\n\n            default:\n\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n\n                vnc_client_error(vs);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n\n            vnc_client_error(vs);\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n\tprintf(\"Msg: %d\\n\", data[0]);\n\n\tvnc_client_error(vs);\n\n\tbreak;\n\n    }\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n    return 0;\n\n}\n", "idx": 432}
{"project": "FFmpeg", "commit_id": "2002436b0c914e18eda4f45ef816b14501a1dbae", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n                        AVPacket *avpkt) {\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    AVSubtitle *sub = data;\n    const uint8_t *buf_end = buf + buf_size;\n    uint8_t *bitmap;\n    int w, h, x, y, i, ret;\n    int64_t packet_time = 0;\n    GetBitContext gb;\n    int has_alpha = avctx->codec_tag == MKTAG('D','X','S','A');\n    // check that at least header fits\n    if (buf_size < 27 + 7 * 2 + 4 * (3 + has_alpha)) {\n        av_log(avctx, AV_LOG_ERROR, \"coded frame size %d too small\\n\", buf_size);\n        return -1;\n    }\n    // read start and end time\n    if (buf[0] != '[' || buf[13] != '-' || buf[26] != ']') {\n        av_log(avctx, AV_LOG_ERROR, \"invalid time code\\n\");\n        return -1;\n    }\n    if (avpkt->pts != AV_NOPTS_VALUE)\n        packet_time = av_rescale_q(avpkt->pts, AV_TIME_BASE_Q, (AVRational){1, 1000});\n    sub->start_display_time = parse_timecode(buf +  1, packet_time);\n    sub->end_display_time   = parse_timecode(buf + 14, packet_time);\n    buf += 27;\n    // read header\n    w = bytestream_get_le16(&buf);\n    h = bytestream_get_le16(&buf);\n    if (av_image_check_size(w, h, 0, avctx) < 0)\n        return -1;\n    x = bytestream_get_le16(&buf);\n    y = bytestream_get_le16(&buf);\n    // skip bottom right position, it gives no new information\n    bytestream_get_le16(&buf);\n    bytestream_get_le16(&buf);\n    // The following value is supposed to indicate the start offset\n    // (relative to the palette) of the data for the second field,\n    // however there are files in which it has a bogus value and thus\n    // we just ignore it\n    bytestream_get_le16(&buf);\n    // allocate sub and set values\n    sub->rects =  av_mallocz(sizeof(*sub->rects));\n    if (!sub->rects)\n        return AVERROR(ENOMEM);\n    sub->rects[0] = av_mallocz(sizeof(*sub->rects[0]));\n    if (!sub->rects[0]) {\n        av_freep(&sub->rects);\n        return AVERROR(ENOMEM);\n    }\n    sub->rects[0]->x = x; sub->rects[0]->y = y;\n    sub->rects[0]->w = w; sub->rects[0]->h = h;\n    sub->rects[0]->type = SUBTITLE_BITMAP;\n    sub->rects[0]->linesize[0] = w;\n    sub->rects[0]->data[0] = av_malloc(w * h);\n    sub->rects[0]->nb_colors = 4;\n    sub->rects[0]->data[1] = av_mallocz(AVPALETTE_SIZE);\n    if (!sub->rects[0]->data[0] || !sub->rects[0]->data[1]) {\n        av_freep(&sub->rects[0]->data[1]);\n        av_freep(&sub->rects[0]->data[0]);\n        av_freep(&sub->rects[0]);\n        av_freep(&sub->rects);\n        return AVERROR(ENOMEM);\n    }\n    sub->num_rects = 1;\n    // read palette\n    for (i = 0; i < sub->rects[0]->nb_colors; i++)\n        ((uint32_t*)sub->rects[0]->data[1])[i] = bytestream_get_be24(&buf);\n    if (!has_alpha) {\n        // make all except background (first entry) non-transparent\n        for (i = 1; i < sub->rects[0]->nb_colors; i++)\n            ((uint32_t *)sub->rects[0]->data[1])[i] |= 0xff000000;\n    } else {\n        for (i = 0; i < sub->rects[0]->nb_colors; i++)\n            ((uint32_t *)sub->rects[0]->data[1])[i] |= *buf++ << 24;\n    }\n#if FF_API_AVPICTURE\nFF_DISABLE_DEPRECATION_WARNINGS\n{\n    AVSubtitleRect *rect;\n    int j;\n    rect = sub->rects[0];\n    for (j = 0; j < 4; j++) {\n        rect->pict.data[j] = rect->data[j];\n        rect->pict.linesize[j] = rect->linesize[j];\n    }\n}\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    // process RLE-compressed data\n    if ((ret = init_get_bits8(&gb, buf, buf_end - buf)) < 0)\n        return ret;\n    bitmap = sub->rects[0]->data[0];\n    for (y = 0; y < h; y++) {\n        // interlaced: do odd lines\n        if (y == (h + 1) / 2) bitmap = sub->rects[0]->data[0] + w;\n        for (x = 0; x < w; ) {\n            int log2 = ff_log2_tab[show_bits(&gb, 8)];\n            int run = get_bits(&gb, 14 - 4 * (log2 >> 1));\n            int color = get_bits(&gb, 2);\n            run = FFMIN(run, w - x);\n            // run length 0 means till end of row\n            if (!run) run = w - x;\n            memset(bitmap, color, run);\n            bitmap += run;\n            x += run;\n        }\n        // interlaced, skip every second line\n        bitmap += w;\n        align_get_bits(&gb);\n    }\n    *data_size = 1;\n    return buf_size;\n}", "idx": 433}
{"project": "qemu", "commit_id": "9dfd24ed848228643293e37c36848b5ac520ab98", "target": 1, "func": "static void tpm_tis_initfn(Object *obj)\n\n{\n\n    ISADevice *dev = ISA_DEVICE(obj);\n\n    TPMState *s = TPM(obj);\n\n\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &tpm_tis_memory_ops,\n\n                          s, \"tpm-tis-mmio\",\n\n                          TPM_TIS_NUM_LOCALITIES << TPM_TIS_LOCALITY_SHIFT);\n\n    memory_region_add_subregion(isa_address_space(dev), TPM_TIS_ADDR_BASE,\n\n                                &s->mmio);\n\n}\n", "idx": 434}
{"project": "FFmpeg", "commit_id": "a4d18a3f54e5b0277234d8fcff65dff8516417a0", "target": 1, "func": "static int process_frame(FFFrameSync *fs)\n\n{\n\n    AVFilterContext *ctx = fs->parent;\n\n    LUT2Context *s = fs->opaque;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFrame *out, *srcx, *srcy;\n\n    int ret;\n\n\n\n    if ((ret = ff_framesync2_get_frame(&s->fs, 0, &srcx, 0)) < 0 ||\n\n        (ret = ff_framesync2_get_frame(&s->fs, 1, &srcy, 0)) < 0)\n\n        return ret;\n\n\n\n    if (ctx->is_disabled) {\n\n        out = av_frame_clone(srcx);\n\n        if (!out)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n        if (!out)\n\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(out, srcx);\n\n\n\n        s->lut2(s, out, srcx, srcy);\n\n    }\n\n\n\n    out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, outlink->time_base);\n\n\n\n    return ff_filter_frame(outlink, out);\n\n}\n", "idx": 435}
{"project": "qemu", "commit_id": "6ce310b5356abb7edc3aa8b8b097d0b8cc76f83f", "target": 1, "func": "static int handle_primary_tcp_pkt(NetFilterState *nf,\n\n                                  Connection *conn,\n\n                                  Packet *pkt)\n\n{\n\n    struct tcphdr *tcp_pkt;\n\n\n\n    tcp_pkt = (struct tcphdr *)pkt->transport_header;\n\n    if (trace_event_get_state_backends(TRACE_COLO_FILTER_REWRITER_DEBUG)) {\n\n        trace_colo_filter_rewriter_pkt_info(__func__,\n\n                    inet_ntoa(pkt->ip->ip_src), inet_ntoa(pkt->ip->ip_dst),\n\n                    ntohl(tcp_pkt->th_seq), ntohl(tcp_pkt->th_ack),\n\n                    tcp_pkt->th_flags);\n\n        trace_colo_filter_rewriter_conn_offset(conn->offset);\n\n    }\n\n\n\n    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_SYN)) {\n\n        /*\n\n         * we use this flag update offset func\n\n         * run once in independent tcp connection\n\n         */\n\n        conn->syn_flag = 1;\n\n    }\n\n\n\n    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_ACK)) {\n\n        if (conn->syn_flag) {\n\n            /*\n\n             * offset = secondary_seq - primary seq\n\n             * ack packet sent by guest from primary node,\n\n             * so we use th_ack - 1 get primary_seq\n\n             */\n\n            conn->offset -= (ntohl(tcp_pkt->th_ack) - 1);\n\n            conn->syn_flag = 0;\n\n        }\n\n        if (conn->offset) {\n\n            /* handle packets to the secondary from the primary */\n\n            tcp_pkt->th_ack = htonl(ntohl(tcp_pkt->th_ack) + conn->offset);\n\n\n\n            net_checksum_calculate((uint8_t *)pkt->data, pkt->size);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 437}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold void ff_dsputil_init_armv6(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEARMV6)) {\n\n        c->idct_put              = ff_simple_idct_put_armv6;\n\n        c->idct_add              = ff_simple_idct_add_armv6;\n\n        c->idct                  = ff_simple_idct_armv6;\n\n        c->idct_permutation_type = FF_LIBMPEG2_IDCT_PERM;\n\n    }\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = ff_put_pixels16_armv6;\n\n    c->put_pixels_tab[0][1] = ff_put_pixels16_x2_armv6;\n\n    c->put_pixels_tab[0][2] = ff_put_pixels16_y2_armv6;\n\n/*     c->put_pixels_tab[0][3] = ff_put_pixels16_xy2_armv6; */\n\n    c->put_pixels_tab[1][0] = ff_put_pixels8_armv6;\n\n    c->put_pixels_tab[1][1] = ff_put_pixels8_x2_armv6;\n\n    c->put_pixels_tab[1][2] = ff_put_pixels8_y2_armv6;\n\n/*     c->put_pixels_tab[1][3] = ff_put_pixels8_xy2_armv6; */\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = ff_put_pixels16_armv6;\n\n    c->put_no_rnd_pixels_tab[0][1] = ff_put_pixels16_x2_no_rnd_armv6;\n\n    c->put_no_rnd_pixels_tab[0][2] = ff_put_pixels16_y2_no_rnd_armv6;\n\n/*     c->put_no_rnd_pixels_tab[0][3] = ff_put_pixels16_xy2_no_rnd_armv6; */\n\n    c->put_no_rnd_pixels_tab[1][0] = ff_put_pixels8_armv6;\n\n    c->put_no_rnd_pixels_tab[1][1] = ff_put_pixels8_x2_no_rnd_armv6;\n\n    c->put_no_rnd_pixels_tab[1][2] = ff_put_pixels8_y2_no_rnd_armv6;\n\n/*     c->put_no_rnd_pixels_tab[1][3] = ff_put_pixels8_xy2_no_rnd_armv6; */\n\n\n\n    c->avg_pixels_tab[0][0] = ff_avg_pixels16_armv6;\n\n    c->avg_pixels_tab[1][0] = ff_avg_pixels8_armv6;\n\n    }\n\n\n\n    if (!high_bit_depth)\n\n        c->get_pixels = ff_get_pixels_armv6;\n\n    c->add_pixels_clamped = ff_add_pixels_clamped_armv6;\n\n    c->diff_pixels = ff_diff_pixels_armv6;\n\n\n\n    c->pix_abs[0][0] = ff_pix_abs16_armv6;\n\n    c->pix_abs[0][1] = ff_pix_abs16_x2_armv6;\n\n    c->pix_abs[0][2] = ff_pix_abs16_y2_armv6;\n\n\n\n    c->pix_abs[1][0] = ff_pix_abs8_armv6;\n\n\n\n    c->sad[0] = ff_pix_abs16_armv6;\n\n    c->sad[1] = ff_pix_abs8_armv6;\n\n\n\n    c->sse[0] = ff_sse16_armv6;\n\n\n\n    c->pix_norm1 = ff_pix_norm1_armv6;\n\n    c->pix_sum   = ff_pix_sum_armv6;\n\n}\n", "idx": 438}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int decode_exponents(AC3DecodeContext *ctx)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i;\n\n    uint8_t *exps;\n\n    uint8_t *dexps;\n\n\n\n    if (ab->flags & AC3_AB_CPLINU && ab->cplexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->cplexpstr, ab->ncplgrps, ab->cplabsexp,\n\n                    ab->cplexps, ab->dcplexps + ab->cplstrtmant))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (ab->chexpstr[i] != AC3_EXPSTR_REUSE) {\n\n            exps = ab->exps[i];\n\n            dexps = ab->dexps[i];\n\n            if (_decode_exponents(ab->chexpstr[i], ab->nchgrps[i], exps[0], exps + 1, dexps + 1))\n\n                return -1;\n\n        }\n\n    if (ctx->bsi.flags & AC3_BSI_LFEON && ab->lfeexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->lfeexpstr, 2, ab->lfeexps[0], ab->lfeexps + 1, ab->dlfeexps))\n\n            return -1;\n\n    return 0;\n\n}\n", "idx": 440}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig,\n\n                                  struct emulated_sigtable *k)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    TaskState *ts = cpu->opaque;\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (do_strace) {\n\n        print_taken_signal(sig, &k->info);\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        sigset_t *blocked_set;\n\n\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &ts->signal_mask);\n\n\n\n        /* block signals in the handler */\n\n        blocked_set = ts->in_sigsuspend ?\n\n            &ts->sigsuspend_mask : &ts->signal_mask;\n\n        sigorset(&ts->signal_mask, blocked_set, &set);\n\n        ts->in_sigsuspend = 0;\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n}\n", "idx": 441}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void block_job_yield(BlockJob *job)\n\n{\n\n    assert(job->busy);\n\n\n\n    /* Check cancellation *before* setting busy = false, too!  */\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    job->busy = false;\n\n    if (!block_job_should_pause(job)) {\n\n        qemu_coroutine_yield();\n\n    }\n\n    job->busy = true;\n\n\n\n    block_job_pause_point(job);\n\n}\n", "idx": 442}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static int udp_close(URLContext *h)\n\n{\n\n    UDPContext *s = h->priv_data;\n\n\n\n    if (s->is_multicast && (h->flags & AVIO_FLAG_READ))\n\n        udp_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr,(struct sockaddr *)&s->local_addr_storage);\n\n    closesocket(s->udp_fd);\n\n#if HAVE_PTHREAD_CANCEL\n\n    if (s->thread_started) {\n\n        int ret;\n\n        pthread_cancel(s->circular_buffer_thread);\n\n        ret = pthread_join(s->circular_buffer_thread, NULL);\n\n        if (ret != 0)\n\n            av_log(h, AV_LOG_ERROR, \"pthread_join(): %s\\n\", strerror(ret));\n\n        pthread_mutex_destroy(&s->mutex);\n\n        pthread_cond_destroy(&s->cond);\n\n    }\n\n#endif\n\n    av_fifo_freep(&s->fifo);\n\n    return 0;\n\n}\n", "idx": 445}
{"project": "FFmpeg", "commit_id": "df884e038f5dc95f55ef07500b5b99b722835f8a", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      uint8_t (*layout_map)[3],\n\n                      GetBitContext *gb, int byte_align_ref)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc;\n\n    int sampling_index;\n\n    int comment_len;\n\n    int tags;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Sample rate index in program config element does not \"\n\n               \"match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n    if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decode_pce: \" overread_err);\n\n        return -1;\n\n    }\n\n    decode_channel_map(layout_map       , AAC_CHANNEL_FRONT, gb, num_front);\n\n    tags = num_front;\n\n    decode_channel_map(layout_map + tags, AAC_CHANNEL_SIDE,  gb, num_side);\n\n    tags += num_side;\n\n    decode_channel_map(layout_map + tags, AAC_CHANNEL_BACK,  gb, num_back);\n\n    tags += num_back;\n\n    decode_channel_map(layout_map + tags, AAC_CHANNEL_LFE,   gb, num_lfe);\n\n    tags += num_lfe;\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(layout_map + tags, AAC_CHANNEL_CC,    gb, num_cc);\n\n    tags += num_cc;\n\n\n\n    relative_align_get_bits(gb, byte_align_ref);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decode_pce: \" overread_err);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    skip_bits_long(gb, comment_len);\n\n    return tags;\n\n}\n", "idx": 447}
{"project": "FFmpeg", "commit_id": "919f3554387e043bdfe10c6369356d1104882183", "target": 1, "func": "void ff_decode_dxt1(const uint8_t *s, uint8_t *dst,\n\n                    const unsigned int w, const unsigned int h,\n\n                    const unsigned int stride) {\n\n    unsigned int bx, by, qstride = stride/4;\n\n    uint32_t *d = (uint32_t *) dst;\n\n\n\n    for (by=0; by < h/4; by++, d += stride-w)\n\n        for (bx=0; bx < w/4; bx++, s+=8, d+=4)\n\n            dxt1_decode_pixels(s, d, qstride, 0, 0LL);\n\n}\n", "idx": 448}
{"project": "FFmpeg", "commit_id": "6a4d1c9063174234ca439244cf8f5f534afa1c28", "target": 0, "func": "static const HWAccel *get_hwaccel(enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n    for (i = 0; hwaccels[i].name; i++)\n\n        if (hwaccels[i].pix_fmt == pix_fmt)\n\n            return &hwaccels[i];\n\n    return NULL;\n\n}\n", "idx": 450}
{"project": "qemu", "commit_id": "7157e2e23e89adcd436caeab31fdd6b47eded377", "target": 1, "func": "static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    VirtIODevice *vdev = proxy->vdev;\n\n    target_phys_addr_t pa;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_GUEST_FEATURES:\n\n\t/* Guest does not negotiate properly?  We have to assume nothing. */\n\n\tif (val & (1 << VIRTIO_F_BAD_FEATURE)) {\n\n\t    if (vdev->bad_features)\n\n\t\tval = proxy->host_features & vdev->bad_features(vdev);\n\n\t    else\n\n\t\tval = 0;\n\n\t}\n\n        if (vdev->set_features)\n\n            vdev->set_features(vdev, val);\n\n        vdev->guest_features = val;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_PFN:\n\n        pa = (target_phys_addr_t)val << VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\n        if (pa == 0) {\n\n            virtio_pci_stop_ioeventfd(proxy);\n\n            virtio_reset(proxy->vdev);\n\n            msix_unuse_all_vectors(&proxy->pci_dev);\n\n        }\n\n        else\n\n            virtio_queue_set_addr(vdev, vdev->queue_sel, pa);\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_SEL:\n\n        if (val < VIRTIO_PCI_QUEUE_MAX)\n\n            vdev->queue_sel = val;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_NOTIFY:\n\n        virtio_queue_notify(vdev, val);\n\n        break;\n\n    case VIRTIO_PCI_STATUS:\n\n        if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n            virtio_pci_stop_ioeventfd(proxy);\n\n        }\n\n\n\n        virtio_set_status(vdev, val & 0xFF);\n\n\n\n        if (val & VIRTIO_CONFIG_S_DRIVER_OK) {\n\n            virtio_pci_start_ioeventfd(proxy);\n\n        }\n\n\n\n        if (vdev->status == 0) {\n\n            virtio_reset(proxy->vdev);\n\n            msix_unuse_all_vectors(&proxy->pci_dev);\n\n        }\n\n\n\n        /* Linux before 2.6.34 sets the device as OK without enabling\n\n           the PCI device bus master bit. In this case we need to disable\n\n           some safety checks. */\n\n        if ((val & VIRTIO_CONFIG_S_DRIVER_OK) &&\n\n            !(proxy->pci_dev.config[PCI_COMMAND] & PCI_COMMAND_MASTER)) {\n\n            proxy->flags |= VIRTIO_PCI_FLAG_BUS_MASTER_BUG;\n\n        }\n\n        break;\n\n    case VIRTIO_MSI_CONFIG_VECTOR:\n\n        msix_vector_unuse(&proxy->pci_dev, vdev->config_vector);\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0)\n\n            val = VIRTIO_NO_VECTOR;\n\n        vdev->config_vector = val;\n\n        break;\n\n    case VIRTIO_MSI_QUEUE_VECTOR:\n\n        msix_vector_unuse(&proxy->pci_dev,\n\n                          virtio_queue_vector(vdev, vdev->queue_sel));\n\n        /* Make it possible for guest to discover an error took place. */\n\n        if (msix_vector_use(&proxy->pci_dev, val) < 0)\n\n            val = VIRTIO_NO_VECTOR;\n\n        virtio_queue_set_vector(vdev, vdev->queue_sel, val);\n\n        break;\n\n    default:\n\n        error_report(\"%s: unexpected address 0x%x value 0x%x\",\n\n                     __func__, addr, val);\n\n        break;\n\n    }\n\n}\n", "idx": 451}
{"project": "FFmpeg", "commit_id": "2d9821a2081aff5dca253386c6e7e71a04509cff", "target": 0, "func": "int ff_get_cpu_flags_x86(void)\n\n{\n\n    int rval = 0;\n\n\n\n#ifdef cpuid\n\n\n\n    int eax, ebx, ecx, edx;\n\n    int max_std_level, max_ext_level, std_caps = 0, ext_caps = 0;\n\n    int family = 0, model = 0;\n\n    union { int i[3]; char c[12]; } vendor;\n\n\n\n    if (!cpuid_test())\n\n        return 0; /* CPUID not supported */\n\n\n\n    cpuid(0, max_std_level, vendor.i[0], vendor.i[2], vendor.i[1]);\n\n\n\n    if (max_std_level >= 1) {\n\n        cpuid(1, eax, ebx, ecx, std_caps);\n\n        family = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);\n\n        model  = ((eax >> 4) & 0xf) + ((eax >> 12) & 0xf0);\n\n        if (std_caps & (1 << 15))\n\n            rval |= AV_CPU_FLAG_CMOV;\n\n        if (std_caps & (1 << 23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (std_caps & (1 << 25))\n\n            rval |= AV_CPU_FLAG_MMXEXT;\n\n#if HAVE_SSE\n\n        if (std_caps & (1 << 25))\n\n            rval |= AV_CPU_FLAG_SSE;\n\n        if (std_caps & (1 << 26))\n\n            rval |= AV_CPU_FLAG_SSE2;\n\n        if (ecx & 1)\n\n            rval |= AV_CPU_FLAG_SSE3;\n\n        if (ecx & 0x00000200 )\n\n            rval |= AV_CPU_FLAG_SSSE3;\n\n        if (ecx & 0x00080000 )\n\n            rval |= AV_CPU_FLAG_SSE4;\n\n        if (ecx & 0x00100000 )\n\n            rval |= AV_CPU_FLAG_SSE42;\n\n#if HAVE_AVX\n\n        /* Check OXSAVE and AVX bits */\n\n        if ((ecx & 0x18000000) == 0x18000000) {\n\n            /* Check for OS support */\n\n            xgetbv(0, eax, edx);\n\n            if ((eax & 0x6) == 0x6) {\n\n                rval |= AV_CPU_FLAG_AVX;\n\n                if (ecx & 0x00001000)\n\n                    rval |= AV_CPU_FLAG_FMA3;\n\n            }\n\n        }\n\n#endif /* HAVE_AVX */\n\n#endif /* HAVE_SSE */\n\n    }\n\n    if (max_std_level >= 7) {\n\n        cpuid(7, eax, ebx, ecx, edx);\n\n#if HAVE_AVX2\n\n        if (ebx & 0x00000020)\n\n            rval |= AV_CPU_FLAG_AVX2;\n\n#endif /* HAVE_AVX2 */\n\n        /* BMI1/2 don't need OS support */\n\n        if (ebx & 0x00000008) {\n\n            rval |= AV_CPU_FLAG_BMI1;\n\n            if (ebx & 0x00000100)\n\n                rval |= AV_CPU_FLAG_BMI2;\n\n        }\n\n    }\n\n\n\n    cpuid(0x80000000, max_ext_level, ebx, ecx, edx);\n\n\n\n    if (max_ext_level >= 0x80000001) {\n\n        cpuid(0x80000001, eax, ebx, ecx, ext_caps);\n\n        if (ext_caps & (1U << 31))\n\n            rval |= AV_CPU_FLAG_3DNOW;\n\n        if (ext_caps & (1 << 30))\n\n            rval |= AV_CPU_FLAG_3DNOWEXT;\n\n        if (ext_caps & (1 << 23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (ext_caps & (1 << 22))\n\n            rval |= AV_CPU_FLAG_MMXEXT;\n\n\n\n        /* Allow for selectively disabling SSE2 functions on AMD processors\n\n           with SSE2 support but not SSE4a. This includes Athlon64, some\n\n           Opteron, and some Sempron processors. MMX, SSE, or 3DNow! are faster\n\n           than SSE2 often enough to utilize this special-case flag.\n\n           AV_CPU_FLAG_SSE2 and AV_CPU_FLAG_SSE2SLOW are both set in this case\n\n           so that SSE2 is used unless explicitly disabled by checking\n\n           AV_CPU_FLAG_SSE2SLOW. */\n\n        if (!strncmp(vendor.c, \"AuthenticAMD\", 12) &&\n\n            rval & AV_CPU_FLAG_SSE2 && !(ecx & 0x00000040)) {\n\n            rval |= AV_CPU_FLAG_SSE2SLOW;\n\n        }\n\n\n\n        /* XOP and FMA4 use the AVX instruction coding scheme, so they can't be\n\n         * used unless the OS has AVX support. */\n\n        if (rval & AV_CPU_FLAG_AVX) {\n\n            if (ecx & 0x00000800)\n\n                rval |= AV_CPU_FLAG_XOP;\n\n            if (ecx & 0x00010000)\n\n                rval |= AV_CPU_FLAG_FMA4;\n\n        }\n\n    }\n\n\n\n    if (!strncmp(vendor.c, \"GenuineIntel\", 12)) {\n\n        if (family == 6 && (model == 9 || model == 13 || model == 14)) {\n\n            /* 6/9 (pentium-m \"banias\"), 6/13 (pentium-m \"dothan\"), and\n\n             * 6/14 (core1 \"yonah\") theoretically support sse2, but it's\n\n             * usually slower than mmx, so let's just pretend they don't.\n\n             * AV_CPU_FLAG_SSE2 is disabled and AV_CPU_FLAG_SSE2SLOW is\n\n             * enabled so that SSE2 is not used unless explicitly enabled\n\n             * by checking AV_CPU_FLAG_SSE2SLOW. The same situation\n\n             * applies for AV_CPU_FLAG_SSE3 and AV_CPU_FLAG_SSE3SLOW. */\n\n            if (rval & AV_CPU_FLAG_SSE2)\n\n                rval ^= AV_CPU_FLAG_SSE2SLOW | AV_CPU_FLAG_SSE2;\n\n            if (rval & AV_CPU_FLAG_SSE3)\n\n                rval ^= AV_CPU_FLAG_SSE3SLOW | AV_CPU_FLAG_SSE3;\n\n        }\n\n        /* The Atom processor has SSSE3 support, which is useful in many cases,\n\n         * but sometimes the SSSE3 version is slower than the SSE2 equivalent\n\n         * on the Atom, but is generally faster on other processors supporting\n\n         * SSSE3. This flag allows for selectively disabling certain SSSE3\n\n         * functions on the Atom. */\n\n        if (family == 6 && model == 28)\n\n            rval |= AV_CPU_FLAG_ATOM;\n\n    }\n\n\n\n#endif /* cpuid */\n\n\n\n    return rval;\n\n}\n", "idx": 453}
{"project": "FFmpeg", "commit_id": "41bdd4adc4ab90a5ef7d63050a4046fcba711365", "target": 0, "func": "static int read_sl_header(PESContext *pes, SLConfigDescr *sl, const uint8_t *buf, int buf_size)\n\n{\n\n    GetBitContext gb;\n\n    int au_start_flag = 0, au_end_flag = 0, ocr_flag = 0, idle_flag = 0;\n\n    int padding_flag = 0, padding_bits = 0, inst_bitrate_flag = 0;\n\n    int dts_flag = -1, cts_flag = -1;\n\n    int64_t dts = AV_NOPTS_VALUE, cts = AV_NOPTS_VALUE;\n\n    init_get_bits(&gb, buf, buf_size*8);\n\n\n\n    if (sl->use_au_start)\n\n        au_start_flag = get_bits1(&gb);\n\n    if (sl->use_au_end)\n\n        au_end_flag = get_bits1(&gb);\n\n    if (!sl->use_au_start && !sl->use_au_end)\n\n        au_start_flag = au_end_flag = 1;\n\n    if (sl->ocr_len > 0)\n\n        ocr_flag = get_bits1(&gb);\n\n    if (sl->use_idle)\n\n        idle_flag = get_bits1(&gb);\n\n    if (sl->use_padding)\n\n        padding_flag = get_bits1(&gb);\n\n    if (padding_flag)\n\n        padding_bits = get_bits(&gb, 3);\n\n\n\n    if (!idle_flag && (!padding_flag || padding_bits != 0)) {\n\n        if (sl->packet_seq_num_len)\n\n            skip_bits_long(&gb, sl->packet_seq_num_len);\n\n        if (sl->degr_prior_len)\n\n            if (get_bits1(&gb))\n\n                skip_bits(&gb, sl->degr_prior_len);\n\n        if (ocr_flag)\n\n            skip_bits_long(&gb, sl->ocr_len);\n\n        if (au_start_flag) {\n\n            if (sl->use_rand_acc_pt)\n\n                get_bits1(&gb);\n\n            if (sl->au_seq_num_len > 0)\n\n                skip_bits_long(&gb, sl->au_seq_num_len);\n\n            if (sl->use_timestamps) {\n\n                dts_flag = get_bits1(&gb);\n\n                cts_flag = get_bits1(&gb);\n\n            }\n\n        }\n\n        if (sl->inst_bitrate_len)\n\n            inst_bitrate_flag = get_bits1(&gb);\n\n        if (dts_flag == 1)\n\n            dts = get_bits64(&gb, sl->timestamp_len);\n\n        if (cts_flag == 1)\n\n            cts = get_bits64(&gb, sl->timestamp_len);\n\n        if (sl->au_len > 0)\n\n            skip_bits_long(&gb, sl->au_len);\n\n        if (inst_bitrate_flag)\n\n            skip_bits_long(&gb, sl->inst_bitrate_len);\n\n    }\n\n\n\n    if (dts != AV_NOPTS_VALUE)\n\n        pes->dts = dts;\n\n    if (cts != AV_NOPTS_VALUE)\n\n        pes->pts = cts;\n\n\n\n    avpriv_set_pts_info(pes->st, sl->timestamp_len, 1, sl->timestamp_res);\n\n\n\n    return (get_bits_count(&gb) + 7) >> 3;\n\n}\n", "idx": 454}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "static enum AVHWDeviceType hw_device_match_type_in_name(const char *codec_name)\n\n{\n\n    const char *type_name;\n\n    enum AVHWDeviceType type;\n\n    for (type = av_hwdevice_iterate_types(AV_HWDEVICE_TYPE_NONE);\n\n         type != AV_HWDEVICE_TYPE_NONE;\n\n         type = av_hwdevice_iterate_types(type)) {\n\n        type_name = av_hwdevice_get_type_name(type);\n\n        if (strstr(codec_name, type_name))\n\n            return type;\n\n    }\n\n    return AV_HWDEVICE_TYPE_NONE;\n\n}\n", "idx": 455}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close(AVCodecContext* avc_context)\n\n{\n\n    TheoraContext *h = avc_context->priv_data;\n\n\n\n    th_encode_free(h->t_state);\n\n    av_freep(&h->stats);\n\n    av_freep(&avc_context->coded_frame);\n\n    av_freep(&avc_context->stats_out);\n\n    av_freep(&avc_context->extradata);\n\n    avc_context->extradata_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 456}
{"project": "FFmpeg", "commit_id": "e72662e131e5099e34d5a7519c5690d2fff7b83f", "target": 0, "func": "static int vaapi_encode_h264_init_slice_params(AVCodecContext *avctx,\n\n                                               VAAPIEncodePicture *pic,\n\n                                               VAAPIEncodeSlice *slice)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = pic->codec_picture_params;\n\n    VAEncSliceParameterBufferH264   *vslice = slice->codec_slice_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264Slice            *pslice;\n\n    VAAPIEncodeH264MiscSliceParams  *mslice;\n\n    int i;\n\n\n\n    slice->priv_data = av_mallocz(sizeof(*pslice));\n\n    if (!slice->priv_data)\n\n        return AVERROR(ENOMEM);\n\n    pslice = slice->priv_data;\n\n    mslice = &pslice->misc_slice_params;\n\n\n\n    if (pic->type == PICTURE_TYPE_IDR)\n\n        mslice->nal_unit_type = H264_NAL_IDR_SLICE;\n\n    else\n\n        mslice->nal_unit_type = H264_NAL_SLICE;\n\n\n\n    switch (pic->type) {\n\n    case PICTURE_TYPE_IDR:\n\n        vslice->slice_type  = SLICE_TYPE_I;\n\n        mslice->nal_ref_idc = 3;\n\n        break;\n\n    case PICTURE_TYPE_I:\n\n        vslice->slice_type  = SLICE_TYPE_I;\n\n        mslice->nal_ref_idc = 2;\n\n        break;\n\n    case PICTURE_TYPE_P:\n\n        vslice->slice_type  = SLICE_TYPE_P;\n\n        mslice->nal_ref_idc = 1;\n\n        break;\n\n    case PICTURE_TYPE_B:\n\n        vslice->slice_type  = SLICE_TYPE_B;\n\n        mslice->nal_ref_idc = 0;\n\n        break;\n\n    default:\n\n        av_assert0(0 && \"invalid picture type\");\n\n    }\n\n\n\n    // Only one slice per frame.\n\n    vslice->macroblock_address = 0;\n\n    vslice->num_macroblocks = priv->mb_width * priv->mb_height;\n\n\n\n    vslice->macroblock_info = VA_INVALID_ID;\n\n\n\n    vslice->pic_parameter_set_id = vpic->pic_parameter_set_id;\n\n    vslice->idr_pic_id = priv->idr_pic_count++;\n\n\n\n    vslice->pic_order_cnt_lsb = pic->display_order &\n\n        ((1 << (4 + vseq->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4)) - 1);\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vslice->RefPicList0); i++) {\n\n        vslice->RefPicList0[i].picture_id = VA_INVALID_ID;\n\n        vslice->RefPicList0[i].flags      = VA_PICTURE_H264_INVALID;\n\n        vslice->RefPicList1[i].picture_id = VA_INVALID_ID;\n\n        vslice->RefPicList1[i].flags      = VA_PICTURE_H264_INVALID;\n\n    }\n\n\n\n    av_assert0(pic->nb_refs <= 2);\n\n    if (pic->nb_refs >= 1) {\n\n        // Backward reference for P- or B-frame.\n\n        av_assert0(pic->type == PICTURE_TYPE_P ||\n\n                   pic->type == PICTURE_TYPE_B);\n\n\n\n        vslice->num_ref_idx_l0_active_minus1 = 0;\n\n        vslice->RefPicList0[0] = vpic->ReferenceFrames[0];\n\n    }\n\n    if (pic->nb_refs >= 2) {\n\n        // Forward reference for B-frame.\n\n        av_assert0(pic->type == PICTURE_TYPE_B);\n\n\n\n        vslice->num_ref_idx_l1_active_minus1 = 0;\n\n        vslice->RefPicList1[0] = vpic->ReferenceFrames[1];\n\n    }\n\n\n\n    if (pic->type == PICTURE_TYPE_B)\n\n        vslice->slice_qp_delta = priv->fixed_qp_b - vpic->pic_init_qp;\n\n    else if (pic->type == PICTURE_TYPE_P)\n\n        vslice->slice_qp_delta = priv->fixed_qp_p - vpic->pic_init_qp;\n\n    else\n\n        vslice->slice_qp_delta = priv->fixed_qp_idr - vpic->pic_init_qp;\n\n\n\n    vslice->direct_spatial_mv_pred_flag = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 457}
{"project": "qemu", "commit_id": "c963530a5b3e3e0f7304841adfe84416d82f59f6", "target": 0, "func": "static char *assign_name(NetClientState *nc1, const char *model)\n\n{\n\n    NetClientState *nc;\n\n    char buf[256];\n\n    int id = 0;\n\n\n\n    QTAILQ_FOREACH(nc, &net_clients, next) {\n\n        if (nc == nc1) {\n\n            continue;\n\n        }\n\n        /* For compatibility only bump id for net clients on a vlan */\n\n        if (strcmp(nc->model, model) == 0 &&\n\n            net_hub_id_for_client(nc, NULL) == 0) {\n\n            id++;\n\n        }\n\n    }\n\n\n\n    snprintf(buf, sizeof(buf), \"%s.%d\", model, id);\n\n\n\n    return g_strdup(buf);\n\n}\n", "idx": 458}
{"project": "qemu", "commit_id": "7860a380ac2a9fd09a6e8f31fd9db5318fc91285", "target": 0, "func": "static void nbd_accept(void *opaque)\n\n{\n\n    int server_fd = (uintptr_t) opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addr_len = sizeof(addr);\n\n\n\n    int fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);\n\n    nbd_started = true;\n\n    if (fd >= 0 && nbd_client_new(exp, fd, nbd_client_closed)) {\n\n        nb_fds++;\n\n    }\n\n}\n", "idx": 459}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "static void dma_init2(struct dma_cont *d, int base, int dshift,\n\n                      int page_base, int pageh_base,\n\n                      qemu_irq *cpu_request_exit)\n\n{\n\n    int i;\n\n\n\n    d->dshift = dshift;\n\n    d->cpu_request_exit = cpu_request_exit;\n\n\n\n    memory_region_init_io(&d->channel_io, NULL, &channel_io_ops, d,\n\n                          \"dma-chan\", 8 << d->dshift);\n\n    memory_region_add_subregion(isa_address_space_io(NULL),\n\n                                base, &d->channel_io);\n\n\n\n    isa_register_portio_list(NULL, page_base, page_portio_list, d,\n\n                             \"dma-page\");\n\n    if (pageh_base >= 0) {\n\n        isa_register_portio_list(NULL, pageh_base, pageh_portio_list, d,\n\n                                 \"dma-pageh\");\n\n    }\n\n\n\n    memory_region_init_io(&d->cont_io, NULL, &cont_io_ops, d, \"dma-cont\",\n\n                          8 << d->dshift);\n\n    memory_region_add_subregion(isa_address_space_io(NULL),\n\n                                base + (8 << d->dshift), &d->cont_io);\n\n\n\n    qemu_register_reset(dma_reset, d);\n\n    dma_reset(d);\n\n    for (i = 0; i < ARRAY_SIZE (d->regs); ++i) {\n\n        d->regs[i].transfer_handler = dma_phony_handler;\n\n    }\n\n}\n", "idx": 460}
{"project": "qemu", "commit_id": "4c8ae0f60e63478aea0a1741cca95474b68fb949", "target": 0, "func": "static inline bool migration_bitmap_test_and_reset_dirty(MemoryRegion *mr,\n\n                                                         ram_addr_t offset)\n\n{\n\n    bool ret;\n\n    int nr = (mr->ram_addr + offset) >> TARGET_PAGE_BITS;\n\n\n\n    ret = test_and_clear_bit(nr, migration_bitmap);\n\n\n\n    if (ret) {\n\n        migration_dirty_pages--;\n\n    }\n\n    return ret;\n\n}\n", "idx": 462}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bge(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_V(cpu_tmp0, src);\n\n    gen_mov_reg_N(dst, src);\n\n    tcg_gen_xor_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 463}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static int qcow_set_key(BlockDriverState *bs, const char *key)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint8_t keybuf[16];\n\n    int len, i;\n\n    Error *err;\n\n\n\n    memset(keybuf, 0, 16);\n\n    len = strlen(key);\n\n    if (len > 16)\n\n        len = 16;\n\n    /* XXX: we could compress the chars to 7 bits to increase\n\n       entropy */\n\n    for(i = 0;i < len;i++) {\n\n        keybuf[i] = key[i];\n\n    }\n\n    assert(bs->encrypted);\n\n\n\n    qcrypto_cipher_free(s->cipher);\n\n    s->cipher = qcrypto_cipher_new(\n\n        QCRYPTO_CIPHER_ALG_AES_128,\n\n        QCRYPTO_CIPHER_MODE_CBC,\n\n        keybuf, G_N_ELEMENTS(keybuf),\n\n        &err);\n\n\n\n    if (!s->cipher) {\n\n        /* XXX would be nice if errors in this method could\n\n         * be properly propagate to the caller. Would need\n\n         * the bdrv_set_key() API signature to be fixed. */\n\n        error_free(err);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 464}
{"project": "qemu", "commit_id": "0fada67420e29f389119ca6f44285203400e0730", "target": 0, "func": "int vhost_dev_init(struct vhost_dev *hdev, int devfd, const char *devpath,\n\n                   bool force)\n\n{\n\n    uint64_t features;\n\n    int r;\n\n    if (devfd >= 0) {\n\n        hdev->control = devfd;\n\n    } else {\n\n        hdev->control = open(devpath, O_RDWR);\n\n        if (hdev->control < 0) {\n\n            return -errno;\n\n        }\n\n    }\n\n    r = ioctl(hdev->control, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = ioctl(hdev->control, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    memory_listener_register(&hdev->memory_listener, NULL);\n\n    hdev->force = force;\n\n    return 0;\n\nfail:\n\n    r = -errno;\n\n    close(hdev->control);\n\n    return r;\n\n}\n", "idx": 465}
{"project": "qemu", "commit_id": "cfaadf0e89e7c2a47462d5f96390c9a9b4de037c", "target": 0, "func": "static void fw_cfg_mem_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgMemState *s = FW_CFG_MEM(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    memory_region_init_io(&s->ctl_iomem, OBJECT(s), &fw_cfg_ctl_mem_ops,\n\n                          FW_CFG(s), \"fwcfg.ctl\", FW_CFG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->ctl_iomem);\n\n\n\n    memory_region_init_io(&s->data_iomem, OBJECT(s), &fw_cfg_data_mem_ops,\n\n                          FW_CFG(s), \"fwcfg.data\",\n\n                          fw_cfg_data_mem_ops.valid.max_access_size);\n\n    sysbus_init_mmio(sbd, &s->data_iomem);\n\n}\n", "idx": 466}
{"project": "FFmpeg", "commit_id": "8b573ddda75980f724f779ff75aacc2ff81d9e0e", "target": 0, "func": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n\n                                int nPbW, int nPbH,\n\n                                int log2_cb_size, int partIdx)\n\n{\n\n#define POS(c_idx, x, y)                                                              \\\n\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int merge_idx = 0;\n\n    struct MvField current_mv = {{{ 0 }}};\n\n\n\n    int min_pu_width = s->sps->min_pu_width;\n\n\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n\n    RefPicList  *refPicList = s->ref->refPicList;\n\n    HEVCFrame *ref0, *ref1;\n\n\n\n    int tmpstride = MAX_PB_SIZE;\n\n\n\n    uint8_t *dst0 = POS(0, x0, y0);\n\n    uint8_t *dst1 = POS(1, x0, y0);\n\n    uint8_t *dst2 = POS(2, x0, y0);\n\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n\n    int min_cb_width     = s->sps->min_cb_width;\n\n    int x_cb             = x0 >> log2_min_cb_size;\n\n    int y_cb             = y0 >> log2_min_cb_size;\n\n    int x_pu, y_pu;\n\n    int i, j;\n\n\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n\n\n    if (!skip_flag)\n\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n\n\n    if (skip_flag || lc->pu.merge_flag) {\n\n        if (s->sh.max_num_merge_cand > 1)\n\n            merge_idx = ff_hevc_merge_idx_decode(s);\n\n        else\n\n            merge_idx = 0;\n\n\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                   partIdx, merge_idx, &current_mv);\n\n    } else {\n\n        enum InterPredIdc inter_pred_idc = PRED_L0;\n\n        int mvp_flag;\n\n\n\n        ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n        if (s->sh.slice_type == B_SLICE)\n\n            inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH);\n\n\n\n        if (inter_pred_idc != PRED_L1) {\n\n            if (s->sh.nb_refs[L0]) {\n\n                current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]);\n\n            }\n\n            current_mv.pred_flag[0] = 1;\n\n            hls_mvd_coding(s, x0, y0, 0);\n\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                     partIdx, merge_idx, &current_mv,\n\n                                     mvp_flag, 0);\n\n            current_mv.mv[0].x += lc->pu.mvd.x;\n\n            current_mv.mv[0].y += lc->pu.mvd.y;\n\n        }\n\n\n\n        if (inter_pred_idc != PRED_L0) {\n\n            if (s->sh.nb_refs[L1]) {\n\n                current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]);\n\n            }\n\n\n\n            if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) {\n\n                AV_ZERO32(&lc->pu.mvd);\n\n            } else {\n\n                hls_mvd_coding(s, x0, y0, 1);\n\n            }\n\n\n\n            current_mv.pred_flag[1] = 1;\n\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                     partIdx, merge_idx, &current_mv,\n\n                                     mvp_flag, 1);\n\n            current_mv.mv[1].x += lc->pu.mvd.x;\n\n            current_mv.mv[1].y += lc->pu.mvd.y;\n\n        }\n\n    }\n\n\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n\n\n    if (current_mv.pred_flag[0]) {\n\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        if (!ref0)\n\n            return;\n\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n\n    }\n\n    if (current_mv.pred_flag[1]) {\n\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref1)\n\n            return;\n\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n\n    }\n\n\n\n    if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) {\n\n        DECLARE_ALIGNED(16, int16_t,  tmp[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n\n                                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                                     s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n\n                                     dst0, s->frame->linesize[0], tmp,\n\n                                     tmpstride, nPbW, nPbH);\n\n        } else {\n\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n\n        }\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n\n                                     dst1, s->frame->linesize[1], tmp, tmpstride,\n\n                                     nPbW / 2, nPbH / 2);\n\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride,\n\n                                     nPbW / 2, nPbH / 2);\n\n        } else {\n\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n\n        }\n\n    } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n\n\n        if (!ref1)\n\n            return;\n\n\n\n        luma_mc(s, tmp, tmpstride, ref1->frame,\n\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n\n                                      s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                                      s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n\n                                      dst0, s->frame->linesize[0], tmp, tmpstride,\n\n                                      nPbW, nPbH);\n\n        } else {\n\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n\n        }\n\n\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame,\n\n                  &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n\n                                     dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n\n        } else {\n\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n\n        }\n\n    } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        HEVCFrame *ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        HEVCFrame *ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n\n\n        if (!ref0 || !ref1)\n\n            return;\n\n\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n\n        luma_mc(s, tmp2, tmpstride, ref1->frame,\n\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom,\n\n                                         s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                                         s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                                         s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n\n                                         s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n\n                                         dst0, s->frame->linesize[0],\n\n                                         tmp, tmp2, tmpstride, nPbW, nPbH);\n\n        } else {\n\n            s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0],\n\n                                             tmp, tmp2, tmpstride, nPbW, nPbH);\n\n        }\n\n\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n        chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame,\n\n                  &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n\n                                         dst1, s->frame->linesize[1], tmp, tmp3,\n\n                                         tmpstride, nPbW / 2, nPbH / 2);\n\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n\n                                         dst2, s->frame->linesize[2], tmp2, tmp4,\n\n                                         tmpstride, nPbW / 2, nPbH / 2);\n\n        } else {\n\n            s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2);\n\n            s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2);\n\n        }\n\n    }\n\n}\n", "idx": 467}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static void select_soundhw (const char *optarg)\n\n{\n\n    struct soundhw *c;\n\n\n\n    if (*optarg == '?') {\n\n    show_valid_cards:\n\n\n\n        printf (\"Valid sound card names (comma separated):\\n\");\n\n        for (c = soundhw; c->name; ++c) {\n\n            printf (\"%-11s %s\\n\", c->name, c->descr);\n\n        }\n\n        printf (\"\\n-soundhw all will enable all of the above\\n\");\n\n        exit (*optarg != '?');\n\n    }\n\n    else {\n\n        size_t l;\n\n        const char *p;\n\n        char *e;\n\n        int bad_card = 0;\n\n\n\n        if (!strcmp (optarg, \"all\")) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                c->enabled = 1;\n\n            }\n\n            return;\n\n        }\n\n\n\n        p = optarg;\n\n        while (*p) {\n\n            e = strchr (p, ',');\n\n            l = !e ? strlen (p) : (size_t) (e - p);\n\n\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (!strncmp (c->name, p, l) && !c->name[l]) {\n\n                    c->enabled = 1;\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (!c->name) {\n\n                if (l > 80) {\n\n                    fprintf (stderr,\n\n                             \"Unknown sound card name (too big to show)\\n\");\n\n                }\n\n                else {\n\n                    fprintf (stderr, \"Unknown sound card name `%.*s'\\n\",\n\n                             (int) l, p);\n\n                }\n\n                bad_card = 1;\n\n            }\n\n            p += l + (e != NULL);\n\n        }\n\n\n\n        if (bad_card)\n\n            goto show_valid_cards;\n\n    }\n\n}\n", "idx": 468}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_bus_reset(IDEBus *bus)\n\n{\n\n    bus->unit = 0;\n\n    bus->cmd = 0;\n\n    ide_reset(&bus->ifs[0]);\n\n    ide_reset(&bus->ifs[1]);\n\n    ide_clear_hob(bus);\n\n\n\n    /* pending async DMA */\n\n    if (bus->dma->aiocb) {\n\n#ifdef DEBUG_AIO\n\n        printf(\"aio_cancel\\n\");\n\n#endif\n\n        bdrv_aio_cancel(bus->dma->aiocb);\n\n        bus->dma->aiocb = NULL;\n\n    }\n\n\n\n    /* reset dma provider too */\n\n    if (bus->dma->ops->reset) {\n\n        bus->dma->ops->reset(bus->dma);\n\n    }\n\n}\n", "idx": 469}
{"project": "qemu", "commit_id": "242acf3af4605adce933906bdc053b2414181ec7", "target": 0, "func": "if_start(void)\n\n{\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output())\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (if_fastq.ifq_next != &if_fastq) {\n\n\t\tifm = if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (next_m != &if_batchq)\n\n\t\t   ifm = next_m;\n\n\t\telse\n\n\t\t   ifm = if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tnext_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\t--if_queued;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n\t/* Encapsulate the packet for sending */\n\n        if_encap(ifm->m_data, ifm->m_len);\n\n\n\n        m_free(ifm);\n\n\n\n\tif (if_queued)\n\n\t   goto again;\n\n}\n", "idx": 470}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MacIONVRAMState *macio_nvram_init (target_phys_addr_t size,\n\n                                   unsigned int it_shift)\n\n{\n\n    MacIONVRAMState *s;\n\n\n\n    s = g_malloc0(sizeof(MacIONVRAMState));\n\n    s->data = g_malloc0(size);\n\n    s->size = size;\n\n    s->it_shift = it_shift;\n\n\n\n    memory_region_init_io(&s->mem, &macio_nvram_ops, s, \"macio-nvram\",\n\n                          size << it_shift);\n\n    vmstate_register(NULL, -1, &vmstate_macio_nvram, s);\n\n    qemu_register_reset(macio_nvram_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 471}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cmd646_data_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (size == 1) {\n\n        ide_ioport_write(cmd646bar->bus, addr, data);\n\n    } else if (addr == 0) {\n\n        if (size == 2) {\n\n            ide_data_writew(cmd646bar->bus, addr, data);\n\n        } else {\n\n            ide_data_writel(cmd646bar->bus, addr, data);\n\n        }\n\n    }\n\n}\n", "idx": 472}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t kvm_apic_mem_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    return ~(uint64_t)0;\n\n}\n", "idx": 473}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t bonito_cop_readl(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    uint32_t val;\n\n    PCIBonitoState *s = opaque;\n\n\n\n    val = ((uint32_t *)(&s->boncop))[addr/sizeof(uint32_t)];\n\n\n\n    return val;\n\n}\n", "idx": 475}
{"project": "qemu", "commit_id": "2278a69e7020d86a8c73a28474e7709d3e7d5081", "target": 0, "func": "size_t iov_memset(const struct iovec *iov, const unsigned int iov_cnt,\n\n                 size_t iov_off, int fillc, size_t size)\n\n{\n\n    size_t iovec_off, buf_off;\n\n    unsigned int i;\n\n\n\n    iovec_off = 0;\n\n    buf_off = 0;\n\n    for (i = 0; i < iov_cnt && size; i++) {\n\n        if (iov_off < (iovec_off + iov[i].iov_len)) {\n\n            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n\n\n\n            memset(iov[i].iov_base + (iov_off - iovec_off), fillc, len);\n\n\n\n            buf_off += len;\n\n            iov_off += len;\n\n            size -= len;\n\n        }\n\n        iovec_off += iov[i].iov_len;\n\n    }\n\n    return buf_off;\n\n}\n", "idx": 476}
{"project": "qemu", "commit_id": "4ef130fca87b7a8c77e1af9ca967f28b683811d7", "target": 0, "func": "static int img_open_password(BlockBackend *blk, const char *filename,\n\n                             int flags, bool quiet)\n\n{\n\n    BlockDriverState *bs;\n\n    char password[256];\n\n\n\n    bs = blk_bs(blk);\n\n    if (bdrv_is_encrypted(bs) && !(flags & BDRV_O_NO_IO)) {\n\n        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            return -1;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 477}
{"project": "FFmpeg", "commit_id": "c9b3c0c740ac912c835ccb7179afc2c5da8d5d23", "target": 0, "func": "void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n\n{\n\n    const char *codec_name;\n\n    AVCodec *p;\n\n    char buf1[32];\n\n    int bitrate;\n\n    AVRational display_aspect_ratio;\n\n\n\n    if (encode)\n\n        p = avcodec_find_encoder(enc->codec_id);\n\n    else\n\n        p = avcodec_find_decoder(enc->codec_id);\n\n\n\n    if (p) {\n\n        codec_name = p->name;\n\n        if (!encode && enc->codec_id == CODEC_ID_MP3) {\n\n            if (enc->sub_id == 2)\n\n                codec_name = \"mp2\";\n\n            else if (enc->sub_id == 1)\n\n                codec_name = \"mp1\";\n\n        }\n\n    } else if (enc->codec_id == CODEC_ID_MPEG2TS) {\n\n        /* fake mpeg2 transport stream codec (currently not\n\n           registered) */\n\n        codec_name = \"mpeg2ts\";\n\n    } else if (enc->codec_name[0] != '\\0') {\n\n        codec_name = enc->codec_name;\n\n    } else {\n\n        /* output avi tags */\n\n        if(   isprint(enc->codec_tag&0xFF) && isprint((enc->codec_tag>>8)&0xFF)\n\n           && isprint((enc->codec_tag>>16)&0xFF) && isprint((enc->codec_tag>>24)&0xFF)){\n\n            snprintf(buf1, sizeof(buf1), \"%c%c%c%c / 0x%04X\",\n\n                     enc->codec_tag & 0xff,\n\n                     (enc->codec_tag >> 8) & 0xff,\n\n                     (enc->codec_tag >> 16) & 0xff,\n\n                     (enc->codec_tag >> 24) & 0xff,\n\n                      enc->codec_tag);\n\n        } else {\n\n            snprintf(buf1, sizeof(buf1), \"0x%04x\", enc->codec_tag);\n\n        }\n\n        codec_name = buf1;\n\n    }\n\n\n\n    switch(enc->codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        snprintf(buf, buf_size,\n\n                 \"Video: %s%s\",\n\n                 codec_name, enc->mb_decision ? \" (hq)\" : \"\");\n\n        if (enc->pix_fmt != PIX_FMT_NONE) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %s\",\n\n                     avcodec_get_pix_fmt_name(enc->pix_fmt));\n\n        }\n\n        if (enc->width) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %dx%d\",\n\n                     enc->width, enc->height);\n\n            if (enc->sample_aspect_ratio.num) {\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          enc->width*enc->sample_aspect_ratio.num,\n\n                          enc->height*enc->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \" [PAR %d:%d DAR %d:%d]\",\n\n                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,\n\n                         display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            if(av_log_get_level() >= AV_LOG_DEBUG){\n\n                int g= ff_gcd(enc->time_base.num, enc->time_base.den);\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %d/%d\",\n\n                     enc->time_base.num/g, enc->time_base.den/g);\n\n            }\n\n        }\n\n        if (encode) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", q=%d-%d\", enc->qmin, enc->qmax);\n\n        }\n\n        bitrate = enc->bit_rate;\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        snprintf(buf, buf_size,\n\n                 \"Audio: %s\",\n\n                 codec_name);\n\n        if (enc->sample_rate) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %d Hz\", enc->sample_rate);\n\n        }\n\n        av_strlcat(buf, \", \", buf_size);\n\n        avcodec_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n\n        if (enc->sample_fmt != SAMPLE_FMT_NONE) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %s\", avcodec_get_sample_fmt_name(enc->sample_fmt));\n\n        }\n\n\n\n        /* for PCM codecs, compute bitrate directly */\n\n        switch(enc->codec_id) {\n\n        case CODEC_ID_PCM_F64BE:\n\n        case CODEC_ID_PCM_F64LE:\n\n            bitrate = enc->sample_rate * enc->channels * 64;\n\n            break;\n\n        case CODEC_ID_PCM_S32LE:\n\n        case CODEC_ID_PCM_S32BE:\n\n        case CODEC_ID_PCM_U32LE:\n\n        case CODEC_ID_PCM_U32BE:\n\n        case CODEC_ID_PCM_F32BE:\n\n        case CODEC_ID_PCM_F32LE:\n\n            bitrate = enc->sample_rate * enc->channels * 32;\n\n            break;\n\n        case CODEC_ID_PCM_S24LE:\n\n        case CODEC_ID_PCM_S24BE:\n\n        case CODEC_ID_PCM_U24LE:\n\n        case CODEC_ID_PCM_U24BE:\n\n        case CODEC_ID_PCM_S24DAUD:\n\n            bitrate = enc->sample_rate * enc->channels * 24;\n\n            break;\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_S16LE_PLANAR:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            bitrate = enc->sample_rate * enc->channels * 16;\n\n            break;\n\n        case CODEC_ID_PCM_S8:\n\n        case CODEC_ID_PCM_U8:\n\n        case CODEC_ID_PCM_ALAW:\n\n        case CODEC_ID_PCM_MULAW:\n\n        case CODEC_ID_PCM_ZORK:\n\n            bitrate = enc->sample_rate * enc->channels * 8;\n\n            break;\n\n        default:\n\n            bitrate = enc->bit_rate;\n\n            break;\n\n        }\n\n        break;\n\n    case CODEC_TYPE_DATA:\n\n        snprintf(buf, buf_size, \"Data: %s\", codec_name);\n\n        bitrate = enc->bit_rate;\n\n        break;\n\n    case CODEC_TYPE_SUBTITLE:\n\n        snprintf(buf, buf_size, \"Subtitle: %s\", codec_name);\n\n        bitrate = enc->bit_rate;\n\n        break;\n\n    case CODEC_TYPE_ATTACHMENT:\n\n        snprintf(buf, buf_size, \"Attachment: %s\", codec_name);\n\n        bitrate = enc->bit_rate;\n\n        break;\n\n    default:\n\n        snprintf(buf, buf_size, \"Invalid Codec type %d\", enc->codec_type);\n\n        return;\n\n    }\n\n    if (encode) {\n\n        if (enc->flags & CODEC_FLAG_PASS1)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", pass 1\");\n\n        if (enc->flags & CODEC_FLAG_PASS2)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", pass 2\");\n\n    }\n\n    if (bitrate != 0) {\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \", %d kb/s\", bitrate / 1000);\n\n    }\n\n}\n", "idx": 478}
{"project": "FFmpeg", "commit_id": "2c474ddbc5b90541ea4a65961490b6469d12529f", "target": 0, "func": "static int transcode_init(OutputFile *output_files,\n\n                          int nb_output_files,\n\n                          InputFile *input_files,\n\n                          int nb_input_files)\n\n{\n\n    int ret = 0, i, j;\n\n    AVFormatContext *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int want_sdp = 1;\n\n\n\n    /* init framerate emulation */\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        InputFile *ifile = &input_files[i];\n\n        if (ifile->rate_emu)\n\n            for (j = 0; j < ifile->nb_streams; j++)\n\n                input_streams[j + ifile->ist_index].start = av_gettime();\n\n    }\n\n\n\n    /* output stream init */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i].ctx;\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(os, i, os->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            return AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        ost = &output_streams[i];\n\n        os = output_files[ost->file_index].ctx;\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX) {\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata) {\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    exit_program(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if (!ost->fifo) {\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels)\n\n                    codec->channels = icodec->channels;\n\n                codec->channel_layout = icodec->channel_layout;\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    exit_program(1);\n\n                }\n\n\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n#if !CONFIG_AVFILTER\n\n                    avcodec_get_frame_defaults(&ost->pict_tmp);\n\n                    if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,\n\n                                       codec->width, codec->height)) {\n\n                        fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                    ost->img_resample_ctx = sws_getContext(\n\n                        icodec->width,\n\n                        icodec->height,\n\n                        icodec->pix_fmt,\n\n                        codec->width,\n\n                        codec->height,\n\n                        codec->pix_fmt,\n\n                        ost->sws_flags, NULL, NULL, NULL);\n\n                    if (ost->img_resample_ctx == NULL) {\n\n                        fprintf(stderr, \"Cannot get resampling context\\n\");\n\n                        exit_program(1);\n\n                    }\n\n#endif\n\n                    codec->bits_per_raw_sample= 0;\n\n                }\n\n\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        exit_program(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        exit_program(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 200);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    /* open each encoder */\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        ost = &output_streams[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits/s as argument, not kbits/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    /* init input streams */\n\n    for (i = 0; i < nb_input_streams; i++)\n\n        if ((ret = init_input_stream(i, output_streams, nb_output_streams, error, sizeof(error))) < 0)\n\n            goto dump_format;\n\n\n\n    /* open files and write file headers */\n\n    for (i = 0; i < nb_output_files; i++) {\n\n        os = output_files[i].ctx;\n\n        if (avformat_write_header(os, &output_files[i].opts) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_files[i].opts);\n\n        if (strcmp(os->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i].ctx, i, output_files[i].ctx->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for (i = 0; i < nb_output_streams;i ++) {\n\n            ost = &output_streams[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            if (ost->st->stream_copy)\n\n                fprintf(stderr, \" (copy)\");\n\n            else\n\n                fprintf(stderr, \" (%s -> %s)\", input_streams[ost->source_index].dec ?\n\n                        input_streams[ost->source_index].dec->name : \"?\",\n\n                        ost->enc ? ost->enc->name : \"?\");\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        return ret;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 479}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n\n{\n\n    LavfiContext *lavfi = avctx->priv_data;\n\n    double min_pts = DBL_MAX;\n\n    int stream_idx, min_pts_sink_idx = 0;\n\n    AVFrame *frame = lavfi->decoded_frame;\n\n    AVPicture pict;\n\n    AVDictionary *frame_metadata;\n\n    int ret, i;\n\n    int size = 0;\n\n\n\n    if (lavfi->subcc_packet.size) {\n\n        *pkt = lavfi->subcc_packet;\n\n        av_init_packet(&lavfi->subcc_packet);\n\n        lavfi->subcc_packet.size = 0;\n\n        lavfi->subcc_packet.data = NULL;\n\n        return pkt->size;\n\n    }\n\n\n\n    /* iterate through all the graph sinks. Select the sink with the\n\n     * minimum PTS */\n\n    for (i = 0; i < lavfi->nb_sinks; i++) {\n\n        AVRational tb = lavfi->sinks[i]->inputs[0]->time_base;\n\n        double d;\n\n        int ret;\n\n\n\n        if (lavfi->sink_eof[i])\n\n            continue;\n\n\n\n        ret = av_buffersink_get_frame_flags(lavfi->sinks[i], frame,\n\n                                            AV_BUFFERSINK_FLAG_PEEK);\n\n        if (ret == AVERROR_EOF) {\n\n            av_dlog(avctx, \"EOF sink_idx:%d\\n\", i);\n\n            lavfi->sink_eof[i] = 1;\n\n            continue;\n\n        } else if (ret < 0)\n\n            return ret;\n\n        d = av_rescale_q_rnd(frame->pts, tb, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);\n\n        av_dlog(avctx, \"sink_idx:%d time:%f\\n\", i, d);\n\n        av_frame_unref(frame);\n\n\n\n        if (d < min_pts) {\n\n            min_pts = d;\n\n            min_pts_sink_idx = i;\n\n        }\n\n    }\n\n    if (min_pts == DBL_MAX)\n\n        return AVERROR_EOF;\n\n\n\n    av_dlog(avctx, \"min_pts_sink_idx:%i\\n\", min_pts_sink_idx);\n\n\n\n    av_buffersink_get_frame_flags(lavfi->sinks[min_pts_sink_idx], frame, 0);\n\n    stream_idx = lavfi->sink_stream_map[min_pts_sink_idx];\n\n\n\n    if (frame->width /* FIXME best way of testing a video */) {\n\n        size = avpicture_get_size(frame->format, frame->width, frame->height);\n\n        if ((ret = av_new_packet(pkt, size)) < 0)\n\n            return ret;\n\n\n\n        memcpy(pict.data,     frame->data,     4*sizeof(frame->data[0]));\n\n        memcpy(pict.linesize, frame->linesize, 4*sizeof(frame->linesize[0]));\n\n\n\n        avpicture_layout(&pict, frame->format, frame->width, frame->height,\n\n                         pkt->data, size);\n\n    } else if (av_frame_get_channels(frame) /* FIXME test audio */) {\n\n        size = frame->nb_samples * av_get_bytes_per_sample(frame->format) *\n\n                                   av_frame_get_channels(frame);\n\n        if ((ret = av_new_packet(pkt, size)) < 0)\n\n            return ret;\n\n        memcpy(pkt->data, frame->data[0], size);\n\n    }\n\n\n\n    frame_metadata = av_frame_get_metadata(frame);\n\n    if (frame_metadata) {\n\n        uint8_t *metadata;\n\n        AVDictionaryEntry *e = NULL;\n\n        AVBPrint meta_buf;\n\n\n\n        av_bprint_init(&meta_buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n        while ((e = av_dict_get(frame_metadata, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n\n            av_bprintf(&meta_buf, \"%s\", e->key);\n\n            av_bprint_chars(&meta_buf, '\\0', 1);\n\n            av_bprintf(&meta_buf, \"%s\", e->value);\n\n            av_bprint_chars(&meta_buf, '\\0', 1);\n\n        }\n\n        if (!av_bprint_is_complete(&meta_buf) ||\n\n            !(metadata = av_packet_new_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA,\n\n                                                 meta_buf.len))) {\n\n            av_bprint_finalize(&meta_buf, NULL);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(metadata, meta_buf.str, meta_buf.len);\n\n        av_bprint_finalize(&meta_buf, NULL);\n\n    }\n\n\n\n    if ((ret = create_subcc_packet(avctx, frame, min_pts_sink_idx)) < 0) {\n\n        av_frame_unref(frame);\n\n        av_packet_unref(pkt);\n\n        return ret;\n\n    }\n\n\n\n    pkt->stream_index = stream_idx;\n\n    pkt->pts = frame->pts;\n\n    pkt->pos = av_frame_get_pkt_pos(frame);\n\n    pkt->size = size;\n\n    av_frame_unref(frame);\n\n    return size;\n\n}\n", "idx": 480}
{"project": "qemu", "commit_id": "2f78e491d7b46542158ce0b8132ee4e05bc0ade4", "target": 1, "func": "static void iothread_complete(UserCreatable *obj, Error **errp)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread->stopping = false;\n\n    iothread->ctx = aio_context_new();\n\n    iothread->thread_id = -1;\n\n\n\n    qemu_mutex_init(&iothread->init_done_lock);\n\n    qemu_cond_init(&iothread->init_done_cond);\n\n\n\n    /* This assumes we are called from a thread with useful CPU affinity for us\n\n     * to inherit.\n\n     */\n\n    qemu_thread_create(&iothread->thread, \"iothread\", iothread_run,\n\n                       iothread, QEMU_THREAD_JOINABLE);\n\n\n\n    /* Wait for initialization to complete */\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    while (iothread->thread_id == -1) {\n\n        qemu_cond_wait(&iothread->init_done_cond,\n\n                       &iothread->init_done_lock);\n\n    }\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n}\n", "idx": 481}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbre_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    switch (rB(ctx->opcode)) {\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        {\n\n            TCGv_i32 t0 = tcg_const_i32(rB(ctx->opcode));\n\n            gen_helper_440_tlbre(cpu_gpr[rD(ctx->opcode)], cpu_env,\n\n                                 t0, cpu_gpr[rA(ctx->opcode)]);\n\n            tcg_temp_free_i32(t0);\n\n        }\n\n        break;\n\n    default:\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        break;\n\n    }\n\n#endif\n\n}\n", "idx": 482}
{"project": "qemu", "commit_id": "9ed5726c043958359b0f1fa44ab3e4f25f9d9a47", "target": 1, "func": "target_ulong helper_evpe(target_ulong arg1)\n\n{\n\n    // TODO\n\n    arg1 = 0;\n\n    // rt = arg1\n\n\n\n    return arg1;\n\n}\n", "idx": 483}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "void helper_ldmxcsr(CPUX86State *env, uint32_t val)\n\n{\n\n    env->mxcsr = val;\n\n    update_sse_status(env);\n\n}\n", "idx": 484}
{"project": "FFmpeg", "commit_id": "629750290f6122a72e68c34cf94f521a90def2ef", "target": 1, "func": "void ff_snow_horizontal_compose97i_mmx(IDWTELEM *b, int width){\n\n    const int w2= (width+1)>>1;\n\n    IDWTELEM temp[width >> 1];\n\n    const int w_l= (width>>1);\n\n    const int w_r= w2 - 1;\n\n    int i;\n\n\n\n    { // Lift 0\n\n        IDWTELEM * const ref = b + w2 - 1;\n\n\n\n        i = 1;\n\n        b[0] = b[0] - ((W_DM * 2 * ref[1]+W_DO)>>W_DS);\n\n        asm volatile(\n\n            \"pcmpeqw    %%mm7, %%mm7         \\n\\t\"\n\n            \"psllw        $15, %%mm7         \\n\\t\"\n\n            \"psrlw        $14, %%mm7         \\n\\t\"\n\n           ::);\n\n        for(; i<w_l-7; i+=8){\n\n            asm volatile(\n\n                \"movq     (%1), %%mm2        \\n\\t\"\n\n                \"movq    8(%1), %%mm6        \\n\\t\"\n\n                \"paddw   2(%1), %%mm2        \\n\\t\"\n\n                \"paddw  10(%1), %%mm6        \\n\\t\"\n\n                \"movq    %%mm2, %%mm0        \\n\\t\"\n\n                \"movq    %%mm6, %%mm4        \\n\\t\"\n\n                \"psraw      $1, %%mm2        \\n\\t\"\n\n                \"psraw      $1, %%mm6        \\n\\t\"\n\n                \"paddw   %%mm0, %%mm2        \\n\\t\"\n\n                \"paddw   %%mm4, %%mm6        \\n\\t\"\n\n                \"paddw   %%mm7, %%mm2        \\n\\t\"\n\n                \"paddw   %%mm7, %%mm6        \\n\\t\"\n\n                \"psraw      $2, %%mm2        \\n\\t\"\n\n                \"psraw      $2, %%mm6        \\n\\t\"\n\n                \"movq     (%0), %%mm0        \\n\\t\"\n\n                \"movq    8(%0), %%mm4        \\n\\t\"\n\n                \"psubw   %%mm2, %%mm0        \\n\\t\"\n\n                \"psubw   %%mm6, %%mm4        \\n\\t\"\n\n                \"movq    %%mm0, (%0)         \\n\\t\"\n\n                \"movq    %%mm4, 8(%0)        \\n\\t\"\n\n                :: \"r\"(&b[i]), \"r\"(&ref[i])\n\n                 : \"memory\"\n\n               );\n\n        }\n\n        snow_horizontal_compose_lift_lead_out(i, b, b, ref, width, w_l, 0, W_DM, W_DO, W_DS);\n\n    }\n\n\n\n    { // Lift 1\n\n        IDWTELEM * const dst = b+w2;\n\n\n\n        i = 0;\n\n        for(; i<w_r-7; i+=8){\n\n            asm volatile(\n\n                \"movq     (%1), %%mm2        \\n\\t\"\n\n                \"movq    8(%1), %%mm6        \\n\\t\"\n\n                \"paddw   2(%1), %%mm2        \\n\\t\"\n\n                \"paddw  10(%1), %%mm6        \\n\\t\"\n\n                \"movq     (%0), %%mm0        \\n\\t\"\n\n                \"movq    8(%0), %%mm4        \\n\\t\"\n\n                \"psubw   %%mm2, %%mm0        \\n\\t\"\n\n                \"psubw   %%mm6, %%mm4        \\n\\t\"\n\n                \"movq    %%mm0, (%0)         \\n\\t\"\n\n                \"movq    %%mm4, 8(%0)        \\n\\t\"\n\n                :: \"r\"(&dst[i]), \"r\"(&b[i])\n\n                 : \"memory\"\n\n               );\n\n        }\n\n        snow_horizontal_compose_lift_lead_out(i, dst, dst, b, width, w_r, 1, W_CM, W_CO, W_CS);\n\n    }\n\n\n\n    { // Lift 2\n\n        IDWTELEM * const ref = b+w2 - 1;\n\n\n\n        i = 1;\n\n        b[0] = b[0] + (((2 * ref[1] + W_BO) + 4 * b[0]) >> W_BS);\n\n        asm volatile(\n\n            \"psllw          $2, %%mm7        \\n\\t\"\n\n           ::);\n\n        for(; i<w_l-7; i+=8){\n\n            asm volatile(\n\n                \"movq     (%1), %%mm0        \\n\\t\"\n\n                \"movq    8(%1), %%mm4        \\n\\t\"\n\n                \"paddw   2(%1), %%mm0        \\n\\t\"\n\n                \"paddw  10(%1), %%mm4        \\n\\t\"\n\n                \"paddw   %%mm7, %%mm0        \\n\\t\"\n\n                \"paddw   %%mm7, %%mm4        \\n\\t\"\n\n                \"psraw      $2, %%mm0        \\n\\t\"\n\n                \"psraw      $2, %%mm4        \\n\\t\"\n\n                \"movq     (%0), %%mm1        \\n\\t\"\n\n                \"movq    8(%0), %%mm5        \\n\\t\"\n\n                \"paddw   %%mm1, %%mm0        \\n\\t\"\n\n                \"paddw   %%mm5, %%mm4        \\n\\t\"\n\n                \"psraw      $2, %%mm0        \\n\\t\"\n\n                \"psraw      $2, %%mm4        \\n\\t\"\n\n                \"paddw   %%mm1, %%mm0        \\n\\t\"\n\n                \"paddw   %%mm5, %%mm4        \\n\\t\"\n\n                \"movq    %%mm0, (%0)         \\n\\t\"\n\n                \"movq    %%mm4, 8(%0)        \\n\\t\"\n\n                :: \"r\"(&b[i]), \"r\"(&ref[i])\n\n                 : \"memory\"\n\n               );\n\n        }\n\n        snow_horizontal_compose_liftS_lead_out(i, b, b, ref, width, w_l);\n\n    }\n\n\n\n    { // Lift 3\n\n        IDWTELEM * const src = b+w2;\n\n        i = 0;\n\n\n\n        for(; i<w_r-7; i+=8){\n\n            asm volatile(\n\n                \"movq    2(%1), %%mm2        \\n\\t\"\n\n                \"movq   10(%1), %%mm6        \\n\\t\"\n\n                \"paddw    (%1), %%mm2        \\n\\t\"\n\n                \"paddw   8(%1), %%mm6        \\n\\t\"\n\n                \"movq     (%0), %%mm0        \\n\\t\"\n\n                \"movq    8(%0), %%mm4        \\n\\t\"\n\n                \"paddw   %%mm2, %%mm0        \\n\\t\"\n\n                \"paddw   %%mm6, %%mm4        \\n\\t\"\n\n                \"psraw      $1, %%mm2        \\n\\t\"\n\n                \"psraw      $1, %%mm6        \\n\\t\"\n\n                \"paddw   %%mm0, %%mm2        \\n\\t\"\n\n                \"paddw   %%mm4, %%mm6        \\n\\t\"\n\n                \"movq    %%mm2, (%2)         \\n\\t\"\n\n                \"movq    %%mm6, 8(%2)        \\n\\t\"\n\n                :: \"r\"(&src[i]), \"r\"(&b[i]), \"r\"(&temp[i])\n\n                 : \"memory\"\n\n               );\n\n        }\n\n        snow_horizontal_compose_lift_lead_out(i, temp, src, b, width, w_r, 1, -W_AM, W_AO+1, W_AS);\n\n    }\n\n\n\n    {\n\n        snow_interleave_line_header(&i, width, b, temp);\n\n\n\n        for (; (i & 0x1E) != 0x1E; i-=2){\n\n            b[i+1] = temp[i>>1];\n\n            b[i] = b[i>>1];\n\n        }\n\n        for (i-=30; i>=0; i-=32){\n\n            asm volatile(\n\n                \"movq        (%1), %%mm0       \\n\\t\"\n\n                \"movq       8(%1), %%mm2       \\n\\t\"\n\n                \"movq      16(%1), %%mm4       \\n\\t\"\n\n                \"movq      24(%1), %%mm6       \\n\\t\"\n\n                \"movq        (%1), %%mm1       \\n\\t\"\n\n                \"movq       8(%1), %%mm3       \\n\\t\"\n\n                \"movq      16(%1), %%mm5       \\n\\t\"\n\n                \"movq      24(%1), %%mm7       \\n\\t\"\n\n                \"punpcklwd   (%2), %%mm0       \\n\\t\"\n\n                \"punpcklwd  8(%2), %%mm2       \\n\\t\"\n\n                \"punpcklwd 16(%2), %%mm4       \\n\\t\"\n\n                \"punpcklwd 24(%2), %%mm6       \\n\\t\"\n\n                \"movq       %%mm0, (%0)        \\n\\t\"\n\n                \"movq       %%mm2, 16(%0)      \\n\\t\"\n\n                \"movq       %%mm4, 32(%0)      \\n\\t\"\n\n                \"movq       %%mm6, 48(%0)      \\n\\t\"\n\n                \"punpckhwd   (%2), %%mm1       \\n\\t\"\n\n                \"punpckhwd  8(%2), %%mm3       \\n\\t\"\n\n                \"punpckhwd 16(%2), %%mm5       \\n\\t\"\n\n                \"punpckhwd 24(%2), %%mm7       \\n\\t\"\n\n                \"movq       %%mm1, 8(%0)       \\n\\t\"\n\n                \"movq       %%mm3, 24(%0)      \\n\\t\"\n\n                \"movq       %%mm5, 40(%0)      \\n\\t\"\n\n                \"movq       %%mm7, 56(%0)      \\n\\t\"\n\n                :: \"r\"(&b[i]), \"r\"(&b[i>>1]), \"r\"(&temp[i>>1])\n\n                 : \"memory\"\n\n               );\n\n        }\n\n    }\n\n}\n", "idx": 485}
{"project": "qemu", "commit_id": "731d5856cbb9c160fe02b90cd3cf354ea4f52f34", "target": 1, "func": "static int net_dump_init(VLANState *vlan, const char *device,\n\n                         const char *name, const char *filename, int len)\n\n{\n\n    struct pcap_file_hdr hdr;\n\n    DumpState *s;\n\n\n\n    s = qemu_malloc(sizeof(DumpState));\n\n\n\n    s->fd = open(filename, O_CREAT | O_WRONLY | O_BINARY, 0644);\n\n    if (s->fd < 0) {\n\n        qemu_error(\"-net dump: can't open %s\\n\", filename);\n\n        return -1;\n\n    }\n\n\n\n    s->pcap_caplen = len;\n\n\n\n    hdr.magic = PCAP_MAGIC;\n\n    hdr.version_major = 2;\n\n    hdr.version_minor = 4;\n\n    hdr.thiszone = 0;\n\n    hdr.sigfigs = 0;\n\n    hdr.snaplen = s->pcap_caplen;\n\n    hdr.linktype = 1;\n\n\n\n    if (write(s->fd, &hdr, sizeof(hdr)) < sizeof(hdr)) {\n\n        qemu_error(\"-net dump write error: %s\\n\", strerror(errno));\n\n        close(s->fd);\n\n        qemu_free(s);\n\n        return -1;\n\n    }\n\n\n\n    s->pcap_vc = qemu_new_vlan_client(NET_CLIENT_TYPE_DUMP,\n\n                                      vlan, NULL, device, name, NULL,\n\n                                      dump_receive, NULL, NULL,\n\n                                      net_dump_cleanup, s);\n\n    snprintf(s->pcap_vc->info_str, sizeof(s->pcap_vc->info_str),\n\n             \"dump to %s (len=%d)\", filename, len);\n\n    return 0;\n\n}\n", "idx": 486}
{"project": "FFmpeg", "commit_id": "70205f1799252c3363a5bb5ea7ea5df090f2c88f", "target": 0, "func": "void check_values (eq2_param_t *par)\n\n{\n\n  /* yuck! floating point comparisons... */\n\n\n\n  if ((par->c == 1.0) && (par->b == 0.0) && (par->g == 1.0)) {\n\n    par->adjust = NULL;\n\n  }\n\n#if HAVE_MMX && HAVE_6REGS\n\n  else if (par->g == 1.0 && ff_gCpuCaps.hasMMX) {\n\n    par->adjust = &affine_1d_MMX;\n\n  }\n\n#endif\n\n  else {\n\n    par->adjust = &apply_lut;\n\n  }\n\n}\n", "idx": 487}
{"project": "FFmpeg", "commit_id": "dcfb0cad687ec89d3c7fe21a014c58f283050283", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x2(IpvideoContext *s)\n\n{\n\n    unsigned char B;\n\n    int x, y;\n\n\n\n    /* copy block from 2 frames ago using a motion vector; need 1 more byte */\n\n    CHECK_STREAM_PTR(s->stream_ptr, s->stream_end, 1);\n\n    B = *s->stream_ptr++;\n\n\n\n    if (B < 56) {\n\n        x = 8 + (B % 7);\n\n        y = B / 7;\n\n    } else {\n\n        x = -14 + ((B - 56) % 29);\n\n        y =   8 + ((B - 56) / 29);\n\n    }\n\n\n\n    debug_interplay (\"    motion byte = %d, (x, y) = (%d, %d)\\n\", B, x, y);\n\n    return copy_from(s, &s->second_last_frame, x, y);\n\n}\n", "idx": 488}
{"project": "FFmpeg", "commit_id": "9f8008a9815ed5ee8846de2bb97c980ddb7b2485", "target": 0, "func": "static int input_get_buffer(AVCodecContext *codec, AVFrame *pic)\n\n{\n\n    AVFilterContext *ctx = codec->opaque;\n\n    AVFilterBufferRef  *ref;\n\n    int perms = AV_PERM_WRITE;\n\n    int i, w, h, stride[4];\n\n    unsigned edge;\n\n\n\n    if(av_image_check_size(w, h, 0, codec))\n\n        return -1;\n\n\n\n    if (codec->codec->capabilities & CODEC_CAP_NEG_LINESIZES)\n\n        perms |= AV_PERM_NEG_LINESIZES;\n\n\n\n    if(pic->buffer_hints & FF_BUFFER_HINTS_VALID) {\n\n        if(pic->buffer_hints & FF_BUFFER_HINTS_READABLE) perms |= AV_PERM_READ;\n\n        if(pic->buffer_hints & FF_BUFFER_HINTS_PRESERVE) perms |= AV_PERM_PRESERVE;\n\n        if(pic->buffer_hints & FF_BUFFER_HINTS_REUSABLE) perms |= AV_PERM_REUSE2;\n\n    }\n\n    if(pic->reference) perms |= AV_PERM_READ | AV_PERM_PRESERVE;\n\n\n\n    w = codec->width;\n\n    h = codec->height;\n\n    avcodec_align_dimensions2(codec, &w, &h, stride);\n\n    edge = codec->flags & CODEC_FLAG_EMU_EDGE ? 0 : avcodec_get_edge_width();\n\n    w += edge << 1;\n\n    h += edge << 1;\n\n\n\n    if(!(ref = avfilter_get_video_buffer(ctx->outputs[0], perms, w, h)))\n\n        return -1;\n\n\n\n    ref->video->w = codec->width;\n\n    ref->video->h = codec->height;\n\n    for(i = 0; i < 4; i ++) {\n\n        unsigned hshift = (i == 1 || i == 2) ? av_pix_fmt_descriptors[ref->format].log2_chroma_w : 0;\n\n        unsigned vshift = (i == 1 || i == 2) ? av_pix_fmt_descriptors[ref->format].log2_chroma_h : 0;\n\n\n\n        if (ref->data[i]) {\n\n            ref->data[i]    += (edge >> hshift) + ((edge * ref->linesize[i]) >> vshift);\n\n        }\n\n        pic->data[i]     = ref->data[i];\n\n        pic->linesize[i] = ref->linesize[i];\n\n    }\n\n    pic->opaque = ref;\n\n    pic->age    = INT_MAX;\n\n    pic->type   = FF_BUFFER_TYPE_USER;\n\n    pic->reordered_opaque = codec->reordered_opaque;\n\n    if(codec->pkt) pic->pkt_pts = codec->pkt->pts;\n\n    else           pic->pkt_pts = AV_NOPTS_VALUE;\n\n    return 0;\n\n}\n", "idx": 489}
{"project": "qemu", "commit_id": "5f8b6491f20732e0a31e64bbf75b62def579e044", "target": 1, "func": "static void coroutine_fn wait_for_overlapping_requests(BlockDriverState *bs,\n        int64_t sector_num, int nb_sectors)\n{\n    BdrvTrackedRequest *req;\n    int64_t cluster_sector_num;\n    int cluster_nb_sectors;\n    bool retry;\n    /* If we touch the same cluster it counts as an overlap.  This guarantees\n     * that allocating writes will be serialized and not race with each other\n     * for the same cluster.  For example, in copy-on-read it ensures that the\n     * CoR read and write operations are atomic and guest writes cannot\n     * interleave between them.\n    round_to_clusters(bs, sector_num, nb_sectors,\n                      &cluster_sector_num, &cluster_nb_sectors);\n    do {\n        retry = false;\n        QLIST_FOREACH(req, &bs->tracked_requests, list) {\n            if (tracked_request_overlaps(req, cluster_sector_num,\n                                         cluster_nb_sectors)) {\n                qemu_co_queue_wait(&req->wait_queue);\n                retry = true;\n                break;\n            }\n        }\n    } while (retry);\n}", "idx": 492}
{"project": "qemu", "commit_id": "e5d1fca0f20babbe355957b9ba536fe6187691cc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan,\n\n                                                const char *model,\n\n                                                const char *name,\n\n                                                int fd, int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len;\n\n    VLANClientState *nc;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv()\n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n        if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n            /* must be bound */\n\n            if (saddr.sin_addr.s_addr == 0) {\n\n                fprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, \"\n\n                        \"cannot setup multicast dst addr\\n\", fd);\n\n                return NULL;\n\n            }\n\n            /* clone dgram socket */\n\n            newfd = net_socket_mcast_create(&saddr, NULL);\n\n            if (newfd < 0) {\n\n                /* error already reported by net_socket_mcast_create() */\n\n                close(fd);\n\n                return NULL;\n\n            }\n\n            /* clone newfd to fd, close newfd */\n\n            dup2(newfd, fd);\n\n            close(newfd);\n\n\n\n        } else {\n\n            fprintf(stderr,\n\n                    \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n                    fd, strerror(errno));\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    nc = qemu_new_net_client(&net_dgram_socket_info, vlan, NULL, model, name);\n\n\n\n    snprintf(nc->info_str, sizeof(nc->info_str),\n\n            \"socket: fd=%d (%s mcast=%s:%d)\",\n\n            fd, is_connected ? \"cloned\" : \"\",\n\n            inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n\n\n    s = DO_UPCAST(NetSocketState, nc, nc);\n\n\n\n    s->fd = fd;\n\n\n\n    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) s->dgram_dst=saddr;\n\n\n\n    return s;\n\n}\n", "idx": 493}
{"project": "qemu", "commit_id": "f798184cfdcb7f92a38c5f717d675bd75e1fd3ac", "target": 0, "func": "int64_t bdrv_dirty_iter_next(BdrvDirtyBitmapIter *iter)\n\n{\n\n    return hbitmap_iter_next(&iter->hbi);\n\n}\n", "idx": 494}
{"project": "qemu", "commit_id": "ccf1d14a1e37abe1f0da162c00a8941963b47a4c", "target": 0, "func": "static void rtl8139_write_buffer(RTL8139State *s, const void *buf, int size)\n\n{\n\n    if (s->RxBufAddr + size > s->RxBufferSize)\n\n    {\n\n        int wrapped = MOD2(s->RxBufAddr + size, s->RxBufferSize);\n\n\n\n        /* write packet data */\n\n        if (wrapped && s->RxBufferSize < 65536 && !rtl8139_RxWrap(s))\n\n        {\n\n            DEBUG_PRINT((\">>> RTL8139: rx packet wrapped in buffer at %d\\n\", size-wrapped));\n\n\n\n            if (size > wrapped)\n\n            {\n\n                cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,\n\n                                           buf, size-wrapped );\n\n            }\n\n\n\n            /* reset buffer pointer */\n\n            s->RxBufAddr = 0;\n\n\n\n            cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,\n\n                                       buf + (size-wrapped), wrapped );\n\n\n\n            s->RxBufAddr = wrapped;\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* non-wrapping path or overwrapping enabled */\n\n    cpu_physical_memory_write( s->RxBuf + s->RxBufAddr, buf, size );\n\n\n\n    s->RxBufAddr += size;\n\n}\n", "idx": 495}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "int ppc_hash32_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                                int mmu_idx)\n\n{\n\n    struct mmu_ctx_hash32 ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = ppc_hash32_get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x40000000;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x42000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x40000000;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x0A000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x08000000;\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 496}
{"project": "qemu", "commit_id": "fd198f9002a9e1f070c82b04d3229c18d9a49471", "target": 0, "func": "bool colo_supported(void)\n\n{\n\n    return true;\n\n}\n", "idx": 499}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_i2s_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    PXA2xxI2SState *s = (PXA2xxI2SState *) opaque;\n\n\n\n    switch (addr) {\n\n    case SACR0:\n\n        return s->control[0];\n\n    case SACR1:\n\n        return s->control[1];\n\n    case SASR0:\n\n        return s->status;\n\n    case SAIMR:\n\n        return s->mask;\n\n    case SAICR:\n\n        return 0;\n\n    case SADIV:\n\n        return s->clk;\n\n    case SADR:\n\n        if (s->rx_len > 0) {\n\n            s->rx_len --;\n\n            pxa2xx_i2s_update(s);\n\n            return s->codec_in(s->opaque);\n\n        }\n\n        return 0;\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 500}
{"project": "qemu", "commit_id": "4cee3cf35c05c863f5acf87af915298c752eefd9", "target": 0, "func": "char *desc_get_buf(DescInfo *info, bool read_only)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(info->ring->r);\n\n    size_t size = read_only ? le16_to_cpu(info->desc.tlv_size) :\n\n                              le16_to_cpu(info->desc.buf_size);\n\n\n\n    if (size > info->buf_size) {\n\n        info->buf = g_realloc(info->buf, size);\n\n        info->buf_size = size;\n\n    }\n\n\n\n    if (!info->buf) {\n\n        return NULL;\n\n    }\n\n\n\n    if (pci_dma_read(dev, le64_to_cpu(info->desc.buf_addr), info->buf, size)) {\n\n        return NULL;\n\n    }\n\n\n\n    return info->buf;\n\n}\n", "idx": 502}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "static void copy_context_after_encode(MpegEncContext *d, MpegEncContext *s, int type){\n\n    int i;\n\n\n\n    memcpy(d->mv, s->mv, 2*4*2*sizeof(int)); \n\n    memcpy(d->last_mv, s->last_mv, 2*2*2*sizeof(int)); //FIXME is memcpy faster then a loop?\n\n    \n\n    /* mpeg1 */\n\n    d->mb_incr= s->mb_incr;\n\n    for(i=0; i<3; i++)\n\n        d->last_dc[i]= s->last_dc[i];\n\n    \n\n    /* statistics */\n\n    d->mv_bits= s->mv_bits;\n\n    d->i_tex_bits= s->i_tex_bits;\n\n    d->p_tex_bits= s->p_tex_bits;\n\n    d->i_count= s->i_count;\n\n    d->p_count= s->p_count;\n\n    d->skip_count= s->skip_count;\n\n    d->misc_bits= s->misc_bits;\n\n\n\n    d->mb_intra= s->mb_intra;\n\n    d->mb_skiped= s->mb_skiped;\n\n    d->mv_type= s->mv_type;\n\n    d->mv_dir= s->mv_dir;\n\n    d->pb= s->pb;\n\n    d->block= s->block;\n\n    for(i=0; i<6; i++)\n\n        d->block_last_index[i]= s->block_last_index[i];\n\n}\n", "idx": 503}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static inline int gen_intermediate_code_internal (CPUState *env,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#if defined(TARGET_PPC64)\n\n    ctx.mem_idx |= msr_sf << 1;\n\n#endif\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#if defined(TARGET_PPC64)\n\n    ctx.mem_idx |= msr_sf << 2;\n\n#endif\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n    ctx.sf_mode = msr_sf;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n#if defined(TARGET_PPCEMB)\n\n    ctx.spe_enabled = msr_spe;\n\n#endif\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_update_nip(&ctx, ctx.nip);\n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=\" ADDRX \" super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x\" ADDRX \" %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x\" ADDRX \" %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (%08x) 0x\" ADDRX \"\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (%08x) 0x\" ADDRX \"\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n#if 0 // XXX: buggy on embedded PowerPC\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n#endif\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#if defined(DEBUG_DISAS)\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = env->bfd_mach;\n\n        flags |= msr_le << 16;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 504}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *address_space_map(AddressSpace *as,\n\n                        target_phys_addr_t addr,\n\n                        target_phys_addr_t *plen,\n\n                        bool is_write)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n    target_phys_addr_t len = *plen;\n\n    target_phys_addr_t todo = 0;\n\n    int l;\n\n    target_phys_addr_t page;\n\n    MemoryRegionSection *section;\n\n    ram_addr_t raddr = RAM_ADDR_MAX;\n\n    ram_addr_t rlen;\n\n    void *ret;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        section = phys_page_find(d, page >> TARGET_PAGE_BITS);\n\n\n\n        if (!(memory_region_is_ram(section->mr) && !section->readonly)) {\n\n            if (todo || bounce.buffer) {\n\n                break;\n\n            }\n\n            bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, TARGET_PAGE_SIZE);\n\n            bounce.addr = addr;\n\n            bounce.len = l;\n\n            if (!is_write) {\n\n                address_space_read(as, addr, bounce.buffer, l);\n\n            }\n\n\n\n            *plen = l;\n\n            return bounce.buffer;\n\n        }\n\n        if (!todo) {\n\n            raddr = memory_region_get_ram_addr(section->mr)\n\n                + memory_region_section_addr(section, addr);\n\n        }\n\n\n\n        len -= l;\n\n        addr += l;\n\n        todo += l;\n\n    }\n\n    rlen = todo;\n\n    ret = qemu_ram_ptr_length(raddr, &rlen);\n\n    *plen = rlen;\n\n    return ret;\n\n}\n", "idx": 505}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "GenericList *visit_next_list(Visitor *v, GenericList **list, size_t size)\n\n{\n\n    assert(list && size >= sizeof(GenericList));\n\n    return v->next_list(v, list, size);\n\n}\n", "idx": 506}
{"project": "qemu", "commit_id": "2d1a35bef0ed96b3f23535e459c552414ccdbafd", "target": 0, "func": "static void *vring_map(MemoryRegion **mr, hwaddr phys, hwaddr len,\n\n                       bool is_write)\n\n{\n\n    MemoryRegionSection section = memory_region_find(get_system_memory(), phys, len);\n\n\n\n    if (!section.mr || int128_get64(section.size) < len) {\n\n        goto out;\n\n    }\n\n    if (is_write && section.readonly) {\n\n        goto out;\n\n    }\n\n    if (!memory_region_is_ram(section.mr)) {\n\n        goto out;\n\n    }\n\n\n\n    /* Ignore regions with dirty logging, we cannot mark them dirty */\n\n    if (memory_region_is_logging(section.mr)) {\n\n        goto out;\n\n    }\n\n\n\n    *mr = section.mr;\n\n    return memory_region_get_ram_ptr(section.mr) + section.offset_within_region;\n\n\n\nout:\n\n    memory_region_unref(section.mr);\n\n    *mr = NULL;\n\n    return NULL;\n\n}\n", "idx": 507}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t ldl_be_phys(target_phys_addr_t addr)\n\n{\n\n    return ldl_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 508}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "stream_push(StreamSlave *sink, uint8_t *buf, size_t len, uint32_t *app)\n\n{\n\n    StreamSlaveClass *k =  STREAM_SLAVE_GET_CLASS(sink);\n\n\n\n    return k->push(sink, buf, len, app);\n\n}\n", "idx": 509}
{"project": "qemu", "commit_id": "d8b7e0adf562277180f96ecbd7f1777a384a0308", "target": 0, "func": "static int raw_write(BlockDriverState *bs, int64_t sector_num,\n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n}\n", "idx": 511}
{"project": "qemu", "commit_id": "facf1a60f29853590073f321e3cba491a5ee097a", "target": 0, "func": "static void tftp_handle_rrq(Slirp *slirp, struct tftp_t *tp, int pktlen)\n\n{\n\n  struct tftp_session *spt;\n\n  int s, k;\n\n  size_t prefix_len;\n\n  char *req_fname;\n\n\n\n  /* check if a session already exists and if so terminate it */\n\n  s = tftp_session_find(slirp, tp);\n\n  if (s >= 0) {\n\n    tftp_session_terminate(&slirp->tftp_sessions[s]);\n\n  }\n\n\n\n  s = tftp_session_allocate(slirp, tp);\n\n\n\n  if (s < 0) {\n\n    return;\n\n  }\n\n\n\n  spt = &slirp->tftp_sessions[s];\n\n\n\n  /* unspecifed prefix means service disabled */\n\n  if (!slirp->tftp_prefix) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  /* skip header fields */\n\n  k = 0;\n\n  pktlen -= ((uint8_t *)&tp->x.tp_buf[0] - (uint8_t *)tp);\n\n\n\n  /* prepend tftp_prefix */\n\n  prefix_len = strlen(slirp->tftp_prefix);\n\n  spt->filename = qemu_malloc(prefix_len + TFTP_FILENAME_MAX + 2);\n\n  memcpy(spt->filename, slirp->tftp_prefix, prefix_len);\n\n  spt->filename[prefix_len] = '/';\n\n\n\n  /* get name */\n\n  req_fname = spt->filename + prefix_len + 1;\n\n\n\n  while (1) {\n\n    if (k >= TFTP_FILENAME_MAX || k >= pktlen) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n    }\n\n    req_fname[k] = (char)tp->x.tp_buf[k];\n\n    if (req_fname[k++] == '\\0') {\n\n      break;\n\n    }\n\n  }\n\n\n\n  /* check mode */\n\n  if ((pktlen - k) < 6) {\n\n    tftp_send_error(spt, 2, \"Access violation\", tp);\n\n    return;\n\n  }\n\n\n\n  if (memcmp(&tp->x.tp_buf[k], \"octet\\0\", 6) != 0) {\n\n      tftp_send_error(spt, 4, \"Unsupported transfer mode\", tp);\n\n      return;\n\n  }\n\n\n\n  k += 6; /* skipping octet */\n\n\n\n  /* do sanity checks on the filename */\n\n  if (!strncmp(req_fname, \"../\", 3) ||\n\n      req_fname[strlen(req_fname) - 1] == '/' ||\n\n      strstr(req_fname, \"/../\")) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  /* check if the file exists */\n\n  if (tftp_read_data(spt, 0, NULL, 0) < 0) {\n\n      tftp_send_error(spt, 1, \"File not found\", tp);\n\n      return;\n\n  }\n\n\n\n  if (tp->x.tp_buf[pktlen - 1] != 0) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  while (k < pktlen) {\n\n      const char *key, *value;\n\n\n\n      key = (const char *)&tp->x.tp_buf[k];\n\n      k += strlen(key) + 1;\n\n\n\n      if (k >= pktlen) {\n\n\t  tftp_send_error(spt, 2, \"Access violation\", tp);\n\n\t  return;\n\n      }\n\n\n\n      value = (const char *)&tp->x.tp_buf[k];\n\n      k += strlen(value) + 1;\n\n\n\n      if (strcmp(key, \"tsize\") == 0) {\n\n\t  int tsize = atoi(value);\n\n\t  struct stat stat_p;\n\n\n\n\t  if (tsize == 0) {\n\n\t      if (stat(spt->filename, &stat_p) == 0)\n\n\t\t  tsize = stat_p.st_size;\n\n\t      else {\n\n\t\t  tftp_send_error(spt, 1, \"File not found\", tp);\n\n\t\t  return;\n\n\t      }\n\n\t  }\n\n\n\n\t  tftp_send_oack(spt, \"tsize\", tsize, tp);\n\n\t  return;\n\n      }\n\n  }\n\n\n\n  tftp_send_data(spt, 1, tp);\n\n}\n", "idx": 513}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static MegasasCmd *megasas_next_frame(MegasasState *s,\n\n    target_phys_addr_t frame)\n\n{\n\n    MegasasCmd *cmd = NULL;\n\n    int num = 0, index;\n\n\n\n    cmd = megasas_lookup_frame(s, frame);\n\n    if (cmd) {\n\n        trace_megasas_qf_found(cmd->index, cmd->pa);\n\n        return cmd;\n\n    }\n\n    index = s->reply_queue_head;\n\n    num = 0;\n\n    while (num < s->fw_cmds) {\n\n        if (!s->frames[index].pa) {\n\n            cmd = &s->frames[index];\n\n            break;\n\n        }\n\n        index = megasas_next_index(s, index, s->fw_cmds);\n\n        num++;\n\n    }\n\n    if (!cmd) {\n\n        trace_megasas_qf_failed(frame);\n\n    }\n\n    trace_megasas_qf_new(index, cmd);\n\n    return cmd;\n\n}\n", "idx": 515}
{"project": "FFmpeg", "commit_id": "0398b7cbd39abb049775d558ccc4ccf6dc01e92c", "target": 1, "func": "static int hnm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    AVFrame *frame = data;\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    int ret;\n\n    uint16_t chunk_id;\n\n\n\n    if (avpkt->size < 8) {\n\n\n\n\n\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n\n        return ret;\n\n\n\n    chunk_id = AV_RL16(avpkt->data + 4);\n\n\n\n    if (chunk_id == HNM4_CHUNK_ID_PL) {\n\n        hnm_update_palette(avctx, avpkt->data, avpkt->size);\n\n        frame->palette_has_changed = 1;\n\n    } else if (chunk_id == HNM4_CHUNK_ID_IZ) {\n\n\n\n\n\n        unpack_intraframe(avctx, avpkt->data + 12, avpkt->size - 12);\n\n        memcpy(hnm->previous, hnm->current, hnm->width * hnm->height);\n\n        if (hnm->version == 0x4a)\n\n            memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);\n\n        else\n\n            postprocess_current_frame(avctx);\n\n        copy_processed_frame(avctx, frame);\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n        memcpy(frame->data[1], hnm->palette, 256 * 4);\n\n        *got_frame = 1;\n\n    } else if (chunk_id == HNM4_CHUNK_ID_IU) {\n\n        if (hnm->version == 0x4a) {\n\n            decode_interframe_v4a(avctx, avpkt->data + 8, avpkt->size - 8);\n\n            memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);\n\n        } else {\n\n            decode_interframe_v4(avctx, avpkt->data + 8, avpkt->size - 8);\n\n            postprocess_current_frame(avctx);\n\n\n        copy_processed_frame(avctx, frame);\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n        frame->key_frame = 0;\n\n        memcpy(frame->data[1], hnm->palette, 256 * 4);\n\n        *got_frame = 1;\n\n        hnm_flip_buffers(hnm);\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid chunk id: %d\\n\", chunk_id);\n\n\n\n\n\n    return avpkt->size;\n", "idx": 516}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void test_nesting(void)\n\n{\n\n    Coroutine *root;\n\n    NestData nd = {\n\n        .n_enter  = 0,\n\n        .n_return = 0,\n\n        .max      = 128,\n\n    };\n\n\n\n    root = qemu_coroutine_create(nest);\n\n    qemu_coroutine_enter(root, &nd);\n\n\n\n    /* Must enter and return from max nesting level */\n\n    g_assert_cmpint(nd.n_enter, ==, nd.max);\n\n    g_assert_cmpint(nd.n_return, ==, nd.max);\n\n}\n", "idx": 517}
{"project": "qemu", "commit_id": "cfb08fbafcd946341bdf14103293887763802697", "target": 1, "func": "static int fdctrl_connect_drives(FDCtrl *fdctrl)\n\n{\n\n    unsigned int i;\n\n    FDrive *drive;\n\n\n\n    for (i = 0; i < MAX_FD; i++) {\n\n        drive = &fdctrl->drives[i];\n\n        drive->fdctrl = fdctrl;\n\n\n\n        if (drive->bs) {\n\n            if (bdrv_get_on_error(drive->bs, 0) != BLOCK_ERR_STOP_ENOSPC) {\n\n                error_report(\"fdc doesn't support drive option werror\");\n\n                return -1;\n\n            }\n\n            if (bdrv_get_on_error(drive->bs, 1) != BLOCK_ERR_REPORT) {\n\n                error_report(\"fdc doesn't support drive option rerror\");\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        fd_init(drive);\n\n        fd_revalidate(drive);\n\n        if (drive->bs) {\n\n            bdrv_set_dev_ops(drive->bs, &fdctrl_block_ops, drive);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 518}
{"project": "FFmpeg", "commit_id": "fccd85b9f30525f88692f53134eba41f1f2d90db", "target": 1, "func": "static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    int err;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp = { av_be2ne64(state) };\n\n    AC3HeaderInfo hdr, *phdr = &hdr;\n\n    GetBitContext gbc;\n\n\n\n    init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54);\n\n    err = avpriv_ac3_parse_header2(&gbc, &phdr);\n\n\n\n    if(err < 0)\n\n        return 0;\n\n\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->bit_rate = hdr.bit_rate;\n\n    hdr_info->channels = hdr.channels;\n\n    hdr_info->channel_layout = hdr.channel_layout;\n\n    hdr_info->samples = hdr.num_blocks * 256;\n\n    hdr_info->service_type = hdr.bitstream_mode;\n\n    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)\n\n        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    if(hdr.bitstream_id>10)\n\n        hdr_info->codec_id = AV_CODEC_ID_EAC3;\n\n    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)\n\n        hdr_info->codec_id = AV_CODEC_ID_AC3;\n\n\n\n    *need_next_header = (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);\n\n    *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);\n\n    return hdr.frame_size;\n\n}\n", "idx": 519}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static bool use_goto_tb(DisasContext *ctx, target_ulong dest)\n\n{\n\n    /* Suppress goto_tb in the case of single-steping and IO.  */\n\n    if ((ctx->base.tb->cflags & CF_LAST_IO) || ctx->base.singlestep_enabled) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 520}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_bufopen(const char *mode, QEMUSizedBuffer *input)\n\n{\n\n    QEMUBuffer *s;\n\n\n\n    if (mode == NULL || (mode[0] != 'r' && mode[0] != 'w') ||\n\n        mode[1] != '\\0') {\n\n        error_report(\"qemu_bufopen: Argument validity check failed\");\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUBuffer));\n\n    if (mode[0] == 'r') {\n\n        s->qsb = input;\n\n    }\n\n\n\n    if (s->qsb == NULL) {\n\n        s->qsb = qsb_create(NULL, 0);\n\n    }\n\n    if (!s->qsb) {\n\n        g_free(s);\n\n        error_report(\"qemu_bufopen: qsb_create failed\");\n\n        return NULL;\n\n    }\n\n\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &buf_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &buf_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 522}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void mips_cpu_class_init(ObjectClass *c, void *data)\n\n{\n\n    MIPSCPUClass *mcc = MIPS_CPU_CLASS(c);\n\n    CPUClass *cc = CPU_CLASS(c);\n\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n\n\n    mcc->parent_realize = dc->realize;\n\n    dc->realize = mips_cpu_realizefn;\n\n\n\n    mcc->parent_reset = cc->reset;\n\n    cc->reset = mips_cpu_reset;\n\n\n\n    cc->has_work = mips_cpu_has_work;\n\n    cc->do_interrupt = mips_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = mips_cpu_exec_interrupt;\n\n    cc->dump_state = mips_cpu_dump_state;\n\n    cc->set_pc = mips_cpu_set_pc;\n\n    cc->synchronize_from_tb = mips_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = mips_cpu_gdb_read_register;\n\n    cc->gdb_write_register = mips_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = mips_cpu_handle_mmu_fault;\n\n#else\n\n    cc->do_unassigned_access = mips_cpu_unassigned_access;\n\n    cc->do_unaligned_access = mips_cpu_do_unaligned_access;\n\n    cc->get_phys_page_debug = mips_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_mips_cpu;\n\n#endif\n\n    cc->disas_set_info = mips_cpu_disas_set_info;\n\n\n\n    cc->gdb_num_core_regs = 73;\n\n    cc->gdb_stop_before_watchpoint = true;\n\n\n\n    /*\n\n     * Reason: mips_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 523}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void check_pointer_type_change(Notifier *notifier, void *data)\n\n{\n\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n\n    int absolute = qemu_input_is_absolute();\n\n\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n\n        vnc_lock_output(vs);\n\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n        vnc_write_u8(vs, 0);\n\n        vnc_write_u16(vs, 1);\n\n        vnc_framebuffer_update(vs, absolute, 0,\n\n                               surface_width(vs->vd->ds),\n\n                               surface_height(vs->vd->ds),\n\n                               VNC_ENCODING_POINTER_TYPE_CHANGE);\n\n        vnc_unlock_output(vs);\n\n        vnc_flush(vs);\n\n    }\n\n    vs->absolute = absolute;\n\n}\n", "idx": 524}
{"project": "FFmpeg", "commit_id": "9078eba062f5e0463d4029aa42b7b0026f42bed3", "target": 1, "func": "static MMSSCPacketType get_tcp_server_response(MMSContext *mms)\n\n{\n\n    int read_result;\n\n    MMSSCPacketType packet_type= -1;\n\n\n\n    for(;;) {\n\n        if((read_result= url_read_complete(mms->mms_hd, mms->in_buffer, 8))==8) {\n\n            // handle command packet.\n\n            if(AV_RL32(mms->in_buffer + 4)==0xb00bface) {\n\n                mms->incoming_flags= mms->in_buffer[3];\n\n                read_result= url_read_complete(mms->mms_hd, mms->in_buffer+8, 4);\n\n                if(read_result == 4) {\n\n                    int length_remaining= AV_RL32(mms->in_buffer+8) + 4;\n\n                    int hr;\n\n\n\n                    dprintf(NULL, \"Length remaining is %d\\n\", length_remaining);\n\n                    // read the rest of the packet.\n\n                    if (length_remaining < 0\n\n                        || length_remaining > sizeof(mms->in_buffer) - 12) {\n\n                        dprintf(NULL, \"Incoming message len %d exceeds buffer len %d\\n\",\n\n                            length_remaining, sizeof(mms->in_buffer) - 12);\n\n\n\n                    read_result = url_read_complete(mms->mms_hd, mms->in_buffer + 12,\n\n                                                  length_remaining) ;\n\n                    if (read_result == length_remaining) {\n\n                        packet_type= AV_RL16(mms->in_buffer+36);\n\n                    } else {\n\n                        dprintf(NULL, \"read for packet type failed%d!\\n\", read_result);\n\n\n\n\n\n\n\n\n                } else {\n\n                    dprintf(NULL, \"read for length remaining failed%d!\\n\", read_result);\n\n\n\n            } else {\n\n                int length_remaining;\n\n                int packet_id_type;\n\n                int tmp;\n\n\n\n                assert(mms->remaining_in_len==0);\n\n\n\n                // note we cache the first 8 bytes,\n\n                // then fill up the buffer with the others\n\n                tmp                       = AV_RL16(mms->in_buffer + 6);\n\n                length_remaining          = (tmp - 8) & 0xffff;\n\n                mms->incoming_packet_seq  = AV_RL32(mms->in_buffer);\n\n                packet_id_type            = mms->in_buffer[4];\n\n                mms->incoming_flags       = mms->in_buffer[5];\n\n\n\n                if (length_remaining < 0\n\n                        || length_remaining > sizeof(mms->in_buffer) - 8) {\n\n                    dprintf(NULL, \"Incoming data len %d exceeds buffer len %d\\n\",\n\n                            length_remaining, sizeof(mms->in_buffer));\n\n\n\n                mms->remaining_in_len    = length_remaining;\n\n                mms->read_in_ptr         = mms->in_buffer;\n\n                read_result= url_read_complete(mms->mms_hd, mms->in_buffer, length_remaining);\n\n                if(read_result != length_remaining) {\n\n                    dprintf(NULL, \"read_bytes result: %d asking for %d\\n\",\n\n                            read_result, length_remaining);\n\n\n                } else {\n\n                    // if we successfully read everything.\n\n                    if(packet_id_type == mms->header_packet_id) {\n\n                        packet_type = SC_PKT_ASF_HEADER;\n\n                        // Store the asf header\n\n                        if(!mms->header_parsed) {\n\n                            void *p = av_realloc(mms->asf_header,\n\n                                              mms->asf_header_size\n\n                                              + mms->remaining_in_len);\n\n                            if (!p) {\n\n                                av_freep(&mms->asf_header);\n\n                                return AVERROR(ENOMEM);\n\n\n                            mms->asf_header = p;\n\n                            memcpy(mms->asf_header + mms->asf_header_size,\n\n                                                 mms->read_in_ptr,\n\n                                                 mms->remaining_in_len);\n\n                            mms->asf_header_size += mms->remaining_in_len;\n\n\n                    } else if(packet_id_type == mms->packet_id) {\n\n                        packet_type = SC_PKT_ASF_MEDIA;\n\n                    } else {\n\n                        dprintf(NULL, \"packet id type %d is old.\", packet_id_type);\n\n                        continue;\n\n\n\n\n\n\n            // preprocess some packet type\n\n            if(packet_type == SC_PKT_KEEPALIVE) {\n\n                send_keepalive_packet(mms);\n\n                continue;\n\n            } else if(packet_type == SC_PKT_STREAM_CHANGING) {\n\n                handle_packet_stream_changing_type(mms);\n\n            } else if(packet_type == SC_PKT_ASF_MEDIA) {\n\n                pad_media_packet(mms);\n\n\n            return packet_type;\n\n        } else {\n\n            if(read_result<0) {\n\n                dprintf(NULL, \"Read error (or cancelled) returned %d!\\n\", read_result);\n\n                packet_type = SC_PKT_CANCEL;\n\n            } else {\n\n                dprintf(NULL, \"Read result of zero?!\\n\");\n\n                packet_type = SC_PKT_NO_DATA;\n\n\n            return packet_type;\n\n\n", "idx": 525}
{"project": "qemu", "commit_id": "a52c757c9f98311c3ba22744d609caa767b899e1", "target": 1, "func": "get_sigframe(struct emulated_sigaction *ka, CPUX86State *env, size_t frame_size)\n\n{\n\n\tunsigned long esp;\n\n\n\n\t/* Default to using normal stack */\n\n\tesp = env->regs[R_ESP];\n\n#if 0\n\n\t/* This is the X/Open sanctioned signal stack switching.  */\n\n\tif (ka->sa.sa_flags & SA_ONSTACK) {\n\n\t\tif (sas_ss_flags(esp) == 0)\n\n\t\t\tesp = current->sas_ss_sp + current->sas_ss_size;\n\n\t}\n\n\n\n\t/* This is the legacy signal stack switching. */\n\n\telse if ((regs->xss & 0xffff) != __USER_DS &&\n\n\t\t !(ka->sa.sa_flags & SA_RESTORER) &&\n\n\t\t ka->sa.sa_restorer) {\n\n\t\tesp = (unsigned long) ka->sa.sa_restorer;\n\n\t}\n\n#endif\n\n\treturn (void *)((esp - frame_size) & -8ul);\n\n}\n", "idx": 527}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static uint32_t add_weights(uint32_t w1, uint32_t w2)\n\n{\n\n    uint32_t max = (w1 & 0xFF) > (w2 & 0xFF) ? (w1 & 0xFF) : (w2 & 0xFF);\n\n\n\n    return ((w1 & 0xFFFFFF00) + (w2 & 0xFFFFFF00)) | (1 + max);\n\n}\n", "idx": 528}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_rlc_opc(CPUTriCoreState *env, DisasContext *ctx,\n\n                           uint32_t op1)\n\n{\n\n    int32_t const16;\n\n    int r1, r2;\n\n\n\n    const16 = MASK_OP_RLC_CONST16_SEXT(ctx->opcode);\n\n    r1      = MASK_OP_RLC_S1(ctx->opcode);\n\n    r2      = MASK_OP_RLC_D(ctx->opcode);\n\n\n\n    switch (op1) {\n\n    case OPC1_32_RLC_ADDI:\n\n        gen_addi_d(cpu_gpr_d[r2], cpu_gpr_d[r1], const16);\n\n        break;\n\n    case OPC1_32_RLC_ADDIH:\n\n        gen_addi_d(cpu_gpr_d[r2], cpu_gpr_d[r1], const16 << 16);\n\n        break;\n\n    case OPC1_32_RLC_ADDIH_A:\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r1], const16 << 16);\n\n        break;\n\n    case OPC1_32_RLC_MFCR:\n\n        const16 = MASK_OP_RLC_CONST16(ctx->opcode);\n\n        gen_mfcr(env, cpu_gpr_d[r2], const16);\n\n        break;\n\n    case OPC1_32_RLC_MOV:\n\n        tcg_gen_movi_tl(cpu_gpr_d[r2], const16);\n\n        break;\n\n    case OPC1_32_RLC_MOV_64:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((r2 & 0x1) != 0) {\n\n                /* TODO: raise OPD trap */\n\n            }\n\n            tcg_gen_movi_tl(cpu_gpr_d[r2], const16);\n\n            tcg_gen_movi_tl(cpu_gpr_d[r2+1], const16 >> 15);\n\n        } else {\n\n            /* TODO: raise illegal opcode trap */\n\n        }\n\n        break;\n\n    case OPC1_32_RLC_MOV_U:\n\n        const16 = MASK_OP_RLC_CONST16(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_d[r2], const16);\n\n        break;\n\n    case OPC1_32_RLC_MOV_H:\n\n        tcg_gen_movi_tl(cpu_gpr_d[r2], const16 << 16);\n\n        break;\n\n    case OPC1_32_RLC_MOVH_A:\n\n        tcg_gen_movi_tl(cpu_gpr_a[r2], const16 << 16);\n\n        break;\n\n    case OPC1_32_RLC_MTCR:\n\n        const16 = MASK_OP_RLC_CONST16(ctx->opcode);\n\n        gen_mtcr(env, ctx, cpu_gpr_d[r1], const16);\n\n        break;\n\n    }\n\n}\n", "idx": 529}
{"project": "qemu", "commit_id": "6ffacc5d3ddf2e3227aae2a8cc5c15627265f727", "target": 1, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    snprintf(pidstr, sizeof(pidstr), \"%d\\n\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 530}
{"project": "FFmpeg", "commit_id": "1f3910262e1b9091f597ebbb710b478d40319986", "target": 1, "func": "static void video_image_display(VideoState *is)\n\n{\n\n    Frame *vp;\n\n    Frame *sp = NULL;\n\n    SDL_Rect rect;\n\n\n\n    vp = frame_queue_peek_last(&is->pictq);\n\n    if (vp->bmp) {\n\n        if (is->subtitle_st) {\n\n            if (frame_queue_nb_remaining(&is->subpq) > 0) {\n\n                sp = frame_queue_peek(&is->subpq);\n\n\n\n                if (vp->pts >= sp->pts + ((float) sp->sub.start_display_time / 1000)) {\n\n                    if (!sp->uploaded) {\n\n                        uint8_t *pixels;\n\n                        int pitch;\n\n                        int i;\n\n                        if (!sp->width || !sp->height) {\n\n                            sp->width = vp->width;\n\n                            sp->height = vp->height;\n\n                        }\n\n                        if (realloc_texture(&is->sub_texture, SDL_PIXELFORMAT_ARGB8888, sp->width, sp->height, SDL_BLENDMODE_BLEND, 1) < 0)\n\n                            return;\n\n\n\n                        for (i = 0; i < sp->sub.num_rects; i++) {\n\n                            AVSubtitleRect *sub_rect = sp->sub.rects[i];\n\n\n\n                            sub_rect->x = av_clip(sub_rect->x, 0, sp->width );\n\n                            sub_rect->y = av_clip(sub_rect->y, 0, sp->height);\n\n                            sub_rect->w = av_clip(sub_rect->w, 0, sp->width  - sub_rect->x);\n\n                            sub_rect->h = av_clip(sub_rect->h, 0, sp->height - sub_rect->y);\n\n\n\n                            is->sub_convert_ctx = sws_getCachedContext(is->sub_convert_ctx,\n\n                                sub_rect->w, sub_rect->h, AV_PIX_FMT_PAL8,\n\n                                sub_rect->w, sub_rect->h, AV_PIX_FMT_BGRA,\n\n                                0, NULL, NULL, NULL);\n\n                            if (!is->sub_convert_ctx) {\n\n                                av_log(NULL, AV_LOG_FATAL, \"Cannot initialize the conversion context\\n\");\n\n                                return;\n\n                            }\n\n                            if (!SDL_LockTexture(is->sub_texture, (SDL_Rect *)sub_rect, (void **)&pixels, &pitch)) {\n\n                                sws_scale(is->sub_convert_ctx, (const uint8_t * const *)sub_rect->data, sub_rect->linesize,\n\n                                          0, sub_rect->h, &pixels, &pitch);\n\n                                SDL_UnlockTexture(is->sub_texture);\n\n                            }\n\n                        }\n\n                        sp->uploaded = 1;\n\n                    }\n\n                } else\n\n                    sp = NULL;\n\n            }\n\n        }\n\n\n\n        calculate_display_rect(&rect, is->xleft, is->ytop, is->width, is->height, vp->width, vp->height, vp->sar);\n\n\n\n        if (!vp->uploaded) {\n\n            if (upload_texture(vp->bmp, vp->frame, &is->img_convert_ctx) < 0)\n\n                return;\n\n            vp->uploaded = 1;\n\n            vp->flip_v = vp->frame->linesize[0] < 0;\n\n        }\n\n\n\n        SDL_RenderCopyEx(renderer, vp->bmp, NULL, &rect, 0, NULL, vp->flip_v ? SDL_FLIP_VERTICAL : 0);\n\n        if (sp) {\n\n#if USE_ONEPASS_SUBTITLE_RENDER\n\n            SDL_RenderCopy(renderer, is->sub_texture, NULL, &rect);\n\n#else\n\n            int i;\n\n            double xratio = (double)rect.w / (double)sp->width;\n\n            double yratio = (double)rect.h / (double)sp->height;\n\n            for (i = 0; i < sp->sub.num_rects; i++) {\n\n                SDL_Rect *sub_rect = (SDL_Rect*)sp->sub.rects[i];\n\n                SDL_Rect target = {.x = rect.x + sub_rect->x * xratio,\n\n                                   .y = rect.y + sub_rect->y * yratio,\n\n                                   .w = sub_rect->w * xratio,\n\n                                   .h = sub_rect->h * yratio};\n\n                SDL_RenderCopy(renderer, is->sub_texture, sub_rect, &target);\n\n            }\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 531}
{"project": "FFmpeg", "commit_id": "5a75924dfd432c0ada79a9f489889dc92d53b481", "target": 0, "func": "static int rtmp_server_handshake(URLContext *s, RTMPContext *rt)\n\n{\n\n    uint8_t buffer[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint32_t hs_epoch;\n\n    uint32_t hs_my_epoch;\n\n    uint8_t hs_c1[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint8_t hs_s1[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint32_t zeroes;\n\n    uint32_t temp       = 0;\n\n    int randomidx       = 0;\n\n    int inoutsize       = 0;\n\n    int ret;\n\n\n\n    inoutsize = ffurl_read_complete(rt->stream, buffer, 1);       // Receive C0\n\n    if (inoutsize <= 0) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to read handshake\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    // Check Version\n\n    if (buffer[0] != 3) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP protocol version mismatch\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (ffurl_write(rt->stream, buffer, 1) <= 0) {                 // Send S0\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Unable to write answer - RTMP S0\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    /* Receive C1 */\n\n    ret = rtmp_receive_hs_packet(rt, &hs_epoch, &zeroes, hs_c1,\n\n                                 RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake C1 Error\\n\");\n\n        return ret;\n\n    }\n\n    if (zeroes)\n\n        av_log(s, AV_LOG_WARNING, \"Erroneous C1 Message zero != 0\\n\");\n\n    /* Send S1 */\n\n    /* By now same epoch will be sent */\n\n    hs_my_epoch = hs_epoch;\n\n    /* Generate random */\n\n    for (randomidx = 0; randomidx < (RTMP_HANDSHAKE_PACKET_SIZE);\n\n         randomidx += 4)\n\n        AV_WB32(hs_s1 + 8 + randomidx, av_get_random_seed());\n\n\n\n    ret = rtmp_send_hs_packet(rt, hs_my_epoch, 0, hs_s1,\n\n                              RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake S1 Error\\n\");\n\n        return ret;\n\n    }\n\n    /* Send S2 */\n\n    ret = rtmp_send_hs_packet(rt, hs_epoch, 0, hs_c1,\n\n                              RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake S2 Error\\n\");\n\n        return ret;\n\n    }\n\n    /* Receive C2 */\n\n    ret = rtmp_receive_hs_packet(rt, &temp, &zeroes, buffer,\n\n                                 RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake C2 Error\\n\");\n\n        return ret;\n\n    }\n\n    if (temp != hs_my_epoch)\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"Erroneous C2 Message epoch does not match up with C1 epoch\\n\");\n\n    if (memcmp(buffer + 8, hs_s1 + 8,\n\n               RTMP_HANDSHAKE_PACKET_SIZE - 8))\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"Erroneous C2 Message random does not match up\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 532}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "int hw_device_setup_for_encode(OutputStream *ost)\n\n{\n\n    enum AVHWDeviceType type;\n\n    HWDevice *dev;\n\n\n\n    type = hw_device_match_type_in_name(ost->enc->name);\n\n    if (type != AV_HWDEVICE_TYPE_NONE) {\n\n        dev = hw_device_get_by_type(type);\n\n        if (!dev) {\n\n            av_log(ost->enc_ctx, AV_LOG_WARNING, \"No device available \"\n\n                   \"for encoder (device type %s for codec %s).\\n\",\n\n                   av_hwdevice_get_type_name(type), ost->enc->name);\n\n            return 0;\n\n        }\n\n        ost->enc_ctx->hw_device_ctx = av_buffer_ref(dev->device_ref);\n\n        if (!ost->enc_ctx->hw_device_ctx)\n\n            return AVERROR(ENOMEM);\n\n        return 0;\n\n    } else {\n\n        // No device required.\n\n        return 0;\n\n    }\n\n}\n", "idx": 533}
{"project": "qemu", "commit_id": "7ec7ae4b973d1471f6f39fc2b6481f69c2b39593", "target": 1, "func": "e1000e_cleanup_msix(E1000EState *s)\n\n{\n\n    if (msix_enabled(PCI_DEVICE(s))) {\n\n        e1000e_unuse_msix_vectors(s, E1000E_MSIX_VEC_NUM);\n\n        msix_uninit(PCI_DEVICE(s), &s->msix, &s->msix);\n\n    }\n\n}\n", "idx": 535}
{"project": "FFmpeg", "commit_id": "158f0545d81b2aca1c936490f80d13988616910e", "target": 1, "func": "ASSStyle *ff_ass_style_get(ASSSplitContext *ctx, const char *style)\n\n{\n\n    ASS *ass = &ctx->ass;\n\n    int i;\n\n\n\n    if (!style || !*style)\n\n        style = \"Default\";\n\n    for (i=0; i<ass->styles_count; i++)\n\n        if (!strcmp(ass->styles[i].name, style))\n\n            return ass->styles + i;\n\n    return NULL;\n\n}\n", "idx": 537}
{"project": "qemu", "commit_id": "7fe4a41c262e2529dc79f77f6fe63c5309fa2fd9", "target": 1, "func": "static void vnc_dpy_copy(DisplayChangeListener *dcl,\n                         int src_x, int src_y,\n                         int dst_x, int dst_y, int w, int h)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    uint8_t *src_row;\n    uint8_t *dst_row;\n    int i, x, y, pitch, inc, w_lim, s;\n    int cmp_bytes;\n    vnc_refresh_server_surface(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vs->force_update = 1;\n            vnc_update_client(vs, 1, true);\n            /* vs might be free()ed here */\n    /* do bitblit op on the local surface too */\n    pitch = vnc_server_fb_stride(vd);\n    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n    y = dst_y;\n    inc = 1;\n    if (dst_y > src_y) {\n        /* copy backwards */\n        src_row += pitch * (h-1);\n        dst_row += pitch * (h-1);\n        pitch = -pitch;\n        y = dst_y + h - 1;\n        inc = -1;\n    w_lim = w - (VNC_DIRTY_PIXELS_PER_BIT - (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n    if (w_lim < 0) {\n        w_lim = w;\n    } else {\n        w_lim = w - (w_lim % VNC_DIRTY_PIXELS_PER_BIT);\n    for (i = 0; i < h; i++) {\n        for (x = 0; x <= w_lim;\n                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n            if (x == w_lim) {\n                if ((s = w - w_lim) == 0)\n                    break;\n            } else if (!x) {\n                s = (VNC_DIRTY_PIXELS_PER_BIT -\n                    (dst_x % VNC_DIRTY_PIXELS_PER_BIT));\n                s = MIN(s, w_lim);\n            } else {\n                s = VNC_DIRTY_PIXELS_PER_BIT;\n            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n            if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n                continue;\n            memmove(dst_row, src_row, cmp_bytes);\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n                    set_bit(((x + dst_x) / VNC_DIRTY_PIXELS_PER_BIT),\n                            vs->dirty[y]);\n        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n        y += inc;\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);", "idx": 538}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuv2yuvX)(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, long dstW, long chrDstW)\n\n{\n\n#ifdef HAVE_MMX\n\n        if(c->flags & SWS_ACCURATE_RND){\n\n                if(uDest){\n\n                        YSCALEYUV2YV12X_ACCURATE(   0, CHR_MMX_FILTER_OFFSET, uDest, chrDstW)\n\n                        YSCALEYUV2YV12X_ACCURATE(4096, CHR_MMX_FILTER_OFFSET, vDest, chrDstW)\n\n                }\n\n\n\n                YSCALEYUV2YV12X_ACCURATE(0, LUM_MMX_FILTER_OFFSET, dest, dstW)\n\n        }else{\n\n                if(uDest){\n\n                        YSCALEYUV2YV12X(   0, CHR_MMX_FILTER_OFFSET, uDest, chrDstW)\n\n                        YSCALEYUV2YV12X(4096, CHR_MMX_FILTER_OFFSET, vDest, chrDstW)\n\n                }\n\n\n\n                YSCALEYUV2YV12X(0, LUM_MMX_FILTER_OFFSET, dest, dstW)\n\n        }\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\nyuv2yuvX_altivec_real(lumFilter, lumSrc, lumFilterSize,\n\n\t\t      chrFilter, chrSrc, chrFilterSize,\n\n\t\t      dest, uDest, vDest, dstW, chrDstW);\n\n#else //HAVE_ALTIVEC\n\nyuv2yuvXinC(lumFilter, lumSrc, lumFilterSize,\n\n\t    chrFilter, chrSrc, chrFilterSize,\n\n\t    dest, uDest, vDest, dstW, chrDstW);\n\n#endif //!HAVE_ALTIVEC\n\n#endif\n\n}\n", "idx": 540}
{"project": "FFmpeg", "commit_id": "975741e79cedc6033e5b02319792534a3a42c4ae", "target": 1, "func": "static int vorbis_residue_decode(vorbis_context *vc, vorbis_residue *vr, uint_fast8_t ch, uint_fast8_t *do_not_decode, float *vec, uint_fast16_t vlen) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t c_p_c=vc->codebooks[vr->classbook].dimensions;\n\n    uint_fast16_t n_to_read=vr->end-vr->begin;\n\n    uint_fast16_t ptns_to_read=n_to_read/vr->partition_size;\n\n    uint_fast8_t classifs[ptns_to_read*vc->audio_channels];\n\n    uint_fast8_t pass;\n\n    uint_fast8_t ch_used;\n\n    uint_fast8_t i,j,l;\n\n    uint_fast16_t k;\n\n\n\n    if (vr->type==2) {\n\n        for(j=1;j<ch;++j) {\n\n                do_not_decode[0]&=do_not_decode[j];  // FIXME - clobbering input\n\n        }\n\n        if (do_not_decode[0]) return 0;\n\n        ch_used=1;\n\n    } else {\n\n        ch_used=ch;\n\n    }\n\n\n\n    AV_DEBUG(\" residue type 0/1/2 decode begin, ch: %d  cpc %d  \\n\", ch, c_p_c);\n\n\n\n    for(pass=0;pass<=vr->maxpass;++pass) { // FIXME OPTIMIZE?\n\n        uint_fast16_t voffset;\n\n        uint_fast16_t partition_count;\n\n        uint_fast16_t j_times_ptns_to_read;\n\n\n\n        voffset=vr->begin;\n\n        for(partition_count=0;partition_count<ptns_to_read;) {  // SPEC        error\n\n            if (!pass) {\n\n                uint_fast32_t inverse_class = ff_inverse[vr->classifications];\n\n                for(j_times_ptns_to_read=0, j=0;j<ch_used;++j) {\n\n                    if (!do_not_decode[j]) {\n\n                        uint_fast32_t temp=get_vlc2(gb, vc->codebooks[vr->classbook].vlc.table,\n\n                        vc->codebooks[vr->classbook].nb_bits, 3);\n\n\n\n                        AV_DEBUG(\"Classword: %d \\n\", temp);\n\n\n\n                        assert(vr->classifications > 1 && temp<=65536); //needed for inverse[]\n\n                        for(i=0;i<c_p_c;++i) {\n\n                            uint_fast32_t temp2;\n\n\n\n                            temp2=(((uint_fast64_t)temp) * inverse_class)>>32;\n\n                            if (partition_count+c_p_c-1-i < ptns_to_read) {\n\n                                classifs[j_times_ptns_to_read+partition_count+c_p_c-1-i]=temp-temp2*vr->classifications;\n\n                            }\n\n                            temp=temp2;\n\n                        }\n\n                    }\n\n                    j_times_ptns_to_read+=ptns_to_read;\n\n                }\n\n            }\n\n            for(i=0;(i<c_p_c) && (partition_count<ptns_to_read);++i) {\n\n                for(j_times_ptns_to_read=0, j=0;j<ch_used;++j) {\n\n                    uint_fast16_t voffs;\n\n\n\n                    if (!do_not_decode[j]) {\n\n                        uint_fast8_t vqclass=classifs[j_times_ptns_to_read+partition_count];\n\n                        int_fast16_t vqbook=vr->books[vqclass][pass];\n\n\n\n                        if (vqbook>=0) {\n\n                            uint_fast16_t coffs;\n\n                            unsigned dim= vc->codebooks[vqbook].dimensions; // not uint_fast8_t: 64bit is slower here on amd64\n\n                            uint_fast16_t step= dim==1 ? vr->partition_size\n\n                                              : FASTDIV(vr->partition_size, dim);\n\n                            vorbis_codebook codebook= vc->codebooks[vqbook];\n\n\n\n                            if (vr->type==0) {\n\n\n\n                                voffs=voffset+j*vlen;\n\n                                for(k=0;k<step;++k) {\n\n                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for(l=0;l<dim;++l) {\n\n                                        vec[voffs+k+l*step]+=codebook.codevectors[coffs+l];  // FPMATH\n\n                                    }\n\n                                }\n\n                            }\n\n                            else if (vr->type==1) {\n\n                                voffs=voffset+j*vlen;\n\n                                for(k=0;k<step;++k) {\n\n                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for(l=0;l<dim;++l, ++voffs) {\n\n                                        vec[voffs]+=codebook.codevectors[coffs+l];  // FPMATH\n\n\n\n                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d  \\n\", pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs);\n\n                                    }\n\n                                }\n\n                            }\n\n                            else if (vr->type==2 && ch==2 && (voffset&1)==0 && (dim&1)==0) { // most frequent case optimized\n\n                                voffs=voffset>>1;\n\n\n\n                                if(dim==2) {\n\n                                    for(k=0;k<step;++k) {\n\n                                        coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2;\n\n                                        vec[voffs+k     ]+=codebook.codevectors[coffs  ];  // FPMATH\n\n                                        vec[voffs+k+vlen]+=codebook.codevectors[coffs+1];  // FPMATH\n\n                                    }\n\n                                } else\n\n                                for(k=0;k<step;++k) {\n\n                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for(l=0;l<dim;l+=2, voffs++) {\n\n                                        vec[voffs     ]+=codebook.codevectors[coffs+l  ];  // FPMATH\n\n                                        vec[voffs+vlen]+=codebook.codevectors[coffs+l+1];  // FPMATH\n\n\n\n                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\", pass, voffset/ch+(voffs%ch)*vlen, vec[voffset/ch+(voffs%ch)*vlen], codebook.codevectors[coffs+l], coffs, l);\n\n                                    }\n\n                                }\n\n\n\n                            }\n\n                            else if (vr->type==2) {\n\n                                voffs=voffset;\n\n\n\n                                for(k=0;k<step;++k) {\n\n                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for(l=0;l<dim;++l, ++voffs) {\n\n                                        vec[voffs/ch+(voffs%ch)*vlen]+=codebook.codevectors[coffs+l];  // FPMATH FIXME use if and counter instead of / and %\n\n\n\n                                        AV_DEBUG(\" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\", pass, voffset/ch+(voffs%ch)*vlen, vec[voffset/ch+(voffs%ch)*vlen], codebook.codevectors[coffs+l], coffs, l);\n\n                                    }\n\n                                }\n\n                            } else {\n\n                                av_log(vc->avccontext, AV_LOG_ERROR, \" Invalid residue type while residue decode?! \\n\");\n\n                                return 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    j_times_ptns_to_read+=ptns_to_read;\n\n                }\n\n                ++partition_count;\n\n                voffset+=vr->partition_size;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 541}
{"project": "qemu", "commit_id": "5f758366c0710d23e43f4d0f83816b98616a13d0", "target": 1, "func": "static CharDriverState *qmp_chardev_open_parallel(ChardevHostdev *parallel,\n\n                                                  Error **errp)\n\n{\n\n#ifdef HAVE_CHARDEV_PARPORT\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(parallel->device, O_RDWR, errp);\n\n    if (error_is_set(errp)) {\n\n        return NULL;\n\n    }\n\n    return qemu_chr_open_pp_fd(fd);\n\n#else\n\n    error_setg(errp, \"character device backend type 'parallel' not supported\");\n\n    return NULL;\n\n#endif\n\n}\n", "idx": 542}
{"project": "qemu", "commit_id": "378df4b23753a11be650af7664ca76bc75cb9f01", "target": 1, "func": "void cpu_exit(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n\n\n    cpu->exit_request = 1;\n\n    cpu_unlink_tb(cpu);\n\n}\n", "idx": 543}
{"project": "FFmpeg", "commit_id": "0e0f8859ba0af33e1145a4c4022e964011e2d75b", "target": 0, "func": "static int hdcd_envelope(int32_t *samples, int count, int stride, int gain, int target_gain, int extend)\n\n{\n\n    int i;\n\n    int32_t *samples_end = samples + stride * count;\n\n\n\n    if (extend) {\n\n        for (i = 0; i < count; i++) {\n\n            int32_t sample = samples[i * stride];\n\n            int32_t asample = abs(sample) - 0x5981;\n\n            if (asample >= 0)\n\n                sample = sample >= 0 ? peaktab[asample] : -peaktab[asample];\n\n            else\n\n                sample <<= 15;\n\n\n\n            samples[i * stride] = sample;\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++)\n\n            samples[i * stride] <<= 15;\n\n    }\n\n\n\n    if (gain <= target_gain) {\n\n        int len = FFMIN(count, target_gain - gain);\n\n        /* attenuate slowly */\n\n        for (i = 0; i < len; i++) {\n\n            ++gain;\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n        count -= len;\n\n    } else {\n\n        int len = FFMIN(count, (gain - target_gain) >> 3);\n\n        /* amplify quickly */\n\n        for (i = 0; i < len; i++) {\n\n            gain -= 8;\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n        if (gain - 8 < target_gain)\n\n            gain = target_gain;\n\n        count -= len;\n\n    }\n\n\n\n    /* hold a steady level */\n\n    if (gain == 0) {\n\n        if (count > 0)\n\n            samples += count * stride;\n\n    } else {\n\n        while (--count >= 0) {\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n    }\n\n\n\n    av_assert0(samples == samples_end);\n\n\n\n    return gain;\n\n}\n", "idx": 544}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_array(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QList *list = NULL;\n\n    QObject *token, *peek;\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_LSQUARE);\n\n\n\n    list = qlist_new();\n\n\n\n    peek = parser_context_peek_token(ctxt);\n\n    if (peek == NULL) {\n\n        parse_error(ctxt, NULL, \"premature EOI\");\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(peek) != JSON_RSQUARE) {\n\n        QObject *obj;\n\n\n\n        obj = parse_value(ctxt, ap);\n\n        if (obj == NULL) {\n\n            parse_error(ctxt, token, \"expecting value\");\n\n            goto out;\n\n        }\n\n\n\n        qlist_append_obj(list, obj);\n\n\n\n        token = parser_context_pop_token(ctxt);\n\n        if (token == NULL) {\n\n            parse_error(ctxt, NULL, \"premature EOI\");\n\n            goto out;\n\n        }\n\n\n\n        while (token_get_type(token) != JSON_RSQUARE) {\n\n            if (token_get_type(token) != JSON_COMMA) {\n\n                parse_error(ctxt, token, \"expected separator in list\");\n\n                goto out;\n\n            }\n\n\n\n            obj = parse_value(ctxt, ap);\n\n            if (obj == NULL) {\n\n                parse_error(ctxt, token, \"expecting value\");\n\n                goto out;\n\n            }\n\n\n\n            qlist_append_obj(list, obj);\n\n\n\n            token = parser_context_pop_token(ctxt);\n\n            if (token == NULL) {\n\n                parse_error(ctxt, NULL, \"premature EOI\");\n\n                goto out;\n\n            }\n\n        }\n\n    } else {\n\n        (void)parser_context_pop_token(ctxt);\n\n    }\n\n\n\n    return QOBJECT(list);\n\n\n\nout:\n\n    QDECREF(list);\n\n    return NULL;\n\n}\n", "idx": 545}
{"project": "qemu", "commit_id": "6b98bd649520d07df4d1b7a0a54ac73bf178519c", "target": 0, "func": "static void raw_aio_unplug(BlockDriverState *bs)\n\n{\n\n#ifdef CONFIG_LINUX_AIO\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->use_aio) {\n\n        laio_io_unplug(bs, s->aio_ctx, true);\n\n    }\n\n#endif\n\n}\n", "idx": 546}
{"project": "qemu", "commit_id": "ce21131a0b9e556bb73bf65eacdc07ccb21f78a9", "target": 0, "func": "void hmp_info_tpm(Monitor *mon, const QDict *qdict)\n\n{\n\n    TPMInfoList *info_list, *info;\n\n    Error *err = NULL;\n\n    unsigned int c = 0;\n\n    TPMPassthroughOptions *tpo;\n\n\n\n    info_list = qmp_query_tpm(&err);\n\n    if (err) {\n\n        monitor_printf(mon, \"TPM device not supported\\n\");\n\n        error_free(err);\n\n        return;\n\n    }\n\n\n\n    if (info_list) {\n\n        monitor_printf(mon, \"TPM device:\\n\");\n\n    }\n\n\n\n    for (info = info_list; info; info = info->next) {\n\n        TPMInfo *ti = info->value;\n\n        monitor_printf(mon, \" tpm%d: model=%s\\n\",\n\n                       c, TpmModel_lookup[ti->model]);\n\n\n\n        monitor_printf(mon, \"  \\\\ %s: type=%s\",\n\n                       ti->id, TpmTypeOptionsKind_lookup[ti->options->kind]);\n\n\n\n        switch (ti->options->kind) {\n\n        case TPM_TYPE_OPTIONS_KIND_PASSTHROUGH:\n\n            tpo = ti->options->passthrough;\n\n            monitor_printf(mon, \"%s%s%s%s\",\n\n                           tpo->has_path ? \",path=\" : \"\",\n\n                           tpo->has_path ? tpo->path : \"\",\n\n                           tpo->has_cancel_path ? \",cancel-path=\" : \"\",\n\n                           tpo->has_cancel_path ? tpo->cancel_path : \"\");\n\n            break;\n\n        case TPM_TYPE_OPTIONS_KIND_MAX:\n\n            break;\n\n        }\n\n        monitor_printf(mon, \"\\n\");\n\n        c++;\n\n    }\n\n    qapi_free_TPMInfoList(info_list);\n\n}\n", "idx": 548}
{"project": "qemu", "commit_id": "fc5b81d1f6df7342f0963120b2cf3e919d6fc08a", "target": 0, "func": "static void tap_set_sndbuf(TAPState *s, int sndbuf, Monitor *mon)\n\n{\n\n#ifdef TUNSETSNDBUF\n\n    if (ioctl(s->fd, TUNSETSNDBUF, &sndbuf) == -1) {\n\n        config_error(mon, \"TUNSETSNDBUF ioctl failed: %s\\n\",\n\n                     strerror(errno));\n\n    }\n\n#else\n\n    config_error(mon, \"No '-net tap,sndbuf=<nbytes>' support available\\n\");\n\n#endif\n\n}\n", "idx": 549}
{"project": "qemu", "commit_id": "c1ded3dc9f2d6caeb62eb3005510837a62b795d2", "target": 0, "func": "ssize_t pcnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size_)\n\n{\n\n    PCNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n    int size = size_;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return -1;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n\n\n    return size_;\n\n}\n", "idx": 550}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_stda_asi(DisasContext *dc, TCGv hi, TCGv addr,\n\n                         int insn, int rd)\n\n{\n\n    TCGv_i32 r_asi, r_size;\n\n    TCGv lo = gen_load_gpr(dc, rd + 1);\n\n    TCGv_i64 t64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_concat_tl_i64(t64, lo, hi);\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(8);\n\n    gen_helper_st_asi(cpu_env, addr, t64, r_asi, r_size);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n    tcg_temp_free_i64(t64);\n\n}\n", "idx": 551}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_enable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_init_iommu(&pbdev->iommu_mr, OBJECT(&pbdev->mr),\n\n                             &s390_iommu_ops, \"iommu-s390\", pbdev->pal + 1);\n\n    memory_region_add_subregion(&pbdev->mr, 0, &pbdev->iommu_mr);\n\n    pbdev->iommu_enabled = true;\n\n}\n", "idx": 552}
{"project": "qemu", "commit_id": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486", "target": 0, "func": "void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    int i;\n\n\n\n    vnc_jobs_join(vs); /* Wait encoding jobs */\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n\n\n    buffer_free(&vs->input);\n\n    buffer_free(&vs->output);\n\n#ifdef CONFIG_VNC_WS\n\n    buffer_free(&vs->ws_input);\n\n    buffer_free(&vs->ws_output);\n\n#endif /* CONFIG_VNC_WS */\n\n\n\n    qapi_free_VncClientInfo(vs->info);\n\n\n\n    vnc_zlib_clear(vs);\n\n    vnc_tight_clear(vs);\n\n    vnc_zrle_clear(vs);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n    vnc_release_modifiers(vs);\n\n\n\n    if (vs->initialized) {\n\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    }\n\n\n\n    if (vs->vd->lock_key_sync)\n\n        qemu_remove_led_event_handler(vs->led);\n\n    vnc_unlock_output(vs);\n\n\n\n    qemu_mutex_destroy(&vs->output_mutex);\n\n    if (vs->bh != NULL) {\n\n        qemu_bh_delete(vs->bh);\n\n    }\n\n    buffer_free(&vs->jobs_buffer);\n\n\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        g_free(vs->lossy_rect[i]);\n\n    }\n\n    g_free(vs->lossy_rect);\n\n    g_free(vs);\n\n}\n", "idx": 553}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "void msix_write_config(PCIDevice *dev, uint32_t addr,\n\n                       uint32_t val, int len)\n\n{\n\n    unsigned enable_pos = dev->msix_cap + MSIX_CONTROL_OFFSET;\n\n    if (addr + len <= enable_pos || addr > enable_pos)\n\n        return;\n\n\n\n    if (msix_enabled(dev))\n\n        qemu_set_irq(dev->irq[0], 0);\n\n}\n", "idx": 554}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "type_init(pflash_cfi02_register_types)\n\n\n\npflash_t *pflash_cfi02_register(hwaddr base,\n\n                                DeviceState *qdev, const char *name,\n\n                                hwaddr size,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1,\n\n                                int be)\n\n{\n\n    DeviceState *dev = qdev_create(NULL, TYPE_CFI_PFLASH02);\n\n\n\n    if (bs && qdev_prop_set_drive(dev, \"drive\", bs)) {\n\n        abort();\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-blocks\", nb_blocs);\n\n    qdev_prop_set_uint32(dev, \"sector-length\", sector_len);\n\n    qdev_prop_set_uint8(dev, \"width\", width);\n\n    qdev_prop_set_uint8(dev, \"mappings\", nb_mappings);\n\n    qdev_prop_set_uint8(dev, \"big-endian\", !!be);\n\n    qdev_prop_set_uint16(dev, \"id0\", id0);\n\n    qdev_prop_set_uint16(dev, \"id1\", id1);\n\n    qdev_prop_set_uint16(dev, \"id2\", id2);\n\n    qdev_prop_set_uint16(dev, \"id3\", id3);\n\n    qdev_prop_set_uint16(dev, \"unlock-addr0\", unlock_addr0);\n\n    qdev_prop_set_uint16(dev, \"unlock-addr1\", unlock_addr1);\n\n    qdev_prop_set_string(dev, \"name\", name);\n\n    qdev_init_nofail(dev);\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, base);\n\n    return CFI_PFLASH02(dev);\n\n}\n", "idx": 556}
{"project": "qemu", "commit_id": "4207117c93357347500235952ce7891688089cb1", "target": 0, "func": "static void akita_init(int ram_size, int vga_ram_size, int boot_device,\n\n                DisplayState *ds, const char **fd_filename, int snapshot,\n\n                const char *kernel_filename, const char *kernel_cmdline,\n\n                const char *initrd_filename, const char *cpu_model)\n\n{\n\n    spitz_common_init(ram_size, vga_ram_size, ds, kernel_filename,\n\n                kernel_cmdline, initrd_filename, akita, 0x2e8);\n\n}\n", "idx": 557}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 558}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "petalogix_ml605_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    DeviceState *dev, *dma, *eth0;\n\n    Object *peer;\n\n    MicroBlazeCPU *cpu;\n\n    SysBusDevice *busdev;\n\n    CPUMBState *env;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    hwaddr ddr_base = MEMORY_BASEADDR;\n\n    MemoryRegion *phys_lmb_bram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32], *cpu_irq;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"microblaze\";\n\n    }\n\n    cpu = cpu_mb_init(cpu_model);\n\n    env = &cpu->env;\n\n\n\n    /* Attach emulated BRAM through the LMB.  */\n\n    memory_region_init_ram(phys_lmb_bram, \"petalogix_ml605.lmb_bram\",\n\n                           LMB_BRAM_SIZE);\n\n    vmstate_register_ram_global(phys_lmb_bram);\n\n    memory_region_add_subregion(address_space_mem, 0x00000000, phys_lmb_bram);\n\n\n\n    memory_region_init_ram(phys_ram, \"petalogix_ml605.ram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ddr_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* 5th parameter 2 means bank-width\n\n     * 10th paremeter 0 means little-endian */\n\n    pflash_cfi01_register(FLASH_BASEADDR,\n\n                          NULL, \"petalogix_ml605.flash\", FLASH_SIZE,\n\n                          dinfo ? dinfo->bdrv : NULL, (64 * 1024),\n\n                          FLASH_SIZE >> 16,\n\n                          2, 0x89, 0x18, 0x0000, 0x0, 0);\n\n\n\n\n\n    cpu_irq = microblaze_pic_init_cpu(env);\n\n    dev = xilinx_intc_create(INTC_BASEADDR, cpu_irq[0], 4);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    serial_mm_init(address_space_mem, UART16550_BASEADDR + 0x1000, 2,\n\n                   irq[5], 115200, serial_hds[0], DEVICE_LITTLE_ENDIAN);\n\n\n\n    /* 2 timers at irq 2 @ 100 Mhz.  */\n\n    xilinx_timer_create(TIMER_BASEADDR, irq[2], 0, 100 * 1000000);\n\n\n\n    /* axi ethernet and dma initialization. */\n\n    qemu_check_nic_model(&nd_table[0], \"xlnx.axi-ethernet\");\n\n    eth0 = qdev_create(NULL, \"xlnx.axi-ethernet\");\n\n    dma = qdev_create(NULL, \"xlnx.axi-dma\");\n\n\n\n    /* FIXME: attach to the sysbus instead */\n\n    object_property_add_child(qdev_get_machine(), \"xilinx-eth\", OBJECT(eth0),\n\n                              NULL);\n\n    object_property_add_child(qdev_get_machine(), \"xilinx-dma\", OBJECT(dma),\n\n                              NULL);\n\n\n\n    peer = object_property_get_link(OBJECT(dma),\n\n                                    \"axistream-connected-target\", NULL);\n\n    xilinx_axiethernet_init(eth0, &nd_table[0], STREAM_SLAVE(peer),\n\n                            0x82780000, irq[3], 0x1000, 0x1000);\n\n\n\n    peer = object_property_get_link(OBJECT(eth0),\n\n                                    \"axistream-connected-target\", NULL);\n\n    xilinx_axidma_init(dma, STREAM_SLAVE(peer), 0x84600000, irq[1], irq[0],\n\n                       100 * 1000000);\n\n\n\n    {\n\n        SSIBus *spi;\n\n\n\n        dev = qdev_create(NULL, \"xlnx.xps-spi\");\n\n        qdev_prop_set_uint8(dev, \"num-ss-bits\", NUM_SPI_FLASHES);\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0x40a00000);\n\n        sysbus_connect_irq(busdev, 0, irq[4]);\n\n\n\n        spi = (SSIBus *)qdev_get_child_bus(dev, \"spi\");\n\n\n\n        for (i = 0; i < NUM_SPI_FLASHES; i++) {\n\n            qemu_irq cs_line;\n\n\n\n            dev = ssi_create_slave(spi, \"n25q128\");\n\n            cs_line = qdev_get_gpio_in(dev, 0);\n\n            sysbus_connect_irq(busdev, i+1, cs_line);\n\n        }\n\n    }\n\n\n\n    microblaze_load_kernel(cpu, ddr_base, ram_size, BINARY_DEVICE_TREE_FILE,\n\n                                                            machine_cpu_reset);\n\n\n\n}\n", "idx": 559}
{"project": "qemu", "commit_id": "f6049f4483d61fa911a0693c2c48ce8308451d33", "target": 0, "func": "void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)\n\n{\n\n    if (num <= VIRTQUEUE_MAX_SIZE) {\n\n        vdev->vq[n].vring.num = num;\n\n        virtqueue_init(&vdev->vq[n]);\n\n    }\n\n}\n", "idx": 560}
{"project": "qemu", "commit_id": "d6f02ce3b8a43ddd8f83553fe754a34b26fb273f", "target": 0, "func": "static void arm_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    CPUState *cs = CPU(dev);\n\n    ARMCPU *cpu = ARM_CPU(dev);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);\n\n    CPUARMState *env = &cpu->env;\n\n    int pagebits;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_exec_realizefn(cs, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Some features automatically imply others: */\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        set_feature(env, ARM_FEATURE_V7);\n\n        set_feature(env, ARM_FEATURE_ARM_DIV);\n\n        set_feature(env, ARM_FEATURE_LPAE);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        set_feature(env, ARM_FEATURE_VAPA);\n\n        set_feature(env, ARM_FEATURE_THUMB2);\n\n        set_feature(env, ARM_FEATURE_MPIDR);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_V6K);\n\n        } else {\n\n            set_feature(env, ARM_FEATURE_V6);\n\n        }\n\n\n\n        /* Always define VBAR for V7 CPUs even if it doesn't exist in\n\n         * non-EL3 configs. This is needed by some legacy boards.\n\n         */\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        set_feature(env, ARM_FEATURE_V6);\n\n        set_feature(env, ARM_FEATURE_MVFR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        set_feature(env, ARM_FEATURE_V5);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_AUXCR);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V5)) {\n\n        set_feature(env, ARM_FEATURE_V4T);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP4)) {\n\n        set_feature(env, ARM_FEATURE_VFP3);\n\n        set_feature(env, ARM_FEATURE_VFP_FP16);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n        set_feature(env, ARM_FEATURE_VFP);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        set_feature(env, ARM_FEATURE_V7MP);\n\n        set_feature(env, ARM_FEATURE_PXN);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n        set_feature(env, ARM_FEATURE_CBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2) &&\n\n        !arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DSP);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V7) &&\n\n        !arm_feature(env, ARM_FEATURE_M) &&\n\n        !arm_feature(env, ARM_FEATURE_MPU)) {\n\n        /* v7VMSA drops support for the old ARMv5 tiny pages, so we\n\n         * can use 4K pages.\n\n         */\n\n        pagebits = 12;\n\n    } else {\n\n        /* For CPUs which might have tiny 1K pages, or which have an\n\n         * MPU and might have small region sizes, stick with 1K pages.\n\n         */\n\n        pagebits = 10;\n\n    }\n\n    if (!set_preferred_target_page_bits(pagebits)) {\n\n        /* This can only ever happen for hotplugging a CPU, or if\n\n         * the board code incorrectly creates a CPU which it has\n\n         * promised via minimum_page_size that it will not.\n\n         */\n\n        error_setg(errp, \"This CPU requires a smaller page size than the \"\n\n                   \"system is using\");\n\n        return;\n\n    }\n\n\n\n    /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.\n\n     * We don't support setting cluster ID ([16..23]) (known as Aff2\n\n     * in later ARM ARM versions), or any of the higher affinity level fields,\n\n     * so these bits always RAZ.\n\n     */\n\n    if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {\n\n        uint32_t Aff1 = cs->cpu_index / ARM_DEFAULT_CPUS_PER_CLUSTER;\n\n        uint32_t Aff0 = cs->cpu_index % ARM_DEFAULT_CPUS_PER_CLUSTER;\n\n        cpu->mp_affinity = (Aff1 << ARM_AFF1_SHIFT) | Aff0;\n\n    }\n\n\n\n    if (cpu->reset_hivecs) {\n\n            cpu->reset_sctlr |= (1 << 13);\n\n    }\n\n\n\n    if (cpu->cfgend) {\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {\n\n            cpu->reset_sctlr |= SCTLR_EE;\n\n        } else {\n\n            cpu->reset_sctlr |= SCTLR_B;\n\n        }\n\n    }\n\n\n\n    if (!cpu->has_el3) {\n\n        /* If the has_el3 CPU property is disabled then we need to disable the\n\n         * feature.\n\n         */\n\n        unset_feature(env, ARM_FEATURE_EL3);\n\n\n\n        /* Disable the security extension feature bits in the processor feature\n\n         * registers as well. These are id_pfr1[7:4] and id_aa64pfr0[15:12].\n\n         */\n\n        cpu->id_pfr1 &= ~0xf0;\n\n        cpu->id_aa64pfr0 &= ~0xf000;\n\n    }\n\n\n\n    if (!cpu->has_el2) {\n\n        unset_feature(env, ARM_FEATURE_EL2);\n\n    }\n\n\n\n    if (!cpu->has_pmu || !kvm_enabled()) {\n\n        cpu->has_pmu = false;\n\n        unset_feature(env, ARM_FEATURE_PMU);\n\n    }\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_EL2)) {\n\n        /* Disable the hypervisor feature bits in the processor feature\n\n         * registers if we don't have EL2. These are id_pfr1[15:12] and\n\n         * id_aa64pfr0_el1[11:8].\n\n         */\n\n        cpu->id_aa64pfr0 &= ~0xf00;\n\n        cpu->id_pfr1 &= ~0xf000;\n\n    }\n\n\n\n    if (!cpu->has_mpu) {\n\n        unset_feature(env, ARM_FEATURE_MPU);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_MPU) &&\n\n        arm_feature(env, ARM_FEATURE_V7)) {\n\n        uint32_t nr = cpu->pmsav7_dregion;\n\n\n\n        if (nr > 0xff) {\n\n            error_setg(errp, \"PMSAv7 MPU #regions invalid %\" PRIu32, nr);\n\n            return;\n\n        }\n\n\n\n        if (nr) {\n\n            env->pmsav7.drbar = g_new0(uint32_t, nr);\n\n            env->pmsav7.drsr = g_new0(uint32_t, nr);\n\n            env->pmsav7.dracr = g_new0(uint32_t, nr);\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n\n\n    register_cp_regs_for_features(cpu);\n\n    arm_cpu_register_gdb_regs_for_features(cpu);\n\n\n\n    init_cpreg_list(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->has_el3) {\n\n        cs->num_ases = 2;\n\n    } else {\n\n        cs->num_ases = 1;\n\n    }\n\n\n\n    if (cpu->has_el3) {\n\n        AddressSpace *as;\n\n\n\n        if (!cpu->secure_memory) {\n\n            cpu->secure_memory = cs->memory;\n\n        }\n\n        as = address_space_init_shareable(cpu->secure_memory,\n\n                                          \"cpu-secure-memory\");\n\n        cpu_address_space_init(cs, as, ARMASIdx_S);\n\n    }\n\n    cpu_address_space_init(cs,\n\n                           address_space_init_shareable(cs->memory,\n\n                                                        \"cpu-memory\"),\n\n                           ARMASIdx_NS);\n\n#endif\n\n\n\n    qemu_init_vcpu(cs);\n\n    cpu_reset(cs);\n\n\n\n    acc->parent_realize(dev, errp);\n\n}\n", "idx": 561}
{"project": "qemu", "commit_id": "9445673ea67c272616b9f718396e267caa6446b7", "target": 0, "func": "static bool nbd_process_legacy_socket_options(QDict *output_options,\n\n                                              QemuOpts *legacy_opts,\n\n                                              Error **errp)\n\n{\n\n    const char *path = qemu_opt_get(legacy_opts, \"path\");\n\n    const char *host = qemu_opt_get(legacy_opts, \"host\");\n\n    const char *port = qemu_opt_get(legacy_opts, \"port\");\n\n    const QDictEntry *e;\n\n\n\n    if (!path && !host && !port) {\n\n        return true;\n\n    }\n\n\n\n    for (e = qdict_first(output_options); e; e = qdict_next(output_options, e))\n\n    {\n\n        if (strstart(e->key, \"server.\", NULL)) {\n\n            error_setg(errp, \"Cannot use 'server' and path/host/port at the \"\n\n                       \"same time\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    if (path && host) {\n\n        error_setg(errp, \"path and host may not be used at the same time\");\n\n        return false;\n\n    } else if (path) {\n\n        if (port) {\n\n            error_setg(errp, \"port may not be used without host\");\n\n            return false;\n\n        }\n\n\n\n        qdict_put(output_options, \"server.type\", qstring_from_str(\"unix\"));\n\n        qdict_put(output_options, \"server.data.path\", qstring_from_str(path));\n\n    } else if (host) {\n\n        qdict_put(output_options, \"server.type\", qstring_from_str(\"inet\"));\n\n        qdict_put(output_options, \"server.data.host\", qstring_from_str(host));\n\n        qdict_put(output_options, \"server.data.port\",\n\n                  qstring_from_str(port ?: stringify(NBD_DEFAULT_PORT)));\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 562}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_linear_bitblt_write(void *opaque,\n\n                                       target_phys_addr_t addr,\n\n                                       uint64_t val,\n\n                                       unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n\n\n    if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\n\t/* bitblt */\n\n\t*s->cirrus_srcptr++ = (uint8_t) val;\n\n\tif (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\n\t    cirrus_bitblt_cputovideo_next(s);\n\n\t}\n\n    }\n\n}\n", "idx": 563}
{"project": "qemu", "commit_id": "1f001dc7bc9e435bf231a5b0edcad1c7c2bd6214", "target": 0, "func": "static int default_monitor_get_fd(Monitor *mon, const char *name, Error **errp)\n\n{\n\n    error_setg(errp, \"only QEMU supports file descriptor passing\");\n\n    return -1;\n\n}\n", "idx": 564}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "uint64_t helper_st_virt_to_phys (uint64_t virtaddr)\n\n{\n\n    uint64_t tlb_addr, physaddr;\n\n    int index, mmu_idx;\n\n    void *retaddr;\n\n\n\n    mmu_idx = cpu_mmu_index(env);\n\n    index = (virtaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n redo:\n\n    tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n\n    if ((virtaddr & TARGET_PAGE_MASK) ==\n\n        (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n\n        physaddr = virtaddr + env->tlb_table[mmu_idx][index].addend;\n\n    } else {\n\n        /* the page is not in the TLB : fill it */\n\n        retaddr = GETPC();\n\n        tlb_fill(virtaddr, 1, mmu_idx, retaddr);\n\n        goto redo;\n\n    }\n\n    return physaddr;\n\n}\n", "idx": 565}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_recovery_point(H264Context *h)\n\n{\n\n    h->sei_recovery_frame_cnt = get_ue_golomb(&h->gb);\n\n\n\n    /* 1b exact_match_flag,\n\n     * 1b broken_link_flag,\n\n     * 2b changing_slice_group_idc */\n\n    skip_bits(&h->gb, 4);\n\n\n\n    if (h->avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(h->avctx, AV_LOG_DEBUG, \"sei_recovery_frame_cnt: %d\\n\", h->sei_recovery_frame_cnt);\n\n\n\n    h->has_recovery_point = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 567}
{"project": "FFmpeg", "commit_id": "20e8be0c20c7b51964fa4d317073bd36b983eb55", "target": 1, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if (s->pb->seekable && !mkv->is_live)\n\n        put_ebml_void(s->pb, avio_tell(pb));\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_chapters(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        ret = mkv_write_tags(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    if (!s->pb->seekable && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (pb->seekable && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 568}
{"project": "qemu", "commit_id": "84273177f25886b3476138470280890001debcbc", "target": 1, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n        return sizeof(target_ulong);\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n        env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n        return 16;\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            env->eip = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n#define LOAD_SEG(index, sreg)\\\n\n            tmp = ldl_p(mem_buf);\\\n\n            if (tmp != env->segs[sreg].selector)\\\n\n                cpu_x86_load_seg(env, sreg, tmp);\\\n\n            return 4\n\n#else\n\n/* FIXME: Honor segment registers.  Needs to avoid raising an exception\n\n   when the selector is invalid.  */\n\n#define LOAD_SEG(index, sreg) return 4\n\n#endif\n\n        case IDX_SEG_REGS:     LOAD_SEG(10, R_CS);\n\n        case IDX_SEG_REGS + 1: LOAD_SEG(11, R_SS);\n\n        case IDX_SEG_REGS + 2: LOAD_SEG(12, R_DS);\n\n        case IDX_SEG_REGS + 3: LOAD_SEG(13, R_ES);\n\n        case IDX_SEG_REGS + 4: LOAD_SEG(14, R_FS);\n\n        case IDX_SEG_REGS + 5: LOAD_SEG(15, R_GS);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */  return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */ return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */ return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */ return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */ return 4;\n\n        case IDX_FP_REGS + 15: /* fop */   return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 570}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUS390XState *env)\n\n{\n\n    int i;\n\n    rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof *frame);\n\n    qemu_log(\"%s: frame_addr 0x%llx\\n\", __FUNCTION__,\n\n             (unsigned long long)frame_addr);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    qemu_log(\"%s: 1\\n\", __FUNCTION__);\n\n    copy_siginfo_to_user(&frame->info, info);\n\n\n\n    /* Create the ucontext.  */\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user((abi_ulong)0, (abi_ulong *)&frame->uc.tuc_link);\n\n    __put_user(target_sigaltstack_used.ss_sp, &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(get_sp_from_cpustate(env)),\n\n                      &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size, &frame->uc.tuc_stack.ss_size);\n\n    save_sigregs(env, &frame->uc.tuc_mcontext);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n        __put_user((abi_ulong)set->sig[i],\n\n        (abi_ulong *)&frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    /* Set up to return from userspace.  If provided, use a stub\n\n       already in userspace.  */\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;\n\n    } else {\n\n        env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;\n\n        if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_rt_sigreturn,\n\n                       (uint16_t *)(frame->retcode))) {\n\n            goto give_sigsegv;\n\n        }\n\n    }\n\n\n\n    /* Set up backchain. */\n\n    if (__put_user(env->regs[15], (abi_ulong *) frame)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    /* Set up registers for signal handler */\n\n    env->regs[15] = frame_addr;\n\n    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;\n\n\n\n    env->regs[2] = sig; //map_signal(sig);\n\n    env->regs[3] = frame_addr + offsetof(typeof(*frame), info);\n\n    env->regs[4] = frame_addr + offsetof(typeof(*frame), uc);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    qemu_log(\"%s: give_sigsegv\\n\", __FUNCTION__);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 571}
{"project": "FFmpeg", "commit_id": "d662143f064636f11d92083cd9aa4f907cf97d59", "target": 1, "func": "static int dxv_decompress_dxt5(AVCodecContext *avctx)\n\n{\n\n    DXVContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    uint32_t value, op;\n\n    int idx, prev, state = 0;\n\n    int pos = 4;\n\n    int run = 0;\n\n    int probe, check;\n\n\n\n    /* Copy the first four elements */\n\n    AV_WL32(ctx->tex_data +  0, bytestream2_get_le32(gbc));\n\n    AV_WL32(ctx->tex_data +  4, bytestream2_get_le32(gbc));\n\n    AV_WL32(ctx->tex_data +  8, bytestream2_get_le32(gbc));\n\n    AV_WL32(ctx->tex_data + 12, bytestream2_get_le32(gbc));\n\n\n\n    /* Process input until the whole texture has been filled */\n\n    while (pos + 2 <= ctx->tex_size / 4) {\n\n        if (run) {\n\n            run--;\n\n\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n        } else {\n\n\n\n            if (state == 0) {\n\n                value = bytestream2_get_le32(gbc);\n\n                state = 16;\n\n            }\n\n            op = value & 0x3;\n\n            value >>= 2;\n\n            state--;\n\n\n\n            switch (op) {\n\n            case 0:\n\n                /* Long copy */\n\n                check = bytestream2_get_byte(gbc) + 1;\n\n                if (check == 256) {\n\n                    do {\n\n                        probe = bytestream2_get_le16(gbc);\n\n                        check += probe;\n\n                    } while (probe == 0xFFFF);\n\n                }\n\n                while (check && pos + 4 <= ctx->tex_size / 4) {\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                    pos++;\n\n\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                    pos++;\n\n\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                    pos++;\n\n\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                    pos++;\n\n\n\n                    check--;\n\n                }\n\n\n\n                /* Restart (or exit) the loop */\n\n                continue;\n\n                break;\n\n            case 1:\n\n                /* Load new run value */\n\n                run = bytestream2_get_byte(gbc);\n\n                if (run == 255) {\n\n                    do {\n\n                        probe = bytestream2_get_le16(gbc);\n\n                        run += probe;\n\n                    } while (probe == 0xFFFF);\n\n                }\n\n\n\n                /* Copy two dwords from previous data */\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n                break;\n\n            case 2:\n\n                /* Copy two dwords from a previous index */\n\n                idx = 8 + bytestream2_get_le16(gbc);\n\n                if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)\n\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n                break;\n\n            case 3:\n\n                /* Copy two dwords from input */\n\n                prev = bytestream2_get_le32(gbc);\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n\n\n                prev = bytestream2_get_le32(gbc);\n\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n                pos++;\n\n                break;\n\n            }\n\n        }\n\n\n\n        CHECKPOINT(4);\n\n        if (pos + 2 > ctx->tex_size / 4)\n\n\n\n\n        /* Copy two elements from a previous offset or from the input buffer */\n\n        if (op) {\n\n            if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)\n\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n        } else {\n\n            CHECKPOINT(4);\n\n\n\n            if (op && (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4))\n\n\n            if (op)\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            else\n\n                prev = bytestream2_get_le32(gbc);\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n\n\n            CHECKPOINT(4);\n\n\n\n            if (op)\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            else\n\n                prev = bytestream2_get_le32(gbc);\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 575}
{"project": "qemu", "commit_id": "4fd811a6bd0b8f24f4761fc281454494c336d310", "target": 1, "func": "static void gd_update_geometry_hints(VirtualConsole *vc)\n\n{\n\n    GtkDisplayState *s = vc->s;\n\n    GdkWindowHints mask = 0;\n\n    GdkGeometry geo = {};\n\n    GtkWidget *geo_widget = NULL;\n\n    GtkWindow *geo_window;\n\n\n\n    if (vc->type == GD_VC_GFX) {\n\n        if (!vc->gfx.ds) {\n\n            return;\n\n        }\n\n        if (s->free_scale) {\n\n            geo.min_width  = surface_width(vc->gfx.ds) * VC_SCALE_MIN;\n\n            geo.min_height = surface_height(vc->gfx.ds) * VC_SCALE_MIN;\n\n            mask |= GDK_HINT_MIN_SIZE;\n\n        } else {\n\n            geo.min_width  = surface_width(vc->gfx.ds) * vc->gfx.scale_x;\n\n            geo.min_height = surface_height(vc->gfx.ds) * vc->gfx.scale_y;\n\n            mask |= GDK_HINT_MIN_SIZE;\n\n        }\n\n        geo_widget = vc->gfx.drawing_area;\n\n        gtk_widget_set_size_request(geo_widget, geo.min_width, geo.min_height);\n\n\n\n#if defined(CONFIG_VTE)\n\n    } else if (vc->type == GD_VC_VTE) {\n\n        VteTerminal *term = VTE_TERMINAL(vc->vte.terminal);\n\n        GtkBorder *ib;\n\n\n\n        geo.width_inc  = vte_terminal_get_char_width(term);\n\n        geo.height_inc = vte_terminal_get_char_height(term);\n\n        mask |= GDK_HINT_RESIZE_INC;\n\n        geo.base_width  = geo.width_inc;\n\n        geo.base_height = geo.height_inc;\n\n        mask |= GDK_HINT_BASE_SIZE;\n\n        geo.min_width  = geo.width_inc * VC_TERM_X_MIN;\n\n        geo.min_height = geo.height_inc * VC_TERM_Y_MIN;\n\n        mask |= GDK_HINT_MIN_SIZE;\n\n        gtk_widget_style_get(vc->vte.terminal, \"inner-border\", &ib, NULL);\n\n        geo.base_width  += ib->left + ib->right;\n\n        geo.base_height += ib->top + ib->bottom;\n\n        geo.min_width   += ib->left + ib->right;\n\n        geo.min_height  += ib->top + ib->bottom;\n\n        geo_widget = vc->vte.terminal;\n\n#endif\n\n    }\n\n\n\n    geo_window = GTK_WINDOW(vc->window ? vc->window : s->window);\n\n    gtk_window_set_geometry_hints(geo_window, geo_widget, &geo, mask);\n\n}\n", "idx": 576}
{"project": "qemu", "commit_id": "2aaa1940684a3bf2b381fd2a8ff26c287a05109d", "target": 1, "func": "static uint32_t cc_calc_abs_64(int64_t dst)\n\n{\n\n    if ((uint64_t)dst == 0x8000000000000000ULL) {\n\n        return 3;\n\n    } else if (dst) {\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 577}
{"project": "qemu", "commit_id": "f811f97040a48358b456b46ecbc9167f0131034f", "target": 1, "func": "static void virtio_serial_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n    QLIST_REMOVE(vser, next);\n    g_free(vser->ivqs);\n    g_free(vser->ovqs);\n    g_free(vser->ports_map);\n    if (vser->post_load) {\n        g_free(vser->post_load->connected);\n        timer_del(vser->post_load->timer);\n        timer_free(vser->post_load->timer);\n        g_free(vser->post_load);\n    }\n    virtio_cleanup(vdev);\n}", "idx": 579}
{"project": "FFmpeg", "commit_id": "b6671787db5b5d53e065f88e52a35d94cb50504c", "target": 1, "func": "static int flashsv2_prime(FlashSVContext *s, uint8_t *src, int size)\n{\n    z_stream zs;\n    int zret; // Zlib return code\n    zs.zalloc = NULL;\n    zs.zfree  = NULL;\n    zs.opaque = NULL;\n    s->zstream.next_in   = src;\n    s->zstream.avail_in  = size;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n    if (deflateInit(&zs, 0) != Z_OK)\n        return -1;\n    zs.next_in   = s->tmpblock;\n    zs.avail_in  = s->block_size * 3 - s->zstream.avail_out;\n    zs.next_out  = s->deflate_block;\n    zs.avail_out = s->deflate_block_size;\n    deflate(&zs, Z_SYNC_FLUSH);\n    deflateEnd(&zs);\n    if ((zret = inflateReset(&s->zstream)) != Z_OK) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Inflate reset error: %d\\n\", zret);\n        return AVERROR_UNKNOWN;\n    }\n    s->zstream.next_in   = s->deflate_block;\n    s->zstream.avail_in  = s->deflate_block_size - zs.avail_out;\n    s->zstream.next_out  = s->tmpblock;\n    s->zstream.avail_out = s->block_size * 3;\n    inflate(&s->zstream, Z_SYNC_FLUSH);\n    return 0;\n}", "idx": 580}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int vid_probe(AVProbeData *p)\n\n{\n\n    // little endian VID tag, file starts with \"VID\\0\"\n\n    if (p->buf_size < 4 || AV_RL32(p->buf) != MKTAG('V', 'I', 'D', 0))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 582}
{"project": "qemu", "commit_id": "e64e353590c2584b41cd1db925f67042a05f4250", "target": 1, "func": "static inline void gen_intermediate_code_internal(X86CPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  bool search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUX86State *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_ptr;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj;\n\n    uint64_t flags;\n\n    target_ulong pc_start;\n\n    target_ulong cs_base;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n    cs_base = tb->cs_base;\n\n    flags = tb->flags;\n\n\n\n    dc->pe = (flags >> HF_PE_SHIFT) & 1;\n\n    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;\n\n    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;\n\n    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = 0;\n\n    dc->vm86 = (flags >> VM_SHIFT) & 1;\n\n    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;\n\n    dc->iopl = (flags >> IOPL_SHIFT) & 3;\n\n    dc->tf = (flags >> TF_SHIFT) & 1;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    dc->cc_op_dirty = false;\n\n    dc->cs_base = cs_base;\n\n    dc->tb = tb;\n\n    dc->popl_esp_hack = 0;\n\n    /* select memory access functions */\n\n    dc->mem_index = 0;\n\n    if (flags & HF_SOFTMMU_MASK) {\n\n        dc->mem_index = cpu_mmu_index(env);\n\n    }\n\n    dc->cpuid_features = env->features[FEAT_1_EDX];\n\n    dc->cpuid_ext_features = env->features[FEAT_1_ECX];\n\n    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];\n\n    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];\n\n    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];\n\n#ifdef TARGET_X86_64\n\n    dc->lma = (flags >> HF_LMA_SHIFT) & 1;\n\n    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;\n\n#endif\n\n    dc->flags = flags;\n\n    dc->jmp_opt = !(dc->tf || cs->singlestep_enabled ||\n\n                    (flags & HF_INHIBIT_IRQ_MASK)\n\n#ifndef CONFIG_SOFTMMU\n\n                    || (flags & HF_SOFTMMU_MASK)\n\n#endif\n\n                    );\n\n#if 0\n\n    /* check addseg logic */\n\n    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))\n\n        printf(\"ERROR addseg\\n\");\n\n#endif\n\n\n\n    cpu_T[0] = tcg_temp_new();\n\n    cpu_T[1] = tcg_temp_new();\n\n    cpu_A0 = tcg_temp_new();\n\n\n\n    cpu_tmp0 = tcg_temp_new();\n\n    cpu_tmp1_i64 = tcg_temp_new_i64();\n\n    cpu_tmp2_i32 = tcg_temp_new_i32();\n\n    cpu_tmp3_i32 = tcg_temp_new_i32();\n\n    cpu_tmp4 = tcg_temp_new();\n\n    cpu_ptr0 = tcg_temp_new_ptr();\n\n    cpu_ptr1 = tcg_temp_new_ptr();\n\n    cpu_cc_srcT = tcg_temp_local_new();\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    pc_ptr = pc_start;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_tb_start();\n\n    for(;;) {\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == pc_ptr &&\n\n                    !((bp->flags & BP_CPU) && (tb->flags & HF_RF_MASK))) {\n\n                    gen_debug(dc, pc_ptr - dc->cs_base);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            tcg_ctx.gen_opc_pc[lj] = pc_ptr;\n\n            gen_opc_cc_op[lj] = dc->cc_op;\n\n            tcg_ctx.gen_opc_instr_start[lj] = 1;\n\n            tcg_ctx.gen_opc_icount[lj] = num_insns;\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        pc_ptr = disas_insn(env, dc, pc_ptr);\n\n        num_insns++;\n\n        /* stop translation if indicated */\n\n        if (dc->is_jmp)\n\n            break;\n\n        /* if single step mode, we generate only one instruction and\n\n           generate an exception */\n\n        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear\n\n           the flag and abort the translation to give the irqs a\n\n           change to be happen */\n\n        if (dc->tf || dc->singlestep_enabled ||\n\n            (flags & HF_INHIBIT_IRQ_MASK)) {\n\n            gen_jmp_im(pc_ptr - dc->cs_base);\n\n            gen_eob(dc);\n\n            break;\n\n        }\n\n        /* if too long translation, stop generation too */\n\n        if (tcg_ctx.gen_opc_ptr >= gen_opc_end ||\n\n            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||\n\n            num_insns >= max_insns) {\n\n            gen_jmp_im(pc_ptr - dc->cs_base);\n\n            gen_eob(dc);\n\n            break;\n\n        }\n\n        if (singlestep) {\n\n            gen_jmp_im(pc_ptr - dc->cs_base);\n\n            gen_eob(dc);\n\n            break;\n\n        }\n\n    }\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    /* we don't forget to fill the last values */\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            tcg_ctx.gen_opc_instr_start[lj++] = 0;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        int disas_flags;\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n#ifdef TARGET_X86_64\n\n        if (dc->code64)\n\n            disas_flags = 2;\n\n        else\n\n#endif\n\n            disas_flags = !dc->code32;\n\n        log_target_disas(env, pc_start, pc_ptr - pc_start, disas_flags);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (!search_pc) {\n\n        tb->size = pc_ptr - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n}\n", "idx": 584}
{"project": "qemu", "commit_id": "c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7", "target": 1, "func": "static always_inline void gen_op_subfo (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subf();\n\n    gen_op_check_subfo();\n\n}\n", "idx": 586}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void fd_accept_incoming_migration(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n\n\n    qemu_set_fd_handler2(qemu_get_fd(f), NULL, NULL, NULL, NULL);\n\n    process_incoming_migration(f);\n\n}\n", "idx": 587}
{"project": "qemu", "commit_id": "949868633f0454715af1781c0f377413b6ab000e", "target": 1, "func": "hwaddr ppc_hash64_get_phys_page_debug(PowerPCCPU *cpu, target_ulong addr)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    unsigned apshift;\n\n\n\n    if (msr_dr == 0) {\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        return addr & 0x0FFFFFFFFFFFFFFFULL;\n\n    }\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return -1;\n\n    }\n\n\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, addr, &pte);\n\n    if (pte_offset == -1) {\n\n        return -1;\n\n    }\n\n\n\n    apshift = hpte_page_shift(slb->sps, pte.pte0, pte.pte1);\n\n    if (!apshift) {\n\n        return -1;\n\n    }\n\n\n\n    return deposit64(pte.pte1 & HPTE64_R_RPN, 0, apshift, addr)\n\n        & TARGET_PAGE_MASK;\n\n}\n", "idx": 588}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int adx_read_header(AVFormatContext *s)\n\n{\n\n    ADXDemuxerContext *c = s->priv_data;\n\n    AVCodecParameters *par;\n\n\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    par = s->streams[0]->codecpar;\n\n\n\n    if (avio_rb16(s->pb) != 0x8000)\n\n        return AVERROR_INVALIDDATA;\n\n    c->header_size = avio_rb16(s->pb) + 4;\n\n    avio_seek(s->pb, -4, SEEK_CUR);\n\n\n\n    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (par->extradata_size < 12) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid extradata size.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    par->channels    = AV_RB8 (par->extradata + 7);\n\n    par->sample_rate = AV_RB32(par->extradata + 8);\n\n\n\n    if (par->channels <= 0) {\n\n        av_log(s, AV_LOG_ERROR, \"invalid number of channels %d\\n\", par->channels);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (par->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", par->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    par->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    par->codec_id    = s->iformat->raw_codec_id;\n\n    par->bit_rate    = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;\n\n\n\n    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);\n\n\n\n    return 0;\n\n}\n", "idx": 589}
{"project": "qemu", "commit_id": "85d9d044471f93c48c5c396f7e217b4ef12f69f8", "target": 1, "func": "static void virgl_cmd_get_capset(VirtIOGPU *g,\n\n                                 struct virtio_gpu_ctrl_command *cmd)\n\n{\n\n    struct virtio_gpu_get_capset gc;\n\n    struct virtio_gpu_resp_capset *resp;\n\n    uint32_t max_ver, max_size;\n\n    VIRTIO_GPU_FILL_CMD(gc);\n\n\n\n    virgl_renderer_get_cap_set(gc.capset_id, &max_ver,\n\n                               &max_size);\n\n    if (!max_size) {\n\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n\n        return;\n\n    }\n\n\n\n    resp = g_malloc(sizeof(*resp) + max_size);\n\n    resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET;\n\n    virgl_renderer_fill_caps(gc.capset_id,\n\n                             gc.capset_version,\n\n                             (void *)resp->capset_data);\n\n    virtio_gpu_ctrl_response(g, cmd, &resp->hdr, sizeof(*resp) + max_size);\n\n    g_free(resp);\n\n}\n", "idx": 590}
{"project": "qemu", "commit_id": "69c98726537627e708abb8fcb33e3a2b10e40bf1", "target": 1, "func": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags)\n{\n    BDRVQcowState *s = bs->opaque;\n    int len, i, ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n    if (header.magic != QCOW_MAGIC) {\n        ret = -EMEDIUMTYPE;\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n    s->qcow_version = header.version;\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table);\n        report_unsupported_feature(bs, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        ret = -EINVAL;\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        ret = -EINVAL;\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n    /* read the level 1 table */\n    s->l1_size = header.l1_size;\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        ret = -EFBIG;\n    s->l1_vm_state_index = l1_vm_state_index;\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        ret = -EINVAL;\n    s->l1_table_offset = header.l1_table_offset;\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {\n        ret = -EINVAL;\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > 1023) {\n            len = 1023;\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n        bs->backing_file[len] = '\\0';\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && s->autoclear_features != 0) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n    /* Repair image if dirty */\n    if (!(flags & BDRV_O_CHECK) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create_nofail(&qcow2_runtime_opts);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (error_is_set(&local_err)) {\n        qerror_report_err(local_err);\n        error_free(local_err);\n        ret = -EINVAL;\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n    qemu_opts_del(opts);\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        qerror_report(ERROR_CLASS_GENERIC_ERROR, \"Lazy refcounts require \"\n            \"a qcow2 image with at least qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n#endif\n    return ret;\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;", "idx": 591}
{"project": "FFmpeg", "commit_id": "5fbd97fc756a827f62f556c66272f851cc3c7f90", "target": 1, "func": "static void decode_subband(DiracContext *s, GetBitContext *gb, int quant,\n\n                           int slice_x, int slice_y, int bits_end,\n\n                           SubBand *b1, SubBand *b2)\n\n{\n\n    int left   = b1->width  * slice_x    / s->num_x;\n\n    int right  = b1->width  *(slice_x+1) / s->num_x;\n\n    int top    = b1->height * slice_y    / s->num_y;\n\n    int bottom = b1->height *(slice_y+1) / s->num_y;\n\n\n\n    int qfactor = qscale_tab[quant & 0x7f];\n\n    int qoffset = qoffset_intra_tab[quant & 0x7f] + 2;\n\n\n\n    uint8_t *buf1 =      b1->ibuf + top * b1->stride;\n\n    uint8_t *buf2 = b2 ? b2->ibuf + top * b2->stride: NULL;\n\n    int x, y;\n\n    /* we have to constantly check for overread since the spec explicitly\n\n       requires this, with the meaning that all remaining coeffs are set to 0 */\n\n    if (get_bits_count(gb) >= bits_end)\n\n        return;\n\n\n\n    if (s->pshift) {\n\n        for (y = top; y < bottom; y++) {\n\n            for (x = left; x < right; x++) {\n\n                PARSE_VALUES(int32_t, x, gb, bits_end, buf1, buf2);\n\n            }\n\n            buf1 += b1->stride;\n\n            if (buf2)\n\n                buf2 += b2->stride;\n\n        }\n\n    }\n\n    else {\n\n        for (y = top; y < bottom; y++) {\n\n            for (x = left; x < right; x++) {\n\n                PARSE_VALUES(int16_t, x, gb, bits_end, buf1, buf2);\n\n            }\n\n            buf1 += b1->stride;\n\n            if (buf2)\n\n                buf2 += b2->stride;\n\n        }\n\n    }\n\n}\n", "idx": 592}
{"project": "qemu", "commit_id": "5b120785e70a9a48b43e3f1f156a10a015334a28", "target": 0, "func": "int spapr_h_cas_compose_response(sPAPRMachineState *spapr,\n\n                                 target_ulong addr, target_ulong size,\n\n                                 bool cpu_update,\n\n                                 sPAPROptionVector *ov5_updates)\n\n{\n\n    void *fdt, *fdt_skel;\n\n    sPAPRDeviceTreeUpdateHeader hdr = { .version_id = 1 };\n\n\n\n    size -= sizeof(hdr);\n\n\n\n    /* Create sceleton */\n\n    fdt_skel = g_malloc0(size);\n\n    _FDT((fdt_create(fdt_skel, size)));\n\n    _FDT((fdt_begin_node(fdt_skel, \"\")));\n\n    _FDT((fdt_end_node(fdt_skel)));\n\n    _FDT((fdt_finish(fdt_skel)));\n\n    fdt = g_malloc0(size);\n\n    _FDT((fdt_open_into(fdt_skel, fdt, size)));\n\n    g_free(fdt_skel);\n\n\n\n    /* Fixup cpu nodes */\n\n    if (cpu_update) {\n\n        _FDT((spapr_fixup_cpu_dt(fdt, spapr)));\n\n    }\n\n\n\n    if (spapr_dt_cas_updates(spapr, fdt, ov5_updates)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Pack resulting tree */\n\n    _FDT((fdt_pack(fdt)));\n\n\n\n    if (fdt_totalsize(fdt) + sizeof(hdr) > size) {\n\n        trace_spapr_cas_failed(size);\n\n        return -1;\n\n    }\n\n\n\n    cpu_physical_memory_write(addr, &hdr, sizeof(hdr));\n\n    cpu_physical_memory_write(addr + sizeof(hdr), fdt, fdt_totalsize(fdt));\n\n    trace_spapr_cas_continue(fdt_totalsize(fdt) + sizeof(hdr));\n\n    g_free(fdt);\n\n\n\n    return 0;\n\n}\n", "idx": 593}
{"project": "qemu", "commit_id": "1ad9f0a464fe78d30ee60b3629f7a825cf2fab13", "target": 0, "func": "void kvmppc_hash64_write_pte(CPUPPCState *env, target_ulong pte_index,\n\n                             target_ulong pte0, target_ulong pte1)\n\n{\n\n    int htab_fd;\n\n    struct kvm_get_htab_fd ghf;\n\n    struct kvm_get_htab_buf hpte_buf;\n\n\n\n    ghf.flags = 0;\n\n    ghf.start_index = 0;     /* Ignored */\n\n    htab_fd = kvm_vm_ioctl(kvm_state, KVM_PPC_GET_HTAB_FD, &ghf);\n\n    if (htab_fd < 0) {\n\n        goto error_out;\n\n    }\n\n\n\n    hpte_buf.header.n_valid = 1;\n\n    hpte_buf.header.n_invalid = 0;\n\n    hpte_buf.header.index = pte_index;\n\n    hpte_buf.hpte[0] = pte0;\n\n    hpte_buf.hpte[1] = pte1;\n\n    /*\n\n     * Write the hpte entry.\n\n     * CAUTION: write() has the warn_unused_result attribute. Hence we\n\n     * need to check the return value, even though we do nothing.\n\n     */\n\n    if (write(htab_fd, &hpte_buf, sizeof(hpte_buf)) < 0) {\n\n        goto out_close;\n\n    }\n\n\n\nout_close:\n\n    close(htab_fd);\n\n    return;\n\n\n\nerror_out:\n\n    return;\n\n}\n", "idx": 594}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "func": "int tcp_start_outgoing_migration(MigrationState *s, const char *host_port,\n\n                                 Error **errp)\n\n{\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n\n\n    s->fd = inet_connect(host_port, false, errp);\n\n\n\n    if (!error_is_set(errp)) {\n\n        migrate_fd_connect(s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_IN_PROGRESS)) {\n\n        DPRINTF(\"connect in progress\\n\");\n\n        qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CREATE_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        return -1;\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        migrate_fd_error(s);\n\n        return -1;\n\n    } else {\n\n        DPRINTF(\"unknown error\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 595}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    if (v9fs_device_realize_common(s, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    v->config_size = sizeof(struct virtio_9p_config) + strlen(s->fsconf.tag);\n\n    virtio_init(vdev, \"virtio-9p\", VIRTIO_ID_9P, v->config_size);\n\n    v->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n    v9fs_register_transport(s, &virtio_9p_transport);\n\n\n\nout:\n\n    return;\n\n}\n", "idx": 596}
{"project": "qemu", "commit_id": "820613b1c1c76cb77a15313eb333a710972614ec", "target": 0, "func": "static void trigger_access_exception(CPUS390XState *env, uint32_t type,\n\n                                     uint32_t ilen, uint64_t tec)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_s390_access_exception(cpu, type, tec);\n\n    } else {\n\n        CPUState *cs = CPU(cpu);\n\n        stq_phys(cs->as, env->psa + offsetof(LowCore, trans_exc_code), tec);\n\n        trigger_pgm_exception(env, type, ilen);\n\n    }\n\n}\n", "idx": 597}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "func": "static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,\n\n                                        DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(hotplug_dev);\n\n    Error *local_err = NULL;\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t size = memory_region_size(mr);\n\n    uint32_t nr_lmbs = size / SPAPR_MEMORY_BLOCK_SIZE;\n\n    uint64_t addr_start, addr;\n\n    int i;\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    sPAPRDIMMState *ds;\n\n\n\n    addr_start = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP,\n\n                                         &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    ds = g_malloc0(sizeof(sPAPRDIMMState));\n\n    ds->nr_lmbs = nr_lmbs;\n\n    ds->dimm = dimm;\n\n    spapr_pending_dimm_unplugs_add(spapr, ds);\n\n\n\n    addr = addr_start;\n\n    for (i = 0; i < nr_lmbs; i++) {\n\n        drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                addr / SPAPR_MEMORY_BLOCK_SIZE);\n\n        g_assert(drc);\n\n\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drck->detach(drc, dev, spapr_lmb_release, NULL, errp);\n\n        addr += SPAPR_MEMORY_BLOCK_SIZE;\n\n    }\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                   addr_start / SPAPR_MEMORY_BLOCK_SIZE);\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    spapr_hotplug_req_remove_by_count_indexed(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                              nr_lmbs,\n\n                                              drck->get_index(drc));\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 598}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void l2x0_priv_write(void *opaque, target_phys_addr_t offset,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    l2x0_state *s = (l2x0_state *)opaque;\n\n    offset &= 0xfff;\n\n    if (offset >= 0x730 && offset < 0x800) {\n\n        /* ignore */\n\n        return;\n\n    }\n\n    switch (offset) {\n\n    case 0x100:\n\n        s->ctrl = value & 1;\n\n        break;\n\n    case 0x104:\n\n        s->aux_ctrl = value;\n\n        break;\n\n    case 0x108:\n\n        s->tag_ctrl = value;\n\n        break;\n\n    case 0x10C:\n\n        s->data_ctrl = value;\n\n        break;\n\n    case 0xC00:\n\n        s->filter_start = value;\n\n        break;\n\n    case 0xC04:\n\n        s->filter_end = value;\n\n        break;\n\n    case 0xF40:\n\n        return;\n\n    case 0xF60:\n\n        return;\n\n    case 0xF80:\n\n        return;\n\n    default:\n\n        fprintf(stderr, \"l2x0_priv_write: Bad offset %x\\n\", (int)offset);\n\n        break;\n\n    }\n\n}\n", "idx": 600}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "static void json_emit_element(QJSON *json, const char *name)\n\n{\n\n    /* Check whether we need to print a , before an element */\n\n    if (json->omit_comma) {\n\n        json->omit_comma = false;\n\n    } else {\n\n        qstring_append(json->str, \", \");\n\n    }\n\n\n\n    if (name) {\n\n        qstring_append(json->str, \"\\\"\");\n\n        qstring_append(json->str, name);\n\n        qstring_append(json->str, \"\\\" : \");\n\n    }\n\n}\n", "idx": 601}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static bool vfio_pci_host_match(PCIHostDeviceAddress *host1,\n\n                                PCIHostDeviceAddress *host2)\n\n{\n\n    return (host1->domain == host2->domain && host1->bus == host2->bus &&\n\n            host1->slot == host2->slot && host1->function == host2->function);\n\n}\n", "idx": 602}
{"project": "FFmpeg", "commit_id": "fe7a37c36febd71576cbefc385d995a8d6e444e7", "target": 0, "func": "int ff_ivi_dec_huff_desc(GetBitContext *gb, int desc_coded, int which_tab,\n\n                         IVIHuffTab *huff_tab, AVCodecContext *avctx)\n\n{\n\n    int         i, result;\n\n    IVIHuffDesc new_huff;\n\n\n\n    if (!desc_coded) {\n\n        /* select default table */\n\n        huff_tab->tab = (which_tab) ? &ff_ivi_blk_vlc_tabs[7]\n\n            : &ff_ivi_mb_vlc_tabs [7];\n\n    } else {\n\n        huff_tab->tab_sel = get_bits(gb, 3);\n\n        if (huff_tab->tab_sel == 7) {\n\n            /* custom huffman table (explicitly encoded) */\n\n            new_huff.num_rows = get_bits(gb, 4);\n\n\n\n            for (i = 0; i < new_huff.num_rows; i++)\n\n                new_huff.xbits[i] = get_bits(gb, 4);\n\n\n\n            /* Have we got the same custom table? Rebuild if not. */\n\n            if (ff_ivi_huff_desc_cmp(&new_huff, &huff_tab->cust_desc)) {\n\n                ff_ivi_huff_desc_copy(&huff_tab->cust_desc, &new_huff);\n\n\n\n                if (huff_tab->cust_tab.table)\n\n                    ff_free_vlc(&huff_tab->cust_tab);\n\n                result = ff_ivi_create_huff_from_desc(&huff_tab->cust_desc,\n\n                        &huff_tab->cust_tab, 0);\n\n                if (result) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"Error while initializing custom vlc table!\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n            huff_tab->tab = &huff_tab->cust_tab;\n\n        } else {\n\n            /* select one of predefined tables */\n\n            huff_tab->tab = (which_tab) ? &ff_ivi_blk_vlc_tabs[huff_tab->tab_sel]\n\n                : &ff_ivi_mb_vlc_tabs [huff_tab->tab_sel];\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 603}
{"project": "qemu", "commit_id": "a86b35f992f107323e432c0a96107e11e1b699ad", "target": 0, "func": "int check_params(char *buf, int buf_size,\n\n                 const char * const *params, const char *str)\n\n{\n\n    const char *p;\n\n    int i;\n\n\n\n    p = str;\n\n    while (*p != '\\0') {\n\n        p = get_opt_name(buf, buf_size, p, '=');\n\n        if (*p != '=') {\n\n            return -1;\n\n        }\n\n        p++;\n\n        for (i = 0; params[i] != NULL; i++) {\n\n            if (!strcmp(params[i], buf)) {\n\n                break;\n\n            }\n\n        }\n\n        if (params[i] == NULL) {\n\n            return -1;\n\n        }\n\n        p = get_opt_value(NULL, 0, p);\n\n        if (*p != ',') {\n\n            break;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 604}
{"project": "qemu", "commit_id": "b61359781958759317ee6fd1a45b59be0b7dbbe1", "target": 0, "func": "static void memory_region_update_container_subregions(MemoryRegion *subregion)\n\n{\n\n    hwaddr offset = subregion->addr;\n\n    MemoryRegion *mr = subregion->container;\n\n    MemoryRegion *other;\n\n\n\n    memory_region_transaction_begin();\n\n\n\n    memory_region_ref(subregion);\n\n    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {\n\n        if (subregion->may_overlap || other->may_overlap) {\n\n            continue;\n\n        }\n\n        if (int128_ge(int128_make64(offset),\n\n                      int128_add(int128_make64(other->addr), other->size))\n\n            || int128_le(int128_add(int128_make64(offset), subregion->size),\n\n                         int128_make64(other->addr))) {\n\n            continue;\n\n        }\n\n#if 0\n\n        printf(\"warning: subregion collision %llx/%llx (%s) \"\n\n               \"vs %llx/%llx (%s)\\n\",\n\n               (unsigned long long)offset,\n\n               (unsigned long long)int128_get64(subregion->size),\n\n               subregion->name,\n\n               (unsigned long long)other->addr,\n\n               (unsigned long long)int128_get64(other->size),\n\n               other->name);\n\n#endif\n\n    }\n\n    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {\n\n        if (subregion->priority >= other->priority) {\n\n            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);\n\n            goto done;\n\n        }\n\n    }\n\n    QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);\n\ndone:\n\n    memory_region_update_pending |= mr->enabled && subregion->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 605}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn bdrv_qed_co_get_block_status(BlockDriverState *bs,\n\n                                                 int64_t sector_num,\n\n                                                 int nb_sectors, int *pnum)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;\n\n    QEDIsAllocatedCB cb = {\n\n        .bs = bs,\n\n        .pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE,\n\n        .status = BDRV_BLOCK_OFFSET_MASK,\n\n        .pnum = pnum,\n\n    };\n\n    QEDRequest request = { .l2_table = NULL };\n\n\n\n    qed_find_cluster(s, &request, cb.pos, len, qed_is_allocated_cb, &cb);\n\n\n\n    /* Now sleep if the callback wasn't invoked immediately */\n\n    while (cb.status == BDRV_BLOCK_OFFSET_MASK) {\n\n        cb.co = qemu_coroutine_self();\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    qed_unref_l2_cache_entry(request.l2_table);\n\n\n\n    return cb.status;\n\n}\n", "idx": 606}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static sPAPRPHBState *find_phb(sPAPREnvironment *spapr, uint64_t buid)\n\n{\n\n    sPAPRPHBState *sphb;\n\n\n\n    QLIST_FOREACH(sphb, &spapr->phbs, list) {\n\n        if (sphb->buid != buid) {\n\n            continue;\n\n        }\n\n        return sphb;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 607}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ahci_mem_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    AHCIState *s = opaque;\n\n\n\n    /* Only aligned reads are allowed on AHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"ahci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08\"PRIX64\"\\n\", (unsigned) addr, val);\n\n\n\n        switch (addr) {\n\n            case HOST_CAP: /* R/WO, RO */\n\n                /* FIXME handle R/WO */\n\n                break;\n\n            case HOST_CTL: /* R/W */\n\n                if (val & HOST_CTL_RESET) {\n\n                    DPRINTF(-1, \"HBA Reset\\n\");\n\n                    ahci_reset(s);\n\n                } else {\n\n                    s->control_regs.ghc = (val & 0x3) | HOST_CTL_AHCI_EN;\n\n                    ahci_check_irq(s);\n\n                }\n\n                break;\n\n            case HOST_IRQ_STAT: /* R/WC, RO */\n\n                s->control_regs.irqstatus &= ~val;\n\n                ahci_check_irq(s);\n\n                break;\n\n            case HOST_PORTS_IMPL: /* R/WO, RO */\n\n                /* FIXME handle R/WO */\n\n                break;\n\n            case HOST_VERSION: /* RO */\n\n                /* FIXME report write? */\n\n                break;\n\n            default:\n\n                DPRINTF(-1, \"write to unknown register 0x%x\\n\", (unsigned)addr);\n\n        }\n\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n\n        ahci_port_write(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n\n                        addr & AHCI_PORT_ADDR_OFFSET_MASK, val);\n\n    }\n\n\n\n}\n", "idx": 608}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void jpeg_term_destination(j_compress_ptr cinfo)\n\n{\n\n    VncState *vs = cinfo->client_data;\n\n    Buffer *buffer = &vs->tight_jpeg;\n\n\n\n    buffer->offset = buffer->capacity - cinfo->dest->free_in_buffer;\n\n}\n", "idx": 609}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qdict_destroy_obj(QObject *obj)\n\n{\n\n    int i;\n\n    QDict *qdict;\n\n\n\n    assert(obj != NULL);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    for (i = 0; i < QDICT_BUCKET_MAX; i++) {\n\n        QDictEntry *entry = QLIST_FIRST(&qdict->table[i]);\n\n        while (entry) {\n\n            QDictEntry *tmp = QLIST_NEXT(entry, next);\n\n            QLIST_REMOVE(entry, next);\n\n            qentry_destroy(entry);\n\n            entry = tmp;\n\n        }\n\n    }\n\n\n\n    g_free(qdict);\n\n}\n", "idx": 610}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int pte64_check (mmu_ctx_t *ctx,\n\n                        target_ulong pte0, target_ulong pte1, int h, int rw)\n\n{\n\n    return _pte_check(ctx, 1, pte0, pte1, h, rw);\n\n}\n", "idx": 611}
{"project": "qemu", "commit_id": "a4a1c70dc759e5b81627e96564f344ab43ea86eb", "target": 0, "func": "static GenericList *qobject_input_next_list(Visitor *v, GenericList *tail,\n\n                                            size_t size)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    StackObject *so = QSLIST_FIRST(&qiv->stack);\n\n\n\n    if (!so->entry) {\n\n        return NULL;\n\n    }\n\n    tail->next = g_malloc0(size);\n\n    return tail->next;\n\n}\n", "idx": 612}
{"project": "qemu", "commit_id": "772a73692ecb52bace0cff6f95df62f59b8cabe0", "target": 0, "func": "static int coroutine_fn v9fs_do_readdir_with_stat(V9fsPDU *pdu,\n\n                                                  V9fsFidState *fidp,\n\n                                                  uint32_t max_count)\n\n{\n\n    V9fsPath path;\n\n    V9fsStat v9stat;\n\n    int len, err = 0;\n\n    int32_t count = 0;\n\n    struct stat stbuf;\n\n    off_t saved_dir_pos;\n\n    struct dirent *dent;\n\n\n\n    /* save the directory position */\n\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n\n    if (saved_dir_pos < 0) {\n\n        return saved_dir_pos;\n\n    }\n\n\n\n    while (1) {\n\n        v9fs_path_init(&path);\n\n\n\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n\n        if (err || !dent) {\n\n            break;\n\n        }\n\n        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);\n\n        if (err < 0) {\n\n            break;\n\n        }\n\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n\n        if (err < 0) {\n\n            break;\n\n        }\n\n        err = stat_to_v9stat(pdu, &path, dent->d_name, &stbuf, &v9stat);\n\n        if (err < 0) {\n\n            break;\n\n        }\n\n        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */\n\n        len = pdu_marshal(pdu, 11 + count, \"S\", &v9stat);\n\n\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n\n\n        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {\n\n            /* Ran out of buffer. Set dir back to old position and return */\n\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n\n            v9fs_stat_free(&v9stat);\n\n            v9fs_path_free(&path);\n\n            return count;\n\n        }\n\n        count += len;\n\n        v9fs_stat_free(&v9stat);\n\n        v9fs_path_free(&path);\n\n        saved_dir_pos = dent->d_off;\n\n    }\n\n\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n\n\n    v9fs_path_free(&path);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    return count;\n\n}\n", "idx": 613}
{"project": "FFmpeg", "commit_id": "5675a11f9277b5c7b1c9ad45da893e9ef9a42f03", "target": 0, "func": "static int decode_block_refinement(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,\n\n                        int ac_index, int16_t *quant_matrix,\n\n                        int ss, int se, int Al, int *EOBRUN)\n\n{\n\n    int code, i=ss, j, sign, val, run;\n\n    int last = FFMIN(se, *last_nnz);\n\n\n\n    OPEN_READER(re, &s->gb);\n\n    if(*EOBRUN)\n\n        (*EOBRUN)--;\n\n    else {\n\n        for(;;i++) {\n\n            UPDATE_CACHE(re, &s->gb);\n\n            GET_VLC(code, re, &s->gb, s->vlcs[1][ac_index].table, 9, 2)\n\n            /* Progressive JPEG use AC coeffs from zero and this decoder sets offset 16 by default */\n\n            code -= 16;\n\n            if(code & 0xF) {\n\n                run = ((unsigned) code) >> 4;\n\n                UPDATE_CACHE(re, &s->gb);\n\n                val = SHOW_UBITS(re, &s->gb, 1);\n\n                LAST_SKIP_BITS(re, &s->gb, 1);\n\n                ZERO_RUN;\n\n                j = s->scantable.permutated[i];\n\n                val--;\n\n                block[j] = ((quant_matrix[j]^val)-val) << Al;\n\n                if(i == se) {\n\n                    if(i > *last_nnz)\n\n                        *last_nnz = i;\n\n                    CLOSE_READER(re, &s->gb)\n\n                    return 0;\n\n                }\n\n            }else{\n\n                run = ((unsigned) code) >> 4;\n\n                if(run == 0xF){\n\n                    ZERO_RUN;\n\n                }else{\n\n                    val = run;\n\n                    run = (1 << run);\n\n                    if(val) {\n\n                        UPDATE_CACHE(re, &s->gb);\n\n                        run += SHOW_UBITS(re, &s->gb, val);\n\n                        LAST_SKIP_BITS(re, &s->gb, val);\n\n                    }\n\n                    *EOBRUN = run - 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(i > *last_nnz)\n\n            *last_nnz = i;\n\n    }\n\n\n\n    for(;i<=last;i++) {\n\n        j = s->scantable.permutated[i];\n\n        if(block[j])\n\n            REFINE_BIT(j)\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n\n\n    return 0;\n\n}\n", "idx": 614}
{"project": "FFmpeg", "commit_id": "39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4", "target": 1, "func": "static void destroy_buffers(SANMVideoContext *ctx)\n\n{\n\n    av_freep(&ctx->frm0);\n\n    av_freep(&ctx->frm1);\n\n    av_freep(&ctx->frm2);\n\n    av_freep(&ctx->stored_frame);\n\n    av_freep(&ctx->rle_buf);\n\n    ctx->frm0_size =\n\n    ctx->frm1_size =\n\n    ctx->frm2_size = 0;\n\n\n}", "idx": 615}
{"project": "qemu", "commit_id": "cec56a733dd2c3fa81dbedbecf03922258747f7d", "target": 1, "func": "void cpu_state_reset(CPUMIPSState *env)\n{\n    MIPSCPU *cpu = mips_env_get_cpu(env);\n    CPUState *cs = CPU(cpu);\n    /* Reset registers to their default values */\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n#ifdef TARGET_WORDS_BIGENDIAN\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n#endif\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n    env->CP0_Config4 = env->cpu_model->CP0_Config4;\n    env->CP0_Config4_rw_bitmask = env->cpu_model->CP0_Config4_rw_bitmask;\n    env->CP0_Config5 = env->cpu_model->CP0_Config5;\n    env->CP0_Config5_rw_bitmask = env->cpu_model->CP0_Config5_rw_bitmask;\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n                                 << env->cpu_model->CP0_LLAddr_shift;\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n    env->CCRes = env->cpu_model->CCRes;\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n    env->current_tc = 0;\n    env->SEGBITS = env->cpu_model->SEGBITS;\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n#if defined(TARGET_MIPS64)\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n        env->SEGMask |= 3ULL << 62;\n    }\n#endif\n    env->PABITS = env->cpu_model->PABITS;\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n    env->CP0_PageGrain_rw_bitmask = env->cpu_model->CP0_PageGrain_rw_bitmask;\n    env->CP0_PageGrain = env->cpu_model->CP0_PageGrain;\n    env->CP0_EBaseWG_rw_bitmask = env->cpu_model->CP0_EBaseWG_rw_bitmask;\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n    env->active_fpu.fcr31_rw_bitmask = env->cpu_model->CP1_fcr31_rw_bitmask;\n    env->active_fpu.fcr31 = env->cpu_model->CP1_fcr31;\n    env->msair = env->cpu_model->MSAIR;\n    env->insn_flags = env->cpu_model->insn_flags;\n#if defined(CONFIG_USER_ONLY)\n    env->CP0_Status = (MIPS_HFLAG_UM << CP0St_KSU);\n# ifdef TARGET_MIPS64\n    /* Enable 64-bit register mode.  */\n    env->CP0_Status |= (1 << CP0St_PX);\n# endif\n# ifdef TARGET_ABI_MIPSN64\n    /* Enable 64-bit address mode.  */\n    env->CP0_Status |= (1 << CP0St_UX);\n# endif\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n       hardware registers.  */\n    env->CP0_HWREna |= 0x0000000F;\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n        env->CP0_Status |= (1 << CP0St_CU1);\n    }\n    if (env->CP0_Config3 & (1 << CP0C3_DSPP)) {\n        env->CP0_Status |= (1 << CP0St_MX);\n    }\n# if defined(TARGET_MIPS64)\n    /* For MIPS64, init FR bit to 1 if FPU unit is there and bit is writable. */\n    if ((env->CP0_Config1 & (1 << CP0C1_FP)) &&\n        (env->CP0_Status_rw_bitmask & (1 << CP0St_FR))) {\n        env->CP0_Status |= (1 << CP0St_FR);\n    }\n# endif\n#else\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n        /* If the exception was raised from a delay slot,\n           come back to the jump.  */\n        env->CP0_ErrorEPC = (env->active_tc.PC\n                             - (env->hflags & MIPS_HFLAG_B16 ? 2 : 4));\n    } else {\n        env->CP0_ErrorEPC = env->active_tc.PC;\n    }\n    env->active_tc.PC = env->exception_base;\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n    env->CP0_Wired = 0;\n    env->CP0_GlobalNumber = (cs->cpu_index & 0xFF) << CP0GN_VPId;\n    env->CP0_EBase = (cs->cpu_index & 0x3FF);\n    if (kvm_enabled()) {\n        env->CP0_EBase |= 0x40000000;\n    } else {\n        env->CP0_EBase |= (int32_t)0x80000000;\n    }\n    if (env->CP0_Config3 & (1 << CP0C3_CMGCR)) {\n        env->CP0_CMGCRBase = 0x1fbf8000 >> 4;\n    }\n    env->CP0_EntryHi_ASID_mask = (env->CP0_Config4 & (1 << CP0C4_AE)) ?\n                                 0x3ff : 0xff;\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n    /* vectored interrupts not implemented, timer on int 7,\n       no performance counters. */\n    env->CP0_IntCtl = 0xe0000000;\n    {\n        int i;\n        for (i = 0; i < 7; i++) {\n            env->CP0_WatchLo[i] = 0;\n            env->CP0_WatchHi[i] = 0x80000000;\n        }\n        env->CP0_WatchLo[7] = 0;\n        env->CP0_WatchHi[7] = 0;\n    }\n    /* Count register increments in debug mode, EJTAG version 1 */\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n    cpu_mips_store_count(env, 1);\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n        int i;\n        /* Only TC0 on VPE 0 starts as active.  */\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n            env->tcs[i].CP0_TCBind = cs->cpu_index << CP0TCBd_CurVPE;\n            env->tcs[i].CP0_TCHalt = 1;\n        }\n        env->active_tc.CP0_TCHalt = 1;\n        cs->halted = 1;\n        if (cs->cpu_index == 0) {\n            /* VPE0 starts up enabled.  */\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n            /* TC0 starts up unhalted.  */\n            cs->halted = 0;\n            env->active_tc.CP0_TCHalt = 0;\n            env->tcs[0].CP0_TCHalt = 0;\n            /* With thread 0 active.  */\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n        }\n    }\n#endif\n    if ((env->insn_flags & ISA_MIPS32R6) &&\n        (env->active_fpu.fcr0 & (1 << FCR0_F64))) {\n        /* Status.FR = 0 mode in 64-bit FPU not allowed in R6 */\n        env->CP0_Status |= (1 << CP0St_FR);\n    }\n    /* MSA */\n    if (env->CP0_Config3 & (1 << CP0C3_MSAP)) {\n        msa_reset(env);\n    }\n    compute_hflags(env);\n    restore_fp_status(env);\n    restore_pamask(env);\n    cs->exception_index = EXCP_NONE;\n    if (semihosting_get_argc()) {\n        /* UHI interface can be used to obtain argc and argv */\n        env->active_tc.gpr[4] = -1;\n    }\n}", "idx": 616}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)\n\n{\n\n    dev->flags &= ~VIO_PAPR_FLAG_DMA_BYPASS;\n\n\n\n    if (dev->rtce_table) {\n\n        size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)\n\n            * sizeof(VIOsPAPR_RTCE);\n\n        memset(dev->rtce_table, 0, size);\n\n    }\n\n\n\n    dev->crq.qladdr = 0;\n\n    dev->crq.qsize = 0;\n\n    dev->crq.qnext = 0;\n\n}\n", "idx": 617}
{"project": "FFmpeg", "commit_id": "51f64552853e16d72644308db53abee870aecfb9", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n                   int w, int h, enum AVPixelFormat pix_fmt, int align)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    int i, ret;\n    uint8_t *buf;\n    if (!desc)\n        return AVERROR(EINVAL);\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n        return ret;\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, align>7 ? FFALIGN(w, 8) : w)) < 0)\n        return ret;\n    for (i = 0; i < 4; i++)\n        linesizes[i] = FFALIGN(linesizes[i], align);\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n        return ret;\n    buf = av_malloc(ret + align);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n        av_free(buf);\n        return ret;\n    if (desc->flags & AV_PIX_FMT_FLAG_PAL || desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)\n        avpriv_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n    return ret;", "idx": 618}
{"project": "qemu", "commit_id": "c9f82d013be0d8d9c5d9f51bb76e337a0a5a5cac", "target": 1, "func": "static void do_dcbz(CPUPPCState *env, target_ulong addr, int dcache_line_size,\n\n                    uintptr_t raddr)\n\n{\n\n    int i;\n\n\n\n    addr &= ~(dcache_line_size - 1);\n\n    for (i = 0; i < dcache_line_size; i += 4) {\n\n        cpu_stl_data_ra(env, addr + i, 0, raddr);\n\n    }\n\n    if (env->reserve_addr == addr) {\n\n        env->reserve_addr = (target_ulong)-1ULL;\n\n    }\n\n}\n", "idx": 619}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t ide_nop_int32(IDEDMA *dma, int x)\n\n{\n\n    return 0;\n\n}\n", "idx": 620}
{"project": "qemu", "commit_id": "fdcf6e65bce1f8972030fed7af5e8aa5f6ae92c6", "target": 1, "func": "static int read_password(char *buf, int buf_size)\n\n{\n\n    int c, i;\n\n    printf(\"Password: \");\n\n    fflush(stdout);\n\n    i = 0;\n\n    for(;;) {\n\n        c = getchar();\n\n        if (c == '\\n')\n\n            break;\n\n        if (i < (buf_size - 1))\n\n            buf[i++] = c;\n\n    }\n\n    buf[i] = '\\0';\n\n    return 0;\n\n}\n", "idx": 621}
{"project": "qemu", "commit_id": "7f72cd235fa33f2fc7a8d1cc4d621bf7db61e9eb", "target": 1, "func": "long do_rt_sigreturn(CPUARMState *env)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr = env->xregs[31];\n\n\n\n    if (frame_addr & 15) {\n\n        goto badframe;\n\n    }\n\n\n\n    if  (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (target_restore_sigframe(env, frame)) {\n\n        goto badframe;\n\n    }\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n            offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n            0, get_sp_from_cpustate(env)) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->xregs[0];\n\n\n\n badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 622}
{"project": "qemu", "commit_id": "b5ab677189b93efa4eaa921f42b21dc008247184", "target": 1, "func": "tcp_sockclosed(struct tcpcb *tp)\n\n{\n\n\n\n\tDEBUG_CALL(\"tcp_sockclosed\");\n\n\tDEBUG_ARG(\"tp = %p\", tp);\n\n\n\n\tswitch (tp->t_state) {\n\n\n\n\tcase TCPS_CLOSED:\n\n\tcase TCPS_LISTEN:\n\n\tcase TCPS_SYN_SENT:\n\n\t\ttp->t_state = TCPS_CLOSED;\n\n\t\ttp = tcp_close(tp);\n\n\t\tbreak;\n\n\n\n\tcase TCPS_SYN_RECEIVED:\n\n\tcase TCPS_ESTABLISHED:\n\n\t\ttp->t_state = TCPS_FIN_WAIT_1;\n\n\t\tbreak;\n\n\n\n\tcase TCPS_CLOSE_WAIT:\n\n\t\ttp->t_state = TCPS_LAST_ACK;\n\n\t\tbreak;\n\n\t}\n\n\tif (tp)\n\n\t\ttcp_output(tp);\n\n}\n", "idx": 623}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static void icp_pit_write(void *opaque, target_phys_addr_t offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_write: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    arm_timer_write(s->timer[n], offset & 0xff, value);\n\n}\n", "idx": 624}
{"project": "qemu", "commit_id": "fce0a826083e0416981e2ea9518ce5faa75b81a3", "target": 1, "func": "static int exynos4210_combiner_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    Exynos4210CombinerState *s = EXYNOS4210_COMBINER(dev);\n\n    unsigned int i;\n\n\n\n    /* Allocate general purpose input signals and connect a handler to each of\n\n     * them */\n\n    qdev_init_gpio_in(dev, exynos4210_combiner_handler, IIC_NIRQ);\n\n\n\n    /* Connect SysBusDev irqs to device specific irqs */\n\n    for (i = 0; i < IIC_NIRQ; i++) {\n\n        sysbus_init_irq(sbd, &s->output_irq[i]);\n\n    }\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &exynos4210_combiner_ops, s,\n\n                          \"exynos4210-combiner\", IIC_REGION_SIZE);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n\n\n    return 0;\n\n}\n", "idx": 625}
{"project": "FFmpeg", "commit_id": "90f03441654f85a1402a65c3dcaa3f634a24c27e", "target": 0, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part = (1 << porder);\n\n    all_bits = 0;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for(i=0; i<part; i++) {\n\n        if(i == 1) cnt = (n >> porder);\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n    }\n\n    all_bits += (4 * part);\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 626}
{"project": "FFmpeg", "commit_id": "da8242e2d6f85d95239082efd0e5e2345e685a2c", "target": 0, "func": "static void raw_decode(uint8_t *dst, const int8_t *src, int src_size)\n\n{\n\n    while (src_size--)\n\n        *dst++ = *src++ + 128;\n\n}\n", "idx": 627}
{"project": "FFmpeg", "commit_id": "76b6f4b7d91901929177cc61d9810dcca0bb40c1", "target": 0, "func": "static int dxtory_decode_v1_410(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    int h, w;\n\n    uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V;\n\n    int ret;\n\n\n\n    if (src_size < avctx->width * avctx->height * 9LL / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y1 = pic->data[0];\n\n    Y2 = pic->data[0] + pic->linesize[0];\n\n    Y3 = pic->data[0] + pic->linesize[0] * 2;\n\n    Y4 = pic->data[0] + pic->linesize[0] * 3;\n\n    U  = pic->data[1];\n\n    V  = pic->data[2];\n\n    for (h = 0; h < avctx->height; h += 4) {\n\n        for (w = 0; w < avctx->width; w += 4) {\n\n            AV_COPY32U(Y1 + w, src);\n\n            AV_COPY32U(Y2 + w, src + 4);\n\n            AV_COPY32U(Y3 + w, src + 8);\n\n            AV_COPY32U(Y4 + w, src + 12);\n\n            U[w >> 2] = src[16] + 0x80;\n\n            V[w >> 2] = src[17] + 0x80;\n\n            src += 18;\n\n        }\n\n        Y1 += pic->linesize[0] << 2;\n\n        Y2 += pic->linesize[0] << 2;\n\n        Y3 += pic->linesize[0] << 2;\n\n        Y4 += pic->linesize[0] << 2;\n\n        U  += pic->linesize[1];\n\n        V  += pic->linesize[2];\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 628}
{"project": "FFmpeg", "commit_id": "ff6b34009d4571ae0a4d130c0f8d27706a4c4026", "target": 1, "func": "static int ff_filter_frame_framed(AVFilterLink *link, AVFilterBufferRef *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *src = link->srcpad;\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFilterBufferRef *out;\n\n    int perms, ret;\n\n    AVFilterCommand *cmd= link->dst->command_queue;\n\n    int64_t pts;\n\n\n\n    if (link->closed) {\n\n        avfilter_unref_buffer(frame);\n\n        return AVERROR_EOF;\n\n    }\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    av_assert1((frame->perms & src->min_perms) == src->min_perms);\n\n    frame->perms &= ~ src->rej_perms;\n\n    perms = frame->perms;\n\n\n\n    if (frame->linesize[0] < 0)\n\n        perms |= AV_PERM_NEG_LINESIZES;\n\n\n\n    /* prepare to copy the frame if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & perms) != dst->min_perms ||\n\n        dst->rej_perms & perms) {\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        /* Maybe use ff_copy_buffer_ref instead? */\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, dst->min_perms,\n\n                                      link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, dst->min_perms,\n\n                                      frame->audio->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            avfilter_unref_buffer(frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        avfilter_copy_buffer_ref_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->video->w, frame->video->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->audio->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->audio->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        avfilter_unref_buffer(frame);\n\n    } else\n\n        out = frame;\n\n\n\n    while(cmd && cmd->time <= frame->pts * av_q2d(link->time_base)){\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Processing command time:%f command:%s arg:%s\\n\",\n\n               cmd->time, cmd->command, cmd->arg);\n\n        avfilter_process_command(link->dst, cmd->command, cmd->arg, 0, 0, cmd->flags);\n\n        ff_command_queue_pop(link->dst);\n\n        cmd= link->dst->command_queue;\n\n    }\n\n\n\n    pts = out->pts;\n\n    ret = filter_frame(link, out);\n\n    ff_update_link_current_pts(link, pts);\n\n    return ret;\n\n}\n", "idx": 629}
{"project": "qemu", "commit_id": "b783e409bf17b92f4af8dc5d6bd040d0092f33e0", "target": 1, "func": "void bdrv_get_backing_filename(BlockDriverState *bs,\n\n                               char *filename, int filename_size)\n\n{\n\n    if (!bs->backing_hd) {\n\n        pstrcpy(filename, filename_size, \"\");\n\n    } else {\n\n        pstrcpy(filename, filename_size, bs->backing_file);\n\n    }\n\n}\n", "idx": 630}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint32_t e1000e_macreg_read(e1000e_device *d, uint32_t reg)\n\n{\n\n    return qpci_io_readl(d->pci_dev, d->mac_regs + reg);\n\n}\n", "idx": 631}
{"project": "FFmpeg", "commit_id": "2217a2249dd78c3719f865569b661b8adcda4962", "target": 1, "func": "static void encode_rgb48_10bit(AVCodecContext *avctx, const AVPicture *pic, uint8_t *dst)\n\n{\n\n    DPXContext *s = avctx->priv_data;\n\n    const uint8_t *src = pic->data[0];\n\n    int x, y;\n\n\n\n    for (y = 0; y < avctx->height; y++) {\n\n        for (x = 0; x < avctx->width; x++) {\n\n            int value;\n\n            if (s->big_endian) {\n\n                value = ((AV_RB16(src + 6*x + 4) & 0xFFC0) >> 4)\n\n                      | ((AV_RB16(src + 6*x + 2) & 0xFFC0) << 6)\n\n                      | ((AV_RB16(src + 6*x + 0) & 0xFFC0) << 16);\n\n            } else {\n\n                value = ((AV_RL16(src + 6*x + 4) & 0xFFC0) >> 4)\n\n                      | ((AV_RL16(src + 6*x + 2) & 0xFFC0) << 6)\n\n                      | ((AV_RL16(src + 6*x + 0) & 0xFFC0) << 16);\n\n            }\n\n            write32(dst, value);\n\n            dst += 4;\n\n        }\n\n        src += pic->linesize[0];\n\n    }\n\n}\n", "idx": 633}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static int tgv_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TgvContext *s = avctx->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    int chunk_type;\n\n\n\n    if (buf_end - buf < EA_PREAMBLE_SIZE)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    chunk_type = AV_RL32(&buf[0]);\n\n    buf += EA_PREAMBLE_SIZE;\n\n\n\n    if (chunk_type==kVGT_TAG) {\n\n        int pal_count, i;\n\n        if(buf_end - buf < 12) {\n\n            av_log(avctx, AV_LOG_WARNING, \"truncated header\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->width  = AV_RL16(&buf[0]);\n\n        s->height = AV_RL16(&buf[2]);\n\n        if (s->avctx->width!=s->width || s->avctx->height!=s->height) {\n\n            avcodec_set_dimensions(s->avctx, s->width, s->height);\n\n            cond_release_buffer(&s->frame);\n\n            cond_release_buffer(&s->last_frame);\n\n        }\n\n\n\n        pal_count = AV_RL16(&buf[6]);\n\n        buf += 12;\n\n        for(i=0; i<pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {\n\n            s->palette[i] = 0xFF << 24 | AV_RB24(buf);\n\n            buf += 3;\n\n        }\n\n    }\n\n\n\n    if (av_image_check_size(s->width, s->height, 0, avctx))\n\n        return -1;\n\n\n\n    /* shuffle */\n\n    FFSWAP(AVFrame, s->frame, s->last_frame);\n\n    if (!s->frame.data[0]) {\n\n        s->frame.reference = 3;\n\n        s->frame.buffer_hints = FF_BUFFER_HINTS_VALID;\n\n        s->frame.linesize[0] = s->width;\n\n\n\n        /* allocate additional 12 bytes to accommodate av_memcpy_backptr() OUTBUF_PADDED optimisation */\n\n        s->frame.data[0] = av_malloc(s->width*s->height + 12);\n\n        if (!s->frame.data[0])\n\n            return AVERROR(ENOMEM);\n\n        s->frame.data[1] = av_malloc(AVPALETTE_SIZE);\n\n        if (!s->frame.data[1]) {\n\n            av_freep(&s->frame.data[0]);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n\n\n    if(chunk_type==kVGT_TAG) {\n\n        s->frame.key_frame = 1;\n\n        s->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        if (unpack(buf, buf_end, s->frame.data[0], s->avctx->width, s->avctx->height)<0) {\n\n            av_log(avctx, AV_LOG_WARNING, \"truncated intra frame\\n\");\n\n            return -1;\n\n        }\n\n    }else{\n\n        if (!s->last_frame.data[0]) {\n\n            av_log(avctx, AV_LOG_WARNING, \"inter frame without corresponding intra frame\\n\");\n\n            return buf_size;\n\n        }\n\n        s->frame.key_frame = 0;\n\n        s->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        if (tgv_decode_inter(s, buf, buf_end)<0) {\n\n            av_log(avctx, AV_LOG_WARNING, \"truncated inter frame\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 634}
{"project": "FFmpeg", "commit_id": "6394acaf36da3106f4793bda32730f8ff6b0ddb1", "target": 1, "func": "static void adjust_frame_information(ChannelElement *cpe, int chans)\n\n{\n\n    int i, w, w2, g, ch;\n\n    int start, maxsfb, cmaxsfb;\n\n\n\n    for (ch = 0; ch < chans; ch++) {\n\n        IndividualChannelStream *ics = &cpe->ch[ch].ics;\n\n        start = 0;\n\n        maxsfb = 0;\n\n        cpe->ch[ch].pulse.num_pulse = 0;\n\n        for (w = 0; w < ics->num_windows*16; w += 16) {\n\n            for (g = 0; g < ics->num_swb; g++) {\n\n                //apply M/S\n\n                if (cpe->common_window && !ch && cpe->ms_mask[w + g]) {\n\n                    for (i = 0; i < ics->swb_sizes[g]; i++) {\n\n                        cpe->ch[0].coeffs[start+i] = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) / 2.0;\n\n                        cpe->ch[1].coeffs[start+i] =  cpe->ch[0].coeffs[start+i] - cpe->ch[1].coeffs[start+i];\n\n                    }\n\n                }\n\n                start += ics->swb_sizes[g];\n\n            }\n\n            for (cmaxsfb = ics->num_swb; cmaxsfb > 0 && cpe->ch[ch].zeroes[w+cmaxsfb-1]; cmaxsfb--)\n\n                ;\n\n            maxsfb = FFMAX(maxsfb, cmaxsfb);\n\n        }\n\n        ics->max_sfb = maxsfb;\n\n\n\n        //adjust zero bands for window groups\n\n        for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {\n\n            for (g = 0; g < ics->max_sfb; g++) {\n\n                i = 1;\n\n                for (w2 = w; w2 < w + ics->group_len[w]; w2++) {\n\n                    if (!cpe->ch[ch].zeroes[w2*16 + g]) {\n\n                        i = 0;\n\n                        break;\n\n                    }\n\n                }\n\n                cpe->ch[ch].zeroes[w*16 + g] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (chans > 1 && cpe->common_window) {\n\n        IndividualChannelStream *ics0 = &cpe->ch[0].ics;\n\n        IndividualChannelStream *ics1 = &cpe->ch[1].ics;\n\n        int msc = 0;\n\n        ics0->max_sfb = FFMAX(ics0->max_sfb, ics1->max_sfb);\n\n        ics1->max_sfb = ics0->max_sfb;\n\n        for (w = 0; w < ics0->num_windows*16; w += 16)\n\n            for (i = 0; i < ics0->max_sfb; i++)\n\n                if (cpe->ms_mask[w+i])\n\n                    msc++;\n\n        if (msc == 0 || ics0->max_sfb == 0)\n\n            cpe->ms_mode = 0;\n\n        else\n\n            cpe->ms_mode = msc < ics0->max_sfb * ics0->num_windows ? 1 : 2;\n\n    }\n\n}\n", "idx": 635}
{"project": "FFmpeg", "commit_id": "e6e8cc8ce9c2a398fbb51254a5067f4bd3c4fa8a", "target": 1, "func": "int ff_img_read_header(AVFormatContext *s1)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    int first_index, last_index;\n\n    AVStream *st;\n\n    enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;\n\n\n\n    s1->ctx_flags |= AVFMTCTX_NOHEADER;\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (s->pixel_format &&\n\n        (pix_fmt = av_get_pix_fmt(s->pixel_format)) == AV_PIX_FMT_NONE) {\n\n        av_log(s1, AV_LOG_ERROR, \"No such pixel format: %s.\\n\",\n\n               s->pixel_format);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_strlcpy(s->path, s1->filename, sizeof(s->path));\n\n    s->img_number = 0;\n\n    s->img_count  = 0;\n\n\n\n    /* find format */\n\n    if (s1->iformat->flags & AVFMT_NOFILE)\n\n        s->is_pipe = 0;\n\n    else {\n\n        s->is_pipe       = 1;\n\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n\n    }\n\n\n\n    if (s->ts_from_file == 2) {\n\n#if !HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\n        av_log(s1, AV_LOG_ERROR, \"POSIX.1-2008 not supported, nanosecond file timestamps unavailable\\n\");\n\n        return AVERROR(ENOSYS);\n\n#endif\n\n        avpriv_set_pts_info(st, 64, 1, 1000000000);\n\n    } else if (s->ts_from_file)\n\n        avpriv_set_pts_info(st, 64, 1, 1);\n\n    else\n\n        avpriv_set_pts_info(st, 64, s->framerate.den, s->framerate.num);\n\n\n\n    if (s->width && s->height) {\n\n        st->codec->width  = s->width;\n\n        st->codec->height = s->height;\n\n    }\n\n\n\n    if (!s->is_pipe) {\n\n        if (s->pattern_type == PT_GLOB_SEQUENCE) {\n\n        s->use_glob = is_glob(s->path);\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            char *p = s->path, *q, *dup;\n\n            int gerr;\n\n#endif\n\n\n\n            av_log(s1, AV_LOG_WARNING, \"Pattern type 'glob_sequence' is deprecated: \"\n\n                   \"use pattern_type 'glob' instead\\n\");\n\n#if HAVE_GLOB\n\n            dup = q = av_strdup(p);\n\n            while (*q) {\n\n                /* Do we have room for the next char and a \\ insertion? */\n\n                if ((p - s->path) >= (sizeof(s->path) - 2))\n\n                  break;\n\n                if (*q == '%' && strspn(q + 1, \"%*?[]{}\"))\n\n                    ++q;\n\n                else if (strspn(q, \"\\\\*?[]{}\"))\n\n                    *p++ = '\\\\';\n\n                *p++ = *q++;\n\n            }\n\n            *p = 0;\n\n            av_free(dup);\n\n\n\n            gerr = glob(s->path, GLOB_NOCHECK|GLOB_BRACE|GLOB_NOMAGIC, NULL, &s->globstate);\n\n            if (gerr != 0) {\n\n                return AVERROR(ENOENT);\n\n            }\n\n            first_index = 0;\n\n            last_index = s->globstate.gl_pathc - 1;\n\n#endif\n\n        }\n\n        }\n\n        if ((s->pattern_type == PT_GLOB_SEQUENCE && !s->use_glob) || s->pattern_type == PT_SEQUENCE) {\n\n            if (find_image_range(&first_index, &last_index, s->path,\n\n                                 s->start_number, s->start_number_range) < 0) {\n\n                av_log(s1, AV_LOG_ERROR,\n\n                       \"Could find no file with path '%s' and index in the range %d-%d\\n\",\n\n                       s->path, s->start_number, s->start_number + s->start_number_range - 1);\n\n                return AVERROR(ENOENT);\n\n            }\n\n        } else if (s->pattern_type == PT_GLOB) {\n\n#if HAVE_GLOB\n\n            int gerr;\n\n            gerr = glob(s->path, GLOB_NOCHECK|GLOB_BRACE|GLOB_NOMAGIC, NULL, &s->globstate);\n\n            if (gerr != 0) {\n\n                return AVERROR(ENOENT);\n\n            }\n\n            first_index = 0;\n\n            last_index = s->globstate.gl_pathc - 1;\n\n            s->use_glob = 1;\n\n#else\n\n            av_log(s1, AV_LOG_ERROR,\n\n                   \"Pattern type 'glob' was selected but globbing \"\n\n                   \"is not supported by this libavformat build\\n\");\n\n            return AVERROR(ENOSYS);\n\n#endif\n\n        } else if (s->pattern_type != PT_GLOB_SEQUENCE) {\n\n            av_log(s1, AV_LOG_ERROR,\n\n                   \"Unknown value '%d' for pattern_type option\\n\", s->pattern_type);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        s->img_first  = first_index;\n\n        s->img_last   = last_index;\n\n        s->img_number = first_index;\n\n        /* compute duration */\n\n        if (!s->ts_from_file) {\n\n            st->start_time = 0;\n\n            st->duration   = last_index - first_index + 1;\n\n        }\n\n    }\n\n\n\n    if (s1->video_codec_id) {\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id   = s1->video_codec_id;\n\n    } else if (s1->audio_codec_id) {\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id   = s1->audio_codec_id;\n\n    } else if (s1->iformat->raw_codec_id) {\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id   = s1->iformat->raw_codec_id;\n\n    } else {\n\n        const char *str = strrchr(s->path, '.');\n\n        s->split_planes       = str && !av_strcasecmp(str + 1, \"y\");\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        if (s1->pb) {\n\n            int probe_buffer_size = 2048;\n\n            uint8_t *probe_buffer = av_realloc(NULL, probe_buffer_size + AVPROBE_PADDING_SIZE);\n\n            AVInputFormat *fmt = NULL;\n\n            AVProbeData pd = { 0 };\n\n\n\n            if (!probe_buffer)\n\n                return AVERROR(ENOMEM);\n\n\n\n            probe_buffer_size = avio_read(s1->pb, probe_buffer, probe_buffer_size);\n\n            if (probe_buffer_size < 0) {\n\n                av_free(probe_buffer);\n\n                return probe_buffer_size;\n\n            }\n\n            memset(probe_buffer + probe_buffer_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n            pd.buf = probe_buffer;\n\n            pd.buf_size = probe_buffer_size;\n\n            pd.filename = s1->filename;\n\n\n\n            while ((fmt = av_iformat_next(fmt))) {\n\n                if (fmt->read_header != ff_img_read_header ||\n\n                    !fmt->read_probe ||\n\n                    (fmt->flags & AVFMT_NOFILE) ||\n\n                    !fmt->raw_codec_id)\n\n                    continue;\n\n                if (fmt->read_probe(&pd) > 0) {\n\n                    st->codec->codec_id = fmt->raw_codec_id;\n\n                    break;\n\n                }\n\n            }\n\n            ffio_rewind_with_probe_data(s1->pb, &probe_buffer, probe_buffer_size);\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            st->codec->codec_id = ff_guess_image2_codec(s->path);\n\n        if (st->codec->codec_id == AV_CODEC_ID_LJPEG)\n\n            st->codec->codec_id = AV_CODEC_ID_MJPEG;\n\n        if (st->codec->codec_id == AV_CODEC_ID_ALIAS_PIX) // we cannot distingiush this from BRENDER_PIX\n\n            st->codec->codec_id = AV_CODEC_ID_NONE;\n\n    }\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        pix_fmt != AV_PIX_FMT_NONE)\n\n        st->codec->pix_fmt = pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 636}
{"project": "qemu", "commit_id": "c36ad13fe9ece9a21a8c1dd082473a2b182298ee", "target": 1, "func": "static void hpet_ram_write(void *opaque, hwaddr addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    int i;\n\n    HPETState *s = opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_read(opaque, addr, 4);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x\\n\", timer_id);\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n            if (activating_bit(old_val, new_val, HPET_TN_FSB_ENABLE)) {\n\n                update_irq(timer, 0);\n\n            }\n\n            val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n            timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n            if (new_val & HPET_TN_32BIT) {\n\n                timer->cmp = (uint32_t)timer->cmp;\n\n                timer->period = (uint32_t)timer->period;\n\n            }\n\n            if (activating_bit(old_val, new_val, HPET_TN_ENABLE)) {\n\n                hpet_set_timer(timer);\n\n            } else if (deactivating_bit(old_val, new_val, HPET_TN_ENABLE)) {\n\n                hpet_del_timer(timer);\n\n            }\n\n            break;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n            break;\n\n        case HPET_TN_CMP: // comparator register\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP\\n\");\n\n            if (timer->config & HPET_TN_32BIT) {\n\n                new_val = (uint32_t)new_val;\n\n            }\n\n            if (!timer_is_periodic(timer)\n\n                || (timer->config & HPET_TN_SETVAL)) {\n\n                timer->cmp = (timer->cmp & 0xffffffff00000000ULL) | new_val;\n\n            }\n\n            if (timer_is_periodic(timer)) {\n\n                /*\n\n                 * FIXME: Clamp period to reasonable min value?\n\n                 * Clamp period to reasonable max value\n\n                 */\n\n                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                timer->period =\n\n                    (timer->period & 0xffffffff00000000ULL) | new_val;\n\n            }\n\n            timer->config &= ~HPET_TN_SETVAL;\n\n            if (hpet_enabled(s)) {\n\n                hpet_set_timer(timer);\n\n            }\n\n            break;\n\n        case HPET_TN_CMP + 4: // comparator register high order\n\n            DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n            if (!timer_is_periodic(timer)\n\n                || (timer->config & HPET_TN_SETVAL)) {\n\n                timer->cmp = (timer->cmp & 0xffffffffULL) | new_val << 32;\n\n            } else {\n\n                /*\n\n                 * FIXME: Clamp period to reasonable min value?\n\n                 * Clamp period to reasonable max value\n\n                 */\n\n                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                timer->period =\n\n                    (timer->period & 0xffffffffULL) | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled(s)) {\n\n                    hpet_set_timer(timer);\n\n                }\n\n                break;\n\n        case HPET_TN_ROUTE:\n\n            timer->fsb = (timer->fsb & 0xffffffff00000000ULL) | new_val;\n\n            break;\n\n        case HPET_TN_ROUTE + 4:\n\n            timer->fsb = (new_val << 32) | (timer->fsb & 0xffffffff);\n\n            break;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n            break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return;\n\n        case HPET_CFG:\n\n            val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n            s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n            if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                /* Enable main counter and interrupt generation. */\n\n                s->hpet_offset =\n\n                    ticks_to_ns(s->hpet_counter) - qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n                for (i = 0; i < s->num_timers; i++) {\n\n                    if ((&s->timer[i])->cmp != ~0ULL) {\n\n                        hpet_set_timer(&s->timer[i]);\n\n                    }\n\n                }\n\n            } else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                /* Halt main counter and disable interrupt generation. */\n\n                s->hpet_counter = hpet_get_ticks(s);\n\n                for (i = 0; i < s->num_timers; i++) {\n\n                    hpet_del_timer(&s->timer[i]);\n\n                }\n\n            }\n\n            /* i8254 and RTC output pins are disabled\n\n             * when HPET is in legacy mode */\n\n            if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                qemu_set_irq(s->pit_enabled, 0);\n\n                qemu_irq_lower(s->irqs[0]);\n\n                qemu_irq_lower(s->irqs[RTC_ISA_IRQ]);\n\n            } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                qemu_irq_lower(s->irqs[0]);\n\n                qemu_set_irq(s->pit_enabled, 1);\n\n                qemu_set_irq(s->irqs[RTC_ISA_IRQ], s->rtc_irq_level);\n\n            }\n\n            break;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG+4 write\\n\");\n\n            break;\n\n        case HPET_STATUS:\n\n            val = new_val & s->isr;\n\n            for (i = 0; i < s->num_timers; i++) {\n\n                if (val & (1 << i)) {\n\n                    update_irq(&s->timer[i], 0);\n\n                }\n\n            }\n\n            break;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                DPRINTF(\"qemu: Writing counter while HPET enabled!\\n\");\n\n            }\n\n            s->hpet_counter =\n\n                (s->hpet_counter & 0xffffffff00000000ULL) | value;\n\n            DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                    value, s->hpet_counter);\n\n            break;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                DPRINTF(\"qemu: Writing counter while HPET enabled!\\n\");\n\n            }\n\n            s->hpet_counter =\n\n                (s->hpet_counter & 0xffffffffULL) | (((uint64_t)value) << 32);\n\n            DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                    value, s->hpet_counter);\n\n            break;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 637}
{"project": "qemu", "commit_id": "7dd47667b9b0b23807fc1a550644fc2427462f41", "target": 1, "func": "static abi_ulong copy_elf_strings(int argc,char ** argv, void **page,\n\n                                  abi_ulong p)\n\n{\n\n    char *tmp, *tmp1, *pag = NULL;\n\n    int len, offset = 0;\n\n\n\n    if (!p) {\n\n        return 0;       /* bullet-proofing */\n\n    }\n\n    while (argc-- > 0) {\n\n        tmp = argv[argc];\n\n        if (!tmp) {\n\n            fprintf(stderr, \"VFS: argc is wrong\");\n\n            exit(-1);\n\n        }\n\n        tmp1 = tmp;\n\n        while (*tmp++);\n\n        len = tmp - tmp1;\n\n        if (p < len) {  /* this shouldn't happen - 128kB */\n\n            return 0;\n\n        }\n\n        while (len) {\n\n            --p; --tmp; --len;\n\n            if (--offset < 0) {\n\n                offset = p % TARGET_PAGE_SIZE;\n\n                pag = (char *)page[p/TARGET_PAGE_SIZE];\n\n                if (!pag) {\n\n                    pag = (char *)malloc(TARGET_PAGE_SIZE);\n\n                    memset(pag, 0, TARGET_PAGE_SIZE);\n\n                    page[p/TARGET_PAGE_SIZE] = pag;\n\n                    if (!pag)\n\n                        return 0;\n\n                }\n\n            }\n\n            if (len == 0 || offset == 0) {\n\n                *(pag + offset) = *tmp;\n\n            }\n\n            else {\n\n                int bytes_to_copy = (len > offset) ? offset : len;\n\n                tmp -= bytes_to_copy;\n\n                p -= bytes_to_copy;\n\n                offset -= bytes_to_copy;\n\n                len -= bytes_to_copy;\n\n                memcpy_fromfs(pag + offset, tmp, bytes_to_copy + 1);\n\n            }\n\n        }\n\n    }\n\n    return p;\n\n}\n", "idx": 638}
{"project": "FFmpeg", "commit_id": "a9f9b7f5c70e80245983e67b8ed23212d9637645", "target": 1, "func": "static int mov_text_decode_close(AVCodecContext *avctx)\n\n{\n\n    MovTextContext *m = avctx->priv_data;\n\n    mov_text_cleanup_ftab(m);\n\n\n    return 0;\n\n}", "idx": 639}
{"project": "qemu", "commit_id": "7da76e12cc5cc902dda4c168d8d608fd4e61cbc5", "target": 1, "func": "static void xhci_intr_raise(XHCIState *xhci, int v)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n\n\n\n    xhci->intr[v].erdp_low |= ERDP_EHB;\n\n    xhci->intr[v].iman |= IMAN_IP;\n\n    xhci->usbsts |= USBSTS_EINT;\n\n\n\n\n\n\n    if (!(xhci->intr[v].iman & IMAN_IE)) {\n\n\n\n\n\n    if (!(xhci->usbcmd & USBCMD_INTE)) {\n\n\n\n\n\n    if (msix_enabled(pci_dev)) {\n\n        trace_usb_xhci_irq_msix(v);\n\n        msix_notify(pci_dev, v);\n\n\n\n\n\n    if (msi_enabled(pci_dev)) {\n\n        trace_usb_xhci_irq_msi(v);\n\n        msi_notify(pci_dev, v);\n\n\n\n\n\n    if (v == 0) {\n\n        trace_usb_xhci_irq_intx(1);\n\n        pci_irq_assert(pci_dev);\n\n", "idx": 640}
{"project": "qemu", "commit_id": "4f8586144161d5e680fdef3e09b7e8e9111c2929", "target": 1, "func": "int qemu_chr_fe_get_msgfd(CharDriverState *s)\n\n{\n\n    int fd;\n\n    return (qemu_chr_fe_get_msgfds(s, &fd, 1) >= 0) ? fd : -1;\n\n}\n", "idx": 641}
{"project": "qemu", "commit_id": "2ec62faea274aabb2feaad2b8f85961161b5e1e4", "target": 1, "func": "void qemu_set_dfilter_ranges(const char *filter_spec)\n{\n    gchar **ranges = g_strsplit(filter_spec, \",\", 0);\n    if (ranges) {\n        gchar **next = ranges;\n        gchar *r = *next++;\n        debug_regions = g_array_sized_new(FALSE, FALSE,\n                                          sizeof(Range), g_strv_length(ranges));\n        while (r) {\n            char *range_op = strstr(r, \"-\");\n            char *r2 = range_op ? range_op + 1 : NULL;\n            if (!range_op) {\n                range_op = strstr(r, \"+\");\n                r2 = range_op ? range_op + 1 : NULL;\n            if (!range_op) {\n                range_op = strstr(r, \"..\");\n                r2 = range_op ? range_op + 2 : NULL;\n            if (range_op) {\n                const char *e = NULL;\n                uint64_t r1val, r2val;\n                if ((qemu_strtoull(r, &e, 0, &r1val) == 0) &&\n                    (qemu_strtoull(r2, NULL, 0, &r2val) == 0) &&\n                    r2val > 0) {\n                    struct Range range;\n                    g_assert(e == range_op);\n                    switch (*range_op) {\n                    case '+':\n                    {\n                        range.begin = r1val;\n                        range.end = r1val + (r2val - 1);\n                        break;\n                    case '-':\n                    {\n                        range.end = r1val;\n                        range.begin = r1val - (r2val - 1);\n                        break;\n                    case '.':\n                        range.begin = r1val;\n                        range.end = r2val;\n                        break;\n                    default:\n                        g_assert_not_reached();\n                    g_array_append_val(debug_regions, range);\n                } else {\n                    g_error(\"Failed to parse range in: %s\", r);\n            } else {\n                g_error(\"Bad range specifier in: %s\", r);\n            r = *next++;\n        g_strfreev(ranges);", "idx": 642}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static void flush(AVCodecContext *avctx)\n\n{\n\n    WmallDecodeCtx *s    = avctx->priv_data;\n\n    s->packet_loss       = 1;\n\n    s->packet_done       = 0;\n\n    s->num_saved_bits    = 0;\n\n    s->frame_offset      = 0;\n\n    s->next_packet_start = 0;\n\n    s->cdlms[0][0].order = 0;\n\n    s->frame.nb_samples  = 0;\n\n    init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n\n}\n", "idx": 643}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "avs_decode_frame(AVCodecContext * avctx,\n\n                 void *data, int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    const uint8_t *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    AvsContext *const avs = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame *const p =  &avs->picture;\n\n    const uint8_t *table, *vect;\n\n    uint8_t *out;\n\n    int i, j, x, y, stride, vect_w = 3, vect_h = 3;\n\n    AvsVideoSubType sub_type;\n\n    AvsBlockType type;\n\n    GetBitContext change_map;\n\n\n\n    if (avctx->reget_buffer(avctx, p)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n    p->reference = 3;\n\n    p->pict_type = AV_PICTURE_TYPE_P;\n\n    p->key_frame = 0;\n\n\n\n    out = avs->picture.data[0];\n\n    stride = avs->picture.linesize[0];\n\n\n\n    if (buf_end - buf < 4)\n\n        return AVERROR_INVALIDDATA;\n\n    sub_type = buf[0];\n\n    type = buf[1];\n\n    buf += 4;\n\n\n\n    if (type == AVS_PALETTE) {\n\n        int first, last;\n\n        uint32_t *pal = (uint32_t *) avs->picture.data[1];\n\n\n\n        first = AV_RL16(buf);\n\n        last = first + AV_RL16(buf + 2);\n\n        if (first >= 256 || last > 256 || buf_end - buf < 4 + 4 + 3 * (last - first))\n\n            return AVERROR_INVALIDDATA;\n\n        buf += 4;\n\n        for (i=first; i<last; i++, buf+=3) {\n\n            pal[i] = (buf[0] << 18) | (buf[1] << 10) | (buf[2] << 2);\n\n            pal[i] |= 0xFF << 24 | (pal[i] >> 6) & 0x30303;\n\n        }\n\n\n\n        sub_type = buf[0];\n\n        type = buf[1];\n\n        buf += 4;\n\n    }\n\n\n\n    if (type != AVS_VIDEO)\n\n        return -1;\n\n\n\n    switch (sub_type) {\n\n    case AVS_I_FRAME:\n\n        p->pict_type = AV_PICTURE_TYPE_I;\n\n        p->key_frame = 1;\n\n    case AVS_P_FRAME_3X3:\n\n        vect_w = 3;\n\n        vect_h = 3;\n\n        break;\n\n\n\n    case AVS_P_FRAME_2X2:\n\n        vect_w = 2;\n\n        vect_h = 2;\n\n        break;\n\n\n\n    case AVS_P_FRAME_2X3:\n\n        vect_w = 2;\n\n        vect_h = 3;\n\n        break;\n\n\n\n    default:\n\n      return -1;\n\n    }\n\n\n\n    if (buf_end - buf < 256 * vect_w * vect_h)\n\n        return AVERROR_INVALIDDATA;\n\n    table = buf + (256 * vect_w * vect_h);\n\n    if (sub_type != AVS_I_FRAME) {\n\n        int map_size = ((318 / vect_w + 7) / 8) * (198 / vect_h);\n\n        if (buf_end - table < map_size)\n\n            return AVERROR_INVALIDDATA;\n\n        init_get_bits(&change_map, table, map_size * 8);\n\n        table += map_size;\n\n    }\n\n\n\n    for (y=0; y<198; y+=vect_h) {\n\n        for (x=0; x<318; x+=vect_w) {\n\n            if (sub_type == AVS_I_FRAME || get_bits1(&change_map)) {\n\n                if (buf_end - table < 1)\n\n                    return AVERROR_INVALIDDATA;\n\n                vect = &buf[*table++ * (vect_w * vect_h)];\n\n                for (j=0; j<vect_w; j++) {\n\n                    out[(y + 0) * stride + x + j] = vect[(0 * vect_w) + j];\n\n                    out[(y + 1) * stride + x + j] = vect[(1 * vect_w) + j];\n\n                    if (vect_h == 3)\n\n                        out[(y + 2) * stride + x + j] =\n\n                            vect[(2 * vect_w) + j];\n\n                }\n\n            }\n\n        }\n\n        if (sub_type != AVS_I_FRAME)\n\n            align_get_bits(&change_map);\n\n    }\n\n\n\n    *picture   = avs->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return buf_size;\n\n}\n", "idx": 644}
{"project": "qemu", "commit_id": "14a10fc39923b3af07c8c46d22cb20843bee3a72", "target": 1, "func": "static void uc32_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    UniCore32CPUClass *ucc = UNICORE32_CPU_GET_CLASS(dev);\n    ucc->parent_realize(dev, errp);\n}", "idx": 645}
{"project": "qemu", "commit_id": "75cdcd1553e74b5edc58aed23e3b2da8dabb1876", "target": 1, "func": "void parse_option_size(const char *name, const char *value,\n\n                       uint64_t *ret, Error **errp)\n\n{\n\n    char *postfix;\n\n    double sizef;\n\n\n\n    sizef = strtod(value, &postfix);\n\n    if (sizef < 0 || sizef > UINT64_MAX) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name,\n\n                   \"a non-negative number below 2^64\");\n\n        return;\n\n    }\n\n    switch (*postfix) {\n\n    case 'T':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'G':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'M':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'K':\n\n    case 'k':\n\n        sizef *= 1024;\n\n        /* fall through */\n\n    case 'b':\n\n    case '\\0':\n\n        *ret = (uint64_t) sizef;\n\n        break;\n\n    default:\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name, \"a size\");\n\n        error_append_hint(errp, \"You may use k, M, G or T suffixes for \"\n\n                          \"kilobytes, megabytes, gigabytes and terabytes.\\n\");\n\n        return;\n\n    }\n\n}\n", "idx": 647}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_ove_cy(DisasContext *dc, TCGv cy)\n\n{\n\n    if (dc->tb_flags & SR_OVE) {\n\n        gen_helper_ove(cpu_env, cy);\n\n    }\n\n}\n", "idx": 648}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void limits_nesting(void)\n\n{\n\n    enum { max_nesting = 1024 }; /* see qobject/json-streamer.c */\n\n    char buf[2 * (max_nesting + 1) + 1];\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting), NULL);\n\n    g_assert(obj != NULL);\n\n    qobject_decref(obj);\n\n\n\n    obj = qobject_from_json(make_nest(buf, max_nesting + 1), NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 649}
{"project": "FFmpeg", "commit_id": "dc9f52602f6493b33d1ac0d729ffb188e6a676fa", "target": 1, "func": "static int decode_end(AVCodecContext *avctx)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    MpegEncContext *s = &h->s;\n\n    \n\n\n    free_tables(h); //FIXME cleanup init stuff perhaps\n\n    MPV_common_end(s);\n\n\n\n//    memset(h, 0, sizeof(H264Context));\n\n        \n\n    return 0;\n\n}", "idx": 650}
{"project": "FFmpeg", "commit_id": "99ca4f73f0a2085d8b3c7636f4734825894c42dc", "target": 0, "func": "static av_cold int validate_options(AVCodecContext *avctx, AC3EncodeContext *s)\n\n{\n\n    int i, j;\n\n\n\n    if (!avctx->channel_layout) {\n\n        av_log(avctx, AV_LOG_WARNING, \"No channel layout specified. The \"\n\n                                      \"encoder will guess the layout, but it \"\n\n                                      \"might be incorrect.\\n\");\n\n    }\n\n    if (set_channel_info(s, avctx->channels, &avctx->channel_layout)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid channel layout\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* frequency */\n\n    for (i = 0; i < 3; i++) {\n\n        for (j = 0; j < 3; j++)\n\n            if ((ff_ac3_sample_rate_tab[j] >> i) == avctx->sample_rate)\n\n                goto found;\n\n    }\n\n    return -1;\n\n found:\n\n    s->sample_rate        = avctx->sample_rate;\n\n    s->bit_alloc.sr_shift = i;\n\n    s->bit_alloc.sr_code  = j;\n\n    s->bitstream_id       = 8 + s->bit_alloc.sr_shift;\n\n    s->bitstream_mode     = 0; /* complete main audio service */\n\n\n\n    /* bitrate & frame size */\n\n    for (i = 0; i < 19; i++) {\n\n        if ((ff_ac3_bitrate_tab[i] >> s->bit_alloc.sr_shift)*1000 == avctx->bit_rate)\n\n            break;\n\n    }\n\n    if (i == 19)\n\n        return -1;\n\n    s->bit_rate        = avctx->bit_rate;\n\n    s->frame_size_code = i << 1;\n\n\n\n    return 0;\n\n}\n", "idx": 651}
{"project": "FFmpeg", "commit_id": "8de3458a07376b0a96772e586b6dba5e93432f52", "target": 0, "func": "static NvencSurface *get_free_frame(NvencContext *ctx)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < ctx->nb_surfaces; i++) {\n\n        if (!ctx->surfaces[i].lockCount) {\n\n            ctx->surfaces[i].lockCount = 1;\n\n            return &ctx->surfaces[i];\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 652}
{"project": "FFmpeg", "commit_id": "99a335299ff3541f89e6e3be4b9ae84257288fcc", "target": 0, "func": "int ff_ccitt_unpack(AVCodecContext *avctx,\n\n                    const uint8_t *src, int srcsize,\n\n                    uint8_t *dst, int height, int stride,\n\n                    enum TiffCompr compr, int opts)\n\n{\n\n    int j;\n\n    GetBitContext gb;\n\n    int *runs, *ref, *runend;\n\n    int ret;\n\n    int runsize= avctx->width + 2;\n\n\n\n    runs = av_malloc(runsize * sizeof(runs[0]));\n\n    ref  = av_malloc(runsize * sizeof(ref[0]));\n\n    ref[0] = avctx->width;\n\n    ref[1] = 0;\n\n    ref[2] = 0;\n\n    init_get_bits(&gb, src, srcsize*8);\n\n    for(j = 0; j < height; j++){\n\n        runend = runs + runsize;\n\n        if(compr == TIFF_G4){\n\n            ret = decode_group3_2d_line(avctx, &gb, avctx->width, runs, runend, ref);\n\n            if(ret < 0){\n\n                av_free(runs);\n\n                av_free(ref);\n\n                return -1;\n\n            }\n\n        }else{\n\n            int g3d1 = (compr == TIFF_G3) && !(opts & 1);\n\n            if(compr!=TIFF_CCITT_RLE && find_group3_syncmarker(&gb, srcsize*8) < 0)\n\n                break;\n\n            if(compr==TIFF_CCITT_RLE || g3d1 || get_bits1(&gb))\n\n                ret = decode_group3_1d_line(avctx, &gb, avctx->width, runs, runend);\n\n            else\n\n                ret = decode_group3_2d_line(avctx, &gb, avctx->width, runs, runend, ref);\n\n            if(compr==TIFF_CCITT_RLE)\n\n                align_get_bits(&gb);\n\n        }\n\n        if(ret < 0){\n\n            put_line(dst, stride, avctx->width, ref);\n\n        }else{\n\n            put_line(dst, stride, avctx->width, runs);\n\n            FFSWAP(int*, runs, ref);\n\n        }\n\n        dst += stride;\n\n    }\n\n    av_free(runs);\n\n    av_free(ref);\n\n    return 0;\n\n}\n", "idx": 654}
{"project": "FFmpeg", "commit_id": "ae100046ca32b0b83031a60d0c3cdfc5ceb9f874", "target": 0, "func": "static int exif_decode_tag(void *logctx, GetByteContext *gbytes, int le,\n\n                           int depth, AVDictionary **metadata)\n\n{\n\n    int ret, cur_pos;\n\n    unsigned id, count;\n\n    enum TiffTypes type;\n\n\n\n    if (depth > 2) {\n\n        return 0;\n\n    }\n\n\n\n    ff_tread_tag(gbytes, le, &id, &type, &count, &cur_pos);\n\n\n\n    if (!bytestream2_tell(gbytes)) {\n\n        bytestream2_seek(gbytes, cur_pos, SEEK_SET);\n\n        return 0;\n\n    }\n\n\n\n    // read count values and add it metadata\n\n    // store metadata or proceed with next IFD\n\n    ret = ff_tis_ifd(id);\n\n    if (ret) {\n\n        ret = avpriv_exif_decode_ifd(logctx, gbytes, le, depth + 1, metadata);\n\n    } else {\n\n        const char *name = exif_get_tag_name(id);\n\n        char *use_name   = (char*) name;\n\n\n\n        if (!use_name) {\n\n            use_name = av_malloc(7);\n\n            if (!use_name) {\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            snprintf(use_name, 7, \"0x%04X\", id);\n\n        }\n\n\n\n        ret = exif_add_metadata(logctx, count, type, use_name, NULL,\n\n                                gbytes, le, metadata);\n\n\n\n        if (!name) {\n\n            av_freep(&use_name);\n\n        }\n\n    }\n\n\n\n    bytestream2_seek(gbytes, cur_pos, SEEK_SET);\n\n\n\n    return ret;\n\n}\n", "idx": 655}
{"project": "qemu", "commit_id": "80aa796bf38b7ef21daa42673b4711510c450d8a", "target": 1, "func": "static int pci_bridge_dev_initfn(PCIDevice *dev)\n\n{\n\n    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);\n\n    PCIBridgeDev *bridge_dev = DO_UPCAST(PCIBridgeDev, bridge, br);\n\n    int err;\n\n    pci_bridge_map_irq(br, NULL, pci_bridge_dev_map_irq_fn);\n\n    err = pci_bridge_initfn(dev);\n\n    if (err) {\n\n        goto bridge_error;\n\n    }\n\n    memory_region_init(&bridge_dev->bar, \"shpc-bar\", shpc_bar_size(dev));\n\n    err = shpc_init(dev, &br->sec_bus, &bridge_dev->bar, 0);\n\n    if (err) {\n\n        goto shpc_error;\n\n    }\n\n    err = slotid_cap_init(dev, 0, bridge_dev->chassis_nr, 0);\n\n    if (err) {\n\n        goto slotid_error;\n\n    }\n\n    if ((bridge_dev->flags & (1 << PCI_BRIDGE_DEV_F_MSI_REQ)) &&\n\n        msi_supported) {\n\n        err = msi_init(dev, 0, 1, true, true);\n\n        if (err < 0) {\n\n            goto msi_error;\n\n        }\n\n    }\n\n    /* TODO: spec recommends using 64 bit prefetcheable BAR.\n\n     * Check whether that works well. */\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n\t\t     PCI_BASE_ADDRESS_MEM_TYPE_64, &bridge_dev->bar);\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x1;\n\n    return 0;\n\nmsi_error:\n\n    slotid_cap_cleanup(dev);\n\nslotid_error:\n\n    shpc_cleanup(dev, &bridge_dev->bar);\n\nshpc_error:\n\n    memory_region_destroy(&bridge_dev->bar);\n\nbridge_error:\n\n    return err;\n\n}\n", "idx": 656}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static const AVClass *urlcontext_child_class_next(const AVClass *prev)\n\n{\n\n    URLProtocol *p = NULL;\n\n\n\n    /* find the protocol that corresponds to prev */\n\n    while (prev && (p = ffurl_protocol_next(p)))\n\n        if (p->priv_data_class == prev)\n\n            break;\n\n\n\n    /* find next protocol with priv options */\n\n    while (p = ffurl_protocol_next(p))\n\n        if (p->priv_data_class)\n\n            return p->priv_data_class;\n\n    return NULL;\n\n}\n", "idx": 658}
{"project": "qemu", "commit_id": "2a7e8dda090af586f3d0b3d157054a9e18776a52", "target": 1, "func": "static void do_change_vnc(const char *target)\n\n{\n\n    if (strcmp(target, \"passwd\") == 0 ||\n\n\tstrcmp(target, \"password\") == 0) {\n\n\tchar password[9];\n\n\tmonitor_readline(\"Password: \", 1, password, sizeof(password)-1);\n\n\tpassword[sizeof(password)-1] = '\\0';\n\n\tif (vnc_display_password(NULL, password) < 0)\n\n\t    term_printf(\"could not set VNC server password\\n\");\n\n    } else {\n\n\tif (vnc_display_open(NULL, target) < 0)\n\n\t    term_printf(\"could not start VNC server on %s\\n\", target);\n\n    }\n\n}\n", "idx": 659}
{"project": "FFmpeg", "commit_id": "5938e02185430ca711106aaec9b5622dbf588af3", "target": 1, "func": "int ff_get_cpu_flags_x86(void)\n\n{\n\n    int rval = 0;\n\n    int eax, ebx, ecx, edx;\n\n    int max_std_level, max_ext_level, std_caps=0, ext_caps=0;\n\n    int family=0, model=0;\n\n    union { int i[3]; char c[12]; } vendor;\n\n\n\n#if ARCH_X86_32\n\n    x86_reg a, c;\n\n    __asm__ volatile (\n\n        /* See if CPUID instruction is supported ... */\n\n        /* ... Get copies of EFLAGS into eax and ecx */\n\n        \"pushfl\\n\\t\"\n\n        \"pop %0\\n\\t\"\n\n        \"mov %0, %1\\n\\t\"\n\n\n\n        /* ... Toggle the ID bit in one copy and store */\n\n        /*     to the EFLAGS reg */\n\n        \"xor $0x200000, %0\\n\\t\"\n\n        \"push %0\\n\\t\"\n\n        \"popfl\\n\\t\"\n\n\n\n        /* ... Get the (hopefully modified) EFLAGS */\n\n        \"pushfl\\n\\t\"\n\n        \"pop %0\\n\\t\"\n\n        : \"=a\" (a), \"=c\" (c)\n\n        :\n\n        : \"cc\"\n\n        );\n\n\n\n    if (a == c)\n\n        return 0; /* CPUID not supported */\n\n#endif\n\n\n\n    cpuid(0, max_std_level, vendor.i[0], vendor.i[2], vendor.i[1]);\n\n\n\n    if(max_std_level >= 1){\n\n        cpuid(1, eax, ebx, ecx, std_caps);\n\n        family = ((eax>>8)&0xf) + ((eax>>20)&0xff);\n\n        model  = ((eax>>4)&0xf) + ((eax>>12)&0xf0);\n\n        if (std_caps & (1<<23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (std_caps & (1<<25))\n\n            rval |= AV_CPU_FLAG_MMX2\n\n#if HAVE_SSE\n\n                  | AV_CPU_FLAG_SSE;\n\n        if (std_caps & (1<<26))\n\n            rval |= AV_CPU_FLAG_SSE2;\n\n        if (ecx & 1)\n\n            rval |= AV_CPU_FLAG_SSE3;\n\n        if (ecx & 0x00000200 )\n\n            rval |= AV_CPU_FLAG_SSSE3;\n\n        if (ecx & 0x00080000 )\n\n            rval |= AV_CPU_FLAG_SSE4;\n\n        if (ecx & 0x00100000 )\n\n            rval |= AV_CPU_FLAG_SSE42;\n\n#if HAVE_AVX\n\n        /* Check OXSAVE and AVX bits */\n\n        if ((ecx & 0x18000000) == 0x18000000) {\n\n            /* Check for OS support */\n\n            xgetbv(0, eax, edx);\n\n            if ((eax & 0x6) == 0x6)\n\n                rval |= AV_CPU_FLAG_AVX;\n\n        }\n\n#endif\n\n#endif\n\n                  ;\n\n    }\n\n\n\n    cpuid(0x80000000, max_ext_level, ebx, ecx, edx);\n\n\n\n    if(max_ext_level >= 0x80000001){\n\n        cpuid(0x80000001, eax, ebx, ecx, ext_caps);\n\n        if (ext_caps & (1<<31))\n\n            rval |= AV_CPU_FLAG_3DNOW;\n\n        if (ext_caps & (1<<30))\n\n            rval |= AV_CPU_FLAG_3DNOWEXT;\n\n        if (ext_caps & (1<<23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (ext_caps & (1<<22))\n\n            rval |= AV_CPU_FLAG_MMX2;\n\n\n\n        /* Allow for selectively disabling SSE2 functions on AMD processors\n\n           with SSE2 support but not SSE4a. This includes Athlon64, some\n\n           Opteron, and some Sempron processors. MMX, SSE, or 3DNow! are faster\n\n           than SSE2 often enough to utilize this special-case flag.\n\n           AV_CPU_FLAG_SSE2 and AV_CPU_FLAG_SSE2SLOW are both set in this case\n\n           so that SSE2 is used unless explicitly disabled by checking\n\n           AV_CPU_FLAG_SSE2SLOW. */\n\n        if (!strncmp(vendor.c, \"AuthenticAMD\", 12) &&\n\n            rval & AV_CPU_FLAG_SSE2 && !(ecx & 0x00000040)) {\n\n            rval |= AV_CPU_FLAG_SSE2SLOW;\n\n        }\n\n    }\n\n\n\n    if (!strncmp(vendor.c, \"GenuineIntel\", 12)) {\n\n        if (family == 6 && (model == 9 || model == 13 || model == 14)) {\n\n            /* 6/9 (pentium-m \"banias\"), 6/13 (pentium-m \"dothan\"), and 6/14 (core1 \"yonah\")\n\n            * theoretically support sse2, but it's usually slower than mmx,\n\n            * so let's just pretend they don't. AV_CPU_FLAG_SSE2 is disabled and\n\n            * AV_CPU_FLAG_SSE2SLOW is enabled so that SSE2 is not used unless\n\n            * explicitly enabled by checking AV_CPU_FLAG_SSE2SLOW. The same\n\n            * situation applies for AV_CPU_FLAG_SSE3 and AV_CPU_FLAG_SSE3SLOW. */\n\n            if (rval & AV_CPU_FLAG_SSE2) rval ^= AV_CPU_FLAG_SSE2SLOW|AV_CPU_FLAG_SSE2;\n\n            if (rval & AV_CPU_FLAG_SSE3) rval ^= AV_CPU_FLAG_SSE3SLOW|AV_CPU_FLAG_SSE3;\n\n        }\n\n        /* The Atom processor has SSSE3 support, which is useful in many cases,\n\n         * but sometimes the SSSE3 version is slower than the SSE2 equivalent\n\n         * on the Atom, but is generally faster on other processors supporting\n\n         * SSSE3. This flag allows for selectively disabling certain SSSE3\n\n         * functions on the Atom. */\n\n        if (family == 6 && model == 28)\n\n            rval |= AV_CPU_FLAG_ATOM;\n\n    }\n\n\n\n    return rval;\n\n}\n", "idx": 660}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline void cvtyuvtoRGB (SwsContext *c,\n\n\t\t\t   vector signed short Y, vector signed short U, vector signed short V,\n\n\t\t\t   vector signed short *R, vector signed short *G, vector signed short *B)\n\n{\n\n  vector signed   short vx,ux,uvx;\n\n\n\n  Y = vec_mradds (Y, c->CY, c->OY);\n\n  U  = vec_sub (U,(vector signed short)\n\n  \t\t\tvec_splat((vector signed short)AVV(128),0));\n\n  V  = vec_sub (V,(vector signed short)\n\n  \t\t\tvec_splat((vector signed short)AVV(128),0));\n\n\n\n  //   ux  = (CBU*(u<<c->CSHIFT)+0x4000)>>15;\n\n  ux = vec_sl (U, c->CSHIFT);\n\n  *B = vec_mradds (ux, c->CBU, Y);\n\n\n\n  // vx  = (CRV*(v<<c->CSHIFT)+0x4000)>>15;\n\n  vx = vec_sl (V, c->CSHIFT);\n\n  *R = vec_mradds (vx, c->CRV, Y);\n\n\n\n  // uvx = ((CGU*u) + (CGV*v))>>15;\n\n  uvx = vec_mradds (U, c->CGU, Y);\n\n  *G = vec_mradds (V, c->CGV, uvx);\n\n}\n", "idx": 661}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "void usb_generic_async_ctrl_complete(USBDevice *s, USBPacket *p)\n\n{\n\n    if (p->len < 0) {\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n    }\n\n\n\n    switch (s->setup_state) {\n\n    case SETUP_STATE_SETUP:\n\n        if (p->len < s->setup_len) {\n\n            s->setup_len = p->len;\n\n        }\n\n        s->setup_state = SETUP_STATE_DATA;\n\n        p->len = 8;\n\n        break;\n\n\n\n    case SETUP_STATE_ACK:\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->len = 0;\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n    usb_packet_complete(s, p);\n\n}\n", "idx": 662}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static int encode_audio_frame(AVFormatContext *s, OutputStream *ost,\n\n                              const uint8_t *buf, int buf_size)\n\n{\n\n    AVCodecContext *enc = ost->st->codec;\n\n    AVFrame *frame = NULL;\n\n    AVPacket pkt;\n\n    int ret, got_packet;\n\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n\n\n    if (buf && buf_size) {\n\n        if (!ost->output_frame) {\n\n            ost->output_frame = avcodec_alloc_frame();\n\n            if (!ost->output_frame) {\n\n                av_log(NULL, AV_LOG_FATAL, \"out-of-memory in encode_audio_frame()\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n        frame = ost->output_frame;\n\n        if (frame->extended_data != frame->data)\n\n            av_freep(&frame->extended_data);\n\n        avcodec_get_frame_defaults(frame);\n\n\n\n        frame->nb_samples  = buf_size /\n\n                             (enc->channels * av_get_bytes_per_sample(enc->sample_fmt));\n\n        if ((ret = avcodec_fill_audio_frame(frame, enc->channels, enc->sample_fmt,\n\n                                            buf, buf_size, 1)) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Audio encoding failed (avcodec_fill_audio_frame)\\n\");\n\n            exit_program(1);\n\n        }\n\n\n\n        frame->pts = ost->sync_opts;\n\n        ost->sync_opts += frame->nb_samples;\n\n    }\n\n\n\n    got_packet = 0;\n\n    update_benchmark(NULL);\n\n    if (avcodec_encode_audio2(enc, &pkt, frame, &got_packet) < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Audio encoding failed (avcodec_encode_audio2)\\n\");\n\n        exit_program(1);\n\n    }\n\n    update_benchmark(\"encode_audio %d.%d\", ost->file_index, ost->index);\n\n\n\n    ret = pkt.size;\n\n\n\n    if (got_packet) {\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts      = av_rescale_q(pkt.pts,      enc->time_base, ost->st->time_base);\n\n        if (pkt.dts != AV_NOPTS_VALUE) {\n\n            int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n            pkt.dts      = av_rescale_q(pkt.dts,      enc->time_base, ost->st->time_base);\n\n            if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt.dts) {\n\n                av_log(s, max - pkt.dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt.dts, max);\n\n                pkt.pts = pkt.dts = max;\n\n            }\n\n        }\n\n        if (pkt.duration > 0)\n\n            pkt.duration = av_rescale_q(pkt.duration, enc->time_base, ost->st->time_base);\n\n\n\n        write_frame(s, &pkt, ost);\n\n\n\n        audio_size += pkt.size;\n\n\n\n        av_free_packet(&pkt);\n\n    }\n\n\n\n    if (debug_ts) {\n\n        av_log(NULL, AV_LOG_INFO, \"encoder -> type:audio \"\n\n               \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",\n\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ost->st->time_base),\n\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ost->st->time_base));\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 663}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static void rng_egd_opened(RngBackend *b, Error **errp)\n{\n    RngEgd *s = RNG_EGD(b);\n    if (s->chr_name == NULL) {\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n                  \"chardev\", \"a valid character device\");\n    s->chr = qemu_chr_find(s->chr_name);\n    if (s->chr == NULL) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, s->chr_name);\n    /* FIXME we should resubmit pending requests when the CDS reconnects. */\n    qemu_chr_add_handlers(s->chr, rng_egd_chr_can_read, rng_egd_chr_read,\n                          NULL, s);", "idx": 664}
{"project": "FFmpeg", "commit_id": "0a90b6a43e76aec8031b6c8a46bba2bf6cd25fa7", "target": 0, "func": "static int64_t mpegts_get_pcr(AVFormatContext *s, int stream_index,\n\n                              int64_t *ppos, int64_t pos_limit)\n\n{\n\n    MpegTSContext *ts = s->priv_data;\n\n    int64_t pos, timestamp;\n\n    uint8_t buf[TS_PACKET_SIZE];\n\n    int pcr_l, pcr_pid = ((PESContext*)s->streams[stream_index]->priv_data)->pcr_pid;\n\n    pos = ((*ppos  + ts->raw_packet_size - 1 - ts->pos47) / ts->raw_packet_size) * ts->raw_packet_size + ts->pos47;\n\n        while(pos < pos_limit) {\n\n            avio_seek(s->pb, pos, SEEK_SET);\n\n            if (avio_read(s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)\n\n                return AV_NOPTS_VALUE;\n\n            if ((pcr_pid < 0 || (AV_RB16(buf + 1) & 0x1fff) == pcr_pid) &&\n\n                parse_pcr(&timestamp, &pcr_l, buf) == 0) {\n\n                *ppos = pos;\n\n                return timestamp;\n\n            }\n\n            pos += ts->raw_packet_size;\n\n        }\n\n\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 665}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static enum AVPixelFormat get_pixel_format(H264Context *h)\n\n{\n\n#define HWACCEL_MAX (CONFIG_H264_DXVA2_HWACCEL + \\\n\n                     CONFIG_H264_D3D11VA_HWACCEL + \\\n\n                     CONFIG_H264_VAAPI_HWACCEL + \\\n\n                     (CONFIG_H264_VDA_HWACCEL * 2) + \\\n\n                     CONFIG_H264_VDPAU_HWACCEL)\n\n    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;\n\n    const enum AVPixelFormat *choices = pix_fmts;\n\n\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 9:\n\n        if (CHROMA444(h)) {\n\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n\n                *fmt++ = AV_PIX_FMT_GBRP9;\n\n            } else\n\n                *fmt++ = AV_PIX_FMT_YUV444P9;\n\n        } else if (CHROMA422(h))\n\n            *fmt++ = AV_PIX_FMT_YUV422P9;\n\n        else\n\n            *fmt++ = AV_PIX_FMT_YUV420P9;\n\n        break;\n\n    case 10:\n\n        if (CHROMA444(h)) {\n\n            if (h->avctx->colorspace == AVCOL_SPC_RGB) {\n\n                *fmt++ = AV_PIX_FMT_GBRP10;\n\n            } else\n\n                *fmt++ = AV_PIX_FMT_YUV444P10;\n\n        } else if (CHROMA422(h))\n\n            *fmt++ = AV_PIX_FMT_YUV422P10;\n\n        else\n\n            *fmt++ = AV_PIX_FMT_YUV420P10;\n\n        break;\n\n    case 8:\n\n#if CONFIG_H264_VDPAU_HWACCEL\n\n        *fmt++ = AV_PIX_FMT_VDPAU;\n\n#endif\n\n        if (CHROMA444(h)) {\n\n            if (h->avctx->colorspace == AVCOL_SPC_RGB)\n\n                *fmt++ = AV_PIX_FMT_GBRP;\n\n            else if (h->avctx->color_range == AVCOL_RANGE_JPEG)\n\n                *fmt++ = AV_PIX_FMT_YUVJ444P;\n\n            else\n\n                *fmt++ = AV_PIX_FMT_YUV444P;\n\n        } else if (CHROMA422(h)) {\n\n            if (h->avctx->color_range == AVCOL_RANGE_JPEG)\n\n                *fmt++ = AV_PIX_FMT_YUVJ422P;\n\n            else\n\n                *fmt++ = AV_PIX_FMT_YUV422P;\n\n        } else {\n\n#if CONFIG_H264_DXVA2_HWACCEL\n\n            *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n\n#endif\n\n#if CONFIG_H264_D3D11VA_HWACCEL\n\n            *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n\n#endif\n\n#if CONFIG_H264_VAAPI_HWACCEL\n\n            *fmt++ = AV_PIX_FMT_VAAPI;\n\n#endif\n\n#if CONFIG_H264_VDA_HWACCEL\n\n            *fmt++ = AV_PIX_FMT_VDA_VLD;\n\n            *fmt++ = AV_PIX_FMT_VDA;\n\n#endif\n\n            if (h->avctx->codec->pix_fmts)\n\n                choices = h->avctx->codec->pix_fmts;\n\n            else if (h->avctx->color_range == AVCOL_RANGE_JPEG)\n\n                *fmt++ = AV_PIX_FMT_YUVJ420P;\n\n            else\n\n                *fmt++ = AV_PIX_FMT_YUV420P;\n\n        }\n\n        break;\n\n    default:\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Unsupported bit depth %d\\n\", h->sps.bit_depth_luma);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *fmt = AV_PIX_FMT_NONE;\n\n\n\n    return ff_get_format(h->avctx, choices);\n\n}\n", "idx": 667}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static void mv88w8618_eth_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n\n{\n\n    mv88w8618_eth_state *s;\n\n    int iomemtype;\n\n\n\n    qemu_check_nic_model(nd, \"mv88w8618\");\n\n\n\n    s = qemu_mallocz(sizeof(mv88w8618_eth_state));\n\n    s->irq = irq;\n\n    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n\n                                 eth_receive, eth_can_receive, s);\n\n    iomemtype = cpu_register_io_memory(0, mv88w8618_eth_readfn,\n\n                                       mv88w8618_eth_writefn, s);\n\n    cpu_register_physical_memory(base, MP_ETH_SIZE, iomemtype);\n\n}\n", "idx": 671}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static int vnc_update_client_sync(VncState *vs, int has_dirty)\n\n{\n\n    int ret = vnc_update_client(vs, has_dirty);\n\n    vnc_jobs_join(vs);\n\n    return ret;\n\n}\n", "idx": 672}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_tipb_bridge_s *omap_tipb_bridge_init(\n\n    MemoryRegion *memory, hwaddr base,\n\n    qemu_irq abort_irq, omap_clk clk)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)\n\n            g_malloc0(sizeof(struct omap_tipb_bridge_s));\n\n\n\n    s->abort = abort_irq;\n\n    omap_tipb_bridge_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_tipb_bridge_ops, s,\n\n                          \"omap-tipb-bridge\", 0x100);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 673}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static void seqvideo_decode(SeqVideoContext *seq, const unsigned char *data, int data_size)\n\n{\n\n    GetBitContext gb;\n\n    int flags, i, j, x, y, op;\n\n    unsigned char c[3];\n\n    unsigned char *dst;\n\n    uint32_t *palette;\n\n\n\n    flags = *data++;\n\n\n\n    if (flags & 1) {\n\n        palette = (uint32_t *)seq->frame.data[1];\n\n        for (i = 0; i < 256; i++) {\n\n            for (j = 0; j < 3; j++, data++)\n\n                c[j] = (*data << 2) | (*data >> 4);\n\n            palette[i] = AV_RB24(c);\n\n        }\n\n        seq->frame.palette_has_changed = 1;\n\n    }\n\n\n\n    if (flags & 2) {\n\n        init_get_bits(&gb, data, 128 * 8); data += 128;\n\n        for (y = 0; y < 128; y += 8)\n\n            for (x = 0; x < 256; x += 8) {\n\n                dst = &seq->frame.data[0][y * seq->frame.linesize[0] + x];\n\n                op = get_bits(&gb, 2);\n\n                switch (op) {\n\n                case 1:\n\n                    data = seq_decode_op1(seq, data, dst);\n\n                    break;\n\n                case 2:\n\n                    data = seq_decode_op2(seq, data, dst);\n\n                    break;\n\n                case 3:\n\n                    data = seq_decode_op3(seq, data, dst);\n\n                    break;\n\n                }\n\n            }\n\n    }\n\n}\n", "idx": 675}
{"project": "FFmpeg", "commit_id": "1ad542f11f4717a9dee19d46f4da5ce3f6beb449", "target": 1, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = frame->height;\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 676}
{"project": "FFmpeg", "commit_id": "f7f96cf4bcc369730bb945e993bec53881e212f5", "target": 0, "func": "static int build_table(VLC *vlc, int table_nb_bits, int nb_codes,\n\n                       VLCcode *codes, int flags)\n\n{\n\n    int table_size, table_index, index, code_prefix, symbol, subtable_bits;\n\n    int i, j, k, n, nb, inc;\n\n    uint32_t code;\n\n    VLC_TYPE (*table)[2];\n\n\n\n    table_size = 1 << table_nb_bits;\n\n    if (table_nb_bits > 30)\n\n       return -1;\n\n    table_index = alloc_table(vlc, table_size, flags & INIT_VLC_USE_NEW_STATIC);\n\n    av_dlog(NULL, \"new table index=%d size=%d\\n\", table_index, table_size);\n\n    if (table_index < 0)\n\n        return table_index;\n\n    table = &vlc->table[table_index];\n\n\n\n    for (i = 0; i < table_size; i++) {\n\n        table[i][1] = 0; //bits\n\n        table[i][0] = -1; //codes\n\n    }\n\n\n\n    /* first pass: map codes and compute auxiliary table sizes */\n\n    for (i = 0; i < nb_codes; i++) {\n\n        n      = codes[i].bits;\n\n        code   = codes[i].code;\n\n        symbol = codes[i].symbol;\n\n        av_dlog(NULL, \"i=%d n=%d code=0x%x\\n\", i, n, code);\n\n        if (n <= table_nb_bits) {\n\n            /* no need to add another table */\n\n            j = code >> (32 - table_nb_bits);\n\n            nb = 1 << (table_nb_bits - n);\n\n            inc = 1;\n\n            if (flags & INIT_VLC_LE) {\n\n                j = bitswap_32(code);\n\n                inc = 1 << n;\n\n            }\n\n            for (k = 0; k < nb; k++) {\n\n                av_dlog(NULL, \"%4x: code=%d n=%d\\n\", j, i, n);\n\n                if (table[j][1] /*bits*/ != 0) {\n\n                    av_log(NULL, AV_LOG_ERROR, \"incorrect codes\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                table[j][1] = n; //bits\n\n                table[j][0] = symbol;\n\n                j += inc;\n\n            }\n\n        } else {\n\n            /* fill auxiliary table recursively */\n\n            n -= table_nb_bits;\n\n            code_prefix = code >> (32 - table_nb_bits);\n\n            subtable_bits = n;\n\n            codes[i].bits = n;\n\n            codes[i].code = code << table_nb_bits;\n\n            for (k = i+1; k < nb_codes; k++) {\n\n                n = codes[k].bits - table_nb_bits;\n\n                if (n <= 0)\n\n                    break;\n\n                code = codes[k].code;\n\n                if (code >> (32 - table_nb_bits) != code_prefix)\n\n                    break;\n\n                codes[k].bits = n;\n\n                codes[k].code = code << table_nb_bits;\n\n                subtable_bits = FFMAX(subtable_bits, n);\n\n            }\n\n            subtable_bits = FFMIN(subtable_bits, table_nb_bits);\n\n            j = (flags & INIT_VLC_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;\n\n            table[j][1] = -subtable_bits;\n\n            av_dlog(NULL, \"%4x: n=%d (subtable)\\n\",\n\n                    j, codes[i].bits + table_nb_bits);\n\n            index = build_table(vlc, subtable_bits, k-i, codes+i, flags);\n\n            if (index < 0)\n\n                return index;\n\n            /* note: realloc has been done, so reload tables */\n\n            table = &vlc->table[table_index];\n\n            table[j][0] = index; //code\n\n            av_assert0(table[j][0] == index);\n\n            i = k-1;\n\n        }\n\n    }\n\n    return table_index;\n\n}\n", "idx": 678}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_h_loop_filter_luma_intra_c(uint8_t *pix, int stride, int alpha, int beta)\n\n{\n\n    h264_loop_filter_luma_intra_c(pix, 1, stride, alpha, beta);\n\n}\n", "idx": 679}
{"project": "FFmpeg", "commit_id": "3b6516f7e7bb33b7aef9fa25adbf45f3de6c0560", "target": 0, "func": "static inline void do_imdct(AC3DecodeContext *s, int channels)\n\n{\n\n    int ch;\n\n\n\n    for (ch=1; ch<=channels; ch++) {\n\n        if (s->block_switch[ch]) {\n\n            int i;\n\n            float *x = s->tmp_output+128;\n\n            for(i=0; i<128; i++)\n\n                x[i] = s->transform_coeffs[ch][2*i];\n\n            ff_imdct_half(&s->imdct_256, s->tmp_output, x);\n\n            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);\n\n            for(i=0; i<128; i++)\n\n                x[i] = s->transform_coeffs[ch][2*i+1];\n\n            ff_imdct_half(&s->imdct_256, s->delay[ch-1], x);\n\n        } else {\n\n            ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);\n\n            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);\n\n            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));\n\n        }\n\n    }\n\n}\n", "idx": 680}
{"project": "qemu", "commit_id": "f2917853f715b0ef55df29eb2ffea29dc69ce814", "target": 1, "func": "static void parse_header_digest(struct iscsi_context *iscsi, const char *target)\n\n{\n\n    QemuOptsList *list;\n\n    QemuOpts *opts;\n\n    const char *digest = NULL;\n\n\n\n    list = qemu_find_opts(\"iscsi\");\n\n    if (!list) {\n\n        return;\n\n    }\n\n\n\n    opts = qemu_opts_find(list, target);\n\n    if (opts == NULL) {\n\n        opts = QTAILQ_FIRST(&list->head);\n\n        if (!opts) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    digest = qemu_opt_get(opts, \"header-digest\");\n\n    if (!digest) {\n\n        return;\n\n    }\n\n\n\n    if (!strcmp(digest, \"CRC32C\")) {\n\n        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C);\n\n    } else if (!strcmp(digest, \"NONE\")) {\n\n        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE);\n\n    } else if (!strcmp(digest, \"CRC32C-NONE\")) {\n\n        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C_NONE);\n\n    } else if (!strcmp(digest, \"NONE-CRC32C\")) {\n\n        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n    } else {\n\n        error_report(\"Invalid header-digest setting : %s\", digest);\n\n    }\n\n}\n", "idx": 681}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_str(Visitor *v, char **obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_str(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 684}
{"project": "FFmpeg", "commit_id": "a6e14edde01bafbbe54f6f451efa718a48975b47", "target": 1, "func": "static int http_send_data(HTTPContext *c)\n\n{\n\n    int len, ret;\n\n\n\n    while (c->buffer_ptr >= c->buffer_end) {\n\n        ret = http_prepare_data(c);\n\n        if (ret < 0)\n\n            return -1;\n\n        else if (ret == 0) {\n\n            break;\n\n        } else {\n\n            /* state change requested */\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (c->buffer_end > c->buffer_ptr) {\n\n        len = write(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr);\n\n        if (len < 0) {\n\n            if (errno != EAGAIN && errno != EINTR) {\n\n                /* error : close connection */\n\n                return -1;\n\n            }\n\n        } else {\n\n            c->buffer_ptr += len;\n\n            c->data_count += len;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 685}
{"project": "qemu", "commit_id": "8bf6cbaf396a8b54b138bb8a7c3377f2868ed16e", "target": 1, "func": "static void m68060_cpu_initfn(Object *obj)\n\n{\n\n    M68kCPU *cpu = M68K_CPU(obj);\n\n    CPUM68KState *env = &cpu->env;\n\n\n\n    m68k_set_feature(env, M68K_FEATURE_M68000);\n\n    m68k_set_feature(env, M68K_FEATURE_USP);\n\n    m68k_set_feature(env, M68K_FEATURE_WORD_INDEX);\n\n    m68k_set_feature(env, M68K_FEATURE_BRAL);\n\n    m68k_set_feature(env, M68K_FEATURE_BCCL);\n\n    m68k_set_feature(env, M68K_FEATURE_BITFIELD);\n\n    m68k_set_feature(env, M68K_FEATURE_EXT_FULL);\n\n    m68k_set_feature(env, M68K_FEATURE_SCALED_INDEX);\n\n    m68k_set_feature(env, M68K_FEATURE_LONG_MULDIV);\n\n    m68k_set_feature(env, M68K_FEATURE_FPU);\n\n    m68k_set_feature(env, M68K_FEATURE_CAS);\n\n    m68k_set_feature(env, M68K_FEATURE_BKPT);\n\n    m68k_set_feature(env, M68K_FEATURE_RTD);\n\n\n}", "idx": 687}
{"project": "qemu", "commit_id": "0ccff151b42a5b684ce22473b68972a94bc708fb", "target": 1, "func": "void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,\n\n                    const char *boot_device,\n\n                    const char *kernel_filename, const char *kernel_cmdline,\n\n                    const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    unsigned long bios_offset;\n\n    int bios_size;\n\n    CPUState *env;\n\n    RTCState *rtc_state;\n\n    int i;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"R4000\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    /* allocate RAM */\n\n\n\n\n\n\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    if (!mips_qemu_iomemtype) {\n\n        mips_qemu_iomemtype = cpu_register_io_memory(0, mips_qemu_read,\n\n                                                     mips_qemu_write, NULL);\n\n\n    cpu_register_physical_memory(0x1fbf0000, 0x10000, mips_qemu_iomemtype);\n\n\n\n    /* Try to load a BIOS image. If this fails, we continue regardless,\n\n       but initialize the hardware ourselves. When a kernel gets\n\n       preloaded we also initialize the hardware, since the BIOS wasn't\n\n       run. */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if ((bios_size > 0) && (bios_size <= BIOS_SIZE)) {\n\n\tcpu_register_physical_memory(0x1fc00000,\n\n\t\t\t\t     BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n    } else if ((index = drive_get_index(IF_PFLASH, 0, 0)) > -1) {\n\n        uint32_t mips_rom = 0x00400000;\n\n        cpu_register_physical_memory(0x1fc00000, mips_rom,\n\n\t                     qemu_ram_alloc(mips_rom) | IO_MEM_ROM);\n\n        if (!pflash_cfi01_register(0x1fc00000, qemu_ram_alloc(mips_rom),\n\n            drives_table[index].bdrv, sector_len, mips_rom / sector_len,\n\n            4, 0, 0, 0, 0)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n\n\n    else {\n\n\t/* not fatal */\n\n        fprintf(stderr, \"qemu: Warning, could not load MIPS bios '%s'\\n\",\n\n\t\tbuf);\n\n\n\n\n    if (kernel_filename) {\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        load_kernel (env);\n\n\n\n\n    /* Init CPU internal devices */\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    /* The PIC is attached to the MIPS CPU INT0 pin */\n\n    i8259 = i8259_init(env->irq[2]);\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    /* Register 64 KB of ISA IO space at 0x14000000 */\n\n    isa_mmio_init(0x14000000, 0x00010000);\n\n    isa_mem_base = 0x10000000;\n\n\n\n    pit = pit_init(0x40, i8259[0]);\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n\n\n\n\n    isa_vga_init(phys_ram_base + ram_size, ram_size,\n\n                 vga_ram_size);\n\n\n\n    if (nd_table[0].vlan)\n\n        isa_ne2000_init(0x300, i8259[9], &nd_table[0]);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n        if (index != -1)\n\n            hd[i] = drives_table[index].bdrv;\n\n        else\n\n            hd[i] = NULL;\n\n\n\n\n    for(i = 0; i < MAX_IDE_BUS; i++)\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n                     hd[MAX_IDE_DEVS * i],\n\n\t\t     hd[MAX_IDE_DEVS * i + 1]);\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n", "idx": 688}
{"project": "FFmpeg", "commit_id": "a6c49f18abacb9bf52d4d808a2a56561a5b5445c", "target": 1, "func": "static void windowing_and_mdct_ltp(AACContext *ac, float *out,\n\n                                   float *in, IndividualChannelStream *ics)\n\n{\n\n    const float *lwindow      = ics->use_kb_window[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n\n\n    if (ics->window_sequence[0] != LONG_STOP_SEQUENCE) {\n\n        ac->dsp.vector_fmul(in, in, lwindow_prev, 1024);\n\n    } else {\n\n        memset(in, 0, 448 * sizeof(float));\n\n        ac->dsp.vector_fmul(in + 448, in + 448, swindow_prev, 128);\n\n        memcpy(in + 576, in + 576, 448 * sizeof(float));\n\n    }\n\n    if (ics->window_sequence[0] != LONG_START_SEQUENCE) {\n\n        ac->dsp.vector_fmul_reverse(in + 1024, in + 1024, lwindow, 1024);\n\n    } else {\n\n        memcpy(in + 1024, in + 1024, 448 * sizeof(float));\n\n        ac->dsp.vector_fmul_reverse(in + 1024 + 448, in + 1024 + 448, swindow, 128);\n\n        memset(in + 1024 + 576, 0, 448 * sizeof(float));\n\n    }\n\n    ac->mdct_ltp.mdct_calc(&ac->mdct_ltp, out, in);\n\n}\n", "idx": 689}
{"project": "FFmpeg", "commit_id": "712d962a6a29b1099cd872cfb07867175a93ac4c", "target": 0, "func": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n    c->trak_index = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    c->trak_index = -1;\n\n\n\n    /* sanity checks */\n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(c, &sc->pb, c->fc->filename, dref,\n\n                          &c->fc->interrupt_callback) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num && st->codec->width && st->codec->height &&\n\n            sc->height && sc->width &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    // If the duration of the mp3 packets is not constant, then they could need a parser\n\n    if (st->codec->codec_id == AV_CODEC_ID_MP3\n\n        && sc->stts_count > 3\n\n        && sc->stts_count*10 > st->nb_frames\n\n        && sc->time_scale == st->codec->sample_rate) {\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n    }\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n", "idx": 690}
{"project": "FFmpeg", "commit_id": "c7c207aecde0773afc974ce4b7e25dca659bc5b5", "target": 1, "func": "static int mxg_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int size;\n\n    uint8_t *startmarker_ptr, *end, *search_end, marker;\n\n    MXGContext *mxg = s->priv_data;\n\n\n\n    while (!avio_feof(s->pb) && !s->pb->error){\n\n        if (mxg->cache_size <= OVERREAD_SIZE) {\n\n            /* update internal buffer */\n\n            ret = mxg_update_cache(s, DEFAULT_PACKET_SIZE + OVERREAD_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n        end = mxg->buffer_ptr + mxg->cache_size;\n\n\n\n        /* find start marker - 0xff */\n\n        if (mxg->cache_size > OVERREAD_SIZE) {\n\n            search_end = end - OVERREAD_SIZE;\n\n            startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n\n        } else {\n\n            search_end = end;\n\n            startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n\n            if (startmarker_ptr >= search_end - 1 ||\n\n                *(startmarker_ptr + 1) != EOI) break;\n\n        }\n\n\n\n        if (startmarker_ptr != search_end) { /* start marker found */\n\n            marker = *(startmarker_ptr + 1);\n\n            mxg->buffer_ptr = startmarker_ptr + 2;\n\n            mxg->cache_size = end - mxg->buffer_ptr;\n\n\n\n            if (marker == SOI) {\n\n                mxg->soi_ptr = startmarker_ptr;\n\n            } else if (marker == EOI) {\n\n                if (!mxg->soi_ptr) {\n\n                    av_log(s, AV_LOG_WARNING, \"Found EOI before SOI, skipping\\n\");\n\n                    continue;\n\n                }\n\n\n\n                pkt->pts = pkt->dts = mxg->dts;\n\n                pkt->stream_index = 0;\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n                pkt->destruct = NULL;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n                pkt->buf  = NULL;\n\n                pkt->size = mxg->buffer_ptr - mxg->soi_ptr;\n\n                pkt->data = mxg->soi_ptr;\n\n\n\n                if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) {\n\n                    if (mxg->cache_size > 0) {\n\n                        memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n\n                    }\n\n\n\n                    mxg->buffer_ptr = mxg->buffer;\n\n                }\n\n                mxg->soi_ptr = 0;\n\n\n\n                return pkt->size;\n\n            } else if ( (SOF0 <= marker && marker <= SOF15) ||\n\n                        (SOS  <= marker && marker <= COM) ) {\n\n                /* all other markers that start marker segment also contain\n\n                   length value (see specification for JPEG Annex B.1) */\n\n                size = AV_RB16(mxg->buffer_ptr);\n\n                if (size < 2)\n\n                    return AVERROR(EINVAL);\n\n\n\n                if (mxg->cache_size < size) {\n\n                    ret = mxg_update_cache(s, size);\n\n                    if (ret < 0)\n\n                        return ret;\n\n                    startmarker_ptr = mxg->buffer_ptr - 2;\n\n                    mxg->cache_size = 0;\n\n                } else {\n\n                    mxg->cache_size -= size;\n\n                }\n\n\n\n                mxg->buffer_ptr += size;\n\n\n\n                if (marker == APP13 && size >= 16) { /* audio data */\n\n                    /* time (GMT) of first sample in usec since 1970, little-endian */\n\n                    pkt->pts = pkt->dts = AV_RL64(startmarker_ptr + 8);\n\n                    pkt->stream_index = 1;\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n                    pkt->destruct = NULL;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n                    pkt->buf  = NULL;\n\n                    pkt->size = size - 14;\n\n                    pkt->data = startmarker_ptr + 16;\n\n\n\n                    if (startmarker_ptr - mxg->buffer > mxg->cache_size) {\n\n                        if (mxg->cache_size > 0) {\n\n                            memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n\n                        }\n\n                        mxg->buffer_ptr = mxg->buffer;\n\n                    }\n\n\n\n                    return pkt->size;\n\n                } else if (marker == COM && size >= 18 &&\n\n                           !strncmp(startmarker_ptr + 4, \"MXF\", 3)) {\n\n                    /* time (GMT) of video frame in usec since 1970, little-endian */\n\n                    mxg->dts = AV_RL64(startmarker_ptr + 12);\n\n                }\n\n            }\n\n        } else {\n\n            /* start marker not found */\n\n            mxg->buffer_ptr = search_end;\n\n            mxg->cache_size = OVERREAD_SIZE;\n\n        }\n\n    }\n\n\n\n    return AVERROR_EOF;\n\n}\n", "idx": 692}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static uint32_t pci_unin_config_readl (void *opaque,\n\n                                       target_phys_addr_t addr)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    return s->config_reg;\n\n}\n", "idx": 693}
{"project": "FFmpeg", "commit_id": "0fadbd3623cf9132832f48810c0edb93aa63f51b", "target": 1, "func": "static int amf_parse_object(AVFormatContext *s, AVStream *astream,\n\n                            AVStream *vstream, const char *key,\n\n                            int64_t max_pos, int depth)\n\n{\n\n    AVCodecContext *acodec, *vcodec;\n\n    FLVContext *flv = s->priv_data;\n\n    AVIOContext *ioc;\n\n    AMFDataType amf_type;\n\n    char str_val[256];\n\n    double num_val;\n\n\n\n    num_val  = 0;\n\n    ioc      = s->pb;\n\n    amf_type = avio_r8(ioc);\n\n\n\n    switch (amf_type) {\n\n    case AMF_DATA_TYPE_NUMBER:\n\n        num_val = av_int2double(avio_rb64(ioc));\n\n        break;\n\n    case AMF_DATA_TYPE_BOOL:\n\n        num_val = avio_r8(ioc);\n\n        break;\n\n    case AMF_DATA_TYPE_STRING:\n\n        if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0)\n\n            return -1;\n\n        break;\n\n    case AMF_DATA_TYPE_OBJECT:\n\n        if ((vstream || astream) && key &&\n\n            ioc->seekable &&\n\n            !strcmp(KEYFRAMES_TAG, key) && depth == 1)\n\n            if (parse_keyframes_index(s, ioc, vstream ? vstream : astream,\n\n                                      max_pos) < 0)\n\n                av_log(s, AV_LOG_ERROR, \"Keyframe index parsing failed\\n\");\n\n\n\n        while (avio_tell(ioc) < max_pos - 2 &&\n\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n\n                                 depth + 1) < 0)\n\n                return -1;     // if we couldn't skip, bomb out.\n\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n\n            return -1;\n\n        break;\n\n    case AMF_DATA_TYPE_NULL:\n\n    case AMF_DATA_TYPE_UNDEFINED:\n\n    case AMF_DATA_TYPE_UNSUPPORTED:\n\n        break;     // these take up no additional space\n\n    case AMF_DATA_TYPE_MIXEDARRAY:\n\n        avio_skip(ioc, 4);     // skip 32-bit max array index\n\n        while (avio_tell(ioc) < max_pos - 2 &&\n\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n\n            // this is the only case in which we would want a nested\n\n            // parse to not skip over the object\n\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n\n                                 depth + 1) < 0)\n\n                return -1;\n\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n\n            return -1;\n\n        break;\n\n    case AMF_DATA_TYPE_ARRAY:\n\n    {\n\n        unsigned int arraylen, i;\n\n\n\n        arraylen = avio_rb32(ioc);\n\n        for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++)\n\n            if (amf_parse_object(s, NULL, NULL, NULL, max_pos,\n\n                                 depth + 1) < 0)\n\n                return -1;      // if we couldn't skip, bomb out.\n\n    }\n\n    break;\n\n    case AMF_DATA_TYPE_DATE:\n\n        avio_skip(ioc, 8 + 2);  // timestamp (double) and UTC offset (int16)\n\n        break;\n\n    default:                    // unsupported type, we couldn't skip\n\n        return -1;\n\n    }\n\n\n\n    if (key) {\n\n        // stream info doesn't live any deeper than the first object\n\n        if (depth == 1) {\n\n            acodec = astream ? astream->codec : NULL;\n\n            vcodec = vstream ? vstream->codec : NULL;\n\n\n\n            if (amf_type == AMF_DATA_TYPE_NUMBER ||\n\n                amf_type == AMF_DATA_TYPE_BOOL) {\n\n                if (!strcmp(key, \"duration\"))\n\n                    s->duration = num_val * AV_TIME_BASE;\n\n                else if (!strcmp(key, \"videodatarate\") && vcodec &&\n\n                         0 <= (int)(num_val * 1024.0))\n\n                    vcodec->bit_rate = num_val * 1024.0;\n\n                else if (!strcmp(key, \"audiodatarate\") && acodec &&\n\n                         0 <= (int)(num_val * 1024.0))\n\n                    acodec->bit_rate = num_val * 1024.0;\n\n                else if (!strcmp(key, \"datastream\")) {\n\n                    AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);\n\n                    if (!st)\n\n                        return AVERROR(ENOMEM);\n\n                    st->codec->codec_id = AV_CODEC_ID_TEXT;\n\n                } else if (flv->trust_metadata) {\n\n                    if (!strcmp(key, \"videocodecid\") && vcodec) {\n\n                        flv_set_video_codec(s, vstream, num_val, 0);\n\n                    } else if (!strcmp(key, \"audiocodecid\") && acodec) {\n\n                        int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;\n\n                        flv_set_audio_codec(s, astream, acodec, id);\n\n                    } else if (!strcmp(key, \"audiosamplerate\") && acodec) {\n\n                        acodec->sample_rate = num_val;\n\n                    } else if (!strcmp(key, \"audiosamplesize\") && acodec) {\n\n                        acodec->bits_per_coded_sample = num_val;\n\n                    } else if (!strcmp(key, \"stereo\") && acodec) {\n\n                        acodec->channels       = num_val + 1;\n\n                        acodec->channel_layout = acodec->channels == 2 ?\n\n                                                 AV_CH_LAYOUT_STEREO :\n\n                                                 AV_CH_LAYOUT_MONO;\n\n                    } else if (!strcmp(key, \"width\") && vcodec) {\n\n                        vcodec->width = num_val;\n\n                    } else if (!strcmp(key, \"height\") && vcodec) {\n\n                        vcodec->height = num_val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 &&\n\n           ((!acodec && !strcmp(key, \"audiocodecid\")) ||\n\n            (!vcodec && !strcmp(key, \"videocodecid\"))))\n\n                s->ctx_flags &= ~AVFMTCTX_NOHEADER; //If there is either audio/video missing, codecid will be an empty object\n\n\n\n        if (!strcmp(key, \"duration\")        ||\n\n            !strcmp(key, \"filesize\")        ||\n\n            !strcmp(key, \"width\")           ||\n\n            !strcmp(key, \"height\")          ||\n\n            !strcmp(key, \"videodatarate\")   ||\n\n            !strcmp(key, \"framerate\")       ||\n\n            !strcmp(key, \"videocodecid\")    ||\n\n            !strcmp(key, \"audiodatarate\")   ||\n\n            !strcmp(key, \"audiosamplerate\") ||\n\n            !strcmp(key, \"audiosamplesize\") ||\n\n            !strcmp(key, \"stereo\")          ||\n\n            !strcmp(key, \"audiocodecid\")    ||\n\n            !strcmp(key, \"datastream\"))\n\n            return 0;\n\n\n\n        s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n\n        if (amf_type == AMF_DATA_TYPE_BOOL) {\n\n            av_strlcpy(str_val, num_val > 0 ? \"true\" : \"false\",\n\n                       sizeof(str_val));\n\n            av_dict_set(&s->metadata, key, str_val, 0);\n\n        } else if (amf_type == AMF_DATA_TYPE_NUMBER) {\n\n            snprintf(str_val, sizeof(str_val), \"%.f\", num_val);\n\n            av_dict_set(&s->metadata, key, str_val, 0);\n\n        } else if (amf_type == AMF_DATA_TYPE_STRING)\n\n            av_dict_set(&s->metadata, key, str_val, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 694}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_subq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_sub_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 695}
{"project": "FFmpeg", "commit_id": "0f13cc732b3752828890b8dff507615cfd454336", "target": 1, "func": "static void decode_component(DiracContext *s, int comp)\n\n{\n\n    AVCodecContext *avctx = s->avctx;\n\n    SubBand *bands[3*MAX_DWT_LEVELS+1];\n\n    enum dirac_subband orientation;\n\n    int level, num_bands = 0;\n\n\n\n    /* Unpack all subbands at all levels. */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            SubBand *b = &s->plane[comp].band[level][orientation];\n\n            bands[num_bands++] = b;\n\n\n\n            align_get_bits(&s->gb);\n\n            /* [DIRAC_STD] 13.4.2 subband() */\n\n            b->length = svq3_get_ue_golomb(&s->gb);\n\n            if (b->length) {\n\n                b->quant = svq3_get_ue_golomb(&s->gb);\n\n                align_get_bits(&s->gb);\n\n                b->coeff_data = s->gb.buffer + get_bits_count(&s->gb)/8;\n\n                b->length = FFMIN(b->length, get_bits_left(&s->gb)/8);\n\n                skip_bits_long(&s->gb, b->length*8);\n\n            }\n\n        }\n\n        /* arithmetic coding has inter-level dependencies, so we can only execute one level at a time */\n\n        if (s->is_arith)\n\n            avctx->execute(avctx, decode_subband_arith, &s->plane[comp].band[level][!!level],\n\n                           NULL, 4-!!level, sizeof(SubBand));\n\n    }\n\n    /* golomb coding has no inter-level dependencies, so we can execute all subbands in parallel */\n\n    if (!s->is_arith)\n\n        avctx->execute(avctx, decode_subband_golomb, bands, NULL, num_bands, sizeof(SubBand*));\n\n}\n", "idx": 697}
{"project": "qemu", "commit_id": "b981289c493c7ddabc1cdf7de99daa24642c7739", "target": 1, "func": "static void ppc_heathrow_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    PowerPCCPU *cpu = NULL;\n\n    CPUPPCState *env = NULL;\n\n    char *filename;\n\n    qemu_irq *pic, **heathrow_irqs;\n\n    int linux_boot, i;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios = g_new(MemoryRegion, 1);\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    uint32_t kernel_base, initrd_base, cmdline_base = 0;\n\n    int32_t kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    PCIDevice *macio;\n\n    MACIOIDEState *macio_ide;\n\n    DeviceState *dev;\n\n    BusState *adb_bus;\n\n    int bios_size;\n\n    MemoryRegion *pic_mem;\n\n    MemoryRegion *escc_mem, *escc_bar = g_new(MemoryRegion, 1);\n\n    uint16_t ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    uint64_t tbfreq;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"G3\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        /* Set time-base frequency to 16.6 Mhz */\n\n        cpu_ppc_tb_init(env,  TBFREQ);\n\n        qemu_register_reset(ppc_heathrow_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    if (ram_size > (2047 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2047 MB\\n\",\n\n                ((unsigned int)ram_size / (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_heathrow.ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    /* allocate and load BIOS */\n\n    memory_region_init_ram(bios, NULL, \"ppc_heathrow.bios\", BIOS_SIZE);\n\n    vmstate_register_ram_global(bios);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    memory_region_set_readonly(bios, true);\n\n    memory_region_add_subregion(sysmem, PROM_ADDR, bios);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, 0, NULL, NULL, NULL, NULL,\n\n                             1, ELF_MACHINE, 0);\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n            cmdline_base = round_page(initrd_base + initrd_size);\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n            cmdline_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            /* TOFIX: for now, the second IDE channel is not properly\n\n             *        used by OHW. The Mac floppy disk are not emulated.\n\n             *        For now, OHW cannot boot from the network.\n\n             */\n\n#if 0\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#else\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'd') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n#endif\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for G3 Beige machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Register 2 MB of ISA IO space */\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, 0x00200000);\n\n    memory_region_add_subregion(sysmem, 0xfe000000, isa);\n\n\n\n    /* XXX: we register only 1 output pin for heathrow PIC */\n\n    heathrow_irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    heathrow_irqs[0] =\n\n        g_malloc0(smp_cpus * sizeof(qemu_irq) * 1);\n\n    /* Connect the heathrow PIC outputs to the 6xx bus */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);\n\n            heathrow_irqs[i][0] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            break;\n\n        default:\n\n            hw_error(\"Bus model not supported on OldWorld Mac machine\\n\");\n\n        }\n\n    }\n\n\n\n    /* Timebase Frequency */\n\n    if (kvm_enabled()) {\n\n        tbfreq = kvmppc_get_tbfreq();\n\n    } else {\n\n        tbfreq = TBFREQ;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on heathrow machine\\n\");\n\n    }\n\n    pic = heathrow_pic_init(&pic_mem, 1, heathrow_irqs);\n\n    pci_bus = pci_grackle_init(0xfec00000, pic,\n\n                               get_system_memory(),\n\n                               get_system_io());\n\n    pci_vga_init(pci_bus);\n\n\n\n    escc_mem = escc_init(0, pic[0x0f], pic[0x10], serial_hds[0],\n\n                               serial_hds[1], ESCC_CLOCK, 4);\n\n    memory_region_init_alias(escc_bar, NULL, \"escc-bar\",\n\n                             escc_mem, 0, memory_region_size(escc_mem));\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n\n\n    macio = pci_create(pci_bus, -1, TYPE_OLDWORLD_MACIO);\n\n    dev = DEVICE(macio);\n\n    qdev_connect_gpio_out(dev, 0, pic[0x12]); /* CUDA */\n\n    qdev_connect_gpio_out(dev, 1, pic[0x0D]); /* IDE-0 */\n\n    qdev_connect_gpio_out(dev, 2, pic[0x02]); /* IDE-0 DMA */\n\n    qdev_connect_gpio_out(dev, 3, pic[0x0E]); /* IDE-1 */\n\n    qdev_connect_gpio_out(dev, 4, pic[0x03]); /* IDE-1 DMA */\n\n\n    macio_init(macio, pic_mem, escc_bar);\n\n\n\n    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n\n                                                        \"ide[0]\"));\n\n    macio_ide_init_drives(macio_ide, hd);\n\n\n\n    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n\n                                                        \"ide[1]\"));\n\n    macio_ide_init_drives(macio_ide, &hd[MAX_IDE_DEVS]);\n\n\n\n    dev = DEVICE(object_resolve_path_component(OBJECT(macio), \"cuda\"));\n\n    adb_bus = qdev_get_child_bus(dev, \"adb.0\");\n\n    dev = qdev_create(adb_bus, TYPE_ADB_KEYBOARD);\n\n    qdev_init_nofail(dev);\n\n    dev = qdev_create(adb_bus, TYPE_ADB_MOUSE);\n\n    qdev_init_nofail(dev);\n\n\n\n    if (usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_HEATHROW);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, cmdline_base);\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        hypercall = g_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, tbfreq);\n\n    /* Mac OS X requires a \"known good\" clock-frequency value; pass it one. */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_CLOCKFREQ, CLOCKFREQ);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_BUSFREQ, BUSFREQ);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}", "idx": 698}
{"project": "FFmpeg", "commit_id": "2f00300b779e7b247c85db0d7daef448225105ff", "target": 1, "func": "static int unpack_dct_coeffs(Vp3DecodeContext *s, GetBitContext *gb)\n\n{\n\n    int i;\n\n    int dc_y_table;\n\n    int dc_c_table;\n\n    int ac_y_table;\n\n    int ac_c_table;\n\n    int residual_eob_run = 0;\n\n    VLC *y_tables[64];\n\n    VLC *c_tables[64];\n\n\n\n    s->dct_tokens[0][0] = s->dct_tokens_base;\n\n\n\n    if (get_bits_left(gb) < 16)\n\n\n\n\n    /* fetch the DC table indexes */\n\n    dc_y_table = get_bits(gb, 4);\n\n    dc_c_table = get_bits(gb, 4);\n\n\n\n    /* unpack the Y plane DC coefficients */\n\n    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_y_table], 0,\n\n                                   0, residual_eob_run);\n\n    if (residual_eob_run < 0)\n\n        return residual_eob_run;\n\n\n\n\n\n    /* reverse prediction of the Y-plane DC coefficients */\n\n    reverse_dc_prediction(s, 0, s->fragment_width[0], s->fragment_height[0]);\n\n\n\n    /* unpack the C plane DC coefficients */\n\n    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_c_table], 0,\n\n                                   1, residual_eob_run);\n\n    if (residual_eob_run < 0)\n\n        return residual_eob_run;\n\n    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_c_table], 0,\n\n                                   2, residual_eob_run);\n\n    if (residual_eob_run < 0)\n\n        return residual_eob_run;\n\n\n\n    /* reverse prediction of the C-plane DC coefficients */\n\n    if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n        reverse_dc_prediction(s, s->fragment_start[1],\n\n                              s->fragment_width[1], s->fragment_height[1]);\n\n        reverse_dc_prediction(s, s->fragment_start[2],\n\n                              s->fragment_width[1], s->fragment_height[1]);\n\n    }\n\n\n\n\n\n    /* fetch the AC table indexes */\n\n    ac_y_table = get_bits(gb, 4);\n\n    ac_c_table = get_bits(gb, 4);\n\n\n\n    /* build tables of AC VLC tables */\n\n    for (i = 1; i <= 5; i++) {\n\n        y_tables[i] = &s->ac_vlc_1[ac_y_table];\n\n        c_tables[i] = &s->ac_vlc_1[ac_c_table];\n\n    }\n\n    for (i = 6; i <= 14; i++) {\n\n        y_tables[i] = &s->ac_vlc_2[ac_y_table];\n\n        c_tables[i] = &s->ac_vlc_2[ac_c_table];\n\n    }\n\n    for (i = 15; i <= 27; i++) {\n\n        y_tables[i] = &s->ac_vlc_3[ac_y_table];\n\n        c_tables[i] = &s->ac_vlc_3[ac_c_table];\n\n    }\n\n    for (i = 28; i <= 63; i++) {\n\n        y_tables[i] = &s->ac_vlc_4[ac_y_table];\n\n        c_tables[i] = &s->ac_vlc_4[ac_c_table];\n\n    }\n\n\n\n    /* decode all AC coefficients */\n\n    for (i = 1; i <= 63; i++) {\n\n        residual_eob_run = unpack_vlcs(s, gb, y_tables[i], i,\n\n                                       0, residual_eob_run);\n\n        if (residual_eob_run < 0)\n\n            return residual_eob_run;\n\n\n\n        residual_eob_run = unpack_vlcs(s, gb, c_tables[i], i,\n\n                                       1, residual_eob_run);\n\n        if (residual_eob_run < 0)\n\n            return residual_eob_run;\n\n        residual_eob_run = unpack_vlcs(s, gb, c_tables[i], i,\n\n                                       2, residual_eob_run);\n\n        if (residual_eob_run < 0)\n\n            return residual_eob_run;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 699}
{"project": "FFmpeg", "commit_id": "ef0c6d9b01de773e5a1177de5fcbb981aac44d65", "target": 1, "func": "static void free_device_list(AVOpenCLDeviceList *device_list)\n\n{\n\n    int i, j;\n\n    if (!device_list)\n\n        return;\n\n    for (i = 0; i < device_list->platform_num; i++) {\n\n        if (!device_list->platform_node[i])\n\n            continue;\n\n        for (j = 0; j < device_list->platform_node[i]->device_num; j++) {\n\n            av_freep(&(device_list->platform_node[i]->device_node[j]->device_name));\n\n            av_freep(&(device_list->platform_node[i]->device_node[j]));\n\n        }\n\n        av_freep(&device_list->platform_node[i]->device_node);\n\n        av_freep(&(device_list->platform_node[i]->platform_name));\n\n        av_freep(&device_list->platform_node[i]);\n\n    }\n\n    av_freep(&device_list->platform_node);\n\n    device_list->platform_num = 0;\n\n}\n", "idx": 700}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_init(QemuCond *cond)\n\n{\n\n    memset(cond, 0, sizeof(*cond));\n\n\n\n    cond->sema = CreateSemaphore(NULL, 0, LONG_MAX, NULL);\n\n    if (!cond->sema) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n    cond->continue_event = CreateEvent(NULL,    /* security */\n\n                                       FALSE,   /* auto-reset */\n\n                                       FALSE,   /* not signaled */\n\n                                       NULL);   /* name */\n\n    if (!cond->continue_event) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n}\n", "idx": 701}
{"project": "qemu", "commit_id": "a1bb73849fbd7d992b6ac2cf30c034244fb2299d", "target": 1, "func": "void helper_rfdi(CPUPPCState *env)\n\n{\n\n    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], SPR_BOOKE_DSRR1,\n\n           ~((target_ulong)0x3FFF0000), 0);\n\n}\n", "idx": 702}
{"project": "FFmpeg", "commit_id": "947cbeca16c7a30322e02feea440e1e67801ab9a", "target": 1, "func": "static void choose_sample_rate(AVStream *st, AVCodec *codec)\n\n{\n\n    if(codec && codec->supported_samplerates){\n\n        const int *p= codec->supported_samplerates;\n\n        int best;\n\n        int best_dist=INT_MAX;\n\n        for(; *p; p++){\n\n            int dist= abs(st->codec->sample_rate - *p);\n\n            if(dist < best_dist){\n\n                best_dist= dist;\n\n                best= *p;\n\n            }\n\n        }\n\n        if(best_dist){\n\n            av_log(st->codec, AV_LOG_WARNING, \"Requested sampling rate unsupported using closest supported (%d)\\n\", best);\n\n        }\n\n        st->codec->sample_rate= best;\n\n    }\n\n}\n", "idx": 703}
{"project": "qemu", "commit_id": "e911765cbb9e9ddf5d952c88bb52180a62c6cea0", "target": 1, "func": "unsigned iov_copy(struct iovec *dst_iov, unsigned int dst_iov_cnt,\n\n                 const struct iovec *iov, unsigned int iov_cnt,\n\n                 size_t offset, size_t bytes)\n\n{\n\n    size_t len;\n\n    unsigned int i, j;\n\n    for (i = 0, j = 0; i < iov_cnt && j < dst_iov_cnt && bytes; i++) {\n\n        if (offset >= iov[i].iov_len) {\n\n            offset -= iov[i].iov_len;\n\n            continue;\n\n        }\n\n        len = MIN(bytes, iov[i].iov_len - offset);\n\n\n\n        dst_iov[j].iov_base = iov[i].iov_base + offset;\n\n        dst_iov[j].iov_len = len;\n\n        j++;\n\n        bytes -= len;\n\n        offset = 0;\n\n    }\n\n    assert(offset == 0);\n\n    return j;\n\n}\n", "idx": 704}
{"project": "qemu", "commit_id": "ef001f069e0f175a036929782c5c63053df9569a", "target": 1, "func": "static int spapr_populate_drconf_memory(sPAPRMachineState *spapr, void *fdt)\n\n{\n\n    MachineState *machine = MACHINE(spapr);\n\n    int ret, i, offset;\n\n    uint64_t lmb_size = SPAPR_MEMORY_BLOCK_SIZE;\n\n    uint32_t prop_lmb_size[] = {0, cpu_to_be32(lmb_size)};\n\n    uint32_t nr_lmbs = (machine->maxram_size - machine->ram_size)/lmb_size;\n\n    uint32_t *int_buf, *cur_index, buf_len;\n\n    int nr_nodes = nb_numa_nodes ? nb_numa_nodes : 1;\n\n\n\n    /* Allocate enough buffer size to fit in ibm,dynamic-memory */\n\n    buf_len = nr_lmbs * SPAPR_DR_LMB_LIST_ENTRY_SIZE * sizeof(uint32_t) +\n\n                sizeof(uint32_t);\n\n    cur_index = int_buf = g_malloc0(buf_len);\n\n\n\n    offset = fdt_add_subnode(fdt, 0, \"ibm,dynamic-reconfiguration-memory\");\n\n\n\n    ret = fdt_setprop(fdt, offset, \"ibm,lmb-size\", prop_lmb_size,\n\n                    sizeof(prop_lmb_size));\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = fdt_setprop_cell(fdt, offset, \"ibm,memory-flags-mask\", 0xff);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = fdt_setprop_cell(fdt, offset, \"ibm,memory-preservation-time\", 0x0);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* ibm,dynamic-memory */\n\n    int_buf[0] = cpu_to_be32(nr_lmbs);\n\n    cur_index++;\n\n    for (i = 0; i < nr_lmbs; i++) {\n\n        sPAPRDRConnector *drc;\n\n        sPAPRDRConnectorClass *drck;\n\n        uint64_t addr = i * lmb_size + spapr->hotplug_memory.base;;\n\n        uint32_t *dynamic_memory = cur_index;\n\n\n\n        drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                       addr/lmb_size);\n\n        g_assert(drc);\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n        dynamic_memory[0] = cpu_to_be32(addr >> 32);\n\n        dynamic_memory[1] = cpu_to_be32(addr & 0xffffffff);\n\n        dynamic_memory[2] = cpu_to_be32(drck->get_index(drc));\n\n        dynamic_memory[3] = cpu_to_be32(0); /* reserved */\n\n        dynamic_memory[4] = cpu_to_be32(numa_get_node(addr, NULL));\n\n        if (addr < machine->ram_size ||\n\n                    memory_region_present(get_system_memory(), addr)) {\n\n            dynamic_memory[5] = cpu_to_be32(SPAPR_LMB_FLAGS_ASSIGNED);\n\n        } else {\n\n            dynamic_memory[5] = cpu_to_be32(0);\n\n        }\n\n\n\n        cur_index += SPAPR_DR_LMB_LIST_ENTRY_SIZE;\n\n    }\n\n    ret = fdt_setprop(fdt, offset, \"ibm,dynamic-memory\", int_buf, buf_len);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* ibm,associativity-lookup-arrays */\n\n    cur_index = int_buf;\n\n    int_buf[0] = cpu_to_be32(nr_nodes);\n\n    int_buf[1] = cpu_to_be32(4); /* Number of entries per associativity list */\n\n    cur_index += 2;\n\n    for (i = 0; i < nr_nodes; i++) {\n\n        uint32_t associativity[] = {\n\n            cpu_to_be32(0x0),\n\n            cpu_to_be32(0x0),\n\n            cpu_to_be32(0x0),\n\n            cpu_to_be32(i)\n\n        };\n\n        memcpy(cur_index, associativity, sizeof(associativity));\n\n        cur_index += 4;\n\n    }\n\n    ret = fdt_setprop(fdt, offset, \"ibm,associativity-lookup-arrays\", int_buf,\n\n            (cur_index - int_buf) * sizeof(uint32_t));\n\nout:\n\n    g_free(int_buf);\n\n    return ret;\n\n}\n", "idx": 708}
{"project": "FFmpeg", "commit_id": "5eb765ef341c3ec1bea31914c897750f88476ede", "target": 1, "func": "static int http_server(struct sockaddr_in my_addr)\n\n{\n\n    int server_fd, tmp, ret;\n\n    struct sockaddr_in from_addr;\n\n    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 1], *poll_entry;\n\n    HTTPContext *c, **cp;\n\n    long cur_time;\n\n\n\n    server_fd = socket(AF_INET,SOCK_STREAM,0);\n\n    if (server_fd < 0) {\n\n        perror (\"socket\");\n\n        return -1;\n\n    }\n\n        \n\n    tmp = 1;\n\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(tmp));\n\n\n\n    if (bind (server_fd, (struct sockaddr *) &my_addr, sizeof (my_addr)) < 0) {\n\n        perror (\"bind\");\n\n        close(server_fd);\n\n        return -1;\n\n    }\n\n  \n\n    if (listen (server_fd, 5) < 0) {\n\n        perror (\"listen\");\n\n        close(server_fd);\n\n        return -1;\n\n    }\n\n\n\n    http_log(\"ffserver started.\\n\");\n\n\n\n    start_children(first_feed);\n\n\n\n    fcntl(server_fd, F_SETFL, O_NONBLOCK);\n\n    first_http_ctx = NULL;\n\n    nb_connections = 0;\n\n    first_http_ctx = NULL;\n\n    for(;;) {\n\n        poll_entry = poll_table;\n\n        poll_entry->fd = server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        /* wait for events on each HTTP handle */\n\n        c = first_http_ctx;\n\n        while (c != NULL) {\n\n            int fd;\n\n            fd = c->fd;\n\n            switch(c->state) {\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_SEND_HEADER:\n\n            case HTTPSTATE_SEND_DATA_HEADER:\n\n            case HTTPSTATE_SEND_DATA:\n\n            case HTTPSTATE_SEND_DATA_TRAILER:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLOUT;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT_FEED:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, 1000);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        /* now handle the events */\n\n\n\n        cp = &first_http_ctx;\n\n        while ((*cp) != NULL) {\n\n            c = *cp;\n\n            if (handle_http (c, cur_time) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close(c->fd);\n\n                if (c->fmt_in)\n\n                    av_close_input_file(c->fmt_in);\n\n                *cp = c->next;\n\n                nb_bandwidth -= c->bandwidth;\n\n                av_free(c->buffer);\n\n                av_free(c->pbuffer);\n\n                av_free(c);\n\n                nb_connections--;\n\n            } else {\n\n                cp = &c->next;\n\n            }\n\n        }\n\n\n\n        /* new connection request ? */\n\n        poll_entry = poll_table;\n\n        if (poll_entry->revents & POLLIN) {\n\n            int fd, len;\n\n\n\n            len = sizeof(from_addr);\n\n            fd = accept(server_fd, (struct sockaddr *)&from_addr, \n\n                        &len);\n\n            if (fd >= 0) {\n\n                fcntl(fd, F_SETFL, O_NONBLOCK);\n\n                /* XXX: should output a warning page when coming\n\n                   close to the connection limit */\n\n                if (nb_connections >= nb_max_connections) {\n\n                    c = NULL;\n\n                } else {\n\n                    /* add a new connection */\n\n                    c = av_mallocz(sizeof(HTTPContext));\n\n                    if (c) {\n\n                        c->next = first_http_ctx;\n\n                        first_http_ctx = c;\n\n                        c->fd = fd;\n\n                        c->poll_entry = NULL;\n\n                        c->from_addr = from_addr;\n\n                        c->state = HTTPSTATE_WAIT_REQUEST;\n\n                        c->buffer = av_malloc(c->buffer_size = IOBUFFER_INIT_SIZE);\n\n                        c->pbuffer = av_malloc(c->pbuffer_size = PBUFFER_INIT_SIZE);\n\n                        if (!c->buffer || !c->pbuffer) {\n\n                            av_free(c->buffer);\n\n                            av_free(c->pbuffer);\n\n                            av_freep(&c);\n\n                        } else {\n\n                            c->buffer_ptr = c->buffer;\n\n                            c->buffer_end = c->buffer + c->buffer_size;\n\n                            c->timeout = cur_time + REQUEST_TIMEOUT;\n\n                            c->start_time = cur_time;\n\n                            nb_connections++;\n\n                        }\n\n                    }\n\n                }\n\n                if (!c) {\n\n                    close(fd);\n\n                }\n\n            }\n\n        }\n\n        poll_entry++;\n\n    }\n\n}\n", "idx": 709}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n    uint8_t t[sizeof(diag_501)];\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, t, sizeof(diag_501), 0)) {\n\n        return -EINVAL;\n\n    } else if (memcmp(t, diag_501, sizeof(diag_501))) {\n\n        return -EINVAL;\n\n    } else if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                                   sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 711}
{"project": "qemu", "commit_id": "aa90fec7ad128039617d31a5fd5ced8b0488f71b", "target": 1, "func": "static int kvm_get_dirty_pages_log_range(MemoryRegionSection *section,\n\n                                         unsigned long *bitmap)\n\n{\n\n    unsigned int i, j;\n\n    unsigned long page_number, addr, addr1, c;\n\n    unsigned int len = ((section->size / TARGET_PAGE_SIZE) + HOST_LONG_BITS - 1) / HOST_LONG_BITS;\n\n\n\n    /*\n\n     * bitmap-traveling is faster than memory-traveling (for addr...)\n\n     * especially when most of the memory is not dirty.\n\n     */\n\n    for (i = 0; i < len; i++) {\n\n        if (bitmap[i] != 0) {\n\n            c = leul_to_cpu(bitmap[i]);\n\n            do {\n\n                j = ffsl(c) - 1;\n\n                c &= ~(1ul << j);\n\n                page_number = i * HOST_LONG_BITS + j;\n\n                addr1 = page_number * TARGET_PAGE_SIZE;\n\n                addr = section->offset_within_region + addr1;\n\n                memory_region_set_dirty(section->mr, addr);\n\n            } while (c != 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 714}
{"project": "qemu", "commit_id": "07a68f990785a8574c78a36b21cf5165e46f1113", "target": 1, "func": "static int ppc_hash64_pte_prot(PowerPCCPU *cpu,\n\n                               ppc_slb_t *slb, ppc_hash_pte64_t pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned pp, key;\n\n    /* Some pp bit combinations have undefined behaviour, so default\n\n     * to no access in those cases */\n\n    int prot = 0;\n\n\n\n    key = !!(msr_pr ? (slb->vsid & SLB_VSID_KP)\n\n             : (slb->vsid & SLB_VSID_KS));\n\n    pp = (pte.pte1 & HPTE64_R_PP) | ((pte.pte1 & HPTE64_R_PP0) >> 61);\n\n\n\n    if (key == 0) {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x1:\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            break;\n\n\n\n        case 0x3:\n\n        case 0x6:\n\n            prot = PAGE_READ | PAGE_EXEC;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (pp) {\n\n        case 0x0:\n\n        case 0x6:\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x3:\n\n            prot = PAGE_READ | PAGE_EXEC;\n\n            break;\n\n\n\n        case 0x2:\n\n            prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* No execute if either noexec or guarded bits set */\n\n    if (!(pte.pte1 & HPTE64_R_N) || (pte.pte1 & HPTE64_R_G)\n\n        || (slb->vsid & SLB_VSID_N)) {\n\n        prot |= PAGE_EXEC;\n\n    }\n\n\n\n    return prot;\n\n}\n", "idx": 715}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int rd_frame(CinepakEncContext *s, AVFrame *frame, unsigned char *buf, int buf_size)\n\n{\n\n    int num_strips, strip, h, i, y, size, temp_size, best_size;\n\n    AVPicture last_pict, pict, scratch_pict;\n\n    int64_t best_score = 0, score, score_temp;\n\n\n\n    //TODO: support encoding zero strips (meaning skip the whole frame)\n\n    for(num_strips = MIN_STRIPS; num_strips <= MAX_STRIPS && num_strips <= s->h / MB_SIZE; num_strips++) {\n\n        score = 0;\n\n        size = 0;\n\n        h = s->h / num_strips;\n\n        //make h into next multiple of 4\n\n        h += 4 - (h & 3);\n\n\n\n        for(strip = 0; strip < num_strips; strip++) {\n\n            y = strip*h;\n\n\n\n            get_sub_picture(s, 0, y, (AVPicture*)frame,            &pict);\n\n            get_sub_picture(s, 0, y, (AVPicture*)&s->last_frame,    &last_pict);\n\n            get_sub_picture(s, 0, y, (AVPicture*)&s->scratch_frame, &scratch_pict);\n\n\n\n            if((temp_size = rd_strip(s, y, FFMIN(h, s->h - y), frame->key_frame, &last_pict, &pict, &scratch_pict, s->frame_buf + CVID_HEADER_SIZE, &score_temp)) < 0)\n\n                return temp_size;\n\n\n\n            score += score_temp;\n\n            size += temp_size;\n\n        }\n\n\n\n        if(best_score == 0 || score < best_score) {\n\n            best_score = score;\n\n            best_size = size + write_cvid_header(s, s->frame_buf, num_strips, size);\n\n            av_log(s->avctx, AV_LOG_INFO, \"best number of strips so far: %2i, %12li, %i B\\n\", num_strips, score, best_size);\n\n\n\n            FFSWAP(AVFrame, s->best_frame, s->scratch_frame);\n\n        }\n\n    }\n\n\n\n    memcpy(buf, s->frame_buf, best_size);\n\n\n\n    return best_size;\n\n}\n", "idx": 716}
{"project": "FFmpeg", "commit_id": "4ced5d7780fea2ea49444d6686d26f26b3a2160f", "target": 1, "func": "void ff_hevc_set_qPy(HEVCContext *s, int xC, int yC,\n\n                     int xBase, int yBase, int log2_cb_size)\n\n{\n\n    int qp_y = get_qPy_pred(s, xC, yC, xBase, yBase, log2_cb_size);\n\n\n\n    if (s->HEVClc->tu.cu_qp_delta != 0) {\n\n        int off = s->sps->qp_bd_offset;\n\n        s->HEVClc->qp_y = ((qp_y + s->HEVClc->tu.cu_qp_delta + 52 + 2 * off) %\n\n                          (52 + off)) - off;\n\n    } else\n\n        s->HEVClc->qp_y = qp_y;\n\n}\n", "idx": 717}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void sdhci_sysbus_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->vmsd = &sdhci_vmstate;\n\n    dc->props = sdhci_sysbus_properties;\n\n    dc->realize = sdhci_sysbus_realize;\n\n    dc->reset = sdhci_poweron_reset;\n\n\n\n\n\n\n}", "idx": 718}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "grlib_gptimer_writel(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    GPTimerUnit        *unit = opaque;\n\n    target_phys_addr_t  timer_addr;\n\n    int                 id;\n\n\n\n    addr &= 0xff;\n\n\n\n    /* Unit registers */\n\n    switch (addr) {\n\n    case SCALER_OFFSET:\n\n        value &= 0xFFFF; /* clean up the value */\n\n        unit->scaler = value;\n\n        trace_grlib_gptimer_writel(-1, \"scaler:\", unit->scaler);\n\n        return;\n\n\n\n    case SCALER_RELOAD_OFFSET:\n\n        value &= 0xFFFF; /* clean up the value */\n\n        unit->reload = value;\n\n        trace_grlib_gptimer_writel(-1, \"reload:\", unit->reload);\n\n        grlib_gptimer_set_scaler(unit, value);\n\n        return;\n\n\n\n    case CONFIG_OFFSET:\n\n        /* Read Only (disable timer freeze not supported) */\n\n        trace_grlib_gptimer_writel(-1, \"config (Read Only):\", 0);\n\n        return;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    timer_addr = (addr % TIMER_BASE);\n\n    id         = (addr - TIMER_BASE) / TIMER_BASE;\n\n\n\n    if (id >= 0 && id < unit->nr_timers) {\n\n\n\n        /* GPTimer registers */\n\n        switch (timer_addr) {\n\n        case COUNTER_OFFSET:\n\n            trace_grlib_gptimer_writel(id, \"counter:\", value);\n\n            unit->timers[id].counter = value;\n\n            grlib_gptimer_enable(&unit->timers[id]);\n\n            return;\n\n\n\n        case COUNTER_RELOAD_OFFSET:\n\n            trace_grlib_gptimer_writel(id, \"reload:\", value);\n\n            unit->timers[id].reload = value;\n\n            return;\n\n\n\n        case CONFIG_OFFSET:\n\n            trace_grlib_gptimer_writel(id, \"config:\", value);\n\n\n\n            if (value & GPTIMER_INT_PENDING) {\n\n                /* clear pending bit */\n\n                value &= ~GPTIMER_INT_PENDING;\n\n            } else {\n\n                /* keep pending bit */\n\n                value |= unit->timers[id].config & GPTIMER_INT_PENDING;\n\n            }\n\n\n\n            unit->timers[id].config = value;\n\n\n\n            /* gptimer_restart calls gptimer_enable, so if \"enable\" and \"load\"\n\n               bits are present, we just have to call restart. */\n\n\n\n            if (value & GPTIMER_LOAD) {\n\n                grlib_gptimer_restart(&unit->timers[id]);\n\n            } else if (value & GPTIMER_ENABLE) {\n\n                grlib_gptimer_enable(&unit->timers[id]);\n\n            }\n\n\n\n            /* These fields must always be read as 0 */\n\n            value &= ~(GPTIMER_LOAD & GPTIMER_DEBUG_HALT);\n\n\n\n            unit->timers[id].config = value;\n\n            return;\n\n\n\n        default:\n\n            break;\n\n        }\n\n\n\n    }\n\n\n\n    trace_grlib_gptimer_unknown_register(\"write\", addr);\n\n}\n", "idx": 719}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "static void check_watchpoint(int offset, int len, MemTxAttrs attrs, int flags)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    CPUArchState *env = cpu->env_ptr;\n\n    target_ulong pc, cs_base;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    uint32_t cpu_flags;\n\n\n\n    if (cpu->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    vaddr = cc->adjust_watchpoint_address(cpu, vaddr, len);\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        if (cpu_watchpoint_address_matches(wp, vaddr, len)\n\n            && (wp->flags & flags)) {\n\n            if (flags == BP_MEM_READ) {\n\n                wp->flags |= BP_WATCHPOINT_HIT_READ;\n\n            } else {\n\n                wp->flags |= BP_WATCHPOINT_HIT_WRITE;\n\n            }\n\n            wp->hitaddr = vaddr;\n\n            wp->hitattrs = attrs;\n\n            if (!cpu->watchpoint_hit) {\n\n                if (wp->flags & BP_CPU &&\n\n                    !cc->debug_check_watchpoint(cpu, wp)) {\n\n                    wp->flags &= ~BP_WATCHPOINT_HIT;\n\n                    continue;\n\n                }\n\n                cpu->watchpoint_hit = wp;\n\n\n\n                /* The tb_lock will be reset when cpu_loop_exit or\n\n                 * cpu_loop_exit_noexc longjmp back into the cpu_exec\n\n                 * main loop.\n\n                 */\n\n                tb_lock();\n\n                tb_check_watchpoint(cpu);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    cpu->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(cpu);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(cpu, pc, cs_base, cpu_flags, 1);\n\n                    cpu_loop_exit_noexc(cpu);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 720}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "DISAS_INSN(shift_im)\n\n{\n\n    TCGv reg;\n\n    int tmp;\n\n    TCGv shift;\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n\n\n    reg = DREG(insn, 0);\n\n    tmp = (insn >> 9) & 7;\n\n    if (tmp == 0)\n\n        tmp = 8;\n\n    shift = tcg_const_i32(tmp);\n\n    /* No need to flush flags becuse we know we will set C flag.  */\n\n    if (insn & 0x100) {\n\n        gen_helper_shl_cc(reg, cpu_env, reg, shift);\n\n    } else {\n\n        if (insn & 8) {\n\n            gen_helper_shr_cc(reg, cpu_env, reg, shift);\n\n        } else {\n\n            gen_helper_sar_cc(reg, cpu_env, reg, shift);\n\n        }\n\n    }\n\n}\n", "idx": 721}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static target_ulong h_protect(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong avpn = args[2];\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, pte_index)) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn)) {\n\n        return H_NOT_FOUND;\n\n    }\n\n\n\n    r &= ~(HPTE64_R_PP0 | HPTE64_R_PP | HPTE64_R_N |\n\n           HPTE64_R_KEY_HI | HPTE64_R_KEY_LO);\n\n    r |= (flags << 55) & HPTE64_R_PP0;\n\n    r |= (flags << 48) & HPTE64_R_KEY_HI;\n\n    r |= flags & (HPTE64_R_PP | HPTE64_R_N | HPTE64_R_KEY_LO);\n\n    rb = compute_tlbie_rb(v, r, pte_index);\n\n    ppc_hash64_store_hpte(cpu, pte_index,\n\n                          (v & ~HPTE64_V_VALID) | HPTE64_V_HPTE_DIRTY, 0);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    /* Don't need a memory barrier, due to qemu's global lock */\n\n    ppc_hash64_store_hpte(cpu, pte_index, v | HPTE64_V_HPTE_DIRTY, r);\n\n    return H_SUCCESS;\n\n}\n", "idx": 722}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (cpu->hyperv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (cpu->hyperv_time) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to get MSR 0x%\" PRIx32,\n\n                     (uint32_t)e->index);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 723}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_mig_unlock(void)\n\n{\n\n    qemu_mutex_unlock(&block_mig_state.lock);\n\n}\n", "idx": 724}
{"project": "qemu", "commit_id": "955939a2b51f72bea1c200b559ea39985df5a633", "target": 1, "func": "static void do_tb_flush(CPUState *cpu, void *data)\n\n{\n\n    unsigned tb_flush_req = (unsigned) (uintptr_t) data;\n\n\n\n    tb_lock();\n\n\n\n    /* If it's already been done on request of another CPU,\n\n     * just retry.\n\n     */\n\n    if (tcg_ctx.tb_ctx.tb_flush_count != tb_flush_req) {\n\n        goto done;\n\n    }\n\n\n\n#if defined(DEBUG_FLUSH)\n\n    printf(\"qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\\n\",\n\n           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),\n\n           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?\n\n           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /\n\n           tcg_ctx.tb_ctx.nb_tbs : 0);\n\n#endif\n\n    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)\n\n        > tcg_ctx.code_gen_buffer_size) {\n\n        cpu_abort(cpu, \"Internal error: code buffer overflow\\n\");\n\n    }\n\n\n\n    CPU_FOREACH(cpu) {\n\n        int i;\n\n\n\n        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {\n\n            atomic_set(&cpu->tb_jmp_cache[i], NULL);\n\n        }\n\n    }\n\n\n\n    tcg_ctx.tb_ctx.nb_tbs = 0;\n\n    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n\n    page_flush_tb();\n\n\n\n    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;\n\n    /* XXX: flush processor icache at this point if cache flush is\n\n       expensive */\n\n    atomic_mb_set(&tcg_ctx.tb_ctx.tb_flush_count,\n\n                  tcg_ctx.tb_ctx.tb_flush_count + 1);\n\n\n\ndone:\n\n    tb_unlock();\n\n}\n", "idx": 725}
{"project": "qemu", "commit_id": "6d56fc6cc372284a4571f09b361a9ccd99318103", "target": 1, "func": "static int decode_gusa(DisasContext *ctx, CPUSH4State *env, int *pmax_insns)\n\n{\n\n    uint16_t insns[5];\n\n    int ld_adr, ld_dst, ld_mop;\n\n    int op_dst, op_src, op_opc;\n\n    int mv_src, mt_dst, st_src, st_mop;\n\n    TCGv op_arg;\n\n\n\n    uint32_t pc = ctx->pc;\n\n    uint32_t pc_end = ctx->tb->cs_base;\n\n    int backup = sextract32(ctx->tbflags, GUSA_SHIFT, 8);\n\n    int max_insns = (pc_end - pc) / 2;\n\n    int i;\n\n\n\n    if (pc != pc_end + backup || max_insns < 2) {\n\n        /* This is a malformed gUSA region.  Don't do anything special,\n\n           since the interpreter is likely to get confused.  */\n\n        ctx->envflags &= ~GUSA_MASK;\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->tbflags & GUSA_EXCLUSIVE) {\n\n        /* Regardless of single-stepping or the end of the page,\n\n           we must complete execution of the gUSA region while\n\n           holding the exclusive lock.  */\n\n        *pmax_insns = max_insns;\n\n        return 0;\n\n    }\n\n\n\n    /* The state machine below will consume only a few insns.\n\n       If there are more than that in a region, fail now.  */\n\n    if (max_insns > ARRAY_SIZE(insns)) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read all of the insns for the region.  */\n\n    for (i = 0; i < max_insns; ++i) {\n\n        insns[i] = cpu_lduw_code(env, pc + i * 2);\n\n    }\n\n\n\n    ld_adr = ld_dst = ld_mop = -1;\n\n    mv_src = -1;\n\n    op_dst = op_src = op_opc = -1;\n\n    mt_dst = -1;\n\n    st_src = st_mop = -1;\n\n    TCGV_UNUSED(op_arg);\n\n    i = 0;\n\n\n\n#define NEXT_INSN \\\n\n    do { if (i >= max_insns) goto fail; ctx->opcode = insns[i++]; } while (0)\n\n\n\n    /*\n\n     * Expect a load to begin the region.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6000: /* mov.b @Rm,Rn */\n\n        ld_mop = MO_SB;\n\n        break;\n\n    case 0x6001: /* mov.w @Rm,Rn */\n\n        ld_mop = MO_TESW;\n\n        break;\n\n    case 0x6002: /* mov.l @Rm,Rn */\n\n        ld_mop = MO_TESL;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    ld_adr = B7_4;\n\n    ld_dst = B11_8;\n\n    if (ld_adr == ld_dst) {\n\n        goto fail;\n\n    }\n\n    /* Unless we see a mov, any two-operand operation must use ld_dst.  */\n\n    op_dst = ld_dst;\n\n\n\n    /*\n\n     * Expect an optional register move.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003: /* mov Rm,Rn */\n\n        /* Here we want to recognize ld_dst being saved for later consumtion,\n\n           or for another input register being copied so that ld_dst need not\n\n           be clobbered during the operation.  */\n\n        op_dst = B11_8;\n\n        mv_src = B7_4;\n\n        if (op_dst == ld_dst) {\n\n            /* Overwriting the load output.  */\n\n            goto fail;\n\n        }\n\n        if (mv_src != ld_dst) {\n\n            /* Copying a new input; constrain op_src to match the load.  */\n\n            op_src = ld_dst;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Put back and re-examine as operation.  */\n\n        --i;\n\n    }\n\n\n\n    /*\n\n     * Expect the operation.\n\n     */\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x300c: /* add Rm,Rn */\n\n        op_opc = INDEX_op_add_i32;\n\n        goto do_reg_op;\n\n    case 0x2009: /* and Rm,Rn */\n\n        op_opc = INDEX_op_and_i32;\n\n        goto do_reg_op;\n\n    case 0x200a: /* xor Rm,Rn */\n\n        op_opc = INDEX_op_xor_i32;\n\n        goto do_reg_op;\n\n    case 0x200b: /* or Rm,Rn */\n\n        op_opc = INDEX_op_or_i32;\n\n    do_reg_op:\n\n        /* The operation register should be as expected, and the\n\n           other input cannot depend on the load.  */\n\n        if (op_dst != B11_8) {\n\n            goto fail;\n\n        }\n\n        if (op_src < 0) {\n\n            /* Unconstrainted input.  */\n\n            op_src = B7_4;\n\n        } else if (op_src == B7_4) {\n\n            /* Constrained input matched load.  All operations are\n\n               commutative; \"swap\" them by \"moving\" the load output\n\n               to the (implicit) first argument and the move source\n\n               to the (explicit) second argument.  */\n\n            op_src = mv_src;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        op_arg = REG(op_src);\n\n        break;\n\n\n\n    case 0x6007: /* not Rm,Rn */\n\n        if (ld_dst != B7_4 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_dst = B11_8;\n\n        op_opc = INDEX_op_xor_i32;\n\n        op_arg = tcg_const_i32(-1);\n\n        break;\n\n\n\n    case 0x7000 ... 0x700f: /* add #imm,Rn */\n\n        if (op_dst != B11_8 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_add_i32;\n\n        op_arg = tcg_const_i32(B7_0s);\n\n        break;\n\n\n\n    case 0x3000: /* cmp/eq Rm,Rn */\n\n        /* Looking for the middle of a compare-and-swap sequence,\n\n           beginning with the compare.  Operands can be either order,\n\n           but with only one overlapping the load.  */\n\n        if ((ld_dst == B11_8) + (ld_dst == B7_4) != 1 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_setcond_i32;  /* placeholder */\n\n        op_src = (ld_dst == B11_8 ? B7_4 : B11_8);\n\n        op_arg = REG(op_src);\n\n\n\n        NEXT_INSN;\n\n        switch (ctx->opcode & 0xff00) {\n\n        case 0x8b00: /* bf label */\n\n        case 0x8f00: /* bf/s label */\n\n            if (pc + (i + 1 + B7_0s) * 2 != pc_end) {\n\n                goto fail;\n\n            }\n\n            if ((ctx->opcode & 0xff00) == 0x8b00) { /* bf label */\n\n                break;\n\n            }\n\n            /* We're looking to unconditionally modify Rn with the\n\n               result of the comparison, within the delay slot of\n\n               the branch.  This is used by older gcc.  */\n\n            NEXT_INSN;\n\n            if ((ctx->opcode & 0xf0ff) == 0x0029) { /* movt Rn */\n\n                mt_dst = B11_8;\n\n            } else {\n\n                goto fail;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case 0x2008: /* tst Rm,Rn */\n\n        /* Looking for a compare-and-swap against zero.  */\n\n        if (ld_dst != B11_8 || ld_dst != B7_4 || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        op_opc = INDEX_op_setcond_i32;\n\n        op_arg = tcg_const_i32(0);\n\n\n\n        NEXT_INSN;\n\n        if ((ctx->opcode & 0xff00) != 0x8900 /* bt label */\n\n            || pc + (i + 1 + B7_0s) * 2 != pc_end) {\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        /* Put back and re-examine as store.  */\n\n        --i;\n\n    }\n\n\n\n    /*\n\n     * Expect the store.\n\n     */\n\n    /* The store must be the last insn.  */\n\n    if (i != max_insns - 1) {\n\n        goto fail;\n\n    }\n\n    NEXT_INSN;\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x2000: /* mov.b Rm,@Rn */\n\n        st_mop = MO_UB;\n\n        break;\n\n    case 0x2001: /* mov.w Rm,@Rn */\n\n        st_mop = MO_UW;\n\n        break;\n\n    case 0x2002: /* mov.l Rm,@Rn */\n\n        st_mop = MO_UL;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    /* The store must match the load.  */\n\n    if (ld_adr != B11_8 || st_mop != (ld_mop & MO_SIZE)) {\n\n        goto fail;\n\n    }\n\n    st_src = B7_4;\n\n\n\n#undef NEXT_INSN\n\n\n\n    /*\n\n     * Emit the operation.\n\n     */\n\n    tcg_gen_insn_start(pc, ctx->envflags);\n\n    switch (op_opc) {\n\n    case -1:\n\n        /* No operation found.  Look for exchange pattern.  */\n\n        if (st_src == ld_dst || mv_src >= 0) {\n\n            goto fail;\n\n        }\n\n        tcg_gen_atomic_xchg_i32(REG(ld_dst), REG(ld_adr), REG(st_src),\n\n                                ctx->memidx, ld_mop);\n\n        break;\n\n\n\n    case INDEX_op_add_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst && st_mop == MO_UL) {\n\n            tcg_gen_atomic_add_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_add_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            if (op_dst != ld_dst) {\n\n                /* Note that mop sizes < 4 cannot use add_fetch\n\n                   because it won't carry into the higher bits.  */\n\n                tcg_gen_add_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_and_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_and_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_and_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_and_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_or_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_or_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                        op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_or_i32(REG(ld_dst), REG(ld_adr),\n\n                                        op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_or_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_xor_i32:\n\n        if (op_dst != st_src) {\n\n            goto fail;\n\n        }\n\n        if (op_dst == ld_dst) {\n\n            tcg_gen_atomic_xor_fetch_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n        } else {\n\n            tcg_gen_atomic_fetch_xor_i32(REG(ld_dst), REG(ld_adr),\n\n                                         op_arg, ctx->memidx, ld_mop);\n\n            tcg_gen_xor_i32(REG(op_dst), REG(ld_dst), op_arg);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_setcond_i32:\n\n        if (st_src == ld_dst) {\n\n            goto fail;\n\n        }\n\n        tcg_gen_atomic_cmpxchg_i32(REG(ld_dst), REG(ld_adr), op_arg,\n\n                                   REG(st_src), ctx->memidx, ld_mop);\n\n        tcg_gen_setcond_i32(TCG_COND_EQ, cpu_sr_t, REG(ld_dst), op_arg);\n\n        if (mt_dst >= 0) {\n\n            tcg_gen_mov_i32(REG(mt_dst), cpu_sr_t);\n\n        }\n\n        break;\n\n\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* If op_src is not a valid register, then op_arg was a constant.  */\n\n    if (op_src < 0) {\n\n        tcg_temp_free_i32(op_arg);\n\n    }\n\n\n\n    /* The entire region has been translated.  */\n\n    ctx->envflags &= ~GUSA_MASK;\n\n    ctx->pc = pc_end;\n\n    return max_insns;\n\n\n\n fail:\n\n    qemu_log_mask(LOG_UNIMP, \"Unrecognized gUSA sequence %08x-%08x\\n\",\n\n                  pc, pc_end);\n\n\n\n    /* Restart with the EXCLUSIVE bit set, within a TB run via\n\n       cpu_exec_step_atomic holding the exclusive lock.  */\n\n    tcg_gen_insn_start(pc, ctx->envflags);\n\n    ctx->envflags |= GUSA_EXCLUSIVE;\n\n    gen_save_cpu_state(ctx, false);\n\n    gen_helper_exclusive(cpu_env);\n\n    ctx->bstate = BS_EXCP;\n\n\n\n    /* We're not executing an instruction, but we must report one for the\n\n       purposes of accounting within the TB.  We might as well report the\n\n       entire region consumed via ctx->pc so that it's immediately available\n\n       in the disassembly dump.  */\n\n    ctx->pc = pc_end;\n\n    return 1;\n\n}\n", "idx": 726}
{"project": "FFmpeg", "commit_id": "3d179edf6d2a987e7eb134eea541954338a19add", "target": 1, "func": "static int yop_read_header(AVFormatContext *s)\n\n{\n\n    YopDecContext *yop = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n\n\n    AVCodecContext *audio_dec, *video_dec;\n\n    AVStream *audio_stream, *video_stream;\n\n\n\n    int frame_rate, ret;\n\n\n\n    audio_stream = avformat_new_stream(s, NULL);\n\n    video_stream = avformat_new_stream(s, NULL);\n\n\n\n\n\n    // Extra data that will be passed to the decoder\n\n    video_stream->codec->extradata_size = 8;\n\n\n\n    video_stream->codec->extradata = av_mallocz(video_stream->codec->extradata_size +\n\n                                                FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if (!video_stream->codec->extradata)\n\n\n\n\n    // Audio\n\n    audio_dec               = audio_stream->codec;\n\n    audio_dec->codec_type   = AVMEDIA_TYPE_AUDIO;\n\n    audio_dec->codec_id     = AV_CODEC_ID_ADPCM_IMA_APC;\n\n    audio_dec->channels     = 1;\n\n    audio_dec->sample_rate  = 22050;\n\n\n\n    // Video\n\n    video_dec               = video_stream->codec;\n\n    video_dec->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n    video_dec->codec_id     = AV_CODEC_ID_YOP;\n\n\n\n    avio_skip(pb, 6);\n\n\n\n    frame_rate              = avio_r8(pb);\n\n    yop->frame_size         = avio_r8(pb) * 2048;\n\n    video_dec->width        = avio_rl16(pb);\n\n    video_dec->height       = avio_rl16(pb);\n\n\n\n    video_stream->sample_aspect_ratio = (AVRational){1, 2};\n\n\n\n    ret = avio_read(pb, video_dec->extradata, 8);\n\n    if (ret < 8)\n\n        return ret < 0 ? ret : AVERROR_EOF;\n\n\n\n    yop->palette_size       = video_dec->extradata[0] * 3 + 4;\n\n    yop->audio_block_length = AV_RL16(video_dec->extradata + 6);\n\n\n\n    // 1840 samples per frame, 1 nibble per sample; hence 1840/2 = 920\n\n    if (yop->audio_block_length < 920 ||\n\n        yop->audio_block_length + yop->palette_size >= yop->frame_size) {\n\n        av_log(s, AV_LOG_ERROR, \"YOP has invalid header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    avio_seek(pb, 2048, SEEK_SET);\n\n\n\n    avpriv_set_pts_info(video_stream, 32, 1, frame_rate);\n\n\n\n    return 0;\n\n}", "idx": 727}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "int64_t bdrv_get_block_status_above(BlockDriverState *bs,\n\n                                    BlockDriverState *base,\n\n                                    int64_t sector_num,\n\n                                    int nb_sectors, int *pnum,\n\n                                    BlockDriverState **file)\n\n{\n\n    Coroutine *co;\n\n    BdrvCoGetBlockStatusData data = {\n\n        .bs = bs,\n\n        .base = base,\n\n        .file = file,\n\n        .sector_num = sector_num,\n\n        .nb_sectors = nb_sectors,\n\n        .pnum = pnum,\n\n        .done = false,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_get_block_status_above_co_entry(&data);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_get_block_status_above_co_entry);\n\n        qemu_coroutine_enter(co, &data);\n\n        while (!data.done) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n    return data.ret;\n\n}\n", "idx": 728}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_string_metadata(int count, const char *name,\n\n                               TiffContext *s)\n\n{\n\n    char *value;\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) < count || count < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    value = av_malloc(count + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n\n\n    bytestream2_get_bufferu(&s->gb, value, count);\n\n    value[count] = 0;\n\n\n\n    av_dict_set(avpriv_frame_get_metadatap(&s->picture), name, value, AV_DICT_DONT_STRDUP_VAL);\n\n    return 0;\n\n}\n", "idx": 730}
{"project": "qemu", "commit_id": "04920fc0faa4760f9c4fc0e73b992b768099be70", "target": 1, "func": "static void pc_q35_init_1_6(QEMUMachineInitArgs *args)\n\n{\n\n    has_pci_info = false;\n\n\n    pc_q35_init(args);\n\n}", "idx": 731}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static void dvbsub_parse_clut_segment(AVCodecContext *avctx,\n\n                                        const uint8_t *buf, int buf_size)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    int i, clut_id;\n\n    DVBSubCLUT *clut;\n\n    int entry_id, depth , full_range;\n\n    int y, cr, cb, alpha;\n\n    int r, g, b, r_add, g_add, b_add;\n\n\n\n    av_dlog(avctx, \"DVB clut packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    clut_id = *buf++;\n\n    buf += 1;\n\n\n\n    clut = get_clut(ctx, clut_id);\n\n\n\n    if (!clut) {\n\n        clut = av_malloc(sizeof(DVBSubCLUT));\n\n\n\n        memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n\n\n\n        clut->id = clut_id;\n\n\n\n        clut->next = ctx->clut_list;\n\n        ctx->clut_list = clut;\n\n    }\n\n\n\n    while (buf + 4 < buf_end) {\n\n        entry_id = *buf++;\n\n\n\n        depth = (*buf) & 0xe0;\n\n\n\n        if (depth == 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid clut depth 0x%x!\\n\", *buf);\n\n            return;\n\n        }\n\n\n\n        full_range = (*buf++) & 1;\n\n\n\n        if (full_range) {\n\n            y = *buf++;\n\n            cr = *buf++;\n\n            cb = *buf++;\n\n            alpha = *buf++;\n\n        } else {\n\n            y = buf[0] & 0xfc;\n\n            cr = (((buf[0] & 3) << 2) | ((buf[1] >> 6) & 3)) << 4;\n\n            cb = (buf[1] << 2) & 0xf0;\n\n            alpha = (buf[1] << 6) & 0xc0;\n\n\n\n            buf += 2;\n\n        }\n\n\n\n        if (y == 0)\n\n            alpha = 0xff;\n\n\n\n        YUV_TO_RGB1_CCIR(cb, cr);\n\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n\n\n\n        av_dlog(avctx, \"clut %d := (%d,%d,%d,%d)\\n\", entry_id, r, g, b, alpha);\n\n\n\n        if (depth & 0x80)\n\n            clut->clut4[entry_id] = RGBA(r,g,b,255 - alpha);\n\n        if (depth & 0x40)\n\n            clut->clut16[entry_id] = RGBA(r,g,b,255 - alpha);\n\n        if (depth & 0x20)\n\n            clut->clut256[entry_id] = RGBA(r,g,b,255 - alpha);\n\n    }\n\n}\n", "idx": 732}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_l0t_8x8_msa(uint8_t *src, int32_t stride)\n\n{\n\n    uint8_t lp_cnt;\n\n    uint32_t src0, src1, src2 = 0;\n\n    uint32_t out0, out1, out2;\n\n    v16u8 src_top;\n\n    v8u16 add;\n\n    v4u32 sum;\n\n\n\n    src_top = LD_UB(src - stride);\n\n    add = __msa_hadd_u_h(src_top, src_top);\n\n    sum = __msa_hadd_u_w(add, add);\n\n    src0 = __msa_copy_u_w((v4i32) sum, 0);\n\n    src1 = __msa_copy_u_w((v4i32) sum, 1);\n\n\n\n    for (lp_cnt = 0; lp_cnt < 4; lp_cnt++) {\n\n        src2 += src[lp_cnt * stride - 1];\n\n    }\n\n    src2 = (src0 + src2 + 4) >> 3;\n\n    src0 = (src0 + 2) >> 2;\n\n    src1 = (src1 + 2) >> 2;\n\n    out0 = src0 * 0x01010101;\n\n    out1 = src1 * 0x01010101;\n\n    out2 = src2 * 0x01010101;\n\n\n\n    for (lp_cnt = 4; lp_cnt--;) {\n\n        SW(out2, src);\n\n        SW(out1, src + 4);\n\n        SW(out0, src + stride * 4);\n\n        SW(out1, src + stride * 4 + 4);\n\n        src += stride;\n\n    }\n\n}\n", "idx": 733}
{"project": "FFmpeg", "commit_id": "21de6ba5c12fbdd2ad86e5faf8aa12be8f5f6408", "target": 0, "func": "static int write_streamheader(AVFormatContext *avctx, AVIOContext *bc, AVStream *st, int i){\n\n    NUTContext *nut = avctx->priv_data;\n\n    AVCodecContext *codec = st->codec;\n\n    unsigned codec_tag = av_codec_get_tag(ff_nut_codec_tags, codec->codec_id);\n\n\n\n    ff_put_v(bc, i);\n\n    switch(codec->codec_type){\n\n    case AVMEDIA_TYPE_VIDEO: ff_put_v(bc, 0); break;\n\n    case AVMEDIA_TYPE_AUDIO: ff_put_v(bc, 1); break;\n\n    case AVMEDIA_TYPE_SUBTITLE: ff_put_v(bc, 2); break;\n\n    default              : ff_put_v(bc, 3); break;\n\n    }\n\n    ff_put_v(bc, 4);\n\n\n\n    if (!codec_tag)\n\n        codec_tag = codec->codec_tag;\n\n\n\n    if (codec_tag) {\n\n        avio_wl32(bc, codec_tag);\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"No codec tag defined for stream %d\\n\", i);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ff_put_v(bc, nut->stream[i].time_base - nut->time_base);\n\n    ff_put_v(bc, nut->stream[i].msb_pts_shift);\n\n    ff_put_v(bc, nut->stream[i].max_pts_distance);\n\n    ff_put_v(bc, codec->has_b_frames);\n\n    avio_w8(bc, 0); /* flags: 0x1 - fixed_fps, 0x2 - index_present */\n\n\n\n    ff_put_v(bc, codec->extradata_size);\n\n    avio_write(bc, codec->extradata, codec->extradata_size);\n\n\n\n    switch(codec->codec_type){\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        ff_put_v(bc, codec->sample_rate);\n\n        ff_put_v(bc, 1);\n\n        ff_put_v(bc, codec->channels);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        ff_put_v(bc, codec->width);\n\n        ff_put_v(bc, codec->height);\n\n\n\n        if(st->sample_aspect_ratio.num<=0 || st->sample_aspect_ratio.den<=0){\n\n            ff_put_v(bc, 0);\n\n            ff_put_v(bc, 0);\n\n        }else{\n\n            ff_put_v(bc, st->sample_aspect_ratio.num);\n\n            ff_put_v(bc, st->sample_aspect_ratio.den);\n\n        }\n\n        ff_put_v(bc, 0); /* csp type -- unknown */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 735}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "SYNTH_FILTER_FUNC(sse2)\n\nSYNTH_FILTER_FUNC(avx)\n\nSYNTH_FILTER_FUNC(fma3)\n\n#endif /* HAVE_YASM */\n\n\n\nav_cold void ff_synth_filter_init_x86(SynthFilterContext *s)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_avx;\n\n    }\n\n    if (EXTERNAL_FMA3(cpu_flags)) {\n\n        s->synth_filter_float = synth_filter_fma3;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 736}
{"project": "qemu", "commit_id": "e49ab19fcaa617ad6cdfe1ac401327326b6a2552", "target": 1, "func": "static BlockDriverAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,\n\n        unsigned long int req, void *buf,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    struct iscsi_data data;\n\n    IscsiAIOCB *acb;\n\n\n\n    assert(req == SG_IO);\n\n\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n\n\n    acb->iscsilun = iscsilun;\n\n    acb->canceled    = 0;\n\n    acb->bh          = NULL;\n\n    acb->status      = -EINPROGRESS;\n\n    acb->buf         = NULL;\n\n    acb->ioh         = buf;\n\n\n\n    acb->task = malloc(sizeof(struct scsi_task));\n\n    if (acb->task == NULL) {\n\n        error_report(\"iSCSI: Failed to allocate task for scsi command. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    memset(acb->task, 0, sizeof(struct scsi_task));\n\n\n\n    switch (acb->ioh->dxfer_direction) {\n\n    case SG_DXFER_TO_DEV:\n\n        acb->task->xfer_dir = SCSI_XFER_WRITE;\n\n        break;\n\n    case SG_DXFER_FROM_DEV:\n\n        acb->task->xfer_dir = SCSI_XFER_READ;\n\n        break;\n\n    default:\n\n        acb->task->xfer_dir = SCSI_XFER_NONE;\n\n        break;\n\n    }\n\n\n\n    acb->task->cdb_size = acb->ioh->cmd_len;\n\n    memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);\n\n    acb->task->expxferlen = acb->ioh->dxfer_len;\n\n\n\n    data.size = 0;\n\n    if (acb->task->xfer_dir == SCSI_XFER_WRITE) {\n\n        if (acb->ioh->iovec_count == 0) {\n\n            data.data = acb->ioh->dxferp;\n\n            data.size = acb->ioh->dxfer_len;\n\n        } else {\n\n#if defined(LIBISCSI_FEATURE_IOVECTOR)\n\n            scsi_task_set_iov_out(acb->task,\n\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n\n                                 acb->ioh->iovec_count);\n\n#else\n\n            struct iovec *iov = (struct iovec *)acb->ioh->dxferp;\n\n\n\n            acb->buf = g_malloc(acb->ioh->dxfer_len);\n\n            data.data = acb->buf;\n\n            data.size = iov_to_buf(iov, acb->ioh->iovec_count, 0,\n\n                                   acb->buf, acb->ioh->dxfer_len);\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n\n                                 iscsi_aio_ioctl_cb,\n\n                                 (data.size > 0) ? &data : NULL,\n\n                                 acb) != 0) {\n\n        scsi_free_scsi_task(acb->task);\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n\n\n    /* tell libiscsi to read straight into the buffer we got from ioctl */\n\n    if (acb->task->xfer_dir == SCSI_XFER_READ) {\n\n        if (acb->ioh->iovec_count == 0) {\n\n            scsi_task_add_data_in_buffer(acb->task,\n\n                                         acb->ioh->dxfer_len,\n\n                                         acb->ioh->dxferp);\n\n        } else {\n\n#if defined(LIBISCSI_FEATURE_IOVECTOR)\n\n            scsi_task_set_iov_in(acb->task,\n\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n\n                                 acb->ioh->iovec_count);\n\n#else\n\n            int i;\n\n            for (i = 0; i < acb->ioh->iovec_count; i++) {\n\n                struct iovec *iov = (struct iovec *)acb->ioh->dxferp;\n\n\n\n                scsi_task_add_data_in_buffer(acb->task,\n\n                    iov[i].iov_len,\n\n                    iov[i].iov_base);\n\n            }\n\n#endif\n\n        }\n\n    }\n\n\n\n    iscsi_set_events(iscsilun);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 737}
{"project": "qemu", "commit_id": "c3543fb5fe4520f03dd4fef04fab7745eeca1c96", "target": 1, "func": "static void esp_pci_dma_memory_rw(PCIESPState *pci, uint8_t *buf, int len,\n\n                                  DMADirection dir)\n\n{\n\n    dma_addr_t addr;\n\n    DMADirection expected_dir;\n\n\n\n    if (pci->dma_regs[DMA_CMD] & DMA_CMD_DIR) {\n\n        expected_dir = DMA_DIRECTION_FROM_DEVICE;\n\n    } else {\n\n        expected_dir = DMA_DIRECTION_TO_DEVICE;\n\n    }\n\n\n\n    if (dir != expected_dir) {\n\n        trace_esp_pci_error_invalid_dma_direction();\n\n        return;\n\n    }\n\n\n\n    if (pci->dma_regs[DMA_STAT] & DMA_CMD_MDL) {\n\n        qemu_log_mask(LOG_UNIMP, \"am53c974: MDL transfer not implemented\\n\");\n\n    }\n\n\n\n    addr = pci->dma_regs[DMA_SPA];\n\n    if (pci->dma_regs[DMA_WBC] < len) {\n\n        len = pci->dma_regs[DMA_WBC];\n\n    }\n\n\n\n    pci_dma_rw(PCI_DEVICE(pci), addr, buf, len, dir);\n\n\n\n    /* update status registers */\n\n    pci->dma_regs[DMA_WBC] -= len;\n\n    pci->dma_regs[DMA_WAC] += len;\n\n\n\n}", "idx": 738}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_fflush(QEMUFile *f)\n\n{\n\n    ssize_t ret = 0;\n\n\n\n    if (!qemu_file_is_writable(f)) {\n\n        return;\n\n    }\n\n\n\n    if (f->ops->writev_buffer) {\n\n        if (f->iovcnt > 0) {\n\n            ret = f->ops->writev_buffer(f->opaque, f->iov, f->iovcnt, f->pos);\n\n        }\n\n    } else {\n\n        if (f->buf_index > 0) {\n\n            ret = f->ops->put_buffer(f->opaque, f->buf, f->pos, f->buf_index);\n\n        }\n\n    }\n\n    if (ret >= 0) {\n\n        f->pos += ret;\n\n    }\n\n    f->buf_index = 0;\n\n    f->iovcnt = 0;\n\n    if (ret < 0) {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 739}
{"project": "FFmpeg", "commit_id": "eca2a49716ae1f42804dd3545da2f740edf03250", "target": 1, "func": "int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)\n\n{\n\n    int64_t offset1;\n\n    int64_t pos;\n\n    int force = whence & AVSEEK_FORCE;\n\n    int buffer_size;\n\n    int short_seek;\n\n    whence &= ~AVSEEK_FORCE;\n\n\n\n    if(!s)\n\n\n\n\n    buffer_size = s->buf_end - s->buffer;\n\n    // pos is the absolute position that the beginning of s->buffer corresponds to in the file\n\n    pos = s->pos - (s->write_flag ? 0 : buffer_size);\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n\n\n        offset += offset1;\n\n    }\n\n    if (offset < 0)\n\n\n\n\n    if (s->short_seek_get) {\n\n        short_seek = s->short_seek_get(s->opaque);\n\n        /* fallback to default short seek */\n\n        if (short_seek <= 0)\n\n            short_seek = s->short_seek_threshold;\n\n    } else\n\n        short_seek = s->short_seek_threshold;\n\n\n\n    offset1 = offset - pos; // \"offset1\" is the relative offset from the beginning of s->buffer\n\n    s->buf_ptr_max = FFMAX(s->buf_ptr_max, s->buf_ptr);\n\n    if ((!s->direct || !s->seek) &&\n\n        offset1 >= 0 && offset1 <= (s->write_flag ? s->buf_ptr_max - s->buffer : buffer_size)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else if ((!(s->seekable & AVIO_SEEKABLE_NORMAL) ||\n\n               offset1 <= buffer_size + short_seek) &&\n\n               !s->write_flag && offset1 >= 0 &&\n\n               (!s->direct || !s->seek) &&\n\n              (whence != SEEK_END || force)) {\n\n        while(s->pos < offset && !s->eof_reached)\n\n            fill_buffer(s);\n\n        if (s->eof_reached)\n\n            return AVERROR_EOF;\n\n        s->buf_ptr = s->buf_end - (s->pos - offset);\n\n    } else if(!s->write_flag && offset1 < 0 && -offset1 < buffer_size>>1 && s->seek && offset > 0) {\n\n        int64_t res;\n\n\n\n        pos -= FFMIN(buffer_size>>1, pos);\n\n        if ((res = s->seek(s->opaque, pos, SEEK_SET)) < 0)\n\n            return res;\n\n        s->buf_end =\n\n        s->buf_ptr = s->buffer;\n\n        s->pos = pos;\n\n        s->eof_reached = 0;\n\n        fill_buffer(s);\n\n        return avio_seek(s, offset, SEEK_SET | force);\n\n    } else {\n\n        int64_t res;\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n        }\n\n        if (!s->seek)\n\n            return AVERROR(EPIPE);\n\n        if ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\n\n            return res;\n\n        s->seek_count ++;\n\n        if (!s->write_flag)\n\n            s->buf_end = s->buffer;\n\n        s->buf_ptr = s->buf_ptr_max = s->buffer;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}", "idx": 741}
{"project": "qemu", "commit_id": "49dd946bb5419681c8668b09a6d10f42bc707b78", "target": 1, "func": "static void coroutine_fn v9fs_rename(void *opaque)\n\n{\n\n    int32_t fid;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    V9fsString name;\n\n    int32_t newdirfid;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    v9fs_string_init(&name);\n\n    err = pdu_unmarshal(pdu, offset, \"dds\", &fid, &newdirfid, &name);\n\n    if (err < 0) {\n\n        goto out_nofid;\n\n    }\n\n\n\n    if (name_is_illegal(name.data)) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n\n        err = -EISDIR;\n\n        goto out_nofid;\n\n    }\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    BUG_ON(fidp->fid_type != P9_FID_NONE);\n\n    /* if fs driver is not path based, return EOPNOTSUPP */\n\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n\n        err = -EOPNOTSUPP;\n\n        goto out;\n\n    }\n\n    v9fs_path_write_lock(s);\n\n    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);\n\n    v9fs_path_unlock(s);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    pdu_complete(pdu, err);\n\n    v9fs_string_free(&name);\n\n}\n", "idx": 742}
{"project": "FFmpeg", "commit_id": "3a6ded7cfcb33e06ade98c5791eae06453f65668", "target": 1, "func": "AVVDPAUContext *av_vdpau_alloc_context(void)\n\n{\n\n    return av_mallocz(sizeof(AVVDPAUContext));\n\n}\n", "idx": 743}
{"project": "FFmpeg", "commit_id": "cea3a63ba3d89d8403eef008f7a7c54d645cff70", "target": 1, "func": "static AVBufferRef *pool_alloc_buffer(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *buf;\n\n    AVBufferRef     *ret;\n\n\n\n    ret = pool->alloc(pool->size);\n\n    if (!ret)\n\n        return NULL;\n\n\n\n    buf = av_mallocz(sizeof(*buf));\n\n    if (!buf) {\n\n        av_buffer_unref(&ret);\n\n        return NULL;\n\n    }\n\n\n\n    buf->data   = ret->buffer->data;\n\n    buf->opaque = ret->buffer->opaque;\n\n    buf->free   = ret->buffer->free;\n\n    buf->pool   = pool;\n\n\n\n    ret->buffer->opaque = buf;\n\n    ret->buffer->free   = pool_release_buffer;\n\n\n\n    avpriv_atomic_int_add_and_fetch(&pool->refcount, 1);\n\n\n\n\n    return ret;\n\n}", "idx": 744}
{"project": "FFmpeg", "commit_id": "1677155df8ee2dbf6c99738b289e27c2237506bd", "target": 1, "func": "static void compute_frame_duration(int *pnum, int *pden, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        if(st->time_base.num*1000 > st->time_base.den){\n\n            *pnum = st->time_base.num;\n\n            *pden = st->time_base.den;\n\n        }else if(st->codec.time_base.num*1000 > st->codec.time_base.den){\n\n            *pnum = st->codec.time_base.num;\n\n            *pden = st->codec.time_base.den;\n\n            if (pc && pc->repeat_pict) {\n\n                *pden *= 2;\n\n                *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 745}
{"project": "qemu", "commit_id": "9ac228e02cf16202547e7025ef300369e0db7781", "target": 1, "func": "static int vdi_check(BlockDriverState *bs)\n\n{\n\n    /* TODO: additional checks possible. */\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    int n_errors = 0;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    bmap = qemu_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    /* Check block map and value of blocks_allocated. */\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (bmap_entry != VDI_UNALLOCATED) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (bmap[bmap_entry] == VDI_UNALLOCATED) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                n_errors++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        n_errors++;\n\n    }\n\n\n\n    qemu_free(bmap);\n\n\n\n    return n_errors;\n\n}\n", "idx": 746}
{"project": "qemu", "commit_id": "5c3234c6c037943bd4c2d643a1b8cc35f563dbdb", "target": 1, "func": "static void submit_pdu(V9fsState *s, V9fsPDU *pdu)\n\n{\n\n    pdu_handler_t *handler;\n\n\n\n    if (debug_9p_pdu) {\n\n        pprint_pdu(pdu);\n\n    }\n\n\n\n    BUG_ON(pdu->id >= ARRAY_SIZE(pdu_handlers));\n\n\n\n    handler = pdu_handlers[pdu->id];\n\n    BUG_ON(handler == NULL);\n\n\n\n    handler(s, pdu);\n\n}\n", "idx": 749}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addqv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 += op2;\n\n    if (unlikely((tmp ^ op2 ^ (-1ULL)) & (tmp ^ op1) & (1ULL << 63))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 750}
{"project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "target": 1, "func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\n\t\t\t\t\t     unsigned mode,\n\n\t\t\t\t\t     unsigned offset,\n\n\t\t\t\t\t     uint32_t mem_value)\n\n{\n\n    int x;\n\n    unsigned val = mem_value;\n\n    uint8_t *dst;\n\n\n\n    dst = s->vram_ptr + offset;\n\n    for (x = 0; x < 8; x++) {\n\n\tif (val & 0x80) {\n\n\t    *dst = s->cirrus_shadow_gr1;\n\n\t} else if (mode == 5) {\n\n\t    *dst = s->cirrus_shadow_gr0;\n\n\t}\n\n\tval <<= 1;\n\n\tdst++;\n\n    }\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n\n}\n", "idx": 751}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "void translator_loop(const TranslatorOps *ops, DisasContextBase *db,\n\n                     CPUState *cpu, TranslationBlock *tb)\n\n{\n\n    int max_insns;\n\n\n\n    /* Initialize DisasContext */\n\n    db->tb = tb;\n\n    db->pc_first = tb->pc;\n\n    db->pc_next = db->pc_first;\n\n    db->is_jmp = DISAS_NEXT;\n\n    db->num_insns = 0;\n\n    db->singlestep_enabled = cpu->singlestep_enabled;\n\n\n\n    /* Instruction counting */\n\n    max_insns = db->tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n    if (db->singlestep_enabled || singlestep) {\n\n        max_insns = 1;\n\n    }\n\n\n\n    max_insns = ops->init_disas_context(db, cpu, max_insns);\n\n    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n    /* Reset the temp count so that we can identify leaks */\n\n    tcg_clear_temp_count();\n\n\n\n    /* Start translating.  */\n\n    gen_tb_start(db->tb);\n\n    ops->tb_start(db, cpu);\n\n    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n    while (true) {\n\n        db->num_insns++;\n\n        ops->insn_start(db, cpu);\n\n        tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */\n\n\n\n        /* Pass breakpoint hits to target for further processing */\n\n        if (unlikely(!QTAILQ_EMPTY(&cpu->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n                if (bp->pc == db->pc_next) {\n\n                    if (ops->breakpoint_check(db, cpu, bp)) {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            /* The breakpoint_check hook may use DISAS_TOO_MANY to indicate\n\n               that only one more instruction is to be executed.  Otherwise\n\n               it should use DISAS_NORETURN when generating an exception,\n\n               but may use a DISAS_TARGET_* value for Something Else.  */\n\n            if (db->is_jmp > DISAS_TOO_MANY) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* Disassemble one instruction.  The translate_insn hook should\n\n           update db->pc_next and db->is_jmp to indicate what should be\n\n           done next -- either exiting this loop or locate the start of\n\n           the next instruction.  */\n\n        if (db->num_insns == max_insns && (db->tb->cflags & CF_LAST_IO)) {\n\n            /* Accept I/O on the last instruction.  */\n\n            gen_io_start();\n\n            ops->translate_insn(db, cpu);\n\n            gen_io_end();\n\n        } else {\n\n            ops->translate_insn(db, cpu);\n\n        }\n\n\n\n        /* Stop translation if translate_insn so indicated.  */\n\n        if (db->is_jmp != DISAS_NEXT) {\n\n            break;\n\n        }\n\n\n\n        /* Stop translation if the output buffer is full,\n\n           or we have executed all of the allowed instructions.  */\n\n        if (tcg_op_buf_full() || db->num_insns >= max_insns) {\n\n            db->is_jmp = DISAS_TOO_MANY;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Emit code to exit the TB, as indicated by db->is_jmp.  */\n\n    ops->tb_stop(db, cpu);\n\n    gen_tb_end(db->tb, db->num_insns);\n\n\n\n    /* The disas_log hook may use these values rather than recompute.  */\n\n    db->tb->size = db->pc_next - db->pc_first;\n\n    db->tb->icount = db->num_insns;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n\n        && qemu_log_in_addr_range(db->pc_first)) {\n\n        qemu_log_lock();\n\n        qemu_log(\"----------------\\n\");\n\n        ops->disas_log(db, cpu);\n\n        qemu_log(\"\\n\");\n\n        qemu_log_unlock();\n\n    }\n\n#endif\n\n}\n", "idx": 752}
{"project": "FFmpeg", "commit_id": "631fa0432be8968e0fd372595749b918224946df", "target": 1, "func": "static int load_apply_palette(FFFrameSync *fs)\n\n{\n\n    AVFilterContext *ctx = fs->parent;\n\n    AVFilterLink *inlink = ctx->inputs[0];\n\n    PaletteUseContext *s = ctx->priv;\n\n    AVFrame *master, *second, *out = NULL;\n\n    int ret;\n\n\n\n    // writable for error diffusal dithering\n\n    ret = ff_framesync_dualinput_get_writable(fs, &master, &second);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (!master || !second) {\n\n        ret = AVERROR_BUG;\n\n        goto error;\n\n    }\n\n    if (!s->palette_loaded) {\n\n        load_palette(s, second);\n\n    }\n\n    ret = apply_palette(inlink, master, &out);\n\n    if (ret < 0)\n\n        goto error;\n\n    return ff_filter_frame(ctx->outputs[0], out);\n\n\n\nerror:\n\n    av_frame_free(&master);\n\n    av_frame_free(&second);\n\n    return ret;\n\n}\n", "idx": 753}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "void avfilter_uninit(void)\n\n{\n\n    memset(registered_avfilters, 0, sizeof(registered_avfilters));\n\n    next_registered_avfilter_idx = 0;\n\n}\n", "idx": 755}
{"project": "FFmpeg", "commit_id": "d701934bef6ff6868c0a2179b7b9105c7a49b41f", "target": 0, "func": "int pcm_read_seek(AVFormatContext *s,\n\n                  int stream_index, int64_t timestamp, int flags)\n\n{\n\n    AVStream *st;\n\n    int block_align, byte_rate;\n\n    int64_t pos;\n\n\n\n    st = s->streams[0];\n\n\n\n    block_align = st->codec->block_align ? st->codec->block_align :\n\n        (av_get_bits_per_sample(st->codec->codec_id) * st->codec->channels) >> 3;\n\n    byte_rate = st->codec->bit_rate ? st->codec->bit_rate >> 3 :\n\n        block_align * st->codec->sample_rate;\n\n\n\n    if (block_align <= 0 || byte_rate <= 0)\n\n        return -1;\n\n\n\n    /* compute the position by aligning it to block_align */\n\n    pos = av_rescale_rnd(timestamp * byte_rate,\n\n                         st->time_base.num,\n\n                         st->time_base.den * (int64_t)block_align,\n\n                         (flags & AVSEEK_FLAG_BACKWARD) ? AV_ROUND_DOWN : AV_ROUND_UP);\n\n    pos *= block_align;\n\n\n\n    /* recompute exact position */\n\n    st->cur_dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num);\n\n    url_fseek(s->pb, pos + s->data_offset, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 756}
{"project": "FFmpeg", "commit_id": "9cb5c760d73e08bcd5d441d261abe67d472e98ee", "target": 0, "func": "void show_pix_fmts(void)\n\n{\n\n    list_fmts(avcodec_pix_fmt_string, PIX_FMT_NB);\n\n}\n", "idx": 758}
{"project": "FFmpeg", "commit_id": "f86387b6c2b11650cb9d5a8fd886be76e48c665b", "target": 0, "func": "static int spdif_get_offset_and_codec(AVFormatContext *s,\n\n                                      enum IEC61937DataType data_type,\n\n                                      const char *buf, int *offset,\n\n                                      enum AVCodecID *codec)\n\n{\n\n    AACADTSHeaderInfo aac_hdr;\n\n    GetBitContext gbc;\n\n\n\n    switch (data_type & 0xff) {\n\n    case IEC61937_AC3:\n\n        *offset = AC3_FRAME_SIZE << 2;\n\n        *codec = AV_CODEC_ID_AC3;\n\n        break;\n\n    case IEC61937_MPEG1_LAYER1:\n\n        *offset = spdif_mpeg_pkt_offset[1][0];\n\n        *codec = AV_CODEC_ID_MP1;\n\n        break;\n\n    case IEC61937_MPEG1_LAYER23:\n\n        *offset = spdif_mpeg_pkt_offset[1][0];\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_MPEG2_EXT:\n\n        *offset = 4608;\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_MPEG2_AAC:\n\n        init_get_bits(&gbc, buf, AAC_ADTS_HEADER_SIZE * 8);\n\n        if (avpriv_aac_parse_header(&gbc, &aac_hdr)) {\n\n            if (s) /* be silent during a probe */\n\n                av_log(s, AV_LOG_ERROR, \"Invalid AAC packet in IEC 61937\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        *offset = aac_hdr.samples << 2;\n\n        *codec = AV_CODEC_ID_AAC;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER1_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][0];\n\n        *codec = AV_CODEC_ID_MP1;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER2_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][1];\n\n        *codec = AV_CODEC_ID_MP2;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER3_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][2];\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_DTS1:\n\n        *offset = 2048;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    case IEC61937_DTS2:\n\n        *offset = 4096;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    case IEC61937_DTS3:\n\n        *offset = 8192;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    default:\n\n        if (s) { /* be silent during a probe */\n\n            avpriv_request_sample(s, \"Data type 0x%04x in IEC 61937\",\n\n                                  data_type);\n\n        }\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    return 0;\n\n}\n", "idx": 759}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n\n{\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n\n\n    seq->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 760}
{"project": "FFmpeg", "commit_id": "d319064465e148b8adb53d1ea5d38c09f987056e", "target": 0, "func": "void set_context_opts(void *ctx, void *opts_ctx, int flags, AVCodec *codec)\n\n{\n\n    int i;\n\n    void *priv_ctx=NULL;\n\n    if(!strcmp(\"AVCodecContext\", (*(AVClass**)ctx)->class_name)){\n\n        AVCodecContext *avctx= ctx;\n\n        if(codec && codec->priv_class && avctx->priv_data){\n\n            priv_ctx= avctx->priv_data;\n\n        }\n\n    } else if (!strcmp(\"AVFormatContext\", (*(AVClass**)ctx)->class_name)) {\n\n        AVFormatContext *avctx = ctx;\n\n        if (avctx->oformat && avctx->oformat->priv_class) {\n\n            priv_ctx = avctx->priv_data;\n\n        }\n\n    }\n\n\n\n    for(i=0; i<opt_name_count; i++){\n\n        char buf[256];\n\n        const AVOption *opt;\n\n        const char *str= av_get_string(opts_ctx, opt_names[i], &opt, buf, sizeof(buf));\n\n        /* if an option with name opt_names[i] is present in opts_ctx then str is non-NULL */\n\n        if(str && ((opt->flags & flags) == flags))\n\n            av_set_string3(ctx, opt_names[i], str, 1, NULL);\n\n        /* We need to use a differnt system to pass options to the private context because\n\n           it is not known which codec and thus context kind that will be when parsing options\n\n           we thus use opt_values directly instead of opts_ctx */\n\n        if(!str && priv_ctx) {\n\n            if (av_find_opt(priv_ctx, opt_names[i], NULL, flags, flags))\n\n                av_set_string3(priv_ctx, opt_names[i], opt_values[i], 0, NULL);\n\n        }\n\n    }\n\n}\n", "idx": 761}
{"project": "FFmpeg", "commit_id": "7bf9e3391fa21d90ff283fc03a12287fe73db9e8", "target": 0, "func": "int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame,\n\n                             int64_t pts, AVRational pixel_aspect)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!buf) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format);\n\n\n\n    buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE,\n\n                                    c->w, c->h);\n\n    av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize,\n\n                  c->pix_fmt, c->w, c->h);\n\n\n\n    avfilter_copy_frame_props(buf, frame);\n\n    buf->pts                    = pts;\n\n    buf->video->pixel_aspect    = pixel_aspect;\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 762}
{"project": "FFmpeg", "commit_id": "4843227b2ca6876d07caddddd62e58e52d67e94f", "target": 1, "func": "static int decode_byterun(uint8_t *dst, int dst_size,\n\n                          const uint8_t *buf, const uint8_t *const buf_end)\n\n{\n\n    const uint8_t *const buf_start = buf;\n\n    unsigned x;\n\n    for (x = 0; x < dst_size && buf < buf_end;) {\n\n        unsigned length;\n\n        const int8_t value = *buf++;\n\n        if (value >= 0) {\n\n            length = value + 1;\n\n            memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf));\n\n            buf += length;\n\n        } else if (value > -128) {\n\n            length = -value + 1;\n\n            memset(dst + x, *buf++, FFMIN(length, dst_size - x));\n\n        } else { // noop\n\n            continue;\n\n        }\n\n        x += length;\n\n    }\n\n    if (x < dst_size) {\n\n        av_log(NULL, AV_LOG_WARNING, \"decode_byterun ended before plane size\\n\");\n\n        memset(dst+x, 0, dst_size - x);\n\n    }\n\n    return buf - buf_start;\n\n}\n", "idx": 763}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t blk_mig_bytes_total(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n    uint64_t sum = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        sum += bmds->total_sectors;\n\n    }\n\n    return sum << BDRV_SECTOR_BITS;\n\n}\n", "idx": 764}
{"project": "FFmpeg", "commit_id": "11d058b7b351db8fb73104c847c5cc43b91735c6", "target": 1, "func": "theora_header (AVFormatContext * s, int idx)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    AVStream *st = s->streams[idx];\n\n    struct theora_params *thp = os->private;\n\n    int cds = st->codec->extradata_size + os->psize + 2;\n\n    uint8_t *cdp;\n\n\n\n    if(!(os->buf[os->pstart] & 0x80))\n\n        return 0;\n\n\n\n    if(!thp){\n\n        thp = av_mallocz(sizeof(*thp));\n\n        os->private = thp;\n\n\n\n\n    if (os->buf[os->pstart] == 0x80) {\n\n        GetBitContext gb;\n\n        int width, height;\n\n\n\n        init_get_bits(&gb, os->buf + os->pstart, os->psize*8);\n\n\n\n        skip_bits_long(&gb, 7*8); /* 0x80\"theora\" */\n\n\n\n        thp->version = get_bits_long(&gb, 24);\n\n        if (thp->version < 0x030100)\n\n        {\n\n            av_log(s, AV_LOG_ERROR,\n\n                \"Too old or unsupported Theora (%x)\\n\", thp->version);\n\n            return -1;\n\n\n\n\n        width  = get_bits(&gb, 16) << 4;\n\n        height = get_bits(&gb, 16) << 4;\n\n        avcodec_set_dimensions(st->codec, width, height);\n\n\n\n        if (thp->version >= 0x030400)\n\n            skip_bits(&gb, 100);\n\n\n\n        if (thp->version >= 0x030200) {\n\n            width  = get_bits_long(&gb, 24);\n\n            height = get_bits_long(&gb, 24);\n\n            if (   width  <= st->codec->width  && width  > st->codec->width-16\n\n                && height <= st->codec->height && height > st->codec->height-16)\n\n                avcodec_set_dimensions(st->codec, width, height);\n\n\n\n            skip_bits(&gb, 16);\n\n\n        st->codec->time_base.den = get_bits_long(&gb, 32);\n\n        st->codec->time_base.num = get_bits_long(&gb, 32);\n\n\n\n\n\n\n        st->time_base = st->codec->time_base;\n\n\n\n        st->sample_aspect_ratio.num = get_bits_long(&gb, 24);\n\n        st->sample_aspect_ratio.den = get_bits_long(&gb, 24);\n\n\n\n        if (thp->version >= 0x030200)\n\n            skip_bits_long(&gb, 38);\n\n        if (thp->version >= 0x304000)\n\n            skip_bits(&gb, 2);\n\n\n\n        thp->gpshift = get_bits(&gb, 5);\n\n        thp->gpmask = (1 << thp->gpshift) - 1;\n\n\n\n        st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n        st->codec->codec_id = CODEC_ID_THEORA;\n\n\n\n    } else if (os->buf[os->pstart] == 0x83) {\n\n        vorbis_comment (s, os->buf + os->pstart + 7, os->psize - 8);\n\n\n\n\n    st->codec->extradata = av_realloc (st->codec->extradata,\n\n                                       cds + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    cdp = st->codec->extradata + st->codec->extradata_size;\n\n    *cdp++ = os->psize >> 8;\n\n    *cdp++ = os->psize & 0xff;\n\n    memcpy (cdp, os->buf + os->pstart, os->psize);\n\n    st->codec->extradata_size = cds;\n\n\n\n    return 1;\n", "idx": 765}
{"project": "qemu", "commit_id": "b946a1533209f61a93e34898aebb5b43154b99c3", "target": 1, "func": "static TAPState *net_tap_fd_init(VLANState *vlan,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = qemu_mallocz(sizeof(TAPState));\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, model, name, tap_receive, NULL, s);\n\n    s->vc->fd_readv = tap_receive_iov;\n\n    qemu_set_fd_handler(s->fd, tap_send, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"fd=%d\", fd);\n\n    return s;\n\n}\n", "idx": 766}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_refcount_block_entries(BlockDriverState *bs,\n\n    int64_t refcount_block_offset, int first_index, int last_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    size_t size;\n\n    int ret;\n\n\n\n    if (cache_refcount_updates) {\n\n        return 0;\n\n    }\n\n\n\n    if (first_index < 0) {\n\n        return 0;\n\n    }\n\n\n\n    first_index &= ~(REFCOUNTS_PER_SECTOR - 1);\n\n    last_index = (last_index + REFCOUNTS_PER_SECTOR)\n\n        & ~(REFCOUNTS_PER_SECTOR - 1);\n\n\n\n    size = (last_index - first_index) << REFCOUNT_SHIFT;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_UPDATE_PART);\n\n    ret = bdrv_pwrite(bs->file,\n\n        refcount_block_offset + (first_index << REFCOUNT_SHIFT),\n\n        &s->refcount_block_cache[first_index], size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 769}
{"project": "FFmpeg", "commit_id": "14e4e26559697cfdea584767be4e68474a0a9c7f", "target": 1, "func": "static int t15(InterplayACMContext *s, unsigned ind, unsigned col)\n\n{\n\n    GetBitContext *gb = &s->gb;\n\n    unsigned i, b;\n\n    int n1, n2, n3;\n\n\n\n    for (i = 0; i < s->rows; i++) {\n\n        /* b = (x1) + (x2 * 3) + (x3 * 9) */\n\n        b = get_bits(gb, 5);\n\n\n\n\n\n\n\n        n1 =  (mul_3x3[b] & 0x0F) - 1;\n\n        n2 = ((mul_3x3[b] >> 4) & 0x0F) - 1;\n\n        n3 = ((mul_3x3[b] >> 8) & 0x0F) - 1;\n\n\n\n        set_pos(s, i++, col, n1);\n\n        if (i >= s->rows)\n\n            break;\n\n        set_pos(s, i++, col, n2);\n\n        if (i >= s->rows)\n\n            break;\n\n        set_pos(s, i, col, n3);\n\n\n    return 0;\n", "idx": 770}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_load_6xx_tlb (int is_code)\n\n{\n\n    target_ulong RPN, CMP, EPN;\n\n    int way;\n\n    \n\n    RPN = env->spr[SPR_RPA];\n\n    if (is_code) {\n\n        CMP = env->spr[SPR_ICMP];\n\n        EPN = env->spr[SPR_IMISS];\n\n    } else {\n\n        CMP = env->spr[SPR_DCMP];\n\n        EPN = env->spr[SPR_DMISS];\n\n    }\n\n    way = (env->spr[SPR_SRR1] >> 17) & 1;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: EPN %08lx %08lx PTE0 %08lx PTE1 %08lx way %d\\n\",\n\n                __func__, (unsigned long)T0, (unsigned long)EPN,\n\n                (unsigned long)CMP, (unsigned long)RPN, way);\n\n    }\n\n#endif\n\n    /* Store this TLB */\n\n    ppc6xx_tlb_store(env, T0 & TARGET_PAGE_MASK, way, is_code, CMP, RPN);\n\n}\n", "idx": 773}
{"project": "qemu", "commit_id": "c9f82d013be0d8d9c5d9f51bb76e337a0a5a5cac", "target": 1, "func": "void helper_dcbz(CPUPPCState *env, target_ulong addr, uint32_t is_dcbzl)\n\n{\n\n    int dcbz_size = env->dcache_line_size;\n\n\n\n#if defined(TARGET_PPC64)\n\n    if (!is_dcbzl &&\n\n        (env->excp_model == POWERPC_EXCP_970) &&\n\n        ((env->spr[SPR_970_HID5] >> 7) & 0x3) == 1) {\n\n        dcbz_size = 32;\n\n    }\n\n#endif\n\n\n\n    /* XXX add e500mc support */\n\n\n\n    do_dcbz(env, addr, dcbz_size, GETPC());\n\n}\n", "idx": 774}
{"project": "qemu", "commit_id": "ec45bbe5f1921c6553fbf9c0c76b358b0403c22d", "target": 1, "func": "envlist_create(void)\n\n{\n\n\tenvlist_t *envlist;\n\n\n\n\tif ((envlist = malloc(sizeof (*envlist))) == NULL)\n\n\t\treturn (NULL);\n\n\n\n\tQLIST_INIT(&envlist->el_entries);\n\n\tenvlist->el_count = 0;\n\n\n\n\treturn (envlist);\n\n}\n", "idx": 775}
{"project": "qemu", "commit_id": "b68e60e6f0d2865e961a800fb8db96a7fc6494c4", "target": 1, "func": "static void gen_ori(DisasContext *ctx)\n\n{\n\n    target_ulong uimm = UIMM(ctx->opcode);\n\n\n\n    if (rS(ctx->opcode) == rA(ctx->opcode) && uimm == 0) {\n\n        /* NOP */\n\n        /* XXX: should handle special NOPs for POWER series */\n\n        return;\n\n    }\n\n    tcg_gen_ori_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rS(ctx->opcode)], uimm);\n\n}\n", "idx": 776}
{"project": "FFmpeg", "commit_id": "15861962a7a9e64fbe75f5cc0dc7d1c032db8dd5", "target": 1, "func": "static void close(AVCodecParserContext *s)\n\n{\n\n    H264Context *h = s->priv_data;\n\n    ParseContext *pc = &h->s.parse_context;\n\n\n\n    av_free(pc->buffer);\n\n\n}", "idx": 777}
{"project": "qemu", "commit_id": "6b7741c2bedeae2e8c54fffce81723ca0a0c25c0", "target": 1, "func": "static void sch_handle_start_func(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int path;\n\n    int ret;\n\n\n\n    /* Path management: In our simple css, we always choose the only path. */\n\n    path = 0x80;\n\n\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n\n\n        /* Look at the orb and try to execute the channel program. */\n\n        assert(orb != NULL); /* resume does not pass an orb */\n\n        p->intparm = orb->intparm;\n\n        if (!(orb->lpm & path)) {\n\n            /* Generate a deferred cc 3 condition. */\n\n            s->flags |= SCSW_FLAGS_MASK_CC;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);\n\n            return;\n\n        }\n\n        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);\n\n        sch->ccw_no_data_cnt = 0;\n\n    } else {\n\n        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);\n\n    }\n\n    sch->last_cmd_valid = false;\n\n    do {\n\n        ret = css_interpret_ccw(sch, sch->channel_prog);\n\n        switch (ret) {\n\n        case -EAGAIN:\n\n            /* ccw chain, continue processing */\n\n            break;\n\n        case 0:\n\n            /* success */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_STATUS_PEND;\n\n            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -ENOSYS:\n\n            /* unsupported command, generate unit check (command reject) */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->dstat = SCSW_DSTAT_UNIT_CHECK;\n\n            /* Set sense bit 0 in ecw0. */\n\n            sch->sense_data[0] = 0x80;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EFAULT:\n\n            /* memory problem, generate channel data check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_DATA_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EBUSY:\n\n            /* subchannel busy, generate deferred cc 1 */\n\n            s->flags &= ~SCSW_FLAGS_MASK_CC;\n\n            s->flags |= (1 << 8);\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            break;\n\n        case -EINPROGRESS:\n\n            /* channel program has been suspended */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl |= SCSW_ACTL_SUSP;\n\n            break;\n\n        default:\n\n            /* error, generate channel program check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_PROG_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        }\n\n    } while (ret == -EAGAIN);\n\n\n\n}", "idx": 778}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "static int net_vhost_chardev_opts(void *opaque,\n\n                                  const char *name, const char *value,\n\n                                  Error **errp)\n\n{\n\n    VhostUserChardevProps *props = opaque;\n\n\n\n    if (strcmp(name, \"backend\") == 0 && strcmp(value, \"socket\") == 0) {\n\n        props->is_socket = true;\n\n    } else if (strcmp(name, \"path\") == 0) {\n\n        props->is_unix = true;\n\n    } else if (strcmp(name, \"server\") == 0) {\n\n    } else {\n\n        error_setg(errp,\n\n                   \"vhost-user does not support a chardev with option %s=%s\",\n\n                   name, value);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 779}
{"project": "FFmpeg", "commit_id": "fea714ecd9de557054b2540119f6b5635ba0e636", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *data_size,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    const uint8_t *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr;\n\n\n\n    int magic_num, offset, endian;\n\n    int x, y;\n\n    int w, h, stride, bits_per_color, descriptor, elements, target_packet_size, source_packet_size;\n\n\n\n    unsigned int rgbBuffer;\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n\n\n\n\n    offset = read32(&buf, endian);\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = PIX_FMT_RGB24;\n\n\n            source_packet_size = elements;\n\n            target_packet_size = elements;\n\n            break;\n\n        case 10:\n\n            avctx->pix_fmt = PIX_FMT_RGB48;\n\n            target_packet_size = 6;\n\n            source_packet_size = elements * 2;\n\n            break;\n\n        case 12:\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = PIX_FMT_RGB48LE;\n\n\n            target_packet_size = 6;\n\n            source_packet_size = elements * 2;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    switch (bits_per_color) {\n\n        case 10:\n\n            for (x = 0; x < avctx->height; x++) {\n\n               uint16_t *dst = (uint16_t*)ptr;\n\n               for (y = 0; y < avctx->width; y++) {\n\n                   rgbBuffer = read32(&buf, endian);\n\n                   // Read out the 10-bit colors and convert to 16-bit\n\n                   *dst++ = make_16bit(rgbBuffer >> 16);\n\n                   *dst++ = make_16bit(rgbBuffer >>  6);\n\n                   *dst++ = make_16bit(rgbBuffer <<  4);\n\n\n               ptr += stride;\n\n\n            break;\n\n        case 8:\n\n        case 12: // Treat 12-bit as 16-bit\n\n        case 16:\n\n\n\n\n\n            if (source_packet_size == target_packet_size) {\n\n                for (x = 0; x < avctx->height; x++) {\n\n                    memcpy(ptr, buf, target_packet_size*avctx->width);\n\n                    ptr += stride;\n\n                    buf += source_packet_size*avctx->width;\n\n\n            } else {\n\n                for (x = 0; x < avctx->height; x++) {\n\n                    uint8_t *dst = ptr;\n\n                    for (y = 0; y < avctx->width; y++) {\n\n                        memcpy(dst, buf, target_packet_size);\n\n                        dst += target_packet_size;\n\n                        buf += source_packet_size;\n\n\n                    ptr += stride;\n\n\n\n            break;\n\n\n\n\n    *picture   = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return buf_size;\n", "idx": 780}
{"project": "FFmpeg", "commit_id": "71434945f20c6d340b4c942de7746e6ea46ec74b", "target": 1, "func": "static int mpeg_decode_mb(MpegEncContext *s,\n\n                          DCTELEM block[12][64])\n\n{\n\n    int i, j, k, cbp, val, mb_type, motion_type;\n\n    const int mb_block_count = 4 + (1<< s->chroma_format)\n\n\n\n    dprintf(\"decode_mb: x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n    assert(s->mb_skiped==0);\n\n\n\n    if (s->mb_skip_run-- != 0) {\n\n        if(s->pict_type == I_TYPE){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"skiped MB in I frame at %d %d\\n\", s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n    \n\n        /* skip mb */\n\n        s->mb_intra = 0;\n\n        for(i=0;i<12;i++)\n\n            s->block_last_index[i] = -1;\n\n        if(s->picture_structure == PICT_FRAME)\n\n            s->mv_type = MV_TYPE_16X16;\n\n        else\n\n            s->mv_type = MV_TYPE_FIELD;\n\n        if (s->pict_type == P_TYPE) {\n\n            /* if P type, zero motion vector is implied */\n\n            s->mv_dir = MV_DIR_FORWARD;\n\n            s->mv[0][0][0] = s->mv[0][0][1] = 0;\n\n            s->last_mv[0][0][0] = s->last_mv[0][0][1] = 0;\n\n            s->last_mv[0][1][0] = s->last_mv[0][1][1] = 0;\n\n            s->field_select[0][0]= s->picture_structure - 1;\n\n            s->mb_skiped = 1;\n\n            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16;\n\n        } else {\n\n            /* if B type, reuse previous vectors and directions */\n\n            s->mv[0][0][0] = s->last_mv[0][0][0];\n\n            s->mv[0][0][1] = s->last_mv[0][0][1];\n\n            s->mv[1][0][0] = s->last_mv[1][0][0];\n\n            s->mv[1][0][1] = s->last_mv[1][0][1];\n\n\n\n            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= \n\n                s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1] | MB_TYPE_SKIP;\n\n//            assert(s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1]&(MB_TYPE_16x16|MB_TYPE_16x8));\n\n\n\n            if((s->mv[0][0][0]|s->mv[0][0][1]|s->mv[1][0][0]|s->mv[1][0][1])==0) \n\n                s->mb_skiped = 1;\n\n        }\n\n\n\n        return 0;\n\n    }\n\n\n\n    switch(s->pict_type) {\n\n    default:\n\n    case I_TYPE:\n\n        if (get_bits1(&s->gb) == 0) {\n\n            if (get_bits1(&s->gb) == 0){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid mb type in I Frame at %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n            mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA;\n\n        } else {\n\n            mb_type = MB_TYPE_INTRA;\n\n        }\n\n        break;\n\n    case P_TYPE:\n\n        mb_type = get_vlc2(&s->gb, mb_ptype_vlc.table, MB_PTYPE_VLC_BITS, 1);\n\n        if (mb_type < 0){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid mb type in P Frame at %d %d\\n\", s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        mb_type = ptype2mb_type[ mb_type ];\n\n        break;\n\n    case B_TYPE:\n\n        mb_type = get_vlc2(&s->gb, mb_btype_vlc.table, MB_BTYPE_VLC_BITS, 1);\n\n        if (mb_type < 0){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid mb type in B Frame at %d %d\\n\", s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        mb_type = btype2mb_type[ mb_type ];\n\n        break;\n\n    }\n\n    dprintf(\"mb_type=%x\\n\", mb_type);\n\n//    motion_type = 0; /* avoid warning */\n\n    if (IS_INTRA(mb_type)) {\n\n        /* compute dct type */\n\n        if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?\n\n            !s->frame_pred_frame_dct) {\n\n            s->interlaced_dct = get_bits1(&s->gb);\n\n        }\n\n\n\n        if (IS_QUANT(mb_type))\n\n            s->qscale = get_qscale(s);\n\n        \n\n        if (s->concealment_motion_vectors) {\n\n            /* just parse them */\n\n            if (s->picture_structure != PICT_FRAME) \n\n                skip_bits1(&s->gb); /* field select */\n\n            \n\n            s->mv[0][0][0]= s->last_mv[0][0][0]= s->last_mv[0][1][0] = \n\n                mpeg_decode_motion(s, s->mpeg_f_code[0][0], s->last_mv[0][0][0]);\n\n            s->mv[0][0][1]= s->last_mv[0][0][1]= s->last_mv[0][1][1] = \n\n                mpeg_decode_motion(s, s->mpeg_f_code[0][1], s->last_mv[0][0][1]);\n\n\n\n            skip_bits1(&s->gb); /* marker */\n\n        }else\n\n            memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */\n\n        s->mb_intra = 1;\n\n#ifdef HAVE_XVMC\n\n        //one 1 we memcpy blocks in xvmcvideo\n\n        if(s->avctx->xvmc_acceleration > 1){\n\n            XVMC_pack_pblocks(s,-1);//inter are always full blocks\n\n            if(s->swap_uv){\n\n                exchange_uv(s);\n\n            }\n\n        }\n\n#endif\n\n\n\n        if (s->codec_id == CODEC_ID_MPEG2VIDEO) {\n\n            for(i=0;i<mb_block_count;i++) {\n\n                if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)\n\n                    return -1;\n\n            }\n\n        } else {\n\n            for(i=0;i<6;i++) {\n\n                if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)\n\n                    return -1;\n\n            }\n\n        }\n\n    } else {\n\n        if (mb_type & MB_TYPE_ZERO_MV){\n\n            assert(mb_type & MB_TYPE_CBP);\n\n\n\n            /* compute dct type */\n\n            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?\n\n                !s->frame_pred_frame_dct) {\n\n                s->interlaced_dct = get_bits1(&s->gb);\n\n            }\n\n\n\n            if (IS_QUANT(mb_type))\n\n                s->qscale = get_qscale(s);\n\n\n\n            s->mv_dir = MV_DIR_FORWARD;\n\n            if(s->picture_structure == PICT_FRAME)\n\n                s->mv_type = MV_TYPE_16X16;\n\n            else{\n\n                s->mv_type = MV_TYPE_FIELD;\n\n                mb_type |= MB_TYPE_INTERLACED;\n\n                s->field_select[0][0]= s->picture_structure - 1;\n\n            }\n\n            s->last_mv[0][0][0] = 0;\n\n            s->last_mv[0][0][1] = 0;\n\n            s->last_mv[0][1][0] = 0;\n\n            s->last_mv[0][1][1] = 0;\n\n            s->mv[0][0][0] = 0;\n\n            s->mv[0][0][1] = 0;\n\n        }else{\n\n            assert(mb_type & MB_TYPE_L0L1);\n\n//FIXME decide if MBs in field pictures are MB_TYPE_INTERLACED\n\n            /* get additionnal motion vector type */\n\n            if (s->frame_pred_frame_dct) \n\n                motion_type = MT_FRAME;\n\n            else{\n\n                motion_type = get_bits(&s->gb, 2);\n\n            }\n\n\n\n            /* compute dct type */\n\n            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?\n\n                !s->frame_pred_frame_dct && HAS_CBP(mb_type)) {\n\n                s->interlaced_dct = get_bits1(&s->gb);\n\n            }\n\n\n\n            if (IS_QUANT(mb_type))\n\n                s->qscale = get_qscale(s);\n\n\n\n            /* motion vectors */\n\n            s->mv_dir = 0;\n\n            for(i=0;i<2;i++) {\n\n                if (USES_LIST(mb_type, i)) {\n\n                    s->mv_dir |= (MV_DIR_FORWARD >> i);\n\n                    dprintf(\"motion_type=%d\\n\", motion_type);\n\n                    switch(motion_type) {\n\n                    case MT_FRAME: /* or MT_16X8 */\n\n                        if (s->picture_structure == PICT_FRAME) {\n\n                            /* MT_FRAME */\n\n                            mb_type |= MB_TYPE_16x16; \n\n                            s->mv_type = MV_TYPE_16X16;\n\n                            s->mv[i][0][0]= s->last_mv[i][0][0]= s->last_mv[i][1][0] = \n\n                                mpeg_decode_motion(s, s->mpeg_f_code[i][0], s->last_mv[i][0][0]);\n\n                            s->mv[i][0][1]= s->last_mv[i][0][1]= s->last_mv[i][1][1] = \n\n                                mpeg_decode_motion(s, s->mpeg_f_code[i][1], s->last_mv[i][0][1]);\n\n                            /* full_pel: only for mpeg1 */\n\n                            if (s->full_pel[i]){\n\n                                s->mv[i][0][0] <<= 1;\n\n                                s->mv[i][0][1] <<= 1;\n\n                            }\n\n                        } else {\n\n                            /* MT_16X8 */\n\n                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED; \n\n                            s->mv_type = MV_TYPE_16X8;\n\n                            for(j=0;j<2;j++) {\n\n                                s->field_select[i][j] = get_bits1(&s->gb);\n\n                                for(k=0;k<2;k++) {\n\n                                    val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],\n\n                                                             s->last_mv[i][j][k]);\n\n                                    s->last_mv[i][j][k] = val;\n\n                                    s->mv[i][j][k] = val;\n\n                                }\n\n                            }\n\n                        }\n\n                        break;\n\n                    case MT_FIELD:\n\n                        s->mv_type = MV_TYPE_FIELD;\n\n                        if (s->picture_structure == PICT_FRAME) {\n\n                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED; \n\n                            for(j=0;j<2;j++) {\n\n                                s->field_select[i][j] = get_bits1(&s->gb);\n\n                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][0],\n\n                                                         s->last_mv[i][j][0]);\n\n                                s->last_mv[i][j][0] = val;\n\n                                s->mv[i][j][0] = val;\n\n                                dprintf(\"fmx=%d\\n\", val);\n\n                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][1],\n\n                                                         s->last_mv[i][j][1] >> 1);\n\n                                s->last_mv[i][j][1] = val << 1;\n\n                                s->mv[i][j][1] = val;\n\n                                dprintf(\"fmy=%d\\n\", val);\n\n                            }\n\n                        } else {\n\n                            mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED; \n\n                            s->field_select[i][0] = get_bits1(&s->gb);\n\n                            for(k=0;k<2;k++) {\n\n                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],\n\n                                                         s->last_mv[i][0][k]);\n\n                                s->last_mv[i][0][k] = val;\n\n                                s->last_mv[i][1][k] = val;\n\n                                s->mv[i][0][k] = val;\n\n                            }\n\n                        }\n\n                        break;\n\n                    case MT_DMV:\n\n                        {\n\n                            int dmx, dmy, mx, my, m;\n\n\n\n                            mx = mpeg_decode_motion(s, s->mpeg_f_code[i][0], \n\n                                                    s->last_mv[i][0][0]);\n\n                            s->last_mv[i][0][0] = mx;\n\n                            s->last_mv[i][1][0] = mx;\n\n                            dmx = get_dmv(s);\n\n                            my = mpeg_decode_motion(s, s->mpeg_f_code[i][1], \n\n                                                    s->last_mv[i][0][1] >> 1);\n\n                            dmy = get_dmv(s);\n\n                            s->mv_type = MV_TYPE_DMV;\n\n\n\n\n\n                            s->last_mv[i][0][1] = my<<1;\n\n                            s->last_mv[i][1][1] = my<<1;\n\n\n\n                            s->mv[i][0][0] = mx;\n\n                            s->mv[i][0][1] = my;\n\n                            s->mv[i][1][0] = mx;//not used\n\n                            s->mv[i][1][1] = my;//not used\n\n\n\n                            if (s->picture_structure == PICT_FRAME) {\n\n                                mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED; \n\n\n\n                                //m = 1 + 2 * s->top_field_first;\n\n                                m = s->top_field_first ? 1 : 3;\n\n\n\n                                /* top -> top pred */\n\n                                s->mv[i][2][0] = ((mx * m + (mx > 0)) >> 1) + dmx;\n\n                                s->mv[i][2][1] = ((my * m + (my > 0)) >> 1) + dmy - 1;\n\n                                m = 4 - m;\n\n                                s->mv[i][3][0] = ((mx * m + (mx > 0)) >> 1) + dmx;\n\n                                s->mv[i][3][1] = ((my * m + (my > 0)) >> 1) + dmy + 1;\n\n                            } else {\n\n                                mb_type |= MB_TYPE_16x16;\n\n\n\n                                s->mv[i][2][0] = ((mx + (mx > 0)) >> 1) + dmx;\n\n                                s->mv[i][2][1] = ((my + (my > 0)) >> 1) + dmy;\n\n                                if(s->picture_structure == PICT_TOP_FIELD)\n\n                                    s->mv[i][2][1]--;\n\n                                else \n\n                                    s->mv[i][2][1]++;\n\n                            }\n\n                        }\n\n                        break;\n\n                    default:\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"00 motion_type at %d %d\\n\", s->mb_x, s->mb_y);\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        \n\n        s->mb_intra = 0;\n\n\n\n        if (HAS_CBP(mb_type)) {\n\n            cbp = get_vlc2(&s->gb, mb_pat_vlc.table, MB_PAT_VLC_BITS, 1);\n\n            if (cbp < 0 || ((cbp == 0) && (s->chroma_format < 2)) ){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid cbp at %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n            if(mb_block_count > 6){\n\n\t         cbp<<= mb_block_count-6;\n\n\t\t cbp |= get_bits(&s->gb, mb_block_count-6);\n\n            }\n\n\n\n#ifdef HAVE_XVMC\n\n            //on 1 we memcpy blocks in xvmcvideo\n\n            if(s->avctx->xvmc_acceleration > 1){\n\n                XVMC_pack_pblocks(s,cbp);\n\n                if(s->swap_uv){\n\n                    exchange_uv(s);\n\n                }\n\n            }    \n\n#endif\n\n\n\n            if (s->codec_id == CODEC_ID_MPEG2VIDEO) {\n\n                if(s->flags2 & CODEC_FLAG2_FAST){\n\n                    for(i=0;i<6;i++) {\n\n                        if(cbp & 32) {\n\n                            mpeg2_fast_decode_block_non_intra(s, s->pblocks[i], i);\n\n                        } else {\n\n                            s->block_last_index[i] = -1;\n\n                        }\n\n                        cbp+=cbp;\n\n                    }\n\n                }else{\n\n                    cbp<<= 12-mb_block_count;\n\n    \n\n                    for(i=0;i<mb_block_count;i++) {\n\n                        if ( cbp & (1<<11) ) {\n\n                            if (mpeg2_decode_block_non_intra(s, s->pblocks[i], i) < 0)\n\n                                return -1;\n\n                        } else {\n\n                            s->block_last_index[i] = -1;\n\n                        }\n\n                        cbp+=cbp;\n\n                    }\n\n                }\n\n            } else {\n\n                if(s->flags2 & CODEC_FLAG2_FAST){\n\n                    for(i=0;i<6;i++) {\n\n                        if (cbp & 32) {\n\n                            mpeg1_fast_decode_block_inter(s, s->pblocks[i], i);\n\n                        } else {\n\n                            s->block_last_index[i] = -1;\n\n                        }\n\n                        cbp+=cbp;\n\n                    }\n\n                }else{\n\n                    for(i=0;i<6;i++) {\n\n                        if (cbp & 32) {\n\n                            if (mpeg1_decode_block_inter(s, s->pblocks[i], i) < 0)\n\n                                return -1;\n\n                        } else {\n\n                            s->block_last_index[i] = -1;\n\n                        }\n\n                        cbp+=cbp;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            for(i=0;i<6;i++)\n\n                s->block_last_index[i] = -1;\n\n        }\n\n    }\n\n\n\n    s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= mb_type;\n\n\n\n    return 0;\n\n}\n", "idx": 783}
{"project": "qemu", "commit_id": "76e050c2e62995f1d6905e28674dea3a7fcff1a5", "target": 1, "func": "void op_subo (void)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = T0;\n\n    T0 = (int32_t)T0 - (int32_t)T1;\n\n    if (!((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31))) {\n\n        CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 784}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "int get_physical_address (CPUState *env, mmu_ctx_t *ctx, target_ulong eaddr,\n\n                          int rw, int access_type, int check_BATs)\n\n{\n\n    int ret;\n\n#if 0\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s\\n\", __func__);\n\n    }\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        /* No address translation */\n\n        ret = check_physical(env, ctx, eaddr, rw);\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (check_BATs)\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            /* No break here */\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_64BRIDGE:\n\n#endif\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_601:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"601 MMU model not implemented\\n\");\n\n            return -1;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE_FSL:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n            return -1;\n\n        case POWERPC_MMU_REAL_4xx:\n\n            cpu_abort(env, \"PowerPC 401 does not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s address \" ADDRX \" => %d \" PADDRX \"\\n\",\n\n                __func__, eaddr, ret, ctx->raddr);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 785}
{"project": "qemu", "commit_id": "4a9f9cb24de52e93aae7539a004dd20314ca1c0c", "target": 0, "func": "uint32_t HELPER(neon_min_f32)(uint32_t a, uint32_t b)\n\n{\n\n    float32 f0 = make_float32(a);\n\n    float32 f1 = make_float32(b);\n\n    return (float32_compare_quiet(f0, f1, NFS) == -1) ? a : b;\n\n}\n", "idx": 786}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_primitive_lists(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    PrimitiveType *pt = args->test_data;\n\n    PrimitiveList pl = { .value = { NULL } };\n\n    PrimitiveList pl_copy = { .value = { NULL } };\n\n    PrimitiveList *pl_copy_ptr = &pl_copy;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    void *cur_head = NULL;\n\n    int i;\n\n\n\n    pl.type = pl_copy.type = pt->type;\n\n\n\n    /* build up our list of primitive types */\n\n    for (i = 0; i < 32; i++) {\n\n        switch (pl.type) {\n\n        case PTYPE_STRING: {\n\n            strList *tmp = g_new0(strList, 1);\n\n            tmp->value = g_strdup(pt->value.string);\n\n            if (pl.value.strings == NULL) {\n\n                pl.value.strings = tmp;\n\n            } else {\n\n                tmp->next = pl.value.strings;\n\n                pl.value.strings = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_INTEGER: {\n\n            intList *tmp = g_new0(intList, 1);\n\n            tmp->value = pt->value.integer;\n\n            if (pl.value.integers == NULL) {\n\n                pl.value.integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.integers;\n\n                pl.value.integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S8: {\n\n            int8List *tmp = g_new0(int8List, 1);\n\n            tmp->value = pt->value.s8;\n\n            if (pl.value.s8_integers == NULL) {\n\n                pl.value.s8_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s8_integers;\n\n                pl.value.s8_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S16: {\n\n            int16List *tmp = g_new0(int16List, 1);\n\n            tmp->value = pt->value.s16;\n\n            if (pl.value.s16_integers == NULL) {\n\n                pl.value.s16_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s16_integers;\n\n                pl.value.s16_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S32: {\n\n            int32List *tmp = g_new0(int32List, 1);\n\n            tmp->value = pt->value.s32;\n\n            if (pl.value.s32_integers == NULL) {\n\n                pl.value.s32_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s32_integers;\n\n                pl.value.s32_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S64: {\n\n            int64List *tmp = g_new0(int64List, 1);\n\n            tmp->value = pt->value.s64;\n\n            if (pl.value.s64_integers == NULL) {\n\n                pl.value.s64_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s64_integers;\n\n                pl.value.s64_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U8: {\n\n            uint8List *tmp = g_new0(uint8List, 1);\n\n            tmp->value = pt->value.u8;\n\n            if (pl.value.u8_integers == NULL) {\n\n                pl.value.u8_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u8_integers;\n\n                pl.value.u8_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U16: {\n\n            uint16List *tmp = g_new0(uint16List, 1);\n\n            tmp->value = pt->value.u16;\n\n            if (pl.value.u16_integers == NULL) {\n\n                pl.value.u16_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u16_integers;\n\n                pl.value.u16_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U32: {\n\n            uint32List *tmp = g_new0(uint32List, 1);\n\n            tmp->value = pt->value.u32;\n\n            if (pl.value.u32_integers == NULL) {\n\n                pl.value.u32_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u32_integers;\n\n                pl.value.u32_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U64: {\n\n            uint64List *tmp = g_new0(uint64List, 1);\n\n            tmp->value = pt->value.u64;\n\n            if (pl.value.u64_integers == NULL) {\n\n                pl.value.u64_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u64_integers;\n\n                pl.value.u64_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_NUMBER: {\n\n            numberList *tmp = g_new0(numberList, 1);\n\n            tmp->value = pt->value.number;\n\n            if (pl.value.numbers == NULL) {\n\n                pl.value.numbers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.numbers;\n\n                pl.value.numbers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_BOOLEAN: {\n\n            boolList *tmp = g_new0(boolList, 1);\n\n            tmp->value = pt->value.boolean;\n\n            if (pl.value.booleans == NULL) {\n\n                pl.value.booleans = tmp;\n\n            } else {\n\n                tmp->next = pl.value.booleans;\n\n                pl.value.booleans = tmp;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    ops->serialize((void **)&pl, &serialize_data, visit_primitive_list, &err);\n\n    ops->deserialize((void **)&pl_copy_ptr, serialize_data, visit_primitive_list, &err);\n\n\n\n    g_assert(err == NULL);\n\n    i = 0;\n\n\n\n    /* compare our deserialized list of primitives to the original */\n\n    do {\n\n        switch (pl_copy.type) {\n\n        case PTYPE_STRING: {\n\n            strList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.strings;\n\n            }\n\n            g_assert_cmpstr(pt->value.string, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_INTEGER: {\n\n            intList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.integers;\n\n            }\n\n            g_assert_cmpint(pt->value.integer, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S8: {\n\n            int8List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s8_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s8, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S16: {\n\n            int16List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s16_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s16, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S32: {\n\n            int32List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s32_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s32, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S64: {\n\n            int64List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s64_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s64, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U8: {\n\n            uint8List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u8_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u8, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U16: {\n\n            uint16List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u16_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u16, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U32: {\n\n            uint32List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u32_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u32, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U64: {\n\n            uint64List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u64_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u64, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_NUMBER: {\n\n            numberList *ptr;\n\n            GString *double_expected = g_string_new(\"\");\n\n            GString *double_actual = g_string_new(\"\");\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.numbers;\n\n            }\n\n            /* we serialize with %f for our reference visitors, so rather than\n\n             * fuzzy floating math to test \"equality\", just compare the\n\n             * formatted values\n\n             */\n\n            g_string_printf(double_expected, \"%.6f\", pt->value.number);\n\n            g_string_printf(double_actual, \"%.6f\", ptr->value);\n\n            g_assert_cmpstr(double_actual->str, ==, double_expected->str);\n\n            g_string_free(double_expected, true);\n\n            g_string_free(double_actual, true);\n\n            break;\n\n        }\n\n        case PTYPE_BOOLEAN: {\n\n            boolList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.booleans;\n\n            }\n\n            g_assert_cmpint(!!pt->value.boolean, ==, !!ptr->value);\n\n            break;\n\n        }\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n        i++;\n\n    } while (cur_head);\n\n\n\n    g_assert_cmpint(i, ==, 33);\n\n\n\n    ops->cleanup(serialize_data);\n\n    dealloc_helper(&pl, visit_primitive_list, &err);\n\n    g_assert(!err);\n\n    dealloc_helper(&pl_copy, visit_primitive_list, &err);\n\n    g_assert(!err);\n\n    g_free(args);\n\n}\n", "idx": 787}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_pwl_s *omap_pwl_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_pwl_s *s = g_malloc0(sizeof(*s));\n\n\n\n    omap_pwl_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_pwl_ops, s,\n\n                          \"omap-pwl\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n    return s;\n\n}\n", "idx": 788}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_transmit(GemState *s)\n\n{\n\n    unsigned    desc[2];\n\n    target_phys_addr_t packet_desc_addr;\n\n    uint8_t     tx_packet[2048];\n\n    uint8_t     *p;\n\n    unsigned    total_bytes;\n\n\n\n    /* Do nothing if transmit is not enabled. */\n\n    if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n\n        return;\n\n    }\n\n\n\n    DB_PRINT(\"\\n\");\n\n\n\n    /* The packet we will hand off to qemu.\n\n     * Packets scattered across multiple descriptors are gathered to this\n\n     * one contiguous buffer first.\n\n     */\n\n    p = tx_packet;\n\n    total_bytes = 0;\n\n\n\n    /* read current descriptor */\n\n    packet_desc_addr = s->tx_desc_addr;\n\n    cpu_physical_memory_read(packet_desc_addr,\n\n                             (uint8_t *)&desc[0], sizeof(desc));\n\n    /* Handle all descriptors owned by hardware */\n\n    while (tx_desc_get_used(desc) == 0) {\n\n\n\n        /* Do nothing if transmit is not enabled. */\n\n        if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {\n\n            return;\n\n        }\n\n        print_gem_tx_desc(desc);\n\n\n\n        /* The real hardware would eat this (and possibly crash).\n\n         * For QEMU let's lend a helping hand.\n\n         */\n\n        if ((tx_desc_get_buffer(desc) == 0) ||\n\n            (tx_desc_get_length(desc) == 0)) {\n\n            DB_PRINT(\"Invalid TX descriptor @ 0x%x\\n\", packet_desc_addr);\n\n            break;\n\n        }\n\n\n\n        /* Gather this fragment of the packet from \"dma memory\" to our contig.\n\n         * buffer.\n\n         */\n\n        cpu_physical_memory_read(tx_desc_get_buffer(desc), p,\n\n                                 tx_desc_get_length(desc));\n\n        p += tx_desc_get_length(desc);\n\n        total_bytes += tx_desc_get_length(desc);\n\n\n\n        /* Last descriptor for this packet; hand the whole thing off */\n\n        if (tx_desc_get_last(desc)) {\n\n            /* Modify the 1st descriptor of this packet to be owned by\n\n             * the processor.\n\n             */\n\n            cpu_physical_memory_read(s->tx_desc_addr,\n\n                                     (uint8_t *)&desc[0], sizeof(desc));\n\n            tx_desc_set_used(desc);\n\n            cpu_physical_memory_write(s->tx_desc_addr,\n\n                                      (uint8_t *)&desc[0], sizeof(desc));\n\n            /* Advance the hardare current descriptor past this packet */\n\n            if (tx_desc_get_wrap(desc)) {\n\n                s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n            } else {\n\n                s->tx_desc_addr = packet_desc_addr + 8;\n\n            }\n\n            DB_PRINT(\"TX descriptor next: 0x%08x\\n\", s->tx_desc_addr);\n\n\n\n            s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;\n\n\n\n            /* Handle interrupt consequences */\n\n            gem_update_int_status(s);\n\n\n\n            /* Is checksum offload enabled? */\n\n            if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {\n\n                net_checksum_calculate(tx_packet, total_bytes);\n\n            }\n\n\n\n            /* Update MAC statistics */\n\n            gem_transmit_updatestats(s, tx_packet, total_bytes);\n\n\n\n            /* Send the packet somewhere */\n\n            if (s->phy_loop) {\n\n                gem_receive(&s->nic->nc, tx_packet, total_bytes);\n\n            } else {\n\n                qemu_send_packet(&s->nic->nc, tx_packet, total_bytes);\n\n            }\n\n\n\n            /* Prepare for next packet */\n\n            p = tx_packet;\n\n            total_bytes = 0;\n\n        }\n\n\n\n        /* read next descriptor */\n\n        if (tx_desc_get_wrap(desc)) {\n\n            packet_desc_addr = s->regs[GEM_TXQBASE];\n\n        } else {\n\n            packet_desc_addr += 8;\n\n        }\n\n        cpu_physical_memory_read(packet_desc_addr,\n\n                                 (uint8_t *)&desc[0], sizeof(desc));\n\n    }\n\n\n\n    if (tx_desc_get_used(desc)) {\n\n        s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;\n\n        gem_update_int_status(s);\n\n    }\n\n}\n", "idx": 789}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static void rx_init_frame(eTSEC *etsec, const uint8_t *buf, size_t size)\n\n{\n\n    uint32_t fcb_size = 0;\n\n    uint8_t  prsdep   = (etsec->regs[RCTRL].value >> RCTRL_PRSDEP_OFFSET)\n\n        & RCTRL_PRSDEP_MASK;\n\n\n\n    if (prsdep != 0) {\n\n        /* Prepend FCB (FCB size + RCTRL[PAL]) */\n\n        fcb_size = 8 + ((etsec->regs[RCTRL].value >> 16) & 0x1F);\n\n\n\n        etsec->rx_fcb_size = fcb_size;\n\n\n\n        /* TODO: fill_FCB(etsec); */\n\n        memset(etsec->rx_fcb, 0x0, sizeof(etsec->rx_fcb));\n\n\n\n    } else {\n\n        etsec->rx_fcb_size = 0;\n\n    }\n\n\n\n    if (etsec->rx_buffer != NULL) {\n\n        g_free(etsec->rx_buffer);\n\n    }\n\n\n\n    /* Do not copy the frame for now */\n\n    etsec->rx_buffer     = (uint8_t *)buf;\n\n    etsec->rx_buffer_len = size;\n\n\n\n    /* CRC padding (We don't have to compute the CRC) */\n\n    etsec->rx_padding = 4;\n\n\n\n    etsec->rx_first_in_frame = 1;\n\n    etsec->rx_remaining_data = etsec->rx_buffer_len;\n\n    RING_DEBUG(\"%s: rx_buffer_len:%u rx_padding+crc:%u\\n\", __func__,\n\n               etsec->rx_buffer_len, etsec->rx_padding);\n\n}\n", "idx": 790}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static uint32_t qpci_spapr_io_readl(QPCIBus *bus, void *addr)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    uint32_t v;\n\n    if (port < s->pio.size) {\n\n        v = readl(s->pio_cpu_base + port);\n\n    } else {\n\n        v = readl(s->mmio_cpu_base + port);\n\n    }\n\n    return bswap32(v);\n\n}\n", "idx": 791}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "void cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)\n\n{\n\n#if defined(TARGET_MIPS) || defined(TARGET_SH4)\n\n    CPUArchState *env = cpu->env_ptr;\n\n#endif\n\n    TranslationBlock *tb;\n\n    uint32_t n, cflags;\n\n    target_ulong pc, cs_base;\n\n    uint32_t flags;\n\n\n\n    tb_lock();\n\n    tb = tb_find_pc(retaddr);\n\n    if (!tb) {\n\n        cpu_abort(cpu, \"cpu_io_recompile: could not find TB for pc=%p\",\n\n                  (void *)retaddr);\n\n    }\n\n    n = cpu->icount_decr.u16.low + tb->icount;\n\n    cpu_restore_state_from_tb(cpu, tb, retaddr);\n\n    /* Calculate how many instructions had been executed before the fault\n\n       occurred.  */\n\n    n = n - cpu->icount_decr.u16.low;\n\n    /* Generate a new TB ending on the I/O insn.  */\n\n    n++;\n\n    /* On MIPS and SH, delay slot instructions can only be restarted if\n\n       they were already the first instruction in the TB.  If this is not\n\n       the first instruction in a TB then re-execute the preceding\n\n       branch.  */\n\n#if defined(TARGET_MIPS)\n\n    if ((env->hflags & MIPS_HFLAG_BMASK) != 0 && n > 1) {\n\n        env->active_tc.PC -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);\n\n        cpu->icount_decr.u16.low++;\n\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n\n    }\n\n#elif defined(TARGET_SH4)\n\n    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0\n\n            && n > 1) {\n\n        env->pc -= 2;\n\n        cpu->icount_decr.u16.low++;\n\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n\n    }\n\n#endif\n\n    /* This should never happen.  */\n\n    if (n > CF_COUNT_MASK) {\n\n        cpu_abort(cpu, \"TB too big during recompile\");\n\n    }\n\n\n\n    cflags = n | CF_LAST_IO;\n\n    cflags |= curr_cflags();\n\n    pc = tb->pc;\n\n    cs_base = tb->cs_base;\n\n    flags = tb->flags;\n\n    tb_phys_invalidate(tb, -1);\n\n    if (tb->cflags & CF_NOCACHE) {\n\n        if (tb->orig_tb) {\n\n            /* Invalidate original TB if this TB was generated in\n\n             * cpu_exec_nocache() */\n\n            tb_phys_invalidate(tb->orig_tb, -1);\n\n        }\n\n        tb_free(tb);\n\n    }\n\n    /* FIXME: In theory this could raise an exception.  In practice\n\n       we have already translated the block once so it's probably ok.  */\n\n    tb_gen_code(cpu, pc, cs_base, flags, cflags);\n\n\n\n    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not\n\n     * the first in the TB) then we end up generating a whole new TB and\n\n     *  repeating the fault, which is horribly inefficient.\n\n     *  Better would be to execute just this insn uncached, or generate a\n\n     *  second new TB.\n\n     *\n\n     * cpu_loop_exit_noexc will longjmp back to cpu_exec where the\n\n     * tb_lock gets reset.\n\n     */\n\n    cpu_loop_exit_noexc(cpu);\n\n}\n", "idx": 792}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(unterminated_array)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32\");\n\n    fail_unless(obj == NULL);\n\n}\n", "idx": 793}
{"project": "qemu", "commit_id": "ccdb81d3274d281d770703417257bd40bcdf4c0e", "target": 0, "func": "static void imx_fec_reset(DeviceState *d)\n\n{\n\n    IMXFECState *s = IMX_FEC(d);\n\n\n\n    /* Reset the FEC */\n\n    s->eir = 0;\n\n    s->eimr = 0;\n\n    s->rx_enabled = 0;\n\n    s->ecr = 0;\n\n    s->mscr = 0;\n\n    s->mibc = 0xc0000000;\n\n    s->rcr = 0x05ee0001;\n\n    s->tcr = 0;\n\n    s->tfwr = 0;\n\n    s->frsr = 0x500;\n\n    s->miigsk_cfgr = 0;\n\n    s->miigsk_enr = 0x6;\n\n\n\n    /* We also reset the PHY */\n\n    phy_reset(s);\n\n}\n", "idx": 796}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irq(omap_mmc_cover_cb, s, 0);\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 798}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int vmstate_register(int instance_id, const VMStateDescription *vmsd,\n\n                     void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    pstrcpy(se->idstr, sizeof(se->idstr), vmsd->name);\n\n    se->version_id = vmsd->version_id;\n\n    se->section_id = global_section_id++;\n\n    se->save_live_state = NULL;\n\n    se->save_state = NULL;\n\n    se->load_state = NULL;\n\n    se->opaque = opaque;\n\n    se->vmsd = vmsd;\n\n\n\n    if (instance_id == -1) {\n\n        se->instance_id = calculate_new_instance_id(vmsd->name);\n\n    } else {\n\n        se->instance_id = instance_id;\n\n    }\n\n    /* add at the end of list */\n\n    TAILQ_INSERT_TAIL(&savevm_handlers, se, entry);\n\n    return 0;\n\n}\n", "idx": 799}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool qemu_clock_expired(QEMUClockType type)\n\n{\n\n    return timerlist_expired(\n\n        main_loop_tlg.tl[type]);\n\n}\n", "idx": 800}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int serrno, fd;\n\n\n\n    fs->dir = NULL;\n\n    fd = v9fs_request(ctx->private, T_OPEN, NULL, \"sd\", fs_path, O_DIRECTORY);\n\n    if (fd < 0) {\n\n        errno = -fd;\n\n        return -1;\n\n    }\n\n    fs->dir = fdopendir(fd);\n\n    if (!fs->dir) {\n\n        serrno = errno;\n\n        close(fd);\n\n        errno = serrno;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 801}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static sd_rsp_type_t sd_normal_command(SDState *sd,\n\n                                       SDRequest req)\n\n{\n\n    uint32_t rca = 0x0000;\n\n    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;\n\n\n\n    /* Not interpreting this as an app command */\n\n    sd->card_status &= ~APP_CMD;\n\n\n\n    if (sd_cmd_type[req.cmd] == sd_ac || sd_cmd_type[req.cmd] == sd_adtc)\n\n        rca = req.arg >> 16;\n\n\n\n    DPRINTF(\"CMD%d 0x%08x state %d\\n\", req.cmd, req.arg, sd->state);\n\n    switch (req.cmd) {\n\n    /* Basic commands (Class 0 and Class 1) */\n\n    case 0:\t/* CMD0:   GO_IDLE_STATE */\n\n        switch (sd->state) {\n\n        case sd_inactive_state:\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n\n\n        default:\n\n            sd->state = sd_idle_state;\n\n            sd_reset(sd, sd->bdrv);\n\n            return sd->spi ? sd_r1 : sd_r0;\n\n        }\n\n        break;\n\n\n\n    case 1:\t/* CMD1:   SEND_OP_CMD */\n\n        if (!sd->spi)\n\n            goto bad_cmd;\n\n\n\n        sd->state = sd_transfer_state;\n\n        return sd_r1;\n\n\n\n    case 2:\t/* CMD2:   ALL_SEND_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_ready_state:\n\n            sd->state = sd_identification_state;\n\n            return sd_r2_i;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3:\t/* CMD3:   SEND_RELATIVE_ADDR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_identification_state:\n\n        case sd_standby_state:\n\n            sd->state = sd_standby_state;\n\n            sd_set_rca(sd);\n\n            return sd_r6;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4:\t/* CMD4:   SEND_DSR */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            break;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 5: /* CMD5: reserved for SDIO cards */\n\n        return sd_illegal;\n\n\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            sd_function_switch(sd, req.arg);\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 7:\t/* CMD7:   SELECT/DESELECT_CARD */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_transfer_state:\n\n        case sd_sendingdata_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_standby_state;\n\n            return sd_r1b;\n\n\n\n        case sd_disconnect_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_programming_state;\n\n            return sd_r1b;\n\n\n\n        case sd_programming_state:\n\n            if (sd->rca == rca)\n\n                break;\n\n\n\n            sd->state = sd_disconnect_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 8:\t/* CMD8:   SEND_IF_COND */\n\n        /* Physical Layer Specification Version 2.00 command */\n\n        switch (sd->state) {\n\n        case sd_idle_state:\n\n            sd->vhs = 0;\n\n\n\n            /* No response if not exactly one VHS bit is set.  */\n\n            if (!(req.arg >> 8) || (req.arg >> ffs(req.arg & ~0xff)))\n\n                return sd->spi ? sd_r7 : sd_r0;\n\n\n\n            /* Accept.  */\n\n            sd->vhs = req.arg;\n\n            return sd_r7;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_s;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->csd, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        switch (sd->state) {\n\n        case sd_standby_state:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r2_i;\n\n\n\n        case sd_transfer_state:\n\n            if (!sd->spi)\n\n                break;\n\n            sd->state = sd_sendingdata_state;\n\n            memcpy(sd->data, sd->cid, 16);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = req.arg;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 12:\t/* CMD12:  STOP_TRANSMISSION */\n\n        switch (sd->state) {\n\n        case sd_sendingdata_state:\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        case sd_receivingdata_state:\n\n            sd->state = sd_programming_state;\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* CMD13:  SEND_STATUS */\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 15:\t/* CMD15:  GO_INACTIVE_STATE */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->mode) {\n\n        case sd_data_transfer_mode:\n\n            if (sd->rca != rca)\n\n                return sd_r0;\n\n\n\n            sd->state = sd_inactive_state;\n\n            return sd_r0;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block read commands (Classs 2) */\n\n    case 16:\t/* CMD16:  SET_BLOCKLEN */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (req.arg > (1 << HWBLOCK_SHIFT))\n\n                sd->card_status |= BLOCK_LEN_ERROR;\n\n            else\n\n                sd->blk_len = req.arg;\n\n\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Block write commands (Class 4) */\n\n    case 24:\t/* CMD24:  WRITE_SINGLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 25:\t/* CMD25:  WRITE_MULTIPLE_BLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            /* Writing in SPI mode not implemented.  */\n\n            if (sd->spi)\n\n                break;\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            sd->blk_written = 0;\n\n\n\n            if (sd->data_start + sd->blk_len > sd->size)\n\n                sd->card_status |= ADDRESS_ERROR;\n\n            if (sd_wp_addr(sd, sd->data_start))\n\n                sd->card_status |= WP_VIOLATION;\n\n            if (sd->csd[14] & 0x30)\n\n                sd->card_status |= WP_VIOLATION;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 26:\t/* CMD26:  PROGRAM_CID */\n\n        if (sd->spi)\n\n            goto bad_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 27:\t/* CMD27:  PROGRAM_CSD */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Write protection (Class 6) */\n\n    case 28:\t/* CMD28:  SET_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            set_bit(sd_addr_to_wpnum(addr), sd->wp_groups);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 29:\t/* CMD29:  CLR_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (addr >= sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            clear_bit(sd_addr_to_wpnum(addr), sd->wp_groups);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_sendingdata_state;\n\n            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);\n\n            sd->data_start = addr;\n\n            sd->data_offset = 0;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Erase commands (Class 5) */\n\n    case 32:\t/* CMD32:  ERASE_WR_BLK_START */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_start = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 33:\t/* CMD33:  ERASE_WR_BLK_END */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->erase_end = req.arg;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 38:\t/* CMD38:  ERASE */\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            if (sd->csd[14] & 0x30) {\n\n                sd->card_status |= WP_VIOLATION;\n\n                return sd_r1b;\n\n            }\n\n\n\n            sd->state = sd_programming_state;\n\n            sd_erase(sd);\n\n            /* Bzzzzzzztt .... Operation complete.  */\n\n            sd->state = sd_transfer_state;\n\n            return sd_r1b;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    /* Lock card commands (Class 7) */\n\n    case 42:\t/* CMD42:  LOCK_UNLOCK */\n\n        if (sd->spi)\n\n            goto unimplemented_cmd;\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->state = sd_receivingdata_state;\n\n            sd->data_start = 0;\n\n            sd->data_offset = 0;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 52:\n\n    case 53:\n\n        /* CMD52, CMD53: reserved for SDIO cards\n\n         * (see the SDIO Simplified Specification V2.0)\n\n         * Handle as illegal command but do not complain\n\n         * on stderr, as some OSes may use these in their\n\n         * probing for presence of an SDIO card.\n\n         */\n\n        return sd_illegal;\n\n\n\n    /* Application specific commands (Class 8) */\n\n    case 55:\t/* CMD55:  APP_CMD */\n\n        if (sd->rca != rca)\n\n            return sd_r0;\n\n\n\n        sd->expecting_acmd = true;\n\n        sd->card_status |= APP_CMD;\n\n        return sd_r1;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        fprintf(stderr, \"SD: GEN_CMD 0x%08x\\n\", req.arg);\n\n\n\n        switch (sd->state) {\n\n        case sd_transfer_state:\n\n            sd->data_offset = 0;\n\n            if (req.arg & 1)\n\n                sd->state = sd_sendingdata_state;\n\n            else\n\n                sd->state = sd_receivingdata_state;\n\n            return sd_r1;\n\n\n\n        default:\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    bad_cmd:\n\n        fprintf(stderr, \"SD: Unknown CMD%i\\n\", req.cmd);\n\n        return sd_illegal;\n\n\n\n    unimplemented_cmd:\n\n        /* Commands that are recognised but not yet implemented in SPI mode.  */\n\n        fprintf(stderr, \"SD: CMD%i not implemented in SPI mode\\n\", req.cmd);\n\n        return sd_illegal;\n\n    }\n\n\n\n    fprintf(stderr, \"SD: CMD%i in a wrong state\\n\", req.cmd);\n\n    return sd_illegal;\n\n}\n", "idx": 802}
{"project": "qemu", "commit_id": "d9429b84af2302b6e28bec3c52710cf67eda3cee", "target": 0, "func": "static void amdvi_mmio_trace(hwaddr addr, unsigned size)\n\n{\n\n    uint8_t index = (addr & ~0x2000) / 8;\n\n\n\n    if ((addr & 0x2000)) {\n\n        /* high table */\n\n        index = index >= AMDVI_MMIO_REGS_HIGH ? AMDVI_MMIO_REGS_HIGH : index;\n\n        trace_amdvi_mmio_read(amdvi_mmio_high[index], addr, size, addr & ~0x07);\n\n    } else {\n\n        index = index >= AMDVI_MMIO_REGS_LOW ? AMDVI_MMIO_REGS_LOW : index;\n\n        trace_amdvi_mmio_read(amdvi_mmio_high[index], addr, size, addr & ~0x07);\n\n    }\n\n}\n", "idx": 803}
{"project": "qemu", "commit_id": "c611c76417f52b335ecaab01c61743e3b705eb7c", "target": 0, "func": "void virtio_cleanup(VirtIODevice *vdev)\n\n{\n\n    qemu_del_vm_change_state_handler(vdev->vmstate);\n\n    g_free(vdev->config);\n\n    g_free(vdev->vq);\n\n    g_free(vdev->vector_queues);\n\n}\n", "idx": 804}
{"project": "qemu", "commit_id": "b00c72180c36510bf9b124e190bd520e3b7e1358", "target": 0, "func": "static void gen_pool32axf (CPUMIPSState *env, DisasContext *ctx, int rt, int rs)\n\n{\n\n    int extension = (ctx->opcode >> 6) & 0x3f;\n\n    int minor = (ctx->opcode >> 12) & 0xf;\n\n    uint32_t mips32_op;\n\n\n\n    switch (extension) {\n\n    case TEQ:\n\n        mips32_op = OPC_TEQ;\n\n        goto do_trap;\n\n    case TGE:\n\n        mips32_op = OPC_TGE;\n\n        goto do_trap;\n\n    case TGEU:\n\n        mips32_op = OPC_TGEU;\n\n        goto do_trap;\n\n    case TLT:\n\n        mips32_op = OPC_TLT;\n\n        goto do_trap;\n\n    case TLTU:\n\n        mips32_op = OPC_TLTU;\n\n        goto do_trap;\n\n    case TNE:\n\n        mips32_op = OPC_TNE;\n\n    do_trap:\n\n        gen_trap(ctx, mips32_op, rs, rt, -1);\n\n        break;\n\n#ifndef CONFIG_USER_ONLY\n\n    case MFC0:\n\n    case MFC0 + 32:\n\n        check_cp0_enabled(ctx);\n\n        if (rt == 0) {\n\n            /* Treat as NOP. */\n\n            break;\n\n        }\n\n        gen_mfc0(ctx, cpu_gpr[rt], rs, (ctx->opcode >> 11) & 0x7);\n\n        break;\n\n    case MTC0:\n\n    case MTC0 + 32:\n\n        check_cp0_enabled(ctx);\n\n        {\n\n            TCGv t0 = tcg_temp_new();\n\n\n\n            gen_load_gpr(t0, rt);\n\n            gen_mtc0(ctx, t0, rs, (ctx->opcode >> 11) & 0x7);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x2a:\n\n        switch (minor & 3) {\n\n        case MADD_ACC:\n\n            gen_muldiv(ctx, OPC_MADD, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        case MADDU_ACC:\n\n            gen_muldiv(ctx, OPC_MADDU, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        case MSUB_ACC:\n\n            gen_muldiv(ctx, OPC_MSUB, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        case MSUBU_ACC:\n\n            gen_muldiv(ctx, OPC_MSUBU, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x32:\n\n        switch (minor & 3) {\n\n        case MULT_ACC:\n\n            gen_muldiv(ctx, OPC_MULT, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        case MULTU_ACC:\n\n            gen_muldiv(ctx, OPC_MULTU, (ctx->opcode >> 14) & 3, rs, rt);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x2c:\n\n        switch (minor) {\n\n        case BITSWAP:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            gen_bitswap(ctx, OPC_BITSWAP, rs, rt);\n\n            break;\n\n        case SEB:\n\n            gen_bshfl(ctx, OPC_SEB, rs, rt);\n\n            break;\n\n        case SEH:\n\n            gen_bshfl(ctx, OPC_SEH, rs, rt);\n\n            break;\n\n        case CLO:\n\n            mips32_op = OPC_CLO;\n\n            goto do_cl;\n\n        case CLZ:\n\n            mips32_op = OPC_CLZ;\n\n        do_cl:\n\n            check_insn(ctx, ISA_MIPS32);\n\n            gen_cl(ctx, mips32_op, rt, rs);\n\n            break;\n\n        case RDHWR:\n\n            gen_rdhwr(ctx, rt, rs);\n\n            break;\n\n        case WSBH:\n\n            gen_bshfl(ctx, OPC_WSBH, rs, rt);\n\n            break;\n\n        case MULT:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MULT;\n\n            goto do_mul;\n\n        case MULTU:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MULTU;\n\n            goto do_mul;\n\n        case DIV:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_DIV;\n\n            goto do_div;\n\n        case DIVU:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_DIVU;\n\n            goto do_div;\n\n        do_div:\n\n            check_insn(ctx, ISA_MIPS32);\n\n            gen_muldiv(ctx, mips32_op, 0, rs, rt);\n\n            break;\n\n        case MADD:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MADD;\n\n            goto do_mul;\n\n        case MADDU:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MADDU;\n\n            goto do_mul;\n\n        case MSUB:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MSUB;\n\n            goto do_mul;\n\n        case MSUBU:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            mips32_op = OPC_MSUBU;\n\n        do_mul:\n\n            check_insn(ctx, ISA_MIPS32);\n\n            gen_muldiv(ctx, mips32_op, 0, rs, rt);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x34:\n\n        switch (minor) {\n\n        case MFC2:\n\n        case MTC2:\n\n        case MFHC2:\n\n        case MTHC2:\n\n        case CFC2:\n\n        case CTC2:\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x3c:\n\n        switch (minor) {\n\n        case JALR:    /* JALRC */\n\n        case JALR_HB: /* JALRC_HB */\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                /* JALRC, JALRC_HB */\n\n                gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 0);\n\n            } else {\n\n                /* JALR, JALR_HB */\n\n                gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 4);\n\n                ctx->hflags |= MIPS_HFLAG_BDS_STRICT;\n\n            }\n\n            break;\n\n        case JALRS:\n\n        case JALRS_HB:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 2);\n\n            ctx->hflags |= MIPS_HFLAG_BDS_STRICT;\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x05:\n\n        switch (minor) {\n\n        case RDPGPR:\n\n            check_cp0_enabled(ctx);\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rs, rt);\n\n            break;\n\n        case WRPGPR:\n\n            check_cp0_enabled(ctx);\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rs, rt);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n#ifndef CONFIG_USER_ONLY\n\n    case 0x0d:\n\n        switch (minor) {\n\n        case TLBP:\n\n            mips32_op = OPC_TLBP;\n\n            goto do_cp0;\n\n        case TLBR:\n\n            mips32_op = OPC_TLBR;\n\n            goto do_cp0;\n\n        case TLBWI:\n\n            mips32_op = OPC_TLBWI;\n\n            goto do_cp0;\n\n        case TLBWR:\n\n            mips32_op = OPC_TLBWR;\n\n            goto do_cp0;\n\n        case TLBINV:\n\n            mips32_op = OPC_TLBINV;\n\n            goto do_cp0;\n\n        case TLBINVF:\n\n            mips32_op = OPC_TLBINVF;\n\n            goto do_cp0;\n\n        case WAIT:\n\n            mips32_op = OPC_WAIT;\n\n            goto do_cp0;\n\n        case DERET:\n\n            mips32_op = OPC_DERET;\n\n            goto do_cp0;\n\n        case ERET:\n\n            mips32_op = OPC_ERET;\n\n        do_cp0:\n\n            gen_cp0(env, ctx, mips32_op, rt, rs);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x1d:\n\n        switch (minor) {\n\n        case DI:\n\n            check_cp0_enabled(ctx);\n\n            {\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                save_cpu_state(ctx, 1);\n\n                gen_helper_di(t0, cpu_env);\n\n                gen_store_gpr(t0, rs);\n\n                /* Stop translation as we may have switched the execution mode */\n\n                ctx->bstate = BS_STOP;\n\n                tcg_temp_free(t0);\n\n            }\n\n            break;\n\n        case EI:\n\n            check_cp0_enabled(ctx);\n\n            {\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                save_cpu_state(ctx, 1);\n\n                gen_helper_ei(t0, cpu_env);\n\n                gen_store_gpr(t0, rs);\n\n                /* Stop translation as we may have switched the execution mode */\n\n                ctx->bstate = BS_STOP;\n\n                tcg_temp_free(t0);\n\n            }\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n#endif\n\n    case 0x2d:\n\n        switch (minor) {\n\n        case SYNC:\n\n            /* NOP */\n\n            break;\n\n        case SYSCALL:\n\n            generate_exception_end(ctx, EXCP_SYSCALL);\n\n            break;\n\n        case SDBBP:\n\n            if (is_uhi(extract32(ctx->opcode, 16, 10))) {\n\n                gen_helper_do_semihosting(cpu_env);\n\n            } else {\n\n                check_insn(ctx, ISA_MIPS32);\n\n                if (ctx->hflags & MIPS_HFLAG_SBRI) {\n\n                    generate_exception_end(ctx, EXCP_RI);\n\n                } else {\n\n                    generate_exception_end(ctx, EXCP_DBp);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x01:\n\n        switch (minor & 3) {\n\n        case MFHI_ACC:\n\n            gen_HILO(ctx, OPC_MFHI, minor >> 2, rs);\n\n            break;\n\n        case MFLO_ACC:\n\n            gen_HILO(ctx, OPC_MFLO, minor >> 2, rs);\n\n            break;\n\n        case MTHI_ACC:\n\n            gen_HILO(ctx, OPC_MTHI, minor >> 2, rs);\n\n            break;\n\n        case MTLO_ACC:\n\n            gen_HILO(ctx, OPC_MTLO, minor >> 2, rs);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    case 0x35:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        switch (minor) {\n\n        case MFHI32:\n\n            gen_HILO(ctx, OPC_MFHI, 0, rs);\n\n            break;\n\n        case MFLO32:\n\n            gen_HILO(ctx, OPC_MFLO, 0, rs);\n\n            break;\n\n        case MTHI32:\n\n            gen_HILO(ctx, OPC_MTHI, 0, rs);\n\n            break;\n\n        case MTLO32:\n\n            gen_HILO(ctx, OPC_MTLO, 0, rs);\n\n            break;\n\n        default:\n\n            goto pool32axf_invalid;\n\n        }\n\n        break;\n\n    default:\n\n    pool32axf_invalid:\n\n        MIPS_INVAL(\"pool32axf\");\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 805}
{"project": "FFmpeg", "commit_id": "2f300f8965793c3bb9f9d753fcd4542f94f4c58a", "target": 0, "func": "void ff_fix_long_mvs(MpegEncContext * s, uint8_t *field_select_table, int field_select, \n\n                     int16_t (*mv_table)[2], int f_code, int type, int truncate)\n\n{\n\n    MotionEstContext * const c= &s->me;\n\n    int y, h_range, v_range;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->out_format == FMT_MPEG1) ? 8 : 16) << f_code);\n\n\n\n    if(s->msmpeg4_version) range= 16;\n\n    if(c->avctx->me_range && range > c->avctx->me_range) range= c->avctx->me_range;\n\n\n\n    h_range= range;\n\n    v_range= field_select_table ? range>>1 : range;\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= y*s->mb_stride;\n\n        for(x=0; x<s->mb_width; x++){\n\n            if (s->mb_type[xy] & type){    // RAL: \"type\" test added...\n\n                if(field_select_table==NULL || field_select_table[xy] == field_select){\n\n                    if(   mv_table[xy][0] >=h_range || mv_table[xy][0] <-h_range\n\n                       || mv_table[xy][1] >=v_range || mv_table[xy][1] <-v_range){\n\n\n\n                        if(truncate){\n\n                            if     (mv_table[xy][0] > h_range-1) mv_table[xy][0]=  h_range-1;\n\n                            else if(mv_table[xy][0] < -h_range ) mv_table[xy][0]= -h_range;\n\n                            if     (mv_table[xy][1] > v_range-1) mv_table[xy][1]=  v_range-1;\n\n                            else if(mv_table[xy][1] < -v_range ) mv_table[xy][1]= -v_range;\n\n                        }else{\n\n                            s->mb_type[xy] &= ~type;\n\n                            s->mb_type[xy] |= CANDIDATE_MB_TYPE_INTRA;\n\n                            mv_table[xy][0]=\n\n                            mv_table[xy][1]= 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            xy++;\n\n        }\n\n    }\n\n}\n", "idx": 806}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "ThreadPool *thread_pool_new(AioContext *ctx)\n\n{\n\n    ThreadPool *pool = g_new(ThreadPool, 1);\n\n    thread_pool_init_one(pool, ctx);\n\n    return pool;\n\n}\n", "idx": 807}
{"project": "qemu", "commit_id": "4e9e9d6e0a68f1691bcdcc80601a9a1bc2954736", "target": 0, "func": "static int parse_bootdevices(char *devices)\n\n{\n\n    /* We just do some generic consistency checks */\n\n    const char *p;\n\n    int bitmap = 0;\n\n\n\n    for (p = devices; *p != '\\0'; p++) {\n\n        /* Allowed boot devices are:\n\n         * a-b: floppy disk drives\n\n         * c-f: IDE disk drives\n\n         * g-m: machine implementation dependant drives\n\n         * n-p: network devices\n\n         * It's up to each machine implementation to check if the given boot\n\n         * devices match the actual hardware implementation and firmware\n\n         * features.\n\n         */\n\n        if (*p < 'a' || *p > 'p') {\n\n            fprintf(stderr, \"Invalid boot device '%c'\\n\", *p);\n\n            exit(1);\n\n        }\n\n        if (bitmap & (1 << (*p - 'a'))) {\n\n            fprintf(stderr, \"Boot device '%c' was given twice\\n\", *p);\n\n            exit(1);\n\n        }\n\n        bitmap |= 1 << (*p - 'a');\n\n    }\n\n    return bitmap;\n\n}\n", "idx": 808}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGCond cond, TCGReg arg1,\n\n                           TCGReg arg2, int label_index)\n\n{\n\n    static const MIPSInsn b_zero[16] = {\n\n        [TCG_COND_LT] = OPC_BLTZ,\n\n        [TCG_COND_GT] = OPC_BGTZ,\n\n        [TCG_COND_LE] = OPC_BLEZ,\n\n        [TCG_COND_GE] = OPC_BGEZ,\n\n    };\n\n\n\n    TCGLabel *l;\n\n    MIPSInsn s_opc = OPC_SLTU;\n\n    MIPSInsn b_opc;\n\n    int cmp_map;\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n        b_opc = OPC_BEQ;\n\n        break;\n\n    case TCG_COND_NE:\n\n        b_opc = OPC_BNE;\n\n        break;\n\n\n\n    case TCG_COND_LT:\n\n    case TCG_COND_GT:\n\n    case TCG_COND_LE:\n\n    case TCG_COND_GE:\n\n        if (arg2 == 0) {\n\n            b_opc = b_zero[cond];\n\n            arg2 = arg1;\n\n            arg1 = 0;\n\n            break;\n\n        }\n\n        s_opc = OPC_SLT;\n\n        /* FALLTHRU */\n\n\n\n    case TCG_COND_LTU:\n\n    case TCG_COND_GTU:\n\n    case TCG_COND_LEU:\n\n    case TCG_COND_GEU:\n\n        cmp_map = mips_cmp_map[cond];\n\n        if (cmp_map & MIPS_CMP_SWAP) {\n\n            TCGReg t = arg1;\n\n            arg1 = arg2;\n\n            arg2 = t;\n\n        }\n\n        tcg_out_opc_reg(s, s_opc, TCG_TMP0, arg1, arg2);\n\n        b_opc = (cmp_map & MIPS_CMP_INV ? OPC_BEQ : OPC_BNE);\n\n        arg1 = TCG_TMP0;\n\n        arg2 = TCG_REG_ZERO;\n\n        break;\n\n\n\n    default:\n\n        tcg_abort();\n\n        break;\n\n    }\n\n\n\n    tcg_out_opc_br(s, b_opc, arg1, arg2);\n\n    l = &s->labels[label_index];\n\n    if (l->has_value) {\n\n        reloc_pc16(s->code_ptr - 1, l->u.value_ptr);\n\n    } else {\n\n        tcg_out_reloc(s, s->code_ptr - 1, R_MIPS_PC16, label_index, 0);\n\n    }\n\n    tcg_out_nop(s);\n\n}\n", "idx": 809}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_rp(DisasContext *dc)\n\n{\n\n\tTCGv t[2];\n\n\tDIS(fprintf (logfile, \"move $r%u, $p%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tt[0] = tcg_temp_new(TCG_TYPE_TL);\n\n\tif (dc->op2 == PR_CCS) {\n\n\t\tcris_evaluate_flags(dc);\n\n\t\tt_gen_mov_TN_reg(t[0], dc->op1);\n\n\t\tif (dc->tb_flags & U_FLAG) {\n\n\t\t\tt[1] = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t/* User space is not allowed to touch all flags.  */\n\n\t\t\ttcg_gen_andi_tl(t[0], t[0], 0x39f);\n\n\t\t\ttcg_gen_andi_tl(t[1], cpu_PR[PR_CCS], ~0x39f);\n\n\t\t\ttcg_gen_or_tl(t[0], t[1], t[0]);\n\n\t\t\ttcg_temp_free(t[1]);\n\n\t\t}\n\n\t}\n\n\telse\n\n\t\tt_gen_mov_TN_reg(t[0], dc->op1);\n\n\n\n\tt_gen_mov_preg_TN(dc, dc->op2, t[0]);\n\n\tif (dc->op2 == PR_CCS) {\n\n\t\tcris_update_cc_op(dc, CC_OP_FLAGS, 4);\n\n\t\tdc->flags_uptodate = 1;\n\n\t}\n\n\ttcg_temp_free(t[0]);\n\n\treturn 2;\n\n}\n", "idx": 810}
{"project": "qemu", "commit_id": "ad6919dc0ab3b8ae26d772e883aa8e709785d249", "target": 0, "func": "static uint32_t get_elf_hwcap(void)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(thread_cpu);\n\n    uint32_t hwcaps = 0;\n\n\n\n    hwcaps |= ARM_HWCAP_ARM_SWP;\n\n    hwcaps |= ARM_HWCAP_ARM_HALF;\n\n    hwcaps |= ARM_HWCAP_ARM_THUMB;\n\n    hwcaps |= ARM_HWCAP_ARM_FAST_MULT;\n\n\n\n    /* probe for the extra features */\n\n#define GET_FEATURE(feat, hwcap) \\\n\n    do { if (arm_feature(&cpu->env, feat)) { hwcaps |= hwcap; } } while (0)\n\n    /* EDSP is in v5TE and above, but all our v5 CPUs are v5TE */\n\n    GET_FEATURE(ARM_FEATURE_V5, ARM_HWCAP_ARM_EDSP);\n\n    GET_FEATURE(ARM_FEATURE_VFP, ARM_HWCAP_ARM_VFP);\n\n    GET_FEATURE(ARM_FEATURE_IWMMXT, ARM_HWCAP_ARM_IWMMXT);\n\n    GET_FEATURE(ARM_FEATURE_THUMB2EE, ARM_HWCAP_ARM_THUMBEE);\n\n    GET_FEATURE(ARM_FEATURE_NEON, ARM_HWCAP_ARM_NEON);\n\n    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPv3);\n\n    GET_FEATURE(ARM_FEATURE_V6K, ARM_HWCAP_ARM_TLS);\n\n    GET_FEATURE(ARM_FEATURE_VFP4, ARM_HWCAP_ARM_VFPv4);\n\n    GET_FEATURE(ARM_FEATURE_ARM_DIV, ARM_HWCAP_ARM_IDIVA);\n\n    GET_FEATURE(ARM_FEATURE_THUMB_DIV, ARM_HWCAP_ARM_IDIVT);\n\n    /* All QEMU's VFPv3 CPUs have 32 registers, see VFP_DREG in translate.c.\n\n     * Note that the ARM_HWCAP_ARM_VFPv3D16 bit is always the inverse of\n\n     * ARM_HWCAP_ARM_VFPD32 (and so always clear for QEMU); it is unrelated\n\n     * to our VFP_FP16 feature bit.\n\n     */\n\n    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPD32);\n\n    GET_FEATURE(ARM_FEATURE_LPAE, ARM_HWCAP_ARM_LPAE);\n\n#undef GET_FEATURE\n\n\n\n    return hwcaps;\n\n}\n", "idx": 811}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint64(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U64);\n\n}\n", "idx": 812}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_flush(BlockDriverState *bs,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_flush(bs, opaque);\n\n\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, bs, cb, opaque);\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n\n\n    co = qemu_coroutine_create(bdrv_aio_flush_co_entry);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 813}
{"project": "qemu", "commit_id": "7d08c73e7bdc39b10e5f2f5acdce700f17ffe962", "target": 0, "func": "xmit_seg(E1000State *s)\n\n{\n\n    uint16_t len;\n\n    unsigned int frames = s->tx.tso_frames, css, sofar;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (tp->props.tse && tp->props.cptse) {\n\n        css = tp->props.ipcss;\n\n        DBGOUT(TXSUM, \"frames %d size %d ipcss %d\\n\",\n\n               frames, tp->size, css);\n\n        if (tp->props.ip) {    /* IPv4 */\n\n            stw_be_p(tp->data+css+2, tp->size - css);\n\n            stw_be_p(tp->data+css+4,\n\n                     lduw_be_p(tp->data + css + 4) + frames);\n\n        } else {         /* IPv6 */\n\n            stw_be_p(tp->data+css+4, tp->size - css);\n\n        }\n\n        css = tp->props.tucss;\n\n        len = tp->size - css;\n\n        DBGOUT(TXSUM, \"tcp %d tucss %d len %d\\n\", tp->props.tcp, css, len);\n\n        if (tp->props.tcp) {\n\n            sofar = frames * tp->props.mss;\n\n            stl_be_p(tp->data+css+4, ldl_be_p(tp->data+css+4)+sofar); /* seq */\n\n            if (tp->props.paylen - sofar > tp->props.mss) {\n\n                tp->data[css + 13] &= ~9;    /* PSH, FIN */\n\n            } else if (frames) {\n\n                e1000x_inc_reg_if_not_full(s->mac_reg, TSCTC);\n\n            }\n\n        } else    /* UDP */\n\n            stw_be_p(tp->data+css+4, len);\n\n        if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {\n\n            unsigned int phsum;\n\n            // add pseudo-header length before checksum calculation\n\n            void *sp = tp->data + tp->props.tucso;\n\n\n\n            phsum = lduw_be_p(sp) + len;\n\n            phsum = (phsum >> 16) + (phsum & 0xffff);\n\n            stw_be_p(sp, phsum);\n\n        }\n\n        tp->tso_frames++;\n\n    }\n\n\n\n    if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {\n\n        putsum(tp->data, tp->size, tp->props.tucso,\n\n               tp->props.tucss, tp->props.tucse);\n\n    }\n\n    if (tp->props.sum_needed & E1000_TXD_POPTS_IXSM) {\n\n        putsum(tp->data, tp->size, tp->props.ipcso,\n\n               tp->props.ipcss, tp->props.ipcse);\n\n    }\n\n    if (tp->vlan_needed) {\n\n        memmove(tp->vlan, tp->data, 4);\n\n        memmove(tp->data, tp->data + 4, 8);\n\n        memcpy(tp->data + 8, tp->vlan_header, 4);\n\n        e1000_send_packet(s, tp->vlan, tp->size + 4);\n\n    } else {\n\n        e1000_send_packet(s, tp->data, tp->size);\n\n    }\n\n\n\n    e1000x_inc_reg_if_not_full(s->mac_reg, TPT);\n\n    e1000x_grow_8reg_if_not_full(s->mac_reg, TOTL, s->tx.size);\n\n    s->mac_reg[GPTC] = s->mac_reg[TPT];\n\n    s->mac_reg[GOTCL] = s->mac_reg[TOTL];\n\n    s->mac_reg[GOTCH] = s->mac_reg[TOTH];\n\n}\n", "idx": 816}
{"project": "FFmpeg", "commit_id": "0846719dd11ab3f7a7caee13e7af71f71d913389", "target": 0, "func": "int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)\n\n{\n\n    int         mbn, blk, num_blocks, num_coeffs, blk_size, scan_pos, run, val,\n\n                pos, is_intra, mc_type, mv_x, mv_y, col_mask;\n\n    uint8_t     col_flags[8];\n\n    int32_t     prev_dc, trvec[64];\n\n    uint32_t    cbp, sym, lo, hi, quant, buf_offs, q;\n\n    IVIMbInfo   *mb;\n\n    RVMapDesc   *rvmap = band->rv_map;\n\n    void (*mc_with_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n\n    void (*mc_no_delta_func)  (int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n\n    const uint16_t  *base_tab;\n\n    const uint8_t   *scale_tab;\n\n\n\n    prev_dc = 0; /* init intra prediction for the DC coefficient */\n\n\n\n    blk_size   = band->blk_size;\n\n    col_mask   = blk_size - 1; /* column mask for tracking non-zero coeffs */\n\n    num_blocks = (band->mb_size != blk_size) ? 4 : 1; /* number of blocks per mb */\n\n    num_coeffs = blk_size * blk_size;\n\n    if (blk_size == 8) {\n\n        mc_with_delta_func = ff_ivi_mc_8x8_delta;\n\n        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;\n\n    } else {\n\n        mc_with_delta_func = ff_ivi_mc_4x4_delta;\n\n        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;\n\n    }\n\n\n\n    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {\n\n        is_intra = !mb->type;\n\n        cbp      = mb->cbp;\n\n        buf_offs = mb->buf_offs;\n\n\n\n        quant = av_clip(band->glob_quant + mb->q_delta, 0, 23);\n\n\n\n        base_tab  = is_intra ? band->intra_base  : band->inter_base;\n\n        scale_tab = is_intra ? band->intra_scale : band->inter_scale;\n\n        if (scale_tab)\n\n            quant = scale_tab[quant];\n\n\n\n        if (!is_intra) {\n\n            mv_x = mb->mv_x;\n\n            mv_y = mb->mv_y;\n\n            if (!band->is_halfpel) {\n\n                mc_type = 0; /* we have only fullpel vectors */\n\n            } else {\n\n                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);\n\n                mv_x >>= 1;\n\n                mv_y >>= 1; /* convert halfpel vectors into fullpel ones */\n\n            }\n\n        }\n\n\n\n        for (blk = 0; blk < num_blocks; blk++) {\n\n            /* adjust block position in the buffer according to its number */\n\n            if (blk & 1) {\n\n                buf_offs += blk_size;\n\n            } else if (blk == 2) {\n\n                buf_offs -= blk_size;\n\n                buf_offs += blk_size * band->pitch;\n\n            }\n\n\n\n            if (cbp & 1) { /* block coded ? */\n\n                scan_pos = -1;\n\n                memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n\n                memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n\n\n\n                while (scan_pos <= num_coeffs) {\n\n                    sym = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                    if (sym == rvmap->eob_sym)\n\n                        break; /* End of block */\n\n\n\n                    if (sym == rvmap->esc_sym) { /* Escape - run/val explicitly coded using 3 vlc codes */\n\n                        run = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1) + 1;\n\n                        lo  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                        hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                        val = IVI_TOSIGNED((hi << 6) | lo); /* merge them and convert into signed val */\n\n                    } else {\n\n                        if (sym >= 256U) {\n\n                            av_log(NULL, AV_LOG_ERROR, \"Invalid sym encountered: %d.\\n\", sym);\n\n                            return -1;\n\n                        }\n\n                        run = rvmap->runtab[sym];\n\n                        val = rvmap->valtab[sym];\n\n                    }\n\n\n\n                    /* de-zigzag and dequantize */\n\n                    scan_pos += run;\n\n                    if (scan_pos >= num_coeffs)\n\n                        break;\n\n                    pos = band->scan[scan_pos];\n\n\n\n                    if (!val)\n\n                        av_dlog(NULL, \"Val = 0 encountered!\\n\");\n\n\n\n                    q = (base_tab[pos] * quant) >> 9;\n\n                    if (q > 1)\n\n                        val = val * q + FFSIGN(val) * (((q ^ 1) - 1) >> 1);\n\n                    trvec[pos] = val;\n\n                    col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */\n\n                }// while\n\n\n\n                if (scan_pos >= num_coeffs && sym != rvmap->eob_sym)\n\n                    return -1; /* corrupt block data */\n\n\n\n                /* undoing DC coeff prediction for intra-blocks */\n\n                if (is_intra && band->is_2d_trans) {\n\n                    prev_dc      += trvec[0];\n\n                    trvec[0]      = prev_dc;\n\n                    col_flags[0] |= !!prev_dc;\n\n                }\n\n\n\n                /* apply inverse transform */\n\n                band->inv_transform(trvec, band->buf + buf_offs,\n\n                                    band->pitch, col_flags);\n\n\n\n                /* apply motion compensation */\n\n                if (!is_intra)\n\n                    mc_with_delta_func(band->buf + buf_offs,\n\n                                       band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n\n                                       band->pitch, mc_type);\n\n            } else {\n\n                /* block not coded */\n\n                /* for intra blocks apply the dc slant transform */\n\n                /* for inter - perform the motion compensation without delta */\n\n                if (is_intra && band->dc_transform) {\n\n                    band->dc_transform(&prev_dc, band->buf + buf_offs,\n\n                                       band->pitch, blk_size);\n\n                } else\n\n                    mc_no_delta_func(band->buf + buf_offs,\n\n                                     band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n\n                                     band->pitch, mc_type);\n\n            }\n\n\n\n            cbp >>= 1;\n\n        }// for blk\n\n    }// for mbn\n\n\n\n    align_get_bits(gb);\n\n\n\n    return 0;\n\n}\n", "idx": 817}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void assigned_dev_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                                      uint64_t data, unsigned size)\n\n{\n\n    assigned_dev_ioport_rw(opaque, addr, size, &data);\n\n}\n", "idx": 818}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_fpu(CPUState *env)\n\n{\n\n    struct kvm_fpu fpu;\n\n    int i;\n\n\n\n    memset(&fpu, 0, sizeof fpu);\n\n    fpu.fsw = env->fpus & ~(7 << 11);\n\n    fpu.fsw |= (env->fpstt & 7) << 11;\n\n    fpu.fcw = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n\tfpu.ftwx |= (!env->fptags[i]) << i;\n\n    memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);\n\n    memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);\n\n    fpu.mxcsr = env->mxcsr;\n\n\n\n    return kvm_vcpu_ioctl(env, KVM_SET_FPU, &fpu);\n\n}\n", "idx": 819}
{"project": "qemu", "commit_id": "e612a1f7256bb3546cf3e9ae6cad3997c4153663", "target": 1, "func": "target_read_memory (bfd_vma memaddr,\n\n                    bfd_byte *myaddr,\n\n                    int length,\n\n                    struct disassemble_info *info)\n\n{\n\n    int i;\n\n    for(i = 0; i < length; i++) {\n\n        myaddr[i] = ldub_code(memaddr + i);\n\n    }\n\n    return 0;\n\n}\n", "idx": 820}
{"project": "FFmpeg", "commit_id": "d176f9038711e497b32f1431e60e4e3da94179d1", "target": 1, "func": "static int http_connect(URLContext *h, const char *path, const char *hoststr,\n\n                        const char *auth, int *new_location)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    int post, err, ch;\n\n    char line[1024], *q;\n\n    char *auth_b64;\n\n    int auth_b64_len = strlen(auth)* 4 / 3 + 12;\n\n    int64_t off = s->off;\n\n\n\n\n\n    /* send http header */\n\n    post = h->flags & URL_WRONLY;\n\n    auth_b64 = av_malloc(auth_b64_len);\n\n    av_base64_encode(auth_b64, auth_b64_len, auth, strlen(auth));\n\n    snprintf(s->buffer, sizeof(s->buffer),\n\n             \"%s %s HTTP/1.1\\r\\n\"\n\n             \"User-Agent: %s\\r\\n\"\n\n             \"Accept: */*\\r\\n\"\n\n             \"Range: bytes=%\"PRId64\"-\\r\\n\"\n\n             \"Host: %s\\r\\n\"\n\n             \"Authorization: Basic %s\\r\\n\"\n\n             \"Connection: close\\r\\n\"\n\n             \"\\r\\n\",\n\n             post ? \"POST\" : \"GET\",\n\n             path,\n\n             LIBAVFORMAT_IDENT,\n\n             s->off,\n\n             hoststr,\n\n             auth_b64);\n\n\n\n    av_freep(&auth_b64);\n\n    if (http_write(h, s->buffer, strlen(s->buffer)) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    /* init input buffer */\n\n    s->buf_ptr = s->buffer;\n\n    s->buf_end = s->buffer;\n\n    s->line_count = 0;\n\n    s->off = 0;\n\n    s->filesize = -1;\n\n    if (post) {\n\n        return 0;\n\n    }\n\n\n\n    /* wait for header */\n\n    q = line;\n\n    for(;;) {\n\n        ch = http_getc(s);\n\n        if (ch < 0)\n\n            return AVERROR(EIO);\n\n        if (ch == '\\n') {\n\n            /* process line */\n\n            if (q > line && q[-1] == '\\r')\n\n                q--;\n\n            *q = '\\0';\n\n#ifdef DEBUG\n\n            printf(\"header='%s'\\n\", line);\n\n#endif\n\n            err = process_line(h, line, s->line_count, new_location);\n\n            if (err < 0)\n\n                return err;\n\n            if (err == 0)\n\n                break;\n\n            s->line_count++;\n\n            q = line;\n\n        } else {\n\n            if ((q - line) < sizeof(line) - 1)\n\n                *q++ = ch;\n\n        }\n\n    }\n\n\n\n    return (off == s->off) ? 0 : -1;\n\n}\n", "idx": 821}
{"project": "qemu", "commit_id": "bce6261eb2d879625126485d4ddd28cacb93152e", "target": 1, "func": "static void set_guest_connected(VirtIOSerialPort *port, int guest_connected)\n\n{\n\n    VirtConsole *vcon = VIRTIO_CONSOLE(port);\n\n    DeviceState *dev = DEVICE(port);\n\n\n\n    if (vcon->chr) {\n\n        qemu_chr_fe_set_open(vcon->chr, guest_connected);\n\n    }\n\n\n\n    if (dev->id) {\n\n        qapi_event_send_vserport_change(dev->id, guest_connected,\n\n                                        &error_abort);\n\n    }\n\n}\n", "idx": 822}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_errno(Error **errp, int os_errno, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg;\n\n    int saved_errno = errno;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (os_errno != 0) {\n\n        msg = (*errp)->msg;\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s\", msg, strerror(os_errno));\n\n        g_free(msg);\n\n    }\n\n\n\n    errno = saved_errno;\n\n}\n", "idx": 823}
{"project": "qemu", "commit_id": "e12ed72e5c00dd3375b8bd107200e4d7e950276a", "target": 1, "func": "void bitmap_set(unsigned long *map, long start, long nr)\n{\n    unsigned long *p = map + BIT_WORD(start);\n    const long size = start + nr;\n    int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);\n    unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);\n    while (nr - bits_to_set >= 0) {\n        *p |= mask_to_set;\n        nr -= bits_to_set;\n        bits_to_set = BITS_PER_LONG;\n        mask_to_set = ~0UL;\n        p++;\n    }\n    if (nr) {\n        mask_to_set &= BITMAP_LAST_WORD_MASK(size);\n        *p |= mask_to_set;\n    }\n}", "idx": 824}
{"project": "qemu", "commit_id": "b3c0bfb6f949d8f1c97f390f951c0bab3e703810", "target": 1, "func": "static void vmdk_free_extents(BlockDriverState *bs)\n\n{\n\n    int i;\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        g_free(s->extents[i].l1_table);\n\n        g_free(s->extents[i].l2_cache);\n\n        g_free(s->extents[i].l1_backup_table);\n\n    }\n\n    g_free(s->extents);\n\n}\n", "idx": 825}
{"project": "qemu", "commit_id": "3eea5498ca501922520b3447ba94815bfc109743", "target": 1, "func": "static void console_putchar(TextConsole *s, int ch)\n\n{\n\n    TextCell *c;\n\n    int y1, i;\n\n    int x, y;\n\n\n\n    switch(s->state) {\n\n    case TTY_STATE_NORM:\n\n        switch(ch) {\n\n        case '\\r':  /* carriage return */\n\n            s->x = 0;\n\n            break;\n\n        case '\\n':  /* newline */\n\n            console_put_lf(s);\n\n            break;\n\n        case '\\b':  /* backspace */\n\n            if (s->x > 0)\n\n                s->x--;\n\n            break;\n\n        case '\\t':  /* tabspace */\n\n            if (s->x + (8 - (s->x % 8)) > s->width) {\n\n                s->x = 0;\n\n                console_put_lf(s);\n\n            } else {\n\n                s->x = s->x + (8 - (s->x % 8));\n\n            }\n\n            break;\n\n        case '\\a':  /* alert aka. bell */\n\n            /* TODO: has to be implemented */\n\n            break;\n\n        case 14:\n\n            /* SI (shift in), character set 0 (ignored) */\n\n            break;\n\n        case 15:\n\n            /* SO (shift out), character set 1 (ignored) */\n\n            break;\n\n        case 27:    /* esc (introducing an escape sequence) */\n\n            s->state = TTY_STATE_ESC;\n\n            break;\n\n        default:\n\n            if (s->x >= s->width) {\n\n                /* line wrap */\n\n                s->x = 0;\n\n                console_put_lf(s);\n\n            }\n\n            y1 = (s->y_base + s->y) % s->total_height;\n\n            c = &s->cells[y1 * s->width + s->x];\n\n            c->ch = ch;\n\n            c->t_attrib = s->t_attrib;\n\n            update_xy(s, s->x, s->y);\n\n            s->x++;\n\n            break;\n\n        }\n\n        break;\n\n    case TTY_STATE_ESC: /* check if it is a terminal escape sequence */\n\n        if (ch == '[') {\n\n            for(i=0;i<MAX_ESC_PARAMS;i++)\n\n                s->esc_params[i] = 0;\n\n            s->nb_esc_params = 0;\n\n            s->state = TTY_STATE_CSI;\n\n        } else {\n\n            s->state = TTY_STATE_NORM;\n\n        }\n\n        break;\n\n    case TTY_STATE_CSI: /* handle escape sequence parameters */\n\n        if (ch >= '0' && ch <= '9') {\n\n            if (s->nb_esc_params < MAX_ESC_PARAMS) {\n\n                s->esc_params[s->nb_esc_params] =\n\n                    s->esc_params[s->nb_esc_params] * 10 + ch - '0';\n\n            }\n\n        } else {\n\n            s->nb_esc_params++;\n\n            if (ch == ';')\n\n                break;\n\n#ifdef DEBUG_CONSOLE\n\n            fprintf(stderr, \"escape sequence CSI%d;%d%c, %d parameters\\n\",\n\n                    s->esc_params[0], s->esc_params[1], ch, s->nb_esc_params);\n\n#endif\n\n            s->state = TTY_STATE_NORM;\n\n            switch(ch) {\n\n            case 'A':\n\n                /* move cursor up */\n\n                if (s->esc_params[0] == 0) {\n\n                    s->esc_params[0] = 1;\n\n                }\n\n                s->y -= s->esc_params[0];\n\n                if (s->y < 0) {\n\n                    s->y = 0;\n\n                }\n\n                break;\n\n            case 'B':\n\n                /* move cursor down */\n\n                if (s->esc_params[0] == 0) {\n\n                    s->esc_params[0] = 1;\n\n                }\n\n                s->y += s->esc_params[0];\n\n                if (s->y >= s->height) {\n\n                    s->y = s->height - 1;\n\n                }\n\n                break;\n\n            case 'C':\n\n                /* move cursor right */\n\n                if (s->esc_params[0] == 0) {\n\n                    s->esc_params[0] = 1;\n\n                }\n\n                s->x += s->esc_params[0];\n\n                if (s->x >= s->width) {\n\n                    s->x = s->width - 1;\n\n                }\n\n                break;\n\n            case 'D':\n\n                /* move cursor left */\n\n                if (s->esc_params[0] == 0) {\n\n                    s->esc_params[0] = 1;\n\n                }\n\n                s->x -= s->esc_params[0];\n\n                if (s->x < 0) {\n\n                    s->x = 0;\n\n                }\n\n                break;\n\n            case 'G':\n\n                /* move cursor to column */\n\n                s->x = s->esc_params[0] - 1;\n\n                if (s->x < 0) {\n\n                    s->x = 0;\n\n                }\n\n                break;\n\n            case 'f':\n\n            case 'H':\n\n                /* move cursor to row, column */\n\n                s->x = s->esc_params[1] - 1;\n\n                if (s->x < 0) {\n\n                    s->x = 0;\n\n                }\n\n                s->y = s->esc_params[0] - 1;\n\n                if (s->y < 0) {\n\n                    s->y = 0;\n\n                }\n\n                break;\n\n            case 'J':\n\n                switch (s->esc_params[0]) {\n\n                case 0:\n\n                    /* clear to end of screen */\n\n                    for (y = s->y; y < s->height; y++) {\n\n                        for (x = 0; x < s->width; x++) {\n\n                            if (y == s->y && x < s->x) {\n\n                                continue;\n\n                            }\n\n                            console_clear_xy(s, x, y);\n\n                        }\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* clear from beginning of screen */\n\n                    for (y = 0; y <= s->y; y++) {\n\n                        for (x = 0; x < s->width; x++) {\n\n                            if (y == s->y && x > s->x) {\n\n                                break;\n\n                            }\n\n                            console_clear_xy(s, x, y);\n\n                        }\n\n                    }\n\n                    break;\n\n                case 2:\n\n                    /* clear entire screen */\n\n                    for (y = 0; y <= s->height; y++) {\n\n                        for (x = 0; x < s->width; x++) {\n\n                            console_clear_xy(s, x, y);\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n                break;\n\n            case 'K':\n\n                switch (s->esc_params[0]) {\n\n                case 0:\n\n                    /* clear to eol */\n\n                    for(x = s->x; x < s->width; x++) {\n\n                        console_clear_xy(s, x, s->y);\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* clear from beginning of line */\n\n                    for (x = 0; x <= s->x; x++) {\n\n                        console_clear_xy(s, x, s->y);\n\n                    }\n\n                    break;\n\n                case 2:\n\n                    /* clear entire line */\n\n                    for(x = 0; x < s->width; x++) {\n\n                        console_clear_xy(s, x, s->y);\n\n                    }\n\n                    break;\n\n                }\n\n                break;\n\n            case 'm':\n\n                console_handle_escape(s);\n\n                break;\n\n            case 'n':\n\n                /* report cursor position */\n\n                /* TODO: send ESC[row;colR */\n\n                break;\n\n            case 's':\n\n                /* save cursor position */\n\n                s->x_saved = s->x;\n\n                s->y_saved = s->y;\n\n                break;\n\n            case 'u':\n\n                /* restore cursor position */\n\n                s->x = s->x_saved;\n\n                s->y = s->y_saved;\n\n                break;\n\n            default:\n\n#ifdef DEBUG_CONSOLE\n\n                fprintf(stderr, \"unhandled escape character '%c'\\n\", ch);\n\n#endif\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 826}
{"project": "qemu", "commit_id": "687db4ed2ecd5fd74c94fbb420482823cca4ab7e", "target": 1, "func": "static void blkverify_err(BlkverifyAIOCB *acb, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    va_start(ap, fmt);\n\n    fprintf(stderr, \"blkverify: %s sector_num=%ld nb_sectors=%d \",\n\n            acb->is_write ? \"write\" : \"read\", acb->sector_num,\n\n            acb->nb_sectors);\n\n    vfprintf(stderr, fmt, ap);\n\n    fprintf(stderr, \"\\n\");\n\n    va_end(ap);\n\n    exit(1);\n\n}\n", "idx": 827}
{"project": "FFmpeg", "commit_id": "258dfff8394d383beaa639d19912b3f068f67e16", "target": 1, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        char part[3][512], int part_size, int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    part[0][0] = part[1][0] = part[2][0] = 0;\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                snprintf(part[0], part_size, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n\n            }\n\n        }\n\n        snprintf(part[1], part_size, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    vsnprintf(part[2], part_size, fmt, vl);\n\n\n\n    *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\\n';\n\n}\n", "idx": 828}
{"project": "FFmpeg", "commit_id": "dff5a8353266641311827a4bbdd940f7ad08c8b6", "target": 0, "func": "find_c_packed_planar_out_funcs(SwsContext *c,\n\n                               yuv2planar1_fn *yuv2yuv1,    yuv2planarX_fn *yuv2yuvX,\n\n                               yuv2packed1_fn *yuv2packed1, yuv2packed2_fn *yuv2packed2,\n\n                               yuv2packedX_fn *yuv2packedX)\n\n{\n\n    enum PixelFormat dstFormat = c->dstFormat;\n\n\n\n    if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) {\n\n        *yuv2yuvX     = yuv2nv12X_c;\n\n    } else if (is16BPS(dstFormat)) {\n\n        *yuv2yuvX     = isBE(dstFormat) ? yuv2yuvX16BE_c  : yuv2yuvX16LE_c;\n\n    } else if (is9_OR_10BPS(dstFormat)) {\n\n        if (av_pix_fmt_descriptors[dstFormat].comp[0].depth_minus1 == 8) {\n\n            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX9BE_c :  yuv2yuvX9LE_c;\n\n        } else {\n\n            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX10BE_c : yuv2yuvX10LE_c;\n\n        }\n\n    } else {\n\n        *yuv2yuv1     = yuv2yuv1_c;\n\n        *yuv2yuvX     = yuv2yuvX_c;\n\n    }\n\n    if(c->flags & SWS_FULL_CHR_H_INT) {\n\n        switch (dstFormat) {\n\n            case PIX_FMT_RGBA:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2rgba32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2rgba32_full_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packedX = yuv2rgbx32_full_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n                break;\n\n            case PIX_FMT_ARGB:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2argb32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2argb32_full_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packedX = yuv2xrgb32_full_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n                break;\n\n            case PIX_FMT_BGRA:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2bgra32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2bgra32_full_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packedX = yuv2bgrx32_full_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n                break;\n\n            case PIX_FMT_ABGR:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2abgr32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2abgr32_full_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packedX = yuv2xbgr32_full_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n                break;\n\n            case PIX_FMT_RGB24:\n\n            *yuv2packedX = yuv2rgb24_full_X_c;\n\n            break;\n\n        case PIX_FMT_BGR24:\n\n            *yuv2packedX = yuv2bgr24_full_X_c;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (dstFormat) {\n\n        case PIX_FMT_GRAY16BE:\n\n            *yuv2packed1 = yuv2gray16BE_1_c;\n\n            *yuv2packed2 = yuv2gray16BE_2_c;\n\n            *yuv2packedX = yuv2gray16BE_X_c;\n\n            break;\n\n        case PIX_FMT_GRAY16LE:\n\n            *yuv2packed1 = yuv2gray16LE_1_c;\n\n            *yuv2packed2 = yuv2gray16LE_2_c;\n\n            *yuv2packedX = yuv2gray16LE_X_c;\n\n            break;\n\n        case PIX_FMT_MONOWHITE:\n\n            *yuv2packed1 = yuv2monowhite_1_c;\n\n            *yuv2packed2 = yuv2monowhite_2_c;\n\n            *yuv2packedX = yuv2monowhite_X_c;\n\n            break;\n\n        case PIX_FMT_MONOBLACK:\n\n            *yuv2packed1 = yuv2monoblack_1_c;\n\n            *yuv2packed2 = yuv2monoblack_2_c;\n\n            *yuv2packedX = yuv2monoblack_X_c;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            *yuv2packed1 = yuv2yuyv422_1_c;\n\n            *yuv2packed2 = yuv2yuyv422_2_c;\n\n            *yuv2packedX = yuv2yuyv422_X_c;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            *yuv2packed1 = yuv2uyvy422_1_c;\n\n            *yuv2packed2 = yuv2uyvy422_2_c;\n\n            *yuv2packedX = yuv2uyvy422_X_c;\n\n            break;\n\n        case PIX_FMT_RGB48LE:\n\n            //*yuv2packed1 = yuv2rgb48le_1_c;\n\n            //*yuv2packed2 = yuv2rgb48le_2_c;\n\n            //*yuv2packedX = yuv2rgb48le_X_c;\n\n            //break;\n\n        case PIX_FMT_RGB48BE:\n\n            *yuv2packed1 = yuv2rgb48be_1_c;\n\n            *yuv2packed2 = yuv2rgb48be_2_c;\n\n            *yuv2packedX = yuv2rgb48be_X_c;\n\n            break;\n\n        case PIX_FMT_BGR48LE:\n\n            //*yuv2packed1 = yuv2bgr48le_1_c;\n\n            //*yuv2packed2 = yuv2bgr48le_2_c;\n\n            //*yuv2packedX = yuv2bgr48le_X_c;\n\n            //break;\n\n        case PIX_FMT_BGR48BE:\n\n            *yuv2packed1 = yuv2bgr48be_1_c;\n\n            *yuv2packed2 = yuv2bgr48be_2_c;\n\n            *yuv2packedX = yuv2bgr48be_X_c;\n\n            break;\n\n        case PIX_FMT_RGB32:\n\n        case PIX_FMT_BGR32:\n\n#if CONFIG_SMALL\n\n            *yuv2packed1 = yuv2rgb32_1_c;\n\n            *yuv2packed2 = yuv2rgb32_2_c;\n\n            *yuv2packedX = yuv2rgb32_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packed1 = yuv2rgba32_1_c;\n\n                    *yuv2packed2 = yuv2rgba32_2_c;\n\n                    *yuv2packedX = yuv2rgba32_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packed1 = yuv2rgbx32_1_c;\n\n                    *yuv2packed2 = yuv2rgbx32_2_c;\n\n                    *yuv2packedX = yuv2rgbx32_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n            break;\n\n        case PIX_FMT_RGB32_1:\n\n        case PIX_FMT_BGR32_1:\n\n#if CONFIG_SMALL\n\n                *yuv2packed1 = yuv2rgb32_1_1_c;\n\n                *yuv2packed2 = yuv2rgb32_1_2_c;\n\n                *yuv2packedX = yuv2rgb32_1_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packed1 = yuv2rgba32_1_1_c;\n\n                    *yuv2packed2 = yuv2rgba32_1_2_c;\n\n                    *yuv2packedX = yuv2rgba32_1_X_c;\n\n                } else\n\n#endif /* CONFIG_SWSCALE_ALPHA */\n\n                {\n\n                    *yuv2packed1 = yuv2rgbx32_1_1_c;\n\n                    *yuv2packed2 = yuv2rgbx32_1_2_c;\n\n                    *yuv2packedX = yuv2rgbx32_1_X_c;\n\n                }\n\n#endif /* !CONFIG_SMALL */\n\n                break;\n\n        case PIX_FMT_RGB24:\n\n            *yuv2packed1 = yuv2rgb24_1_c;\n\n            *yuv2packed2 = yuv2rgb24_2_c;\n\n            *yuv2packedX = yuv2rgb24_X_c;\n\n            break;\n\n        case PIX_FMT_BGR24:\n\n            *yuv2packed1 = yuv2bgr24_1_c;\n\n            *yuv2packed2 = yuv2bgr24_2_c;\n\n            *yuv2packedX = yuv2bgr24_X_c;\n\n            break;\n\n        case PIX_FMT_RGB565:\n\n        case PIX_FMT_BGR565:\n\n            *yuv2packed1 = yuv2rgb16_1_c;\n\n            *yuv2packed2 = yuv2rgb16_2_c;\n\n            *yuv2packedX = yuv2rgb16_X_c;\n\n            break;\n\n        case PIX_FMT_RGB555:\n\n        case PIX_FMT_BGR555:\n\n            *yuv2packed1 = yuv2rgb15_1_c;\n\n            *yuv2packed2 = yuv2rgb15_2_c;\n\n            *yuv2packedX = yuv2rgb15_X_c;\n\n            break;\n\n        case PIX_FMT_RGB444:\n\n        case PIX_FMT_BGR444:\n\n            *yuv2packed1 = yuv2rgb12_1_c;\n\n            *yuv2packed2 = yuv2rgb12_2_c;\n\n            *yuv2packedX = yuv2rgb12_X_c;\n\n            break;\n\n        case PIX_FMT_RGB8:\n\n        case PIX_FMT_BGR8:\n\n            *yuv2packed1 = yuv2rgb8_1_c;\n\n            *yuv2packed2 = yuv2rgb8_2_c;\n\n            *yuv2packedX = yuv2rgb8_X_c;\n\n            break;\n\n        case PIX_FMT_RGB4:\n\n        case PIX_FMT_BGR4:\n\n            *yuv2packed1 = yuv2rgb4_1_c;\n\n            *yuv2packed2 = yuv2rgb4_2_c;\n\n            *yuv2packedX = yuv2rgb4_X_c;\n\n            break;\n\n        case PIX_FMT_RGB4_BYTE:\n\n        case PIX_FMT_BGR4_BYTE:\n\n            *yuv2packed1 = yuv2rgb4b_1_c;\n\n            *yuv2packed2 = yuv2rgb4b_2_c;\n\n            *yuv2packedX = yuv2rgb4b_X_c;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 829}
{"project": "FFmpeg", "commit_id": "f777504f640260337974848c7d5d7a3f064bbb45", "target": 0, "func": "static av_always_inline void h264_filter_mb_fast_internal(H264Context *h,\n\n                                                          int mb_x, int mb_y,\n\n                                                          uint8_t *img_y,\n\n                                                          uint8_t *img_cb,\n\n                                                          uint8_t *img_cr,\n\n                                                          unsigned int linesize,\n\n                                                          unsigned int uvlinesize,\n\n                                                          int pixel_shift)\n\n{\n\n    int chroma = !(CONFIG_GRAY && (h->flags&CODEC_FLAG_GRAY));\n\n    int chroma444 = CHROMA444(h);\n\n    int chroma422 = CHROMA422(h);\n\n\n\n    int mb_xy = h->mb_xy;\n\n    int left_type= h->left_type[LTOP];\n\n    int top_type= h->top_type;\n\n\n\n    int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    int a = h->slice_alpha_c0_offset - qp_bd_offset;\n\n    int b = h->slice_beta_offset - qp_bd_offset;\n\n\n\n    int mb_type = h->cur_pic.mb_type[mb_xy];\n\n    int qp      = h->cur_pic.qscale_table[mb_xy];\n\n    int qp0     = h->cur_pic.qscale_table[mb_xy - 1];\n\n    int qp1     = h->cur_pic.qscale_table[h->top_mb_xy];\n\n    int qpc = get_chroma_qp( h, 0, qp );\n\n    int qpc0 = get_chroma_qp( h, 0, qp0 );\n\n    int qpc1 = get_chroma_qp( h, 0, qp1 );\n\n    qp0 = (qp + qp0 + 1) >> 1;\n\n    qp1 = (qp + qp1 + 1) >> 1;\n\n    qpc0 = (qpc + qpc0 + 1) >> 1;\n\n    qpc1 = (qpc + qpc1 + 1) >> 1;\n\n\n\n    if( IS_INTRA(mb_type) ) {\n\n        static const int16_t bS4[4] = {4,4,4,4};\n\n        static const int16_t bS3[4] = {3,3,3,3};\n\n        const int16_t *bSH = FIELD_PICTURE(h) ? bS3 : bS4;\n\n        if(left_type)\n\n            filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1);\n\n        if( IS_8x8DCT(mb_type) ) {\n\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n\n            if(top_type){\n\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n\n            }\n\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n\n        } else {\n\n            filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n\n            filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n\n            if(top_type){\n\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n\n            }\n\n            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0);\n\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n\n            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0);\n\n        }\n\n        if(chroma){\n\n            if(chroma444){\n\n                if(left_type){\n\n                    filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n\n                    filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n\n                }\n\n                if( IS_8x8DCT(mb_type) ) {\n\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    if(top_type){\n\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n\n                    }\n\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                } else {\n\n                    filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n\n                    if(top_type){\n\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n\n                    }\n\n                    filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                    filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n\n                }\n\n            }else if(chroma422){\n\n                if(left_type){\n\n                    filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n\n                    filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n\n                }\n\n                filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                if(top_type){\n\n                    filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n\n                    filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n\n                }\n\n                filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n            }else{\n\n                if(left_type){\n\n                    filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n\n                    filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n\n                }\n\n                filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                if(top_type){\n\n                    filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n\n                    filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n\n                }\n\n                filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n                filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n\n            }\n\n        }\n\n        return;\n\n    } else {\n\n        LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]);\n\n        int edges;\n\n        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) {\n\n            edges = 4;\n\n            AV_WN64A(bS[0][0], 0x0002000200020002ULL);\n\n            AV_WN64A(bS[0][2], 0x0002000200020002ULL);\n\n            AV_WN64A(bS[1][0], 0x0002000200020002ULL);\n\n            AV_WN64A(bS[1][2], 0x0002000200020002ULL);\n\n        } else {\n\n            int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); //(mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0;\n\n            int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); // (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (h->left_type[LTOP] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0;\n\n            int step =  1+(mb_type>>24); //IS_8x8DCT(mb_type) ? 2 : 1;\n\n            edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); //(mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;\n\n            h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,\n\n                                              h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE(h));\n\n        }\n\n        if( IS_INTRA(left_type) )\n\n            AV_WN64A(bS[0][0], 0x0004000400040004ULL);\n\n        if( IS_INTRA(top_type) )\n\n            AV_WN64A(bS[1][0], FIELD_PICTURE(h) ? 0x0003000300030003ULL : 0x0004000400040004ULL);\n\n\n\n#define FILTER(hv,dir,edge,intra)\\\n\n        if(AV_RN64A(bS[dir][edge])) {                                   \\\n\n            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\\\n\n            if(chroma){\\\n\n                if(chroma444){\\\n\n                    filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n\n                    filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n\n                } else if(!(edge&1)) {\\\n\n                    filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n\n                    filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n\n                }\\\n\n            }\\\n\n        }\n\n        if(left_type)\n\n            FILTER(v,0,0,1);\n\n        if( edges == 1 ) {\n\n            if(top_type)\n\n                FILTER(h,1,0,1);\n\n        } else if( IS_8x8DCT(mb_type) ) {\n\n            FILTER(v,0,2,0);\n\n            if(top_type)\n\n                FILTER(h,1,0,1);\n\n            FILTER(h,1,2,0);\n\n        } else {\n\n            FILTER(v,0,1,0);\n\n            FILTER(v,0,2,0);\n\n            FILTER(v,0,3,0);\n\n            if(top_type)\n\n                FILTER(h,1,0,1);\n\n            FILTER(h,1,1,0);\n\n            FILTER(h,1,2,0);\n\n            FILTER(h,1,3,0);\n\n        }\n\n#undef FILTER\n\n    }\n\n}\n", "idx": 830}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int h263_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    s->avctx = avctx;\n\n    s->out_format = FMT_H263;\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    /* select sub codec */\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_H263:\n\n        s->gob_number = 0;\n\n        s->first_gob_line = 0;\n\n        break;\n\n    case CODEC_ID_MPEG4:\n\n        s->time_increment_bits = 4; /* default value for broken headers */\n\n        s->h263_pred = 1;\n\n        s->has_b_frames = 1; //default, might be overriden in the vol header during header parsing\n\n        break;\n\n    case CODEC_ID_MSMPEG4V1:\n\n        s->h263_msmpeg4 = 1;\n\n        s->h263_pred = 1;\n\n        s->msmpeg4_version=1;\n\n        break;\n\n    case CODEC_ID_MSMPEG4V2:\n\n        s->h263_msmpeg4 = 1;\n\n        s->h263_pred = 1;\n\n        s->msmpeg4_version=2;\n\n        break;\n\n    case CODEC_ID_MSMPEG4V3:\n\n        s->h263_msmpeg4 = 1;\n\n        s->h263_pred = 1;\n\n        s->msmpeg4_version=3;\n\n        break;\n\n    case CODEC_ID_WMV1:\n\n        s->h263_msmpeg4 = 1;\n\n        s->h263_pred = 1;\n\n        s->msmpeg4_version=4;\n\n        break;\n\n    case CODEC_ID_H263I:\n\n        s->h263_intel = 1;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    /* for h263, we allocate the images after having read the header */\n\n    if (avctx->codec->id != CODEC_ID_H263 && avctx->codec->id != CODEC_ID_MPEG4)\n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n\n\n    /* XXX: suppress this matrix init, only needed because using mpeg1\n\n       dequantize in mmx case */\n\n    for(i=0;i<64;i++)\n\n        s->non_intra_matrix[i] = default_non_intra_matrix[i];\n\n\n\n    if (s->h263_msmpeg4)\n\n        msmpeg4_decode_init_vlc(s);\n\n    else\n\n        h263_decode_init_vlc(s);\n\n    \n\n    return 0;\n\n}\n", "idx": 831}
{"project": "FFmpeg", "commit_id": "4b6bfbe2b70ea87831fa9a42a2ac112ee8a386d2", "target": 1, "func": "static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    IEC958Context *ctx = s->priv_data;\n\n    int ret, padding;\n\n\n\n\n    ctx->out_bytes = pkt->size;\n\n    ctx->length_code = FFALIGN(pkt->size, 2) << 3;\n\n\n\n    ret = ctx->header_info(s, pkt);\n\n    if (ret < 0)\n\n        return -1;\n\n    if (!ctx->pkt_offset)\n\n        return 0;\n\n\n\n    padding = (ctx->pkt_offset - BURST_HEADER_SIZE - ctx->out_bytes) >> 1;\n\n    if (padding < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"bitrate is too high\\n\");\n\n        return -1;\n\n    }\n\n\n\n    put_le16(s->pb, SYNCWORD1);      //Pa\n\n    put_le16(s->pb, SYNCWORD2);      //Pb\n\n    put_le16(s->pb, ctx->data_type); //Pc\n\n    put_le16(s->pb, ctx->length_code);//Pd\n\n\n\n#if HAVE_BIGENDIAN\n\n    put_buffer(s->pb, ctx->out_buf, ctx->out_bytes & ~1);\n\n#else\n\n    av_fast_malloc(&ctx->buffer, &ctx->buffer_size, ctx->out_bytes + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!ctx->buffer)\n\n        return AVERROR(ENOMEM);\n\n    ff_spdif_bswap_buf16((uint16_t *)ctx->buffer, (uint16_t *)ctx->out_buf, ctx->out_bytes >> 1);\n\n    put_buffer(s->pb, ctx->buffer, ctx->out_bytes & ~1);\n\n#endif\n\n\n\n    if (ctx->out_bytes & 1)\n\n        put_be16(s->pb, ctx->out_buf[ctx->out_bytes - 1]);\n\n\n\n    for (; padding > 0; padding--)\n\n        put_be16(s->pb, 0);\n\n\n\n    av_log(s, AV_LOG_DEBUG, \"type=%x len=%i pkt_offset=%i\\n\",\n\n           ctx->data_type, ctx->out_bytes, ctx->pkt_offset);\n\n\n\n    put_flush_packet(s->pb);\n\n    return 0;\n\n}", "idx": 832}
{"project": "qemu", "commit_id": "05cc758a3dfc79488d0a8eb7f5830a41871e78d0", "target": 1, "func": "static void blkverify_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n\n\n    /* bs->file->bs has already been refreshed */\n\n    bdrv_refresh_filename(s->test_file->bs);\n\n\n\n    if (bs->file->bs->full_open_options\n\n        && s->test_file->bs->full_open_options)\n\n    {\n\n        QDict *opts = qdict_new();\n\n        qdict_put_str(opts, \"driver\", \"blkverify\");\n\n\n\n        QINCREF(bs->file->bs->full_open_options);\n\n        qdict_put(opts, \"raw\", bs->file->bs->full_open_options);\n\n        QINCREF(s->test_file->bs->full_open_options);\n\n        qdict_put(opts, \"test\", s->test_file->bs->full_open_options);\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->file->bs->exact_filename[0]\n\n        && s->test_file->bs->exact_filename[0])\n\n    {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"blkverify:%s:%s\",\n\n                 bs->file->bs->exact_filename,\n\n                 s->test_file->bs->exact_filename);\n\n    }\n\n}\n", "idx": 833}
{"project": "FFmpeg", "commit_id": "b84675d63aaede8f6944b901250a10456c5477e6", "target": 0, "func": "static int ffmmal_read_frame(AVCodecContext *avctx, AVFrame *frame, int *got_frame)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    MMAL_BUFFER_HEADER_T *buffer = NULL;\n\n    MMAL_STATUS_T status = 0;\n\n    int ret = 0;\n\n\n\n    if (ctx->eos_received)\n\n        goto done;\n\n\n\n    while (1) {\n\n        // To ensure decoding in lockstep with a constant delay between fed packets\n\n        // and output frames, we always wait until an output buffer is available.\n\n        // Except during start we don't know after how many input packets the decoder\n\n        // is going to return the first buffer, and we can't distinguish decoder\n\n        // being busy from decoder waiting for input. So just poll at the start and\n\n        // keep feeding new data to the buffer.\n\n        // We are pretty sure the decoder will produce output if we sent more input\n\n        // frames than what a h264 decoder could logically delay. This avoids too\n\n        // excessive buffering.\n\n        // We also wait if we sent eos, but didn't receive it yet (think of decoding\n\n        // stream with a very low number of frames).\n\n        if (ctx->frames_output || ctx->packets_sent > MAX_DELAYED_FRAMES || ctx->eos_sent) {\n\n            buffer = mmal_queue_wait(ctx->queue_decoded_frames);\n\n        } else {\n\n            buffer = mmal_queue_get(ctx->queue_decoded_frames);\n\n        }\n\n        if (!buffer)\n\n            goto done;\n\n\n\n        ctx->eos_received |= !!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS);\n\n        if (ctx->eos_received)\n\n            goto done;\n\n\n\n        if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {\n\n            MMAL_COMPONENT_T *decoder = ctx->decoder;\n\n            MMAL_EVENT_FORMAT_CHANGED_T *ev = mmal_event_format_changed_get(buffer);\n\n            MMAL_BUFFER_HEADER_T *stale_buffer;\n\n\n\n            av_log(avctx, AV_LOG_INFO, \"Changing output format.\\n\");\n\n\n\n            if ((status = mmal_port_disable(decoder->output[0])))\n\n                goto done;\n\n\n\n            while ((stale_buffer = mmal_queue_get(ctx->queue_decoded_frames)))\n\n                mmal_buffer_header_release(stale_buffer);\n\n\n\n            mmal_format_copy(decoder->output[0]->format, ev->format);\n\n\n\n            if ((ret = ffmal_update_format(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_output_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_input_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        } else if (buffer->cmd) {\n\n            char s[20];\n\n            av_get_codec_tag_string(s, sizeof(s), buffer->cmd);\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown MMAL event %s on output port\\n\", s);\n\n            goto done;\n\n        } else if (buffer->length == 0) {\n\n            // Unused output buffer that got drained after format change.\n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        }\n\n\n\n        ctx->frames_output++;\n\n\n\n        if ((ret = ffmal_copy_frame(avctx, frame, buffer)) < 0)\n\n            goto done;\n\n\n\n        *got_frame = 1;\n\n        break;\n\n    }\n\n\n\ndone:\n\n    if (buffer)\n\n        mmal_buffer_header_release(buffer);\n\n    if (status && ret >= 0)\n\n        ret = AVERROR_UNKNOWN;\n\n    return ret;\n\n}\n", "idx": 834}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "void ff_sbrdsp_init_x86(SBRDSPContext *s)\n\n{\n\n    if (HAVE_YASM) {\n\n        int mm_flags = av_get_cpu_flags();\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE) {\n\n            s->sum_square = ff_sbr_sum_square_sse;\n\n            s->hf_g_filt = ff_sbr_hf_g_filt_sse;\n\n        }\n\n    }\n\n}\n", "idx": 835}
{"project": "qemu", "commit_id": "c4c0e236beabb9de5ff472f77aeb811ec5484615", "target": 1, "func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n\n{\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret, value, index;\n\n\n\n    /* \n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n    value = le16_to_cpu(s->ctrl.req.wValue);\n\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n\n        s->ctrl.len);\n\n\n\n    if (s->ctrl.req.bRequestType == 0) {\n\n        switch (s->ctrl.req.bRequest) {\n\n        case USB_REQ_SET_ADDRESS:\n\n            return usb_host_set_address(s, value);\n\n\n\n        case USB_REQ_SET_CONFIGURATION:\n\n            return usb_host_set_config(s, value & 0xff);\n\n        }\n\n    }\n\n\n\n    if (s->ctrl.req.bRequestType == 1 &&\n\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n\n        return usb_host_set_interface(s, index, value);\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    aurb = async_alloc();\n\n    aurb->hdev   = s;\n\n    aurb->packet = p;\n\n\n\n    /* \n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is layed out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */ \n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &s->ctrl.req;\n\n    urb->buffer_length = 8 + s->ctrl.len;\n\n\n\n    urb->usercontext = s;\n\n\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    usb_defer_packet(p, async_cancel, aurb);\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 836}
{"project": "qemu", "commit_id": "2ba154cf4eb8636cdd3aa90f392ca9e77206ca39", "target": 1, "func": "static void pc_init1(MachineState *machine)\n\n{\n\n    PCMachineState *pc_machine = PC_MACHINE(machine);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n    ram_addr_t lowmem;\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (machine->ram_size >= 0xe0000000) {\n\n        lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n    } else {\n\n        lowmem = 0xe0000000;\n\n    }\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(qemu limit, user limit).\n\n     */\n\n    if (lowmem > pc_machine->max_ram_below_4g) {\n\n        lowmem = pc_machine->max_ram_below_4g;\n\n        if (machine->ram_size - lowmem > lowmem &&\n\n            lowmem & ((1ULL << 30) - 1)) {\n\n            error_report(\"Warning: Large machine and max_ram_below_4g(%\"PRIu64\n\n                         \") not a multiple of 1G; possible bad performance.\",\n\n                         pc_machine->max_ram_below_4g);\n\n        }\n\n    }\n\n\n\n    if (machine->ram_size >= lowmem) {\n\n        above_4g_mem_size = machine->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = machine->ram_size;\n\n    }\n\n\n\n    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n\n                                      &ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(machine->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n    guest_info->legacy_acpi_table_size = legacy_acpi_table_size;\n\n\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n    guest_info->has_reserved_memory = has_reserved_memory;\n\n    guest_info->rsdp_in_ram = rsdp_in_ram;\n\n\n\n    if (smbios_defaults) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            mc->name, smbios_legacy_mode, smbios_uuid_encoded);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(machine, system_memory,\n\n                                below_4g_mem_size, above_4g_mem_size,\n\n                                rom_memory, &ram_memory, guest_info);\n\n    } else if (machine->kernel_filename != NULL) {\n\n        /* For xen HVM direct kernel boot, load linux here */\n\n        fw_cfg = xen_load_linux(machine->kernel_filename,\n\n                                machine->kernel_cmdline,\n\n                                machine->initrd_filename,\n\n                                below_4g_mem_size,\n\n                                guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, machine->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, get_system_memory(), system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    assert(pc_machine->vmport != ON_OFF_AUTO_MAX);\n\n    if (pc_machine->vmport == ON_OFF_AUTO_AUTO) {\n\n        pc_machine->vmport = xen_enabled() ? ON_OFF_AUTO_OFF : ON_OFF_AUTO_ON;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, true, &floppy,\n\n                         (pc_machine->vmport != ON_OFF_AUTO_ON), 0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,\n\n                 machine, floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled()) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        DeviceState *piix4_pm;\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg, &piix4_pm);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n\n\n        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n\n                                 TYPE_HOTPLUG_HANDLER,\n\n                                 (Object **)&pc_machine->acpi_dev,\n\n                                 object_property_allow_set_link,\n\n                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),\n\n                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 839}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void parse_type_int64(Visitor *v, const char *name, int64_t *obj,\n\n                             Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (!siv->string) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    parse_str(siv, errp);\n\n\n\n    if (!siv->ranges) {\n\n        goto error;\n\n    }\n\n\n\n    if (!siv->cur_range) {\n\n        Range *r;\n\n\n\n        siv->cur_range = g_list_first(siv->ranges);\n\n        if (!siv->cur_range) {\n\n            goto error;\n\n        }\n\n\n\n        r = siv->cur_range->data;\n\n        if (!r) {\n\n            goto error;\n\n        }\n\n\n\n        siv->cur = r->begin;\n\n    }\n\n\n\n    *obj = siv->cur;\n\n    siv->cur++;\n\n    return;\n\n\n\nerror:\n\n    error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n               \"an int64 value or range\");\n\n}\n", "idx": 840}
{"project": "qemu", "commit_id": "ac3107340fbb9422ea63ee5d6729775965e121fd", "target": 1, "func": "void qemu_chr_be_write(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    s->chr_read(s->handler_opaque, buf, len);\n\n}\n", "idx": 841}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "static void virtio_set_status(struct subchannel_id schid,\n\n                              unsigned long dev_addr)\n\n{\n\n    unsigned char status = dev_addr;\n\n    if (run_ccw(schid, CCW_CMD_WRITE_STATUS, &status, sizeof(status))) {\n\n        virtio_panic(\"Could not write status to host!\\n\");\n\n    }\n\n}\n", "idx": 842}
{"project": "qemu", "commit_id": "206ae74aea5593f5f5bad769a6b4f101f17bc6fd", "target": 1, "func": "uint32_t do_arm_semihosting(CPUState *env)\n\n{\n\n    target_ulong args;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = env->opaque;\n\n#else\n\n    CPUState *ts = env;\n\n#endif\n\n\n\n    nr = env->regs[0];\n\n    args = env->regs[1];\n\n    switch (nr) {\n\n    case SYS_OPEN:\n\n        if (!(s = lock_user_string(ARG(0))))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        if (ARG(1) >= 12)\n\n            return (uint32_t)-1;\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            if (ARG(1) < 4)\n\n                return STDIN_FILENO;\n\n            else\n\n                return STDOUT_FILENO;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"open,%s,%x,1a4\", ARG(0),\n\n\t\t\t   (int)ARG(2)+1, gdb_open_modeflags[ARG(1)]);\n\n            return env->regs[0];\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[ARG(1)], 0644));\n\n        }\n\n        unlock_user(s, ARG(0), 0);\n\n        return ret;\n\n    case SYS_CLOSE:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"close,%x\", ARG(0));\n\n            return env->regs[0];\n\n        } else {\n\n            return set_swi_errno(ts, close(ARG(0)));\n\n        }\n\n    case SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                gdb_do_syscall(arm_semi_cb, \"write,2,%x,1\", args);\n\n                return env->regs[0];\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"write,2,%x,%x\\n\", args, len);\n\n            ret = env->regs[0];\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case SYS_WRITE:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            gdb_do_syscall(arm_semi_cb, \"write,%x,%x,%x\", ARG(0), ARG(1), len);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user(VERIFY_READ, ARG(1), len, 1)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret = set_swi_errno(ts, write(ARG(0), s, len));\n\n            unlock_user(s, ARG(1), 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case SYS_READ:\n\n        len = ARG(2);\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            gdb_do_syscall(arm_semi_cb, \"read,%x,%x,%x\", ARG(0), ARG(1), len);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user(VERIFY_WRITE, ARG(1), len, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            do\n\n              ret = set_swi_errno(ts, read(ARG(0), s, len));\n\n            while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, ARG(1), len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case SYS_READC:\n\n       /* XXX: Read from debug cosole. Not implemented.  */\n\n        return 0;\n\n    case SYS_ISTTY:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"isatty,%x\", ARG(0));\n\n            return env->regs[0];\n\n        } else {\n\n            return isatty(ARG(0));\n\n        }\n\n    case SYS_SEEK:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"lseek,%x,%x,0\", ARG(0), ARG(1));\n\n            return env->regs[0];\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(ARG(0), ARG(1), SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case SYS_FLEN:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_flen_cb, \"fstat,%x,%x\",\n\n\t\t\t   ARG(0), env->regs[13]-64);\n\n            return env->regs[0];\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(ARG(0), &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case SYS_REMOVE:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"unlink,%s\", ARG(0), (int)ARG(1)+1);\n\n            ret = env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user_string(ARG(0))))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, ARG(0), 0);\n\n        }\n\n        return ret;\n\n    case SYS_RENAME:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"rename,%s,%s\",\n\n                           ARG(0), (int)ARG(1)+1, ARG(2), (int)ARG(3)+1);\n\n            return env->regs[0];\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(ARG(0));\n\n            s2 = lock_user_string(ARG(2));\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, ARG(2), 0);\n\n            if (s)\n\n                unlock_user(s, ARG(0), 0);\n\n            return ret;\n\n        }\n\n    case SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case SYS_SYSTEM:\n\n        if (use_gdb_syscalls()) {\n\n            gdb_do_syscall(arm_semi_cb, \"system,%s\", ARG(0), (int)ARG(1)+1);\n\n            return env->regs[0];\n\n        } else {\n\n            if (!(s = lock_user_string(ARG(0))))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, ARG(0), 0);\n\n            return ret;\n\n        }\n\n    case SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case SYS_GET_CMDLINE:\n\n#ifdef CONFIG_USER_ONLY\n\n        /* Build a commandline from the original argv.  */\n\n        {\n\n            char *arm_cmdline_buffer;\n\n            const char *host_cmdline_buffer;\n\n\n\n            unsigned int i;\n\n            unsigned int arm_cmdline_len = ARG(1);\n\n            unsigned int host_cmdline_len =\n\n                ts->info->arg_end-ts->info->arg_start;\n\n\n\n            if (!arm_cmdline_len || host_cmdline_len > arm_cmdline_len) {\n\n                return -1; /* not enough space to store command line */\n\n            }\n\n\n\n            if (!host_cmdline_len) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                arm_cmdline_buffer = lock_user(VERIFY_WRITE, ARG(0), 1, 0);\n\n                arm_cmdline_buffer[0] = 0;\n\n                unlock_user(arm_cmdline_buffer, ARG(0), 1);\n\n\n\n                /* Adjust the commandline length argument. */\n\n                SET_ARG(1, 0);\n\n                return 0;\n\n            }\n\n\n\n            /* lock the buffers on the ARM side */\n\n            arm_cmdline_buffer =\n\n                lock_user(VERIFY_WRITE, ARG(0), host_cmdline_len, 0);\n\n            host_cmdline_buffer =\n\n                lock_user(VERIFY_READ, ts->info->arg_start,\n\n                                       host_cmdline_len, 1);\n\n\n\n            if (arm_cmdline_buffer && host_cmdline_buffer)\n\n            {\n\n                /* the last argument is zero-terminated;\n\n                   no need for additional termination */\n\n                memcpy(arm_cmdline_buffer, host_cmdline_buffer,\n\n                       host_cmdline_len);\n\n\n\n                /* separate arguments by white spaces */\n\n                for (i = 0; i < host_cmdline_len-1; i++) {\n\n                    if (arm_cmdline_buffer[i] == 0) {\n\n                        arm_cmdline_buffer[i] = ' ';\n\n                    }\n\n                }\n\n\n\n                /* Adjust the commandline length argument. */\n\n                SET_ARG(1, host_cmdline_len-1);\n\n            }\n\n\n\n            /* Unlock the buffers on the ARM side.  */\n\n            unlock_user(arm_cmdline_buffer, ARG(0), host_cmdline_len);\n\n            unlock_user((void*)host_cmdline_buffer, ts->info->arg_start, 0);\n\n\n\n            /* Return success if we could return a commandline.  */\n\n            return (arm_cmdline_buffer && host_cmdline_buffer) ? 0 : -1;\n\n        }\n\n#else\n\n        return -1;\n\n#endif\n\n    case SYS_HEAPINFO:\n\n        {\n\n            uint32_t *ptr;\n\n            uint32_t limit;\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                long ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret != -1)\n\n                        break;\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            ptr[0] = tswap32(ts->heap_base);\n\n            ptr[1] = tswap32(ts->heap_limit);\n\n            ptr[2] = tswap32(ts->stack_base);\n\n            ptr[3] = tswap32(0); /* Stack limit.  */\n\n            unlock_user(ptr, ARG(0), 16);\n\n#else\n\n            limit = ram_size;\n\n            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            ptr[0] = tswap32(limit / 2);\n\n            ptr[1] = tswap32(limit);\n\n            ptr[2] = tswap32(limit); /* Stack base */\n\n            ptr[3] = tswap32(0); /* Stack limit.  */\n\n            unlock_user(ptr, ARG(0), 16);\n\n#endif\n\n            return 0;\n\n        }\n\n    case SYS_EXIT:\n\n        gdb_exit(env, 0);\n\n        exit(0);\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(env, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 843}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "int inet_connect(const char *str, Error **errp)\n\n{\n\n    QemuOpts *opts;\n\n    int sock = -1;\n\n\n\n    opts = qemu_opts_create(&dummy_opts, NULL, 0, NULL);\n\n    if (inet_parse(opts, str) == 0) {\n\n        sock = inet_connect_opts(opts, true, NULL, errp);\n\n    } else {\n\n        error_set(errp, QERR_SOCKET_CREATE_FAILED);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return sock;\n\n}\n", "idx": 844}
{"project": "qemu", "commit_id": "885b7c44e4f8b7a012a92770a0dba8b238662caa", "target": 1, "func": "static void do_interrupt_user(CPUX86State *env, int intno, int is_int,\n\n                              int error_code, target_ulong next_eip)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int dpl, cpl, shift;\n\n    uint32_t e2;\n\n\n\n    dt = &env->idt;\n\n    if (env->hflags & HF_LMA_MASK) {\n\n        shift = 4;\n\n    } else {\n\n        shift = 3;\n\n    }\n\n    ptr = dt->base + (intno << shift);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, (intno << shift) + 2);\n\n    }\n\n\n\n    /* Since we emulate only user space, we cannot do more than\n\n       exiting the emulation with the suitable exception and error\n\n       code. So update EIP for INT 0x80 and EXCP_SYSCALL. */\n\n    if (is_int || intno == EXCP_SYSCALL) {\n\n        env->eip = next_eip;\n\n    }\n\n}\n", "idx": 845}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel(void)\n\n{\n\n    int64_t entry, kernel_high;\n\n    long kernel_size, initrd_size, params_size;\n\n    ram_addr_t initrd_offset;\n\n    uint32_t *params_buf;\n\n    int big_endian;\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n    kernel_size = load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys,\n\n                           NULL, (uint64_t *)&entry, NULL,\n\n                           (uint64_t *)&kernel_high, big_endian,\n\n                           ELF_MACHINE, 1);\n\n    if (kernel_size >= 0) {\n\n        if ((entry & ~0x7fffffffULL) == 0x80000000)\n\n            entry = (int32_t)entry;\n\n    } else {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Store command line.  */\n\n    params_size = 264;\n\n    params_buf = g_malloc(params_size);\n\n\n\n    params_buf[0] = tswap32(ram_size);\n\n    params_buf[1] = tswap32(0x12345678);\n\n\n\n    if (initrd_size > 0) {\n\n        snprintf((char *)params_buf + 8, 256, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 cpu_mips_phys_to_kseg0(NULL, initrd_offset),\n\n                 initrd_size, loaderparams.kernel_cmdline);\n\n    } else {\n\n        snprintf((char *)params_buf + 8, 256, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    rom_add_blob_fixed(\"params\", params_buf, params_size,\n\n                       (16 << 20) - 264);\n\n\n\n\n    return entry;\n\n}", "idx": 846}
{"project": "FFmpeg", "commit_id": "48d6556dd46d4f4fac10d0f4a819e314887cd50e", "target": 1, "func": "static int cin_read_frame_header(CinDemuxContext *cin, AVIOContext *pb) {\n\n    CinFrameHeader *hdr = &cin->frame_header;\n\n\n\n    hdr->video_frame_type = avio_r8(pb);\n\n    hdr->audio_frame_type = avio_r8(pb);\n\n    hdr->pal_colors_count = avio_rl16(pb);\n\n    hdr->video_frame_size = avio_rl32(pb);\n\n    hdr->audio_frame_size = avio_rl32(pb);\n\n\n\n    if (pb->eof_reached || pb->error)\n\n        return AVERROR(EIO);\n\n\n\n    if (avio_rl32(pb) != 0xAA55AA55)\n\n\n\n\n\n\n    return 0;\n\n}", "idx": 847}
{"project": "qemu", "commit_id": "2ad645d2854746b55ddfd1d8e951f689cca5d78f", "target": 1, "func": "static void test_endianness_combine(gconstpointer data)\n\n{\n\n    const TestCase *test = data;\n\n    char *args;\n\n\n\n    args = g_strdup_printf(\"-display none -M %s%s%s -device pc-testdev\",\n\n                           test->machine,\n\n                           test->superio ? \" -device \" : \"\",\n\n                           test->superio ?: \"\");\n\n    qtest_start(args);\n\n    isa_outl(test, 0xe0, 0x87654321);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654321);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);\n\n\n\n    isa_outw(test, 0xe2, 0x8866);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x88664321);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8866);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);\n\n\n\n    isa_outw(test, 0xe0, 0x4422);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x88664422);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8866);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4422);\n\n\n\n    isa_outb(test, 0xe3, 0x87);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87664422);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8766);\n\n\n\n    isa_outb(test, 0xe2, 0x65);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654422);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4422);\n\n\n\n    isa_outb(test, 0xe1, 0x43);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654322);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4322);\n\n\n\n    isa_outb(test, 0xe0, 0x21);\n\n    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654321);\n\n    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);\n\n    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n", "idx": 849}
{"project": "FFmpeg", "commit_id": "210461c0a83a5625560fa1d92229200dc7fb869b", "target": 0, "func": "int avpicture_deinterlace(AVPicture *dst, const AVPicture *src,\n\n                          enum AVPixelFormat pix_fmt, int width, int height)\n\n{\n\n    int i;\n\n\n\n    if (pix_fmt != AV_PIX_FMT_YUV420P &&\n\n        pix_fmt != AV_PIX_FMT_YUVJ420P &&\n\n        pix_fmt != AV_PIX_FMT_YUV422P &&\n\n        pix_fmt != AV_PIX_FMT_YUVJ422P &&\n\n        pix_fmt != AV_PIX_FMT_YUV444P &&\n\n        pix_fmt != AV_PIX_FMT_YUV411P &&\n\n        pix_fmt != AV_PIX_FMT_GRAY8)\n\n        return -1;\n\n    if ((width & 3) != 0 || (height & 3) != 0)\n\n        return -1;\n\n\n\n    for(i=0;i<3;i++) {\n\n        if (i == 1) {\n\n            switch(pix_fmt) {\n\n            case AV_PIX_FMT_YUVJ420P:\n\n            case AV_PIX_FMT_YUV420P:\n\n                width >>= 1;\n\n                height >>= 1;\n\n                break;\n\n            case AV_PIX_FMT_YUV422P:\n\n            case AV_PIX_FMT_YUVJ422P:\n\n                width >>= 1;\n\n                break;\n\n            case AV_PIX_FMT_YUV411P:\n\n                width >>= 2;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            if (pix_fmt == AV_PIX_FMT_GRAY8) {\n\n                break;\n\n            }\n\n        }\n\n        if (src == dst) {\n\n            deinterlace_bottom_field_inplace(dst->data[i], dst->linesize[i],\n\n                                 width, height);\n\n        } else {\n\n            deinterlace_bottom_field(dst->data[i],dst->linesize[i],\n\n                                        src->data[i], src->linesize[i],\n\n                                        width, height);\n\n        }\n\n    }\n\n    emms_c();\n\n    return 0;\n\n}\n", "idx": 851}
{"project": "FFmpeg", "commit_id": "a1926a29fb4325afa46842883f197c74d4535c36", "target": 0, "func": "static void chroma_mc(HEVCContext *s, int16_t *dst1, int16_t *dst2,\n\n                      ptrdiff_t dststride, AVFrame *ref, const Mv *mv,\n\n                      int x_off, int y_off, int block_w, int block_h)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t *src1        = ref->data[1];\n\n    uint8_t *src2        = ref->data[2];\n\n    ptrdiff_t src1stride = ref->linesize[1];\n\n    ptrdiff_t src2stride = ref->linesize[2];\n\n    int pic_width        = s->ps.sps->width >> 1;\n\n    int pic_height       = s->ps.sps->height >> 1;\n\n\n\n    int mx = mv->x & 7;\n\n    int my = mv->y & 7;\n\n\n\n    x_off += mv->x >> 3;\n\n    y_off += mv->y >> 3;\n\n    src1  += y_off * src1stride + (x_off << s->ps.sps->pixel_shift);\n\n    src2  += y_off * src2stride + (x_off << s->ps.sps->pixel_shift);\n\n\n\n    if (x_off < EPEL_EXTRA_BEFORE || y_off < EPEL_EXTRA_AFTER ||\n\n        x_off >= pic_width - block_w - EPEL_EXTRA_AFTER ||\n\n        y_off >= pic_height - block_h - EPEL_EXTRA_AFTER) {\n\n        const int edge_emu_stride = EDGE_EMU_BUFFER_STRIDE << s->ps.sps->pixel_shift;\n\n        int offset1 = EPEL_EXTRA_BEFORE * (src1stride + (1 << s->ps.sps->pixel_shift));\n\n        int buf_offset1 = EPEL_EXTRA_BEFORE *\n\n                          (edge_emu_stride + (1 << s->ps.sps->pixel_shift));\n\n        int offset2 = EPEL_EXTRA_BEFORE * (src2stride + (1 << s->ps.sps->pixel_shift));\n\n        int buf_offset2 = EPEL_EXTRA_BEFORE *\n\n                          (edge_emu_stride + (1 << s->ps.sps->pixel_shift));\n\n\n\n        s->vdsp.emulated_edge_mc(lc->edge_emu_buffer, src1 - offset1,\n\n                                 edge_emu_stride, src1stride,\n\n                                 block_w + EPEL_EXTRA, block_h + EPEL_EXTRA,\n\n                                 x_off - EPEL_EXTRA_BEFORE,\n\n                                 y_off - EPEL_EXTRA_BEFORE,\n\n                                 pic_width, pic_height);\n\n\n\n        src1 = lc->edge_emu_buffer + buf_offset1;\n\n        src1stride = edge_emu_stride;\n\n        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst1, dststride, src1, src1stride,\n\n                                             block_w, block_h, mx, my, lc->mc_buffer);\n\n\n\n        s->vdsp.emulated_edge_mc(lc->edge_emu_buffer, src2 - offset2,\n\n                                 edge_emu_stride, src2stride,\n\n                                 block_w + EPEL_EXTRA, block_h + EPEL_EXTRA,\n\n                                 x_off - EPEL_EXTRA_BEFORE,\n\n                                 y_off - EPEL_EXTRA_BEFORE,\n\n                                 pic_width, pic_height);\n\n        src2 = lc->edge_emu_buffer + buf_offset2;\n\n        src2stride = edge_emu_stride;\n\n\n\n        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst2, dststride, src2, src2stride,\n\n                                             block_w, block_h, mx, my,\n\n                                             lc->mc_buffer);\n\n    } else {\n\n        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst1, dststride, src1, src1stride,\n\n                                             block_w, block_h, mx, my,\n\n                                             lc->mc_buffer);\n\n        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst2, dststride, src2, src2stride,\n\n                                             block_w, block_h, mx, my,\n\n                                             lc->mc_buffer);\n\n    }\n\n}\n", "idx": 852}
{"project": "FFmpeg", "commit_id": "ec23a47286a9be0ca67b78f4d8b9d87220c18286", "target": 0, "func": "static void mpegts_push_data(void *opaque,\n\n                             const uint8_t *buf, int buf_size, int is_start)\n\n{\n\n    PESContext *pes = opaque;\n\n    MpegTSContext *ts = pes->stream->priv_data;\n\n    AVStream *st;\n\n    const uint8_t *p;\n\n    int len, code, codec_type, codec_id;\n\n    \n\n    if (is_start) {\n\n        pes->state = MPEGTS_HEADER;\n\n        pes->data_index = 0;\n\n    }\n\n    p = buf;\n\n    while (buf_size > 0) {\n\n        switch(pes->state) {\n\n        case MPEGTS_HEADER:\n\n            len = PES_START_SIZE - pes->data_index;\n\n            if (len > buf_size)\n\n                len = buf_size;\n\n            memcpy(pes->header + pes->data_index, p, len);\n\n            pes->data_index += len;\n\n            p += len;\n\n            buf_size -= len;\n\n            if (pes->data_index == PES_START_SIZE) {\n\n                /* we got all the PES or section header. We can now\n\n                   decide */\n\n#if 0\n\n                av_hex_dump(pes->header, pes->data_index);\n\n#endif\n\n                if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n\n                    pes->header[2] == 0x01) {\n\n                    /* it must be an mpeg2 PES stream */\n\n                    /* XXX: add AC3 support */\n\n                    code = pes->header[3] | 0x100;\n\n                    if (!((code >= 0x1c0 && code <= 0x1df) ||\n\n                          (code >= 0x1e0 && code <= 0x1ef)))\n\n                        goto skip;\n\n                    if (!pes->st) {\n\n                        /* allocate stream */\n\n                        if (code >= 0x1c0 && code <= 0x1df) {\n\n                            codec_type = CODEC_TYPE_AUDIO;\n\n                            codec_id = CODEC_ID_MP2;\n\n                        } else {\n\n                            codec_type = CODEC_TYPE_VIDEO;\n\n                            codec_id = CODEC_ID_MPEG1VIDEO;\n\n                        }\n\n                        st = av_new_stream(pes->stream, pes->pid);\n\n                        if (st) {\n\n                            st->priv_data = pes;\n\n                            st->codec.codec_type = codec_type;\n\n                            st->codec.codec_id = codec_id;\n\n                            pes->st = st;\n\n                        }\n\n                    }\n\n                    pes->state = MPEGTS_PESHEADER_FILL;\n\n                    pes->total_size = (pes->header[4] << 8) | pes->header[5];\n\n                    /* NOTE: a zero total size means the PES size is\n\n                       unbounded */\n\n                    if (pes->total_size)\n\n                        pes->total_size += 6;\n\n                    pes->pes_header_size = pes->header[8] + 9;\n\n                } else {\n\n                    /* otherwise, it should be a table */\n\n                    /* skip packet */\n\n                skip:\n\n                    pes->state = MPEGTS_SKIP;\n\n                    continue;\n\n                }\n\n            }\n\n            break;\n\n            /**********************************************/\n\n            /* PES packing parsing */\n\n        case MPEGTS_PESHEADER_FILL:\n\n            len = pes->pes_header_size - pes->data_index;\n\n            if (len > buf_size)\n\n                len = buf_size;\n\n            memcpy(pes->header + pes->data_index, p, len);\n\n            pes->data_index += len;\n\n            p += len;\n\n            buf_size -= len;\n\n            if (pes->data_index == pes->pes_header_size) {\n\n                const uint8_t *r;\n\n                unsigned int flags;\n\n\n\n                flags = pes->header[7];\n\n                r = pes->header + 9;\n\n                pes->pts = AV_NOPTS_VALUE;\n\n                pes->dts = AV_NOPTS_VALUE;\n\n                if ((flags & 0xc0) == 0x80) {\n\n                    pes->pts = get_pts(r);\n\n                    r += 5;\n\n                } else if ((flags & 0xc0) == 0xc0) {\n\n                    pes->pts = get_pts(r);\n\n                    r += 5;\n\n                    pes->dts = get_pts(r);\n\n                    r += 5;\n\n                }\n\n                /* we got the full header. We parse it and get the payload */\n\n                pes->state = MPEGTS_PAYLOAD;\n\n            }\n\n            break;\n\n        case MPEGTS_PAYLOAD:\n\n            if (pes->total_size) {\n\n                len = pes->total_size - pes->data_index;\n\n                if (len > buf_size)\n\n                    len = buf_size;\n\n            } else {\n\n                len = buf_size;\n\n            }\n\n            if (len > 0) {\n\n                AVPacket *pkt = ts->pkt;\n\n                if (pes->st && av_new_packet(pkt, len) == 0) {\n\n                    memcpy(pkt->data, p, len);\n\n                    pkt->stream_index = pes->st->index;\n\n                    pkt->pts = pes->pts;\n\n                    /* reset pts values */\n\n                    pes->pts = AV_NOPTS_VALUE;\n\n                    pes->dts = AV_NOPTS_VALUE;\n\n                    ts->stop_parse = 1;\n\n                    return;\n\n                }\n\n            }\n\n            buf_size = 0;\n\n            break;\n\n        case MPEGTS_SKIP:\n\n            buf_size = 0;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 853}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static bool gscb_needed(void *opaque)\n\n{\n\n    return kvm_s390_get_gs();\n\n}\n", "idx": 856}
{"project": "qemu", "commit_id": "e864cabdc0a38bb598ddcf88b264896dc6f3e3b2", "target": 1, "func": "void do_fctiw (void)\n\n{\n\n    union {\n\n        double d;\n\n        uint64_t i;\n\n    } p;\n\n\n\n    /* XXX: higher bits are not supposed to be significant.\n\n     *     to make tests easier, return the same as a real PowerPC 750 (aka G3)\n\n     */\n\n    p.i = float64_to_int32(FT0, &env->fp_status);\n\n    p.i |= 0xFFF80000ULL << 32;\n\n    FT0 = p.d;\n\n}\n", "idx": 857}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "static struct omap_mpu_timer_s *omap_mpu_timer_init(MemoryRegion *system_memory,\n\n                hwaddr base,\n\n                qemu_irq irq, omap_clk clk)\n\n{\n\n    struct omap_mpu_timer_s *s = (struct omap_mpu_timer_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_timer_s));\n\n\n\n    s->irq = irq;\n\n    s->clk = clk;\n\n    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_timer_tick, s);\n\n    s->tick = qemu_bh_new(omap_timer_fire, s);\n\n    omap_mpu_timer_reset(s);\n\n    omap_timer_clk_setup(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mpu_timer_ops, s,\n\n                          \"omap-mpu-timer\", 0x100);\n\n\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 858}
{"project": "FFmpeg", "commit_id": "97af2faaba70c866ae4c11459a79a16d4a014530", "target": 1, "func": "static int libopenjpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                    const AVFrame *frame, int *got_packet)\n\n{\n\n    LibOpenJPEGContext *ctx = avctx->priv_data;\n\n    opj_cinfo_t *compress = ctx->compress;\n\n    opj_image_t *image    = ctx->image;\n\n    opj_cio_t *stream     = ctx->stream;\n\n    int cpyresult = 0;\n\n    int ret, len;\n\n    AVFrame *gbrframe;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_RGB24:\n\n    case AV_PIX_FMT_RGBA:\n\n    case AV_PIX_FMT_GRAY8A:\n\n        cpyresult = libopenjpeg_copy_packed8(avctx, frame, image);\n\n        break;\n\n    case AV_PIX_FMT_XYZ12:\n\n        cpyresult = libopenjpeg_copy_packed12(avctx, frame, image);\n\n        break;\n\n    case AV_PIX_FMT_RGB48:\n\n    case AV_PIX_FMT_RGBA64:\n\n        cpyresult = libopenjpeg_copy_packed16(avctx, frame, image);\n\n        break;\n\n    case AV_PIX_FMT_GBR24P:\n\n    case AV_PIX_FMT_GBRP9:\n\n    case AV_PIX_FMT_GBRP10:\n\n    case AV_PIX_FMT_GBRP12:\n\n    case AV_PIX_FMT_GBRP14:\n\n    case AV_PIX_FMT_GBRP16:\n\n        gbrframe = av_frame_alloc();\n\n\n\n        av_frame_ref(gbrframe, frame);\n\n        gbrframe->data[0] = frame->data[2]; // swap to be rgb\n\n        gbrframe->data[1] = frame->data[0];\n\n        gbrframe->data[2] = frame->data[1];\n\n        gbrframe->linesize[0] = frame->linesize[2];\n\n        gbrframe->linesize[1] = frame->linesize[0];\n\n        gbrframe->linesize[2] = frame->linesize[1];\n\n        if (avctx->pix_fmt == AV_PIX_FMT_GBR24P) {\n\n            cpyresult = libopenjpeg_copy_unpacked8(avctx, gbrframe, image);\n\n        } else {\n\n            cpyresult = libopenjpeg_copy_unpacked16(avctx, gbrframe, image);\n\n        }\n\n        av_frame_free(&gbrframe);\n\n        break;\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YUV410P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA444P:\n\n        cpyresult = libopenjpeg_copy_unpacked8(avctx, frame, image);\n\n        break;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV420P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUVA420P9:\n\n    case AV_PIX_FMT_YUVA422P9:\n\n    case AV_PIX_FMT_YUVA444P9:\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUVA444P10:\n\n    case AV_PIX_FMT_YUVA422P10:\n\n    case AV_PIX_FMT_YUVA420P10:\n\n    case AV_PIX_FMT_YUV420P12:\n\n    case AV_PIX_FMT_YUV422P12:\n\n    case AV_PIX_FMT_YUV444P12:\n\n    case AV_PIX_FMT_YUV420P14:\n\n    case AV_PIX_FMT_YUV422P14:\n\n    case AV_PIX_FMT_YUV444P14:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n    case AV_PIX_FMT_YUVA444P16:\n\n    case AV_PIX_FMT_YUVA422P16:\n\n    case AV_PIX_FMT_YUVA420P16:\n\n        cpyresult = libopenjpeg_copy_unpacked16(avctx, frame, image);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"The frame's pixel format '%s' is not supported\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n        break;\n\n    }\n\n\n\n    if (!cpyresult) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Could not copy the frame data to the internal image buffer\\n\");\n\n        return -1;\n\n    }\n\n\n\n    cio_seek(stream, 0);\n\n    if (!opj_encode(compress, stream, image, NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error during the opj encode\\n\");\n\n        return -1;\n\n    }\n\n\n\n    len = cio_tell(stream);\n\n    if ((ret = ff_alloc_packet2(avctx, pkt, len)) < 0) {\n\n        return ret;\n\n    }\n\n\n\n    memcpy(pkt->data, stream->buffer, len);\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n}", "idx": 861}
{"project": "qemu", "commit_id": "23994a5f524aa575c7a4b2e5250f17b127d2cf2f", "target": 1, "func": "static void termsig_handler(int signum)\n\n{\n\n    state = TERMINATE;\n\n    qemu_notify_event();\n\n}\n", "idx": 862}
{"project": "qemu", "commit_id": "9de68637dff05a18d0eafcff2737e551b70bc490", "target": 1, "func": "static int qxl_post_load(void *opaque, int version)\n\n{\n\n    PCIQXLDevice* d = opaque;\n\n    uint8_t *ram_start = d->vga.vram_ptr;\n\n    QXLCommandExt *cmds;\n\n    int in, out, newmode;\n\n\n\n    assert(d->last_release_offset < d->vga.vram_size);\n\n    if (d->last_release_offset == 0) {\n\n        d->last_release = NULL;\n\n    } else {\n\n        d->last_release = (QXLReleaseInfo *)(ram_start + d->last_release_offset);\n\n    }\n\n\n\n    d->modes = (QXLModes*)((uint8_t*)d->rom + d->rom->modes_offset);\n\n\n\n    trace_qxl_post_load(d->id, qxl_mode_to_string(d->mode));\n\n    newmode = d->mode;\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n\n\n    switch (newmode) {\n\n    case QXL_MODE_UNDEFINED:\n\n        qxl_create_memslots(d);\n\n        break;\n\n    case QXL_MODE_VGA:\n\n        qxl_create_memslots(d);\n\n        qxl_enter_vga_mode(d);\n\n        break;\n\n    case QXL_MODE_NATIVE:\n\n        qxl_create_memslots(d);\n\n        qxl_create_guest_primary(d, 1, QXL_SYNC);\n\n\n\n        /* replay surface-create and cursor-set commands */\n\n        cmds = g_malloc0(sizeof(QXLCommandExt) * (d->ssd.num_surfaces + 1));\n\n        for (in = 0, out = 0; in < d->ssd.num_surfaces; in++) {\n\n            if (d->guest_surfaces.cmds[in] == 0) {\n\n                continue;\n\n            }\n\n            cmds[out].cmd.data = d->guest_surfaces.cmds[in];\n\n            cmds[out].cmd.type = QXL_CMD_SURFACE;\n\n            cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n            out++;\n\n        }\n\n        if (d->guest_cursor) {\n\n            cmds[out].cmd.data = d->guest_cursor;\n\n            cmds[out].cmd.type = QXL_CMD_CURSOR;\n\n            cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n            out++;\n\n        }\n\n        qxl_spice_loadvm_commands(d, cmds, out);\n\n        g_free(cmds);\n\n        if (d->guest_monitors_config) {\n\n            qxl_spice_monitors_config_async(d, 1);\n\n        }\n\n        break;\n\n    case QXL_MODE_COMPAT:\n\n        /* note: no need to call qxl_create_memslots, qxl_set_mode\n\n         * creates the mem slot. */\n\n        qxl_set_mode(d, d->shadow_rom.mode, 1);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 864}
{"project": "FFmpeg", "commit_id": "22cc57da64bfd73f2206969486b0aa183ee76479", "target": 1, "func": "static int rtp_parse_one_packet(RTPDemuxContext *s, AVPacket *pkt,\n\n                                uint8_t **bufptr, int len)\n\n{\n\n    uint8_t *buf = bufptr ? *bufptr : NULL;\n\n    int flags = 0;\n\n    uint32_t timestamp;\n\n    int rv = 0;\n\n\n\n    if (!buf) {\n\n        /* If parsing of the previous packet actually returned 0 or an error,\n\n         * there's nothing more to be parsed from that packet, but we may have\n\n         * indicated that we can return the next enqueued packet. */\n\n        if (s->prev_ret <= 0)\n\n            return rtp_parse_queued_packet(s, pkt);\n\n        /* return the next packets, if any */\n\n        if (s->handler && s->handler->parse_packet) {\n\n            /* timestamp should be overwritten by parse_packet, if not,\n\n             * the packet is left with pts == AV_NOPTS_VALUE */\n\n            timestamp = RTP_NOTS_VALUE;\n\n            rv        = s->handler->parse_packet(s->ic, s->dynamic_protocol_context,\n\n                                                 s->st, pkt, &timestamp, NULL, 0, 0,\n\n                                                 flags);\n\n            finalize_packet(s, pkt, timestamp);\n\n            return rv;\n\n        }\n\n    }\n\n\n\n    if (len < 12)\n\n        return -1;\n\n\n\n    if ((buf[0] & 0xc0) != (RTP_VERSION << 6))\n\n        return -1;\n\n    if (RTP_PT_IS_RTCP(buf[1])) {\n\n        return rtcp_parse_packet(s, buf, len);\n\n    }\n\n\n\n    if (s->st) {\n\n        int64_t received = av_gettime_relative();\n\n        uint32_t arrival_ts = av_rescale_q(received, AV_TIME_BASE_Q,\n\n                                           s->st->time_base);\n\n        timestamp = AV_RB32(buf + 4);\n\n        // Calculate the jitter immediately, before queueing the packet\n\n        // into the reordering queue.\n\n        rtcp_update_jitter(&s->statistics, timestamp, arrival_ts);\n\n    }\n\n\n\n    if ((s->seq == 0 && !s->queue) || s->queue_size <= 1) {\n\n        /* First packet, or no reordering */\n\n        return rtp_parse_packet_internal(s, pkt, buf, len);\n\n    } else {\n\n        uint16_t seq = AV_RB16(buf + 2);\n\n        int16_t diff = seq - s->seq;\n\n        if (diff < 0) {\n\n            /* Packet older than the previously emitted one, drop */\n\n            av_log(s->st ? s->st->codec : NULL, AV_LOG_WARNING,\n\n                   \"RTP: dropping old packet received too late\\n\");\n\n            return -1;\n\n        } else if (diff <= 1) {\n\n            /* Correct packet */\n\n            rv = rtp_parse_packet_internal(s, pkt, buf, len);\n\n            return rv;\n\n        } else {\n\n            /* Still missing some packet, enqueue this one. */\n\n            enqueue_packet(s, buf, len);\n\n            *bufptr = NULL;\n\n            /* Return the first enqueued packet if the queue is full,\n\n             * even if we're missing something */\n\n            if (s->queue_len >= s->queue_size) {\n\n                av_log(s->st ? s->st->codec : NULL, AV_LOG_WARNING,\n\n                       \"jitter buffer full\\n\");\n\n                return rtp_parse_queued_packet(s, pkt);\n\n            }\n\n            return -1;\n\n        }\n\n    }\n\n}\n", "idx": 865}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb16to15)(const uint8_t *src,uint8_t *dst,long src_size)\n\n{\n\n  register const uint8_t* s=src;\n\n  register uint8_t* d=dst;\n\n  register const uint8_t *end;\n\n  const uint8_t *mm_end;\n\n  end = s + src_size;\n\n#ifdef HAVE_MMX\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*s));\n\n  __asm __volatile(\"movq\t%0, %%mm7\"::\"m\"(mask15rg));\n\n  __asm __volatile(\"movq\t%0, %%mm6\"::\"m\"(mask15b));\n\n  mm_end = end - 15;\n\n  while(s<mm_end)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"psrlq\t$1, %%mm0\\n\\t\"\n\n\t\t\"psrlq\t$1, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm7, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm7, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm6, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm6, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*d)\n\n\t\t:\"m\"(*s)\n\n\t\t);\n\n\td+=16;\n\n\ts+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n    mm_end = end - 3;\n\n    while(s < mm_end)\n\n    {\n\n\tregister uint32_t x= *((uint32_t *)s);\n\n\t*((uint32_t *)d) = ((x>>1)&0x7FE07FE0) | (x&0x001F001F);\n\n\ts+=4;\n\n\td+=4;\n\n    }\n\n    if(s < end)\n\n    {\n\n\tregister uint16_t x= *((uint16_t *)s);\n\n\t*((uint16_t *)d) = ((x>>1)&0x7FE0) | (x&0x001F);\n\n\ts+=2;\n\n\td+=2;\n\n    }\n\n}\n", "idx": 866}
{"project": "qemu", "commit_id": "5a3d7b23ba41b4884b43b6bc936ea18f999d5c6b", "target": 0, "func": "static void xics_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->realize = xics_realize;\n\n    dc->props = xics_properties;\n\n    dc->reset = xics_reset;\n\n}\n", "idx": 868}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void acpi_memory_hotplug_init(MemoryRegion *as, Object *owner,\n\n                              MemHotplugState *state)\n\n{\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n\n\n    state->dev_count = machine->ram_slots;\n\n    if (!state->dev_count) {\n\n        return;\n\n    }\n\n\n\n    state->devs = g_malloc0(sizeof(*state->devs) * state->dev_count);\n\n    memory_region_init_io(&state->io, owner, &acpi_memory_hotplug_ops, state,\n\n                          \"acpi-mem-hotplug\", ACPI_MEMORY_HOTPLUG_IO_LEN);\n\n    memory_region_add_subregion(as, ACPI_MEMORY_HOTPLUG_BASE, &state->io);\n\n}\n", "idx": 869}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_correct(void)\n\n{\n\n    const char *str = \"12345 foo\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 12345);\n\n    g_assert(endptr == str + 5);\n\n}\n", "idx": 870}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml *aml_shiftleft(Aml *arg1, Aml *count)\n\n{\n\n    Aml *var = aml_opcode(0x79 /* ShiftLeftOp */);\n\n    aml_append(var, arg1);\n\n    aml_append(var, count);\n\n    build_append_byte(var->buf, 0x00); /* NullNameOp */\n\n    return var;\n\n}\n", "idx": 871}
{"project": "qemu", "commit_id": "37d1e4d9bfac846a1331375aab3d13b54a048c01", "target": 0, "func": "static void nfs_process_write(void *arg)\n\n{\n\n    NFSClient *client = arg;\n\n\n\n    aio_context_acquire(client->aio_context);\n\n    nfs_service(client->context, POLLOUT);\n\n    nfs_set_events(client);\n\n    aio_context_release(client->aio_context);\n\n}\n", "idx": 872}
{"project": "qemu", "commit_id": "55ac0a9bf4e1b1adfc7d73586a7aa085f58c9851", "target": 0, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit)\n\n{\n\n    uintptr_t ret;\n\n    int32_t insns_left;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    if (*tb_exit != TB_EXIT_REQUESTED) {\n\n        *last_tb = tb;\n\n        return;\n\n    }\n\n\n\n    *last_tb = NULL;\n\n    insns_left = atomic_read(&cpu->icount_decr.u32);\n\n    atomic_set(&cpu->icount_decr.u16.high, 0);\n\n    if (insns_left < 0) {\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_mb();\n\n        return;\n\n    }\n\n\n\n    /* Instruction counter expired.  */\n\n    assert(use_icount);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->icount_extra) {\n\n        /* Refill decrementer and continue execution.  */\n\n        cpu->icount_extra += insns_left;\n\n        insns_left = MIN(0xffff, cpu->icount_extra);\n\n        cpu->icount_extra -= insns_left;\n\n        cpu->icount_decr.u16.low = insns_left;\n\n    } else {\n\n        /* Execute any remaining instructions, then let the main loop\n\n         * handle the next event.\n\n         */\n\n        if (insns_left > 0) {\n\n            cpu_exec_nocache(cpu, insns_left, tb, false);\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 873}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_byte_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                                uint8_t *value, uint8_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint8_t valid_emu_mask = 0;\n\n\n\n    /* emulate byte register */\n\n    valid_emu_mask = reg->emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 874}
{"project": "qemu", "commit_id": "0282abf078c3353a178ab77a115828ce333181dd", "target": 0, "func": "static int vfio_setup_pcie_cap(VFIOPCIDevice *vdev, int pos, uint8_t size)\n\n{\n\n    uint16_t flags;\n\n    uint8_t type;\n\n\n\n    flags = pci_get_word(vdev->pdev.config + pos + PCI_CAP_FLAGS);\n\n    type = (flags & PCI_EXP_FLAGS_TYPE) >> 4;\n\n\n\n    if (type != PCI_EXP_TYPE_ENDPOINT &&\n\n        type != PCI_EXP_TYPE_LEG_END &&\n\n        type != PCI_EXP_TYPE_RC_END) {\n\n\n\n        error_report(\"vfio: Assignment of PCIe type 0x%x \"\n\n                     \"devices is not currently supported\", type);\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!pci_bus_is_express(vdev->pdev.bus)) {\n\n        /*\n\n         * Use express capability as-is on PCI bus.  It doesn't make much\n\n         * sense to even expose, but some drivers (ex. tg3) depend on it\n\n         * and guests don't seem to be particular about it.  We'll need\n\n         * to revist this or force express devices to express buses if we\n\n         * ever expose an IOMMU to the guest.\n\n         */\n\n    } else if (pci_bus_is_root(vdev->pdev.bus)) {\n\n        /*\n\n         * On a Root Complex bus Endpoints become Root Complex Integrated\n\n         * Endpoints, which changes the type and clears the LNK & LNK2 fields.\n\n         */\n\n        if (type == PCI_EXP_TYPE_ENDPOINT) {\n\n            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,\n\n                                   PCI_EXP_TYPE_RC_END << 4,\n\n                                   PCI_EXP_FLAGS_TYPE);\n\n\n\n            /* Link Capabilities, Status, and Control goes away */\n\n            if (size > PCI_EXP_LNKCTL) {\n\n                vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP, 0, ~0);\n\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA, 0, ~0);\n\n\n\n#ifndef PCI_EXP_LNKCAP2\n\n#define PCI_EXP_LNKCAP2 44\n\n#endif\n\n#ifndef PCI_EXP_LNKSTA2\n\n#define PCI_EXP_LNKSTA2 50\n\n#endif\n\n                /* Link 2 Capabilities, Status, and Control goes away */\n\n                if (size > PCI_EXP_LNKCAP2) {\n\n                    vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP2, 0, ~0);\n\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL2, 0, ~0);\n\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA2, 0, ~0);\n\n                }\n\n            }\n\n\n\n        } else if (type == PCI_EXP_TYPE_LEG_END) {\n\n            /*\n\n             * Legacy endpoints don't belong on the root complex.  Windows\n\n             * seems to be happier with devices if we skip the capability.\n\n             */\n\n            return 0;\n\n        }\n\n\n\n    } else {\n\n        /*\n\n         * Convert Root Complex Integrated Endpoints to regular endpoints.\n\n         * These devices don't support LNK/LNK2 capabilities, so make them up.\n\n         */\n\n        if (type == PCI_EXP_TYPE_RC_END) {\n\n            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,\n\n                                   PCI_EXP_TYPE_ENDPOINT << 4,\n\n                                   PCI_EXP_FLAGS_TYPE);\n\n            vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP,\n\n                                   PCI_EXP_LNK_MLW_1 | PCI_EXP_LNK_LS_25, ~0);\n\n            vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n\n        }\n\n\n\n        /* Mark the Link Status bits as emulated to allow virtual negotiation */\n\n        vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA,\n\n                               pci_get_word(vdev->pdev.config + pos +\n\n                                            PCI_EXP_LNKSTA),\n\n                               PCI_EXP_LNKCAP_MLW | PCI_EXP_LNKCAP_SLS);\n\n    }\n\n\n\n    pos = pci_add_capability(&vdev->pdev, PCI_CAP_ID_EXP, pos, size);\n\n    if (pos >= 0) {\n\n        vdev->pdev.exp.exp_cap = pos;\n\n    }\n\n\n\n    return pos;\n\n}\n", "idx": 875}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static UserDefNested *nested_struct_create(void)\n\n{\n\n    UserDefNested *udnp = g_malloc0(sizeof(*udnp));\n\n    udnp->string0 = strdup(\"test_string0\");\n\n    udnp->dict1.string1 = strdup(\"test_string1\");\n\n    udnp->dict1.dict2.userdef1 = g_malloc0(sizeof(UserDefOne));\n\n    udnp->dict1.dict2.userdef1->base = g_new0(UserDefZero, 1);\n\n    udnp->dict1.dict2.userdef1->base->integer = 42;\n\n    udnp->dict1.dict2.userdef1->string = strdup(\"test_string\");\n\n    udnp->dict1.dict2.string2 = strdup(\"test_string2\");\n\n    udnp->dict1.has_dict3 = true;\n\n    udnp->dict1.dict3.userdef2 = g_malloc0(sizeof(UserDefOne));\n\n    udnp->dict1.dict3.userdef2->base = g_new0(UserDefZero, 1);\n\n    udnp->dict1.dict3.userdef2->base->integer = 43;\n\n    udnp->dict1.dict3.userdef2->string = strdup(\"test_string\");\n\n    udnp->dict1.dict3.string3 = strdup(\"test_string3\");\n\n    return udnp;\n\n}\n", "idx": 876}
{"project": "qemu", "commit_id": "6744cbab8cd63b7ce72b3eee4f0055007acf0798", "target": 0, "func": "static int qcow2_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    const char *backing_file = NULL;\n\n    const char *backing_fmt = NULL;\n\n    uint64_t sectors = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    int prealloc = 0;\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            sectors = options->value.n / 512;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n\n            backing_file = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FMT)) {\n\n            backing_fmt = options->value.s;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_ENCRYPT)) {\n\n            flags |= options->value.n ? BLOCK_FLAG_ENCRYPT : 0;\n\n        } else if (!strcmp(options->name, BLOCK_OPT_CLUSTER_SIZE)) {\n\n            if (options->value.n) {\n\n                cluster_size = options->value.n;\n\n            }\n\n        } else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {\n\n            if (!options->value.s || !strcmp(options->value.s, \"off\")) {\n\n                prealloc = 0;\n\n            } else if (!strcmp(options->value.s, \"metadata\")) {\n\n                prealloc = 1;\n\n            } else {\n\n                fprintf(stderr, \"Invalid preallocation mode: '%s'\\n\",\n\n                    options->value.s);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n        options++;\n\n    }\n\n\n\n    if (backing_file && prealloc) {\n\n        fprintf(stderr, \"Backing file and preallocation cannot be used at \"\n\n            \"the same time\\n\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    return qcow2_create2(filename, sectors, backing_file, backing_fmt, flags,\n\n                         cluster_size, prealloc, options);\n\n}\n", "idx": 877}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 878}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_str(Visitor *v, const char *name, char **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    if (*obj) {\n\n        qmp_output_add(qov, name, qstring_from_str(*obj));\n\n    } else {\n\n        qmp_output_add(qov, name, qstring_from_str(\"\"));\n\n    }\n\n}\n", "idx": 879}
{"project": "qemu", "commit_id": "630c26893d6dc7713c0fcfc3c09d6bfe536a6ce3", "target": 0, "func": "static void v9fs_open_post_lstat(V9fsState *s, V9fsOpenState *vs, int err)\n\n{\n\n    int flags;\n\n\n\n    if (err) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    stat_to_qid(&vs->stbuf, &vs->qid);\n\n\n\n    if (S_ISDIR(vs->stbuf.st_mode)) {\n\n        vs->fidp->fs.dir = v9fs_do_opendir(s, &vs->fidp->path);\n\n        v9fs_open_post_opendir(s, vs, err);\n\n    } else {\n\n        if (s->proto_version == V9FS_PROTO_2000L) {\n\n            if (!valid_flags(vs->mode)) {\n\n                err = -EINVAL;\n\n                goto out;\n\n            }\n\n            flags = vs->mode;\n\n        } else {\n\n            flags = omode_to_uflags(vs->mode);\n\n        }\n\n        vs->fidp->fs.fd = v9fs_do_open(s, &vs->fidp->path, flags);\n\n        v9fs_open_post_open(s, vs, err);\n\n    }\n\n    return;\n\nout:\n\n    complete_pdu(s, vs->pdu, err);\n\n    qemu_free(vs);\n\n}\n", "idx": 880}
{"project": "qemu", "commit_id": "94ad93bd976841c26af75322301f5aad925114d6", "target": 0, "func": "static void spapr_cpu_core_unrealizefn(DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRCPUCore *sc = SPAPR_CPU_CORE(OBJECT(dev));\n\n    sPAPRCPUCoreClass *scc = SPAPR_CPU_CORE_GET_CLASS(OBJECT(dev));\n\n    size_t size = object_type_get_instance_size(scc->cpu_type);\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    int i;\n\n\n\n    for (i = 0; i < cc->nr_threads; i++) {\n\n        void *obj = sc->threads + i * size;\n\n        DeviceState *dev = DEVICE(obj);\n\n        CPUState *cs = CPU(dev);\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n\n\n        spapr_cpu_destroy(cpu);\n\n        object_unparent(cpu->intc);\n\n        cpu_remove_sync(cs);\n\n        object_unparent(obj);\n\n    }\n\n    g_free(sc->threads);\n\n}\n", "idx": 881}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static uint32_t taihu_cpld_readw (void *opaque, hwaddr addr)\n\n{\n\n    uint32_t ret;\n\n\n\n    ret = taihu_cpld_readb(opaque, addr) << 8;\n\n    ret |= taihu_cpld_readb(opaque, addr + 1);\n\n\n\n    return ret;\n\n}\n", "idx": 884}
{"project": "qemu", "commit_id": "3356128cd13d7ec7689b7cddd3efbfbc5339a262", "target": 0, "func": "int vfio_container_ioctl(AddressSpace *as, int32_t groupid,\n\n                         int req, void *param)\n\n{\n\n    /* We allow only certain ioctls to the container */\n\n    switch (req) {\n\n    case VFIO_CHECK_EXTENSION:\n\n    case VFIO_IOMMU_SPAPR_TCE_GET_INFO:\n\n    case VFIO_EEH_PE_OP:\n\n        break;\n\n    default:\n\n        /* Return an error on unknown requests */\n\n        error_report(\"vfio: unsupported ioctl %X\", req);\n\n        return -1;\n\n    }\n\n\n\n    return vfio_container_do_ioctl(as, groupid, req, param);\n\n}\n", "idx": 885}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /* Check if the request is in interrupt address range */\n\n    if (vtd_is_interrupt_addr(addr)) {\n\n        if (is_write) {\n\n            /* FIXME: since we don't know the length of the access here, we\n\n             * treat Non-DWORD length write requests without PASID as\n\n             * interrupt requests, too. Withoud interrupt remapping support,\n\n             * we just use 1:1 mapping.\n\n             */\n\n            VTD_DPRINTF(MMU, \"write request to interrupt address \"\n\n                        \"gpa 0x%\"PRIx64, addr);\n\n            entry->iova = addr & VTD_PAGE_MASK_4K;\n\n            entry->translated_addr = addr & VTD_PAGE_MASK_4K;\n\n            entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n            entry->perm = IOMMU_WO;\n\n            return;\n\n        } else {\n\n            VTD_DPRINTF(GENERAL, \"error: read request from interrupt address \"\n\n                        \"gpa 0x%\"PRIx64, addr);\n\n            vtd_report_dmar_fault(s, source_id, addr, VTD_FR_READ, is_write);\n\n            return;\n\n        }\n\n    }\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        VTD_DPRINTF(CACHE, \"hit iotlb sid 0x%\"PRIx16 \" gpa 0x%\"PRIx64\n\n                    \" slpte 0x%\"PRIx64 \" did 0x%\"PRIx16, source_id, addr,\n\n                    iotlb_entry->slpte, iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        reads = iotlb_entry->read_flags;\n\n        writes = iotlb_entry->write_flags;\n\n        goto out;\n\n    }\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        VTD_DPRINTF(CACHE, \"hit context-cache bus %d devfn %d \"\n\n                    \"(hi %\"PRIx64 \" lo %\"PRIx64 \" gen %\"PRIu32 \")\",\n\n                    bus_num, devfn, cc_entry->context_entry.hi,\n\n                    cc_entry->context_entry.lo, cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                VTD_DPRINTF(FLOG, \"fault processing is disabled for DMA \"\n\n                            \"requests through this context-entry \"\n\n                            \"(with FPD Set)\");\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            return;\n\n        }\n\n        /* Update context-cache */\n\n        VTD_DPRINTF(CACHE, \"update context-cache bus %d devfn %d \"\n\n                    \"(hi %\"PRIx64 \" lo %\"PRIx64 \" gen %\"PRIu32 \"->%\"PRIu32 \")\",\n\n                    bus_num, devfn, ce.hi, ce.lo,\n\n                    cc_entry->context_cache_gen, s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    ret_fr = vtd_gpa_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                              &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            VTD_DPRINTF(FLOG, \"fault processing is disabled for DMA requests \"\n\n                        \"through this context-entry (with FPD Set)\");\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        return;\n\n    }\n\n\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     reads, writes);\n\nout:\n\n    entry->iova = addr & VTD_PAGE_MASK_4K;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & VTD_PAGE_MASK_4K;\n\n    entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n    entry->perm = (writes ? 2 : 0) + (reads ? 1 : 0);\n\n}\n", "idx": 887}
{"project": "qemu", "commit_id": "d9e147ad1050f58d0fdcf2d2d53aa8d57dd7b0e2", "target": 0, "func": "void call_pal (CPUState *env, int palcode)\n\n{\n\n    target_ulong ret;\n\n\n\n    if (logfile != NULL)\n\n        fprintf(logfile, \"%s: palcode %02x\\n\", __func__, palcode);\n\n    switch (palcode) {\n\n    case 0x83:\n\n        /* CALLSYS */\n\n        if (logfile != NULL)\n\n            fprintf(logfile, \"CALLSYS n \" TARGET_FMT_ld \"\\n\", env->ir[0]);\n\n        ret = do_syscall(env, env->ir[IR_V0], env->ir[IR_A0], env->ir[IR_A1],\n\n                         env->ir[IR_A2], env->ir[IR_A3], env->ir[IR_A4],\n\n                         env->ir[IR_A5]);\n\n        if (ret >= 0) {\n\n            env->ir[IR_A3] = 0;\n\n            env->ir[IR_V0] = ret;\n\n        } else {\n\n            env->ir[IR_A3] = 1;\n\n            env->ir[IR_V0] = -ret;\n\n        }\n\n        break;\n\n    case 0x9E:\n\n        /* RDUNIQUE */\n\n        env->ir[IR_V0] = env->unique;\n\n        if (logfile != NULL)\n\n            fprintf(logfile, \"RDUNIQUE: \" TARGET_FMT_lx \"\\n\", env->unique);\n\n        break;\n\n    case 0x9F:\n\n        /* WRUNIQUE */\n\n        env->unique = env->ir[IR_A0];\n\n        if (logfile != NULL)\n\n            fprintf(logfile, \"WRUNIQUE: \" TARGET_FMT_lx \"\\n\", env->unique);\n\n        break;\n\n    default:\n\n        if (logfile != NULL)\n\n            fprintf(logfile, \"%s: unhandled palcode %02x\\n\",\n\n                    __func__, palcode);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 888}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,\n\n                                  const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                                  const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                                  const uint16_t *abuf0, uint8_t *dest,\n\n                                  int dstW, int uvalpha, enum PixelFormat dstFormat,\n\n                                  int flags, int y)\n\n{\n\n    const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2PACKED1(%%REGBP, %5)\n\n            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2PACKED1b(%%REGBP, %5)\n\n            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 889}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2gray16_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                        const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                        const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                        const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                        int uvalpha, enum PixelFormat dstFormat,\n\n                        int flags, int y, enum PixelFormat target)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        const int i2 = 2 * i;\n\n        int Y1 = buf0[i2  ] << 1;\n\n        int Y2 = buf0[i2+1] << 1;\n\n\n\n        output_pixel(&dest[2 * i2 + 0], Y1);\n\n        output_pixel(&dest[2 * i2 + 2], Y2);\n\n    }\n\n}\n", "idx": 890}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_efdctuiz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint32_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 891}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "int qcow2_zero_clusters(BlockDriverState *bs, uint64_t offset, int nb_sectors)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    unsigned int nb_clusters;\n\n    int ret;\n\n\n\n    /* The zero flag is only supported by version 3 and newer */\n\n    if (s->qcow_version < 3) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /* Each L2 table is handled by its own loop iteration */\n\n    nb_clusters = size_to_clusters(s, nb_sectors << BDRV_SECTOR_BITS);\n\n\n\n    s->cache_discards = true;\n\n\n\n    while (nb_clusters > 0) {\n\n        ret = zero_single_l2(bs, offset, nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        nb_clusters -= ret;\n\n        offset += (ret * s->cluster_size);\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    s->cache_discards = false;\n\n    qcow2_process_discards(bs, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 892}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "void async_context_push(void)\n\n{\n\n    struct AsyncContext *new = qemu_mallocz(sizeof(*new));\n\n    new->parent = async_context;\n\n    new->id = async_context->id + 1;\n\n    async_context = new;\n\n}\n", "idx": 893}
{"project": "FFmpeg", "commit_id": "53c853e0491691d4ee6f33e6348da2ffc7d345d8", "target": 0, "func": "static int h264_extradata_to_annexb(AVCodecContext *avctx, const int padding)\n\n{\n\n    uint16_t unit_size;\n\n    uint64_t total_size                 = 0;\n\n    uint8_t *out                        = NULL, unit_nb, sps_done = 0,\n\n             sps_seen                   = 0, pps_seen = 0;\n\n    const uint8_t *extradata            = avctx->extradata + 4;\n\n    static const uint8_t nalu_header[4] = { 0, 0, 0, 1 };\n\n    int length_size = (*extradata++ & 0x3) + 1; // retrieve length coded size\n\n\n\n    /* retrieve sps and pps unit(s) */\n\n    unit_nb = *extradata++ & 0x1f; /* number of sps unit(s) */\n\n    if (!unit_nb) {\n\n        goto pps;\n\n    } else {\n\n        sps_seen = 1;\n\n    }\n\n\n\n    while (unit_nb--) {\n\n        void *tmp;\n\n\n\n        unit_size   = AV_RB16(extradata);\n\n        total_size += unit_size + 4;\n\n        if (total_size > INT_MAX - padding ||\n\n            extradata + 2 + unit_size > avctx->extradata +\n\n            avctx->extradata_size) {\n\n            av_free(out);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        tmp = av_realloc(out, total_size + padding);\n\n        if (!tmp) {\n\n            av_free(out);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        out = tmp;\n\n        memcpy(out + total_size - unit_size - 4, nalu_header, 4);\n\n        memcpy(out + total_size - unit_size, extradata + 2, unit_size);\n\n        extradata += 2 + unit_size;\n\npps:\n\n        if (!unit_nb && !sps_done++) {\n\n            unit_nb = *extradata++; /* number of pps unit(s) */\n\n            if (unit_nb)\n\n                pps_seen = 1;\n\n        }\n\n    }\n\n\n\n    if (out)\n\n        memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if (!sps_seen)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Warning: SPS NALU missing or invalid. \"\n\n               \"The resulting stream may not play.\\n\");\n\n\n\n    if (!pps_seen)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Warning: PPS NALU missing or invalid. \"\n\n               \"The resulting stream may not play.\\n\");\n\n\n\n    av_free(avctx->extradata);\n\n    avctx->extradata      = out;\n\n    avctx->extradata_size = total_size;\n\n\n\n    return length_size;\n\n}\n", "idx": 894}
{"project": "qemu", "commit_id": "d17d45e95f497e67aa48ff9e49a4ad62bb1e17df", "target": 0, "func": "static inline void stl_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n    hwaddr l = 4;\n\n    hwaddr addr1;\n\n\n\n    section = address_space_translate(&address_space_memory, addr, &addr1, &l,\n\n                                      true);\n\n    if (l < 4 || !memory_region_is_ram(section->mr) || section->readonly) {\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap32(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap32(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr1, val, 4);\n\n    } else {\n\n        /* RAM case */\n\n        addr1 += memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK;\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stl_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stl_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stl_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 4);\n\n    }\n\n}\n", "idx": 895}
{"project": "qemu", "commit_id": "91b85bd388c3767e6b63aaf33851dbfe87ea24d1", "target": 0, "func": "static int vmdk_write(BlockDriverState *bs, int64_t sector_num,\n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent = NULL;\n\n    int n;\n\n    int64_t index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    VmdkMetaData m_data;\n\n\n\n    if (sector_num > bs->total_sectors) {\n\n        fprintf(stderr,\n\n                \"(VMDK) Wrong offset: sector_num=0x%\" PRIx64\n\n                \" total_sectors=0x%\" PRIx64 \"\\n\",\n\n                sector_num, bs->total_sectors);\n\n        return -1;\n\n    }\n\n\n\n    while (nb_sectors > 0) {\n\n        extent = find_extent(s, sector_num, extent);\n\n        if (!extent) {\n\n            return -EIO;\n\n        }\n\n        cluster_offset = get_cluster_offset(\n\n                                bs,\n\n                                extent,\n\n                                &m_data,\n\n                                sector_num << 9, 1);\n\n        if (!cluster_offset) {\n\n            return -1;\n\n        }\n\n        index_in_cluster = sector_num % extent->cluster_sectors;\n\n        n = extent->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (bdrv_pwrite(bs->file,\n\n                        cluster_offset + index_in_cluster * 512,\n\n                        buf, n * 512)\n\n                != n * 512) {\n\n            return -1;\n\n        }\n\n        if (m_data.valid) {\n\n            /* update L2 tables */\n\n            if (vmdk_L2update(extent, &m_data) == -1) {\n\n                return -1;\n\n            }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n\n\n        // update CID on the first write every time the virtual disk is opened\n\n        if (!s->cid_updated) {\n\n            vmdk_write_cid(bs, time(NULL));\n\n            s->cid_updated = true;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 896}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], ~0x8000000080000000LL);\n\n#else\n\n    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], ~0x80000000);\n\n    tcg_gen_andi_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], ~0x80000000);\n\n#endif\n\n}\n", "idx": 897}
{"project": "qemu", "commit_id": "7c37e6a4c4972ad3cdb2478a0249757ee3a1bf70", "target": 0, "func": "void usb_ep_reset(USBDevice *dev)\n\n{\n\n    int ep;\n\n\n\n    dev->ep_ctl.nr = 0;\n\n    dev->ep_ctl.type = USB_ENDPOINT_XFER_CONTROL;\n\n    dev->ep_ctl.ifnum = 0;\n\n    dev->ep_ctl.dev = dev;\n\n    dev->ep_ctl.pipeline = false;\n\n    for (ep = 0; ep < USB_MAX_ENDPOINTS; ep++) {\n\n        dev->ep_in[ep].nr = ep + 1;\n\n        dev->ep_out[ep].nr = ep + 1;\n\n        dev->ep_in[ep].pid = USB_TOKEN_IN;\n\n        dev->ep_out[ep].pid = USB_TOKEN_OUT;\n\n        dev->ep_in[ep].type = USB_ENDPOINT_XFER_INVALID;\n\n        dev->ep_out[ep].type = USB_ENDPOINT_XFER_INVALID;\n\n        dev->ep_in[ep].ifnum = 0;\n\n        dev->ep_out[ep].ifnum = 0;\n\n        dev->ep_in[ep].dev = dev;\n\n        dev->ep_out[ep].dev = dev;\n\n        dev->ep_in[ep].pipeline = false;\n\n        dev->ep_out[ep].pipeline = false;\n\n    }\n\n}\n", "idx": 898}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "int qemu_v9fs_synth_mkdir(V9fsSynthNode *parent, int mode,\n\n                          const char *name, V9fsSynthNode **result)\n\n{\n\n    int ret;\n\n    V9fsSynthNode *node, *tmp;\n\n\n\n    if (!v9fs_synth_fs) {\n\n        return EAGAIN;\n\n    }\n\n    if (!name || (strlen(name) >= NAME_MAX)) {\n\n        return EINVAL;\n\n    }\n\n    if (!parent) {\n\n        parent = &v9fs_synth_root;\n\n    }\n\n    qemu_mutex_lock(&v9fs_synth_mutex);\n\n    QLIST_FOREACH(tmp, &parent->child, sibling) {\n\n        if (!strcmp(tmp->name, name)) {\n\n            ret = EEXIST;\n\n            goto err_out;\n\n        }\n\n    }\n\n    /* Add the name */\n\n    node = v9fs_add_dir_node(parent, mode, name, NULL, v9fs_synth_node_count++);\n\n    v9fs_add_dir_node(node, parent->attr->mode, \"..\",\n\n                      parent->attr, parent->attr->inode);\n\n    v9fs_add_dir_node(node, node->attr->mode, \".\",\n\n                      node->attr, node->attr->inode);\n\n    *result = node;\n\n    ret = 0;\n\nerr_out:\n\n    qemu_mutex_unlock(&v9fs_synth_mutex);\n\n    return ret;\n\n}\n", "idx": 900}
{"project": "qemu", "commit_id": "8cc46787b5b58f01a11c919c7ff939ed009e27fc", "target": 0, "func": "static void megasas_handle_frame(MegasasState *s, uint64_t frame_addr,\n\n                                 uint32_t frame_count)\n\n{\n\n    uint8_t frame_status = MFI_STAT_INVALID_CMD;\n\n    uint64_t frame_context;\n\n    MegasasCmd *cmd;\n\n\n\n    /*\n\n     * Always read 64bit context, top bits will be\n\n     * masked out if required in megasas_enqueue_frame()\n\n     */\n\n    frame_context = megasas_frame_get_context(s, frame_addr);\n\n\n\n    cmd = megasas_enqueue_frame(s, frame_addr, frame_context, frame_count);\n\n    if (!cmd) {\n\n        /* reply queue full */\n\n        trace_megasas_frame_busy(frame_addr);\n\n        megasas_frame_set_scsi_status(s, frame_addr, BUSY);\n\n        megasas_frame_set_cmd_status(s, frame_addr, MFI_STAT_SCSI_DONE_WITH_ERROR);\n\n        megasas_complete_frame(s, frame_context);\n\n        s->event_count++;\n\n        return;\n\n    }\n\n    switch (cmd->frame->header.frame_cmd) {\n\n    case MFI_CMD_INIT:\n\n        frame_status = megasas_init_firmware(s, cmd);\n\n        break;\n\n    case MFI_CMD_DCMD:\n\n        frame_status = megasas_handle_dcmd(s, cmd);\n\n        break;\n\n    case MFI_CMD_ABORT:\n\n        frame_status = megasas_handle_abort(s, cmd);\n\n        break;\n\n    case MFI_CMD_PD_SCSI_IO:\n\n        frame_status = megasas_handle_scsi(s, cmd, 0);\n\n        break;\n\n    case MFI_CMD_LD_SCSI_IO:\n\n        frame_status = megasas_handle_scsi(s, cmd, 1);\n\n        break;\n\n    case MFI_CMD_LD_READ:\n\n    case MFI_CMD_LD_WRITE:\n\n        frame_status = megasas_handle_io(s, cmd);\n\n        break;\n\n    default:\n\n        trace_megasas_unhandled_frame_cmd(cmd->index,\n\n                                          cmd->frame->header.frame_cmd);\n\n        s->event_count++;\n\n        break;\n\n    }\n\n    if (frame_status != MFI_STAT_INVALID_STATUS) {\n\n        if (cmd->frame) {\n\n            cmd->frame->header.cmd_status = frame_status;\n\n        } else {\n\n            megasas_frame_set_cmd_status(s, frame_addr, frame_status);\n\n        }\n\n        megasas_unmap_frame(s, cmd);\n\n        megasas_complete_frame(s, cmd->context);\n\n    }\n\n}\n", "idx": 901}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffff);\n\n}\n", "idx": 902}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "void pcnet_common_cleanup(PCNetState *d)\n\n{\n\n    d->nic = NULL;\n\n}\n", "idx": 903}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lan9118_16bit_mode_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t val, unsigned size)\n\n{\n\n    switch (size) {\n\n    case 2:\n\n        lan9118_writew(opaque, offset, (uint32_t)val);\n\n        return;\n\n    case 4:\n\n        lan9118_writel(opaque, offset, val, size);\n\n        return;\n\n    }\n\n\n\n    hw_error(\"lan9118_write: Bad size 0x%x\\n\", size);\n\n}\n", "idx": 904}
{"project": "FFmpeg", "commit_id": "65afa65e7393e7745427e267d6c6ca814c7c8b45", "target": 0, "func": "av_cold int ff_h264_decode_init(AVCodecContext *avctx)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    int ret;\n\n\n\n    ret = h264_init_context(avctx, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n\n\n\n    /* set defaults */\n\n    // s->decode_mb = ff_h263_decode_mb;\n\n    if (!avctx->has_b_frames)\n\n        h->low_delay = 1;\n\n\n\n    ff_h264_decode_init_vlc();\n\n\n\n    ff_init_cabac_states();\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_H264) {\n\n        if (avctx->ticks_per_frame == 1)\n\n            h->avctx->framerate.num *= 2;\n\n        avctx->ticks_per_frame = 2;\n\n    }\n\n\n\n    if (avctx->extradata_size > 0 && avctx->extradata) {\n\n       ret = ff_h264_decode_extradata(h);\n\n       if (ret < 0) {\n\n           ff_h264_free_context(h);\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    if (h->sps.bitstream_restriction_flag &&\n\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        h->low_delay           = 0;\n\n    }\n\n\n\n    avctx->internal->allocate_progress = 1;\n\n\n\n    if (h->enable_er) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Error resilience is enabled. It is unsafe and unsupported and may crash. \"\n\n               \"Use it at your own risk\\n\");\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 905}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_desc_load(struct Stream *s, hwaddr addr)\n\n{\n\n    struct SDesc *d = &s->desc;\n\n    int i;\n\n\n\n    cpu_physical_memory_read(addr, (void *) d, sizeof *d);\n\n\n\n    /* Convert from LE into host endianness.  */\n\n    d->buffer_address = le64_to_cpu(d->buffer_address);\n\n    d->nxtdesc = le64_to_cpu(d->nxtdesc);\n\n    d->control = le32_to_cpu(d->control);\n\n    d->status = le32_to_cpu(d->status);\n\n    for (i = 0; i < ARRAY_SIZE(d->app); i++) {\n\n        d->app[i] = le32_to_cpu(d->app[i]);\n\n    }\n\n}\n", "idx": 907}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState *qemu_chr_open_win_file(HANDLE fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    s->hcom = fd_out;\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    return chr;\n\n}\n", "idx": 908}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "void gdb_exit(CPUState *env, int code)\n\n{\n\n  GDBState *s;\n\n  char buf[4];\n\n\n\n  s = &gdbserver_state;\n\n  if (gdbserver_fd < 0 || s->fd < 0)\n\n    return;\n\n\n\n  snprintf(buf, sizeof(buf), \"W%02x\", code);\n\n  put_packet(s, buf);\n\n}\n", "idx": 909}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix4_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 910}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void pxa2xx_gpio_write(void *opaque, hwaddr offset,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        s->dir[bank] = value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        s->olevel[bank] |= value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        s->olevel[bank] &= ~value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising[bank] = value;\n\n        break;\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling[bank] = value;\n\n        break;\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2] = value;\n\n        break;\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2 + 1] = value;\n\n        break;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        s->status[bank] &= ~value;\n\n        pxa2xx_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n}\n", "idx": 911}
{"project": "qemu", "commit_id": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d", "target": 0, "func": "int cpu_signal_handler(int host_signum, void *pinfo, void *puc)\n\n{\n\n    siginfo_t *info = pinfo;\n\n    ucontext_t *uc = puc;\n\n    unsigned long ip;\n\n    int is_write = 0;\n\n\n\n    ip = uc->uc_mcontext.sc_ip;\n\n    switch (host_signum) {\n\n    case SIGILL:\n\n    case SIGFPE:\n\n    case SIGSEGV:\n\n    case SIGBUS:\n\n    case SIGTRAP:\n\n        if (info->si_code && (info->si_segvflags & __ISR_VALID)) {\n\n            /* ISR.W (write-access) is bit 33:  */\n\n            is_write = (info->si_isr >> 33) & 1;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n    return handle_cpu_signal(ip, (unsigned long)info->si_addr,\n\n                             is_write,\n\n                             (sigset_t *)&uc->uc_sigmask);\n\n}\n", "idx": 912}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "void virtio_blk_data_plane_start(VirtIOBlockDataPlane *s)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s->vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOBlock *vblk = VIRTIO_BLK(s->vdev);\n\n    VirtQueue *vq;\n\n    int r;\n\n\n\n    if (s->started || s->disabled) {\n\n        return;\n\n    }\n\n\n\n    if (s->starting) {\n\n        return;\n\n    }\n\n\n\n    s->starting = true;\n\n\n\n    vq = virtio_get_queue(s->vdev, 0);\n\n    if (!vring_setup(&s->vring, s->vdev, 0)) {\n\n        goto fail_vring;\n\n    }\n\n\n\n    /* Set up guest notifier (irq) */\n\n    r = k->set_guest_notifiers(qbus->parent, 1, true);\n\n    if (r != 0) {\n\n        fprintf(stderr, \"virtio-blk failed to set guest notifier (%d), \"\n\n                \"ensure -enable-kvm is set\\n\", r);\n\n        goto fail_guest_notifiers;\n\n    }\n\n    s->guest_notifier = virtio_queue_get_guest_notifier(vq);\n\n\n\n    /* Set up virtqueue notify */\n\n    r = k->set_host_notifier(qbus->parent, 0, true);\n\n    if (r != 0) {\n\n        fprintf(stderr, \"virtio-blk failed to set host notifier (%d)\\n\", r);\n\n        goto fail_host_notifier;\n\n    }\n\n    s->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n\n\n    s->saved_complete_request = vblk->complete_request;\n\n    vblk->complete_request = complete_request_vring;\n\n\n\n    s->starting = false;\n\n    s->started = true;\n\n    trace_virtio_blk_data_plane_start(s);\n\n\n\n    blk_set_aio_context(s->conf->conf.blk, s->ctx);\n\n\n\n    /* Kick right away to begin processing requests already in vring */\n\n    event_notifier_set(virtio_queue_get_host_notifier(vq));\n\n\n\n    /* Get this show started by hooking up our callbacks */\n\n    aio_context_acquire(s->ctx);\n\n    aio_set_event_notifier(s->ctx, &s->host_notifier, true,\n\n                           handle_notify);\n\n    aio_context_release(s->ctx);\n\n    return;\n\n\n\n  fail_host_notifier:\n\n    k->set_guest_notifiers(qbus->parent, 1, false);\n\n  fail_guest_notifiers:\n\n    vring_teardown(&s->vring, s->vdev, 0);\n\n    s->disabled = true;\n\n  fail_vring:\n\n    s->starting = false;\n\n}\n", "idx": 915}
{"project": "FFmpeg", "commit_id": "3bbe7f5d6b8215ed2dcce0c50e93137919f3d384", "target": 0, "func": "static void qdm2_decode_fft_packets (QDM2Context *q)\n\n{\n\n    int i, j, min, max, value, type, unknown_flag;\n\n    GetBitContext gb;\n\n\n\n    if (q->sub_packet_list_B[0].packet == NULL)\n\n        return;\n\n\n\n    /* reset minimum indices for FFT coefficients */\n\n    q->fft_coefs_index = 0;\n\n    for (i=0; i < 5; i++)\n\n        q->fft_coefs_min_index[i] = -1;\n\n\n\n    /* process subpackets ordered by type, largest type first */\n\n    for (i = 0, max = 256; i < q->sub_packets_B; i++) {\n\n        QDM2SubPacket *packet;\n\n\n\n        /* find subpacket with largest type less than max */\n\n        for (j = 0, min = 0, packet = NULL; j < q->sub_packets_B; j++) {\n\n            value = q->sub_packet_list_B[j].packet->type;\n\n            if (value > min && value < max) {\n\n                min = value;\n\n                packet = q->sub_packet_list_B[j].packet;\n\n            }\n\n        }\n\n\n\n        max = min;\n\n\n\n        /* check for errors (?) */\n\n        if (i == 0 && (packet->type < 16 || packet->type >= 48 || fft_subpackets[packet->type - 16]))\n\n            return;\n\n\n\n        /* decode FFT tones */\n\n        init_get_bits (&gb, packet->data, packet->size*8);\n\n\n\n        if (packet->type >= 32 && packet->type < 48 && !fft_subpackets[packet->type - 16])\n\n            unknown_flag = 1;\n\n        else\n\n            unknown_flag = 0;\n\n\n\n        type = packet->type;\n\n\n\n        if ((type >= 17 && type < 24) || (type >= 33 && type < 40)) {\n\n            int duration = q->sub_sampling + 5 - (type & 15);\n\n\n\n            if (duration >= 0 && duration < 4)\n\n                qdm2_fft_decode_tones(q, duration, &gb, unknown_flag);\n\n        } else if (type == 31) {\n\n            for (i=0; i < 4; i++)\n\n                qdm2_fft_decode_tones(q, i, &gb, unknown_flag);\n\n        } else if (type == 46) {\n\n            for (i=0; i < 6; i++)\n\n                q->fft_level_exp[i] = get_bits(&gb, 6);\n\n            for (i=0; i < 4; i++)\n\n            qdm2_fft_decode_tones(q, i, &gb, unknown_flag);\n\n        }\n\n    } // Loop on B packets\n\n\n\n    /* calculate maximum indices for FFT coefficients */\n\n    for (i = 0, j = -1; i < 5; i++)\n\n        if (q->fft_coefs_min_index[i] >= 0) {\n\n            if (j >= 0)\n\n                q->fft_coefs_max_index[j] = q->fft_coefs_min_index[i];\n\n            j = i;\n\n        }\n\n    if (j >= 0)\n\n        q->fft_coefs_max_index[j] = q->fft_coefs_index;\n\n}\n", "idx": 916}
{"project": "FFmpeg", "commit_id": "862c1d2f0573c81ed0929b685c55959906b4300c", "target": 0, "func": "void avcodec_get_channel_layout_string(char *buf, int buf_size, int nb_channels, int64_t channel_layout)\n\n{\n\n    int i;\n\n\n\n    if (channel_layout==0)\n\n        channel_layout = avcodec_guess_channel_layout(nb_channels, CODEC_ID_NONE, NULL);\n\n\n\n    for (i=0; channel_layout_map[i].name; i++)\n\n        if (nb_channels    == channel_layout_map[i].nb_channels &&\n\n            channel_layout == channel_layout_map[i].layout) {\n\n            snprintf(buf, buf_size, channel_layout_map[i].name);\n\n            return;\n\n        }\n\n\n\n    snprintf(buf, buf_size, \"%d channels\", nb_channels);\n\n    if (channel_layout) {\n\n        int i,ch;\n\n        av_strlcat(buf, \" (\", buf_size);\n\n        for(i=0,ch=0; i<64; i++) {\n\n            if ((channel_layout & (1L<<i))) {\n\n                const char *name = get_channel_name(i);\n\n                if (name) {\n\n                    if (ch>0) av_strlcat(buf, \"|\", buf_size);\n\n                    av_strlcat(buf, name, buf_size);\n\n                }\n\n                ch++;\n\n            }\n\n        }\n\n        av_strlcat(buf, \")\", buf_size);\n\n    }\n\n}\n", "idx": 917}
{"project": "FFmpeg", "commit_id": "aa427537b529cd584cd73222980286d36a00fe28", "target": 0, "func": "int ff_h264_decode_ref_pic_list_reordering(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int list, index, pic_structure;\n\n\n\n    print_short_term(h);\n\n    print_long_term(h);\n\n\n\n    for (list = 0; list < sl->list_count; list++) {\n\n        memcpy(sl->ref_list[list], h->default_ref_list[list], sl->ref_count[list] * sizeof(sl->ref_list[0][0]));\n\n\n\n        if (get_bits1(&sl->gb)) {    // ref_pic_list_modification_flag_l[01]\n\n            int pred = h->curr_pic_num;\n\n\n\n            for (index = 0; ; index++) {\n\n                unsigned int modification_of_pic_nums_idc = get_ue_golomb_31(&sl->gb);\n\n                unsigned int pic_id;\n\n                int i;\n\n                H264Picture *ref = NULL;\n\n\n\n                if (modification_of_pic_nums_idc == 3)\n\n                    break;\n\n\n\n                if (index >= sl->ref_count[list]) {\n\n                    av_log(h->avctx, AV_LOG_ERROR, \"reference count overflow\\n\");\n\n                    return -1;\n\n                }\n\n\n\n                switch (modification_of_pic_nums_idc) {\n\n                case 0:\n\n                case 1: {\n\n                    const unsigned int abs_diff_pic_num = get_ue_golomb(&sl->gb) + 1;\n\n                    int frame_num;\n\n\n\n                    if (abs_diff_pic_num > h->max_pic_num) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"abs_diff_pic_num overflow\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    if (modification_of_pic_nums_idc == 0)\n\n                        pred -= abs_diff_pic_num;\n\n                    else\n\n                        pred += abs_diff_pic_num;\n\n                    pred &= h->max_pic_num - 1;\n\n\n\n                    frame_num = pic_num_extract(h, pred, &pic_structure);\n\n\n\n                    for (i = h->short_ref_count - 1; i >= 0; i--) {\n\n                        ref = h->short_ref[i];\n\n                        assert(ref->reference);\n\n                        assert(!ref->long_ref);\n\n                        if (ref->frame_num == frame_num &&\n\n                            (ref->reference & pic_structure))\n\n                            break;\n\n                    }\n\n                    if (i >= 0)\n\n                        ref->pic_id = pred;\n\n                    break;\n\n                }\n\n                case 2: {\n\n                    int long_idx;\n\n                    pic_id = get_ue_golomb(&sl->gb); // long_term_pic_idx\n\n\n\n                    long_idx = pic_num_extract(h, pic_id, &pic_structure);\n\n\n\n                    if (long_idx > 31) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"long_term_pic_idx overflow\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ref = h->long_ref[long_idx];\n\n                    assert(!(ref && !ref->reference));\n\n                    if (ref && (ref->reference & pic_structure)) {\n\n                        ref->pic_id = pic_id;\n\n                        assert(ref->long_ref);\n\n                        i = 0;\n\n                    } else {\n\n                        i = -1;\n\n                    }\n\n                    break;\n\n                }\n\n                default:\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal modification_of_pic_nums_idc %u\\n\",\n\n                           modification_of_pic_nums_idc);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (i < 0) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"reference picture missing during reorder\\n\");\n\n                    memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME\n\n                } else {\n\n                    for (i = index; i + 1 < sl->ref_count[list]; i++) {\n\n                        if (sl->ref_list[list][i].parent &&\n\n                            ref->long_ref == sl->ref_list[list][i].parent->long_ref &&\n\n                            ref->pic_id   == sl->ref_list[list][i].pic_id)\n\n                            break;\n\n                    }\n\n                    for (; i > index; i--) {\n\n                        sl->ref_list[list][i] = sl->ref_list[list][i - 1];\n\n                    }\n\n                    ref_from_h264pic(&sl->ref_list[list][index], ref);\n\n                    if (FIELD_PICTURE(h)) {\n\n                        pic_as_field(&sl->ref_list[list][index], pic_structure);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (list = 0; list < sl->list_count; list++) {\n\n        for (index = 0; index < sl->ref_count[list]; index++) {\n\n            if (   !sl->ref_list[list][index].parent\n\n                || (!FIELD_PICTURE(h) && (sl->ref_list[list][index].reference&3) != 3)) {\n\n                int i;\n\n                av_log(h->avctx, AV_LOG_ERROR, \"Missing reference picture, default is %d\\n\", h->default_ref_list[list][0].poc);\n\n                for (i = 0; i < FF_ARRAY_ELEMS(h->last_pocs); i++)\n\n                    h->last_pocs[i] = INT_MIN;\n\n                if (h->default_ref_list[list][0].parent\n\n                    && !(!FIELD_PICTURE(h) && (h->default_ref_list[list][0].reference&3) != 3))\n\n                    sl->ref_list[list][index] = h->default_ref_list[list][0];\n\n                else\n\n                    return -1;\n\n            }\n\n            av_assert0(av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 918}
{"project": "FFmpeg", "commit_id": "ec849f637e8548ec6c9b6329334944c7c81df443", "target": 1, "func": "void FUNCC(ff_h264_chroma422_dc_dequant_idct)(int16_t *_block, int qmul){\n\n    const int stride= 16*2;\n\n    const int xStride= 16;\n\n    int i;\n\n    int temp[8];\n\n    static const uint8_t x_offset[2]={0, 16};\n\n    dctcoef *block = (dctcoef*)_block;\n\n\n\n    for(i=0; i<4; i++){\n\n        temp[2*i+0] = block[stride*i + xStride*0] + block[stride*i + xStride*1];\n\n        temp[2*i+1] = block[stride*i + xStride*0] - block[stride*i + xStride*1];\n\n    }\n\n\n\n    for(i=0; i<2; i++){\n\n        const int offset= x_offset[i];\n\n        const int z0= temp[2*0+i] + temp[2*2+i];\n\n        const int z1= temp[2*0+i] - temp[2*2+i];\n\n        const int z2= temp[2*1+i] - temp[2*3+i];\n\n        const int z3= temp[2*1+i] + temp[2*3+i];\n\n\n\n        block[stride*0+offset]= ((z0 + z3)*qmul + 128) >> 8;\n\n        block[stride*1+offset]= ((z1 + z2)*qmul + 128) >> 8;\n\n        block[stride*2+offset]= ((z1 - z2)*qmul + 128) >> 8;\n\n        block[stride*3+offset]= ((z0 - z3)*qmul + 128) >> 8;\n\n    }\n\n}\n", "idx": 919}
{"project": "qemu", "commit_id": "6265eb26a375179f193f792e4f0d49036d2cf052", "target": 1, "func": "static int curl_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLState *state = NULL;\n\n    double d;\n\n\n\n    #define RA_OPTSTR \":readahead=\"\n\n    char *file;\n\n    char *ra;\n\n    const char *ra_val;\n\n    int parse_state = 0;\n\n\n\n    static int inited = 0;\n\n\n\n    file = strdup(filename);\n\n    s->readahead_size = READ_AHEAD_SIZE;\n\n\n\n    /* Parse a trailing \":readahead=#:\" param, if present. */\n\n    ra = file + strlen(file) - 1;\n\n    while (ra >= file) {\n\n        if (parse_state == 0) {\n\n            if (*ra == ':')\n\n                parse_state++;\n\n            else\n\n                break;\n\n        } else if (parse_state == 1) {\n\n            if (*ra > '9' || *ra < '0') {\n\n                char *opt_start = ra - strlen(RA_OPTSTR) + 1;\n\n                if (opt_start > file &&\n\n                    strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {\n\n                    ra_val = ra + 1;\n\n                    ra -= strlen(RA_OPTSTR) - 1;\n\n                    *ra = '\\0';\n\n                    s->readahead_size = atoi(ra_val);\n\n                    break;\n\n                } else {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        ra--;\n\n    }\n\n\n\n    if ((s->readahead_size & 0x1ff) != 0) {\n\n        fprintf(stderr, \"HTTP_READAHEAD_SIZE %zd is not a multiple of 512\\n\",\n\n                s->readahead_size);\n\n        goto out_noclean;\n\n    }\n\n\n\n    if (!inited) {\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        inited = 1;\n\n    }\n\n\n\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n\n    s->url = file;\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        goto out_noclean;\n\n\n\n    // Get file size\n\n\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);\n\n    if (curl_easy_perform(state->curl))\n\n        goto out;\n\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_read_cb);\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 0);\n\n    if (d)\n\n        s->len = (size_t)d;\n\n    else if(!s->len)\n\n        goto out;\n\n    DPRINTF(\"CURL: Size = %lld\\n\", (long long)s->len);\n\n\n\n    curl_clean_state(state);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\n\n\n    // Now we know the file exists and its size, so let's\n\n    // initialize the multi interface!\n\n\n\n    s->multi = curl_multi_init();\n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETDATA, s); \n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb ); \n\n    curl_multi_do(s);\n\n\n\n    return 0;\n\n\n\nout:\n\n    fprintf(stderr, \"CURL: Error opening file: %s\\n\", state->errmsg);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\nout_noclean:\n\n    qemu_free(file);\n\n    return -EINVAL;\n\n}\n", "idx": 920}
{"project": "FFmpeg", "commit_id": "47f0beadba9003391d8bfef59b15aa21a5b2d293", "target": 1, "func": "static void cin_decode_rle(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    int len, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        if (code & 0x80) {\n\n            len = code - 0x7F;\n\n            memset(dst, *src++, FFMIN(len, dst_end - dst));\n\n        } else {\n\n            len = code + 1;\n\n            memcpy(dst, src, FFMIN(len, dst_end - dst));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n    }\n\n}\n", "idx": 922}
{"project": "qemu", "commit_id": "79f9c75e1707082e56723787e6b3610a46843e20", "target": 1, "func": "static int64_t coroutine_fn iscsi_co_get_block_status(BlockDriverState *bs,\n\n                                                  int64_t sector_num,\n\n                                                  int nb_sectors, int *pnum,\n\n                                                  BlockDriverState **file)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct scsi_get_lba_status *lbas = NULL;\n\n    struct scsi_lba_status_descriptor *lbasd = NULL;\n\n    struct IscsiTask iTask;\n\n    uint64_t lba;\n\n    int64_t ret;\n\n\n\n    if (!is_sector_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* default to all sectors allocated */\n\n    ret = BDRV_BLOCK_DATA;\n\n    ret |= (sector_num << BDRV_SECTOR_BITS) | BDRV_BLOCK_OFFSET_VALID;\n\n    *pnum = nb_sectors;\n\n\n\n    /* LUN does not support logical block provisioning */\n\n    if (!iscsilun->lbpme) {\n\n        goto out;\n\n    }\n\n\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_get_lba_status_task(iscsilun->iscsi, iscsilun->lun,\n\n                                  lba, 8 + 16, iscsi_co_generic_cb,\n\n                                  &iTask) == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        if (iTask.task != NULL) {\n\n            scsi_free_scsi_task(iTask.task);\n\n            iTask.task = NULL;\n\n        }\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        /* in case the get_lba_status_callout fails (i.e.\n\n         * because the device is busy or the cmd is not\n\n         * supported) we pretend all blocks are allocated\n\n         * for backwards compatibility */\n\n        error_report(\"iSCSI GET_LBA_STATUS failed at lba %\" PRIu64 \": %s\",\n\n                     lba, iTask.err_str);\n\n        goto out_unlock;\n\n    }\n\n\n\n    lbas = scsi_datain_unmarshall(iTask.task);\n\n    if (lbas == NULL) {\n\n        ret = -EIO;\n\n        goto out_unlock;\n\n    }\n\n\n\n    lbasd = &lbas->descriptors[0];\n\n\n\n    if (sector_qemu2lun(sector_num, iscsilun) != lbasd->lba) {\n\n        ret = -EIO;\n\n        goto out_unlock;\n\n    }\n\n\n\n    *pnum = sector_lun2qemu(lbasd->num_blocks, iscsilun);\n\n\n\n    if (lbasd->provisioning == SCSI_PROVISIONING_TYPE_DEALLOCATED ||\n\n        lbasd->provisioning == SCSI_PROVISIONING_TYPE_ANCHORED) {\n\n        ret &= ~BDRV_BLOCK_DATA;\n\n        if (iscsilun->lbprz) {\n\n            ret |= BDRV_BLOCK_ZERO;\n\n        }\n\n    }\n\n\n\n    if (ret & BDRV_BLOCK_ZERO) {\n\n        iscsi_allocmap_set_unallocated(iscsilun, sector_num, *pnum);\n\n    } else {\n\n        iscsi_allocmap_set_allocated(iscsilun, sector_num, *pnum);\n\n    }\n\n\n\n    if (*pnum > nb_sectors) {\n\n        *pnum = nb_sectors;\n\n    }\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    g_free(iTask.err_str);\n\nout:\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n    }\n\n    if (ret > 0 && ret & BDRV_BLOCK_OFFSET_VALID) {\n\n        *file = bs;\n\n    }\n\n    return ret;\n\n}\n", "idx": 923}
{"project": "FFmpeg", "commit_id": "74d7db586a2e9aeb107e357739c7e4dde0b6991c", "target": 0, "func": "static int dvvideo_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVVideoContext *s = avctx->priv_data;\n\n    const uint8_t *vsc_pack;\n\n    int apt, is16_9, ret;\n\n    const AVDVProfile *sys;\n\n\n\n    sys = av_dv_frame_profile(s->sys, buf, buf_size);\n\n    if (!sys || buf_size < sys->frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"could not find dv frame profile\\n\");\n\n        return -1; /* NOTE: we only accept several full frames */\n\n    }\n\n\n\n    if (sys != s->sys) {\n\n        ret = ff_dv_init_dynamic_tables(s, sys);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing the work tables.\\n\");\n\n            return ret;\n\n        }\n\n        s->sys = sys;\n\n    }\n\n\n\n    s->frame            = data;\n\n    s->frame->key_frame = 1;\n\n    s->frame->pict_type = AV_PICTURE_TYPE_I;\n\n    avctx->pix_fmt      = s->sys->pix_fmt;\n\n    avctx->framerate    = av_inv_q(s->sys->time_base);\n\n\n\n    ret = ff_set_dimensions(avctx, s->sys->width, s->sys->height);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Determine the codec's sample_aspect ratio from the packet */\n\n    vsc_pack = buf + 80 * 5 + 48 + 5;\n\n    if (*vsc_pack == dv_video_control) {\n\n        apt    = buf[4] & 0x07;\n\n        is16_9 = (vsc_pack && ((vsc_pack[2] & 0x07) == 0x02 ||\n\n                               (!apt && (vsc_pack[2] & 0x07) == 0x07)));\n\n        ff_set_sar(avctx, s->sys->sar[is16_9]);\n\n    }\n\n\n\n    if (ff_get_buffer(avctx, s->frame, 0) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n    s->frame->interlaced_frame = 1;\n\n    s->frame->top_field_first  = 0;\n\n\n\n    s->buf = buf;\n\n    avctx->execute(avctx, dv_decode_video_segment, s->work_chunks, NULL,\n\n                   dv_work_pool_size(s->sys), sizeof(DVwork_chunk));\n\n\n\n    emms_c();\n\n\n\n    /* return image */\n\n    *got_frame = 1;\n\n\n\n    return s->sys->frame_size;\n\n}\n", "idx": 925}
{"project": "qemu", "commit_id": "9ac228e02cf16202547e7025ef300369e0db7781", "target": 1, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t start, last, cluster_offset;\n\n    int k;\n\n    int errors = 0;\n\n\n\n    if (size <= 0)\n\n        return 0;\n\n\n\n    start = offset & ~(s->cluster_size - 1);\n\n    last = (offset + size - 1) & ~(s->cluster_size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k < 0 || k >= refcount_table_size) {\n\n            fprintf(stderr, \"ERROR: invalid cluster offset=0x%\" PRIx64 \"\\n\",\n\n                cluster_offset);\n\n            errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                errors++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return errors;\n\n}\n", "idx": 926}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static void arm_tr_tb_stop(DisasContextBase *dcbase, CPUState *cpu)\n\n{\n\n    DisasContext *dc = container_of(dcbase, DisasContext, base);\n\n\n\n    if (dc->base.tb->cflags & CF_LAST_IO && dc->condjmp) {\n\n        /* FIXME: This can theoretically happen with self-modifying code. */\n\n        cpu_abort(cpu, \"IO on conditional branch instruction\");\n\n    }\n\n\n\n    /* At this stage dc->condjmp will only be set when the skipped\n\n       instruction was a conditional branch or trap, and the PC has\n\n       already been written.  */\n\n    gen_set_condexec(dc);\n\n    if (dc->base.is_jmp == DISAS_BX_EXCRET) {\n\n        /* Exception return branches need some special case code at the\n\n         * end of the TB, which is complex enough that it has to\n\n         * handle the single-step vs not and the condition-failed\n\n         * insn codepath itself.\n\n         */\n\n        gen_bx_excret_final_code(dc);\n\n    } else if (unlikely(is_singlestepping(dc))) {\n\n        /* Unconditional and \"condition passed\" instruction codepath. */\n\n        switch (dc->base.is_jmp) {\n\n        case DISAS_SWI:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),\n\n                          default_exception_el(dc));\n\n            break;\n\n        case DISAS_HVC:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);\n\n            break;\n\n        case DISAS_SMC:\n\n            gen_ss_advance(dc);\n\n            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);\n\n            break;\n\n        case DISAS_NEXT:\n\n        case DISAS_TOO_MANY:\n\n        case DISAS_UPDATE:\n\n            gen_set_pc_im(dc, dc->pc);\n\n            /* fall through */\n\n        default:\n\n            /* FIXME: Single stepping a WFI insn will not halt the CPU. */\n\n            gen_singlestep_exception(dc);\n\n            break;\n\n        case DISAS_NORETURN:\n\n            break;\n\n        }\n\n    } else {\n\n        /* While branches must always occur at the end of an IT block,\n\n           there are a few other things that can cause us to terminate\n\n           the TB in the middle of an IT block:\n\n            - Exception generating instructions (bkpt, swi, undefined).\n\n            - Page boundaries.\n\n            - Hardware watchpoints.\n\n           Hardware breakpoints have already been handled and skip this code.\n\n         */\n\n        switch(dc->base.is_jmp) {\n\n        case DISAS_NEXT:\n\n        case DISAS_TOO_MANY:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        case DISAS_JUMP:\n\n            gen_goto_ptr();\n\n            break;\n\n        case DISAS_UPDATE:\n\n            gen_set_pc_im(dc, dc->pc);\n\n            /* fall through */\n\n        default:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_NORETURN:\n\n            /* nothing more to generate */\n\n            break;\n\n        case DISAS_WFI:\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_SWI:\n\n            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),\n\n                          default_exception_el(dc));\n\n            break;\n\n        case DISAS_HVC:\n\n            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);\n\n            break;\n\n        case DISAS_SMC:\n\n            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (dc->condjmp) {\n\n        /* \"Condition failed\" instruction codepath for the branch/trap insn */\n\n        gen_set_label(dc->condlabel);\n\n        gen_set_condexec(dc);\n\n        if (unlikely(is_singlestepping(dc))) {\n\n            gen_set_pc_im(dc, dc->pc);\n\n            gen_singlestep_exception(dc);\n\n        } else {\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n        }\n\n    }\n\n\n\n    /* Functions above can change dc->pc, so re-align db->pc_next */\n\n    dc->base.pc_next = dc->pc;\n\n}\n", "idx": 927}
{"project": "qemu", "commit_id": "7797a73947d5c0e63dd5552b348cf66c384b4555", "target": 1, "func": "void pcmcia_info(Monitor *mon, const QDict *qdict)\n\n{\n\n    struct pcmcia_socket_entry_s *iter;\n\n\n\n    if (!pcmcia_sockets)\n\n        monitor_printf(mon, \"No PCMCIA sockets\\n\");\n\n\n\n    for (iter = pcmcia_sockets; iter; iter = iter->next)\n\n        monitor_printf(mon, \"%s: %s\\n\", iter->socket->slot_string,\n\n                       iter->socket->attached ? iter->socket->card_string :\n\n                       \"Empty\");\n\n}\n", "idx": 928}
{"project": "qemu", "commit_id": "98cb5dccb192b0082626080890dac413473573c6", "target": 1, "func": "static void ahci_reg_init(AHCIState *s)\n\n{\n\n    int i;\n\n\n\n    s->control_regs.cap = (s->ports - 1) |\n\n                          (AHCI_NUM_COMMAND_SLOTS << 8) |\n\n                          (AHCI_SUPPORTED_SPEED_GEN1 << AHCI_SUPPORTED_SPEED) |\n\n                          HOST_CAP_NCQ | HOST_CAP_AHCI;\n\n\n\n    s->control_regs.impl = (1 << s->ports) - 1;\n\n\n\n    s->control_regs.version = AHCI_VERSION_1_0;\n\n\n\n    for (i = 0; i < s->ports; i++) {\n\n        s->dev[i].port_state = STATE_RUN;\n\n    }\n\n}\n", "idx": 929}
{"project": "qemu", "commit_id": "9730280d54634caa5d63f0d8fcd85da8311d2ebf", "target": 1, "func": "static void virtio_crypto_get_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOCrypto *c = VIRTIO_CRYPTO(vdev);\n\n    struct virtio_crypto_config crypto_cfg;\n\n\n\n    /*\n\n     * Virtio-crypto device conforms to VIRTIO 1.0 which is always LE,\n\n     * so we can use LE accessors directly.\n\n     */\n\n    stl_le_p(&crypto_cfg.status, c->status);\n\n    stl_le_p(&crypto_cfg.max_dataqueues, c->max_queues);\n\n    stl_le_p(&crypto_cfg.crypto_services, c->conf.crypto_services);\n\n    stl_le_p(&crypto_cfg.cipher_algo_l, c->conf.cipher_algo_l);\n\n    stl_le_p(&crypto_cfg.cipher_algo_h, c->conf.cipher_algo_h);\n\n    stl_le_p(&crypto_cfg.hash_algo, c->conf.hash_algo);\n\n    stl_le_p(&crypto_cfg.mac_algo_l, c->conf.mac_algo_l);\n\n    stl_le_p(&crypto_cfg.mac_algo_h, c->conf.mac_algo_h);\n\n    stl_le_p(&crypto_cfg.aead_algo, c->conf.aead_algo);\n\n    stl_le_p(&crypto_cfg.max_cipher_key_len, c->conf.max_cipher_key_len);\n\n    stl_le_p(&crypto_cfg.max_auth_key_len, c->conf.max_auth_key_len);\n\n    stq_le_p(&crypto_cfg.max_size, c->conf.max_size);\n\n\n\n    memcpy(config, &crypto_cfg, c->config_size);\n\n}\n", "idx": 930}
{"project": "FFmpeg", "commit_id": "8425d693eefbedbb41f91735614d41067695aa37", "target": 1, "func": "static int flac_probe(AVProbeData *p)\n\n{\n\n    uint8_t *bufptr = p->buf;\n\n    uint8_t *end    = p->buf + p->buf_size;\n\n\n\n    if(bufptr > end-4 || memcmp(bufptr, \"fLaC\", 4)) return 0;\n\n    else                                            return AVPROBE_SCORE_MAX/2;\n\n}\n", "idx": 931}
{"project": "FFmpeg", "commit_id": "55fa898969d10e2d47bba0613175bf57a86c5a41", "target": 1, "func": "static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    Jpeg2000QuantStyle tmp;\n    int compno, ret;\n    if ((ret = get_qcx(s, n, &tmp)) < 0)\n        return ret;\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_QCC))\n            memcpy(q + compno, &tmp, sizeof(tmp));\n    return 0;\n}", "idx": 932}
{"project": "qemu", "commit_id": "df46189412567906312684eb72ba87c6a86a4cdb", "target": 1, "func": "void slirp_init(int restricted, struct in_addr vnetwork,\n\n                struct in_addr vnetmask, struct in_addr vhost,\n\n                const char *vhostname, const char *tftp_path,\n\n                const char *bootfile, struct in_addr vdhcp_start,\n\n                struct in_addr vnameserver)\n\n{\n\n#ifdef _WIN32\n\n    WSADATA Data;\n\n\n\n    WSAStartup(MAKEWORD(2,0), &Data);\n\n    atexit(slirp_cleanup);\n\n#endif\n\n\n\n    link_up = 1;\n\n    slirp_restrict = restricted;\n\n\n\n    if_init();\n\n    ip_init();\n\n\n\n    /* Initialise mbufs *after* setting the MTU */\n\n    m_init();\n\n\n\n    /* set default addresses */\n\n    inet_aton(\"127.0.0.1\", &loopback_addr);\n\n\n\n    if (get_dns_addr(&dns_addr) < 0) {\n\n        dns_addr = loopback_addr;\n\n        fprintf (stderr, \"Warning: No DNS servers found\\n\");\n\n    }\n\n\n\n    vnetwork_addr = vnetwork;\n\n    vnetwork_mask = vnetmask;\n\n    vhost_addr = vhost;\n\n    if (vhostname) {\n\n        pstrcpy(slirp_hostname, sizeof(slirp_hostname), vhostname);\n\n    }\n\n    qemu_free(tftp_prefix);\n\n    tftp_prefix = NULL;\n\n    if (tftp_path) {\n\n        tftp_prefix = qemu_strdup(tftp_path);\n\n    }\n\n    qemu_free(bootp_filename);\n\n    bootp_filename = NULL;\n\n    if (bootfile) {\n\n        bootp_filename = qemu_strdup(bootfile);\n\n    }\n\n    vdhcp_startaddr = vdhcp_start;\n\n    vnameserver_addr = vnameserver;\n\n\n\n    getouraddr();\n\n    register_savevm(\"slirp\", 0, 1, slirp_state_save, slirp_state_load, NULL);\n\n}\n", "idx": 933}
{"project": "qemu", "commit_id": "e9016ee2bda1b7757072b856b2196f691aee3388", "target": 1, "func": "void virtio_net_set_config_size(VirtIONet *n, uint32_t host_features)\n\n{\n\n    int i, config_size = 0;\n\n\n    for (i = 0; feature_sizes[i].flags != 0; i++) {\n\n        if (host_features & feature_sizes[i].flags) {\n\n            config_size = MAX(feature_sizes[i].end, config_size);\n\n        }\n\n    }\n\n    n->config_size = config_size;\n\n}", "idx": 934}
{"project": "qemu", "commit_id": "c364c974d9ab90e25e7887f516da65d2811ba5e3", "target": 1, "func": "qemu_irq *openpic_init (PCIBus *bus, int *pmem_index, int nb_cpus,\n\n                        qemu_irq **irqs, qemu_irq irq_out)\n\n{\n\n    openpic_t *opp;\n\n    uint8_t *pci_conf;\n\n    int i, m;\n\n\n\n    /* XXX: for now, only one CPU is supported */\n\n    if (nb_cpus != 1)\n\n        return NULL;\n\n    if (bus) {\n\n        opp = (openpic_t *)pci_register_device(bus, \"OpenPIC\", sizeof(openpic_t),\n\n                                               -1, NULL, NULL);\n\n        if (opp == NULL)\n\n            return NULL;\n\n        pci_conf = opp->pci_dev.config;\n\n        pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_IBM);\n\n        pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_IBM_OPENPIC2);\n\n        pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER); // FIXME?\n\n        pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type\n\n        pci_conf[0x3d] = 0x00; // no interrupt pin\n\n\n\n        /* Register I/O spaces */\n\n        pci_register_bar((PCIDevice *)opp, 0, 0x40000,\n\n                               PCI_BASE_ADDRESS_SPACE_MEMORY, &openpic_map);\n\n    } else {\n\n        opp = qemu_mallocz(sizeof(openpic_t));\n\n    }\n\n    opp->mem_index = cpu_register_io_memory(openpic_read,\n\n                                            openpic_write, opp);\n\n\n\n    //    isu_base &= 0xFFFC0000;\n\n    opp->nb_cpus = nb_cpus;\n\n    opp->max_irq = OPENPIC_MAX_IRQ;\n\n    opp->irq_ipi0 = OPENPIC_IRQ_IPI0;\n\n    opp->irq_tim0 = OPENPIC_IRQ_TIM0;\n\n    /* Set IRQ types */\n\n    for (i = 0; i < OPENPIC_EXT_IRQ; i++) {\n\n        opp->src[i].type = IRQ_EXTERNAL;\n\n    }\n\n    for (; i < OPENPIC_IRQ_TIM0; i++) {\n\n        opp->src[i].type = IRQ_SPECIAL;\n\n    }\n\n#if MAX_IPI > 0\n\n    m = OPENPIC_IRQ_IPI0;\n\n#else\n\n    m = OPENPIC_IRQ_DBL0;\n\n#endif\n\n    for (; i < m; i++) {\n\n        opp->src[i].type = IRQ_TIMER;\n\n    }\n\n    for (; i < OPENPIC_MAX_IRQ; i++) {\n\n        opp->src[i].type = IRQ_INTERNAL;\n\n    }\n\n    for (i = 0; i < nb_cpus; i++)\n\n        opp->dst[i].irqs = irqs[i];\n\n    opp->irq_out = irq_out;\n\n    opp->need_swap = 1;\n\n\n\n    register_savevm(\"openpic\", 0, 2, openpic_save, openpic_load, opp);\n\n    qemu_register_reset(openpic_reset, opp);\n\n\n\n    opp->irq_raise = openpic_irq_raise;\n\n    opp->reset = openpic_reset;\n\n\n\n    if (pmem_index)\n\n        *pmem_index = opp->mem_index;\n\n\n\n    return qemu_allocate_irqs(openpic_set_irq, opp, opp->max_irq);\n\n}\n", "idx": 935}
{"project": "FFmpeg", "commit_id": "b54ac8403bfea4e7fab0799ccfe728ba76959a38", "target": 0, "func": "static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    uint32_t sequence_number;\n\n\n\n    if (length != 26)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!(s->state & PNG_IHDR)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    s->last_w = s->cur_w;\n\n    s->last_h = s->cur_h;\n\n    s->last_x_offset = s->x_offset;\n\n    s->last_y_offset = s->y_offset;\n\n    s->last_dispose_op = s->dispose_op;\n\n\n\n    sequence_number = bytestream2_get_be32(&s->gb);\n\n    s->cur_w        = bytestream2_get_be32(&s->gb);\n\n    s->cur_h        = bytestream2_get_be32(&s->gb);\n\n    s->x_offset     = bytestream2_get_be32(&s->gb);\n\n    s->y_offset     = bytestream2_get_be32(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */\n\n    s->dispose_op   = bytestream2_get_byte(&s->gb);\n\n    s->blend_op     = bytestream2_get_byte(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n\n\n    if (sequence_number == 0 &&\n\n        (s->cur_w != s->width ||\n\n         s->cur_h != s->height ||\n\n         s->x_offset != 0 ||\n\n         s->y_offset != 0) ||\n\n        s->cur_w <= 0 || s->cur_h <= 0 ||\n\n        s->x_offset < 0 || s->y_offset < 0 ||\n\n        s->cur_w > s->width - s->x_offset|| s->cur_h > s->height - s->y_offset)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n    if (sequence_number == 0 && s->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n\n        // No previous frame to revert to for the first frame\n\n        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND\n\n        s->dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n\n    }\n\n\n\n    if (s->dispose_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n\n        )) {\n\n        // APNG_DISPOSE_OP_OVER is the same as APNG_DISPOSE_OP_SOURCE when there is no alpha channel\n\n        s->dispose_op = APNG_BLEND_OP_SOURCE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 936}
{"project": "FFmpeg", "commit_id": "5bbffe3412c1c34873d83d3fb80b379bb6e53d3f", "target": 1, "func": "int ff_h264_build_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int list, index, pic_structure;\n\n\n\n    print_short_term(h);\n\n    print_long_term(h);\n\n\n\n    h264_initialise_ref_list(h, sl);\n\n\n\n    for (list = 0; list < sl->list_count; list++) {\n\n        int pred = sl->curr_pic_num;\n\n\n\n        for (index = 0; index < sl->nb_ref_modifications[list]; index++) {\n\n            unsigned int modification_of_pic_nums_idc = sl->ref_modifications[list][index].op;\n\n            unsigned int                          val = sl->ref_modifications[list][index].val;\n\n            unsigned int pic_id;\n\n            int i;\n\n            H264Picture *ref = NULL;\n\n\n\n            switch (modification_of_pic_nums_idc) {\n\n            case 0:\n\n            case 1: {\n\n                const unsigned int abs_diff_pic_num = val + 1;\n\n                int frame_num;\n\n\n\n                if (abs_diff_pic_num > sl->max_pic_num) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"abs_diff_pic_num overflow\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (modification_of_pic_nums_idc == 0)\n\n                    pred -= abs_diff_pic_num;\n\n                else\n\n                    pred += abs_diff_pic_num;\n\n                pred &= sl->max_pic_num - 1;\n\n\n\n                frame_num = pic_num_extract(h, pred, &pic_structure);\n\n\n\n                for (i = h->short_ref_count - 1; i >= 0; i--) {\n\n                    ref = h->short_ref[i];\n\n                    assert(ref->reference);\n\n                    assert(!ref->long_ref);\n\n                    if (ref->frame_num == frame_num &&\n\n                        (ref->reference & pic_structure))\n\n                        break;\n\n                }\n\n                if (i >= 0)\n\n                    ref->pic_id = pred;\n\n                break;\n\n            }\n\n            case 2: {\n\n                int long_idx;\n\n                pic_id = val; // long_term_pic_idx\n\n\n\n                long_idx = pic_num_extract(h, pic_id, &pic_structure);\n\n\n\n                if (long_idx > 31U) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"long_term_pic_idx overflow\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                ref = h->long_ref[long_idx];\n\n                assert(!(ref && !ref->reference));\n\n                if (ref && (ref->reference & pic_structure)) {\n\n                    ref->pic_id = pic_id;\n\n                    assert(ref->long_ref);\n\n                    i = 0;\n\n                } else {\n\n                    i = -1;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                av_assert1(0);\n\n            }\n\n\n\n            if (i < 0) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"reference picture missing during reorder\\n\");\n\n                memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME\n\n            } else {\n\n                for (i = index; i + 1 < sl->ref_count[list]; i++) {\n\n                    if (sl->ref_list[list][i].parent &&\n\n                        ref->long_ref == sl->ref_list[list][i].parent->long_ref &&\n\n                        ref->pic_id   == sl->ref_list[list][i].pic_id)\n\n                        break;\n\n                }\n\n                for (; i > index; i--) {\n\n                    sl->ref_list[list][i] = sl->ref_list[list][i - 1];\n\n                }\n\n                ref_from_h264pic(&sl->ref_list[list][index], ref);\n\n                if (FIELD_PICTURE(h)) {\n\n                    pic_as_field(&sl->ref_list[list][index], pic_structure);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (list = 0; list < sl->list_count; list++) {\n\n        for (index = 0; index < sl->ref_count[list]; index++) {\n\n            if (   !sl->ref_list[list][index].parent\n\n                || (!FIELD_PICTURE(h) && (sl->ref_list[list][index].reference&3) != 3)) {\n\n                int i;\n\n                av_log(h->avctx, AV_LOG_ERROR, \"Missing reference picture, default is %d\\n\", h->default_ref[list].poc);\n\n                for (i = 0; i < FF_ARRAY_ELEMS(h->last_pocs); i++)\n\n                    h->last_pocs[i] = INT_MIN;\n\n                if (h->default_ref[list].parent\n\n                    && !(!FIELD_PICTURE(h) && (h->default_ref[list].reference&3) != 3))\n\n                    sl->ref_list[list][index] = h->default_ref[list];\n\n                else\n\n                    return -1;\n\n            }\n\n            av_assert0(av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0);\n\n        }\n\n    }\n\n\n\n    if (FRAME_MBAFF(h))\n\n        h264_fill_mbaff_ref_list(sl);\n\n\n\n    return 0;\n\n}\n", "idx": 938}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "int check_hw_breakpoints(CPUX86State *env, int force_dr6_update)\n\n{\n\n    target_ulong dr6;\n\n    int reg, type;\n\n    int hit_enabled = 0;\n\n\n\n    dr6 = env->dr[6] & ~0xf;\n\n    for (reg = 0; reg < DR7_MAX_BP; reg++) {\n\n        type = hw_breakpoint_type(env->dr[7], reg);\n\n        if ((type == 0 && env->dr[reg] == env->eip) ||\n\n            ((type & 1) && env->cpu_watchpoint[reg] &&\n\n             (env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT))) {\n\n            dr6 |= 1 << reg;\n\n            if (hw_breakpoint_enabled(env->dr[7], reg)) {\n\n                hit_enabled = 1;\n\n            }\n\n        }\n\n    }\n\n    if (hit_enabled || force_dr6_update)\n\n        env->dr[6] = dr6;\n\n    return hit_enabled;\n\n}\n", "idx": 939}
{"project": "FFmpeg", "commit_id": "a39c5c4c6baafcef0c6ec7c6f59bc3fee81b2599", "target": 1, "func": "void ff_dv_offset_reset(DVDemuxContext *c, int64_t frame_offset)\n\n{\n\n    c->frames= frame_offset;\n\n    if (c->ach)\n\n        c->abytes= av_rescale_q(c->frames, c->sys->time_base,\n\n                                (AVRational){8, c->ast[0]->codec->bit_rate});\n\n    c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n\n    c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n\n}\n", "idx": 940}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int process_ipmovie_chunk(IPMVEContext *s, ByteIOContext *pb,\n\n    AVPacket *pkt)\n\n{\n\n    unsigned char chunk_preamble[CHUNK_PREAMBLE_SIZE];\n\n    int chunk_type;\n\n    int chunk_size;\n\n    unsigned char opcode_preamble[OPCODE_PREAMBLE_SIZE];\n\n    unsigned char opcode_type;\n\n    unsigned char opcode_version;\n\n    int opcode_size;\n\n    unsigned char scratch[1024];\n\n    int i, j;\n\n    int first_color, last_color;\n\n    int audio_flags;\n\n    unsigned char r, g, b;\n\n\n\n    /* see if there are any pending packets */\n\n    chunk_type = load_ipmovie_packet(s, pb, pkt);\n\n    if ((chunk_type == CHUNK_VIDEO) && (chunk_type != CHUNK_DONE))\n\n        return chunk_type;\n\n\n\n    /* read the next chunk, wherever the file happens to be pointing */\n\n    if (url_feof(pb))\n\n        return CHUNK_EOF;\n\n    if (get_buffer(pb, chunk_preamble, CHUNK_PREAMBLE_SIZE) !=\n\n        CHUNK_PREAMBLE_SIZE)\n\n        return CHUNK_BAD;\n\n    chunk_size = AV_RL16(&chunk_preamble[0]);\n\n    chunk_type = AV_RL16(&chunk_preamble[2]);\n\n\n\n    debug_ipmovie(\"chunk type 0x%04X, 0x%04X bytes: \", chunk_type, chunk_size);\n\n\n\n    switch (chunk_type) {\n\n\n\n    case CHUNK_INIT_AUDIO:\n\n        debug_ipmovie(\"initialize audio\\n\");\n\n        break;\n\n\n\n    case CHUNK_AUDIO_ONLY:\n\n        debug_ipmovie(\"audio only\\n\");\n\n        break;\n\n\n\n    case CHUNK_INIT_VIDEO:\n\n        debug_ipmovie(\"initialize video\\n\");\n\n        break;\n\n\n\n    case CHUNK_VIDEO:\n\n        debug_ipmovie(\"video (and audio)\\n\");\n\n        break;\n\n\n\n    case CHUNK_SHUTDOWN:\n\n        debug_ipmovie(\"shutdown\\n\");\n\n        break;\n\n\n\n    case CHUNK_END:\n\n        debug_ipmovie(\"end\\n\");\n\n        break;\n\n\n\n    default:\n\n        debug_ipmovie(\"invalid chunk\\n\");\n\n        chunk_type = CHUNK_BAD;\n\n        break;\n\n\n\n    }\n\n\n\n    while ((chunk_size > 0) && (chunk_type != CHUNK_BAD)) {\n\n\n\n        /* read the next chunk, wherever the file happens to be pointing */\n\n       if (url_feof(pb)) {\n\n            chunk_type = CHUNK_EOF;\n\n            break;\n\n        }\n\n        if (get_buffer(pb, opcode_preamble, CHUNK_PREAMBLE_SIZE) !=\n\n            CHUNK_PREAMBLE_SIZE) {\n\n            chunk_type = CHUNK_BAD;\n\n            break;\n\n        }\n\n\n\n        opcode_size = AV_RL16(&opcode_preamble[0]);\n\n        opcode_type = opcode_preamble[2];\n\n        opcode_version = opcode_preamble[3];\n\n\n\n        chunk_size -= OPCODE_PREAMBLE_SIZE;\n\n        chunk_size -= opcode_size;\n\n        if (chunk_size < 0) {\n\n            debug_ipmovie(\"chunk_size countdown just went negative\\n\");\n\n            chunk_type = CHUNK_BAD;\n\n            break;\n\n        }\n\n\n\n        debug_ipmovie(\"  opcode type %02X, version %d, 0x%04X bytes: \",\n\n            opcode_type, opcode_version, opcode_size);\n\n        switch (opcode_type) {\n\n\n\n        case OPCODE_END_OF_STREAM:\n\n            debug_ipmovie(\"end of stream\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_END_OF_CHUNK:\n\n            debug_ipmovie(\"end of chunk\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_CREATE_TIMER:\n\n            debug_ipmovie(\"create timer\\n\");\n\n            if ((opcode_version > 0) || (opcode_size > 6)) {\n\n                debug_ipmovie(\"bad create_timer opcode\\n\");\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            if (get_buffer(pb, scratch, opcode_size) !=\n\n                opcode_size) {\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            s->fps = 1000000.0 / (AV_RL32(&scratch[0]) * AV_RL16(&scratch[4]));\n\n            s->frame_pts_inc = 90000 / s->fps;\n\n            debug_ipmovie(\"  %.2f frames/second (timer div = %d, subdiv = %d)\\n\",\n\n                s->fps, AV_RL32(&scratch[0]), AV_RL16(&scratch[4]));\n\n            break;\n\n\n\n        case OPCODE_INIT_AUDIO_BUFFERS:\n\n            debug_ipmovie(\"initialize audio buffers\\n\");\n\n            if ((opcode_version > 1) || (opcode_size > 10)) {\n\n                debug_ipmovie(\"bad init_audio_buffers opcode\\n\");\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            if (get_buffer(pb, scratch, opcode_size) !=\n\n                opcode_size) {\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            s->audio_sample_rate = AV_RL16(&scratch[4]);\n\n            audio_flags = AV_RL16(&scratch[2]);\n\n            /* bit 0 of the flags: 0 = mono, 1 = stereo */\n\n            s->audio_channels = (audio_flags & 1) + 1;\n\n            /* bit 1 of the flags: 0 = 8 bit, 1 = 16 bit */\n\n            s->audio_bits = (((audio_flags >> 1) & 1) + 1) * 8;\n\n            /* bit 2 indicates compressed audio in version 1 opcode */\n\n            if ((opcode_version == 1) && (audio_flags & 0x4))\n\n                s->audio_type = CODEC_ID_INTERPLAY_DPCM;\n\n            else if (s->audio_bits == 16)\n\n                s->audio_type = CODEC_ID_PCM_S16LE;\n\n            else\n\n                s->audio_type = CODEC_ID_PCM_U8;\n\n            debug_ipmovie(\"audio: %d bits, %d Hz, %s, %s format\\n\",\n\n                s->audio_bits,\n\n                s->audio_sample_rate,\n\n                (s->audio_channels == 2) ? \"stereo\" : \"mono\",\n\n                (s->audio_type == CODEC_ID_INTERPLAY_DPCM) ?\n\n                \"Interplay audio\" : \"PCM\");\n\n            break;\n\n\n\n        case OPCODE_START_STOP_AUDIO:\n\n            debug_ipmovie(\"start/stop audio\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_INIT_VIDEO_BUFFERS:\n\n            debug_ipmovie(\"initialize video buffers\\n\");\n\n            if ((opcode_version > 2) || (opcode_size > 8)) {\n\n                debug_ipmovie(\"bad init_video_buffers opcode\\n\");\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            if (get_buffer(pb, scratch, opcode_size) !=\n\n                opcode_size) {\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            s->video_width = AV_RL16(&scratch[0]) * 8;\n\n            s->video_height = AV_RL16(&scratch[2]) * 8;\n\n            debug_ipmovie(\"video resolution: %d x %d\\n\",\n\n                s->video_width, s->video_height);\n\n            break;\n\n\n\n        case OPCODE_UNKNOWN_06:\n\n        case OPCODE_UNKNOWN_0E:\n\n        case OPCODE_UNKNOWN_10:\n\n        case OPCODE_UNKNOWN_12:\n\n        case OPCODE_UNKNOWN_13:\n\n        case OPCODE_UNKNOWN_14:\n\n        case OPCODE_UNKNOWN_15:\n\n            debug_ipmovie(\"unknown (but documented) opcode %02X\\n\", opcode_type);\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_SEND_BUFFER:\n\n            debug_ipmovie(\"send buffer\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_AUDIO_FRAME:\n\n            debug_ipmovie(\"audio frame\\n\");\n\n\n\n            /* log position and move on for now */\n\n            s->audio_chunk_offset = url_ftell(pb);\n\n            s->audio_chunk_size = opcode_size;\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_SILENCE_FRAME:\n\n            debug_ipmovie(\"silence frame\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_INIT_VIDEO_MODE:\n\n            debug_ipmovie(\"initialize video mode\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_CREATE_GRADIENT:\n\n            debug_ipmovie(\"create gradient\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_SET_PALETTE:\n\n            debug_ipmovie(\"set palette\\n\");\n\n            /* check for the logical maximum palette size\n\n             * (3 * 256 + 4 bytes) */\n\n            if (opcode_size > 0x304) {\n\n                debug_ipmovie(\"demux_ipmovie: set_palette opcode too large\\n\");\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            if (get_buffer(pb, scratch, opcode_size) != opcode_size) {\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n\n\n            /* load the palette into internal data structure */\n\n            first_color = AV_RL16(&scratch[0]);\n\n            last_color = first_color + AV_RL16(&scratch[2]) - 1;\n\n            /* sanity check (since they are 16 bit values) */\n\n            if ((first_color > 0xFF) || (last_color > 0xFF)) {\n\n                debug_ipmovie(\"demux_ipmovie: set_palette indices out of range (%d -> %d)\\n\",\n\n                    first_color, last_color);\n\n                chunk_type = CHUNK_BAD;\n\n                break;\n\n            }\n\n            j = 4;  /* offset of first palette data */\n\n            for (i = first_color; i <= last_color; i++) {\n\n                /* the palette is stored as a 6-bit VGA palette, thus each\n\n                 * component is shifted up to a 8-bit range */\n\n                r = scratch[j++] * 4;\n\n                g = scratch[j++] * 4;\n\n                b = scratch[j++] * 4;\n\n                s->palette_control.palette[i] = (r << 16) | (g << 8) | (b);\n\n            }\n\n            /* indicate a palette change */\n\n            s->palette_control.palette_changed = 1;\n\n            break;\n\n\n\n        case OPCODE_SET_PALETTE_COMPRESSED:\n\n            debug_ipmovie(\"set palette compressed\\n\");\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_SET_DECODING_MAP:\n\n            debug_ipmovie(\"set decoding map\\n\");\n\n\n\n            /* log position and move on for now */\n\n            s->decode_map_chunk_offset = url_ftell(pb);\n\n            s->decode_map_chunk_size = opcode_size;\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        case OPCODE_VIDEO_DATA:\n\n            debug_ipmovie(\"set video data\\n\");\n\n\n\n            /* log position and move on for now */\n\n            s->video_chunk_offset = url_ftell(pb);\n\n            s->video_chunk_size = opcode_size;\n\n            url_fseek(pb, opcode_size, SEEK_CUR);\n\n            break;\n\n\n\n        default:\n\n            debug_ipmovie(\"*** unknown opcode type\\n\");\n\n            chunk_type = CHUNK_BAD;\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    /* make a note of where the stream is sitting */\n\n    s->next_chunk_offset = url_ftell(pb);\n\n\n\n    /* dispatch the first of any pending packets */\n\n    if ((chunk_type == CHUNK_VIDEO) || (chunk_type == CHUNK_AUDIO_ONLY))\n\n        chunk_type = load_ipmovie_packet(s, pb, pkt);\n\n\n\n    return chunk_type;\n\n}\n", "idx": 942}
{"project": "qemu", "commit_id": "2bf3aa85f08186b8162b76e7e8efe5b5a44306a6", "target": 1, "func": "static int save_xbzrle_page(RAMState *rs, uint8_t **current_data,\n\n                            ram_addr_t current_addr, RAMBlock *block,\n\n                            ram_addr_t offset, bool last_stage)\n\n{\n\n    int encoded_len = 0, bytes_xbzrle;\n\n    uint8_t *prev_cached_page;\n\n\n\n    if (!cache_is_cached(XBZRLE.cache, current_addr, rs->bitmap_sync_count)) {\n\n        rs->xbzrle_cache_miss++;\n\n        if (!last_stage) {\n\n            if (cache_insert(XBZRLE.cache, current_addr, *current_data,\n\n                             rs->bitmap_sync_count) == -1) {\n\n                return -1;\n\n            } else {\n\n                /* update *current_data when the page has been\n\n                   inserted into cache */\n\n                *current_data = get_cached_data(XBZRLE.cache, current_addr);\n\n            }\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    prev_cached_page = get_cached_data(XBZRLE.cache, current_addr);\n\n\n\n    /* save current buffer into memory */\n\n    memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n\n\n\n    /* XBZRLE encoding (if there is no overflow) */\n\n    encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n\n                                       TARGET_PAGE_SIZE, XBZRLE.encoded_buf,\n\n                                       TARGET_PAGE_SIZE);\n\n    if (encoded_len == 0) {\n\n        trace_save_xbzrle_page_skipping();\n\n        return 0;\n\n    } else if (encoded_len == -1) {\n\n        trace_save_xbzrle_page_overflow();\n\n        rs->xbzrle_overflows++;\n\n        /* update data in the cache */\n\n        if (!last_stage) {\n\n            memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n\n            *current_data = prev_cached_page;\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    /* we need to update the data in the cache, in order to get the same data */\n\n    if (!last_stage) {\n\n        memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);\n\n    }\n\n\n\n    /* Send XBZRLE based compressed page */\n\n    bytes_xbzrle = save_page_header(rs, block,\n\n                                    offset | RAM_SAVE_FLAG_XBZRLE);\n\n    qemu_put_byte(rs->f, ENCODING_FLAG_XBZRLE);\n\n    qemu_put_be16(rs->f, encoded_len);\n\n    qemu_put_buffer(rs->f, XBZRLE.encoded_buf, encoded_len);\n\n    bytes_xbzrle += encoded_len + 1 + 2;\n\n    rs->xbzrle_pages++;\n\n    rs->xbzrle_bytes += bytes_xbzrle;\n\n    rs->bytes_transferred += bytes_xbzrle;\n\n\n\n    return 1;\n\n}\n", "idx": 943}
{"project": "qemu", "commit_id": "f25391c2a6ef1674384204265429520ea50e82bc", "target": 1, "func": "static void dump_qobject(fprintf_function func_fprintf, void *f,\n\n                         int comp_indent, QObject *obj)\n\n{\n\n    switch (qobject_type(obj)) {\n\n        case QTYPE_QINT: {\n\n            QInt *value = qobject_to_qint(obj);\n\n            func_fprintf(f, \"%\" PRId64, qint_get_int(value));\n\n            break;\n\n        }\n\n        case QTYPE_QSTRING: {\n\n            QString *value = qobject_to_qstring(obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            break;\n\n        }\n\n        case QTYPE_QDICT: {\n\n            QDict *value = qobject_to_qdict(obj);\n\n            dump_qdict(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QLIST: {\n\n            QList *value = qobject_to_qlist(obj);\n\n            dump_qlist(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QFLOAT: {\n\n            QFloat *value = qobject_to_qfloat(obj);\n\n            func_fprintf(f, \"%g\", qfloat_get_double(value));\n\n            break;\n\n        }\n\n        case QTYPE_QBOOL: {\n\n            QBool *value = qobject_to_qbool(obj);\n\n            func_fprintf(f, \"%s\", qbool_get_int(value) ? \"true\" : \"false\");\n\n            break;\n\n        }\n\n        case QTYPE_QERROR: {\n\n            QString *value = qerror_human((QError *)obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n\n            break;\n\n        }\n\n        case QTYPE_NONE:\n\n            break;\n\n        case QTYPE_MAX:\n\n        default:\n\n            abort();\n\n    }\n\n}", "idx": 945}
{"project": "FFmpeg", "commit_id": "364889cf9c1f3c5e816a30d30d714a84765cfc29", "target": 1, "func": "int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)\n\n{\n\n    if (isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1;\n\n\n\n    *inv_table = c->srcColorspaceTable;\n\n    *table     = c->dstColorspaceTable;\n\n    *srcRange  = c->srcRange;\n\n    *dstRange  = c->dstRange;\n\n    *brightness= c->brightness;\n\n    *contrast  = c->contrast;\n\n    *saturation= c->saturation;\n\n\n\n    return 0;\n\n}\n", "idx": 947}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mjpeg_decode_frame(AVCodecContext *avctx, \n\n                              void *data, int *data_size,\n\n                              UINT8 *buf, int buf_size)\n\n{\n\n    MJpegDecodeContext *s = avctx->priv_data;\n\n    UINT8 *buf_end, *buf_ptr;\n\n    int i, start_code;\n\n    AVPicture *picture = data;\n\n\n\n    *data_size = 0;\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n    buf_ptr = buf;\n\n    buf_end = buf + buf_size;\n\n    while (buf_ptr < buf_end) {\n\n        /* find start next marker */\n\n        start_code = find_marker(&buf_ptr, buf_end);\n\n\t{\n\n\t    /* EOF */\n\n            if (start_code < 0) {\n\n\t\tgoto the_end;\n\n            } else {\n\n                dprintf(\"marker=%x avail_size_in_buf=%d\\n\", start_code, buf_end - buf_ptr);\n\n\t\t\n\n\t\tif ((buf_end - buf_ptr) > s->buffer_size)\n\n\t\t{\n\n\t\t    av_free(s->buffer);\n\n\t\t    s->buffer_size = buf_end-buf_ptr;\n\n\t\t    s->buffer = av_malloc(s->buffer_size);\n\n\t\t    dprintf(\"buffer too small, expanding to %d bytes\\n\",\n\n\t\t\ts->buffer_size);\n\n\t\t}\n\n\t\t\n\n\t\t/* unescape buffer of SOS */\n\n\t\tif (start_code == SOS)\n\n\t\t{\n\n\t\t    UINT8 *src = buf_ptr;\n\n\t\t    UINT8 *dst = s->buffer;\n\n\n\n\t\t    while (src<buf_end)\n\n\t\t    {\n\n\t\t\tUINT8 x = *(src++);\n\n\n\n\t\t\t*(dst++) = x;\n\n\t\t\tif (x == 0xff)\n\n\t\t\t{\n\n\t\t\t    while(*src == 0xff) src++;\n\n\n\n\t\t\t    x = *(src++);\n\n\t\t\t    if (x >= 0xd0 && x <= 0xd7)\n\n\t\t\t\t*(dst++) = x;\n\n\t\t\t    else if (x)\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t    }\n\n\t\t    init_get_bits(&s->gb, s->buffer, dst - s->buffer);\n\n\t\t    \n\n\t\t    dprintf(\"escaping removed %d bytes\\n\",\n\n\t\t\t(buf_end - buf_ptr) - (dst - s->buffer));\n\n\t\t}\n\n\t\telse\n\n\t\t    init_get_bits(&s->gb, buf_ptr, buf_end - buf_ptr);\n\n\t\t\n\n\t\ts->start_code = start_code;\n\n\n\n\t\t/* process markers */\n\n\t\tif (start_code >= 0xd0 && start_code <= 0xd7) {\n\n\t\t    dprintf(\"restart marker: %d\\n\", start_code&0x0f);\n\n\t\t} else if (s->first_picture) {\n\n\t\t    /* APP fields */\n\n\t\t    if (start_code >= 0xe0 && start_code <= 0xef)\n\n\t\t\tmjpeg_decode_app(s);\n\n\t\t    /* Comment */\n\n\t\t    else if (start_code == COM)\n\n\t\t\tmjpeg_decode_com(s);\n\n\t\t}\n\n\n\n                switch(start_code) {\n\n                case SOI:\n\n\t\t    s->restart_interval = 0;\n\n                    /* nothing to do on SOI */\n\n                    break;\n\n                case DQT:\n\n                    mjpeg_decode_dqt(s);\n\n                    break;\n\n                case DHT:\n\n                    mjpeg_decode_dht(s);\n\n                    break;\n\n                case SOF0:\n\n                    if (mjpeg_decode_sof0(s) < 0)\n\n\t\t\treturn -1;\n\n                    break;\n\n\t\tcase EOI:\n\neoi_parser:\n\n\t\t    {\n\n                        if (s->interlaced) {\n\n                            s->bottom_field ^= 1;\n\n                            /* if not bottom field, do not output image yet */\n\n                            if (s->bottom_field)\n\n                                goto not_the_end;\n\n                        }\n\n                        for(i=0;i<3;i++) {\n\n                            picture->data[i] = s->current_picture[i];\n\n\t\t\t    picture->linesize[i] = (s->interlaced) ?\n\n\t\t\t\ts->linesize[i] >> 1 : s->linesize[i];\n\n                        }\n\n                        *data_size = sizeof(AVPicture);\n\n                        avctx->height = s->height;\n\n                        if (s->interlaced)\n\n                            avctx->height *= 2;\n\n                        avctx->width = s->width;\n\n                        /* XXX: not complete test ! */\n\n                        switch((s->h_count[0] << 4) | s->v_count[0]) {\n\n                        case 0x11:\n\n                            avctx->pix_fmt = PIX_FMT_YUV444P;\n\n                            break;\n\n                        case 0x21:\n\n                            avctx->pix_fmt = PIX_FMT_YUV422P;\n\n                            break;\n\n                        default:\n\n                        case 0x22:\n\n                            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n                            break;\n\n                        }\n\n                        /* dummy quality */\n\n                        /* XXX: infer it with matrix */\n\n//                    \tavctx->quality = 3; \n\n                        goto the_end;\n\n                    }\n\n\t\t    break;\n\n                case SOS:\n\n                    mjpeg_decode_sos(s);\n\n\t\t    /* buggy avid puts EOI every 10-20th frame */\n\n\t\t    /* if restart period is over process EOI */\n\n\t\t    if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n\n\t\t\tgoto eoi_parser;\n\n                    break;\n\n\t\tcase DRI:\n\n\t\t    mjpeg_decode_dri(s);\n\n\t\t    break;\n\n\t\tcase SOF1:\n\n\t\tcase SOF2:\n\n\t\tcase SOF3:\n\n\t\tcase SOF5:\n\n\t\tcase SOF6:\n\n\t\tcase SOF7:\n\n\t\tcase SOF9:\n\n\t\tcase SOF10:\n\n\t\tcase SOF11:\n\n\t\tcase SOF13:\n\n\t\tcase SOF14:\n\n\t\tcase SOF15:\n\n\t\tcase JPG:\n\n\t\t    printf(\"mjpeg: unsupported coding type (%x)\\n\", start_code);\n\n\t\t    break;\n\n//\t\tdefault:\n\n//\t\t    printf(\"mjpeg: unsupported marker (%x)\\n\", start_code);\n\n//\t\t    break;\n\n                }\n\n\n\nnot_the_end:\n\n\t\t/* eof process start code */\n\n\t\tbuf_ptr += (get_bits_count(&s->gb)+7)/8;\n\n\t\tdprintf(\"marker parser used %d bytes (%d bits)\\n\",\n\n\t\t    (get_bits_count(&s->gb)+7)/8, get_bits_count(&s->gb));\n\n            }\n\n        }\n\n    }\n\nthe_end:\n\n    dprintf(\"mjpeg decode frame unused %d bytes\\n\", buf_end - buf_ptr);\n\n//    return buf_end - buf_ptr;\n\n    return buf_ptr - buf;\n\n}\n", "idx": 948}
{"project": "FFmpeg", "commit_id": "2e67a99fbc6b99315925de40fc6fa7161576be10", "target": 0, "func": "static int draw_text(AVFilterContext *ctx, AVFrame *frame,\n\n                     int width, int height)\n\n{\n\n    DrawTextContext *s = ctx->priv;\n\n    AVFilterLink *inlink = ctx->inputs[0];\n\n\n\n    uint32_t code = 0, prev_code = 0;\n\n    int x = 0, y = 0, i = 0, ret;\n\n    int max_text_line_w = 0, len;\n\n    int box_w, box_h;\n\n    char *text;\n\n    uint8_t *p;\n\n    int y_min = 32000, y_max = -32000;\n\n    int x_min = 32000, x_max = -32000;\n\n    FT_Vector delta;\n\n    Glyph *glyph = NULL, *prev_glyph = NULL;\n\n    Glyph dummy = { 0 };\n\n\n\n    time_t now = time(0);\n\n    struct tm ltime;\n\n    AVBPrint *bp = &s->expanded_text;\n\n\n\n    FFDrawColor fontcolor;\n\n    FFDrawColor shadowcolor;\n\n    FFDrawColor bordercolor;\n\n    FFDrawColor boxcolor;\n\n\n\n    av_bprint_clear(bp);\n\n\n\n    if(s->basetime != AV_NOPTS_VALUE)\n\n        now= frame->pts*av_q2d(ctx->inputs[0]->time_base) + s->basetime/1000000;\n\n\n\n    switch (s->exp_mode) {\n\n    case EXP_NONE:\n\n        av_bprintf(bp, \"%s\", s->text);\n\n        break;\n\n    case EXP_NORMAL:\n\n        if ((ret = expand_text(ctx, s->text, &s->expanded_text)) < 0)\n\n            return ret;\n\n        break;\n\n    case EXP_STRFTIME:\n\n        localtime_r(&now, &ltime);\n\n        av_bprint_strftime(bp, s->text, &ltime);\n\n        break;\n\n    }\n\n\n\n    if (s->tc_opt_string) {\n\n        char tcbuf[AV_TIMECODE_STR_SIZE];\n\n        av_timecode_make_string(&s->tc, tcbuf, inlink->frame_count);\n\n        av_bprint_clear(bp);\n\n        av_bprintf(bp, \"%s%s\", s->text, tcbuf);\n\n    }\n\n\n\n    if (!av_bprint_is_complete(bp))\n\n        return AVERROR(ENOMEM);\n\n    text = s->expanded_text.str;\n\n    if ((len = s->expanded_text.len) > s->nb_positions) {\n\n        if (!(s->positions =\n\n              av_realloc(s->positions, len*sizeof(*s->positions))))\n\n            return AVERROR(ENOMEM);\n\n        s->nb_positions = len;\n\n    }\n\n\n\n    if (s->fontcolor_expr[0]) {\n\n        /* If expression is set, evaluate and replace the static value */\n\n        av_bprint_clear(&s->expanded_fontcolor);\n\n        if ((ret = expand_text(ctx, s->fontcolor_expr, &s->expanded_fontcolor)) < 0)\n\n            return ret;\n\n        if (!av_bprint_is_complete(&s->expanded_fontcolor))\n\n            return AVERROR(ENOMEM);\n\n        av_log(s, AV_LOG_DEBUG, \"Evaluated fontcolor is '%s'\\n\", s->expanded_fontcolor.str);\n\n        ret = av_parse_color(s->fontcolor.rgba, s->expanded_fontcolor.str, -1, s);\n\n        if (ret)\n\n            return ret;\n\n        ff_draw_color(&s->dc, &s->fontcolor, s->fontcolor.rgba);\n\n    }\n\n\n\n    x = 0;\n\n    y = 0;\n\n\n\n    /* load and cache glyphs */\n\n    for (i = 0, p = text; *p; i++) {\n\n        GET_UTF8(code, *p++, continue;);\n\n\n\n        /* get glyph */\n\n        dummy.code = code;\n\n        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);\n\n        if (!glyph) {\n\n            load_glyph(ctx, &glyph, code);\n\n        }\n\n\n\n        y_min = FFMIN(glyph->bbox.yMin, y_min);\n\n        y_max = FFMAX(glyph->bbox.yMax, y_max);\n\n        x_min = FFMIN(glyph->bbox.xMin, x_min);\n\n        x_max = FFMAX(glyph->bbox.xMax, x_max);\n\n    }\n\n    s->max_glyph_h = y_max - y_min;\n\n    s->max_glyph_w = x_max - x_min;\n\n\n\n    /* compute and save position for each glyph */\n\n    glyph = NULL;\n\n    for (i = 0, p = text; *p; i++) {\n\n        GET_UTF8(code, *p++, continue;);\n\n\n\n        /* skip the \\n in the sequence \\r\\n */\n\n        if (prev_code == '\\r' && code == '\\n')\n\n            continue;\n\n\n\n        prev_code = code;\n\n        if (is_newline(code)) {\n\n\n\n            max_text_line_w = FFMAX(max_text_line_w, x);\n\n            y += s->max_glyph_h;\n\n            x = 0;\n\n            continue;\n\n        }\n\n\n\n        /* get glyph */\n\n        prev_glyph = glyph;\n\n        dummy.code = code;\n\n        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);\n\n\n\n        /* kerning */\n\n        if (s->use_kerning && prev_glyph && glyph->code) {\n\n            FT_Get_Kerning(s->face, prev_glyph->code, glyph->code,\n\n                           ft_kerning_default, &delta);\n\n            x += delta.x >> 6;\n\n        }\n\n\n\n        /* save position */\n\n        s->positions[i].x = x + glyph->bitmap_left;\n\n        s->positions[i].y = y - glyph->bitmap_top + y_max;\n\n        if (code == '\\t') x  = (x / s->tabsize + 1)*s->tabsize;\n\n        else              x += glyph->advance;\n\n    }\n\n\n\n    max_text_line_w = FFMAX(x, max_text_line_w);\n\n\n\n    s->var_values[VAR_TW] = s->var_values[VAR_TEXT_W] = max_text_line_w;\n\n    s->var_values[VAR_TH] = s->var_values[VAR_TEXT_H] = y + s->max_glyph_h;\n\n\n\n    s->var_values[VAR_MAX_GLYPH_W] = s->max_glyph_w;\n\n    s->var_values[VAR_MAX_GLYPH_H] = s->max_glyph_h;\n\n    s->var_values[VAR_MAX_GLYPH_A] = s->var_values[VAR_ASCENT ] = y_max;\n\n    s->var_values[VAR_MAX_GLYPH_D] = s->var_values[VAR_DESCENT] = y_min;\n\n\n\n    s->var_values[VAR_LINE_H] = s->var_values[VAR_LH] = s->max_glyph_h;\n\n\n\n    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);\n\n    s->y = s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, &s->prng);\n\n    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);\n\n\n\n    update_alpha(s);\n\n    update_color_with_alpha(s, &fontcolor  , s->fontcolor  );\n\n    update_color_with_alpha(s, &shadowcolor, s->shadowcolor);\n\n    update_color_with_alpha(s, &bordercolor, s->bordercolor);\n\n    update_color_with_alpha(s, &boxcolor   , s->boxcolor   );\n\n\n\n    box_w = FFMIN(width - 1 , max_text_line_w);\n\n    box_h = FFMIN(height - 1, y + s->max_glyph_h);\n\n\n\n    /* draw box */\n\n    if (s->draw_box)\n\n        ff_blend_rectangle(&s->dc, &boxcolor,\n\n                           frame->data, frame->linesize, width, height,\n\n                           s->x - s->boxborderw, s->y - s->boxborderw,\n\n                           box_w + s->boxborderw * 2, box_h + s->boxborderw * 2);\n\n\n\n    if (s->shadowx || s->shadowy) {\n\n        if ((ret = draw_glyphs(s, frame, width, height,\n\n                               &shadowcolor, s->shadowx, s->shadowy, 0)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if (s->borderw) {\n\n        if ((ret = draw_glyphs(s, frame, width, height,\n\n                               &bordercolor, 0, 0, s->borderw)) < 0)\n\n            return ret;\n\n    }\n\n    if ((ret = draw_glyphs(s, frame, width, height,\n\n                           &fontcolor, 0, 0, 0)) < 0)\n\n        return ret;\n\n\n\n    return 0;\n\n}\n", "idx": 949}
{"project": "FFmpeg", "commit_id": "33c827f632f95ffe3399b695a5a0d47b366b6e20", "target": 0, "func": "static int planarCopyWrapper(SwsContext *c, const uint8_t *src[],\n\n                             int srcStride[], int srcSliceY, int srcSliceH,\n\n                             uint8_t *dst[], int dstStride[])\n\n{\n\n    const AVPixFmtDescriptor *desc_src = av_pix_fmt_desc_get(c->srcFormat);\n\n    const AVPixFmtDescriptor *desc_dst = av_pix_fmt_desc_get(c->dstFormat);\n\n    int plane, i, j;\n\n    for (plane = 0; plane < 4; plane++) {\n\n        int length = (plane == 0 || plane == 3) ? c->srcW  : -((-c->srcW  ) >> c->chrDstHSubSample);\n\n        int y =      (plane == 0 || plane == 3) ? srcSliceY: -((-srcSliceY) >> c->chrDstVSubSample);\n\n        int height = (plane == 0 || plane == 3) ? srcSliceH: -((-srcSliceH) >> c->chrDstVSubSample);\n\n        const uint8_t *srcPtr = src[plane];\n\n        uint8_t *dstPtr = dst[plane] + dstStride[plane] * y;\n\n\n\n        if (!dst[plane])\n\n            continue;\n\n        // ignore palette for GRAY8\n\n        if (plane == 1 && !dst[2]) continue;\n\n        if (!src[plane] || (plane == 1 && !src[2])) {\n\n            int val = (plane == 3) ? 255 : 128;\n\n            if (is16BPS(c->dstFormat))\n\n                length *= 2;\n\n            if (is9_OR_10BPS(c->dstFormat)) {\n\n                fill_plane9or10(dst[plane], dstStride[plane],\n\n                                length, height, y, val,\n\n                                desc_dst->comp[plane].depth_minus1 + 1,\n\n                                isBE(c->dstFormat));\n\n            } else\n\n                fillPlane(dst[plane], dstStride[plane], length, height, y,\n\n                          val);\n\n        } else {\n\n            if (is9_OR_10BPS(c->srcFormat)) {\n\n                const int src_depth = desc_src->comp[plane].depth_minus1 + 1;\n\n                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;\n\n                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n\n\n                if (is16BPS(c->dstFormat)) {\n\n                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n#define COPY9_OR_10TO16(rfunc, wfunc) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            int srcpx = rfunc(&srcPtr2[j]); \\\n\n                            wfunc(&dstPtr2[j], (srcpx << (16 - src_depth)) | (srcpx >> (2 * src_depth - 16))); \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr2 += srcStride[plane] / 2; \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO16(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY9_OR_10TO16(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO16(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY9_OR_10TO16(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else if (is9_OR_10BPS(c->dstFormat)) {\n\n                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n#define COPY9_OR_10TO9_OR_10(loop) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            loop; \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr2 += srcStride[plane] / 2; \\\n\n                    }\n\n#define COPY9_OR_10TO9_OR_10_2(rfunc, wfunc) \\\n\n                    if (dst_depth > src_depth) { \\\n\n                        COPY9_OR_10TO9_OR_10(int srcpx = rfunc(&srcPtr2[j]); \\\n\n                            wfunc(&dstPtr2[j], (srcpx << 1) | (srcpx >> 9))); \\\n\n                    } else if (dst_depth < src_depth) { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_1, 1, clip9); \\\n\n                    } else { \\\n\n                        COPY9_OR_10TO9_OR_10(wfunc(&dstPtr2[j], rfunc(&srcPtr2[j]))); \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else {\n\n#define W8(a, b) { *(a) = (b); }\n\n#define COPY9_OR_10TO8(rfunc) \\\n\n                    if (src_depth == 9) { \\\n\n                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_1, 1, av_clip_uint8); \\\n\n                    } else { \\\n\n                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_3, 2, av_clip_uint8); \\\n\n                    }\n\n                    if (isBE(c->srcFormat)) {\n\n                        COPY9_OR_10TO8(AV_RB16);\n\n                    } else {\n\n                        COPY9_OR_10TO8(AV_RL16);\n\n                    }\n\n                }\n\n            } else if (is9_OR_10BPS(c->dstFormat)) {\n\n                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;\n\n                uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n\n\n                if (is16BPS(c->srcFormat)) {\n\n                    const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n#define COPY16TO9_OR_10(rfunc, wfunc) \\\n\n                    if (dst_depth == 9) { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    ff_dither_8x8_128, 7, clip9); \\\n\n                    } else { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_64, 6, clip10); \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY16TO9_OR_10(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY16TO9_OR_10(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY16TO9_OR_10(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY16TO9_OR_10(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else /* 8bit */ {\n\n#define COPY8TO9_OR_10(wfunc) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            const int srcpx = srcPtr[j]; \\\n\n                            wfunc(&dstPtr2[j], (srcpx << (dst_depth - 8)) | (srcpx >> (16 - dst_depth))); \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr  += srcStride[plane]; \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        COPY8TO9_OR_10(AV_WB16);\n\n                    } else {\n\n                        COPY8TO9_OR_10(AV_WL16);\n\n                    }\n\n                }\n\n            } else if (is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) {\n\n                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n#define COPY16TO8(rfunc) \\\n\n                    DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                dither_8x8_256, 8, av_clip_uint8);\n\n                if (isBE(c->srcFormat)) {\n\n                    COPY16TO8(AV_RB16);\n\n                } else {\n\n                    COPY16TO8(AV_RL16);\n\n                }\n\n            } else if (!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) {\n\n                for (i = 0; i < height; i++) {\n\n                    for (j = 0; j < length; j++) {\n\n                        dstPtr[ j << 1     ] = srcPtr[j];\n\n                        dstPtr[(j << 1) + 1] = srcPtr[j];\n\n                    }\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            } else if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat) &&\n\n                      isBE(c->srcFormat) != isBE(c->dstFormat)) {\n\n\n\n                for (i = 0; i < height; i++) {\n\n                    for (j = 0; j < length; j++)\n\n                        ((uint16_t *) dstPtr)[j] = av_bswap16(((const uint16_t *) srcPtr)[j]);\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            } else if (dstStride[plane] == srcStride[plane] &&\n\n                       srcStride[plane] > 0 && srcStride[plane] == length) {\n\n                memcpy(dst[plane] + dstStride[plane] * y, src[plane],\n\n                       height * dstStride[plane]);\n\n            } else {\n\n                if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat))\n\n                    length *= 2;\n\n                else if (!desc_src->comp[0].depth_minus1)\n\n                    length >>= 3; // monowhite/black\n\n                for (i = 0; i < height; i++) {\n\n                    memcpy(dstPtr, srcPtr, length);\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return srcSliceH;\n\n}\n", "idx": 950}
{"project": "qemu", "commit_id": "fa365d7cd11185237471823a5a33d36765454e16", "target": 1, "func": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n\n{\n\n    AcpiPciHpState *s = opaque;\n\n    uint32_t val = 0;\n\n    int bsel = s->hotplug_select;\n\n\n\n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n\n        return 0;\n\n    }\n\n\n\n    switch (addr) {\n\n    case PCI_UP_BASE:\n\n        val = s->acpi_pcihp_pci_status[bsel].up;\n\n        if (!s->legacy_piix) {\n\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n\n        }\n\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n\n        break;\n\n    case PCI_DOWN_BASE:\n\n        val = s->acpi_pcihp_pci_status[bsel].down;\n\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n\n        break;\n\n    case PCI_EJ_BASE:\n\n        /* No feature defined yet */\n\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n\n        break;\n\n    case PCI_RMV_BASE:\n\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n\n        break;\n\n    case PCI_SEL_BASE:\n\n        val = s->hotplug_select;\n\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return val;\n\n}\n", "idx": 951}
{"project": "FFmpeg", "commit_id": "5b0ce5d4e3660fb0fc86779cbd027b47b1758c9f", "target": 1, "func": "static void free_field_queue(PullupField *head, PullupField **last)\n\n{\n\n    PullupField *f = head;\n\n    while (f) {\n\n        av_free(f->diffs);\n\n        av_free(f->combs);\n\n        av_free(f->vars);\n\n        if (f == *last) {\n\n            av_freep(last);\n\n            break;\n\n        }\n\n        f = f->next;\n\n        av_freep(&f->prev);\n\n    };\n\n}\n", "idx": 952}
{"project": "qemu", "commit_id": "83d768b5640946b7da55ce8335509df297e2c7cd", "target": 1, "func": "static void notify_guest_bh(void *opaque)\n\n{\n\n    VirtIOBlockDataPlane *s = opaque;\n\n    unsigned nvqs = s->conf->num_queues;\n\n    unsigned long bitmap[BITS_TO_LONGS(nvqs)];\n\n    unsigned j;\n\n\n\n    memcpy(bitmap, s->batch_notify_vqs, sizeof(bitmap));\n\n    memset(s->batch_notify_vqs, 0, sizeof(bitmap));\n\n\n\n    for (j = 0; j < nvqs; j += BITS_PER_LONG) {\n\n        unsigned long bits = bitmap[j];\n\n\n\n        while (bits != 0) {\n\n            unsigned i = j + ctzl(bits);\n\n            VirtQueue *vq = virtio_get_queue(s->vdev, i);\n\n\n\n            if (virtio_should_notify(s->vdev, vq)) {\n\n                event_notifier_set(virtio_queue_get_guest_notifier(vq));\n\n            }\n\n\n\n            bits &= bits - 1; /* clear right-most bit */\n\n        }\n\n    }\n\n}\n", "idx": 953}
{"project": "FFmpeg", "commit_id": "4b20b21b8dabc74d676404dea94d43569a54a6b1", "target": 1, "func": "static char *doubles2str(double *dp, int count, const char *sep)\n\n{\n\n    int i;\n\n    char *ap, *ap0;\n\n    int component_len = 15 + strlen(sep);\n\n    if (!sep) sep = \", \";\n\n    ap = av_malloc(component_len * count);\n\n    if (!ap)\n\n        return NULL;\n\n    ap0   = ap;\n\n    ap[0] = '\\0';\n\n    for (i = 0; i < count; i++) {\n\n        unsigned l = snprintf(ap, component_len, \"%f%s\", dp[i], sep);\n\n        if(l >= component_len)\n\n            return NULL;\n\n        ap += l;\n\n    }\n\n    ap0[strlen(ap0) - strlen(sep)] = '\\0';\n\n    return ap0;\n\n}\n", "idx": 954}
{"project": "qemu", "commit_id": "39ae2474e337247e5930e8be783b689adc9f6215", "target": 1, "func": "static uint32_t arm_v7m_load_vector(ARMCPU *cpu)\n\n\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxResult result;\n\n    hwaddr vec = env->v7m.vecbase + env->v7m.exception * 4;\n\n    uint32_t addr;\n\n\n\n    addr = address_space_ldl(cs->as, vec,\n\n                             MEMTXATTRS_UNSPECIFIED, &result);\n\n    if (result != MEMTX_OK) {\n\n        /* Architecturally this should cause a HardFault setting HSFR.VECTTBL,\n\n         * which would then be immediately followed by our failing to load\n\n         * the entry vector for that HardFault, which is a Lockup case.\n\n         * Since we don't model Lockup, we just report this guest error\n\n         * via cpu_abort().\n\n         */\n\n        cpu_abort(cs, \"Failed to read from exception vector table \"\n\n                  \"entry %08x\\n\", (unsigned)vec);\n\n    }\n\n    return addr;\n\n}\n", "idx": 955}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static void htab_save_first_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                 int64_t max_ns)\n\n{\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart;\n\n\n\n        /* Consume invalid HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n\n\n        /* Consume valid HPTEs */\n\n        chunkstart = index;\n\n        while ((index < htabslots)\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = index - chunkstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, 0);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n\n\n            if ((qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n    } while ((index < htabslots) && !qemu_file_rate_limit(f));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n        spapr->htab_first_pass = false;\n\n    }\n\n    spapr->htab_save_index = index;\n\n}\n", "idx": 956}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_dsdt(GArray *table_data, BIOSLinker *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           Range *pci_hole, Range *pci_hole64, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    CrsRangeSet crs_range_set;\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    if (pcmc->legacy_cpu_hotplug) {\n\n        build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    } else {\n\n        CPUHotplugFeatures opts = {\n\n            .apci_1_compatible = true, .has_legacy_cphp = true\n\n        };\n\n        build_cpus_aml(dsdt, machine, opts, pm->cpu_hp_io_base,\n\n                       \"\\\\_SB.PCI0\", \"\\\\_GPE._E02\");\n\n    }\n\n    build_memory_hotplug_aml(dsdt, nr_mem, \"\\\\_SB.PCI0\", \"\\\\_GPE._E03\");\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        if (pcms->acpi_nvdimm_state.is_enabled) {\n\n            method = aml_method(\"_E04\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method, aml_notify(aml_name(\"\\\\_SB.NVDR\"),\n\n                                          aml_int(0x80)));\n\n            aml_append(scope, method);\n\n        }\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    crs_range_set_init(&crs_range_set);\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n            if (pci_bus_is_express(bus)) {\n\n                aml_append(dev, build_q35_osc_method());\n\n            }\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent), &crs_range_set);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(crs_range_set.io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < crs_range_set.io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(crs_range_set.io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(crs_range_set.mem_ranges,\n\n                                 range_lob(pci_hole),\n\n                                 range_upb(pci_hole));\n\n    for (i = 0; i < crs_range_set.mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(crs_range_set.mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (!range_is_empty(pci_hole64)) {\n\n        crs_replace_with_free_ranges(crs_range_set.mem_64bit_ranges,\n\n                                     range_lob(pci_hole64),\n\n                                     range_upb(pci_hole64));\n\n        for (i = 0; i < crs_range_set.mem_64bit_ranges->len; i++) {\n\n            entry = g_ptr_array_index(crs_range_set.mem_64bit_ranges, i);\n\n            aml_append(crs,\n\n                       aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED,\n\n                                        AML_MAX_FIXED,\n\n                                        AML_CACHEABLE, AML_READ_WRITE,\n\n                                        0, entry->base, entry->limit,\n\n                                        0, entry->limit - entry->base + 1));\n\n        }\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    crs_range_set_free(&crs_range_set);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        Object *pci_host;\n\n        PCIBus *bus = NULL;\n\n\n\n        pci_host = acpi_get_i386_pci_host();\n\n        if (pci_host) {\n\n            bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n        }\n\n\n\n        if (bus) {\n\n            Aml *scope = aml_scope(\"PCI0\");\n\n            /* Scan all PCI buses. Generate tables to support hotplug. */\n\n            build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n            if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                dev = aml_device(\"ISA.TPM\");\n\n                aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                crs = aml_resource_template();\n\n                aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                           TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                /*\n\n                    FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                    Rewrite to take IRQ from TPM device model and\n\n                    fix default IRQ value there to use some unused IRQ\n\n                 */\n\n                /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                aml_append(scope, dev);\n\n            }\n\n\n\n            aml_append(sb_scope, scope);\n\n        }\n\n    }\n\n    aml_append(dsdt, sb_scope);\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 957}
{"project": "qemu", "commit_id": "cb365646a942ed58aae053064b2048a415337ba2", "target": 1, "func": "int64_t cpu_get_clock(void)\n\n{\n\n    int64_t ti;\n\n    if (!timers_state.cpu_ticks_enabled) {\n\n        return timers_state.cpu_clock_offset;\n\n    } else {\n\n        ti = get_clock();\n\n        return ti + timers_state.cpu_clock_offset;\n\n    }\n\n}\n", "idx": 958}
{"project": "FFmpeg", "commit_id": "6d93307f8df81808f0dcdbc064b848054a6e83b3", "target": 1, "func": "static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int level, dc, diff, j, run;\n\n    int component;\n\n    RLTable *rl;\n\n    uint8_t * scantable = s->intra_scantable.permutated;\n\n    const uint16_t *quant_matrix;\n\n    const int qscale = s->qscale;\n\n\n\n    /* DC coefficient */\n\n    if (n < 4) {\n\n        quant_matrix = s->intra_matrix;\n\n        component = 0;\n\n    } else {\n\n        quant_matrix = s->chroma_intra_matrix;\n\n        component = (n & 1) + 1;\n\n    }\n\n    diff = decode_dc(&s->gb, component);\n\n    if (diff >= 0xffff)\n\n        return -1;\n\n    dc = s->last_dc[component];\n\n    dc += diff;\n\n    s->last_dc[component] = dc;\n\n    block[0] = dc << (3 - s->intra_dc_precision);\n\n    if (s->intra_vlc_format)\n\n        rl = &ff_rl_mpeg2;\n\n    else\n\n        rl = &ff_rl_mpeg1;\n\n\n\n    {\n\n        OPEN_READER(re, &s->gb);\n\n        /* now quantify & encode AC coefficients */\n\n        for (;;) {\n\n            UPDATE_CACHE(re, &s->gb);\n\n            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n            if (level == 127) {\n\n                break;\n\n            } else if (level != 0) {\n\n                scantable += run;\n\n                j = *scantable;\n\n                level = (level * qscale * quant_matrix[j]) >> 4;\n\n                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n                LAST_SKIP_BITS(re, &s->gb, 1);\n\n            } else {\n\n                /* escape */\n\n                run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n                UPDATE_CACHE(re, &s->gb);\n\n                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n                scantable += run;\n\n                j = *scantable;\n\n                if (level < 0) {\n\n                    level = (-level * qscale * quant_matrix[j]) >> 4;\n\n                    level = -level;\n\n                } else {\n\n                    level = (level * qscale * quant_matrix[j]) >> 4;\n\n                }\n\n            }\n\n\n\n            block[j] = level;\n\n        }\n\n        CLOSE_READER(re, &s->gb);\n\n    }\n\n\n\n    s->block_last_index[n] = scantable - s->intra_scantable.permutated;\n\n    return 0;\n\n}\n", "idx": 959}
{"project": "qemu", "commit_id": "3b899ea7d405dc7634ac629aa7b0e7639d506d9f", "target": 1, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6, abi_long arg7,\n\n                    abi_long arg8)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n        /* In old applications this may be used to implement _exit(2).\n\n           However in threaded applictions it is used for thread termination,\n\n           and _exit_group is used for application termination.\n\n           Do thread termination if we have more then one thread.  */\n\n        /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n           be disabling signals.  */\n\n        if (CPU_NEXT(first_cpu)) {\n\n            TaskState *ts;\n\n\n\n            cpu_list_lock();\n\n            /* Remove the CPU from the list.  */\n\n            QTAILQ_REMOVE(&cpus, cpu, node);\n\n            cpu_list_unlock();\n\n            ts = cpu->opaque;\n\n            if (ts->child_tidptr) {\n\n                put_user_u32(0, ts->child_tidptr);\n\n                sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                          NULL, NULL, 0);\n\n            }\n\n            thread_cpu = NULL;\n\n            object_unref(OBJECT(cpu));\n\n            g_free(ts);\n\n            pthread_exit(NULL);\n\n        }\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(do_open(cpu_env, p,\n\n                                target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                                arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2 && ret\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n            int total_size = 0;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n                total_size += strlen(*q) + 1;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n                total_size += strlen(*q) + 1;\n\n            }\n\n            *q = NULL;\n\n\n\n            /* This case will not be caught by the host's execve() if its\n\n               page size is bigger than the target's. */\n\n            if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {\n\n                ret = -TARGET_E2BIG;\n\n                goto execve_end;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#if defined(TARGET_NR_getxpid) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_getxpid:\n\n        ((CPUAlphaState *)cpu_env)->ir[IR_A4] = getppid();\n\n        ret = get_errno(getpid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpid\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapal(target_tbuf->actime);\n\n                tbuf.modtime = tswapal(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(faccessat(arg1, p, arg3, 0));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1,\n\n                      target_to_host_bitmask(arg2, fcntl_flags_tbl), 1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapal(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapal(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapal(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapal(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            struct target_sigaction act, oact, *pact = 0;\n\n            struct target_old_sigaction *old_act;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = 0;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#elif defined(TARGET_MIPS)\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#else\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            struct target_sigaction act, oact, *pact = 0;\n\n            struct target_rt_sigaction *rt_act;\n\n            /* ??? arg4 == sizeof(sigset_t).  */\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, rt_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = rt_act->_sa_handler;\n\n                act.sa_mask = rt_act->sa_mask;\n\n                act.sa_flags = rt_act->sa_flags;\n\n                act.sa_restorer = arg5;\n\n                unlock_user_struct(rt_act, arg2, 0);\n\n                pact = &act;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, rt_act, arg3, 0))\n\n                    goto efault;\n\n                rt_act->_sa_handler = oact._sa_handler;\n\n                rt_act->sa_mask = oact.sa_mask;\n\n                rt_act->sa_flags = oact.sa_flags;\n\n                unlock_user_struct(rt_act, arg3, 1);\n\n            }\n\n#else\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n#endif\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n#if defined(TARGET_ALPHA)\n\n            sigset_t set, oldset;\n\n            abi_ulong mask;\n\n            int how;\n\n\n\n            switch (arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n\n\n            ret = get_errno(sigprocmask(how, &set, &oldset));\n\n            if (!is_error(ret)) {\n\n                host_to_target_old_sigset(&mask, &oldset);\n\n                ret = mask;\n\n                ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0; /* force no error */\n\n            }\n\n#else\n\n            sigset_t set, oldset, *set_ptr;\n\n            int how;\n\n\n\n            if (arg2) {\n\n                switch (arg1) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n#if defined(TARGET_ALPHA)\n\n            abi_ulong mask = arg1;\n\n            target_to_host_old_sigset(&set, &mask);\n\n#else\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n#endif\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret)) {\n\n                if (arg2) {\n\n                    p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t),\n\n                                  0);\n\n                    if (!p) {\n\n                        goto efault;\n\n                    }\n\n                    host_to_target_siginfo(p, &uinfo);\n\n                    unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n                }\n\n                ret = host_to_target_signal(ret);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            int resource = target_to_host_resource(arg1);\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = target_to_host_rlim(target_rlim->rlim_cur);\n\n            rlim.rlim_max = target_to_host_rlim(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            int resource = target_to_host_resource(arg1);\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n\n                target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_select)\n\n    case TARGET_NR_select:\n\n#if defined(TARGET_S390X) || defined(TARGET_ALPHA)\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n#else\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapal(sel->n);\n\n            inp = tswapal(sel->inp);\n\n            outp = tswapal(sel->outp);\n\n            exp = tswapal(sel->exp);\n\n            tvp = tswapal(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pselect6\n\n    case TARGET_NR_pselect6:\n\n        {\n\n            abi_long rfd_addr, wfd_addr, efd_addr, n, ts_addr;\n\n            fd_set rfds, wfds, efds;\n\n            fd_set *rfds_ptr, *wfds_ptr, *efds_ptr;\n\n            struct timespec ts, *ts_ptr;\n\n\n\n            /*\n\n             * The 6th arg is actually two args smashed together,\n\n             * so we cannot use the C library.\n\n             */\n\n            sigset_t set;\n\n            struct {\n\n                sigset_t *set;\n\n                size_t size;\n\n            } sig, *sig_ptr;\n\n\n\n            abi_ulong arg_sigset, arg_sigsize, *arg7;\n\n            target_sigset_t *target_sigset;\n\n\n\n            n = arg1;\n\n            rfd_addr = arg2;\n\n            wfd_addr = arg3;\n\n            efd_addr = arg4;\n\n            ts_addr = arg5;\n\n\n\n            ret = copy_from_user_fdset_ptr(&rfds, &rfds_ptr, rfd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n            ret = copy_from_user_fdset_ptr(&wfds, &wfds_ptr, wfd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n            ret = copy_from_user_fdset_ptr(&efds, &efds_ptr, efd_addr, n);\n\n            if (ret) {\n\n                goto fail;\n\n            }\n\n\n\n            /*\n\n             * This takes a timespec, and not a timeval, so we cannot\n\n             * use the do_select() helper ...\n\n             */\n\n            if (ts_addr) {\n\n                if (target_to_host_timespec(&ts, ts_addr)) {\n\n                    goto efault;\n\n                }\n\n                ts_ptr = &ts;\n\n            } else {\n\n                ts_ptr = NULL;\n\n            }\n\n\n\n            /* Extract the two packed args for the sigset */\n\n            if (arg6) {\n\n                sig_ptr = &sig;\n\n                sig.size = _NSIG / 8;\n\n\n\n                arg7 = lock_user(VERIFY_READ, arg6, sizeof(*arg7) * 2, 1);\n\n                if (!arg7) {\n\n                    goto efault;\n\n                }\n\n                arg_sigset = tswapal(arg7[0]);\n\n                arg_sigsize = tswapal(arg7[1]);\n\n                unlock_user(arg7, arg6, 0);\n\n\n\n                if (arg_sigset) {\n\n                    sig.set = &set;\n\n                    if (arg_sigsize != sizeof(*target_sigset)) {\n\n                        /* Like the kernel, we enforce correct size sigsets */\n\n                        ret = -TARGET_EINVAL;\n\n                        goto fail;\n\n                    }\n\n                    target_sigset = lock_user(VERIFY_READ, arg_sigset,\n\n                                              sizeof(*target_sigset), 1);\n\n                    if (!target_sigset) {\n\n                        goto efault;\n\n                    }\n\n                    target_to_host_sigset(&set, target_sigset);\n\n                    unlock_user(target_sigset, arg_sigset, 0);\n\n                } else {\n\n                    sig.set = NULL;\n\n                }\n\n            } else {\n\n                sig_ptr = NULL;\n\n            }\n\n\n\n            ret = get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,\n\n                                         ts_ptr, sig_ptr));\n\n\n\n            if (!is_error(ret)) {\n\n                if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))\n\n                    goto efault;\n\n                if (wfd_addr && copy_to_user_fdset(wfd_addr, &wfds, n))\n\n                    goto efault;\n\n                if (efd_addr && copy_to_user_fdset(efd_addr, &efds, n))\n\n                    goto efault;\n\n\n\n                if (ts_addr && host_to_target_timespec(ts_addr, &ts))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2) {\n\n                ret = -TARGET_EFAULT;\n\n            } else if (is_proc_myself((const char *)p, \"exe\")) {\n\n                char real[PATH_MAX], *temp;\n\n                temp = realpath(exec_path, real);\n\n                ret = temp == NULL ? get_errno(-1) : strlen(real) ;\n\n                snprintf((char *)p2, arg3, \"%s\", real);\n\n            } else {\n\n                ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2) {\n\n                ret = -TARGET_EFAULT;\n\n            } else if (is_proc_myself((const char *)p, \"exe\")) {\n\n                char real[PATH_MAX], *temp;\n\n                temp = realpath(exec_path, real);\n\n                ret = temp == NULL ? get_errno(-1) : strlen(real) ;\n\n                snprintf((char *)p2, arg4, \"%s\", real);\n\n            } else {\n\n                ret = get_errno(readlinkat(arg1, path(p), p2, arg4));\n\n            }\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        if (arg3 == LINUX_REBOOT_CMD_RESTART2) {\n\n           /* arg4 must be ignored in all other cases */\n\n           p = lock_user_string(arg4);\n\n           if (!p) {\n\n              goto efault;\n\n           }\n\n           ret = get_errno(reboot(arg1, arg2, arg3, p));\n\n           unlock_user(p, arg4, 0);\n\n        } else {\n\n           ret = get_errno(reboot(arg1, arg2, arg3, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || \\\n\n    (defined(TARGET_ARM) && defined(TARGET_ABI32)) || \\\n\n    defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE) \\\n\n    || defined(TARGET_S390X)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapal(v[0]);\n\n            v2 = tswapal(v[1]);\n\n            v3 = tswapal(v[2]);\n\n            v4 = tswapal(v[3]);\n\n            v5 = tswapal(v[4]);\n\n            v6 = tswapal(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        {\n\n            TaskState *ts = cpu->opaque;\n\n            /* Special hack to detect libc making the stack executable.  */\n\n            if ((arg3 & PROT_GROWSDOWN)\n\n                && arg1 >= ts->info->stack_limit\n\n                && arg1 <= ts->info->start_stack) {\n\n                arg3 &= ~PROT_GROWSDOWN;\n\n                arg2 = arg2 + arg1 - ts->info->stack_limit;\n\n                arg1 = ts->info->stack_limit;\n\n            }\n\n        }\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(fchmodat(arg1, p, arg3, 0));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* Note that negative values are valid for getpriority, so we must\n\n           differentiate based on errno settings.  */\n\n        errno = 0;\n\n        ret = getpriority(arg1, arg2);\n\n        if (ret == -1 && errno != 0) {\n\n            ret = -host_to_target_errno(errno);\n\n            break;\n\n        }\n\n#ifdef TARGET_ALPHA\n\n        /* Return value is the unbiased priority.  Signal no error.  */\n\n        ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0;\n\n#else\n\n        /* Return value is a biased priority to avoid negative numbers.  */\n\n        ret = 20 - ret;\n\n#endif\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n\n            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n\n            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept4(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept4\n\n    case TARGET_NR_accept4:\n\n#ifdef CONFIG_ACCEPT4\n\n        ret = do_accept4(arg1, arg2, arg3, arg4);\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmmsg\n\n    case TARGET_NR_sendmmsg:\n\n        ret = do_sendrecvmmsg(arg1, arg2, arg3, arg4, 1);\n\n        break;\n\n    case TARGET_NR_recvmmsg:\n\n        ret = do_sendrecvmmsg(arg1, arg2, arg3, arg4, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n        ret = do_syscall(cpu_env, arg1 & 0xffff, arg2, arg3, arg4, arg5,\n\n                         arg6, arg7, arg8, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr && ret) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = do_semop(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n        /* Linux manages to have three different orderings for its\n\n         * arguments to clone(); the BACKWARDS and BACKWARDS2 defines\n\n         * match the kernel's CONFIG_CLONE_* settings.\n\n         * Microblaze is further special in that it uses a sixth\n\n         * implicit argument to clone for the TLS pointer.\n\n         */\n\n#if defined(TARGET_MICROBLAZE)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg4, arg6, arg5));\n\n#elif defined(TARGET_CLONE_BACKWARDS)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#elif defined(TARGET_CLONE_BACKWARDS2)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg5, arg4));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n#if !defined(__NR_llseek)\n\n            res = lseek(arg1, ((uint64_t)arg2 << 32) | arg3, arg5);\n\n            if (res == -1) {\n\n                ret = get_errno(res);\n\n            } else {\n\n\n            }\n\n#else\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n#endif\n\n            if ((ret == 0) && put_user_s64(res, arg4)) {\n\n                goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#ifdef __NR_getdents\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    tnamelen = reclen - offsetof(struct linux_dirent, d_name);\n\n                    assert(tnamelen >= 0);\n\n                    treclen = tnamelen + offsetof(struct target_dirent, d_name);\n\n                    assert(count1 + treclen <= count);\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapal(de->d_ino);\n\n                    tde->d_off = tswapal(de->d_off);\n\n                    memcpy(tde->d_name, de->d_name, tnamelen);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n#else\n\n        /* Implement getdents in terms of getdents64 */\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n\n\n            dirp = lock_user(VERIFY_WRITE, arg2, count, 0);\n\n            if (!dirp) {\n\n                goto efault;\n\n            }\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                /* Convert the dirent64 structs to target dirent.  We do this\n\n                 * in-place, since we can guarantee that a target_dirent is no\n\n                 * larger than a dirent64; however this means we have to be\n\n                 * careful to read everything before writing in the new format.\n\n                 */\n\n                struct linux_dirent64 *de;\n\n                struct target_dirent *tde;\n\n                int len = ret;\n\n                int tlen = 0;\n\n\n\n                de = dirp;\n\n                tde = (struct target_dirent *)dirp;\n\n                while (len > 0) {\n\n                    int namelen, treclen;\n\n                    int reclen = de->d_reclen;\n\n                    uint64_t ino = de->d_ino;\n\n                    int64_t off = de->d_off;\n\n                    uint8_t type = de->d_type;\n\n\n\n                    namelen = strlen(de->d_name);\n\n                    treclen = offsetof(struct target_dirent, d_name)\n\n                        + namelen + 2;\n\n                    treclen = QEMU_ALIGN_UP(treclen, sizeof(abi_long));\n\n\n\n                    memmove(tde->d_name, de->d_name, namelen + 1);\n\n                    tde->d_ino = tswapal(ino);\n\n                    tde->d_off = tswapal(off);\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    /* The target_dirent type is in what was formerly a padding\n\n                     * byte at the end of the structure:\n\n                     */\n\n                    *(((char *)tde) + treclen - 1) = type;\n\n\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n                    len -= reclen;\n\n                    tlen += treclen;\n\n                }\n\n                ret = tlen;\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#if defined(TARGET_NR__newselect)\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_poll) || defined(TARGET_NR_ppoll)\n\n# ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n# endif\n\n# ifdef TARGET_NR_ppoll\n\n    case TARGET_NR_ppoll:\n\n# endif\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n\n\n# ifdef TARGET_NR_ppoll\n\n            if (num == TARGET_NR_ppoll) {\n\n                struct timespec _timeout_ts, *timeout_ts = &_timeout_ts;\n\n                target_sigset_t *target_set;\n\n                sigset_t _set, *set = &_set;\n\n\n\n                if (arg3) {\n\n                    if (target_to_host_timespec(timeout_ts, arg3)) {\n\n                        unlock_user(target_pfd, arg1, 0);\n\n                        goto efault;\n\n                    }\n\n                } else {\n\n                    timeout_ts = NULL;\n\n                }\n\n\n\n                if (arg4) {\n\n                    target_set = lock_user(VERIFY_READ, arg4, sizeof(target_sigset_t), 1);\n\n                    if (!target_set) {\n\n                        unlock_user(target_pfd, arg1, 0);\n\n                        goto efault;\n\n                    }\n\n                    target_to_host_sigset(set, target_set);\n\n                } else {\n\n                    set = NULL;\n\n                }\n\n\n\n                ret = get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8));\n\n\n\n                if (!is_error(ret) && arg3) {\n\n                    host_to_target_timespec(arg3, timeout_ts);\n\n                }\n\n                if (arg4) {\n\n                    unlock_user(target_set, arg4, 0);\n\n                }\n\n            } else\n\n# endif\n\n                ret = get_errno(poll(pfd, nfds, timeout));\n\n\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n            }\n\n            unlock_user(target_pfd, arg1, sizeof(struct target_pollfd) * nfds);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            struct iovec *vec = lock_iovec(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (vec != NULL) {\n\n                ret = get_errno(readv(arg1, vec, arg3));\n\n                unlock_iovec(vec, arg2, arg3, 1);\n\n            } else {\n\n                ret = -host_to_target_errno(errno);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            struct iovec *vec = lock_iovec(VERIFY_READ, arg2, arg3, 1);\n\n            if (vec != NULL) {\n\n                ret = get_errno(writev(arg1, vec, arg3));\n\n                unlock_iovec(vec, arg2, arg3, 0);\n\n            } else {\n\n                ret = -host_to_target_errno(errno);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_getaffinity:\n\n        {\n\n            unsigned int mask_size;\n\n            unsigned long *mask;\n\n\n\n            /*\n\n             * sched_getaffinity needs multiples of ulong, so need to take\n\n             * care of mismatches between target ulong and host ulong sizes.\n\n             */\n\n            if (arg2 & (sizeof(abi_ulong) - 1)) {\n\n                ret = -TARGET_EINVAL;\n\n                break;\n\n            }\n\n            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n\n\n\n            mask = alloca(mask_size);\n\n            ret = get_errno(sys_sched_getaffinity(arg1, mask_size, mask));\n\n\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user(arg3, mask, ret)) {\n\n                    goto efault;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setaffinity:\n\n        {\n\n            unsigned int mask_size;\n\n            unsigned long *mask;\n\n\n\n            /*\n\n             * sched_setaffinity needs multiples of ulong, so need to take\n\n             * care of mismatches between target ulong and host ulong sizes.\n\n             */\n\n            if (arg2 & (sizeof(abi_ulong) - 1)) {\n\n                ret = -TARGET_EINVAL;\n\n                break;\n\n            }\n\n            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n\n\n\n            mask = alloca(mask_size);\n\n            if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {\n\n                goto efault;\n\n            }\n\n            memcpy(mask, p, arg2);\n\n            unlock_user_struct(p, arg2, 0);\n\n\n\n            ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1) {\n\n        case PR_GET_PDEATHSIG:\n\n        {\n\n            int deathsig;\n\n            ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_ual(deathsig, arg2)) {\n\n                goto efault;\n\n            }\n\n            break;\n\n        }\n\n#ifdef PR_GET_NAME\n\n        case PR_GET_NAME:\n\n        {\n\n            void *name = lock_user(VERIFY_WRITE, arg2, 16, 1);\n\n            if (!name) {\n\n                goto efault;\n\n            }\n\n            ret = get_errno(prctl(arg1, (unsigned long)name,\n\n                                  arg3, arg4, arg5));\n\n            unlock_user(name, arg2, 16);\n\n            break;\n\n        }\n\n        case PR_SET_NAME:\n\n        {\n\n            void *name = lock_user(VERIFY_READ, arg2, 16, 1);\n\n            if (!name) {\n\n                goto efault;\n\n            }\n\n            ret = get_errno(prctl(arg1, (unsigned long)name,\n\n                                  arg3, arg4, arg5));\n\n            unlock_user(name, arg2, 0);\n\n            break;\n\n        }\n\n#endif\n\n        default:\n\n            /* Most prctl options have no pointer arguments */\n\n            ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n            break;\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (regpairs_aligned(cpu_env)) {\n\n            arg4 = arg5;\n\n            arg5 = arg6;\n\n        }\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (regpairs_aligned(cpu_env)) {\n\n            arg4 = arg5;\n\n            arg5 = arg6;\n\n        }\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K) || defined(TARGET_S390X) || defined(TARGET_OPENRISC)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUArchState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n\n\n#ifdef CONFIG_SENDFILE\n\n    case TARGET_NR_sendfile:\n\n    {\n\n        off_t *offp = NULL;\n\n        off_t off;\n\n        if (arg3) {\n\n            ret = get_user_sal(off, arg3);\n\n            if (is_error(ret)) {\n\n                break;\n\n            }\n\n            offp = &off;\n\n        }\n\n        ret = get_errno(sendfile(arg1, arg2, offp, arg4));\n\n        if (!is_error(ret) && arg3) {\n\n            abi_long ret2 = put_user_sal(off, arg3);\n\n            if (is_error(ret2)) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n#ifdef TARGET_NR_sendfile64\n\n    case TARGET_NR_sendfile64:\n\n    {\n\n        off_t *offp = NULL;\n\n        off_t off;\n\n        if (arg3) {\n\n            ret = get_user_s64(off, arg3);\n\n            if (is_error(ret)) {\n\n                break;\n\n            }\n\n            offp = &off;\n\n        }\n\n        ret = get_errno(sendfile(arg1, arg2, offp, arg4));\n\n        if (!is_error(ret) && arg3) {\n\n            abi_long ret2 = put_user_s64(off, arg3);\n\n            if (is_error(ret2)) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#else\n\n    case TARGET_NR_sendfile:\n\n#ifdef TARGET_NR_sendfile64\n\n    case TARGET_NR_sendfile64:\n\n#endif\n\n        goto unimplemented;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tint resource = target_to_host_resource(arg1);\n\n\tret = get_errno(getrlimit(resource, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(fstatat(arg1, path(p), &st, arg4));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_getuid\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgid\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            target_id *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * sizeof(target_id), 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswapid(high2lowgid(grouplist[i]));\n\n                unlock_user(target_grouplist, arg2, gidsetsize * sizeof(target_id));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            target_id *target_grouplist;\n\n            gid_t *grouplist = NULL;\n\n            int i;\n\n            if (gidsetsize) {\n\n                grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n                target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * sizeof(target_id), 1);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for (i = 0; i < gidsetsize; i++) {\n\n                    grouplist[i] = low2highgid(tswapid(target_grouplist[i]));\n\n                }\n\n                unlock_user(target_grouplist, arg2, 0);\n\n            }\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(fchownat(arg1, p, low2highuid(arg3),\n\n                                 low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_id(high2lowuid(ruid), arg1)\n\n                    || put_user_id(high2lowuid(euid), arg2)\n\n                    || put_user_id(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_id(high2lowgid(rgid), arg1)\n\n                    || put_user_id(high2lowgid(egid), arg2)\n\n                    || put_user_id(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2)) {\n\n                    goto efault;\n\n                }\n\n                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr(cpu_env, fpcr);\n\n\n            }\n\n            break;\n\n\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t exc, fpcr, orig_fpcr;\n\n                int si_code;\n\n\n\n                if (get_user_u64(exc, arg2)) {\n\n                    goto efault;\n\n                }\n\n\n\n                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n\n\n\n                /* We only add to the exception status here.  */\n\n                fpcr = orig_fpcr | ((exc & SWCR_STATUS_MASK) << 35);\n\n\n\n                cpu_alpha_store_fpcr(cpu_env, fpcr);\n\n\n\n\n                /* Old exceptions are not signaled.  */\n\n                fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                /* If any exceptions set by this call,\n\n                   and are unmasked, send a signal.  */\n\n                si_code = 0;\n\n                if ((fpcr & (FPCR_INE | FPCR_INED)) == FPCR_INE) {\n\n                    si_code = TARGET_FPE_FLTRES;\n\n                }\n\n                if ((fpcr & (FPCR_UNF | FPCR_UNFD)) == FPCR_UNF) {\n\n                    si_code = TARGET_FPE_FLTUND;\n\n                }\n\n                if ((fpcr & (FPCR_OVF | FPCR_OVFD)) == FPCR_OVF) {\n\n                    si_code = TARGET_FPE_FLTOVF;\n\n                }\n\n                if ((fpcr & (FPCR_DZE | FPCR_DZED)) == FPCR_DZE) {\n\n                    si_code = TARGET_FPE_FLTDIV;\n\n                }\n\n                if ((fpcr & (FPCR_INV | FPCR_INVD)) == FPCR_INV) {\n\n                    si_code = TARGET_FPE_FLTINV;\n\n                }\n\n                if (si_code != 0) {\n\n                    target_siginfo_t info;\n\n                    info.si_signo = SIGFPE;\n\n                    info.si_errno = 0;\n\n                    info.si_code = si_code;\n\n                    info._sifields._sigfault._addr\n\n                        = ((CPUArchState *)cpu_env)->pc;\n\n                    queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(how, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private file-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n        if (cmd == -TARGET_EINVAL) {\n\n            ret = cmd;\n\n            break;\n\n        }\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n        if (regpairs_aligned(cpu_env)) {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef CONFIG_ATTR\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    {\n\n        void *p, *b = 0;\n\n        if (arg2) {\n\n            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!b) {\n\n                ret = -TARGET_EFAULT;\n\n                break;\n\n            }\n\n        }\n\n        p = lock_user_string(arg1);\n\n        if (p) {\n\n            if (num == TARGET_NR_listxattr) {\n\n                ret = get_errno(listxattr(p, b, arg3));\n\n            } else {\n\n                ret = get_errno(llistxattr(p, b, arg3));\n\n            }\n\n        } else {\n\n            ret = -TARGET_EFAULT;\n\n        }\n\n        unlock_user(p, arg1, 0);\n\n        unlock_user(b, arg2, arg3);\n\n        break;\n\n    }\n\n    case TARGET_NR_flistxattr:\n\n    {\n\n        void *b = 0;\n\n        if (arg2) {\n\n            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!b) {\n\n                ret = -TARGET_EFAULT;\n\n                break;\n\n            }\n\n        }\n\n        ret = get_errno(flistxattr(arg1, b, arg3));\n\n        unlock_user(b, arg2, arg3);\n\n        break;\n\n    }\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n        {\n\n            void *p, *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_READ, arg3, arg4, 1);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_setxattr) {\n\n                    ret = get_errno(setxattr(p, n, v, arg4, arg5));\n\n                } else {\n\n                    ret = get_errno(lsetxattr(p, n, v, arg4, arg5));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_fsetxattr:\n\n        {\n\n            void *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_READ, arg3, arg4, 1);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fsetxattr(arg1, n, v, arg4, arg5));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n        {\n\n            void *p, *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_getxattr) {\n\n                    ret = get_errno(getxattr(p, n, v, arg4));\n\n                } else {\n\n                    ret = get_errno(lgetxattr(p, n, v, arg4));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, arg4);\n\n        }\n\n        break;\n\n    case TARGET_NR_fgetxattr:\n\n        {\n\n            void *n, *v = 0;\n\n            if (arg3) {\n\n                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n                if (!v) {\n\n                    ret = -TARGET_EFAULT;\n\n                    break;\n\n                }\n\n            }\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fgetxattr(arg1, n, v, arg4));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n            unlock_user(v, arg3, arg4);\n\n        }\n\n        break;\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n        {\n\n            void *p, *n;\n\n            p = lock_user_string(arg1);\n\n            n = lock_user_string(arg2);\n\n            if (p && n) {\n\n                if (num == TARGET_NR_removexattr) {\n\n                    ret = get_errno(removexattr(p, n));\n\n                } else {\n\n                    ret = get_errno(lremovexattr(p, n));\n\n                }\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(p, arg1, 0);\n\n            unlock_user(n, arg2, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_fremovexattr:\n\n        {\n\n            void *n;\n\n            n = lock_user_string(arg2);\n\n            if (n) {\n\n                ret = get_errno(fremovexattr(arg1, n));\n\n            } else {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n            unlock_user(n, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_ATTR */\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#elif defined(TARGET_M68K)\n\n      {\n\n          TaskState *ts = cpu->opaque;\n\n          ts->tp_value = arg1;\n\n\n          break;\n\n      }\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n        break;\n\n#elif defined(TARGET_M68K)\n\n        {\n\n            TaskState *ts = cpu->opaque;\n\n            ret = ts->tp_value;\n\n            break;\n\n        }\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n    case TARGET_NR_get_robust_list:\n\n        /* The ABI for supporting robust futexes has userspace pass\n\n         * the kernel a pointer to a linked list which is updated by\n\n         * userspace after the syscall; the list is walked by the kernel\n\n         * when the thread exits. Since the linked list in QEMU guest\n\n         * memory isn't a valid linked list for the host and we have\n\n         * no way to reliably intercept the thread-death event, we can't\n\n         * support these. Silently return ENOSYS so that guest userspace\n\n         * falls back to a non-robust futex implementation (which should\n\n         * be OK except in the corner case of the guest crashing while\n\n         * holding a mutex that is shared with another process via\n\n         * shared memory).\n\n         */\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#ifdef CONFIG_INOTIFY1\n\n#if defined(TARGET_NR_inotify_init1) && defined(__NR_inotify_init1)\n\n    case TARGET_NR_inotify_init1:\n\n        ret = get_errno(sys_inotify_init1(arg1));\n\n        break;\n\n#endif\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            struct iovec *vec = lock_iovec(VERIFY_READ, arg2, arg3, 1);\n\n            if (vec != NULL) {\n\n                ret = get_errno(vmsplice(arg1, vec, arg3, arg4));\n\n                unlock_iovec(vec, arg2, arg3, 0);\n\n            } else {\n\n                ret = -host_to_target_errno(errno);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n    {\n\n        int host_flags = arg2 & (~(TARGET_O_NONBLOCK | TARGET_O_CLOEXEC));\n\n        if (arg2 & TARGET_O_NONBLOCK) {\n\n            host_flags |= O_NONBLOCK;\n\n        }\n\n        if (arg2 & TARGET_O_CLOEXEC) {\n\n            host_flags |= O_CLOEXEC;\n\n        }\n\n        ret = get_errno(eventfd(arg1, host_flags));\n\n        break;\n\n    }\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n#if TARGET_ABI_BITS == 32\n\n        ret = get_errno(fallocate(arg1, arg2, target_offset64(arg3, arg4),\n\n                                  target_offset64(arg5, arg6)));\n\n#else\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n#endif\n\n        break;\n\n#endif\n\n#if defined(CONFIG_SYNC_FILE_RANGE)\n\n#if defined(TARGET_NR_sync_file_range)\n\n    case TARGET_NR_sync_file_range:\n\n#if TARGET_ABI_BITS == 32\n\n#if defined(TARGET_MIPS)\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n\n                                        target_offset64(arg5, arg6), arg7));\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg2, arg3),\n\n                                        target_offset64(arg4, arg5), arg6));\n\n#endif /* !TARGET_MIPS */\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, arg2, arg3, arg4));\n\n#endif\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_sync_file_range2)\n\n    case TARGET_NR_sync_file_range2:\n\n        /* This is like sync_file_range but the arguments are reordered */\n\n#if TARGET_ABI_BITS == 32\n\n        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n\n                                        target_offset64(arg5, arg6), arg2));\n\n#else\n\n        ret = get_errno(sync_file_range(arg1, arg3, arg4, arg2));\n\n#endif\n\n        break;\n\n#endif\n\n#endif\n\n#if defined(CONFIG_EPOLL)\n\n#if defined(TARGET_NR_epoll_create)\n\n    case TARGET_NR_epoll_create:\n\n        ret = get_errno(epoll_create(arg1));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_epoll_create1) && defined(CONFIG_EPOLL_CREATE1)\n\n    case TARGET_NR_epoll_create1:\n\n        ret = get_errno(epoll_create1(arg1));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_epoll_ctl)\n\n    case TARGET_NR_epoll_ctl:\n\n    {\n\n        struct epoll_event ep;\n\n        struct epoll_event *epp = 0;\n\n        if (arg4) {\n\n            struct target_epoll_event *target_ep;\n\n            if (!lock_user_struct(VERIFY_READ, target_ep, arg4, 1)) {\n\n                goto efault;\n\n            }\n\n            ep.events = tswap32(target_ep->events);\n\n            /* The epoll_data_t union is just opaque data to the kernel,\n\n             * so we transfer all 64 bits across and need not worry what\n\n             * actual data type it is.\n\n             */\n\n            ep.data.u64 = tswap64(target_ep->data.u64);\n\n            unlock_user_struct(target_ep, arg4, 0);\n\n            epp = &ep;\n\n        }\n\n        ret = get_errno(epoll_ctl(arg1, arg2, arg3, epp));\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_epoll_pwait) && defined(CONFIG_EPOLL_PWAIT)\n\n#define IMPLEMENT_EPOLL_PWAIT\n\n#endif\n\n#if defined(TARGET_NR_epoll_wait) || defined(IMPLEMENT_EPOLL_PWAIT)\n\n#if defined(TARGET_NR_epoll_wait)\n\n    case TARGET_NR_epoll_wait:\n\n#endif\n\n#if defined(IMPLEMENT_EPOLL_PWAIT)\n\n    case TARGET_NR_epoll_pwait:\n\n#endif\n\n    {\n\n        struct target_epoll_event *target_ep;\n\n        struct epoll_event *ep;\n\n        int epfd = arg1;\n\n        int maxevents = arg3;\n\n        int timeout = arg4;\n\n\n\n        target_ep = lock_user(VERIFY_WRITE, arg2,\n\n                              maxevents * sizeof(struct target_epoll_event), 1);\n\n        if (!target_ep) {\n\n            goto efault;\n\n        }\n\n\n\n        ep = alloca(maxevents * sizeof(struct epoll_event));\n\n\n\n        switch (num) {\n\n#if defined(IMPLEMENT_EPOLL_PWAIT)\n\n        case TARGET_NR_epoll_pwait:\n\n        {\n\n            target_sigset_t *target_set;\n\n            sigset_t _set, *set = &_set;\n\n\n\n            if (arg5) {\n\n                target_set = lock_user(VERIFY_READ, arg5,\n\n                                       sizeof(target_sigset_t), 1);\n\n                if (!target_set) {\n\n                    unlock_user(target_ep, arg2, 0);\n\n                    goto efault;\n\n                }\n\n                target_to_host_sigset(set, target_set);\n\n                unlock_user(target_set, arg5, 0);\n\n            } else {\n\n                set = NULL;\n\n            }\n\n\n\n            ret = get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set));\n\n            break;\n\n        }\n\n#endif\n\n#if defined(TARGET_NR_epoll_wait)\n\n        case TARGET_NR_epoll_wait:\n\n            ret = get_errno(epoll_wait(epfd, ep, maxevents, timeout));\n\n            break;\n\n#endif\n\n        default:\n\n            ret = -TARGET_ENOSYS;\n\n        }\n\n        if (!is_error(ret)) {\n\n            int i;\n\n            for (i = 0; i < ret; i++) {\n\n                target_ep[i].events = tswap32(ep[i].events);\n\n                target_ep[i].data.u64 = tswap64(ep[i].data.u64);\n\n            }\n\n        }\n\n        unlock_user(target_ep, arg2, ret * sizeof(struct target_epoll_event));\n\n        break;\n\n    }\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_prlimit64\n\n    case TARGET_NR_prlimit64:\n\n    {\n\n        /* args: pid, resource number, ptr to new rlimit, ptr to old rlimit */\n\n        struct target_rlimit64 *target_rnew, *target_rold;\n\n        struct host_rlimit64 rnew, rold, *rnewp = 0;\n\n        if (arg3) {\n\n            if (!lock_user_struct(VERIFY_READ, target_rnew, arg3, 1)) {\n\n                goto efault;\n\n            }\n\n            rnew.rlim_cur = tswap64(target_rnew->rlim_cur);\n\n            rnew.rlim_max = tswap64(target_rnew->rlim_max);\n\n            unlock_user_struct(target_rnew, arg3, 0);\n\n            rnewp = &rnew;\n\n        }\n\n\n\n        ret = get_errno(sys_prlimit64(arg1, arg2, rnewp, arg4 ? &rold : 0));\n\n        if (!is_error(ret) && arg4) {\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rold, arg4, 1)) {\n\n                goto efault;\n\n            }\n\n            target_rold->rlim_cur = tswap64(rold.rlim_cur);\n\n            target_rold->rlim_max = tswap64(rold.rlim_max);\n\n            unlock_user_struct(target_rold, arg4, 1);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_gethostname\n\n    case TARGET_NR_gethostname:\n\n    {\n\n        char *name = lock_user(VERIFY_WRITE, arg1, arg2, 0);\n\n        if (name) {\n\n            ret = get_errno(gethostname(name, arg2));\n\n            unlock_user(name, arg1, arg2);\n\n        } else {\n\n            ret = -TARGET_EFAULT;\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_atomic_cmpxchg_32\n\n    case TARGET_NR_atomic_cmpxchg_32:\n\n    {\n\n        /* should use start_exclusive from main.c */\n\n        abi_ulong mem_value;\n\n        if (get_user_u32(mem_value, arg6)) {\n\n            target_siginfo_t info;\n\n            info.si_signo = SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = arg6;\n\n            queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);\n\n            ret = 0xdeadbeef;\n\n\n\n        }\n\n        if (mem_value == arg2)\n\n            put_user_u32(arg1, arg6);\n\n        ret = mem_value;\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_atomic_barrier\n\n    case TARGET_NR_atomic_barrier:\n\n    {\n\n        /* Like the kernel implementation and the qemu arm barrier, no-op this? */\n\n\n        break;\n\n    }\n\n#endif\n\n\n\n#ifdef TARGET_NR_timer_create\n\n    case TARGET_NR_timer_create:\n\n    {\n\n        /* args: clockid_t clockid, struct sigevent *sevp, timer_t *timerid */\n\n\n\n        struct sigevent host_sevp = { {0}, }, *phost_sevp = NULL;\n\n        struct target_sigevent *ptarget_sevp;\n\n        struct target_timer_t *ptarget_timer;\n\n\n\n        int clkid = arg1;\n\n        int timer_index = next_free_host_timer();\n\n\n\n        if (timer_index < 0) {\n\n            ret = -TARGET_EAGAIN;\n\n        } else {\n\n            timer_t *phtimer = g_posix_timers  + timer_index;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, ptarget_sevp, arg2, 1)) {\n\n                    goto efault;\n\n                }\n\n\n\n                host_sevp.sigev_signo = tswap32(ptarget_sevp->sigev_signo);\n\n                host_sevp.sigev_notify = tswap32(ptarget_sevp->sigev_notify);\n\n\n\n                phost_sevp = &host_sevp;\n\n            }\n\n\n\n            ret = get_errno(timer_create(clkid, phost_sevp, phtimer));\n\n            if (ret) {\n\n                phtimer = NULL;\n\n            } else {\n\n                if (!lock_user_struct(VERIFY_WRITE, ptarget_timer, arg3, 1)) {\n\n                    goto efault;\n\n                }\n\n                ptarget_timer->ptr = tswap32(0xcafe0000 | timer_index);\n\n                unlock_user_struct(ptarget_timer, arg3, 1);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n#ifdef TARGET_NR_timer_settime\n\n    case TARGET_NR_timer_settime:\n\n    {\n\n        /* args: timer_t timerid, int flags, const struct itimerspec *new_value,\n\n         * struct itimerspec * old_value */\n\n        arg1 &= 0xffff;\n\n        if (arg3 == 0 || arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {\n\n            ret = -TARGET_EINVAL;\n\n        } else {\n\n            timer_t htimer = g_posix_timers[arg1];\n\n            struct itimerspec hspec_new = {{0},}, hspec_old = {{0},};\n\n\n\n            target_to_host_itimerspec(&hspec_new, arg3);\n\n            ret = get_errno(\n\n                          timer_settime(htimer, arg2, &hspec_new, &hspec_old));\n\n            host_to_target_itimerspec(arg2, &hspec_old);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n#ifdef TARGET_NR_timer_gettime\n\n    case TARGET_NR_timer_gettime:\n\n    {\n\n        /* args: timer_t timerid, struct itimerspec *curr_value */\n\n        arg1 &= 0xffff;\n\n        if (!arg2) {\n\n            return -TARGET_EFAULT;\n\n        } else if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {\n\n            ret = -TARGET_EINVAL;\n\n        } else {\n\n            timer_t htimer = g_posix_timers[arg1];\n\n            struct itimerspec hspec;\n\n            ret = get_errno(timer_gettime(htimer, &hspec));\n\n\n\n            if (host_to_target_itimerspec(arg2, &hspec)) {\n\n                ret = -TARGET_EFAULT;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n#ifdef TARGET_NR_timer_getoverrun\n\n    case TARGET_NR_timer_getoverrun:\n\n    {\n\n        /* args: timer_t timerid */\n\n        arg1 &= 0xffff;\n\n        if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {\n\n            ret = -TARGET_EINVAL;\n\n        } else {\n\n            timer_t htimer = g_posix_timers[arg1];\n\n            ret = get_errno(timer_getoverrun(htimer));\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n#ifdef TARGET_NR_timer_delete\n\n    case TARGET_NR_timer_delete:\n\n    {\n\n        /* args: timer_t timerid */\n\n        arg1 &= 0xffff;\n\n        if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {\n\n            ret = -TARGET_EINVAL;\n\n        } else {\n\n            timer_t htimer = g_posix_timers[arg1];\n\n            ret = get_errno(timer_delete(htimer));\n\n            g_posix_timers[arg1] = 0;\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}", "idx": 960}
{"project": "FFmpeg", "commit_id": "7ebdffc353f3f0827864e8e3461fdc00cc243b14", "target": 1, "func": "static int dxv_decompress_dxt1(AVCodecContext *avctx)\n\n{\n\n    DXVContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    uint32_t value, prev, op;\n\n    int idx = 0, state = 0;\n\n    int pos = 2;\n\n\n\n    /* Copy the first two elements */\n\n    AV_WL32(ctx->tex_data, bytestream2_get_le32(gbc));\n\n    AV_WL32(ctx->tex_data + 4, bytestream2_get_le32(gbc));\n\n\n\n    /* Process input until the whole texture has been filled */\n\n    while (pos < ctx->tex_size / 4) {\n\n        CHECKPOINT(2);\n\n\n\n        /* Copy two elements from a previous offset or from the input buffer */\n\n        if (op) {\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n        } else {\n\n            CHECKPOINT(2);\n\n\n\n            if (op)\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            else\n\n                prev = bytestream2_get_le32(gbc);\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n\n\n            CHECKPOINT(2);\n\n\n\n            if (op)\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n\n            else\n\n                prev = bytestream2_get_le32(gbc);\n\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n\n            pos++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 962}
{"project": "FFmpeg", "commit_id": "5d171b1f4718ae2916dfddc35299ccdef1e3001c", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *data_size,\n\n                        AVPacket *avpkt)\n\n{\n\n    JvContext *s           = avctx->priv_data;\n\n    const uint8_t *buf     = avpkt->data;\n\n    const uint8_t *buf_end = buf + avpkt->size;\n\n    int video_size, video_type, i, j;\n\n\n\n    video_size = AV_RL32(buf);\n\n    video_type = buf[4];\n\n    buf += 5;\n\n\n\n    if (video_size) {\n\n        if (video_size < 0 || video_size > avpkt->size - 5) {\n\n            av_log(avctx, AV_LOG_ERROR, \"video size %d invalid\\n\", video_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (avctx->reget_buffer(avctx, &s->frame) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if (video_type == 0 || video_type == 1) {\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, 8 * video_size);\n\n\n\n            for (j = 0; j < avctx->height; j += 8)\n\n                for (i = 0; i < avctx->width; i += 8)\n\n                    decode8x8(&gb, s->frame.data[0] + j*s->frame.linesize[0] + i,\n\n                              s->frame.linesize[0], &s->dsp);\n\n\n\n            buf += video_size;\n\n        } else if (video_type == 2) {\n\n            if (buf + 1 <= buf_end) {\n\n                int v = *buf++;\n\n                for (j = 0; j < avctx->height; j++)\n\n                    memset(s->frame.data[0] + j*s->frame.linesize[0], v, avctx->width);\n\n            }\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"unsupported frame type %i\\n\", video_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (buf_end - buf >= AVPALETTE_COUNT * 3) {\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            uint32_t pal = AV_RB24(buf);\n\n            s->palette[i] = 0xFF << 24 | pal << 2 | ((pal >> 4) & 0x30303);\n\n            buf += 3;\n\n        }\n\n        s->palette_has_changed = 1;\n\n    }\n\n\n\n    if (video_size) {\n\n        s->frame.key_frame           = 1;\n\n        s->frame.pict_type           = AV_PICTURE_TYPE_I;\n\n        s->frame.palette_has_changed = s->palette_has_changed;\n\n        s->palette_has_changed       = 0;\n\n        memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n\n\n        *data_size      = sizeof(AVFrame);\n\n        *(AVFrame*)data = s->frame;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 964}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int asv_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 965}
{"project": "qemu", "commit_id": "6df5718bd3ec56225c44cf96440c723c1b611b87", "target": 1, "func": "static void megasas_reset_frames(MegasasState *s)\n\n{\n\n    PCIDevice *pcid = PCI_DEVICE(s);\n\n    int i;\n\n    MegasasCmd *cmd;\n\n\n\n    for (i = 0; i < s->fw_cmds; i++) {\n\n        cmd = &s->frames[i];\n\n        if (cmd->pa) {\n\n            pci_dma_unmap(pcid, cmd->frame, cmd->pa_size, 0, 0);\n\n            cmd->frame = NULL;\n\n            cmd->pa = 0;\n\n        }\n\n    }\n\n}\n", "idx": 966}
{"project": "qemu", "commit_id": "0ed39f3df2d3cf7f0fc3468b057f952a3b251ad9", "target": 1, "func": "void aio_set_fd_handler(AioContext *ctx,\n\n                        int fd,\n\n                        bool is_external,\n\n                        IOHandler *io_read,\n\n                        IOHandler *io_write,\n\n                        void *opaque)\n\n{\n\n    AioHandler *node;\n\n    bool is_new = false;\n\n\n\n    node = find_aio_handler(ctx, fd);\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_read && !io_write) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_new0(AioHandler, 1);\n\n            node->pfd.fd = fd;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n            is_new = true;\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_read = io_read;\n\n        node->io_write = io_write;\n\n        node->opaque = opaque;\n\n        node->is_external = is_external;\n\n\n\n        node->pfd.events = (io_read ? G_IO_IN | G_IO_HUP | G_IO_ERR : 0);\n\n        node->pfd.events |= (io_write ? G_IO_OUT | G_IO_ERR : 0);\n\n    }\n\n\n\n    aio_epoll_update(ctx, node, is_new);\n\n    aio_notify(ctx);\n\n}\n", "idx": 967}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long hbitmap_iter_skip_words(HBitmapIter *hbi)\n\n{\n\n    size_t pos = hbi->pos;\n\n    const HBitmap *hb = hbi->hb;\n\n    unsigned i = HBITMAP_LEVELS - 1;\n\n\n\n    unsigned long cur;\n\n    do {\n\n        cur = hbi->cur[--i];\n\n        pos >>= BITS_PER_LEVEL;\n\n    } while (cur == 0);\n\n\n\n    /* Check for end of iteration.  We always use fewer than BITS_PER_LONG\n\n     * bits in the level 0 bitmap; thus we can repurpose the most significant\n\n     * bit as a sentinel.  The sentinel is set in hbitmap_alloc and ensures\n\n     * that the above loop ends even without an explicit check on i.\n\n     */\n\n\n\n    if (i == 0 && cur == (1UL << (BITS_PER_LONG - 1))) {\n\n        return 0;\n\n    }\n\n    for (; i < HBITMAP_LEVELS - 1; i++) {\n\n        /* Shift back pos to the left, matching the right shifts above.\n\n         * The index of this word's least significant set bit provides\n\n         * the low-order bits.\n\n         */\n\n        pos = (pos << BITS_PER_LEVEL) + ffsl(cur) - 1;\n\n        hbi->cur[i] = cur & (cur - 1);\n\n\n\n        /* Set up next level for iteration.  */\n\n        cur = hb->levels[i + 1][pos];\n\n    }\n\n\n\n    hbi->pos = pos;\n\n    trace_hbitmap_iter_skip_words(hbi->hb, hbi, pos, cur);\n\n\n\n    assert(cur);\n\n    return cur;\n\n}\n", "idx": 968}
{"project": "qemu", "commit_id": "45fe15c25a5c9feea6e0f78434f5e9f632de9d94", "target": 1, "func": "static int intel_hda_exit(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n\n\n    if (d->msi) {\n\n        msi_uninit(&d->pci);\n\n    }\n\n    cpu_unregister_io_memory(d->mmio_addr);\n\n    return 0;\n\n}\n", "idx": 969}
{"project": "FFmpeg", "commit_id": "709746b6affb5c87aee0c3b8ddb0a078453c6162", "target": 1, "func": "static int compand_nodelay(AVFilterContext *ctx, AVFrame *frame)\n\n{\n\n    CompandContext *s = ctx->priv;\n\n    AVFilterLink *inlink = ctx->inputs[0];\n\n    const int channels = inlink->channels;\n\n    const int nb_samples = frame->nb_samples;\n\n    AVFrame *out_frame;\n\n    int chan, i;\n\n\n\n    if (av_frame_is_writable(frame)) {\n\n        out_frame = frame;\n\n    } else {\n\n        out_frame = ff_get_audio_buffer(inlink, nb_samples);\n\n        if (!out_frame)\n\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(out_frame, frame);\n\n    }\n\n\n\n    for (chan = 0; chan < channels; chan++) {\n\n        const double *src = (double *)frame->extended_data[chan];\n\n        double *dst = (double *)out_frame->extended_data[chan];\n\n        ChanParam *cp = &s->channels[chan];\n\n\n\n        for (i = 0; i < nb_samples; i++) {\n\n            update_volume(cp, fabs(src[i]));\n\n\n\n            dst[i] = av_clipd(src[i] * get_volume(s, cp->volume), -1, 1);\n\n        }\n\n    }\n\n\n\n    if (frame != out_frame)\n\n        av_frame_free(&frame);\n\n\n\n    return ff_filter_frame(ctx->outputs[0], out_frame);\n\n}\n", "idx": 970}
{"project": "qemu", "commit_id": "c6dc3dd72b747a057770087998a1f9ef0b3f1882", "target": 1, "func": "static void pfpu_start(MilkymistPFPUState *s)\n\n{\n\n    int x, y;\n\n    int i;\n\n\n\n    for (y = 0; y <= s->regs[R_VMESHLAST]; y++) {\n\n        for (x = 0; x <= s->regs[R_HMESHLAST]; x++) {\n\n            D_EXEC(qemu_log(\"\\nprocessing x=%d y=%d\\n\", x, y));\n\n\n\n            /* set current position */\n\n            s->gp_regs[GPR_X] = x;\n\n            s->gp_regs[GPR_Y] = y;\n\n\n\n            /* run microcode on this position */\n\n            i = 0;\n\n            while (pfpu_decode_insn(s)) {\n\n                /* decode at most MICROCODE_WORDS instructions */\n\n                if (i++ >= MICROCODE_WORDS) {\n\n                    error_report(\"milkymist_pfpu: too many instructions \"\n\n                            \"executed in microcode. No VECTOUT?\");\n\n                    break;\n\n                }\n\n            }\n\n\n\n            /* reset pc for next run */\n\n            s->regs[R_PC] = 0;\n\n        }\n\n    }\n\n\n\n    s->regs[R_VERTICES] = x * y;\n\n\n\n    trace_milkymist_pfpu_pulse_irq();\n\n    qemu_irq_pulse(s->irq);\n\n}\n", "idx": 972}
{"project": "FFmpeg", "commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582", "target": 1, "func": "av_cold void ff_vp9dsp_init(VP9DSPContext *dsp, int bpp)\n\n{\n\n    if (bpp == 8) {\n\n        ff_vp9dsp_init_8(dsp);\n\n    } else if (bpp == 10) {\n\n        ff_vp9dsp_init_10(dsp);\n\n    } else {\n\n        av_assert0(bpp == 12);\n\n        ff_vp9dsp_init_12(dsp);\n\n    }\n\n\n\n    if (ARCH_X86) ff_vp9dsp_init_x86(dsp, bpp);\n\n    if (ARCH_MIPS) ff_vp9dsp_init_mips(dsp, bpp);\n\n}\n", "idx": 973}
{"project": "FFmpeg", "commit_id": "fd6e513ee1dc13174256de8adaeeb2c2691eee95", "target": 1, "func": "static int mov_read_mdhd(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    print_atom(\"mdhd\", atom);\n\n\n\n    get_byte(pb); /* version */\n\n\n\n    get_byte(pb); get_byte(pb);\n\n    get_byte(pb); /* flags */\n\n\n\n    get_be32(pb); /* creation time */\n\n    get_be32(pb); /* modification time */\n\n\n\n    c->streams[c->total_streams]->time_scale = get_be32(pb);\n\n\n\n#ifdef DEBUG\n\n    printf(\"track[%i].time_scale = %i\\n\", c->fc->nb_streams-1, c->streams[c->total_streams]->time_scale); /* time scale */\n\n#endif\n\n    get_be32(pb); /* duration */\n\n\n\n    get_be16(pb); /* language */\n\n    get_be16(pb); /* quality */\n\n\n\n    return 0;\n\n}\n", "idx": 974}
{"project": "FFmpeg", "commit_id": "a7494872d5a673f064b0570f4359c8d1a3ea1051", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,\n\n    int width, int height, int src_stride, int stride)\n\n{\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    const int lambda= (s->picture.quality*s->picture.quality) >> (2*FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width = (width + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if(s->picture.pict_type == FF_P_TYPE){\n\n        s->m.avctx= s->avctx;\n\n        s->m.current_picture_ptr= &s->m.current_picture;\n\n        s->m.last_picture_ptr   = &s->m.last_picture;\n\n        s->m.last_picture.data[0]= ref_plane;\n\n        s->m.linesize=\n\n        s->m.last_picture.linesize[0]=\n\n        s->m.new_picture.linesize[0]=\n\n        s->m.current_picture.linesize[0]= stride;\n\n        s->m.width= width;\n\n        s->m.height= height;\n\n        s->m.mb_width= block_width;\n\n        s->m.mb_height= block_height;\n\n        s->m.mb_stride= s->m.mb_width+1;\n\n        s->m.b8_stride= 2*s->m.mb_width+1;\n\n        s->m.f_code=1;\n\n        s->m.pict_type= s->picture.pict_type;\n\n        s->m.me_method= s->avctx->me_method;\n\n        s->m.me.scene_change_score=0;\n\n        s->m.flags= s->avctx->flags;\n\n//        s->m.out_format = FMT_H263;\n\n//        s->m.unrestricted_mv= 1;\n\n\n\n        s->m.lambda= s->picture.quality;\n\n        s->m.qscale= (s->m.lambda*139 + FF_LAMBDA_SCALE*64) >> (FF_LAMBDA_SHIFT + 7);\n\n        s->m.lambda2= (s->m.lambda*s->m.lambda + FF_LAMBDA_SCALE/2) >> FF_LAMBDA_SHIFT;\n\n\n\n        if(!s->motion_val8[plane]){\n\n            s->motion_val8 [plane]= av_mallocz((s->m.b8_stride*block_height*2 + 2)*2*sizeof(int16_t));\n\n            s->motion_val16[plane]= av_mallocz((s->m.mb_stride*(block_height + 2) + 1)*2*sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type= s->mb_type;\n\n\n\n        //dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean=   (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var=    (uint16_t*)s->dummy;\n\n        s->m.current_picture.mc_mb_var= (uint16_t*)s->dummy;\n\n        s->m.current_picture.mb_type= s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]= s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table= s->motion_val16[plane] + s->m.mb_stride + 1;\n\n        s->m.dsp= s->dsp; //move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size= s->avctx->dia_size;\n\n        s->m.first_slice_line=1;\n\n        for (y = 0; y < block_height; y++) {\n\n            uint8_t src[stride*16];\n\n\n\n            s->m.new_picture.data[0]= src - y*16*stride; //ugly\n\n            s->m.mb_y= y;\n\n\n\n            for(i=0; i<16 && i + 16*y<height; i++){\n\n                memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n\n                for(x=width; x<16*block_width; x++)\n\n                    src[i*stride+x]= src[i*stride+x-1];\n\n            }\n\n            for(; i<16 && i + 16*y<16*block_height; i++)\n\n                memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x= x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line=0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line=1;\n\n    for (y = 0; y < block_height; y++) {\n\n        uint8_t src[stride*16];\n\n\n\n        for(i=0; i<16 && i + 16*y<height; i++){\n\n            memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n\n            for(x=width; x<16*block_width; x++)\n\n                src[i*stride+x]= src[i*stride+x-1];\n\n        }\n\n        for(; i<16 && i + 16*y<16*block_height; i++)\n\n            memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n\n\n\n        s->m.mb_y= y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7*32];\n\n            int count[3][6];\n\n            int offset = y * 16 * stride + x * 16;\n\n            uint8_t *decoded= decoded_plane + offset;\n\n            uint8_t *ref= ref_plane + offset;\n\n            int score[4]={0,0,0,0}, best;\n\n            uint8_t *temp = s->scratchbuf;\n\n\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < 3000){ //FIXME check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x= x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if(s->picture.pict_type == FF_I_TYPE || (s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTRA)){\n\n                for(i=0; i<6; i++){\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7*32);\n\n                }\n\n                if(s->picture.pict_type == FF_P_TYPE){\n\n                    const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0]= vlc[1]*lambda;\n\n                }\n\n                score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);\n\n                for(i=0; i<6; i++){\n\n                    count[0][i]= put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            }else\n\n                score[0]= INT_MAX;\n\n\n\n            best=0;\n\n\n\n            if(s->picture.pict_type == FF_P_TYPE){\n\n                const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr= h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if(s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTER){\n\n                    for(i=0; i<6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7*32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb= s->reorder_pb[5];\n\n                    mx= motion_ptr[0];\n\n                    my= motion_ptr[1];\n\n                    assert(mx>=-32 && mx<=31);\n\n                    assert(my>=-32 && my<=31);\n\n                    assert(pred_x>=-32 && pred_x<=31);\n\n                    assert(pred_y>=-32 && pred_y<=31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5]= s->m.pb;\n\n                    score[1] += lambda*put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy= (mx&1) + 2*(my&1);\n\n\n\n                    s->dsp.put_pixels_tab[0][dxy](temp+16, ref + (mx>>1) + stride*(my>>1), stride, 16);\n\n\n\n                    score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);\n\n                    best= score[1] <= score[0];\n\n\n\n                    vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);\n\n                    score[2]+= vlc[1]*lambda;\n\n                    if(score[2] < score[best] && mx==0 && my==0){\n\n                        best=2;\n\n                        s->dsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for(i=0; i<6; i++){\n\n                            count[2][i]=0;\n\n                        }\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if(best==1){\n\n                    for(i=0; i<6; i++){\n\n                        count[1][i]= put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                }else{\n\n                    motion_ptr[0                 ] = motion_ptr[1                 ]=\n\n                    motion_ptr[2                 ] = motion_ptr[3                 ]=\n\n                    motion_ptr[0+2*s->m.b8_stride] = motion_ptr[1+2*s->m.b8_stride]=\n\n                    motion_ptr[2+2*s->m.b8_stride] = motion_ptr[3+2*s->m.b8_stride]=0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for(i=5; i>=0; i--){\n\n                ff_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]);\n\n            }\n\n            if(best==0){\n\n                s->dsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n            }\n\n        }\n\n        s->m.first_slice_line=0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 975}
{"project": "qemu", "commit_id": "ebb72c9f066e5f85259e1541a6d3fb5bfd6e73ff", "target": 1, "func": "static int commit_direntries(BDRVVVFATState* s,\n\n\tint dir_index, int parent_mapping_index)\n\n{\n\n    direntry_t* direntry = array_get(&(s->directory), dir_index);\n\n    uint32_t first_cluster = dir_index == 0 ? 0 : begin_of_direntry(direntry);\n\n    mapping_t* mapping = find_mapping_for_cluster(s, first_cluster);\n\n\n\n    int factor = 0x10 * s->sectors_per_cluster;\n\n    int old_cluster_count, new_cluster_count;\n\n    int current_dir_index = mapping->info.dir.first_dir_index;\n\n    int first_dir_index = current_dir_index;\n\n    int ret, i;\n\n    uint32_t c;\n\n\n\nDLOG(fprintf(stderr, \"commit_direntries for %s, parent_mapping_index %d\\n\", mapping->path, parent_mapping_index));\n\n\n\n    assert(direntry);\n\n    assert(mapping);\n\n    assert(mapping->begin == first_cluster);\n\n    assert(mapping->info.dir.first_dir_index < s->directory.next);\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n    assert(dir_index == 0 || is_directory(direntry));\n\n\n\n    mapping->info.dir.parent_mapping_index = parent_mapping_index;\n\n\n\n    if (first_cluster == 0) {\n\n\told_cluster_count = new_cluster_count =\n\n\t    s->last_cluster_of_root_directory;\n\n    } else {\n\n\tfor (old_cluster_count = 0, c = first_cluster; !fat_eof(s, c);\n\n\t\tc = fat_get(s, c))\n\n\t    old_cluster_count++;\n\n\n\n\tfor (new_cluster_count = 0, c = first_cluster; !fat_eof(s, c);\n\n\t\tc = modified_fat_get(s, c))\n\n\t    new_cluster_count++;\n\n    }\n\n\n\n    if (new_cluster_count > old_cluster_count) {\n\n\tif (insert_direntries(s,\n\n\t\tcurrent_dir_index + factor * old_cluster_count,\n\n\t\tfactor * (new_cluster_count - old_cluster_count)) == NULL)\n\n\t    return -1;\n\n    } else if (new_cluster_count < old_cluster_count)\n\n\tremove_direntries(s,\n\n\t\tcurrent_dir_index + factor * new_cluster_count,\n\n\t\tfactor * (old_cluster_count - new_cluster_count));\n\n\n\n    for (c = first_cluster; !fat_eof(s, c); c = modified_fat_get(s, c)) {\n\n\tvoid* direntry = array_get(&(s->directory), current_dir_index);\n\n\tint ret = vvfat_read(s->bs, cluster2sector(s, c), direntry,\n\n\t\ts->sectors_per_cluster);\n\n\tif (ret)\n\n\t    return ret;\n\n\tassert(!strncmp(s->directory.pointer, \"QEMU\", 4));\n\n\tcurrent_dir_index += factor;\n\n    }\n\n\n\n    ret = commit_mappings(s, first_cluster, dir_index);\n\n    if (ret)\n\n\treturn ret;\n\n\n\n    /* recurse */\n\n    for (i = 0; i < factor * new_cluster_count; i++) {\n\n\tdirentry = array_get(&(s->directory), first_dir_index + i);\n\n\tif (is_directory(direntry) && !is_dot(direntry)) {\n\n\t    mapping = find_mapping_for_cluster(s, first_cluster);\n\n\t    assert(mapping->mode & MODE_DIRECTORY);\n\n\t    ret = commit_direntries(s, first_dir_index + i,\n\n\t\tarray_index(&(s->mapping), mapping));\n\n\t    if (ret)\n\n\t\treturn ret;\n\n\t}\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 976}
{"project": "qemu", "commit_id": "77a10d04d033484a913a5ee76eed31a9acc57bae", "target": 1, "func": "void vfio_put_group(VFIOGroup *group)\n\n{\n\n    if (!QLIST_EMPTY(&group->device_list)) {\n\n        return;\n\n    }\n\n\n\n    vfio_kvm_device_del_group(group);\n\n    vfio_disconnect_container(group);\n\n    QLIST_REMOVE(group, next);\n\n    trace_vfio_put_group(group->fd);\n\n    close(group->fd);\n\n    g_free(group);\n\n\n\n    if (QLIST_EMPTY(&vfio_group_list)) {\n\n        qemu_unregister_reset(vfio_reset_handler, NULL);\n\n    }\n\n}\n", "idx": 977}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_div (void)\n\n{\n\n    uint64_t tmp;\n\n\n\n    if (((int32_t)T0 == INT32_MIN && (int32_t)T1 == -1) || (int32_t)T1 == 0) {\n\n        T0 = (long)((-1) * (T0 >> 31));\n\n        env->spr[SPR_MQ] = 0;\n\n    } else {\n\n        tmp = ((uint64_t)T0 << 32) | env->spr[SPR_MQ];\n\n        env->spr[SPR_MQ] = tmp % T1;\n\n        T0 = tmp / (int32_t)T1;\n\n    }\n\n}\n", "idx": 978}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_chr_info(Monitor *mon)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    TAILQ_FOREACH(chr, &chardevs, next) {\n\n        monitor_printf(mon, \"%s: filename=%s\\n\", chr->label, chr->filename);\n\n    }\n\n}\n", "idx": 980}
{"project": "qemu", "commit_id": "6886b98036a8f8f5bce8b10756ce080084cef11b", "target": 0, "func": "void lm32_debug_excp_handler(CPUState *cs)\n\n{\n\n    LM32CPU *cpu = LM32_CPU(cs);\n\n    CPULM32State *env = &cpu->env;\n\n    CPUBreakpoint *bp;\n\n\n\n    if (cs->watchpoint_hit) {\n\n        if (cs->watchpoint_hit->flags & BP_CPU) {\n\n            cs->watchpoint_hit = NULL;\n\n            if (check_watchpoints(env)) {\n\n                raise_exception(env, EXCP_WATCHPOINT);\n\n            } else {\n\n                cpu_resume_from_signal(cs, NULL);\n\n            }\n\n        }\n\n    } else {\n\n        QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n            if (bp->pc == env->pc) {\n\n                if (bp->flags & BP_CPU) {\n\n                    raise_exception(env, EXCP_BREAKPOINT);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 981}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_byte(QEMUFile *f)\n\n{\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    if (f->buf_index >= f->buf_size) {\n\n        qemu_fill_buffer(f);\n\n        if (f->buf_index >= f->buf_size)\n\n            return 0;\n\n    }\n\n    return f->buf[f->buf_index++];\n\n}\n", "idx": 983}
{"project": "qemu", "commit_id": "c96c84a9ff4bc184cb1f6cc9771a550f3854ba59", "target": 0, "func": "static void parse_error(JSONParserContext *ctxt, QObject *token, const char *msg, ...)\n\n{\n\n    fprintf(stderr, \"parse error: %s\\n\", msg);\n\n}\n", "idx": 984}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void gtod_save(QEMUFile *f, void *opaque)\n\n{\n\n    uint64_t tod_low;\n\n    uint8_t tod_high;\n\n    int r;\n\n\n\n    r = s390_get_clock(&tod_high, &tod_low);\n\n    if (r) {\n\n        fprintf(stderr, \"WARNING: Unable to get guest clock for migration. \"\n\n                        \"Error code %d. Guest clock will not be migrated \"\n\n                        \"which could cause the guest to hang.\\n\", r);\n\n        qemu_put_byte(f, S390_TOD_CLOCK_VALUE_MISSING);\n\n        return;\n\n    }\n\n\n\n    qemu_put_byte(f, S390_TOD_CLOCK_VALUE_PRESENT);\n\n    qemu_put_byte(f, tod_high);\n\n    qemu_put_be64(f, tod_low);\n\n}\n", "idx": 985}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "void kvm_arch_update_guest_debug(CPUState *env, struct kvm_guest_debug *dbg)\n\n{\n\n    const uint8_t type_code[] = {\n\n        [GDB_BREAKPOINT_HW] = 0x0,\n\n        [GDB_WATCHPOINT_WRITE] = 0x1,\n\n        [GDB_WATCHPOINT_ACCESS] = 0x3\n\n    };\n\n    const uint8_t len_code[] = {\n\n        [1] = 0x0, [2] = 0x1, [4] = 0x3, [8] = 0x2\n\n    };\n\n    int n;\n\n\n\n    if (kvm_sw_breakpoints_active(env))\n\n        dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP;\n\n\n\n    if (nb_hw_breakpoint > 0) {\n\n        dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;\n\n        dbg->arch.debugreg[7] = 0x0600;\n\n        for (n = 0; n < nb_hw_breakpoint; n++) {\n\n            dbg->arch.debugreg[n] = hw_breakpoint[n].addr;\n\n            dbg->arch.debugreg[7] |= (2 << (n * 2)) |\n\n                (type_code[hw_breakpoint[n].type] << (16 + n*4)) |\n\n                ((uint32_t)len_code[hw_breakpoint[n].len] << (18 + n*4));\n\n        }\n\n    }\n\n    /* Legal xcr0 for loading */\n\n    env->xcr0 = 1;\n\n}\n", "idx": 986}
