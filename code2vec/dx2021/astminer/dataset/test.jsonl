{"project": "FFmpeg", "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065", "target": 0, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 3}
{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n", "idx": 35}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n", "idx": 149}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179}
{"project": "FFmpeg", "commit_id": "3547f8e8f8418af0c578eba0de62ecba08e460c2", "target": 0, "func": "static int rv34_decode_mv(RV34DecContext *r, int block_type)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int i, j, k, l;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int next_bt;\n\n\n\n    memset(r->dmv, 0, sizeof(r->dmv));\n\n    for(i = 0; i < num_mvs[block_type]; i++){\n\n        r->dmv[i][0] = svq3_get_se_golomb(gb);\n\n        r->dmv[i][1] = svq3_get_se_golomb(gb);\n\n    }\n\n    switch(block_type){\n\n    case RV34_MB_TYPE_INTRA:\n\n    case RV34_MB_TYPE_INTRA16x16:\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        return 0;\n\n    case RV34_MB_SKIP:\n\n        if(s->pict_type == AV_PICTURE_TYPE_P){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n            break;\n\n        }\n\n    case RV34_MB_B_DIRECT:\n\n        //surprisingly, it uses motion scheme from next reference frame\n\n        /* wait for the current mb row to be finished */\n\n        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);\n\n\n\n        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];\n\n        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        }else\n\n            for(j = 0; j < 2; j++)\n\n                for(i = 0; i < 2; i++)\n\n                    for(k = 0; k < 2; k++)\n\n                        for(l = 0; l < 2; l++)\n\n                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n\n        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC\n\n            rv34_mc_2mv(r, block_type);\n\n        else\n\n            rv34_mc_2mv_skip(r);\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        break;\n\n    case RV34_MB_P_16x16:\n\n    case RV34_MB_P_MIX16x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n        break;\n\n    case RV34_MB_B_FORWARD:\n\n    case RV34_MB_B_BACKWARD:\n\n        r->dmv[1][0] = r->dmv[0][0];\n\n        r->dmv[1][1] = r->dmv[0][1];\n\n        if(r->rv30)\n\n            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        else\n\n            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 185}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244}
{"project": "FFmpeg", "commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "target": 1, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n\n                                  CodedBitstreamUnit *unit)\n\n{\n\n    BitstreamContext bc;\n\n    int err;\n\n\n\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n\n    if (err < 0)\n\n        return err;\n\n\n\n    switch (unit->type) {\n\n    case HEVC_NAL_VPS:\n\n        {\n\n            H265RawVPS *vps;\n\n\n\n            vps = av_mallocz(sizeof(*vps));\n\n            if (!vps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_vps(ctx, vps);\n\n            if (err < 0) {\n\n                av_free(vps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = vps;\n\n        }\n\n        break;\n\n    case HEVC_NAL_SPS:\n\n        {\n\n            H265RawSPS *sps;\n\n\n\n            sps = av_mallocz(sizeof(*sps));\n\n            if (!sps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_sps(ctx, sps);\n\n            if (err < 0) {\n\n                av_free(sps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = sps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_PPS:\n\n        {\n\n            H265RawPPS *pps;\n\n\n\n            pps = av_mallocz(sizeof(*pps));\n\n            if (!pps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_pps(ctx, pps);\n\n            if (err < 0) {\n\n                av_free(pps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = pps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_TRAIL_N:\n\n    case HEVC_NAL_TRAIL_R:\n\n    case HEVC_NAL_TSA_N:\n\n    case HEVC_NAL_TSA_R:\n\n    case HEVC_NAL_STSA_N:\n\n    case HEVC_NAL_STSA_R:\n\n    case HEVC_NAL_RADL_N:\n\n    case HEVC_NAL_RADL_R:\n\n    case HEVC_NAL_RASL_N:\n\n    case HEVC_NAL_RASL_R:\n\n    case HEVC_NAL_BLA_W_LP:\n\n    case HEVC_NAL_BLA_W_RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 245}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n", "idx": 436}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474}
{"project": "FFmpeg", "commit_id": "ccc27e2139336b66cdec3bb73a2cc7e60ef7e599", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n", "idx": 677}
{"project": "FFmpeg", "commit_id": "d58a6d8537a6f34941973c5c3be93d484a4d62ed", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    FFV1Context *f = avctx->priv_data;\n\n    CABACContext * const c= &f->c;\n\n    AVFrame *pict = data;\n\n    const int width= f->width;\n\n    const int height= f->height;\n\n    AVFrame * const p= &f->picture;\n\n    int used_count= 0;\n\n\n\n    if(avctx->strict_std_compliance >= 0){\n\n        av_log(avctx, AV_LOG_ERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\"\n\n               \"use vstrict=-1 to use it anyway\\n\");\n\n        return -1;\n\n    }\n\n        \n\n    ff_init_cabac_encoder(c, buf, buf_size);\n\n    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n", "idx": 683}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941}
{"project": "FFmpeg", "commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "target": 1, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n\n                    int *seq, int flags, int64_t timestamp)\n\n{\n\n    RMDemuxContext *rm = s->priv_data;\n\n    int ret;\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        rm->current_stream= st->id;\n\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n\n        if(ret)\n\n            return ret < 0 ? ret : -1; //got partial frame or error\n\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n\n            (ast->deint_id == DEINT_ID_INT4) ||\n\n            (ast->deint_id == DEINT_ID_SIPR)) {\n\n            int x;\n\n            int sps = ast->sub_packet_size;\n\n            int cfs = ast->coded_framesize;\n\n            int h = ast->sub_packet_h;\n\n            int y = ast->sub_packet_cnt;\n\n            int w = ast->audio_framesize;\n\n\n\n            if (flags & 2)\n\n                y = ast->sub_packet_cnt = 0;\n\n            if (!y)\n\n                ast->audiotimestamp = timestamp;\n\n\n\n            switch (ast->deint_id) {\n\n                case DEINT_ID_INT4:\n\n                    for (x = 0; x < h/2; x++)\n\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n\n                    break;\n\n                case DEINT_ID_GENR:\n\n                    for (x = 0; x < w/sps; x++)\n\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n\n                    break;\n\n                case DEINT_ID_SIPR:\n\n                    avio_read(pb, ast->pkt.data + y * w, w);\n\n                    break;\n\n            }\n\n\n\n            if (++(ast->sub_packet_cnt) < h)\n\n                return -1;\n\n            if (ast->deint_id == DEINT_ID_SIPR)\n\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n\n\n             ast->sub_packet_cnt = 0;\n\n             rm->audio_stream_num = st->index;\n\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n", "idx": 944}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}", "idx": 1035}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n", "idx": 1059}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060}
